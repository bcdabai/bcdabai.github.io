<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6188d4cad0be2a292f2a5e782f24a680/" rel="bookmark">
			Mysql-- 批量插入(检测重复)返回ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题，前面写过一篇文章：MySql -- 不存在则插入，存在则更新或忽略_知难行难1985的博客-CSDN博客_mysql 如果不存在则插入
不过那篇文章依赖的是比如Primary Key或Unique Key来确定是否重复，如果没有Unique Key来确定是否重复呢？本文就来探讨一下。
1.插入单条记录 需要满足下面几个需求：
插入单条记录，依据某个或者某几个字段判断（非Unique Key），如果数据库中不存在，则插入；如果数据库中已经存在，则什么也不做（目前还没有研究更新，难度应该不大，本项目中暂时用不到）如果发生了插入操作。返回Id，赋值给被存储对象，因为业务中要用到。返回 affects rows。如果插入返回1，不插入返回0. mybatis代码：
mapper.xml:
&lt;!-- 单条插入：以多个字段为标准，如果存在，不做任何操作，如果不存在，则插入，亲测好用 --&gt; &lt;insert id="insertCheckDuplicateKeySingle" keyProperty="id" useGeneratedKeys="true"&gt; INSERT INTO e**_****_customer (customer_id, issuer_id, issuer_*****_no, province_*******_no, mobile, email, customer_type, customer_name, customer_mobile, customer_email, mail_address, credential_type, credential_no, agent_name, agent_mobile, product_code, business_code, bill_type, sign_bank, `status`, status_update_time, del_flag, create_by, create_time, update_by, update_time, remark) SELECT #{customerId}, #{issuerId}, #{issuerCustomerNo},#{provinceCustomerNo}, #{mobile}, #{email},#{customerType}, #{customerName},#{customerMobile}, #{customerEmail}, #{mailAddress}, #{credentialType}, #{credentialNo}, #{agentName}, #{agentMobile}, #{productCode}, #{businessCode}, #{billType}, #{signBank}, #{status}, #{statusUpdateTime}, #{delFlag}, #{createBy}, #{createTime},#{updateBy}, #{updateTime}, #{remark} FROM DUAL where not exists (select issuer_customer_no, del_flag, issuer_id from etc_issuer_customer where issuer_customer_no = #{issuerCustomerNo} and del_flag = 0 and issuer_id = #{issuerId}) &lt;/insert&gt; Mapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6188d4cad0be2a292f2a5e782f24a680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d48e5c9abf12c0f3a31944255188e013/" rel="bookmark">
			redhat7.6版本 安装 mysql8.0版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redhat7.6版本 安装 mysql8.0版本 首先，在VM虚拟机安装好redhat后，卸载系统自带的yum，因为redhat系统中自带yum是收费的，无法直接使用，直接使用会报错。
类似报错信息：
因此，
一、更换yun源： 1.卸载本机现有yum
（1）查看本机现有yum：
rpm -qa |grep yum （2）卸载yum
sudo rpm -e yum-langpacks-0.4.2-7.el7.noarch --nodeps sudo rpm -e yum-rhn-plugin-2.0.1-10.el7.noarch --nodeps sudo rpm -e yum-3.4.3-161.el7.noarch --nodeps sudo rpm -e yum-metadata-parser-1.1.4-10.el7.x86_64 --nodeps sudo rpm -e PackageKit-yum-1.1.10-1.el7.x86_64 --nodeps sudo rpm -e yum-utils-1.1.31-50.el7.noarch --nodeps （3）再次查看本机yum相关文件
rpm -qa |grep yum 此时应该是空的
2.安装yum
（1）下载相关包（确保虚拟机中redhat系统已经连上网，可以进百度试试能不能进去）
wget http://mirrors.163.com/centos/7/os/x86_64/Packages/rpm-4.11.3-45.el7.x86_64.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-urlgrabber-3.10-10.el7.noarch.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-168.el7.centos.noarch.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm （2）安装
sudo rpm -ivh --force rpm-4.11.3-45.el7.x86_64.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm python-urlgrabber-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d48e5c9abf12c0f3a31944255188e013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5461ea3cc5b26c4e6ad7ecae3e3362be/" rel="bookmark">
			一文带你吃透——HTML5（原来html这么简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HTML5篇表单html5自定义属性html5接口网络连接事件和网络断开事件全屏接口的使用读取文件接口拖拽事件sessinoStorage的使用localStorage的使用应用缓存机制 cache manifest文件 HTML5篇 什么是html5?
h5并不是新的语言，而是html语言第五次重大修改的版本
ie9以上主流浏览器全部支持html5增加了用户与文档的交互方式：video audio canvas新增一些特性、和语义化标签（本地存储、网页多媒体、动画、过度、2d、3d）相比h4 抛弃了一些不常用的标签和属性 新增了一系列的语义化标签和属性 html5的语义标签（没有什么不同的就是单纯的命名div）
语义标签作用nav导航标签header页眉也就是头部fotter页脚也就是是底部main文档的主要内容，也就是内容区域article内容左侧aside内容右侧 Ie8无法识别HTML5不支持语义标签
第一种方式
要通过js手动创建 并且要转成块级元素
(document.creatElement(‘header’)) display:block
第二种方式引入html5shiv.js这个插件，就可以实现ie的兼容
表单 表单TYPE属性
type=‘emali’ //邮箱对应的写法 email提供了默认的电子邮箱验证 不写好会阻断提交 type=‘tel’ //它并不是用来实现验证的，它本质是为了能够在移动端打开数字键盘，数字键盘就限制了用户只能输入数字 type=‘url’ //它只能输入合法的网址 包含http://这种的 type=‘number’ //他只能输入数字，不能输入其他的字符，可以输入小数点 ：最大值100 属性 max=‘100’ :最小值0 属性 min=‘0’ :value 属性 默认显示值 type=‘search’ //他会提供更人性化的搜索框 带x删除的那种 type=‘range’ //是一个范围文本框 提供范围的 需要设置最大值和最小值也就是 max min 默认值为中间 也可以通过默认 value修改默认值 type=‘color’ //颜色文本框，可以选取颜色 type=‘time’ //时间 时分秒 type=‘data’ //时间 年月日 type=‘datatime’ //时间 年月日时分秒 但是只有苹果浏览器支持 type=‘datatime-local’ //时间 各大浏览器支持的年月日时分秒 type=‘month’ //月份 type=‘week’ //星期 表单属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5461ea3cc5b26c4e6ad7ecae3e3362be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de7962b685ad847ca2d5efb1f6df387/" rel="bookmark">
			Vmware共享文件夹找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMWarePro16 下：首先设置好共享文件夹
但是我的依然不能使用 我的Ubuntu版本是22.04
然后执行如下命令：
sudo vmhgfs-fuse .host:/ /mnt/hgfs -o nonempty -o allow_other 报错如下：
根据提示把对应的命令删除 然后执行如下代码：
sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other 就可以共享文件了
虚拟机的共享文件夹一般是在/mnt/hgfs/下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7118edac995a70b585efcb76b72532/" rel="bookmark">
			开发者，Docker是什么能干什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词：docker 云原生 容器
前言 云原生架构离不开微服务，容器，k8s等技术的支撑，当下很火的容器 Docker 到底是什么，它又能为开发者带来哪些便利呢？
目录 前言一、Docker是什么？二、虚拟机 (Virtual Machine)三、容器(Container)四、容器 VS 虚拟机五、Docker能帮开发者做什么？5.1 更高效的利用系统资源5.2 更快的启动时间5.3 更轻松迁移5.4 一致的运行环境5.5 持续交付和部署 六、Docker 的缺点？七、写在最后 一、Docker是什么？ 口号：一次创建或配置，可以在任意地方正常运行
Docker是一个开源软件，也是一个开放平台，它用于开发应用、交付应用、运行应用。
Docker允许用户将基础设施中的应用单独分割出来，形成更小的部分容器，从而提高软件交付速度。
二、虚拟机 (Virtual Machine) 虚拟机指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，在实体计算机中能够完成的工作在虚拟机中都能够实现。
在计算机创建虚拟机时，会将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存，每个虚拟机都有独立的硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。
虚拟机会消耗大量系统资源和开销，尤其是当多个虚拟机在同一物理服务器上运行时，每个虚拟机都有自己的子操作系统，大量精力以及资源被用于虚拟化的部署和运行上。
三、容器(Container) 容器类似于虚拟机，只是容器不是完整的操作系统，容器通常只包含必要的操作系统包和应用程序。它们通常不包含完整的操作系统或硬件虚拟化，这就是它们“轻量级”的原因。
Docker 可以尽可能轻松地创建和使用容器。
四、容器 VS 虚拟机 相比之下，每个容器均共享同一主机操作系统或系统内核，非常轻巧，通常只有数 MB ，这意味着容器可能只需几秒钟即可启动，而虚拟机则需要数 GB 和数分种。
特性容器虚拟机隔离级别进程级别操作系统级别系统资源0~5%5~15%镜像大小kb~MBGB~TB启动时间秒级分钟级集群规模上万上百高可用策略弹性，负载，动态备份，容灾，迁移 五、Docker能帮开发者做什么？ 为什么要使用Docker，它能为开发者带来哪些便利呢？
5.1 更高效的利用系统资源 Docker对系统资源的利用率更高，因为容器不用硬件虚拟以及运行完整操作系统等额外开销，无论是应用执行速度、内存损耗或者文件的存储速度，都要比传统虚拟机技术更高效，因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。
5.2 更快的启动时间 传统的虚拟机技术启动应用服务往往是分钟级别的，而Docker由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大的节约了开发、测试、部署的时间。
5.3 更轻松迁移 Docker确保了执行环境的一致性，使得应用的迁移更加容易，Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户不用担心运行环境的变化导致应用无法正常运行的情况。
5.4 一致的运行环境 开发过程中常见的问题是环境一致性问题，由于开发测试生产环境不一致，导致有些bug没能在开发过程中被发现，而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 代码在我机器上能跑，这不怪我啊 这类问题。
5.5 持续交付和部署 对开发和运维（DevOps）来说，最希望的就是一次创建或配置，可以在任意地方正常运行，使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。
……
六、Docker 的缺点？ Docker本身非常适合用于管理单个容器。但随着您开始使用越来越多的容器和容器化应用，并把它们划分成数百个部分，很可能会导致管理和编排变得非常困难。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed7118edac995a70b585efcb76b72532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53eee0f0246a9717ade53207a05c5888/" rel="bookmark">
			Axure RP9原型设计之调整元件层级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前在产品实习阶段，Axure也是完全通过自学去熟悉，关于元件层级的调整很简单，但是元件过多的时候就容易混乱，还是自己之前学习的不到位。比如我想把某一元件调整到它旁边一个元件的上方，我将它上移一层，却并没有看到相应的效果。这里做个系统的关于调整元件层级的总结。
第一步：创建四个颜色的矩形元件，并命名。 可以看到左边栏概要页面出现了我创建的四个矩形元件。
第二步：选中蓝色矩形，右击选择“顺序”选择“置于顶层”（此外还可以选择上方菜单栏的布局进行操作以及快捷操作，见下图） 之后蓝色覆盖在所有图层之上，且在概要中矩形也根据层级情况进行了自动调整。
第三步：将蓝色下移一层，（右击“顺序”，选择下移一层） 可以看到页面中的蓝色矩形在绿色矩形之下，且在另外两个矩形之上，概要中顺序也与此保持一致。
上移同理。
新发现 还有一种调整方式是我在刚在进行总结的时候发现的，更加的方便和一目了然。
如图所示，可以直接在概要中选择需要调整的元件，拖动到需要调整的位置即可。
需要说明的是，在工作中往往会涉及到很多元件，当你想把某一图层调整到另一图层之上的时候，可以想想是从底层向上移容易，还是从顶层向下移容易，这取决于所有元件的层级排列情况。如果想要通过概要进行调整，那么要注意每一个元件都要有命名才比较方便，都是默认名称则此方法不可行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e403ae977adfdd0be7df350a3fe29e/" rel="bookmark">
			缓存穿透&amp;缓存击穿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于缓存，大家肯定都不陌生，不管是前端还是服务端开发，缓存几乎都是必不可少的优化方式之一。在实际生产环境中，缓存的使用规范也是一直备受重视的，如果使用的不好，很容易就遇到缓存击穿、雪崩等严重异常情景，从而给系统带来难以预料的灾害。
为了避免缓存使用不当带来的损失，我们有必要了解每种异常产生的原因和解决办法，从而做出更好的预防措施。
缓存穿透 而缓存穿透是指缓存和数据库中都没有的数据，这样每次请求都会去查库，不会查缓存，如果同一时间有大量请求进来的话，就会给数据库造成巨大的查询压力，甚至击垮 db 系统。
比如说查询 id 为 -1 的商品，这样的 id 在商品表里肯定不存在。如果没做特殊处理的话，攻击者很容易可以让系统奔溃，那我们该如何避免这种情况发生呢？
一般来说，缓存穿透常用的解决方案大概有两种：
1.1 缓存空对象 当缓存和数据都查不到对应 key 的数据时，可以将返回的空对象写到缓存中，这样下次请求该 key 时直接从缓存中查询返回空对象，就不用走 db 了。当然，为了避免存储过多空对象，通常会给空对象设置一个比较短的过期时间，就比如像这样给 key 设置 30秒 的过期时间：
redisTemplate.opsForValue().set(key, null, 30, TimeUnit.SECONDS);
这种方法会存在两个问题：
如果有大量的 key 穿透，缓存空对象会占用宝贵的内存空间。
空对象的 key 设置了过期时间，这段时间内可能数据库刚好有了该 key 的数据，从而导致数据不一致的情况。
这种情况下，我们可以用更好的解决方案，也就是布隆过滤器
1.2 Bloom Filter 布隆过滤器(Bloom Filter)是 1970 年由一个叫布隆的小伙子提出的。是一种由一个很长的二进制向量和一系列随机映射函数构成的概率型数据结构，这种数据结构的空间效率非常高，可以用于检索集合中是否存在特定的元素。
设计思想
布隆过滤器由一个长度为 m 比特的位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。原理是当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就大约知道集合中有没有它了，也就是说，如果这些点有任何一个 0 ，则被检元素一定不在；如果都是 1 ，则被检元素很可能在。
至于说为什么都是 1 的情况只是可能存在检索元素，这是因为不同的元素计算的哈希值有可能一样，会出现哈希碰撞，导致一个不存在的元素有可能对应的比特位为 1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6e403ae977adfdd0be7df350a3fe29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c38377f31121e30c9b7d67aba3e3f332/" rel="bookmark">
			std::unique_ptr作为形参时的使用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;memory&gt; class Test { }; void dowork(std::unique_ptr&lt;Test&gt; p){ std::cout &lt;&lt; "Hello, dowork!" &lt;&lt; std::endl; } int main() { std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl; std::unique_ptr&lt;Test&gt; p(new Test()); dowork(p); return 0; } 报错：main.cpp: In function ‘int main()’:
main.cpp:18:13: error: use of deleted function ‘std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = Test; _Dp = std::default_delete&lt;Test&gt;]’
18 | dowork(p);
| ^
In file included from /usr/include/c++/9/memory:80,
from main.cpp:2:
/usr/include/c++/9/bits/unique_ptr.h:414:7: note: declared here
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c38377f31121e30c9b7d67aba3e3f332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c01aa891247f399fb38e33029396cd52/" rel="bookmark">
			05-Scss-媒体查询与Mixin的配合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编写响应式开发的过程中，常常使用媒体查询：
.header { width: 1000px; } @media screen and (min-width: 768px) { .header { width: 500px; } } 而对于多条媒体查询，这种写法显得重复率较高，而合并的写法又不利于代码的阅读，因此可以通过结合 mixin 混入的方法实现媒体查询。
@mixin ipad { @media screen and (min-width: 768px) { @content; } } 其中，@content 指明了使用mixin处传过来的代码块，使用方法如下：
.header { width: 1000px; @include ipad { width: 500px; } } width: 500px; 即实现了对 @content 的替换
同样地，根据之前的知识，mixin 可以接收参数，例如可以通过 $height 接收传过来的高度值，再赋值给内部属性。
完整代码如下：
main.scss
@mixin ipad($height) { @media screen and (min-width: 768px) { height: $height; @content; } } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c01aa891247f399fb38e33029396cd52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3e5d17724d04d89a438f26e8c4e7bf9/" rel="bookmark">
			Kubernetes监控日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes监控日志 查看资源集群状态 ``
查看master组件的状态： kubectl get cs [root@k8s-master ~]# kubectl get cs Warning: v1 ComponentStatus is deprecated in v1.19+ NAME STATUS MESSAGE ERROR scheduler Unhealthy Get "http://127.0.0.1:10251/healthz": dial tcp 127.0.0.1:10251: connect: connection refused controller-manager Unhealthy Get "http://127.0.0.1:10252/healthz": dial tcp 127.0.0.1:10252: connect: connection refused etcd-0 Healthy {"health":"true"} 查看node状态：kubectl get node [root@k8s-master ~]# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master Ready control-plane,master 130d v1.21.0 k8s-node1 Ready &lt;none&gt; 130d v1.21.0 k8s-node2 Ready &lt;none&gt; 130d v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3e5d17724d04d89a438f26e8c4e7bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f06ebc7b8cf49c0ff5ffef9b1785f1/" rel="bookmark">
			windows 下chisel的安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装java jdk的安装教程参考：
(4条消息) IntelliJ IDEA安装教程（超详细）蓝多多的小仓库的博客-CSDN博客idea安装教程
2. 安装 IntelliJ IDEA 安装教程参考：
(4条消息) IntelliJ IDEA（2020.2）的下载、安装步骤（详细讲解）Run-ning的博客-CSDN博客ideaiu安装教程
3. 环境部署 上边两者都安装成功之后， 环境部署参考：
[(4条消息) Chisel入门之路(二)之Windows+Intellij IDEA 2020.2]chisel开发环境配置董程森的博客-CSDN博客idea配置chisel环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3018a2e54d9b8c236f728872bf7f595d/" rel="bookmark">
			node_modules/canvas: Command failed 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 如果你的项目中不需要 可以到node_modules 中删除 在到package.josn 删除canvas
2:yarn 或者npm 一下 就ok 3: 根本原因还是 你项目中有些依赖用到了canvas 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550829365a050b38a838e09375040108/" rel="bookmark">
			Win10连接投影仪画面不是全屏怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		投影仪是我们经常工作的时候会使用到的东西，最近有用户在Win10系统上使用投影遇到投影仪连接电脑的时候不能全屏的显示，有时候会显示宽屏或者窄屏，不知道怎么解决，今天给大家带来了Win10投影仪的设置方法，具体的一起来看看吧。
Windows10系统 最新正式版 镜像
Win10投影仪不是全屏怎么办？
1、首先在桌面空白处点鼠标右键，选择“显示设置”。
2、然后在弹出的菜单中点击“显示适配器属性”。
3、然后点击界面中的“列出所有模式”。
4、最后重新选择一个模式就好了。
相关阅读：
按win+P可以打开投影显示设置。
可以选择模式“拓展”、“复制”、“仅第二屏幕”。
一般来说投影的时候选择“拓展”会比较好，观众不会直接看到电脑画面的内容，而是要操作者把窗口拖动到屏幕边缘移动到第二屏幕才可以被看到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c81cc3b7a27f680818f043aacd41f2f/" rel="bookmark">
			【感谢大家的支持】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来没几个粉丝，但是这寥寥无几的粉丝重新给了我信心。现在忙着写第二篇小论文，等忙完这一阵，我也会回到CSDN。或者考虑发一些视频，比如在CSDN或者b站之类。现在还有在写文章，在notion里写，等快开学的时候会把个人主页push出来和大家分享的。感谢大家的支持。
目前研一，开学研二，研究方向是多视图聚类，自监督学习。
我也是小菜鸡，希望和大家一起进步，之后会考虑出一些论文讲解，或者编程小知识的视频。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd8447f22a4b6bb7080107d98da1b51/" rel="bookmark">
			SpringSecurity前后端分离自定义登录处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringSecurity前后端分离登录处理 自定义登录成功处理（前后端分离开发）1.实现AuthenticationSucessHandler，自定义成功之后处理。2.配置AuthenticationSuccessHandler3.浏览器返回json格式数据 显示登录失败信息自定义登录失败处理注销登录 自定义登录成功处理（前后端分离开发） 有时候页面跳转并不能满足我们，特别是在前后端分离开发中就不需要成功之后跳转页面。只需要给前端返回一个JSON通知登录成功还是失败与否。这个时候可以通过自定义AuthenticationSucccessHandler 实现。
public interface AuthenticationSuccessHandler { default void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authentication) throws IOException, ServletException { this.onAuthenticationSuccess(request, response, authentication); chain.doFilter(request, response); } void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException; } 根据接口的描述信息,也可以得知登录成功会自动回调这个方法，进一步查看它的默认类实现，你会发现successForwardUrl、defaultSuccessUrl也是由它的子类实现的。
1.实现AuthenticationSucessHandler，自定义成功之后处理。 public class MyAuthenticationSuccessHandlerConfig implements AuthenticationSuccessHandler { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); result.put("msg","登录成功！"); result.put("status",200); result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecd8447f22a4b6bb7080107d98da1b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4615462a519586b49f1deb6757aef17e/" rel="bookmark">
			vue3-antd-admin开源学习-后台管理框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-admin-better是github开源admin中最优秀的集成框架之一，它是国内首个基于vue3.0的开源admin项目，同时支持电脑，手机，平板，默认分支使用vue3.x+antdv开发，master分支使用的是vue2.x+element开发。
适合人群 正在以及想使用 element-ui/element-plus 开发，前端开发经验 1 年+。熟悉 Vue.js 技术栈，使用它开发过几个实际项目。对原理技术感兴趣，想进阶和提升的同学。 特性： 支持 PC、手机端、平板；提供超过 50 余项全局精细化配置；支持后端渲染动态路由拥有完整的登录鉴权和前后端多种配置的动态路由流程支持前端控制路由权限 intelligence、后端控制路由权限 all 模式支持 mock 自动生成自动导出功能支持 scss 自动排序，eslint 自动修复支持登录 RSA 加密支持打包自动生成 7Z 压缩包以及自动化部署支持 errorlog 错误拦截支持多主题、多布局切换 开源地址：https://gitee.com/chu1204505056/vue-admin-better/tree/vue3.0-antdv/
演示地址：https://vue-admin-beautiful.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb293a565317ff0e4a015be0c771e809/" rel="bookmark">
			Linux查看文件创建时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看文件系统类型和文件所在设备 df -T . ext4开始才有创建时间的记录上面命令的“.”是文件当前目录，也可以是一个完整路径若后面的debugfs命令提示没有这个设备，可用下面指令查看所在块设备 lsblk 查看文件索引结点inode stat ./test.txt 查看创建时间 debugfs -R 'stat &lt;12&gt;' /dev/mmcblk0p12 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae3ca98522d83340598bcf4c4450a53/" rel="bookmark">
			​error: RPC failed； curl 56 OpenSSL SSL_read: Connection was reset, errno 10054”​
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git：SSL错误导致失败的解决办法 控制台的报错信息，显示“error: RPC failed; curl 56 OpenSSL SSL_read: Connection was reset, errno 10054”
进入项目的本地仓库目录下，右键Git Bash Here进入控制台，分别执行以下两个命令：
git config --global http.sslVerify "false"
git config --global credential.helper manager
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f11e226826a3266e936d64ed959c2a1/" rel="bookmark">
			单词环（图论、spfa找负环）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们有 n 个字符串，每个字符串都是由 a∼z 的小写英文字母组成的。
如果字符串 A 的结尾两个字符刚好与字符串 B 的开头两个字符相匹配，那么我们称 A 与 B 能够相连（注意：A 能与 B 相连不代表 B 能与 A 相连）。
我们希望从给定的字符串中找出一些，使得它们首尾相连形成一个环串（一个串首尾相连也算），我们想要使这个环串的平均长度最大。
如下例：
ababc
bckjaca
caahoynaab
第一个串能与第二个串相连，第二个串能与第三个串相连，第三个串能与第一个串相连，我们按照此顺序相连，便形成了一个环串，长度为 5+7+10=22（重复部分算两次），总共使用了 3 个串，所以平均长度是 22/3≈7.33。
输入格式
本题有多组数据。
每组数据的第一行，一个整数 n，表示字符串数量；
接下来 n 行，每行一个长度小于等于 1000 的字符串。
读入以 n=0 结束。
输出格式
若不存在环串，输出”No solution”，否则输出最长的环串的平均长度。
只要答案与标准答案的差不超过 0.01，就视为答案正确。
数据范围
1≤n≤10^5
输入样例：
3 intercommunicational alkylbenzenesulfonate tetraiodophenolphthalein 3 ababc bckjaca caahoynaab 2 abcd xyz 1 aba 1 aa 1 aaa 0 输出样例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f11e226826a3266e936d64ed959c2a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d7523d49f5ad0cfeb77f15c443a3f2/" rel="bookmark">
			同步FIFO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FIFO是（ first input first output）一般用作不同时钟域的缓冲器，顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加一完成，根据读和写的时钟是否为同一时钟分为同步FIFO和异步FIFO。FIFO设计的难点在于怎样判断FIFO的空/满状态。为了保证数据正确的写入或读出，而不发生益处或读空的状态出现，必须保证FIFO在满的情况下，不 能进行写操作。在空的状态下不能进行读操作。典型的同步FIFO由三部分组成： FIFO写控制逻辑：用于产生FIFO写地址、写有效信号，同时产生FIFO写满、写错等状态信号。FIFO读控制逻辑：用于产生FIFO读地址、读有效信号，同时产生FIFO读空、读错等状态信号。FIFO存储实体（memory、reg） 结构图如下：
设计主要分为以下两部分：
读写过程的地址控制 定义reg来存储FIFO写数据，读数据。FIFO写操作：写地址加一。FIFO读操作：读地址加一。 空满状态的产生
引入计数器，count计数器存储FIFO数据的的个数。 写操作：count+1。读操作 ：count-1。写满：count=fifo深度，写满为full。读空：count=0，读空为empty。 设计代码如下：
module syn_fifo ( input	clk; input	rst_n; input	wr_cs; input	wr_en; input [7:0]wr_data;	output	reg	full; input	rd_cs; input	dr_en; output [7:0]rd_data;	output	reg	empty; ); reg	[7:0]	wr_addr; reg	[7:0]	rd_addr; reg	[8:0]	count; reg	[7:0]	fifo_ram [255:0]; integer	i; //写数据 always@(posedge clk or negedge rst_n) begin if(!rst_n) begin for(i = 0; i &lt; 128;i = i + 1) fifo_ram[i] &lt;= {8{1'b0}}; end else if(wr_en&amp;&amp;(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d7523d49f5ad0cfeb77f15c443a3f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a01da621edd40a12994314d49395fce/" rel="bookmark">
			汉明距离（Hamming Distance）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉明距离（Hamming Distance） 定义 汉明距离以美国数学家理查德·卫斯里·汉明的名字命名，表示两个相同长度的字符串在相同位置上不同字符的个数。用d(x,y)来表示x和y两个字符串的汉明距离。汉明距离可以用来计算两个文本之间的相似度，根据不同字符的个数来判断两个文本是否相似。
d(10010,10000)=1 d(abcbc,abdab)=3 计算 根据定义，我们需要统计出相同位置上不同字符的个数，如何判断两个字符是否相同呢？如果两个字符都是数字，可以用a==b来判断，如果两个字符是非数字，可以用a.equals(b)来判断，但其实有更快速的方法。把两个字符进行异或运算，如果字符a和字符b相同，则a^b=0，我们只需要统计异或结果不为0的个数。
如果两个字符串长度不相等，则以短字符串长度截取长字符串，计算截取后的字符串与短字符串的汉明距离，加上两个字符串长度差。
以下是Java实现：
// 数组汉明距离计算 byte[] array1 = new byte[]{0,1,0,1,0,0,0,0,1,1,1,0,0}; byte[] array2 = new byte[]{1,1,0,1,1,0,0,1,0,1,0,1,0}; int count = 0; for (int i = 0; i &lt; array1.length; i++) { if ((array1[i] ^ array2[i]) != 0) { count ++; } } System.out.println(count); // 字符串汉明距离计算，先转换成字符数组 String str1 = "abddfaerwerw"; String str2 = "abddfaerw大rw"; char[] arr1 = str1.toCharArray(); char[] arr2 = str2.toCharArray(); int count1 = 0; for (int i = 0; i &lt; arr1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a01da621edd40a12994314d49395fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8072991559b92d1072efb872ccb9c529/" rel="bookmark">
			如何在eclipse工作时切换存储位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在网上找了很久如何在eclipse内部更改存储位置，但大多数讲的都是在进入之前如何更改，现在我附上图片，如何在eclipse工作时进行更改存储位置 第一步：点击File 第二步：在switch workspace中点击你想要的存储位置，或者点击other另新建存储位置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632e636c064ce176b874b08c6f196296/" rel="bookmark">
			NAudio 播放流、字节数组（非wav、mp3、aiff格式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NAudio 播放流、字节数组（非wav、mp3、aiff格式） 1. 问题 http或websocket通信返回的音频数据流，导出到音频文件，然后再用AudioFileReader读取文件流，可以播放比较多格式的音频（例如：webm）。但是如果不创建临时文件，改如何直接播放流MemoryStream?
2. 举例 1、返回的音频流是webm时，临时文件法可以正常播放，猜测可以分析读取文件流的方式，取消掉多余的步骤； var filename = "./tmp.webm"; using (var audioFile = new AudioFileReader(filename)) using (var waveOut = new WaveOutEvent()) { waveOut.Init(audioFile); waveOut.Play(); while (waveOut.PlaybackState == PlaybackState.Playing) Thread.Sleep(100); } 2、查看AudioFileReader构造函数，其中CreateReaderStream方法是成功播放wav、mp3、aiff这3类音频的关键，所以需要找到能MediaFoundationReader相关联的类； // 摘要: // Creates the reader stream, supporting all filetypes in the core NAudio library, // and ensuring we are in PCM format // // 参数: // fileName: // File Name private void CreateReaderStream(string fileName) { if (fileName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/632e636c064ce176b874b08c6f196296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577aaf838628c17f0b0e632c4fe19904/" rel="bookmark">
			品优购前端静态页面(HTML&#43;CSS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在复习前端的知识，在B站上面跟着黑马前端pink老师过了一部分HTML+CSS的知识，然后跟着视频写了一下品优购的项目。在跟着pink老师敲完品优购和商品列表这几个页面后，pink老师为了不水视频时长，还剩下几个页面没有完成就没出视频带着我们来做了。秉着复习和巩固的心态，自己对照着ps效果图把剩下的两个比较重要的页面给做出来了，仅以此文章来纪念复习的一个小阶段。
跟着pink老师做的品优购首页
2.跟着pink老师做的商品列表页面（这个页面有部分是自己补充上去的，因为截图的原因侧边TOP会显得有点奇怪）
3.注册页面
4.商品详情页面个人独立完成
在这里插入代码片&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;!-- SEO搜索优化 --&gt; &lt;title&gt;商品详情-综合公务员首选-正品低价、品质保障、配送及时、轻松购物&lt;/title&gt; &lt;!-- 网站说明 SEO搜索优化--&gt; &lt;meta name="description" content="品优购商城-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!" /&gt; &lt;!-- 关键字 SEO搜索优化--&gt; &lt;meta name="keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东" /&gt; &lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon"/&gt; &lt;link rel="stylesheet" href="css/base.css"&gt; &lt;link rel="stylesheet" href="css/common.css"&gt; &lt;link rel="stylesheet" href="css/product_details.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 快捷导航模块 start--&gt; &lt;section class="shortcut"&gt; &lt;div class="w"&gt; &lt;div class="fl"&gt; &lt;ul&gt; &lt;li&gt;品优购欢迎您！&amp;nbsp;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;请登录&lt;/a&gt;&amp;nbsp; &lt;a href="register.html" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/577aaf838628c17f0b0e632c4fe19904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608b37d62c38c735d7393258ef58c56c/" rel="bookmark">
			VIm自动生成python的文件头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VIm自动生成python的文件头 我实现的效果如图所示：思路是在vimrc配置文件中写相关的函数，代码在下面贴出
按:wq保存退出以后，会自动更新上次修改时间
" 新建py文件时插入文件头 autocmd BufNewFile *.py,*.sh exec ":call SetComment()" " 新建文件后自动定位到文件末尾 autocmd BufNewFile * normal G func SetComment() if expand("%:e") == 'py' call setline(1, '#!/usr/bin/env python') call setline(2, '# -*- coding: utf-8 -*-') call append(line(".")+1, "# File Name: ".expand("%")) call append(line(".")+2, "# Author: David") call append(line(".")+3, "# Created Time: ".strftime("%Y-%m-%d %H:%M")) call append(line(".")+4, "# Last Modified: &lt;none&gt;-&lt;none&gt;") endif endfunc " 保存时插入上次修改时间 au BufWrite *.py call SetLastModifiedTime(-1) " 插入修改时间函数 func SetLastModifiedTime(lineno) let modif_time = strftime("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608b37d62c38c735d7393258ef58c56c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6b71c5b60ee8f4efb07b3527bd8eb5/" rel="bookmark">
			SpringBoot定时任务 @Scheduled详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主在最近的开发中又遇到了关于定时调度的开发任务，在定时调度其实有很多的第三方平台可以接入，但是其实在SpringBoot有自带的定时任务注解@Scheduled。@Scheduled可以通过注解配置快速实现方法的定时调度，直接在方法加上@Scheduled注解即可。
一.@Scheduled注解参数 1.cron参数 这个参数是最经常使用的参数，表示接收一个cron参数，cron它是一个表达式，最多接收7个参数，从左到右分别表示：秒 分 时 天 月 周 年；参数以空格隔开，其中年不是必须参数，可以省略。
/** * cron 一共可以有7个参数 以空格分开 其中年不是必须参数 * [秒] [分] [小时] [日] [月] [周] [年] * 一下表示 */ @Scheduled(cron ="0 0 0 * * * ?") public void testScheduledCron(){ } 注意！！！ 在使用时需要在类上添加注解@EnableScheduling，表示开启定时任务。
cron参数意义： 序号含义是否必填入参范围可填通配符1秒是0-59, - * /2分是0-59, - * /3时是0-23, - * /4日是1-31, - * ? / L W5月是1-12, - * /6周（周一 ~ 周日）是1-7 , - * ? / L #8年否1970-2099, - * / 常用通配符： *：表示所有值 比如用在日 表示每一天。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d6b71c5b60ee8f4efb07b3527bd8eb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae08c5bf310ca3c2e3ef2030e2247354/" rel="bookmark">
			一文搞定Java注解和注解处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言注解注解接口注解元素默认值标记注解单值注解 元注解@Target@Retention@Documented@Inherited@Repeatable 编译器APIToolJavaCompilerDocumentationTool DocumentationTaskFileObjectJavaFileObjectForwardingFileObject JavaFileManagerStandardJavaFileManagerForwardingJavaFileManager DiagnosticDiagnosticListenerDiagnosticCollector ToolProvider 语言模型APIAnnotatedConstructAnnotationMirrorAnnotationValueAnnotationValueVisitorElementPackageElementTypeElementExecutableElementVariableElementTypeParameterElementElementVisitorElementsElementFilter TypeMirrorReferenceTypeArrayTypeDeclaredTypeTypeVariableNullTypeErrorType ExecutableTypeWildcardTypeUnionTypeIntersectionTypePrimitiveTypeNoType TypeVisitorTypes 注解处理器ProcessingEnvironmentRoundEnvironmentFilerMessagerCompletionCompletions demo 前言 注解是指一些被插入到源文件的标签。Javac对于包含注解或不包含注解的代码会产生相同的字节码，要想使用注解必须提供注解处理工具，这些工具可以在运行时对注解进行处理（反射）、在编译时对注解进行处理（注解处理器）或者在字节码层面对注解进行处理（字节码工程）。本文将详细描述注解处理器的使用方法。
注解 注解接口 所有注解都通过注解接口定义，所有注解接口都隐式扩展自java.lang.annotation.Annotation。注解接口不支持继承，并且不支持循环依赖（循环依赖是指自身使用自身或者注解A使用了注解B，那么注解B就不能使用注解A）。
modifiers @interface AnnotationName{ type elementName1(); type elementName2() default value; } 所有注解通过以下形式使用，如果注解元素有默认值，在使用时可以不用为该元素指定值。
@AnnotationName(elementName1=value1,eementName2=value2) 注解元素 所有在注解接口中定义的元素称为注解元素，注解元素必须是以下类型：
基本类型StringClassenumAnnotation以上类型组成的数组 默认值 注解元素的值不能为null，可以使用default为注解元素指定一个默认值：
@interface myAnnotaton{ int intElement() default 1; String stringElement() default "value"; Class classElement() default String.class; StandardOpenOption enumElement() default StandardOpenOption.CREATE; NotNull annotationElement() default @NotNull; int[] arrayElement()default {}; } 默认值并不和注解存储在一起，而是动态获取的，如果修改注解的默认值，那么已经编译过的类文件中也会使用这个新的默认值。
标记注解 如果一个注解中没有任何元素或者所有元素都有默认值，那么这种注解称为标记注解，在使用时可以不用加括号。
@AnnotationName 单值注解 如果在注解中定义了名为 value 的元素，并且在使用该注解时，value为唯一一个需要赋值的元素，那么可以直接在括号中给出value的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae08c5bf310ca3c2e3ef2030e2247354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876ccfdc3b6c450f6ccf1cfa22678a22/" rel="bookmark">
			element 和 input 实现省市区层级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72159142466b322a14db6410926f433f/" rel="bookmark">
			C&#43;&#43;洛谷题解(32)——P5720
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目信息 题名：一尺之棰
题目：《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 a 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 2，向下取整）。第几天的时候木棍的长度会变为 1？
输入格式：输入一个正整数 a，表示木棍长度。
输出格式：输出一个正整数，表示要第几天的时候木棍长度会变为 1。
分析题目 洛谷考我，PTA考我，LeetCode考我，CCF考我，连庄子也考我[哭笑]。不过还好这道题不难，可因为不难所以我觉得这一期的阅读量能破100就很不错了，毕竟这道题很简单。
言归正传，还是简单分析一下题目：
声明变量n和cnt，初始化为1输入n只要n&gt;1就不限循环累加cnt。n/=2输出cnt的值 整段代码最精髓的就是n/=2，题目中的“日取一半”、“锯掉一半”、“向下取整”等操作统统解决
示例代码 #include &lt;bits/stdc++.h&gt;//万能头 using namespace std; int main() { int n, cnt = 1;//声明n和一个计数用的cnt cin &gt;&gt; n;//输入n while (n &gt; 1)//只要n&gt;1就无限循环 { cnt++;//cnt累加 n /= 2;//n/2，没错，他们说的都是废话，代码精髓就4个字符 } cout &lt;&lt; cnt;//输出累加的和 return 0;//结束 } VS Code终于不再乱改注释的位置了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b45db9a3d75ce127751ce4d46f4e56/" rel="bookmark">
			【Java】常见习题练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 基础题目 1、Java语言特点 简单易学（Java语言和C语言和C++语言很接近）面向对象（封装 继承 多态）平台无关性（Java虚拟机实现了平台无关性）支持网络编程（Java语言诞生就是为了简化网络编程设计的）支持多线程解释与编译共存的语言 2、JVM、 JDK 和 JRE JVM是运行java字节码的虚拟机。不同的平台有自己的虚拟机，因此java语言可以实现跨平台。JDK即Java Development Kit，是供Java开发人员使用的，其中有Java的开发工具，比如编译工具javac.exe，打包工具jar.exe，同时包含了jreJRE即Java Runtime Enviroment，是java的运行时环境，包括了jvm、java类库、java命令和其他的一些基础构件。 3、JAVA和C++的区别？ 都是面向对象语言，支持封装继承多态。
java提供指针来直接访问内存，程序内存更加安全。java的类是单继承的，c++放支持多继承，但java的接口可以多继承java它有自动内存管理垃圾回收机制GC。c语言中，字符串和数组最后都会有一个额外的字符’\0’来表示结束。 4、java语言编译与解释并存 java程序要先经过编译，后解释两个步骤，有java编写的程序需要先经过编译步骤，生成字节码文件，这种字节码必须由java解释器来执行。编译型语言指编译器将源代码一次性的翻译成可被特定平台执行的机器码。解释型语言指解释器将源代码逐行解释成可被特定平台执行的机器码并立即执行。 5、continue、break 和return的区别 在循环结构中，当发生了某种条件后提前终止循环。这时候就要用到这几个关键字：
continue：跳出当前的这一次循环，继续下一次循环。break:跳出整体的循环体，继续执行循环下面的语句。return：结束方法的运行。 6、java有哪些基本数据类型 基本数据类型：
数值型：byte(1个字节，默认值0) ，short(2个字节，默认值0) ， int(4个字节，默认值0) ， long(8个字节，默认值0L) ，float(4个字节，默认值0.0F) ，double(8个字节，默认值0.0D)字符型：char（2个字节，默认值’\u0000’）布尔型：boolean(1个字节，默认值false)
引用数据类型：类class接口interface数组[] 7、方法的返回值以及返回值在类的方法里的作用 方法的返回值就是获取到的某个方法体中代码执行后产生的结果。返回值的作用就是接收结果，使得它可以用于其他的操作。 8、面向对象和面向过程 面向对象主要是把事务给对象化，包括它的属性和行为。面向对象编程更贴近实际生活的思想。总体来说面向对象的底层还是面向过程，面向过程抽象成类，然后封装，方便使用就是面向对象。面向过程就是分析出解决问题的步骤，然后用函数把这些步骤一步一步实现，使用时候一次调用即可。 9、面向过程和面向对象的区别 面向过程：面向过程的性能比面向对象高。因为类调用时需要实例化，开销较大消耗资源，所以以性能为主要考虑因素时一般采用面向过程开发，比如单片机，嵌入式开发，Linux等。面向对象：面向对象易于维护，易复用，易扩展。因为面向对象有封装继承多态的特性，所以可以设计出低耦合的系统。 10、 &amp;和&amp;&amp; 的区别 相同点：&amp;和&amp;&amp;都可以用作逻辑与的运算符（and）不同点：
&amp;&amp; 具有短路与的功能。当 &amp; 运算符两边的表达式都为true时，整个运算结果才为true。而 &amp;&amp; 运算符，第一个表达式为false时，结果直接为false，不再进行第二个表达式。
&amp; 还可以做按位与运算符。 11、标识符和关键字的区别 标识符就是我们在写程序的时候为类，变量和方法取的名字。
但有一些标识符，被赋予了特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。
常见的关键字有：
关键字和保留字
12、数学库类中的常见算法 ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；round方法表示四舍五入，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11. 编程练习 首先复习一下语法基础，再进行编程练习
统计位数为偶数的数字
给你一个整数数组 nums，请你返回其中位数为偶数的数字的个数。
示例 1：
输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字 位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41b45db9a3d75ce127751ce4d46f4e56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4e35004aa150c30e5aadcb87061074/" rel="bookmark">
			基于Java——SpringBoot的洗浴会所管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.系统内容
2.1 登录页面、
2.2 注册页面
2.3 系统首页
2.4 服务列表
2.5 服务修改
2.6 会员管理
2.7 会员录入
3.部分代码
3.1 实体类
3.11 admin
3.12 item
3.2 Dao层
3.2.1 admindao
3.2.2 itemdao
3.2.3 memberdao
3.3 Controller 层
3.3.1 admincontroller
3.3.2 itemcontroller
3.3.3 membercontroller
1.前言 学校安排两周的项目实践学习，所以学了一段时间的SpringBoot，因为SpringMvc还没有学完，如果单独学起来SpringBoot并且做项目的话很难，还好在项目实践老师的带领下多多少少领会点了东西，尤其对于基于注解开发的整个流程框架的步骤以及逻辑实现原理。其次学到了不少JavaScript,的知识。以及前端框架的灵活运用。在此次系统中运用了SpringBoot框架集成Maven依赖,以及前端框架Bootstrap开发，很多东西直接调用，大大减少了代码量。
2.系统内容 2.1 登录页面、 登录页面首先搭建前端页面，然后根据后端数据库表中相关信息做出判断。并且附有注册的超链接。
2.2 注册页面 注册页面也是先搭建前端页面，在这里用到了一个阿里云功能，就是根据邮箱发验证码然后根据验证码进行注册，有点符合日常系统的使用规范性。注册成功后则将数据写进后端数据库表中。
2.3 系统首页 系统首页没有太多的后端逻辑功能，就是在用户登录成功后通过后端将管理员的名字保存到本地浏览器中，然后在前端中获取，最后展示到页面中。
2.4 服务列表 服务列表页面中包含的前后端知识，比较多。当在页面刷新完成时，数据就会显示在页面这是利用Jquery里面的一些知识完成的我也没有深入研究。其次对于页面中的分页，要实现前后端逻辑功能，并且在页面中附有模糊查询的搜索框，也需要后端的支持。
2.5 服务修改 服务修改在后端要发两次请求，首先是查询该id的对象信息，输出到页面中，当做出修改后，再次发出保存的请求。
2.6 会员管理 会员管理等同于服务列表页面，只不过增加了批量删除，会员录入的功能。
2.7 会员录入 录入修改信息，写到了一块，首先前端通过输入手机号等相关信息，然后后端通过手机信息查询是否有该对象，如果没有则执行录入新会员功能，如果有的话则执行修改功能。
3.部分代码 3.1 实体类 3.11 admin package tech.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df4e35004aa150c30e5aadcb87061074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b255d79bc05ad197fc720e2257c39d95/" rel="bookmark">
			C&#43;&#43;八股文(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++八股文(一) 1.1 C++语言的特点 C++在C的基础上引入了面向对象机制，同时也兼容C语言；C++三大特性：封装、继承、多态；C++程序结构清晰、易于扩充、程序可读性好；C++代码质量高，运行效率高、仅比汇编语言慢10%~20%；C++更安全，增加const常量、引用、四类cast转换(static_cast、dynamic_cast、const_cast、reinterpret_cast)、智能指针、try-catch等等；C++可复用性高，C++引入了模板的概念，有专门的模板库(STL)；C++是不断发展的语言，C++11中新引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。 1.2 C++和C语言的区别 C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、auto变量等；C++是面对对象的编程语言；C语言是面对过程的编程语言；C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等；C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用。 1.3 C++中 struct 和 class 的区别 struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的；在继承关系中，struct 默认是公有继承，而 class 是私有继承；class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数。 1.4 include头文件的顺序以及双引号""和尖括号&lt;&gt;的区别 区别： 尖括号&lt;&gt;的头文件是系统文件，双引号""的头文件是自定义文件；编译器预处理阶段查找头文件的路径不一样； 查找路径; 使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量;使用双引号""的头文件的查找路径：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。 1.5 C++结构体和C结构体的区别 C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数；C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种；C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用；C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。 1.6 导入C函数的关键字是什么，C++编译时和C有什么不同？ 关键字：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。
编译区别：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。
1.7 简述C++从代码到可执行二进制文件的过程 预编译、编译、汇编、链接
预编译：这个过程主要的处理操作如下：
（1） 将所有的#define删除，并且展开所有的宏定义
（2） 处理所有的条件预编译指令，如#if、#ifdef
（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。
（4） 过滤所有的注释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b255d79bc05ad197fc720e2257c39d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf113089f32f48095f914089f2612e96/" rel="bookmark">
			Java简单案例练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目1：编写java程序，在控制台输出以下两句话
题目2：用户输入(姓名, 年龄, 性别, 身高, 婚姻状况) 并在控制台打印
题目3：编写java程序，通过键盘录入一个三位数的整数，获取该数字上的每一位数字，并且输出。最后再求这三个数字之和输出
题目4：通过键盘输入一个年龄，使用if语句对年龄进行判断。如果年龄大于等于18，则输出：恭喜，您已经成年了！
题目5：键盘录入学生考试成绩，判断学生等级:
题目6：中国使用的公历有闰年的说法,闰年的规则是:四年一闰,百年不闰,四百年再闰。
题目7：需求 : 假设一个简单的在ATM的取款过程如下：
题目8：需求 : 按照从小到大的顺序输出四位数中 (个位 + 百位 = 十位 + 千位 ) 的数字及个数 , 要求使用while循环完成
题目9：某电信客服服务满意度反馈信息如下：
题目10：模拟计算器功能，对键盘录入的两个int类型的数据进行加、减、乘、除的运算，并打印运算结果。
题目11：需求：定义一个长度为5的一维数组，给每个元素赋值. (要求数组中每个元素的值是20-80的随机数)
题目12：需求：键盘录入一个整数作为数组的长度，随后再次键盘录入数据并将数组存满
题目13：需求：某超市在去年4个季度的营业额(单位万元)
题目14：请定义一个方法，该方法可以实现对int类型的数组进行遍历，在控制台打印所有元素。实现方法后，请在主方法中调用方法，查看结果。
题目15：定义标准的项目经理类Manager
题目16：创建一个长度为6的整数数组。请编写代码，随机生成六个0（包含）-100（不包含）之间的整数存放到数组中，然后计算出数组中所有元素的和并打印。
题目：17有一个数组，其中有十个元素从小到大依次排列 {12,14,23,45,66,68,70,77,90,91}。
题目：18请定义一个方法，该方法的功能是在控制台打印九九乘法表。方法实现完毕，请在主方法中调用方法，查看打印结果
题目1：编写java程序，在控制台输出以下两句话 不肯下一点功夫，永远不会明白自己从何而来，又将立足于何处。
很多聪明人之所以没有成功，缺少的不是智慧，而是那种为成功而拼搏的干劲 。
public class demo01 { public static void main(String[] args) { System.out.println("不肯下一点功夫，永远不会明白自己从何而来，又将立足于何处"); System.out.println("很多聪明人之所以没有成功，缺少的不是智慧，而是那种为成功而拼搏的干劲 。"); } } 题目2：用户输入(姓名, 年龄, 性别, 身高, 婚姻状况) 并在控制台打印 //导包 import java.util.Scanner; public class demo01 { public static void main(String[] args) { Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf113089f32f48095f914089f2612e96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9477f2413ddaa137b853846e31438db/" rel="bookmark">
			容器技术之Docker&amp;K8S
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Docker&amp;K8S区别 区别：1、k8s是一种开放源码的容器集群管理系统，而Docker是一种开放源码的应用容器引擎；2、k8s是一套自动化部署工具，可以管理docker容器是容器编排层面的，docker是容器化技术，是容器层面的。
2. 概念 2.1 Docker Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。一句话总结就是，从仓库中拉取镜像，利用镜像生成容器。
Docker技术的三大核心概念，分别是：镜像（Image）、容器（Container）、仓库（Repository）。相关概念解释如下：
宿主机，Host，运行Docker所在的物理机，是Docker运行的系统环境。
镜像，Image，相当于一个程序模板，通过这个模板可以生成很多个相似的容器。可以理解为Java中的类，它本身不具备执行运行的能力，是一个对象抽象的模板。每个镜像可以有多个版本，用tag来区分。镜像可以通过Dockerfile来构建。
容器，Container，Docker运行的最小单位对象。它是通过镜像实例化出来的一个可运行对象。容器的修改，可以提交反作用于镜像，更新这个容器的模板。
仓库，Repository，用于存储管理镜像的仓库，类似于git管理代码的仓库一样，可以管理多版本的镜像。
2.2 Master aster 节点结构如下：apiserver 即 K8s 网关，所有的指令请求都必须要经过 apiserver。Scheduler 调度器，使用调度算法，把请求资源调度到某一个 Node 节点。Controller 控制器，维护 K8s 资源对象。etcd 存储资源对象。
2.3 Node Kubernetes 的 Node 是真正运行业务负载的，每个业务负载会以 Pod 的形式运行。等一下我会介绍一下 Pod 的概念。一个 Pod 中运行的一个或者多个容器，真正去运行这些 Pod 的组件的是叫做 kubelet，也就是 Node 上最为关键的组件，它通过 API Server 接收到所需要 Pod 运行的状态，然后提交到我们下面画的这个 Container Runtime 组件中。
2.4 Pod 简单介绍Pod的概念。首先，Pod运行在一个被称为节点 (Node)的环境中，这个节点既可以是物理机，也可以是私有云或者公 有云中的一个虚拟机，通常在一个节点上运行几百个Pod;其次，在每 个Pod中都运行着一个特殊的被称为Pause的容器，其他容器则为业务容 器，这些业务容器共享Pause容器的网络栈和V olume挂载卷，因此它们 之间的通信和数据交换更为高效，在设计时我们可以充分利用这一特性 将一组密切相关的服务进程放入同一个Pod中;最后，需要注意的是， 并不是每个Pod和它里面运行的容器都能被映射到一个Service上，只有提供服务(无论是对内还是对外)的那组Pod才会被映射为一个服务。
3. 推荐文章 Kubernetes 深入学习（一） —— 入门和集群安装部署 容器技术之Docker&amp;K8S知识笔记
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9477f2413ddaa137b853846e31438db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208a8acc75048a502fb081ec0c11ee42/" rel="bookmark">
			Linux 下编译opencv4 及使用CLion运行demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译安装 1. 官网下载最新版opencv源码。当前最新版为4.5.3
2.解压
3.在解压后的代码目录下创建build目录（也可以在其它地方），作为编译目录
4.cmake生成Makefile
cmake -D OPENCV_GENERATE_PKGCONFIG=ON -D CMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local .. -D OPENCV_GENERATE_PKGCONFIG=ON，为生成opencv.pc文件的配置(注意，opencv4生成的文件叫做opencv4.pc),另外 CMAKE_INSTALL_PREFIX=/usr/local 指定安装路径是在/usr/local下，这也是opencv的默认配置。
5.编译
make -j8 可能出现多个错误。其中一个是gen_java.py中出错，将 assert path[-3:] != '.in', path 中的3改成4即可（网络搜索可知）。笔者的另一些错误是安装了anaconda3导致。编译opencv会链接一些系统的库文件，而由于anaconda安装时，将其路径设置在 PATH 环境变量靠前的位置，导致会优先链接anaconda下lib子目录下的库文件（不肯定），而该目录下的库文件和对应的系统文件版本不同，导致有些函数在旧版本的库文件上找不到。解决方法是将anaconda下lib子目录下的库文件（一般为软连接，指向当前目录下的名字带有版本号的真实库文件）改为指向系统库目录下同名文件。
6.
sudo make install 会将编译好的opencv安装至 /usr/local 目录下。由于打开了 OPENCV_GENERATE_PKGCONFIG，将会在 /usr/local/lib/pkgconfig/ 下生成 opencv4.pc 文件，于是可以用 pkg-config --cflags --libs opencv4 得到include目录和链接目录
在CLion中写opencv程序 参考 OpenCV: Using OpenCV with gcc and CMake
将CMakeLists.txt改为：
cmake_minimum_required(VERSION 2.8) project( DisplayImage ) find_package( OpenCV REQUIRED ) include_directories( ${OpenCV_INCLUDE_DIRS} ) add_executable( DisplayImage DisplayImage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208a8acc75048a502fb081ec0c11ee42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef447bf90e08eb4a5e1bf6a61662fdbe/" rel="bookmark">
			from ui_mainwindow import Ui_MainWindow 报错 ValueError: source code string cannot contain null bytes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍 最近在想了解一下pyside6 的使用，在使用 Qt Designer 制作完成ui文件后使用命令：
pyside6-uic mainwindows.ui &gt; ui_mainwindow.py 把ui文件变成py文件。
但是在运行的时候却报错了，
Traceback (most recent call last): File "e:/project/picture/pygui/side6py04.py", line 23, in &lt;module&gt; from ui_mainwindow import Ui_MainWindow ValueError: source code string cannot contain null bytes 错误解决方法 查了一下资料,才发现，
原来是ui文件转换成py文件之后，.py文件的编码格式是“UTF-16 LE",　不是utf8格式的导致错误。因此只需要把.py文件重新编码保存就可以了。
在vs code中的方法是
点击一下”UTF-16 LE"
重新选择新的“utf-8”格式
成功运行 改变编码之后会再次运行，没有报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6622313098ae5464c78eb78e90b0eb28/" rel="bookmark">
			【C&#43;&#43;简介】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是C++？ （1）C++是一种编程语言，它融合了3种不同的编程方式：
C语言代表的过程性语言、
C++在C语言基础上添加的类代表的面向对象语言、
C++模板支持的泛型编程
（2）C++从C语言发展而来，为了适应大规模结构性逻辑程序而产生，完全兼容C程序，开始只在C的基础上拓展了class结构，所以也被叫做“带类的C”,相对于C语言面向过程的编程，它属于面向对象（OOP(Object Oriented Programming)）的编程,在C++取得一定成功后，才添加了模板，支持泛型编程，使代码的可复用性大大提高。
2.C++的可移植性 （1）什么叫做“这个C++程序是可移植的”？
举例：
假如一个C++程序已经在Windows环境下编写完成且编译通过可用，那么当它在OS环境/Linux环境下，不修改代码，直接编译通过且程序运行良好，则说这个C++程序是可移植的。
（2）为了实现C++程序的可移植性，都采取了哪些措施？
为了解决C++代码可移植的两大问题：
1.硬件特定程序不可移植
2.不同平台上的C++语言有差异，导致可移植性降低
美国国家标准局（American National Standards Institute，ANSI）在1990年设立了一个委员会（ANSI X3J16），专门负责制定C++标准（ANSI制定了C语言标准）。国际标准化组织（ISO）很快通过自己的委员会（ISO-WG-21）加入了这个行列，创建了联合组织ANSI/ISO，致力于制定C++标准。
1998年通过审批，产生标准ISO/IEC 14882:1998，通常称之为C++98，它描述了已有的C++特性，还添加了异常、运行阶段类型识别（RTTI）、模板和**标准模板库（STL）
2003年发布了C++标准第二版（IOS/IEC 14882:2003），称为C++03【只是对C++98的一些语法错误进行修正】
2011年发布新标准ISO/IEC 14882:2011，称为C++11，该版本新增了众多特性【auto、范围for、nullptr、shared_ptr、weak_ptr、unique_ptr、using定义别名、函数模板默认参数等】
3.程序的创建、编译和链接 （1）源代码
打开文本编辑器或常用代码编辑器，书写的程序代码就称为源代码
（2）编译器
编译器的作用就是把写好的源代码，翻译成机器码（计算机可以识别的内部语言）
（3）目标代码
经过编译器翻译后的计算机内部语言，称之为目标代码
（4）链接
链接的主要作用是把我们的目标代码和C++中一些会用到的库【库里面的一些会用大的函数的目标代码】、一些标准的启动代码（startup code）组合起来【运行时会去调用用户编写的main函数】，生成程序的运行阶段版本
（5）可执行代码
上述程序的运行阶段版本就是可执行代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65724d7e8fc192d55f1fccf10aaacef8/" rel="bookmark">
			＜C&#43;&#43;＞ 通讯录管理系统(纯手写含源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🛒本文收录于专栏：【大战C++】
📢专栏目的是对于C++的讲解，重点的逐个击破，会持续输出，欢迎免费订阅！！
🍔彩蛋：
🔎牛客网是一个兼具 面经、刷题、求职 的神器,是我们的最佳选择，我用过很不错呢~ 👉点击注册开始刷题
小鸣人因为准备考研，学完C++准备浅练下算法，后续会推出牛客网刷题记录专栏，到时希望大家多多关注~
✨千里之行，始于足下✨ 目录 🔎通讯录管理系统一、系统概述二、系统实现🔥菜单🔥设计联系人结构体🔥设计结构体结构体🔥1.添加联系人🔥2.显示联系人🔥3.删除联系人🔥4.查找联系人🔥5.修改联系人🔥6.清空联系人🔥0.退出联系人 三、源码 🔎通讯录管理系统 一、系统概述 用C++来实现一个通讯录管理系统
功能如下：
添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多记录1000人显示联系人：显示通讯录中所有联系人信息删除联系人：按照姓名进行删除指定联系人查找联系人：按照姓名查看指定联系人信息修改联系人：按照姓名重新修改指定联系人清空联系人：清空通讯录中所有信息退出通讯录：退出当前使用的通讯录 二、系统实现 🔥菜单 给用户提供选择的界面，下图是效果图：
封装一个函数来实现这个菜单界面，然后在main函数中调用就好了
//菜单界面 void showMenu() { cout &lt;&lt; "***************************" &lt;&lt; endl; cout &lt;&lt; "***** 1、添加联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 2、显示联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 3、删除联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 4、查找联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 5、修改联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 6、清空联系人 *****"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65724d7e8fc192d55f1fccf10aaacef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945bc3ed06fefc9e77fbd91cd3276feb/" rel="bookmark">
			http加密、状态码、百度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.怎么实现非对称加密传输对称加密： 概念 https相当于在http和tcp之间加上了一层ssl加密，但是要注意的是：
https协议的内容传输的加密上使用的是对称加密；非对称加密之作用在证书验证阶段。
因为非对称加密的加解密效率是非常低的，而https的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。
对于对称加密，比如说常见的移位替换等方法，只要知道了加密过程，就一定知道解密过程，因为加密算法比较简单，那么根据加密算法就能反推出解密算法，也就是双方的秘钥是一样的，这就是对称加密。
非对称加密：你的手上有两个密钥（一对密钥），它们有一定的关联，但没有办法通过其中一个算出另外一个。你把一个密钥紧紧地攥在手里，永远不向别人公布**（私钥）；把另外一个发送给我，当然，发送给我的途中，所有的设备都知道了这个密钥（公钥）。之后我用公钥加密了数据**，并发送给你，你却可以奇迹般地用私钥解密它。但是对于只有公钥的人，却不能用公钥对其进行解密。
过程 https建立连接的过程：
1、客户端发起握手请求，注意这里请求是明文的，客户端没有使用任何秘钥。直接达到请求url的443端口即可。
2、服务器将数字证书发送给客户端，这个数字证书是为了防止中间人攻击的，里面包括了公钥。请注意，这里服务器接收到请求之后，会在服务器本地生成这个一对公钥和私钥，它的公钥会发送给客户端，私钥留在自己本地。而数字证书，是保证了客户端收到这个私钥所在的数字证书之后，信任真正是由这个网站发送过来的**（数字证书表示对服务器的认可）而不是别的中间人。
3、客户端验证证书的合法性**。因为数字证书包括过期时间，域名以及最重要的公钥，所以数字证书能验证是不是真正由网站发过来的。
4、确定证书合法之后，客户端随机生成一个长整数，这个长整数用公钥加密，加密之后就发送至服务器。
5、服务器用私钥解密，拿到了之后进行数据交换时用于对称加密的秘钥。这个秘钥就是以后进行真正数据交换的秘钥了。
6、服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输给客户端，这样子这个对称加密的算法双方都知道了，https加密连接也就完成了。
那究竟怎么避免加密失败了呢？
首先，第二步的数字证书保证了服务器和公钥的可信任性，这样之后客户端就可以大胆利用这个公钥进行加密。
第二，服务器用公钥发送，私钥一直留在本地，这样就没可能让客户端发送的东西被其他人截取之后破解，因为没有私钥。也就是说第五步用私钥解密之后，保证了这个客户端随机生成的整数只有客户端和服务器知道，其他的人都不知道。
之后利用这个别人都不知道的整数去生成对称加密的算法，这样其他人就就算是拦截了数据，因为对称加密算法不知道，也就无法破解了。因此保证了https协议的安全性
web状态码 1XX：信息提示 这类状态代码表示临时的响应。客户端在收到常规相应之前，应准备接受一个或多个1xx相应。
HTTP状态码说明100继续101切换协议 2XX：成功 这类状态代码表示服务器成功的接受了客户的请求。
HTTP状态码说明200确定。客户端请求已经成功201已经创建202已接受203非权威性信息204无内容205重置内容206部分内容。表明已经部分下载了一个文件。可以继续损坏的下载，或者将下载拆分为多个并发的流207多状态（webDAV）。此消息之前应该还有一条XML消息，其中可能包含几个单独的响应代码，具体取决于发出了多少个子请求。 3XX：重定向 客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同页面，或通过代理服务器重复该请求。
HTTP状态码说明301已永久移动。此请求和之后所有的请求都应该转到指定的URL302对象已移动。对于基于表单的身份验证，此消息通常表示“对象已经移动”。请求的资源临时驻留在不同的URL。由于重定向有时可能对改变，客户端将来在请求时应该继续使用RequestURL。只有在CacheControl 或 Expires 标题字段中指示，此响应才能够缓存。304未修改。客户端请求的文档已经在缓存中，文档缓存以来尚未被修改过。客户端使用的缓存副本。而从不服务器下载文档307临时从定向 4XX：客户端错误 发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。
401状态码： 403状态码 404状态码 5XX：服务器错误 服务器由于遭遇错误而不能完成该请求
500状态码 502状态码 如何与百度建立连接 1、检查本地dns缓存，看缓存中是否有解析数据。
2、查看本地的hosts文件
3、本机固定的dns服务器（路由器）找到13台根域服务器
4、根域找到com域，com找到baidu域名
给你返回结果
返回给你主机
5、和百度服务器建立TCP可靠连接，三次握手
keep-alive
request
response
最终通过浏览器实现解析页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e34e49762a5f73aadbe3ae825c1dacf/" rel="bookmark">
			windows关闭445、3389端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、检验端口是否开启二、关闭445端口 2.1 445端口（tcp）2.2 445端口（udp） 三、关闭3389端口四、重启电脑五、检验是否关闭成功六、445端口入侵详解 一、检验端口是否开启 打开cmd，运行下面四条指令（一条一条的粘贴那样输出好看点）
netstat -ano -p tcp | find "445" &gt;nul 2&gt;nul &amp;&amp; echo 445端口(tcp)已开启 || echo 445(tcp)端口未开启 netstat -ano -p udp | find "445" &gt;nul 2&gt;nul &amp;&amp; echo 445(udp)端口已开启 || echo 445端口(udp)未开启 netstat -ano -p tcp | find "3389" &gt;nul 2&gt;nul &amp;&amp; echo 3389端口(tcp)已开启 || echo 3389端口(tcp)未开启 netstat -ano -p udp | find "3389" &gt;nul 2&gt;nul &amp;&amp; echo 3389端口(udp)已开启 || echo 3389端口(udp)未开启 注意：如果输出的都是“...未开启”，恭喜你就别往下看了，因为你压根没打开过，别人通过这两个漏洞黑不了你。反之，你就往下针对输出情况选择关闭端口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e34e49762a5f73aadbe3ae825c1dacf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c73baf9146da19b27c9784bc93e3c5/" rel="bookmark">
			Kubernetes基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes是什么 Kubernetes是Google在2014年开源的一个容器集群管理系统，Kubernetes简称K8s Kubernetes用于容器化应用程序的部署，扩展和管理，目标是让部署容器化应用简单高效。 官方网站：http://www.kubernetes.io
官方文档：https://kubernetes.io/zh/docs/home
Kubernetes集群架构与组件 Master节点 kube-apiserver Kubernetes API，集群的统一入口，各组件协调者，以RESTful API提供接口服务，所有对象资源的增删改查和监听操作都交给 APIServer处理后再提交给Etcd存储。
kube-controller-manager 处理集群中常规后台任务，一个资源对应一个控制器，而 ControllerManager就是负责管理这些控制器的。例如 Deployment、Service
kube-scheduler 根据调度算法为新创建的Pod选择一个Node节点，可以任意部署, 可以部署在同一个节点上,也可以部署在不同的节点上。
etcd 分布式键值存储系统。用于保存集群状态数据，比如Pod、Service 等对象信息。
Node节点 kubelet kubelet是Master在Node节点上的Agent，管理本机运行容器的生命周 期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点状态 等工作。kubelet将每个Pod转换成一组容器
kube-proxy 在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作
容器引擎 例如docker、containerd、podman 容器引擎，运行容器。
部署K8S的2种方式 kubeadm Kubeadm是一个工具，提供kubeadm init和kubeadm join，用于快速部署Kubernetes集群。 部署地址：https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/
二进制 从官方下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。 下载地址：https://github.com/kubernetes/kubernetes/releases
第三方工具或者Web kubeadm快速搭建K8s集群 1、安装Docker
2、创建一个 Master 节点 kubeadm init
3、将一个 Node 节点加入到当前集群中 kubeadm join
4、部署容器网络（CNI） kubectl apply -f calico.yaml
5、部署Web UI（Dashboard）
网络组件的作用 部署网络组件的目的是打通Pod到Pod之间网络、Node与Pod之间网络，从而集群中数据包可以任意传输，形成了一 个扁平化网络。
主流网络组件有：Flannel、Calico等 而所谓的CNI（ Container Network Interface，容器网络接口）就是k8s对接这些第三方网络组件的接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63c73baf9146da19b27c9784bc93e3c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dcc7defe867ec25d2097f2ace9dbd9/" rel="bookmark">
			收藏丨8个常用中文OCR数据集，附下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫一扫识别文字、拍照翻译、拍照搜题、车牌自动识别……这些随处可见的功能，给我们的工作和生活带来了极大的便利，其背后都离不开OCR技术的支持。
随着深度学习技术的发展，智能OCR算法与应用也越来越丰富，对相关数据的需求也增加。
许多小伙伴反馈中文OCR数据集不好找，今天我们贴心地帮大家整理了8个常用的中文OCR数据集资源，记得收藏。
No.1 MSRA-TD500 (MSRA Text Detection 500 Database) 下载链接：
https://opendatalab.com/MSRA-TD500
MSRA-TD500由华中科技大学于 2012 年在 CVPR 发布，是一个用于测试和评估多方向、多语言文字检测算法的自然图像数据集，包含500幅拍摄于室内（办公室和商场）和室外（街道）场景的自然图像。室内的图像主要包括标识、门牌和标牌等，室外的图像主要是路牌和广告牌等。图像的分辨率较高，介于1294*864和1920*1280之间。
该数据集由两部分构成：训练集、测试集。训练集中一共有300幅图像，通过随机抽样的形式从原始数据集中抽取出来。余下的200幅图像构成测试集。
数据集中的所有图像都经过完整标注。数据集的基本单元是文本行而非单词。
MSRA-TD500数据集样例（图源：参考资料[1]）
MSRA-TD500数据集中的典型图像以及文字的标准矩形框 每一个矩形框对应一个文本行。红色的矩形框表示其中的文字被标记为“困难”。在MSRA-TD500数据集中，难以检测的文字（一般由低分辨率、模糊和遮挡等因素造成）会被标记为“困难”。
No.2 Chinses Text in the Wild(CTW) 下载链接：
https://ctwdataset.github.io/
由清华大学与腾讯共同推出的一个大型中文自然文本数据集（Chinese Text in the Wild，CTW）。该数据集包含 32,285 张图像和 1,018,402 个中文字符。
每张图像尺寸为2048*2048，数据集大小为31GB。CTW以（8:1:1）的比例将数据集分为：
训练集（25887张图像，812872个中文字符）；
测试集（3269张图像，103519个中文字符）；
验证集（3129张图像，103519个中文字符）；
这些图像源于腾讯街景，从中国的几十个不同城市中捕捉得到。数据多样、复杂，它包含了平面文本、凸出文本、城市街景文本、乡镇街景文本、弱照明条件下的文本、远距离文本、部分显示文本等。
CTW数据集样例示意（图源：参考资料[2]）
对于每张图像，数据集中都标注了所有中文字符。对每个中文字符，数据集都标注了其真实字符、边界框和 6 个属性以指出其是否被遮挡、有复杂的背景、被扭曲、3D 凸出、艺术化，和手写体等。
No.3 Reading Chinses Text in the Wild(RCTW-17) 下载链接：
https://rctw.vlrlab.net/dataset.html
ICDAR（国际文档分析和识别大会）在2017年发起了一项专注于中文检测和识别比赛项目（RCTW），RCTW-17为竞赛数据集，它由12263张包含中文的自然场景图片组成，其中大部分是直接由摄像头或手机拍摄，少部分为生成图像，并且每张图像至少包含一行中文。图像尺寸不规则，数据集大小为11.4GB。
数据的标注均通过标注工具手工标注完成，通过绘制四边形来标注一个文本行，而不是以单词为单位进行标注，每个文本行的内容以UTF-8字符串进行标注。在数据集中存在字体、布局和语言等多样性。
数据集划分为两部分：训练集和验证集。训练集包含8034张图片，测试集包含4229张图片。
RCTW-17数据集样例示意（图源：参考资料[3]）
No.4 ICPR MWI 2018挑战赛 下载链接：
https://tianchi.aliyun.com/competition/entrance/231685/information
ICPR MWI 大赛提供的包含2000张图像的官方数据集，主要由合成图像，产品描述，网络广告构成。该数据集数据量充分，中英文混合，涵盖数十种字体，字体大小不一，多种版式，背景复杂。数据集大小为2GB。其中训练集10000张，测试集10000张。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0dcc7defe867ec25d2097f2ace9dbd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf91620a3000f87351a33a697220155/" rel="bookmark">
			挑战更高难度的多目标跟踪，MOT20数据集使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一期为大家介绍了多目标跟踪任务及其常用的数据集：多目标跟踪（MOT）数据集资源整理分享。其中最新发布的行人数据集MOT20，环境更复杂、人群更密集，任务难度更大。
这一期，给想挑战的朋友，详细介绍一下。
目录指引
1. 数据集简介
2. 数据集详细信息
3. 数据集任务定义及介绍
4. 数据集结构解读
5. 下载链接及可视化脚本
一、数据集简介 发布方：Dynamic Vision and Learning Group at TUM Munich, Germany
发布时间：2020
发布版本：MOT20
背景：相比于此前的多目标跟踪（multi-object tracking）数据集，MOT20关注人群密集的场景，其视频最多可达单帧 246 人。
二、数据集详细信息 1. 数据量及标注情况 数据集共包含 8 个视频片段，分别来自三个不同的场景，4 个视频片段用于训练，4 个视频片段用于测试。每个视频片段均以视频帧的形式提供，8 个视频片段总共包含 13410 帧，其中训练视频 8931 帧，测试视频 4479 帧。
​
​
数据集提供每个视频帧上的矩形框标注，其中测试数据的标注不公开。训练数据平均每帧包含 127.04 个行人（pedestrian）矩形框标注，测试数据平均每帧包含 115.52 个行人矩形框标注。
​
除了行人，数据集还包含其他类型的矩形框标注，如非移动交通工具（non motorized vehicle）等。在评测时仅考虑行人类型的标注，不考虑其他类型。
除了标注信息外，数据集作者在训练数据上训练了一个以 ResNet101 为 backbone 的 Faster R-CNN 作为 baseline，并提供训练和测试数据上逐帧检测行人的结果（注：在竞赛中，如果参赛者要使用基于检测的跟踪方法，只能使用官方提供的检测结果）。
2. 标注类别 数据集的标注包含以下五种标注类别：
● Pedestrian
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf91620a3000f87351a33a697220155/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1cbb2ab61cb088cc52aef9d5861b25/" rel="bookmark">
			element el-dialog组件嵌套时遮罩层显示异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 element el-dialog组件进行嵌套时 打开里面的弹窗发现遮罩层在最外面
解决 在内部的el-dialog组件上添加 append-to-body 属性并将属性值设置为 true 以下为官方示例代码
&lt;template&gt; &lt;el-button type="text" @click="outerVisible = true"&gt;点击打开外层 Dialog&lt;/el-button&gt; &lt;el-dialog title="外层 Dialog" :visible.sync="outerVisible"&gt; &lt;el-dialog width="30%" title="内层 Dialog" :visible.sync="innerVisible" append-to-body&gt; &lt;/el-dialog&gt; &lt;div slot="footer" class="dialog-footer"&gt; &lt;el-button @click="outerVisible = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="innerVisible = true"&gt;打开内层 Dialog&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { outerVisible: false, innerVisible: false }; } } &lt;/script&gt; 作用 将内层 Dialog 的append-to-body属性设置为 true，它就会插入至 body 元素上，从而保证内外层 Dialog 和遮罩层级关系的正确。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ac963da83364261ab05d853145600eb/" rel="bookmark">
			多目标跟踪（MOT）数据集资源整理分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们已经生活在一个被摄像头和视频包围的世界里，从手机、汽车、无人机到各类监控设备，随处可见摄像头的“身影”。据前瞻产业研究院2020年的报告分析，预计到2025年全球摄像头镜头的出货量将超过120亿颗。 面对海量的摄像头及其产生的视频素材，如何利用具有深度学习功能的 AI 技术，高效、智能地处理、挖掘信息，已成为一项非常有价值的课题。
一、目标跟踪简介 视频目标跟踪技术（也称为：目标跟踪、视觉跟踪），作为计算机视觉领域中基础的、重要的研究方向之一，可广泛应用在交通管理、安防监控、自动驾驶、机器人、体育赛事转播等领域，其已成为一大研究热点。
图源：网络
二、目标跟踪分类 ● 根据跟踪的目标数量，目标跟踪任务可分为单目标跟踪（SOT）和多目标跟踪（MOT）；
● 根据背景状态，可分为静态背景下的目标跟踪和动态背景下的目标跟踪；
● 根据摄像头数量，可分为单摄像头跟踪和多摄像头跟踪；
● 根据任务计算类型，可分为在线跟踪、离线跟踪；
更多分类可参考下图：
目标跟踪纵览（图源：参考资料[1]）
其中，多目标跟踪作为计算机视觉中的一项中级任务，仍然是一项具有挑战性的任务，因为它需要同时解决目标检测、轨迹估计、数据关联和重识别问题。另外它也是许多高级任务的基础，如姿态估计、动作识别和行为分析等。
让我们一起来看看。
三、什么是多目标跟踪任务 多目标跟踪与单目标跟踪是一组相对的概念。
单目标跟踪是指，在视频的初始帧画面上框出单个目标，预测后续帧中该目标的大小与位置。该目标始终位于视场中，并且对目标种类无限制。
单目标跟踪示意（图源：网络）
而多目标跟踪是在事先不知道目标数量的情况下，对视频中的行人、汽车、动物等多个目标进行检测并赋予ID进行轨迹跟踪。不同的目标拥有不同的ID，以便实现后续的轨迹预测、精准查找等工作。[2]
多目跟踪示意（图源：网络）
四、多目标跟踪方法步骤 多目标跟踪主要分为以下四个步骤：[3]
1. 对象初始化
首先对各个视频帧中的新出现的对象进行建模，即对象初始化；
2. 检测与特征提取
其次根据建立的模型进行对象检测，获得初始对象序列的特征；
3. 相似度计算
根据得到的特征，在后续帧中重复寻找目标对象进行相似度度量；
4. 数据关联
根据相似度度量结果对目标进行关联，获得一系列的对象轨迹。
五、多目标跟踪任务难点 相对于单目标跟踪，多目标跟踪面临着更加复杂的问题包括频繁的遮挡、轨迹的管理、相似的外观和多目标间的相互影响。
在实际的应用场景中，需要面对存在的各种复杂变化（以行人跟踪为例）：
1. 目标自身的变化
目标的颜色变化（行人的衣服颜色变化），目标的尺度变化（离摄像头的远近）和目标的形态变化（行人的站立、蹲与躺）等。
2. 外界环境的变化
光线明暗的变化、目标所处环境的多样性、目标的消失与出现和目标的遮挡问题。
这些复杂变化会影响跟踪对象与背景环境的区分度，从而进一步影响多目标跟踪算法的跟踪效果和结果的好坏，所以需要恰当地处理这些变化来提高多目标跟踪的准确性。
六、多目标跟踪常用数据集 目前多目标跟踪领域的重要基准是MOTChallenge，作为上传并公布多目标跟踪方法研究成果的公共平台，其拥有最大的公开行人跟踪数据集。[4]
其提供的数据集包括：MOT 15、MOT 16、 MOT 17、MOT 20，这些数据集都提供了训练集的标注，训练集与测试集的检测，以及数据集的目标检测结果，主要侧重于密集场景下行人跟踪任务。
MOT系列数据集的视频序列及其主要属性（图源：参考资料[4]）
另外还有近几年出的TAO数据集，是一个类似COCO的多样化的MOT数据集，其中包含2907个不同环境的高清视频，平均长度半分钟，包含833个类别，比现有的数据集高出一个数量级。
七、多目标跟踪数据集资源 OpenDataLab平台已经上架了多目标跟踪（MOT）系列数据集，提供了丰富的数据集信息、流畅的下载速度，快来体验吧！
· MOT15 https://opendatalab.com/MOT15
· MOT16 https://opendatalab.com/MOT16
· MOT17 https://opendatalab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ac963da83364261ab05d853145600eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e655efb8f20e0cd18b52109160ad319d/" rel="bookmark">
			详细解读：MIT经典的语义分割数据集ADE20K，附下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小伙伴们，乐于分享的OpenDataLab来啦！这次，给大家带来一份ADE20K 数据集的详细使用“攻略”，助大家模型训练一臂之力。
这个由MIT 发布的大型数据集，可用于场景感知、解析、分割、多物体识别和语义理解，不容错过。
一、数据集简介 发布方：MIT CSAIL Computer Vision Group
发布时间：2016
背景：视觉场景的语义理解是计算机视觉的关键问题。尽管社区在数据收集方面做出了努力，但仍然很少有图像数据集涵盖广泛的场景和对象类别，而且缺乏具有用于场景理解的逐像素注释。
简介：ADE20K涵盖了场景、对象、对象部分的各种注释，在某些情况下甚至是部分的部分。有25k张复杂日常场景的图像，其中包含自然空间环境中的各种对象。每个图像平均有19.5个实例和10.5个对象类。
二、数据集详细信息 1. 标注数据量
● 训练集：20210张图像
● 验证集：2000张图像
● 测试集：3000张图像
2. 标注类别
数据集的标注包含三种视觉概念：
● 离散对象（discrete object），它是具有明确定义的形状的事物，例如汽车、人；
● 包含无定形背景区域的东西（stuff），例如草、天空；
● 对象部分（object part），它是某些具有功能意义的现有对象实例的组件，例如头部或腿部。
三种视觉概念共标注类别3169类，其中离散对象和无定形背景区域的东西有2693类。对象部分有476类。
3. 可视化
图1：第一行显示样本图像，第二行显示对象的标注，第三行显示对象部分的标注。颜色方案同时编码对象类别和对象实例，即不同的对象类别具有较大的色差，而来自同一对象类别的不同实例具有较小的色差（例如，第一张图像中的不同人实例具有略微不同的颜色）。
三、数据集任务定义及介绍 1. 场景解析 ● 定义
场景解析是将整个图像密集地分割成语义类，其中每个像素都被分配一个类标签，例如树的区域和建筑物的区域。
● 基准
作者选择 ADE20K 数据集中按其总像素比排名的前150个类别，并构建 ADE20K 的场景解析基准，称为 SceneParse150。
在150个类别中，有35个东西类（即墙壁、天空、道路）和115个离散对象类（即汽车、人、桌子）。150个类的标注像素占数据集所有像素的92.75%，其中无定形背景区域的东西类占60.92%，离散对象类占31.83%。
结果以通常用于语义分割的四个指标报告：
- Pixel accuracy（像素精度）：表示正确分类的像素的比例；
- Mean accuracy（平均准确度）：表示在所有类别中平均正确分类的像素的比例；
- Mean IoU（平均 IoU）：表示预测像素和真实像素之间的交并比，在所有类上平均；
- Weighted IoU（加权IoU）：表示按每个类的总像素比加权的 IoU。
2. 实例分割 ● 定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e655efb8f20e0cd18b52109160ad319d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3244f0a41e069369fd5be665982d6b5/" rel="bookmark">
			java通过TCP实现HL7医疗系统传输协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 开发：java、maven、HAPI、socket、IDEA
测试工具：HAPI testPanel 2.0.1、7Edit
问题记录 句段头不对应导致的读取异常 使用测试工具交互正常
客户端（测试工具）
服务端
连接仪器出现以下问题
客户端 操作历史结果传输（日志）
服务端 接收消息异常
原因： 如上图，抛出异常为大意为 违反MLLP协议-预期字节“11”处于START状态，但为“239”。
刚开始思路不清晰，以为是自己本地版本或者编码的问题，一顿搞，中间问了对方工程师，也以为是版本问题，刚好对方有个中间件版本需要更新，以为是这个原因，结果更新完一试，还是这样。
后来觉着自己对HL7协议还是太不熟悉了，太着急上来就开始搞功能了，于是沉下心有好好熟悉了一下HL7协议的内容。又仔细看了仪器客户端的日志，发现发送的消息前后都有一个字符 展示出来为 如下图的样子：
了解过HL7底层协议的都知道，这两个字符是为了确定消息边界，我称之为句块头、句块尾，各占一个字节，所以千万不要给它认成字符串，类似的还有（相当于回车或换行），
对应的ASC
VT对应句段头，对应的句段头是11，但是怎么会出来个239呢。查自付码表也没有查出来是个什么东西，那么这个239到底是是什么，从哪里来的呢？
可以确定的是，这个239是读取客户端发送过来的信息时候读出来的。这里与客户端交互使用的是第三方的工具包HAPI，通过查看源码可以看出来，HAPI是通过socket与客户端通信的：
关于socket的内容可以自行问度娘，这里不做重点讲解.根据HAPI和仪器与服务端的交互逻辑可以知道，这里使用的是一种面向连接套接字【也成为流格式套接字（Stream Sockets）】。流格式套接字的内部有一个缓冲区（也就是字符数组），通过 socket 传输的数据将保存到这个缓冲区。接收端在收到数据后并不一定立即读取，只要数据不超过缓冲区的容量，接收端有可能在缓冲区被填满以后一次性地读取，也可能分成好几次读取。
也就是说服务端在读取数据的时候会不会是根据自己的设定，并不是一次读一个字符，从而导致判定句段头的时候出错？因为在HAPI TestPanel（HAPI此时工具）中是可以正常读取仪器客户端传送过来的消息的，所以接着扒拉源码…
下图可以看出，HAPI中支持的句段头确实是11，且不是11的时候就会抛出异常，这也正是 违反MLLP协议-预期字节“11”处于START状态，但为“239”异常的原因。
这里大胆猜一下，会不会是仪器客户端 传过来的句段头虽然在文本编辑器中展示的是[VT]，但是它对饮的字节码并不是11？由于没有权限直接进入系统查看仪器的日志，那就用socket自己写了一个服务端，去灵活读取客户端传输过来的信息。服务端代码不贴了就，HL7官方也有对应的demo: java socket 实现HL7服务端 将输入流读取为字符串
*
通过对传输信息的逐个读取，断点调试发现开始读取的时候有空格和特殊字符（乱码），使用测试工具则没有。判定仪器客户端与测试工具客户端传输的规范不一致。这种方式能读取到仪器客户端的内容入下： 进一步确认
偶然发现，向日葵（远程工具）可以通过远程文件跳过仪器的检测系统读取到系统文件，方便了我查看仪器客户端的日志。通过系统日志可以看到，当服务端端使用HAPI 的时候直接抛出异常被客户端接收，连接断开，客户端进行重试，客户端一共进行了五次重试：
客户端发送的内容为：
目测没有问题，那服务端接收到的空格和乱码怎么解释？当我把日志中的内容复制到文本编辑器的时候展示为：
可以发现[VT]和[FS]在文本编辑器中不可见，且开头多出一个不能识别的字符。将客户端发送得消息在粘贴到IDEA看一下：
通过ASC码表知道，正常的[VT]对应的应该是\u000B,这里多出来的不可见字符\uFEFF应该就是读取字段头时候导致239的原因。基于自己的socket服务读取到的句段头字符码是239，因此将句段头改为239后成功读取到仪器客户端发送过来的内容 MSH|^~\\&amp;|||||20220707133720||ORU^R01|1|P|2.3.1||||0||UTF-8 "PID|1|||||||F "OBR|1||1||N|20220622170125|20220622173444||1|1005^1^1||||20220622170125|Serum||||||||||Finished "OBX|1|NM|1|PGⅠ|23.52|ng/mL|-||||F||587367||||0||||2112055C:427 响应客户端 按照规范，服务端接收到消息后应该返回一个ACK格式的MSG，且携带客户端发送信息的ID。消息体也应该包裹在句段头和句段尾之间。官方给出的示例：
示例中将句段头.尾等格式相关的字符设置为了常量，即保持请求跟响应的格式一致。
但是在与仪器客户端的信息交互中，客户端依然提示失败，查看日志并跟工程师沟通，结论为客户端没有收到响应。
汲取之前的教训，将句段头改为正常的格式，再次测试，客户端收到响应并提示操作成功
至此，仪器客户端与服务端信息交互实现。接下来是解析和拼装HL7信息。
参考：
https://saravanansubramanian.com/hl72xjavaprogramming/#step-2-of-8—build-a-simple-tcpip-server-capable-of-receiving-and-echo-ing-of-received-information
https://hapifhir.github.io/hapi-hl7v2/hapi-hl7overhttp/apidocs/index.html
https://blog.csdn.net/weixin_45004203/article/details/125360186
https://hapifhir.github.io/hapi-hl7v2/hapi-testpanel/index.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e808b426907a5c1336129f41c504e0/" rel="bookmark">
			从树莓派系统安装小白到系统SD卡复制克隆高手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了快速复制克隆嵌入式设备，把当前已经调试好的设备的系统做成image系统镜像，无疑是最快捷的。对于树莓派系统来说，属于嵌入式设备，使用树莓派的imager去烧写出系统，然后安装必要的软件，当系统完全设置好之后就可以克隆了，下面讲述整个过程。
1、安装准备 安装操作系统，需要使用树莓派的烧写程序，将SD卡放入读卡器，查到电脑上，当U盘使用
imager下载地址：https://downloads.raspberrypi.org/imager/imager_latest.exe
如果是linux，可以用命令行安装：
sudo apt install rpi-imager 2、安装ubuntu 此次将安装ubuntu，对于这种嵌入式设备，选择ubuntu server no desktop的版本，因为图形桌面太耗费资源，虽然树莓派已经算是比较强的，但是desktop版的系统在树莓派上运行，还是会出现各种问题的。
3、系统设置 3.1、修改系统密码 该版本系统安装好之后，默认的账号密码是ubuntu/ubuntu，第一次登陆会强制修改密码。按照系统引导提示去修改默认密码就可以。
3.2、修改IP地址 树莓派默认的是dhcp配置，嵌入式设备一版都是设置静态IP，这就需要修改配置文件，按照下面的格式写这个配置文件，空格什么的最好都不要错：
sudo vim /etc/netplan/50-cloud-init.yaml
3.3、打开树莓派串口 树莓派默认已经打开uart1，其他的串口需要配置重启才能生效：
sudo vim /boot/firmware/config.txt
打开改文件最后增加如下配置：
dtoverlay=uart2
dtoverlay=uart3
dtoverlay=uart4
dtoverlay=uart5
重启之后你可以看到下面这些设备
3.4、关闭NTP ntp是树莓派提供的一个从互联网自动同步时间的服务，我们如果想让树莓派设定自己想要的时间，那么就需要关闭这个服务即可：
- open:sudo timedatectl set-ntp true - close:sudo timedatectl set-ntp false
3.5、安装必要软件 树莓派的ubuntu安装好之后很多基础的软件都不具备，因此需要手动安装
3.5.1、安装软件时总是报错，可以修改配置文件 系统安装好之后，每次安装软件总是会报一些错误，需要修改如下配置：
sudo vim /etc/needrestart/needrestart.conf
找到这样内容：#$nrconf{ucodehints} = 0;
删掉#，保存退出
3.5.2、安装python2.7 python3并不是完全向下兼容的，有些老项目调用的python函数到python3并不支持，那么就需要安装老版本
sudo apt-get install python2.7
做好符号链接
sudo ln -s /usr/bin/python2.7 /usr/bin/python
3.5.3、安装make sudo apt install make
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e808b426907a5c1336129f41c504e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b76bc337f6405423eac0c592614974c2/" rel="bookmark">
			达梦数据库统计信息和执行计划的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--可参考 DM8_SQL语言使用手册 PDF 手册， 首先，以下对象不支持统计信息： 1. 外部表、 DBLINK 远程表、动态视图、记录类型数组所用的临时表； 2. 所在表空间为 OFFLINE 的对象； 3. 位图索引，位图连接索引、虚索引、 无效的索引、全文索引； 4. 列：BLOB、CLOB 、 TEXT 、IMAGE、 LONGVARBINARY 、 LONGVARCHAR 等列类型。 收集统计信息，可以通过命令和系统函数的方式进行。 第一、通过STAT 命令收集统计信息； 设置表生成统计信息 STAT ON [&lt; 模式名 &gt;.]&lt; 表名 &gt; [GLOBAL]; 举例说明 ： STAT ON SYS.SYSOBJECTS; 收集列、索引生成统计信息 语法格式： STAT &lt; 采样率百分比 &gt; [SIZE &lt; 直方图桶数 &gt;] ON &lt; 统计对象 &gt; [GLOBAL] &lt; 统计对象 &gt; ：：= [&lt; 模式名 &gt;.] &lt;表名 &gt; (&lt; 列名&gt;{,&lt; 列名&gt;}) | INDEX [&lt; 模式名 &gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b76bc337f6405423eac0c592614974c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b17e7ed6bf597ee4d29934ba94d2b77/" rel="bookmark">
			黑马 Spring_day01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring_day01 今日目标
掌握Spring相关概念完成IOC/DI的入门案例编写掌握IOC的相关配置与使用掌握DI的相关配置与使用 1，课程介绍 对于一门新技术，我们需要从为什么要学、学什么以及怎么学这三个方向入手来学习。那对于Spring来说:
1.1 为什么要学? 从使用和占有率看
Spring在市场的占有率与使用率高
Spring在企业的技术选型命中率高
所以说,Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;90%
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Gx5bSvly-1657505762059)(assets/image-20210729171139088.png)]
说明:对于未使用Spring的项目一般都是些比较老的项目，大多都处于维护阶段。
从专业角度看
随着时代发展，软件规模与功能都呈几何式增长，开发难度也在不断递增，该如何解决? Spring可以简化开发，降低企业级开发的复杂性，使开发变得更简单快捷 随着项目规模与功能的增长,遇到的问题就会增多，为了解决问题会引入更多的框架，这些框架如何协调工作? Spring可以框架整合，高效整合其他技术，提高企业级应用开发与运行效率 综上所述，Spring是一款非常优秀而且功能强大的框架，不仅要学，而且还要学好。
1.2 学什么? 从上面的介绍中，我们可以看到Spring框架主要的优势是在简化开发和框架整合上，至于如何实现就是咱们要学习Spring框架的主要内容:
简化开发: Spring框架中提供了两个大的核心技术，分别是:
IOCAOP 事务处理 1.Spring的简化操作都是基于这两块内容,所以这也是Spring学习中最为重要的两个知识点。
2.事务处理属于Spring中AOP的具体应用，可以简化项目中的事务管理，也是Spring技术中的一大亮点。
框架整合: Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如:
MyBatisMyBatis-plusStrutsStruts2Hibernate…… 这些框架中，我们目前只学习了MyBatis，所以在Spring框架的学习中，主要是学习如何整合MyBatis。
综上所述，对于Spring的学习，主要学习四块内容:
(1)IOC,(2)整合Mybatis(IOC的具体应用)，(3)AOP,(4)声明式事务(AOP的具体应用)
1.3 怎么学? 学习Spring框架设计思想 对于Spring来说，它能迅速占领全球市场，不只是说它的某个功能比较强大，更重要是在它的思想上。 学习基础操作，思考操作与思想间的联系 掌握了Spring的设计思想，然后就需要通过一些基础操作来思考操作与思想之间的关联关系 学习案例，熟练应用操作的同时，体会思想 会了基础操作后，就需要通过大量案例来熟练掌握框架的具体应用，加深对设计思想的理解。 介绍完为什么要学、学什么和怎么学Spring框架后，大家需要重点掌握的是:
Spring很优秀，需要认真重点的学习Spring的学习主线是IOC、AOP、声明式事务和整合MyBais 接下来，咱们就开始进入Spring框架的学习。
2，Spring相关概念 2.1 初识Spring 在这一节，主要通过以下两个点来了解下Spring:
2.1.1 Spring家族 官网：https://spring.io，从官网我们可以大概了解到：
Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。Spring并不是单一的一个技术，而是一个大家族，可以从官网的Projects中查看其包含的所有技术。 Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。
Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。
Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫全家桶，如下图所示
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H4Aawaoh-1657505762063)(assets/image-20210729171850181.png)]
说明:
图中的图标都代表什么含义，可以进入https://spring.io/projects网站进行对比查看。
这些技术并不是所有的都需要学习，额外需要重点关注Spring Framework、SpringBoot和SpringCloud:
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8V7ljoEB-1657505762064)(assets/1629714811435.png)]
Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。SpringCloud:这个是用来做分布式之微服务架构的相关开发。 除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData,SpringSecurity等，这些都可以被应用在我们的项目中。我们今天所学习的Spring其实指的是Spring Framework。
2.1.2 了解Spring发展史 接下来我们介绍下Spring Framework这个技术是如何来的呢?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b17e7ed6bf597ee4d29934ba94d2b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2e71bf362ffe8f75a318deea613455/" rel="bookmark">
			tcp支持浏览器websocket协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tcp支持浏览器websocket协议 一个io它是怎么一种情况，一个客户端连接一个服务器，一个客户端一个连接，大家时刻在做服务器，都是时刻抓住这样一个点，
就是说一个客户端在服务端会有一个网络io，一个客户端在服务端会有一个网络io，之前用epoll来管理这些io我们写了一个版本写了一个版本是怎么做的。
网络io到epoll的实现,epoll在实现的中间它有哪些问题以及如何去封装，然后再一层一层的跟大家实现的这个反应堆模式，就是以大量的网络io，然后每一个网络io它对应的事件会有对应的回调函数，
网络io对应的事件有对应的回调函数，
那这个网络io对应的事件是说的哪些事件？
就是所说的epollin/可读,epollout可写，
对应的回调函数怎么理解呢，就是epollin的时候我们调用recv_cb
然后epollout我们调send_cb，
当然还有与之对应的listen,我们可以调用accept_cb，封装完了之后，它的封装性更强，
它的封装性更强好吧，这是跟大家讲的reactor就这么一个模式，
在reactor的基础上面我们看看协议怎么做，基于websocket,就是因为协议很简单，它大体上的东西,核心的元素都会有
一个客户端对应一个连接，一个连接是怎么管理的呢就是通过epoll管理，一个连接我们对应的数据存储在哪呢？
服务器所生成的一个fd我们放到sockitem
如果客户端给服务器发数据，epoll检测到io可读，就会调用sockitem里面对应回调函数。
如果是收到数据那么有两种情况：一个io对应可读或者可写
读的数据发送的数据都放到buffer里面
接收
发送
那么分析这个代码的时候逻辑就会有很大的改变了
recv_cb里面我们接收到的数据我们该怎么去发送，比如回声服务器接收数据就返回什么数据的话我们该怎么做？
我们不需要去关注在什么时候调用send，我们只要关注一点这个sendbuffer里面有没有数据就ok了，只要关注这样一点就ok了，它会自动发送，
发送是怎么发送的呢？
两步就ok
我们现在根本就不用关注他的发送，只要把send_cb这一步做好了
libevent源码也是这样设计的有一个buffer，把数据放到里面就ok了，
我们只是做到了接收与发送，要是有协议呢？
接下来我们如何把websocket协议加进去？
首先第一步要考虑的是websocket的握手，
关于websocket握手是怎么一回事
websocket使用在哪？
为什么会有一个握手？
主要它是用来浏览器跟服务器做一个长链接，什么意思？我们打开CSDN有个登录，我们看到这边我们点击登录，现在这时候出来一个微信二维码，我们现在通过微信扫描二维码登录
那么这个功能与我们的websocket有什么关系？
前端页面，二维码是前端的，现在我们通过微信的那个微信的客户端，我们扫码扫一下这个二维码，扫完之后把对应的二维码，传到微信的服务器，然后微信的服务器，进行回调到csdn的服务器，然后前端扫码完之后为什么会有一个跳转？
就是这步，在csdn的服务器会主动推送一个数据，csdn的服务器，主动发数据给网页前端。
那在这一步是服务器主动发的，主动发的过程中间，就是采用了websocket协议
服务器主动发数据给浏览器的时候，可以选择websocket，但是websocket不是唯一的解决方案，
1.网页聊天，即时通讯
2.网页弹幕
3.股票
单独使用tcp没有那么好做，websocket是基于tcp，
了解websocket的使用场景后思考一下websocket是怎么建立的？
weisocket协议和客户端之间是怎么一种反思？
这个连接请大家注意，这个连接是在TCP建立后连接的基础上面，客户端和服务器已经有一个连接了，然后客户端给服务器发送一段应用数据，这个数据叫做握手数据，
相当于是这样一个客户端和服务器之间建立好的连接，现在这个客户端发送一段数据
首先发的第一步数据验证双方是否合法，这个数据叫做握手数据，
与http协议如此相似，
客户端先握手成功之后在服务器发送消息
握手过程
websocket协议由两部分组成一部分握手，另一部分通信。
就是在recv_cb里面我们怎么接收？我们怎么去区分他是握手数据还是通信数据？
需要引入一个状态机，
那么这个状态机的状态我们保存在哪里？每一个连接里面应该都有一个状态机
区分accept_cb和recv_cb
握手的状态怎么进入通信的状态？
刚刚讲了状态机，横向思考一下，其实HTTP协议也需要有一个状态机
在http协议接收的时候它也有握手，同样它有它的header还有它的body
header和body里面都有自己对应的资源，就是方便理解为什么nginx里面有一个状态机的实现？
实现recv_cb的时候我们不能通过具体的数据去判断它是不是头。
第一个状态处理完了之后去处理下一个状态，状态机就是这样。
websocket通信的时候它的协议头是什么样的？
如果以后自己基于TCP做协议的时候，可以看到有三个核心的点
1.操作码，fin是不是终止的包是不是数据包是不是握手包
2.包长度，分包粘包怎么解：可以选择包长度或者分隔符，这里websocket选择的就是包长度，
3.不想传输明文可以加一个mask–&gt;key 主要与payload做一个可逆的计算得出data
4.payload data数据是纯应用层的数据，就可以采用json/xml，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2e71bf362ffe8f75a318deea613455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce582520d89bd12e7accc503ff68c4c6/" rel="bookmark">
			【校招VIP】java语言考点之线程池相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考点介绍：
线程池相关内容在大厂面试中出现频率很高。线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。
本期分享的java语言考点之线程池相关，分为试题、文章以及视频三部分。
答案详情解析和文章内容点击下方链接即可查看！
一、考点题目 1.Java线程池的工作流程
解答：线程池中的执行流程：（1）当线程数小于核心线程数的时候，使用核心线程数。（2）如果核心线程数小于线程数，就将多余的线程放入任务队列（阻塞队列）中（3）当任务队列（阻塞队列）满的时候，就启动最大线程数……
2.为什么要有线程池？
解答：(1) 降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。(2) 提高响应速度。 当任务到达……
3.线程池有哪几类？有什么区别？有哪些参数？拒绝策略有哪些（阿里面试题）？
解答：常用的JAVA线程池有以下几种类型：1、newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空……
4.请列举一下启动线程有哪几种方式，之后再说明一下线程池的种类都有哪些？
解答：要启动的可以分为两类：返回结果和不返回结果。对于这两种，也分别有两种启动线程的方式：1）继承Thread类，重载run()……
5.创建线程池的几个核心构造参数
解答：// Java线程池的完整构造函数，public ThreadPoolExecutor(，int corePoolSize, // 线程池长期维持的最小线程数，即使线程处于Idle状态，也不会回收……
（答案点击下方链接查看哦）
二、考点文章 1.Java线程池的使用
在Java中，我们可以利用多线程来最大化地压榨CPU多核计算的能力。但是，线程本身是把双刃剑，我们需要知道它的利弊，才能在实际系统中......
2.线程池，这一篇或许就够了
创建/销毁线程伴随着系统开销，过于频繁的创建/销毁线程，会很大程度上影响处理效率，例如：记创建线程消耗时间T1，执行任务消……
3.击穿线程池面试题：3大方法，7大参数，4种拒绝策略
多线程知识是Java面试中必考的点。本文详细介绍——线程池。在实际开发过程里，很多IT从业者使用率不高，也只是了解个理论知识，和背诵各种……
三、考点视频 1.多线程执行下列代码后的值
本题是一道笔试题，属于偏复杂、对时间要求高的题型。主要是具化多线程，把临界点和对应的多线程起始位置画出来，需要细心和时间。建议……
移动端链接：https://m.xiaozhao.vip/dTopic/detail/497
PC端链接：https://xiaozhao.vip/dTopic/detail/497
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9f63f0d5d74956361daa9410d93e7f/" rel="bookmark">
			SpringMVC常见面试题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC常见面试题总结 1. 什么是SpringMVC? SpringMVC是一种基于 Java 的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于Spring框架的一个模块。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。 2.什么是MVC模式？ MVC的全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。V即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。M即model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。C即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 3.SpringMVC的执行流程？ 用户点击某个请求路径，发起一个request请求，此请求会被前端控制器处理。前端控制器请求处理器映射器去查找Handler。可以依据注解或者XML配置去查找。处理器映射器根据配置找到相应的Handler(可能包含若干个Interceptor拦截器)，返回给前端控制器。前端控制器请求处理器适配器去执行相应的Handler处理器（常称为Controller）。处理器适配器执行Handler处理器。Handler处理器执行完毕之后会返回给处理器适配器一个ModelAndView对象（SpringMVC底层对象，包括Model数据模型和View视图信息）。处理器适配器接收到Handler处理器返回的ModelAndView后，将其返回给前端控制器。前端控制器接收到ModelAndView后，会请求视图解析器（ViewResolver）对视图进行解析。视图解析器根据View信息匹配到相应的视图结果，反馈给前端控制器。前端控制器收到View具体视图后，进行视图渲染，将Model中的模型数据填充到View视图中的request域，生成最终的视图(View)。前端控制器向用户返回请求结果。 4.Spring MVC的主要组件？ 前端控制器：其作用是接收用户请求，然后给用户反馈结果。它的作用相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。处理器映射器：其作用是根据请求的URL路径，通过注解或者XML配置，寻找匹配的处理器信息。处理器适配器：其作用是根据映射器处理器找到的处理器信息，按照特定规则执行相关的处理器（Handler）。处理器：其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至ModelAndView对象中。视图解析器：其作用是进行解析操作，通过ModelAndView对象中的View信息将逻辑视图名解析成真正的视图View（如通过一个JSP路径返回一个真正的JSP页面）。视图：View是一个接口，实现类支持不同的View类型（JSP、FreeMarker、Excel等） 5.SpringMVC有哪些优点？ SpringMVC本身是与Spring框架结合而成的，它同时拥有Spring的优点(例如依赖注入DI和切面编程AOP等)。SpringMVc提供强大的约定大于配置的契约式编程支持，即提供一种软件设计范式，减少软件开发人员做决定的次数，开发人员仅需规定应用中不符合约定的部分。支持灵活的URL到页面控制器的映射。可以方便地与其他视图技术(JSP、FreeMarker等)进行整合。由于SpringMVC的模型数据往往是放置在Map数据结构中的，因此其可以很方便地被其他框架引用。拥有十分简洁的异常处理机制。可以十分灵活地实现数据验证、格式化和数据绑定机制，可以使用任意对象进行数据绑定操作。支持RestFul风格。 6、SpringMVC怎么样设定重定向和转发的？ 请求转发与重定向的区别 请求转发在服务器端完成的；重定向是在客户端完成的。请求转发的速度快；重定向速度慢。请求转发的是同一次请求；重定向是两次不同请求。请求转发不会执行转发后的代码；重定向会执行重定向之后的代码。请求转发地址栏没有变化；重定向地址栏有变化。请求转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成。 SpringMVC设定请求转发 在返回值前面加"forward:"。
@RequestParam("/login") public String redirect(User user){ if{ //登录成功... }else{ //登录失败，转发到登录页面 return "forward:tologin"; } } SpringMVC设定重定向 在返回值前面加"redirect:"。例如我们在登录的时候，登录失败会重定向到登录页面。
@RequestParam("/login") public String redirect(User user){ if{ //登录成功... }else{ //登录失败，重定向到登录页面 return "redirect:tologin"; } } 7、 SpringMVC常用的注解有哪些？ @RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。
@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。
@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。
8、SpingMvc中的控制器的注解一般用哪个？有没有别的注解可以替代？ 答：一般用@Controller注解，也可以使用@RestController，@RestController注解相当于@ResponseBody ＋ @Controller，表示是表现层，除此之外，一般不用别的注解代替。
9、springMVC和struts2的区别有哪些? （1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。
（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。
（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。
10、如何解决POST请求中文乱码问题，GET的又如何处理呢？ （1）解决post请求乱码问题：在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；
&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a9f63f0d5d74956361daa9410d93e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ea34e7081148917ebc52b3c804ac0d/" rel="bookmark">
			Executors.newScheduledThreadPool(num)；创建固定大小 线程数 支持定时和周期性任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		周期执行：scheduleAtFixedRate()
方法功能：
scheduleAtFixedRate(command, 2, 4, second):
第一次执行后延迟2秒后 执行第二次，然后每隔4秒执行一次，
如果执行耗时大于等待时间，那么将会在任务执行完成后立马开始执行下一轮任务。
如果执行耗时小于等待时间，那么将会在任务执行完成后等待【等待时间-执行耗时】，然后再执行下一轮任务
ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(1);//创建固定大小 线程数 支持定时和周期性任务 ThreadPoolExecutorDemo1 poolExecutorDemo1=new ThreadPoolExecutorDemo1(1); //第一次执行后延迟2秒后 执行第二次，然后每隔4秒执行一次 newScheduledThreadPool.scheduleAtFixedRate(poolExecutorDemo1, 2, 4, TimeUnit.SECONDS); newScheduledThreadPool.submit(poolExecutorDemo1); 结果
线程池中正在运行的线程:2022-07-10 09:21:51 线程池中运行的线程结束:2022-07-10 09:21:52 线程池中正在运行的线程:2022-07-10 09:21:53 线程池中运行的线程结束:2022-07-10 09:21:54 线程池中正在运行的线程:2022-07-10 09:21:57 线程池中运行的线程结束:2022-07-10 09:21:58 线程池中正在运行的线程:2022-07-10 09:22:01 线程池中运行的线程结束:2022-07-10 09:22:02 线程池中正在运行的线程:2022-07-10 09:22:05 线程池中运行的线程结束:2022-07-10 09:22:06 周期执行：scheduleWithFixedDelay()
方法功能：
newScheduledThreadPool.scheduleWithFixedDelay(poolExecutorDemo1, 5, 4, TimeUnit.SECONDS);
第一次运行5秒后，开始运行第二次，在第二次结束后 等待4秒，运行第3次，以此类推。这是从第二次开始，在上次运行结束后等待4秒，开始运行下一次。
ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(1);//创建固定大小 线程数 支持定时和周期性任务 ThreadPoolExecutorDemo1 poolExecutorDemo1=new ThreadPoolExecutorDemo1(1); newScheduledThreadPool.scheduleWithFixedDelay(poolExecutorDemo1, 5, 4, TimeUnit.SECONDS); newScheduledThreadPool.submit(poolExecutorDemo1); 结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ea34e7081148917ebc52b3c804ac0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314e710c23db0084bba9aad3b2c3dcb3/" rel="bookmark">
			STM32F103C8T6定时器通道对应的引脚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c278b7d40e42ce6273dee9dddb4a31a/" rel="bookmark">
			springboot中websocket服务怎么调用其他类的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 之前有写过一个springboot整合websocket的博客（SpringBoot 集成websocket_清泉影月的博客-CSDN博客），最开始的使用场景就是用websocket发消息给其他长连接；后来新增了一个需求：长连接的某些信息要保存到数据库。想着应该比较简单，写个类方法注入到websocket服务里面调用就行了，结果发现报错，本地调试发现注入的类居然是个null。研究了一番，处理起来就是：启动类启动时把上下文直接配置到 websocket的服务里面，websocket服务调用其他类方法时从上下文中获取。
一、启动类设置上下文到 websocket @SpringBootApplication public class TableApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(TableApplication.class, args); WebSocketServer.setApplicationContext(context); } } WebSocketServer是websocket的服务类。
二、websocket服务类调用其他类方法 websocket服务类新增以下配置，跟启动类相呼应
public class WebSocketServer { private static ApplicationContext applicationContext; public static void setApplicationContext(ApplicationContext context) { applicationContext = context; } } websocket服务类调用其他类方法样例如下：
private void saveInfoToDb(WebsocketMsg websocketMsg) { SocketTableConnService socketTableConnService = applicationContext.getBean(SocketTableConnService.class); socketTableConnService.saveInfoToDb(websocketMsg); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfe4c376f7a6e98e9c84cf82e9facee/" rel="bookmark">
			Elasticsearch和MongoDB对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Elasticsearch和MongoDB对比关于 ElasticsearchElasticsearch应用场景 关于 MongoDBMongoDB优点mongodb适用场景 Elasticsearch和MongoDB对比Elasticsearch和MongoDB 开源许可协议 参考 Elasticsearch和MongoDB对比 关于 Elasticsearch 官网：https://www.elastic.co/cn/elasticsearch/
Elastic is the leading platform for search-powered solutions. We accelerate results that matter.
Elastic是搜索解决方案的领先平台。我们加速了重要的结果。
ElasticSearch(简称ES)是一个开源的高扩展的分布式全文检索引擎;它可以近乎实时的存储、检索数据;本身扩展性很好,可以扩展到上百台服务器;可以处理PB级别的数据。 是当前流行的企业级搜索引擎。
Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。
官方说明：
Elasticsearch 是什么？
简单来说，我们的目标是帮助每个人更快地找到所需内容，从需要通过内网获取文档的员工，到在网上购物寻找适合自己鞋子的客户。 但从更技术的角度来说，大致描述如下：
Elasticsearch 在 Apache Lucene 的基础上开发而成，由 Elasticsearch N.V.（即现在的 Elastic）于 2010 年首次发布。Elasticsearch 以其简单的 REST 风格 API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件；Elastic Stack 是一套适用于数据采集、扩充、存储、分析和可视化的免费开源工具。人们通常将 Elastic Stack 称为 ELK Stack（代指 Elasticsearch、Logstash 和 Kibana），目前 Elastic Stack 包括一系列丰富的轻量型数据采集代理，这些代理统称为 Beats，可用来向 Elasticsearch 发送数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfe4c376f7a6e98e9c84cf82e9facee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2409bfb4b836bb901f1005625966e10/" rel="bookmark">
			【Linux学习笔记】16-网络协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过计算器demo初识协议 https://gitee.com/ipengx1029/linux101/tree/master/lesson34-protocol
二、HTTP协议 1、http协议初识 2、研究http的request 1、请求报头 特点：
以行为单位的消息内容陈列除了第一行，其余都是name:value的形势最后有一个空行
每一次协议都必须解决两个问题：
1、将报头和有效载荷进行分离（解包）
2、将自己的有效载荷交付给上层协议（分用）
空行可以用来将有效载荷和报头进行分离！！！
3、http的response 4、利用HTTP返回html网页 https://gitee.com/ipengx1029/linux101/tree/master/lesson35
http报头错误怎么办？：每个浏览器对于http支持是不一样的，因此在正常返回时把状态码填成404，有些浏览器也是可以显示的。
404属于客户端错误
5、3XX—重定向 301：永久重定向，会更新client端的书签里的目标网址地址
302、307：临时重定向
学校西门有家酸辣粉，因为修路，搬到了东门，他们在老地址上挂了一个牌子说：临时搬去东门；我们去西门看到这个消息后就跑去东门吃了，那么因为告诉我们是临时的，那我们下次还是会去西门看看有没有搬回来。 但是后来因为某种原因永久搬到了东门，在原来老地址挂个牌子说永久搬到东门，那我们心里对于这家酸辣粉店的地址认知就改变到了东门（更新书签），以后就全到东门去了。
location：搭配3xx状态码，告诉client接下来该去哪儿访问
可以分两次分别返回状态行和响应报头，因此TCP是基于字节流的
6、请求方法 1、GET 2、POST 7、Cookei和Session 报头添加Set-Cookie选择
请求一次后收到cookie后再次请求，请求报头会携带cookie字段
1、cookei 2、session 8、https 背景知识 1：
2：3：
4：
一段长文本，通过哈希算法提取出一小段文本，叫做摘要；对摘要进行特定的加密，形成数据指纹
1、对称加密 2、非对称加密 3、非对称加密解密（密钥协商阶段）+对称加密解密（通信加密阶段） 版本一
client发起请求，进行TLS握手，server自己有一套公钥+私钥，把公钥发给client，client使用公钥加密随机生成的对称密钥发给server，srever用私钥进行解密得到对称密钥。
但是这种方法存在危险！！！
server向client发送公钥的过程可能会被劫持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b48c6897f27c51edee549ffd7db185a/" rel="bookmark">
			Spring data JPA入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关系型数据库和SQL一直是数据持久化领域的首选方案。尽管近年来涌现了许多可选的数据库类型，但是关系型数据库依然是通用数据存储的首选，而且短期内不太可能撼动它的地位。
在处理关系型数据的时候，Java开发人员有多种可选方案，其中最常见的是JDBC和JPA。现在实际业务开发中大多数人使用 myatis框架，当然spring data JPA使用的也不少。尽管JDBC和spring JdbcTemplate实际开发为了效率不会使用，但仍有必要了解。
jdbcTemplate入门 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 例子 controller @RestController @RequestMapping("category") public class CategotyController { @Resource private CategoryService categoryService; @GetMapping("/{id}") public Category findOne(@PathVariable("id") int id){ return categoryService.findOne(id); } @GetMapping("/all") public Iterable&lt;Category&gt; findAll(){ return categoryService.findAll(); } } service @Service public class CategoryService { @Autowired private JdbsCategaryRepository categaryRepository; public Iterable&lt;Category&gt; findAll(){ return categaryRepository.findAll(); } public Category findOne(int id){ return categaryRepository.findOne(id); } } dao dao层接口
public interface CategoryRepository { Iterable&lt;Category&gt; findAll(); Category findOne(int id); } 持久层实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b48c6897f27c51edee549ffd7db185a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1218f7e777ba9fe084a9fd7748ef1dc3/" rel="bookmark">
			Cluster &amp; Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统解决主要问题之一就是如何在一台机器上调度硬件资源，比如为一个进程分配cpu、gpu、存储资源等，使得进程可以高效、按照预期地完成运行；
云和互联网解决的主要问题之一是如何在多台机器之间调度硬件资源or调度信息资源，这就产生了更丰富架构，比如可以从服务器获取信息资源（收到服务器带宽限制下载比较慢），也可以使用P2P方式将文件分成n块（ torrent文件存储分成的每块的哈希值，以对下载的数据进行校验；Tracker地址来识别哪些客户端存储着需要的文件），在各个客户端之间并行地下载不同的块（各块之间无下载先后的要求），随后组装。
当单独机器的硬件不足以进行最小任务的调度时，期望可以把独立的机器链接，使得多台机器硬件像一台机器一样进行调度，这样就形成cluster（集群）；比如GPU集群是把很多GPU放到一个资源池里调度、分配使用；gpfs cluster是把存储设备放到一个资源池里可以供一起使用。
有时任务比较小，希望能够把独立的硬件隔离拆分使用，这时就出现VM(虚拟机)以及Docker。
Docker linux中进行开发需要按照各种库，经常遇到在一台机器上开发完，到另一台机器上复现需要重新配置环境甚至由于环境配置问题无法正常运行。Docker是把应用和依赖库打包，然后可以发布到任何linux机器上运行，避免再其他linux机器上重新再配置环境或无法复现。
Docker: build, share, and run modern applications
Dockerfile是文本文件，里面包含一系列命令，用来创建镜像，每条命令构建一层镜像。注意：Docker是以远程调用形式在服务端（Docker 引擎）构建的， docker命令提供的是客户端工具与服务端的Docker引擎交互。
docker build -f /path/Dockerfile 参考：Dockerfile 详解_万wu皆可爱的博客-CSDN博客_dockerfile
Image即Dockerfile生成的镜像，包含了要部署的app及其所关联的所有库。
Image又可以创建多个Container，运行着部署的app。
Kubernetes 即k8s用于调度容器，对容器进行生命周期管理等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e1442d0f25af007304a231750aa4fd/" rel="bookmark">
			二分查找及相关算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找是很重要的一个查找算法，直接上题目
题目一：给定一个数组，和一个元素，判断该元素是否在数组中，如果在，则返回元素在数组中的下标，不在数组中就返回 -1 使用二分查找，二分查找的好处：时间复杂度为 log(n)。
public static int binarySearch(int[] nums, int target) { if (nums == null || nums.length == 0) { return -1; } int left = 0; int right = nums.length - 1; int mid = 0; while (left &lt;= right) { mid = left + (left + (right - left)&gt;&gt;1); if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; } 以上就是二分查找最基本的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e1442d0f25af007304a231750aa4fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c27e5f904ec17d44826ce6f9938cf1d/" rel="bookmark">
			DAS\NAS\SAN存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DAS(Direct Attached Storage)直接通过usb或Thunderbolt直接连接电脑或服务器以拓展其存储；
NAS(Network Attached Storage)是链接到网络的存储设备，可以供不同的client共享数据，其操作系统往往是专门为存储功能裁剪和优化的操作系统，实现Storage + File system，是file-level protocols。
GPFS+SAN+共享磁盘方案：其中a. SAN(Storage Area Network)是存储网络，用来从server端访问存储设备（比如disk array或tape libraries），使得对于操作系统而言就像是直接挂载DAS效果一样（当做本地目录使用），SAN是是block-level protocols。但SAN不提供file system，file system是放在client端实现的; b. client端可以部署GPFS(General Parallel File System), 是IBM提供的解决方案，集群中的节点可以并发访问文件系统里的数据，使用条带化读写（将数据分成条带并行写入到GPFS下的所有磁盘，保证GPFS下所有磁盘的I/O负载时均衡的）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90851d7b410ebfbed2b711c65cdd137/" rel="bookmark">
			SQL中的if-else判断语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL中的if-else判断语句 众所周知，if-else判断在任何地方都很有用，在SQL语句中，"CASE WHEN … THEN … ELSE … END"语句可以用在增删改查各类语句中。
修改判断 给个情景：妇女节大回馈，2020年注册的新用户，所有成年女性账号送10元红包，其他用户送5元红包，自动充值。
示例语句如下：
-- 送红包语句 UPDATE users_info u SET u.balance = CASE WHEN u.sex ='女' and u.age &gt; 18 THEN u.balance + 10 ELSE u.balance + 5 end WHERE u.create_time &gt;= '2020-01-01' 查询判断 有个学生高考分数表，需要将等级列出来，650分以上是重点大学，600-650是一本，500-600分是二本，400-500是三本，400以下大专；
原测试数据如下：
查询语句：
SELECT *,case when total_score &gt;= 650 THEN '重点大学' when total_score &gt;= 600 and total_score &lt;650 THEN '一本' when total_score &gt;= 500 and total_score &lt;600 THEN '二本' when total_score &gt;= 400 and total_score &lt;500 THEN '三本' else '大专' end as status_student from student_score; 指定数据快照或备份 如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f90851d7b410ebfbed2b711c65cdd137/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a402be728ef3aa572227e0fde94a140/" rel="bookmark">
			Java解析剑指offer链表篇(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.链表的回文结构
1、题目要求
2、基本思路
（1）、用常规方法解决
（2）、利用Stack求解
3、代码实现
（1）、常规方法
（2）、Stack
二、相交链表
1、题目要求
2、题目思路
3、代码实现
三、环形链表
1、题目要求
来源：力扣（LeetCode）2、题目思路
3、代码实现
四、求环的入口
1、题目要求
2、题目思路
3、代码实现
一.链表的回文结构 1、题目要求 对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。给定一个链表的头指针A，请返回一个bool值，代表其是否为回文结构。保证链表长度小于等于900。
链表的回文结构_牛客题霸_牛客网 (nowcoder.com)
2、基本思路 首先我们先要弄清楚回文结构是什么意思?
回文结构就类似于一个山峰,有一个顶峰然后两边对称.
这就是一个回文结构，我们不难发现这个结构左边和右边都是对称的。
（1）、用常规方法解决 本题是判断一个链表是否为回文结构， 因此我们需要从链表的头和尾同时遍历然后比较是否相等，假如全部相等那么我们返回true，否则返回false。
首先我们拿到的是一个单向链表，我们需要找到他的中间结点，然后从中间节点往后开始逆置，从而实现从后面结点和头结点开始遍历链表是否为回文结构。
假如这个是我们的目标链表,首先我们可以利用fast和slow结点来找到我们的中间结点，而我们的slow也就是中间结点
接下来我们就需要逆置slow后面的链表即可,这时候我们的slow以及成为了尾结点
我们再利用head和slow来进行比较各自的val值是否相同，但是我们需要思考，假如我们的链表尾偶数怎么办？
我们不难发现其实为偶数的时候我们可以利用head.next == slow来判断最后的结果。这样就解决了这个问题。
（2）、利用Stack求解 这个题我们可以利用栈来求解，首先我们需要遍历一遍链表,得到相应的链表长度,然后将链表的前半段入栈,因为栈的特性为先进后出,所以我们可以用后半段的链表结点依次与栈顶结点的元素比较,最后达成一个判断是否回文的效果
3、代码实现 （1）、常规方法 public boolean chkPalindrome(ListNode head) { if(head == null){ return true; } ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null){ fast = fast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a402be728ef3aa572227e0fde94a140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7449222caf0faf4feb9050608e11df19/" rel="bookmark">
			数据治理（十五）：Ranger管理Hive安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Ranger管理Hive安全
一、配置HiveServer2
1）在Hive服务端配置hive-site.xml
2）在每台Hadoop 节点配置core-site.xml,记得发送到所有节点
3）重启HDFS ，Hive ，在Hive服务端启动Metastore 和 HiveServer2服务
4）在客户端通过beeline连接Hive
二、安装Ranger-hive-plugin
1）远程发送编译好的“hive-plugin”到node1节点“/software”目录下，并解压
2）配置“install.properties”文件
3）执行“enable-hive-plugin.sh”脚本启动hive插件
三、配置Ranger连接Hive服务
1）启动HDFS，启动Hive、Hive MeateStore、Hive Server2
2）在Ranger页面中配置Hive
3）连接测试是否可以jdbc方式连接上Hive
四、Ranger对Hive用户进行权限管理
Ranger管理Hive安全 一、配置HiveServer2 访问Hive有两种方式：HiveServer2和Hive Client，Hive Client需要Hive和Hadoop的jar包，配置环境。HiveServer2使得连接Hive的Client从Yarn和HDFS集群中独立出来，不需要每个节点都配置Hive和Hadoop的jar包和一系列环境。
Ranger管理Hive权限只能针对HiveServer2 jdbc方式连接，所以这里需要配置HiveServer2。
配置HiveServer2步骤如下：
1）在Hive服务端配置hive-site.xml #在Hive 服务端 $HIVE_HOME/conf/hive-site.xml中配置： &lt;!-- 配置hiveserver2 --&gt; &lt;property&gt; &lt;name&gt;hive.server2.thrift.port&lt;/name&gt; &lt;value&gt;10000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt; &lt;value&gt;192.168.179.4&lt;/value&gt; &lt;/property&gt; &lt;!-- 配置hiveserver2使用的zookeeper --&gt; &lt;property&gt; &lt;name&gt;hive.zookeeper.quorum&lt;/name&gt; &lt;value&gt; node3:2181,node4:2181,node5:2181&lt;/value&gt; &lt;/property&gt; 注意：“hive.zookeeper.quorum”搭建hiveserver2HA使用配置项，可以不配置，如果不配置启动hiveServer2时一直连接本地zookeeper,导致大量错误日志（/tmp/root/hive.log），从而导致通过beeline连接当前node1节点的hiveserver2时不稳定，会有连接不上错误信息。
2）在每台Hadoop 节点配置core-site.xml,记得发送到所有节点 &lt;!-- 配置代理访问用户，如果不配置下列信息 hive的jdbc连接会报错 --&gt; &lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; 3）重启HDFS ，Hive ，在Hive服务端启动Metastore 和 HiveServer2服务 [root@node1 conf]# hive --service metastore &amp; [root@node1 conf]# hive --service hiveserver2 &gt; /root/hiveserver2_log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7449222caf0faf4feb9050608e11df19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f424ce8d6c1be78ecd2a1714a78633/" rel="bookmark">
			easyExcel导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.简介
1 官方网站
2 EasyExcel特点
3.相比于poi
4.EasyExcel依赖
二.实际应用
1.编写ExcelUtils工具类
2.编写需要导出的dto类
@ExcelProperty注解
业务层代码
三.总结
开发中总结
一.简介 1 官方网站 GitHub - alibaba/easyexcel: 快速、简洁、解决大文件内存溢出的java处理Excel工具
快速开始：EasyExcel（文档已经迁移） · 语雀
2 EasyExcel特点 Java领域解析、生成Excel比较有名的框架有Apache poi、jxl等。但他们都存在一个严重的问题就是非常的耗内存。如果你的系统并发量不大的话可能还行，但是一旦并发上来后一定会OOM或者JVM频繁的full gc。
EasyExcel是阿里巴巴开源的一个excel处理框架，以使用简单、节省内存著称。EasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。
EasyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）
3.相比于poi 工具上手难易程度POI比较难（需要对源码有所研究 需要写workbook），使用完必须手动关闭流easyExcel简单只需要提供数据和模板，不需要关闭流 4.EasyExcel依赖 &lt;!-- easyexcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.7&lt;/version&gt; &lt;/dependency&gt; 二.实际应用 在我们世家开发中要应用的导出Excel文件,有可能跟跟大家的不同
1.编写ExcelUtils工具类 核心代码
/** * 导出Excel到web * * @param response 响应 * @param excelName Excel名称 * @param sheetName sheet页名称 * @param clazz Excel要转换的类型 * @param data 要导出的数据 * @throws Exception */ public static void export2Web(HttpServletResponse response, String excelName, String sheetName, Class clazz, List data) throws Exception { response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f424ce8d6c1be78ecd2a1714a78633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28186dd44e68d7cc66e307a9e5432183/" rel="bookmark">
			SpringBoot的消息转换器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们制作Web项目时,有时候会遇到Long型长度超过16位的数字,我们的页面就会丢失一定的精度,
例如,我自己尝试了效果:
这里我想着通过员工id禁用员工,代码如下:
后台运行结合We页面进行禁用操作后 这里运行后的结果却不是我们想要的结果,正常情况的是账号状态应该呈现禁用状态,查了数据库
id为1545396580193001474
可是后端数据传到前端数据的id值:1545396580193001500
出现这样的结果的大多因数是Long类型长度超过16位
出现这样的解决方案:
1.配置类转换器类JacksonObjectMapper
:
public class JacksonObjectMapper extends ObjectMapper { public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd"; public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss"; public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss"; public JacksonObjectMapper() { super(); //收到未知属性时不报异常 this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); //反序列化时，属性不存在的兼容处理 this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); SimpleModule simpleModule = new SimpleModule() .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))) .addSerializer(BigInteger.class, ToStringSerializer.instance) .addSerializer(Long.class, ToStringSerializer.instance) .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28186dd44e68d7cc66e307a9e5432183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e9fe866d195cc03e6bcb1482f74b22/" rel="bookmark">
			MySql使用存储过程开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 废 话一、Navicat for MySQL1.1 连接数据库1.2 查询数据库1.2.1 打开数据库连接1.2.2 最简单的查询数据 二、创建存储过程2.1 新建存储过程2.2 编写一个存储过程2.2.1 需求2.2.2 编写存储过程体 三、应用储存过程3.1 创建Django工程3.1.1 创建Django工程，命名为【**country**】3.1.2 创建子应用【world】 3.2 配置文件【settings.py】3.2.1 安装MySql驱动MySqlClient3.2.2 数据库连接信息 3.3 路由地址【urls.py】3.2.1 创建应用路由3.3.2 添加应用路由到主路由 3.4 创建页面3.4.1 编写页面代码3.4.2 查询数据库python实现 四、查看结果4.1 启动程序4.2 通过浏览器验证结果 五、总结附件 废 话 过去初入职场时，使用Microsoft SqlServer进行开发工作，经常使用存储过程解决数据处理问题，很多变化频繁的业务逻辑，如果通过存储过程实现，在变更时，就会显得特别简单和方便。只要通过发布脚本就可实现。不得不说，当年，通过Microsoft SqlServer开发数据库及报表应用，是真的好用。
多年后的今天，发现如今的数据库应用是MySql的天下了，免费开源是真香，使用第三方工具进行MySql的开发还是不错的，不过个人感觉，开发过程不如Microsoft Sql Server官方开发环境使用方便，逻辑性更强，但是谁叫他收费呢，而且还不是一般的贵。
所谓废话少说，接下来直入主题吧。
一、Navicat for MySQL 当然，使用命令行进行开发，也是完全可以的，不过那简直是闲的蛋疼才那样干。学生时候，看到别人在“黑窗口”里敲代码，认为牛的不得了。现在再看到这样做，第一感觉是这人脑子有问题，放着简洁，美观，方便的工具不用，还用最原始的命令方式操作，您咋不用二进制写呢？所以我们选择Navicat for MySQL做为开发工具。
数据库安装过程就不说了，又不用天天安装，某度一下就解决的事。
Navicat for MySQL有绿色版本，不用安装。序列号，自己解决，下点工夫还是能找到的，某宝也就几块钱的事，我觉得与其搜索好几个小时，还不如花几块钱搞定，难道你的几个小时连几块钱都不值吗？
在安装目录下找到美丽的navicat.exe图标，双击之打开开发工具。
1.1 连接数据库 一眼就看到工具栏上有连接图标，这太醒目了，都无法形容了。
打开这个窗口时，发现其实很多内容都已经填好了。如果是安装在本机上的话，只需要随便填个名字（这个时候咱叫他“小甜甜"），密码（这个不能随便输）只有你自己知道。填好之后，“连接测试”一下。他会告诉你是否连接成功。
看到这个提示时，整个人都轻松了很多。
1.2 查询数据库 1.2.1 打开数据库连接 此时我们看到，”小甜甜“已经安静的在房间时等着咱了，还不快点过陪陪他，难道要等到她变成”牛夫人“？
双击”小甜甜“也行，右击”小甜甜“也行。她都会立马开心（打开连接）的。
1.2.2 最简单的查询数据 选择一个数据库，然后【查询-&gt;新建查询】就可以打开一个查询窗口。
在窗口里输入最简单的查询语言
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e9fe866d195cc03e6bcb1482f74b22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8605ee85695fb107b1023ab804b6e5bc/" rel="bookmark">
			渗透测试 ( 9 ) --- 社会工程攻击工具 setoolkit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github 地址：https://github.com/trustedsec/social-engineer-toolkit
kali工具 -- setoolkit(克隆网站及利用)：https://blog.csdn.net/weixin_41489908/article/details/103851057
1、社会工程学概念 社会工程学通常以交谈、欺骗、假冒或口语等方式，从合法用户中套取用户系统的秘密。熟练的社会工程师都是擅长进行信息收集的身体力行者。很多表面上看起来一点用都没有的信息都会被这些人利用起来进行渗透。比如说一个电话号码，一个人的名字，或者工作的id号码，都可能被社会工程师所利用。
2、社会工程学工具 --- set kali 中打开 social engineering toolkit ( root )，或者命令行输入：setoolkit
SET 利用人们的好奇心、信任、贪婪及一些愚蠢的错误，攻击人们自身存在的弱点。SET最常用的攻击方法有：用恶意附件对目标进行 E-mail 钓鱼攻击、Java Applet 攻击、基于浏览器的漏洞攻击、收集网站认证信息、建立感染的便携媒体、邮件群发等攻击手段。
使用 set 需要 root 用户的权限，启动时需要输入密码 kali。
SET 是一个 "菜单驱动" 的 工具包。如下：
这里有 6 行命令
1) Social-Engineering Attacks 1） 社会工程攻击
2) Penetration Testing (Fast-Track) 2） 渗透测试（快速通道）
3) Third Party Modules 3） 第三方模块 4) Update the Social-Engineer Toolkit 4） 更新社会工程师工具包
5) Update SET configuration 5） 更新集配置 6) Help, Credits, and About 6）使用帮助及相关信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8605ee85695fb107b1023ab804b6e5bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30adf8c979161b3285b4a788b1a88a9c/" rel="bookmark">
			4种缓存模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述:
在系统架构中,缓存可谓提供系统性能的最简单的方法之一,稍微懂点开发的人必然会和缓存打交道,最起码也实践过.
在不同的场景下,锁使用的策略也是有变化的,如果在你的印象中,缓存还是个简单的查询,更新,操作,那么这篇文章你要学习下.
这里为大家家烧4种缓存模式以及使用场景.
缓存策略的选择
从本质上讲,缓存取决于数据访问模式,换句话说,数据是如何写和读的
例如:
系统是写多读少吗?
数据是否只写入一次被读取多次?
返回的数据是唯一的吗?
常用的缓存有一下4种
1.Cashe-Aside-Pattern:旁路缓存模式
2:Read Through Cache Pattern 读穿透模式
3:Write Though Cache Pattern 写穿透模式
4:Write Behind Pattern 又叫Write Back ,异步缓存写入模式
Cache Aside
Cache Aside是最常见的缓存模式,应用程序可以直接与缓存和数据库对话,Cache Aside可以用来读操作和写操作
读操作流程
应用程序接收到数据查询请求应用程序需要查询的数据是否在缓存上
- 如果存在Cache hit,从缓存上查出的数据,直接返回
- 如果不存在Cache miss, 则数据库中检索数据,并存入缓存中,返回结果数据.
在这里需要留意的是一个操作的边界,就是数据库和缓存操作均由应用程序直接进行操作.
写的操作流程图
这里的写操作,包括创建,更新和删除,在写操作的时候,Cache Aside模式是先更新数据库(增,删,改)然后直接删除缓存.
Cache Aside 模式可以说是大多数场景下使用的,通常为了应对类型的数据,还可以有两种策略来加载缓存: 使用时加载缓存:当需要使用缓存数据时,从数据库中查询出来,在第一次查询之后,后续请从缓存中获得数据预加载缓存 在项目启动的时候启动,或者启动后通过预加载缓存信息,比如"国家信息.货币信息,用户信息,新闻信息"等不变的数据.
Cache Aside适用于读多写少的场景,比如用户信息,新闻报道,一旦写入缓存,几乎不会进行修改,该模式的缺点就是和数据库的双写不一致的情况.
Cache Aside也是一个标准的模式,像FaceBook,也是采用的这种模式 ReadThrough
Read-Through 和Cache-Aside很相似,不同点在于程序员不需要关注从哪读取数据(缓存还是数据库),他只需要从缓存中读取,而缓存中的数据从哪来是由缓存决定的
Cache Aside是由调用方负责把数据加载到缓存,而ReadThrough则用缓存服务来自己加载,从而对的是透明的.Read-Through的优势是让代码变的更简洁.
这里就涉及到上面锁说的程序员操作的边界问题了,下面来看流程图
在上述流程中,重点关注下虚拟线框里面的操作,这部分不再由应用程序员来处理,而是由缓存存放来处理,也就是说,当应用魂村中查找某条数据的时候,如果数据不存在则由缓存来完成数据加载,最后再由数据结构给应用程序.
Write Through
在Cache Aside 中,应用程序需要维护两个数据存储,一个缓存,一个数据库,这个对应应用程序来说,有一些繁琐.
Write-through模式下,所有的写操作都经过缓存,每次向缓存中 写数据的时候,缓存就会把数据持久到对应的数据库中去,且这个操作在一个事务中完成,因此,只有两次都成功了才是最终写成了,坏处是写延迟,好处是保证了数据的一致性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30adf8c979161b3285b4a788b1a88a9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a0d57cf0ede2d9a2f17cfe01cca54e/" rel="bookmark">
			基于Android &#43; Web&#43; MySQL设计和开发微博应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Android + Web+ MySQL设计和开发微博应用 实践内容要求客户端效果图源码分享微博应用系统设计系统功能设计关键问题设计 实践内容要求 ①用Android开发微博客户端；
②用JSP或PHP开发微博Web服务器；
③用MySQL做Web服务器的后台数据库；
④可以发表微博、查看微博及微博列表等功能；
⑤可以发表评论功能；
⑥可以实现用户客户端登陆功能。
客户端效果图 源码分享 百度网盘链接分享
https://pan.baidu.com/s/1NOe7aoyvHgSAeNlwhltU0g
提取码：ehsk
微博应用系统设计 系统功能设计 1．客户端与服务器的数据交互：使用Json形式进行数据交互，将微博、评论数据进行通过alibaba的fastjson进行json格式的转换，再发送到服务器进行处理，服务器处理完成后反馈客户端操作是否成功；
2．用户登陆与注册：客户端向服务器发送请求，服务器与数据库进行连接交互，查询user表中信息，实现查询账号密码进行用户登陆或向表中插入新用户注册数据；
3．用户注销：用户注销后退出微博系统后，清空Android中activity当前栈，再新建一个栈返回至登陆页面，从而防止使用回退键返回登陆状态；
4．热门搜索：通过微博内容或用户账号搜索站内注册用户所发表微博，客户端发送搜索请求，服务器首先对数据库blog表中微博内容content进行搜索，通过SQL中like进行模糊查询，服务器得到查询结果不为空时返回客户端；若微博内容查询为空，则通过对数据库blog表中微博发布者writer进行查询微博；
5．微博列表：客户端登陆至微博主页时向服务器发送获取所有微博内容请求，服务器按date降序查询数据库blog表中全部内容，将结果以json形式返回到客户端，客户端从而完成主页面数据更新，列表形式显示微博；
6．发表微博与用户评论：客户端用户登陆成功后，新建微博或发表评论后向服务器发送对应请求，服务器获取客户端请求后，解析json数据，将数据进行持久化保存，插入数据库blog表和comment表中；
7．查看微博：用户点击微博列表项后，向服务器发送选中微博详细信息请求，服务器根据客户端请求blogID，查询blog表中全部信息，同时查询comment表中blogID对应得到全部评论信息，将查询结果封装早json数据中回传客户端，客户端进而显示微博详细信息，包括发布者、发布时间、微博内容、所有评论；
8．删除微博：用户查看微博时，判断打开微博的writer与登陆账号是否一致，若相同则用户为该微博的创建者，进而在fragment中动态加入子fargment显示删除按钮，用户点击删除后，客户端发送删除微博请求，服务器解析获取要删除微博的blogID，之后与数据库blog表交互删除对应微博，同时删除comment表中对应blogID的所有评论。
关键问题设计 1.服务器与mysql数据库建立连接
编写JdbcUtil工具类，在静态代码块中注册驱动，传入数据库连接路径，数据库账号密码，获取一个connection静态实例
2.客户端点击发送微博至服务器接收请求数据，更新数据库信息过程
①客户端点击发送微博后，启动发送微博的线程
新建微博线程后，实例化一个微博对象，初始化微博的发布者、创建时间、微博内容、评论数，并且将Microblog对象封装到json字符串，通过POST方法发送请求到服务器，需要设置编码格式为UTF-8，防止中文乱码，同时读取服务器处理请求后的返回结果，验证修改是否成功。
②服务器获取客户端请求数据，解析json字符串，获取微博对象，将microblog对象传入dao层函数add_blog函数中，新增微博，将处理结果返回给客户端
③通过Jdbc工具类建立数据库连接，通过PreparedStatement传递参数，将新增微博数据插入到数据库blog表中
3.根据微博内容或用户ID进行搜索
客户端点击搜索按钮后，发送一个异步的获取blog列表的请求，请求参数search为EditText中用户输入的搜索内容；
服务器接收客户端请求后，获取search参数，首先调用BlogDao中的blog_content进行blog表中微博内容content的查询，通过sql语句的like实现对blog表中content字段模糊查询，返回微博microblog的列表结果；若列表为空(或长度为0)，则微博内容查询为空，则BlogDao中的blog_user进行blog表中对微博发布者writer的查询。
4.用户登陆成功后主页面微博列表的显示
客户端在fragment的生命周期函数onResume中启动一个后台线程，向服务器发送请求获取全部微博内容，返回为微博列表List形式，再通过android适配器RecyclerView.Adapter更新主页面recyclerview的微博列表信息。
每次返回到主页时onResume都会调用进而异步获取首页微博，实现首页微博数据的更新。
服务器接收到客户端请求后，调用BlogDao中blog_all函数获取数据库中blog表中所有微博数据信息，返回microblog数组，再将其转换为json字符串回传给客户端。
4.用户自己创建的微博显示删除按钮，并实现微博删除功能
用户点击微博查看微博详情时，判断打开微博的writer与登陆账号是否一致，若相同则用户为该微博的创建者，进而在fragment中动态加入子fargment显示删除按钮，用户点击删除后，客户端向服务器发送删除微博请求
服务器解析json字符串，获取要删除微博的blogID，调用BlogDao中函数delete_blog删除数据库blog表中blogID对应微博数据，同时删除comment表中对应blogID的所有评论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2995fc56d9c06d697c8b36030942a9f/" rel="bookmark">
			Pdf&#43;Word&#43;Visio&#43;MATLAB输出的3维图像不清晰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决论文里面保存复杂MATLAB三维图的方法笔记 写论文的时候需要用到3维图。遇到好几个问题，记录一下解决方法。
第一个问题就是matlab在保存3维图的时候，如果直接保存成.emf格式，因为三维图里面线条极多，如图1，如果直接在导出设置里面渲染方式调成painter(向量格式)的600dpi，如图2，则会导致保存的文件极大并且非常耗时间。
图一
解决办法为改成保存600dpi的OpenGL位图格式。清晰度同样可以满足要求，但是好像听说新版本的maltab已经可以用函数保存到800dpi左右了。
问题二，得到png图像后放入visio里面，正常作图并且把做好的图放进word里面，再导出，发现图像非常糊。在word里面放大看都好好的，然后原png放大看也是好的，结果一输出就变糊了。
找了很多办法，把一些网站罗列一下（都没有解决问题，但是值得码住）：
DPI和像素、厘米、英寸之间的关系和换算及CSS中的长度单位
visio怎么另存为高质量png
另一篇描述MATLAB存3维图问题的
matlab保存高清图片png、svg、pdf等
exportgraphics函数MATLAB
用排除法找问题：
matlab输出png，没问题， visio里面输出的png以及emf，以及他.vsdx文件本身都是高清可放缩矢量图（插进去的3维png图也是可以放缩看得清楚的），没问题； word里面可以放大查看高清图，没问题。
结果就是输出的pdf图片糊了，出问题了。 而且还注意到原word文档是快20MB的文件，而pdf就只有几MB。
经过多次尝试以及分析，得出以下推测：pdf保存的时候出问题了。
解决办法为改打印机设置：Word转PDF图像失真的解决方法
不能直接导出pdf,一定要选打印选项。
然后还有别的地方提到的：
弄完这些，在打印出来的pdf就瞬间变高清了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908957e1e552fb878039851f99b60ede/" rel="bookmark">
			完全搞懂java中的时间戳，时区，日期格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关概念 【写在最前】
我们平时会接触各种计算机时间的概念，最常见的有GMT,UTC,CST等。
很多小白傻傻分不清楚他们之间的区别与联系，通过本文知识，让我们花5分钟时间彻底搞懂他，相信聪明的你，看完一定会有收获！
GMT 即：格林尼治时间（另有格林威治时间一说）
以本初子午线为基础，精确度相对低。
注意事项：
因为地球每天的自转是不规则的（正在缓慢减速）所以，格林尼治时间的精确度会越来越低。
UTC 即：世界协调时（Universal Time Coordinated的缩写）
以原子时钟长为基础，比GMT格林威治时更加科学更加精确。
UTC是国际无线电咨询委员会制定和推荐的，若与GMT时差大于0.9秒，则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。
UTC时间格式为：YYYY-MM-DDThh:mm:ssZ。例如，2014-11-11T12:00:00Z（为北京时间2014年11月11日20点0分0秒）
中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。
注意事项：
1）目前UTC与GMT 相差为0.9秒，故二者可以基本视为一致。
我们一般认为GMT和UTC是一样的，都与英国伦敦的本地时相同。
2）早期的XP系统中，默认时间格式是GMT。而到了Win7之后，默认时间格式已经改成了UTC
3）阿里云API接口编程中，全部都是UTC
UNIX时间戳（timestamp） 计算机中的UNIX时间戳，是以GMT/UTC时间「1970-01-01T00:00:00」为起点，到当前具体时间的秒数(不考虑闰秒)。这样做的目的，主要是通过“整数计算”来简化计算机对时间操作的复杂度。
无论何种编程语言，基本都有获取unix时间戳的系统方法。
注意事项：
如果开发的软件系统仅仅在国内用，用timestamp没有太大问题（因为大家的linux服务器的时区是一样的）
如果软件系统需要跨国服务，则必须用UTC（比如阿里云API），否则就会因为服务器的UTC时区不同,导致timestamp结果值混乱
CST 这个代号缩写，并不是一个统一标准，目前，可以同时代表如下 4 个不同版本的时区概念（要根据上下文语义加以区分）：
1）China Standard Time 中国标准时区 (UTC+8)
2）Cuba Standard Time 古巴标准时区 (UTC-4)
3）Central Standard Time (USA) 美国中央时区 (UTC-6)
4）Central Standard Time (Australia) 澳大利亚中央时区(UTC+9)
总结 我们一般都认为UTC和GMT时间是相同的，时间戳的含义是 从本初子午线1970年1月1日至今所过去的毫秒数，时间戳与时区无关，如果再不同的时区，先通过时间戳得到一个时间之后，再加上时区的偏移量
Date 构造
public Date() { this(System.currentTimeMillis()); } public Date(long date) { fastTime = date; } 构造很简单，就是设置了一个long类型的时间戳
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/908957e1e552fb878039851f99b60ede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c489b7202cf9643349cd89f8742f9fa4/" rel="bookmark">
			C语言实现扫雷【超详细讲解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实现扫雷的基本思路
二、代码实现的具体步骤
三、完整代码
1、saolei.h部分
2、saolei.c部分
3、test.c部分
扫雷和三子棋有很多相似的地方，相信大家认真学习完三子棋再将本篇博客认真学习完，会很好的掌握相关的知识，融会贯通
一、实现扫雷的基本思路 1、创建菜单
2、实现switch case语句，进行游戏或退出游戏的选择
3、选择进行游戏，实现游戏的代码
4、游戏部分创建两个二维数组，分别是mine和show数组。mine数组是有关炸弹的数组，有炸弹的位置是1，没有炸弹的位置是0；show数组是查找炸弹的数组，不知道的位置是‘*’，查出来的位置的数字是周围的炸弹个数
5、初始化这两个二维数组，mine数组初始化为‘0’，show数组初始化为‘*’
6、打印棋盘，每次输入坐标后都打印一次棋盘，以便观察
7、实现布置雷的操作：和三子棋一样需要rand（头文件：stdlib.h）和time（头文件：time.h），结合使用可以使电脑随机布置雷
8、实现排查雷的操作：玩家输入一个坐标，若踩雷则会提醒游戏结束；若未踩雷，则在show数组中的相应位置中显示周围一圈雷的个数
9、在游戏结束后，继续打印选择的菜单，由玩家决定是否继续进行游戏
二、代码实现的具体步骤 1、创建如下所示的三个部分：
2、 同样在saolei.h中引用头文件，在saolei.c和test.c中只需要引用saolei.h即可
3、在test.c中创建main函数及test函数的switch case语句
4、创建简易的菜单
5、扫雷标准是9行9列，但是由于考虑到靠边的坐标计算周围的地雷数时，还需要不包括越界的地方，所以将两个数组都扩大一圈，就不会有这方面的困扰了，即变为了11行11列的二维数组，使用宏定义的方式分别定义ROW9，COL9，ROWS11，COLS11，以及设置的地雷数MINE_COUNT10
6、test.c中game函数的实现（依然是先完成框架的梳理，再具体实现） 7、在saolei.c中具体实现game函数中的要求（在saolei.h中声明，在saolei.c中实现），下面第一个图片即为声明，第二个图片为函数的实现 （1）、数组初始化函数的实现
（2）、打印棋盘
在9×9的棋盘上方和左方，分别打印一行和一列的数字，方便玩家读取第几行第几列的准确坐标
（3）、布置地雷
在test函数中添加：
（4）、排查地雷
在排查雷函数中，需要用到统计雷个数的函数Find_count，如下：
三、完整代码 1、saolei.h部分 #pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define ROWS 11 #define COLS 11 #define ROW 9 #define COL 9 #define MINE_COUNT 10 //数组的初始化函数 void Init_board(char arr[ROWS][COLS], int rows, int cols, char set); //打印棋盘 void Display_board(char arr[ROWS][COLS], int row, int col); //布置地雷的函数 void Set_mine(char mine[ROWS][COLS], int row, int col); //排查地雷 void Find_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); 2、saolei.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c489b7202cf9643349cd89f8742f9fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4fbbc803edcab5f976b72785d3c612/" rel="bookmark">
			神经网络到底是怎样一回事，神经网络是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络具体是什么？ 神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。 举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。从而识别当前数字是什么字。 神经网络的每个神经元如下。
基本wx + b的形式，其中 x1、x2表示输入向量 w1、w2为权重，几个输入则意味着有几个权重，即每个输入都被赋予一个权重 b为偏置bias g(z) 为激活函数 a 为输出 如果只是上面这样一说，估计以前没接触过的十有八九又必定迷糊了。事实上，上述简单模型可以追溯到20世纪50/60年代的感知器，可以把感知器理解为一个根据不同因素、以及各个因素的重要性程度而做决策的模型。 举个例子，这周末北京有一草莓音乐节，那去不去呢？决定你是否去有二个因素，这二个因素可以对应二个输入，分别用x1、x2表示。此外，这二个因素对做决策的影响程度不一样，各自的影响程度用权重w1、w2表示。一般来说，音乐节的演唱嘉宾会非常影响你去不去，唱得好的前提下 即便没人陪同都可忍受，但如果唱得不好还不如你上台唱呢。所以，我们可以如下表示： x1：是否有喜欢的演唱嘉宾。x1 = 1 你喜欢这些嘉宾，x1 = 0 你不喜欢这些嘉宾。嘉宾因素的权重w1 = 7 x2：是否有人陪你同去。x2 = 1 有人陪你同去，x2 = 0 没人陪你同去。是否有人陪同的权重w2 = 3。 这样，咱们的决策模型便建立起来了：g(z) = g(w1x1 + w2x2 + b )，g表示激活函数，这里的b可以理解成 为更好达到目标而做调整的偏置项。 一开始为了简单，人们把激活函数定义成一个线性函数，即对于结果做一个线性变化，比如一个简单的线性激活函数是g(z) = z，输出都是输入的线性变换。后来实际应用中发现，线性激活函数太过局限，于是引入了非线性激活函数。
A8U神经网络
我想问一下什么是神经网络 神经网络可以指向两种，一个是生物神经网络，一个是人工神经网络。
生物神经网络：一般指生物的大脑神经元，细胞，触点等组成的网络，用于产生生物的意识，帮助生物进行思考和行动。
人工神经网络（Artificial Neural Networks，简写为ANNs）也简称为神经网络（NNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。
人工神经网络：是一种应用类似于大脑神经突触联接的结构进行信息处理的数学模型。在工程与学术界也常直接简称为“神经网络”或类神经网络。
有人可以介绍一下什么是"神经网络"吗? 由于神经网络是多学科交叉的产物，各个相关的学科领域对神经网络。
都有各自的看法，因此，关于神经网络的定义，在科学界存在许多不同的。
见解。目前使用得最广泛的是T.Koholen的定义，即"神经网络是由具有适。
应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经。
系统对真实世界物体所作出的交互反应。"。
如果我们将人脑神经信息活动的特点与现行冯·诺依曼计算机的工作方。
式进行比较，就可以看出人脑具有以下鲜明特征：
1. 巨量并行性。
在冯·诺依曼机中，信息处理的方式是集中、串行的，即所有的程序指。
令都必须调到CPU中后再一条一条地执行。而人在识别一幅图像或作出一项。
决策时，存在于脑中的多方面的知识和经验会同时并发作用以迅速作出解答。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f4fbbc803edcab5f976b72785d3c612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a20229daee0cf9a2b64da26f310b651/" rel="bookmark">
			Spring Cloud Alibaba Sentinel 滑动窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、构建滑动窗口 在前面构建处理器链的时候创建了一个StatisticNode。
用数组实现，保存资源的静态实时数据。
保存了三种类型的实时静态监控数据：秒级别监控，分钟级别监控和线程数量。
public class StatisticNode implements Node { /** * Holds statistics of the recent {@code INTERVAL} seconds. The {@code INTERVAL} is divided into time spans * by given {@code sampleCount}. */ //SAMPLE_COUNT = 2 //初始化有两个桶 //INTERVAL = RuleConstant.DEFAULT_WINDOW_INTERVAL_MS = 1000 //滚动计数器，秒 private transient volatile Metric rollingCounterInSecond = new ArrayMetric(SampleCountProperty.SAMPLE_COUNT, IntervalProperty.INTERVAL); /** * Holds statistics of the recent 60 seconds. The windowLengthInMs is deliberately set to 1000 milliseconds, * meaning each bucket per second, in this way we can get accurate statistics of each second.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a20229daee0cf9a2b64da26f310b651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a100d533cf19aa2cb72eb7e6450d1462/" rel="bookmark">
			python虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python虚拟环境 虚拟环境的作用 一台服务器可同时运行多个项目，各项目对python解释器的要求各不相同从而对python库的版本要求也不相同，例如用于爬取网页的urllib库在python3中直接导入而python2需要再导入一个urllib2。虚拟环境此时的作用就是新增不同版本的python解释器(可指定为python2.7、3.6、3.9)，每一个解释器和默认python一样在系统中都有一个文件路径。
虚拟环境工具 目前市场上流行的虚拟环境工具有：
Virtualenv virtualenv是常用的较为轻量的虚拟环境工具。在界面版系统中，pycharm已经嵌入了多种环境工具以virtualenv为例，步骤如下图
首先新建项目
截图 2022-07-07 111147.jpg]]设置项目的保存路径同时设置虚拟环境python解释器的路径即可
在命令行版系统(Linux)中，使用pip3 install virtualenv，是pip还是pip3是根据系统默认的是python2还是python3决定，总之virtualenv --version是20.15.1最好，慎重使用apt get install virtualenv大概率版本不对。然后pip3 install virtualenvwrapper是virtualenv的插件，更简便地管理虚拟环境。然后sudo vi ~/.bashrc修改环境变量，source .bashrc更新。
export WORKON_HOME=$HOME/.virtualenvs #生成的虚拟环境以及python解释器都在这个目录下，注意这是一个隐藏目录。也可以自定义路径，在$HOME/后修改 export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 export VIRTUALENVWRAPPER_VIRTUALENV=~/.local/bin/virtualenv source ~/.local/bin/virtualenvwrapper.sh #注：ubuntu18及以上版本，virtualenv和virtualenvwrapper.sh被安装到了home目录下的.local/bin/中，非原来的/usr/local/bin/中 没有插件只能mkvirtualenv test一个虚拟环境后每次cd XX/XX/test然后激活进入环境source test/bin/activate，安装插件后只需要进入workon test退出deactivate删除rmvirtualenv test。
开机启动自运行python 有时我们需要服务器或者树莓派，上电后立即执行某几个python项目。那么多任务时我们就需要给每个项目找到对应的python解释器，可以用find / -name python3找到所有包含’python3’名的文件路径也可以进入虚拟环境后python
然后cd /etc/rc.local下用shell脚本添写开机执行命令
#!/bin/sh #/etc/init.d/testboot ### BEGIN INIT INFO # Provides:testboot # Required-Start:$remote_fs $syslog # Required-Stop:$remote_fs $syslog # Default-Start:2 3 4 5 # Default-Stop:0 1 6 # Short-Description: testboot # Description: This service is used to start my applaction ### END INIT INFO case "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a100d533cf19aa2cb72eb7e6450d1462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90fe7869eae0500e10d3c12f66c02f3/" rel="bookmark">
			Linux 虚拟设备-docker网络通信原理与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 ubuntu-mate 20.04.3 + docker环境虚拟网线设备(veth-pair,内核实现的驱动设备,当docker run -it ubuntu:22.04执行,启动一个docker镜像,]通过ifconfig可以发现一个网络设备)
原理：veth-pair不是一个设备，而是一对设备,作为虚拟网线用于连接两个虚拟网络设备。veth pair 是根据数据链路层的 MAC 地址对网络数据包进行转发的过程来实现的，本质是反转通讯数据的方向，需要发送的数据会被转换成需要收到的数据重新送入内核网络层进行处理，从而间接的完成数据的注入工作。网桥设备(bridge，内核实现的驱动设备,docker安装后,系统会自动为其创建默认网桥docker0)
网桥是一种对帧(数据帧)进行转发的技术，根据MAC分区块，可隔离碰撞，网桥将网络的多个网段在数据链路层连接起来，是连接两个局域网的一种存储/转发设备，它能将一个大的LAN分割为多个网段，或将两个以上的LAN互联为一个逻辑LAN，使LAN上的所有用户都可访问服务器。 扩展局域网最常见的方法是使用网桥，网桥的每个端口与一个网段相连。内核namespace: linux通过veth创建多个虚拟设备,使用网桥设备(bridge,充当二层交换机)让这些虚拟设备进行相互通信，在此虚拟化中，需要进行隔离，只有这样才能保证不同的容器之间复用硬件资源的同时，还不会影响其它容器的正常运行。
在 Linux 上实现隔离的技术手段就是 namespace，通过 namespace 可以隔离容器的进程 PID、文件系统挂载点、主机名等多种资源。不过我们今天重点要介绍的是网络 网络（namespace），简称 netns。它可以为不同的命名空间从逻辑上提供独立的网络协议栈，具体包括**网络设备、路由表、arp表、iptables、以及套接字（socket）**等（很关键，当使用iptables对其路由规则查看，可以进入netns 进行查看，docker top docker ps|grep "keen_buck"|cut -d " " -f1，nsenter -n --target 822697，再进行iptables -t nat -L）。使得不同的网络空间就都好像运行在独立的网络中一样。
命令清单:
docker top `docker ps|grep "keen_buck"|cut -d " " -f1 nsenter -n --target 822697 iptables -t nat -L route iptables -S -t nat exit #退出命令空间命令 docker原理 docker 让 veth1与veth2在同一个局域网内(bridge 充当二层交换机作用)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90fe7869eae0500e10d3c12f66c02f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf9739904289fde751be6bf6def9166/" rel="bookmark">
			【Vue】MVVM和双向绑定的底层原理简洁版总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先要了解一个概念，MVVM是什么？
MVVM ：
M：数据模型层 ，负责数据处理。
V：视图层，显示视图。
VM：视图模型层，涉及到双向绑定。
输入框变-data变。view=&gt;data
data变-节点变。data=&gt;view
二、双向绑定底层原理总结：
方式：通过数据劫持Object.defineProperty和发布订阅模式实现。
这里涉及到一个名词，数据劫持是什么？一句话来说：给数据添加监听，一旦发生变化，就执修改视图操作的过程。
简洁版总结①：通过Object.defineProperty监听数据发生变化，然后通知订阅者（watcher），订阅者触发响应的回调。
补充简洁版总结②：通过监听器 Observer-用Obeject.defineProperty()来监听属性变动，通过订阅器Dep来告知订阅者，订阅者Dep就是订阅监听器变化，当变化时触发解析器compile中的更新函数。
补充版总结③：vue源码中有一个核心方法叫 defineReactive() ，把没侦测转为侦测的。具体逻辑：通过监听器 Observer-用Obeject.defineProperty()数据劫持，会劫持到每一个状态数据，遍历对象，给每个属性加setter，getter。这样如果我们赋值，setter就会监听到。同时创建订阅器Dep，再给每个依赖者添加一个订阅者watcher。这样，当数据发生变化时，会触发对应的setter，从而Dep会发布通知，通知每一个订阅者watcher，然后watcher更新对应的数据。也就是触发解析器compile中的更新函数。
具体步骤：
1、实现一个监听器 Observer-用Obeject.defineProperty()来监听属性变动。（用Object.defineProperty() 对属性都加上 setter 和 getter。这样如果我们赋值发生变动，就会触发setter，我们就会监听到）
2、实现一个解析器 Compile-解析 Vue 模板指令，绑定更新函数，添加监听数据的订阅者，一旦数据有变动，调用更新函数进行数据更新。
3、实现订阅者Watcher-订阅Observe的属性变化，当变化，触发解析器 Compile 中对应的更新函数。
4、实现订阅器Dep-当变化时告知订阅者-用来收集订阅者，对监听器和订阅者进行统一管理。
附上在网上找的一张图，感觉非常清晰，供大家参考：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685febd6e08d9fe8208a2bbb1deb9441/" rel="bookmark">
			爬取网页动态加载的评论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超时的处理 爬虫在向服务器请求时，若是服务器没有顺利返回响应，爬虫就会一直等待
有时这种长时间等待是没有没价值的
在requests.get()里添加参数，设置一个等待时间，若是响应超过这段时间还没有返回，就返回异常报告（ConnectTimeout）：
#设置超时时间是0.001秒： response=requests.get(url,timeout=0.001) AJAX、检查工具里的network和XHR 1.AJAX（Asynchronous JavaScript And XML）： 一种异步更新技术，更新网页的部分内容，但是不重新加载整个网页（url不会变）。
在一些网站里，评论就是用JavaScript加载的，在一个&lt;script&gt;的标签内，这些评论数据就不会加载在初次出现的网页源代码里。
2.解释为什么requests请求到的响应会没有element里的标签： 浏览器打开一个网页，用右键【检查】打开查看网页源代码：
在【element】中，我们可以找到标签：&lt;span class="reply-content"&gt;
而在右键【查看网页源代码】打开的网页里（打开的数据就是我们用requests爬到的）：
是找不到这个标签（即使是在网页更新出新内容，再打开源代码，其内容也不会变）
3.network和XHR 右键【检查】或是【F12】打开的小窗的选择栏里有network这个栏目:
左侧红色的小灯：灯亮表示一直在监听页面内通过点击、按键发送的请求
禁止的符号：清除的意思，会清除掉我们找到的页内响应
XHR：不更新网页也可以传输的对象（比如页面内没有展开的评论和回复）
requests、network、SHR和json进行动态网页爬虫： 1、捕获网页源代码里没有的信息，比如说动态加载的评论 1.点击【network】中【禁止符号】对当前的XHR对象进行清除
2.在某网站的某个视频下点击了加载评论的按钮
3.可以发现有新的XHR对象出现（这难道就是传说中的抓包！）对应网页内评论完成更新，XHR对象完成更新（时间差完全可以忽略），在size列下也可以看XHR对象的数据大小。
4.查看这个XHR对象是不是真的有评论数据：
点击这个XHR对象，点击【Preview】进行内容预览，里面是json数据，点击【replies】慢慢往下掏，就有响应的评论内容：
2、打开这个XHR对象的【headers】，组装requests请求url： 将【authority】、【path】 和【scheme】组装成一个url：
3、用requests进行爬取： import requests url="阿巴阿巴" headers={"user-agent":"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3877.400 QQBrowser/10.8.4533.400"} response=requests.get(url,headers=headers) print(response.text) 4、json模块进行数据提取: json是一种字典和列表组成的数据格式，可以做为XHR的一种传输文件格式。
导入和调用模块(python自带)：
import json words=response.content.decode("UTF8") json_=json.loads(words) 一个json格式化的网页：JSON在线解析及格式化验证 - JSON.cn
根据网页解析的分枝数格式进行编写代码：
comments=[] id_names=[] members=json_["data"]["replies"] for each_member in members: comment=each_member["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685febd6e08d9fe8208a2bbb1deb9441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07cfcd63544a149b12eb94b090f0a1c6/" rel="bookmark">
			深度优先搜索（dfs），宽度优先搜索（bfs），深度优先遍历，宽度优先遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图的遍历：我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。
通常有两条遍历图的路径（对有向图和无向图都适用）：①深度优先搜索 ；② 广度优先搜索。
一，DFS（深度优先搜索） 深度优先搜索（暴搜）：一条路走到黑
1，树（排列数字为例） 由题可知需按照字典序排列，所以共有 种情况。
如下图所示。
所谓深搜就是一条路走到黑。以上面的排列数字n=3为例，依次从第一层向下，直到三个位置均满之后，再回溯到上一层，再判断是否下一层还有遗漏情况。也符合字典序要求。
注意，为了避免同一顶点被访问多次，每次每层用过了一个点，需要通过辅助数组（初始值置为“假”或“零”）给该点标记一下（值变为“真”或“一”），说明已经用过。此外也需要对排列路径进行一个记录。但是一次深搜之后还需还原现场（即将标记过的点还原），以便于能继续回溯之后的搜索。
代码：
#include &lt;iostream&gt; using namespace std; const int N=8; int path[N],st[N];//path数组存路径，st数组表示访问标志数组。 int n; void dfs(int u) { if(u==n) { for(int i=0;i&lt;n;i++)cout&lt;&lt;path[i]&lt;&lt;' '; cout&lt;&lt;endl; return ; } for(int i=1;i&lt;=n;i++) { if(!st[i]) { st[i]=1; path[u]=i; dfs(u+1); st[i]=0; } } } int main() { cin&gt;&gt;n; dfs(0); return 0; } 2，图（n皇后为例）： 图的深度遍历：
无向图深搜：
有向图深搜： 例题：
剪枝：提前判断当前路径是否合法，不合法提前回溯。
n皇后问题就是满足n*n的数组中，放n个皇后，并且这n个皇后不能同一列，同一行，同一对角线，同一反对角线。所以，基于全排列问题，我们再多加上对角线和反对角线即可。那么对角线和反对角线如何处理呢？
如下图所示：
代码：
#include &lt;iostream&gt; using namespace std; const int N=20; char g[N][N];//存图； int col[N],dg[N],udg[N];//col表示列，dg正对角线，udg反对角线； int n; void dfs(int u) { if(u==n) { for(int i=0;i&lt;n;i++)cout&lt;&lt;g[i]&lt;&lt;endl; cout&lt;&lt;endl; return ; } for(int i=0;i&lt;n;i++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07cfcd63544a149b12eb94b090f0a1c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc6e221a1a0f0d395150a3daa8b485b6/" rel="bookmark">
			火爆全网的Python数据科学手册，太有用了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，感谢大家一路以来的关注和支持，今天为大家整理和筛选了大量火爆全网的Python数据科学学习资料，全部资料按需自助免费获取！
火爆全网的Python进阶中文版 推荐一本对Python感兴趣的书籍《Python进阶》，是《Intermediate Python》的中文译本，IntermediatePython这本书具有如下几个优点：简单、易读、易译。这些都不是重点，重点是：它是一本开脑洞的书。无论你是Python初学者，还是Python高手，它显现给你的永远是Python里最美好的事物。
本书作者的行文方式有着科普作家的风范，--那就是能将晦涩难懂的技术用比较清晰简洁的方式进行呈现，深入浅出的风格在每个章节的讨论中都得到了体现：
特点
每个章节都非常精简，5分钟就能看完，用最简洁的例子精辟地展现了原理
每个章节都会通过疑问，来引导读者主动思考答案
每个章节都引导读者做延伸阅读，让有兴趣的读者能进一步举一反三
每个章节都是独立的，你可以挑选任意的章节开始阅读，而不受影响
英文链接：http://book.pythontips.com/en/latest/ 原书作者：yasoob《Intermediate Python》
译者
总顾问+审校: 刘宇 @liuyu
主译: PyCon老高 @spawnris
主译: 大牙matt @suqi
参译: 明源 @muxueqz
106页《Python进阶》已经打包好，获取步骤如下：
1，点击下方公众号 数据STUDIO 名片
2，关注 数据STUDIO后，在消息后台回复 进阶
▲点击关注「数据STUDIO」回复进阶
Matplotlib 可视化必备神书 大家知道，在利用Python进行数据分析与可视化过程中，基本上是很难绕开 Matplotlib 的，因为不少其他的可视化库多多少少是建立在 Matplotlib 的基础上的。
最近在研究数据可视化过程中，发现了一本Matplotlib可视化神书 《Scientific Visualization: Python + Matplotlib》，这本书是由来自法国计算机科学研究所的研究员 Nicolas P. Rougier 编写的，是一本关于使用 Python 和 Matplotlib 进行科学可视化的书籍。书中每一个精美绝伦的图表都有对应的源码可供大家学习！
点击了解详情👉Matplotlib 可视化必备神书，完整PDF下载
书籍和源码均已给你打包好！获取步骤如下：
1，点击下方公众号 数据STUDIO 名片
2，关注 数据STUDIO后，在消息后台回复 0501 ▲点击关注「数据STUDIO」回复0501
Python全栈学习手册 本套教程以HTML形式展现，方便阅读，可以复制。其内容丰富。全套教程包括Python基础、Python安装环境、网络爬虫、flask、django、git等到，具体可见如下截图。
Python安装 Python基础 Python基础从认识Python、输入输出、基本数据类型、循环控制语句、函数、类、文件操作等等，内容精辟齐全。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc6e221a1a0f0d395150a3daa8b485b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d68efcce0c0f05c1a29672e438ad95/" rel="bookmark">
			【HBZ】生产环境下如何解决CPU飙高 与排查CPU飙高问题 与如何解决内存泄漏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 生产环境CPU飙高问题原因 0. CPU上运行的是线程， 所以就是说有线程一直在忙碌，一直在运行
线程中有CAS一直获取锁失败，并不断的通过自旋重试，这是CAS的缺点，因此大量线程在自旋重试，会空耗CPU。比如代码中运用了AtmicXXX这些原子类 或 ConcurrentHashMap 或 乐观锁重试这些东西都可能导致CPU飙高
解决方案：使用这些原子类，或者乐观锁时要注意一下，并且自己写乐观锁自旋重试要注意配置重试次数云服务器安装了Redis， 黑客利用6379端口注入挖矿程序，导致占用CPU资源
解决方案：尽量不要让Redis在外网访问，不要暴漏ip，并把端口号 或 ip设置访问权限，所以云服务器尽量买一家的服务端接口被DDOS恶意攻击，当然要做大量的DDOS攻击，要花大量的钱，不是深仇大恨一般不会
解决方案：可以买高仿服务器，但是价格高。或者对接口做限流，图形验证码，ip黑名单等，对接口做限流可以防止服务器崩溃，但依然会把正常的良性请求也给拒绝了代码出现了死循环打印，导致线程无法结束。
解决方案：要合理做一些退出循环的操作， 比如做一些循环次数限制，或者循环时间限制 Windows如何去排查CPU是什么原因飙高 打开任务管理器 ctrl + alt + del看一下cpu百分比最高的对应哪个进程
Linux如何去排查CPU是什么原因飙高 通过命令top -c，找到占比高的进程id，即–&gt;pid
再根据进程pid去找具体哪个线程注意：一定要配置【线程池名称】，否则很难找更推荐使用Arthas(阿尔萨斯)这个工具 1. 下载方式：curl -O https://arthas.aliyun.com/arthas-boot.jar 2. 启动： java -jar arthas-boot.jar 3. 选择指定进程 启动arthas之后会自动列出所有jvm的java进程，前面有对应序号，输入对应序号， 然后回车 即可进入指定进程 4. 输入thread -n 3 回车 表示查看本进程占用CPU最高的3个线程 生产环境如何去排查CPU是什么原因飙高 服务器监控系统：比如阿里云CPU飙高的告警提示运维先知道那台服务器节点CPU飙高，通知开发人员配合该服务器，进程中哪个线程导致cpu飙高这些问题需要运维查，生产环境一般开发人员一定是碰不到的或者通过第三方监控软件的平台查询。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21db5a05572056693ff16724837aa82/" rel="bookmark">
			Markdown文档常用字体及颜色设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、字体、字号、颜色设置 &lt;font face="黑体"&gt;我是黑体字&lt;/font&gt; &lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt; &lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt; &lt;font color=red&gt;我是红色&lt;/font&gt; &lt;font color=#008000&gt;我是绿色&lt;/font&gt; &lt;font color=Blue&gt;我是蓝色&lt;/font&gt; &lt;font size=5&gt;我是尺寸&lt;/font&gt; &lt;font face="黑体" color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt; 上述设置显示效果如下所示：
我是黑体字
我是微软雅黑
我是华文彩云
我是红色
我是绿色
我是蓝色
我是尺寸
我是黑体，绿色，尺寸为5
注意：
CSDN中的blog默认字号为3号字，字号数值可设为1~7，默认字体为微软雅黑。其它颜色值可参考https://www.colorhexa.com
2、加粗、斜体设置 **粗体文字**,或__粗体文字__——&gt; 粗体文字 *斜体文字*,或_斜体文字_——&gt; 斜体文字 粗体文字,或__粗体文字__——&gt; 粗体文字
斜体文字,或_斜体文字_——&gt; 斜体文字
3、背景色设置 背景色的功能。
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt; 背景色是 1 orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;table&gt;&lt;tr&gt;&lt;td bgcolor= BlueViolet &gt; 背景色2 BlueViolet &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 背景色是 1 orange 背景色2 BlueViolet 原文链接：https://blog.csdn.net/sinat_35945236/article/details/120559111
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb3f5a2c0c9dc330435f83f7a8c53af/" rel="bookmark">
			React使用pubsub-js订阅发布和取消订阅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React中父子组件传值有三种形式：
父组件传值给子组件时，通常会使用props传值。子组件传值给父组件时，通常会子组件中的事件触发一个回调函数，父组件中的对应函数去修改值。兄弟组件间传值，通常会将子组件A的值传回父组件，父组件再传给子组件B 以上三种情况都可以使用消息订阅与发布机制来解决。
当然父传子还是用props比较好。子组件传值给父组件，在子组件中发布，在父组件中订阅，就可以拿到相应的值兄弟组件间传值，在子组件A中发布，在子组件B中订阅 下面介绍下PubSubJS的用法：
PubSubJS官方Github链接： GitHub - mroderick/PubSubJS: Dependency free publish/subscribe for JavaScript
1. 安装包
npm install pubsub-js 2. 在React项目中引入包
import PubSub from 'pubsub-js' 3. 重点使用的函数
发送消息：PubSub.publish(名称,参数) 订阅指定消息：PubSub.subscrib(名称,函数) 取消指定订阅：PubSub.unsubscrib(名称) 取消所有订阅：PubSub.clearAllSubscriptions() 4. 使用方法
父组件：
import React from 'react'; import Child from './Child'; import PubSub from 'pubsub-js'; import './App.css'; export default class App extends React.Component { componentDidMount() { // publish 发布消息 消息名为：publish_one 内容为：This is publish PubSub.publish("publish_one","父组件发布信息“hello") PubSub.subscribe("childPublish",(msg,data)=&gt;{ console.log('父组件接受消息',msg,data); }) } render() { return ( &lt;div className = 'ArticleContainer'&gt; 父组件： &lt;Child/&gt; &lt;/div&gt; ) } } 子组件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb3f5a2c0c9dc330435f83f7a8c53af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b933185b4c6241690da7ac081ffed2d/" rel="bookmark">
			MATLAB中smoothdata函数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
语法
说明
示例​
使用移动平均值对数据进行平滑处理
含噪数据的矩阵 高斯滤波器 包含 NaN 的向量 使用样本点对数据进行平滑处理 smoothdata函数的功能是对含噪数据进行平滑处理。
语法 B = smoothdata(A) B = smoothdata(A,dim) B = smoothdata(___,method) B = smoothdata(___,method,window) B = smoothdata(___,nanflag) B = smoothdata(___,Name,Value) [B,window] = smoothdata(___) 说明 ​ B= smoothdata(A) 使用以启发方式确定的固定窗口长度返回向量元素的移动平均值。窗口向下滑动向量的长度，计算每个窗口中的元素的平均值。
如果 A 为矩阵，smoothdata 计算每列的移动平均值。
如果 A 是多维数组，则 smoothdata 沿大小不等于 1 的第一个维度进行运算。
如果 A 是包含数值变量的表或时间表，则 smoothdata 针对每个变量单独执行运算。
​ B= smoothdata(A,dim) 沿 A 的维度 dim 执行运算。例如，如果 A 是一个矩阵，则 smoothdata(A,2) 对 A 中的每行数据进行平滑处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b933185b4c6241690da7ac081ffed2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3c3961bb235b4b252987ed8b180b0e/" rel="bookmark">
			Python中append()函数和extend()函数区别详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python列表中，append()和extend()都可以在在原有列表上增加对象，但是使用起来有很大区别。
append()用于在列表末尾添加新的对象，任意对象都是可以的，列表只占一个索引位，会修改原来的列表。
extend()向列表尾部追加一个列表，对象必须是一个可以迭代的序列，将列表中的每个元素都追加进来，会在已存在的列表中添加新的列表内容。
append() 用于在列表末尾添加新的对象，列表只占一个索引位，在原有列表上增加。
list.append(object) 无返回值，但是会修改原来的列表。
extend() 向列表尾部追加一个列表，将列表中的每个元素都追加进来，在原有列表上增加。
list.extend(seq) 把一个序列seq的内容添加到列表中，即元素列表；
对象必须是一个可以迭代的序列；
将seq打散后依次放入列表末尾。
无返回值，但会在已存在的列表中添加新的列表内容。
举例说明 假定存在两个列表a和b：
&gt;&gt;&gt; a=[1,2,3,4,5] &gt;&gt;&gt; b=[6,7,8,9,10] 如果执行a.append(b)：
&gt;&gt;&gt; a.append(b) &gt;&gt;&gt; print(a) [1, 2, 3, 4, 5, [6, 7, 8, 9, 10]] 如果执行a.extend(b)：
&gt;&gt;&gt; a=[1,2,3,4,5] &gt;&gt;&gt; a.extend(b) &gt;&gt;&gt; print(a) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649e64feb9b869c7ab0a1c7f32d45526/" rel="bookmark">
			C语言【隐式类型转换】和【显式类型转换】的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期介绍🍖
主要介绍：那些不被轻易发现的类型转换，隐式类型转换和显示类型转换👀。
文章目录 一、前言🍖二、隐式类型转换🍖2.1 整形提升🍖2.1.1 例题1🍖2.1.2 例题2🍖2.1.3 例题3🍖 2.2 算数转换🍖 三、显式类型转换🍖 一、前言🍖 C语言是一种强类型语言，当使用一种类型代替另外一种类型进行操作时或者存在两个不同类型的对象进行操作时，首先就得进行类型的转换然后再说其他。而类型转换的方式一般可分为隐式类型转换（也称：自动类型转换）和显示类型转换（也称：强制类型转换），两者有着本质上的区别。
隐式类型转换是由编译器自动进行的，不需要人为的干预，而且我们也观察不到类型是如何进行转换的，所以被称为：“ 隐式 ”。而显式类型转换是由程序员明确指定的，所以才被称为：“ 强制类型转换 ”。
二、隐式类型转换🍖 有些表达式的操作数在求值的过程中可能需要转换为其他的类型，而这种你不知晓的类型上的转换通常分为两种情况：整形提升和运算转换。
在讲整形提升和算数转换之前，还得再补充一个知识点：截断操作。何为截断操作呢？下面举个例子：char a = 3;。大家有没有想过字面常量3是如何存储到char变量a中去的呀？注意这里的字面常量3本质上是一个整数，而一个整数所占的内存空间是32个二进制位，所以这时的3在内存存放的补码如下图所示。但是你想啊，字符变量a只能存放1个字节（即：8个二进制位），怎么可能放得3呢。所以这个时候就要发生截断了，截断的规则：挑低位的字节数，放置到需要截断存储的变量中去，如下图所示。
2.1 整形提升🍖 C语言的整形算数运算总是至少以默认的整形类型（int型）的精度来进行，也就是说参与运算的操作数最小也不能小于4个字节的精度，如若精度小于4个字节该操作数就必须提升成整形的精度。所以为了获得这个精度，表达式中字符型（char）和短整型（short）操作数在使用之前就应该被转换为普通整形，这种转换被称为：整形提升。
那大家有没有想过为什么最小是以整形的精度来进行运算呢？其实表达式的整形运算是在CPU内的整形运算器（ALU）执行，而该运算器操作对象的字节长度一般就是int型的字节长度。因此CPU是无法实现直接对2个char类型的操作数的运算，而是通过先转换为CPU内整形操作数的标准长度然后再进行加法运算的。
整形提升前提条件：只有当表达式中出现长度可能小于int型的整形值时，才须要对该值进行整形提升转换为int或unsigned int型，然后再送入CPU去执行运算。
整形提升的规则：对于有符号的整形变量来说，整型提升是在高位补变量的符号位；而对于无符号的整形变量来说，整形提升是直接高位补0来实现的。
2.1.1 例题1🍖 问上面这个程序最终打印结果为什么是-126，是怎么算出来的呢？下面我们来细致的分析一下，如下图所示。首先char型变量a和b中分别放入截断后的3和127，然后将a+b整形提升运算后的结果进行截断操作放入char型变量c中，最后printf打印%d整形值时对变量c中的值进行按符号位的整形提升，得出的结果当然是-126啦。
2.1.2 例题2🍖 程序如上图所示，问为什么只有c是成功打印的，而a和b却是不行的呢？先拿char型变量a来说吧，首先我们知道a截断存储了十六进制数0xb6，内存补码为：10110110。但当执行到if语句的时候，a需要进行关系运算时需要进行有符号的整形提升，所以整型提升时应该在高位补符号位，结果为：11111111111111111111111110110110，与0xb6的二进制序列：00000000000000000000000010110110当然不一样呀，所以if(a == 0xb6)判断的结果自然为假并不会打印a了呀。同理于short类型的变量b也是如此并不会被打印，而int类型的变量c由于其并不用进行整形提升，所以判断结果为真打印了c。
2.1.3 例题3🍖 很多人会觉得这道题的结果是两个1，但值得注意的是上面这个例子中sizeof（+a）计算的是+a这个表达式值的类型所占的内存空间的大小，而+a表达式的值是a进行整形提升后的结果，所以sizeof的结果为4个字节。
2.2 算数转换🍖 我们刚刚讨论的是类型小于整形的情况，而算数转换是用来处理这些大于等于整形的情况。如果某个操作符的各个操作数属于不同的类型，那么计算是无法进行下去的，除非将这些操作数全都转化为同一类型。寻常算数转换的方向：int→unsigned int→long int→unsigned long int→float→double→long double。
举个易错的例子：
肯定有人会说打印结果必然是hehe，因为sizeof（i）的结果是4嘛，必然大于-1的。可真的是这样吗？
为什么会这样呢？ 这是因为在执行if(i &lt; sizeof(i))判断的时候隐蔽的发生了算数转换，将i的类型从int型转换成了unsigned int型，我们知道int型-1的补码在unsigned int下是一个非常大的整数必然远大于sizeof（i）计算出来的4，所以打印结果为haha。那为什么i会发生算数转换呢？ 这是因为sizeof（）表达式的返回值的类型其实是unsigned int型的。
三、显式类型转换🍖 显示类型转换又被称为强制类型转换，是由我们所决定该转换成什么样的类型，通常在转换时会存在存储精度的损失，所以在使用时需要谨慎。强制类型转换规则：(强制转换的类型)表达式。
举个列子：
你会发现强制类型转换(char)a;其实就像之前的截断操作一样，取后面的低8位然后存储到char类型的b中去，然后在printf打印的时候再按位整形提升，结果自然为-46。
这份博客👍如果对你有帮助，给博主一个免费的点赞以示鼓励欢迎各位🔎点赞👍评论收藏⭐️，谢谢！！！
如果有什么疑问或不同的见解，欢迎评论区留言欧👀。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a999de1b1f6e59b009291d6dcd56122/" rel="bookmark">
			微信背后的产品观，确实厉害！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为一个偶然的机会，看到了别人推荐《微信背后的产品观》，说是在 2013 年的时候张小龙长达 7 个小时的内部分享。那时候很多人想一窥究竟，但都没有这个机会。而在 2021 年的时候，张小龙决定将其整理出版，于是就有了此书。
看到这样的介绍，不免勾起了我的好奇心，这本书真有这么神奇吗？于是，我带着强烈的好奇心开始阅读这本书。从开始阅读到读完，我只花了半天时间。读完之后，确实觉得张小龙还是很厉害的。
产品的极致是满足人性 很多时候我们做产品，都是满足了用户的功能需求。这样做出来的产品，不能说没用，而是说价值有限。而如果你做出的产品，不仅满足了用户的功能需求，还满足了用户的心理需求，即人性深处的那些贪嗔痴。那么你的产品就具备了火起来的基础。
这里说的贪嗔痴，包括了用户的各种人性，例如：分享欲、探索周边事物的欲望等等。比如说微信的摇一摇，按张小龙的说法，是符合了人们对周围事物探索的欲望。于是这样一个功能，人家玩起来就会觉得有趣，所以就有可能火起来。
再举一个例子，漂流瓶这个事情。张小龙觉得是符合了用户倾诉、宣泄的欲望，有时候上班回到家，一个人无人可说，于是漂流瓶就扮演了这样一个角色。从某种程度上，他不仅解决了某个功能，而且是具有人文情怀的。
这是这本书对我最大的启发，即解答「什么样的产品会火？」这样一个问题。这也启发要多去了解人性，只有能准确把握人性，才能更好地做出人们喜爱的产品。产品的极致是满足人性需求。
要做有趣、爽的产品 一个好的产品，他必须是能形成用户口碑传播的，一定要让用户觉得很爽的。如果用户说不出这个字来，证明我们的产品还没成功，也不会被传播。
如果要说两个字的话就是「好玩」。当你把产品放出去，看用户怎么评论你的产品，如果他们用「好玩」来形容，那就对了，因为好玩是一种可以做主动口碑传播的舆论。
如果是「省钱」，用户未必主动发到微博上去，这让别人觉得他很小气啊，老想着省钱。但「好玩」，他就会去传播。所以「爽」和「好玩」是一种体验，是比功能更好的口碑传播点。
上面是文中摘录下来的内容，看完之后是不是觉得很有道理？确实，如果只是省钱，那么人们可能不会传播。但如果好玩、有趣，那用户会自发帮你传播。所以无论做什么事情，写文章也好，做产品也好，都要做有趣的产品。要做让用户用了觉得爽的产品。
抓主场景，不做全功能 张小龙举了漂流瓶来说明这个问题。一开始的时候，他们讨论是否要做个特殊的漂流瓶，例如某个地方的人才能收到，或者说男性、女性才能收到。但他们经过考虑，决定只做最基础的功能，而将发挥的空间留给用户。
如果用户希望是一个特殊的漂流瓶，那么可以自己去操作。这其实跟前面说到的「制造环境，让用户自己选择」这个理念相符。也就是说，我们不要替用户去做选择，而是把用户放到那样一个环境中，让用户自己去选择。
其次，这也符合他说的「化繁为简」的问题。将一个问题抽象成最简单的，然后只做最简单的这个主场景功能，而不是最太过具体的功能。因为功能一旦太过于具体，用户就没有发挥的空间了。
不要脱离场景谈问题 我们总是会说：某某竞品也上了这个功能，于是我们也要上。但很可能我们的产品，真的就不适合这样一个功能。为什么说不适合，因为这种思考方式本来就是错的。我们至少得从用户需求、用户感受出发，去看看用户需要什么，而不是竞品有什么，我们就要上什么。
书里举了语音消息是否自动播放这个功能。有些用户希望语音消息来了，就自动播放。那这个功能到底要不要做呢？如果你是微信的产品经理，你会怎么抉择呢？
此时比较正确的思路是要代入具体的场景。一般来说，需要自动播放的时候，应该是自己一个人独处的时候。这时候用户希望消息来了自动播放，不用再去点一下，确实方便了一点。但当用户并不是独处的时候，例如工作开会的时候，在地铁公交上的时候，这样的场景就不适合自动播放了。
通过列出所有可能的场景，我们发现自动播放这个功能，可能不太适合做成默认开启的。但是可以通过手动开启，让用户可以自由选择。
通过这个例子，我们可以很清晰地感受到场景的重要性。任何问题，抛开了场景，都没有讨论的意义。就像很多方法论，抛开了具体的个人，其实都很不好讨论。
极简方能不被超越 这个例子说的是摇一摇的动画和声音，张小龙说他们把动画和声音删减到了最少，几乎无法再删了。如果再删任何一点，那就会失去原有的意义。为什么这么做呢？因为张小龙觉得，只有极简的东西，才无法被超越。
我仔细想了想这其中的原因。如果做到了极简，那么竞争对手只能通过增加东西，或者改变一些东西来打造所谓的差异化。但无论如何，都是需要加点东西的，东西多了确实会让人觉得比较乱。久而久之，可能没有简单的东西来得自然。
如果一定要逻辑地推理为啥极简的东西，就是更有生命力，其实我是讲不出来的。但是我却隐约相信这种说法。例如说：我们都喜欢喝粥，虾蟹粥、排骨粥啥的。但若干年后，各式各样的粥可能都会过时，但或许只有白粥不会过时。因为白粥，真的简单到了极致，无法再少了。
我想，极简不会过时，是不是因为它是一切的基础。 例如我们的衣橱，或许各种各样的裙子、鞋子都会过时。但那些基础款的白色 T 恤，却会一直在你的衣橱里存在。
总结 要知道这本书的书稿，是在 10 年前的 2013 年。那个时候，微信还不是很火，还只是一个少数人的聊天软件。二维码也不像现在那么普及。但张小龙在那个时候，就预测到了二维码可能会火起来，微信可能会火起来。不得不说，人家对一些事情的理解确实透彻许多。
再说到对于人性的理解，确实更加透彻了。就像最近十年火爆到天的字节跳动，今日头条与抖音，他们确实也是抓住了人性的懒惰 —— 应该是信息找人，而不是人找信息。他们抓住了人性的弱点，迎合了人性，于是爆发了。
就我自己而言，我每次打开电视，我都不知道要看什么，于是过了没几分钟我就关上电视。但每次打开抖音，我不用想着看什么，直接刷就可以，简单方便无脑。这么看，人家确实就是迎合了我懒得去想的弱点。
总的来说，这是一本挺好的书，可以提高你的思想境界，值得一看！
目前这本书只有纸质版本，可以上京东去购买。价格并不是很便宜，但物有所值吧。
如果你想简单看看内容，可以看看知乎上这位朋友整理的笔记：https://zhuanlan.zhihu.com/p/470853149。
这确实是不错的书，很多东西值得细细品读。后续有时间，我要整理一下这本书的读书笔记，方便后续查找和翻阅。到时候整理好了，再和大家分享。
好了，这就是这次的读书分享了。
如果你喜欢今天的分享，记得给我一键三连哦。让我们下次见吧，bye~
推荐阅读
树哥的 JVM 小站上线了！真不错！
深入理解 volatile 关键字
深入理解 happens-before 原则
从 CPU 说起，深入理解 Java 内存模型！
Kafka 写得这么快，都是因为这些优化！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a999de1b1f6e59b009291d6dcd56122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e260cfb89206bca6cd7c1f512e009f/" rel="bookmark">
			递归的实践——反转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、递归的思想 1、确定递归函数的功能：必须确定该函数是做什么的，这也是写程序的第一步。
2、寻找零号问题（Base case）：即找出递归结束的条件。找到最终的那个问题后，它能够直接给出结果，不必再往下走了。
3、拆解，找出函数的等价关系式：每一层的问题都应该比上一层的小，不断缩小问题的 size，才能从大到小到 base case；
二、题目 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
说明:
1 ≤ m ≤ n ≤ 链表长度。
示例:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
三、思路分析 为了方便说明一个问题，这里以链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 3, n = 5为例进行分析如何用递归思想求解该题目。
在这里head指向的结点1，不用关注其后的所有结点时如何将m=3与n=5之间的部分反转的，它只需要知道反转后的结果就可以。也就是说，在这里递推公式reverseBetween的含义是：将拿到的链表反转，然后返回反转后的链表的头结点。
这样就可以初步写出如下的代码：
ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* between = reverseBetween(head-&gt;next, m-1,n-1); } 接着要做的就是，将递推公式reverseBetween返回的结果，挂在head之后，即head.next=between。
这时，代码可以进一步完善，如下所示：
ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* between = reverseBetween(head-&gt;next, m-1,n-1); head-&gt;next = between; return head; } 递推公式的部分已经完成了，接着要明确的就是递归终止条件。在这里原问题是反转链表：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 3, n = 5之间的部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12e260cfb89206bca6cd7c1f512e009f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4d39c02c3fc8af18e140ee677570fd/" rel="bookmark">
			Java引用（强引用和弱引用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引用 一、概述 众所周知，Java中是由JVM负责内存的分配和回收，它的优点是使用方便，程序员不
用再像使用c那样操心内存，但同时也是它的缺点，不够灵活。为了解决内存操作不灵活这
个问题，可以采用弱引用等方法。
在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个
对象。也就是说，只有对象处于可触及状态，程序才能使用它。这就像在日常生活中，从商
店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。
但有时候情况并不这么简单，你可能会遇到类似以鸡肋一样的物品，食之无味，弃之可惜。
这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因为也许将
来还会派用场。对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，
就先把它保留在家里，如果家里空间不够，即使把家里所有的垃圾清除，还是无法容纳那些
必不可少的生活用品，那么再扔掉这些可有可无的物品。从JDK1.2版本开始便有了对象的
引用的机制，从而使程序能更加灵活的控制对象的生命周期
二、强引用(StrongReference) 它类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚
似机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用
的对象来解决内存不足问题。强引用是使用最普遍的引用，以前我们使用的大部分引用实际
上都是强引用。例如：
只要此引用存在没有被释放（没有使student=null),垃圾回收器永远不会回收。只有
当这个引用被释放之后，垃圾回收器才可能回收，这也是我们经常所用到的编码形式。
三、弱引用（WeakReference） 如果一个对象只具有弱引用，那就类似于可有可无的生活用品。在垃圾回收器线程扫描
它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与
否，都会回收它的内存，（不过，由于垃圾回收器是一个优先级很低的线程，因此不一定
会马上发现那些只具有弱引用的对象)如：
当需要获得weakStudent引用的Student时，可以使用
如果此方法返回的为空(null)，那么说明weakStudent指向的对象student已经被回收了。
例如我们常用的在内部类的Handler中使用的Activity弱引用，防止内存泄漏：
*(谨慎入坑) *（谨慎入坑）
static class CountdownTimeHandler extends Handler{ final WeakReference&lt;MainActivity&gt; weakReference; CountdownTimeHandler(WeakReference&lt;MainActivity&gt; weakReference) { this.weakReference = weakReference; } @Override public void handleMessage(@NonNull Message msg) { super.handleMessage(msg); MainActivity activity = weakReference.get(); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab5ee4953a64252e56b8bef8cba3961/" rel="bookmark">
			Python抓取全国旅游景点以及小吃数据，想做旅游攻略？Python助你事半功倍。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 疫情自从来了之后已经很久没有出去旅游过了，蹭着这段疫情好转，那肯定是要出去走一走的，这一篇其实是全国旅游中的一站，因为每个城市能玩的地方太多了，一篇文章下来肯定是写不了的，所以今天就抓取一下——兰州。如果大家喜欢这个案例的话 后续会陆续更新的。
兰州 摘录一段来自维基百科中关于兰州的简介：
兰州市，简称 兰 ，别称 金城 ，是 中华人民共和国 甘肃省 省会，国务院批复确定的中国西北地区重要的工业基地和综合交通枢纽，丝绸之路经济带的重要节点城市，西部地区重要的中心城市之一，西北地区第三大城市，“兰州—西宁城市群”中的核心城市，位于甘肃省中部。
下面是兰州的行政区域：
爬取信息 爬取的信息主要是兰州的美食和景点信息：
import pandas as pd import re import csv import json import requests import random # 显示所有列 pd.set_option('display.max_columns', None) # 显示所有行 pd.set_option('display.max_rows', None) # 设置value的显示长度为100，默认为50 pd.set_option('max_colwidth',100) # 绘图相关 import jieba import matplotlib.pyplot as plt from pyecharts.globals import CurrentConfig, OnlineHostType # 事先导入，防止不出图 from pyecharts import options as opts # 配置项 from pyecharts.charts import Bar, Scatter, Pie, Line, HeatMap, Funnel, WordCloud, Grid, Page # 各个图形的类 from pyecharts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab5ee4953a64252e56b8bef8cba3961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b02535ec5ed469674d432a4b95f19fd/" rel="bookmark">
			SAP ABAP Selection Screen 选择屏幕看这一篇就够了（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Selection Screen 选择屏幕 文章目录 Selection Screen 选择屏幕BLOCK 块Radio button 单选框豪横的横向单选框Check Box 复选框文本框 - 一般不用 PARAMETERS文本框 - 主要使用 SELECT-OPTIONS动态显示选择屏幕Screen Icon 屏幕图标Drop Down List 下拉选项 BLOCK 块 Block 是在屏幕上划分一个区域，对屏幕进行分块便于对功能进行区分。
为了好看
SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME TITLE TEXT-001. SELECTION-SCREEN END OF BLOCK blk1. WITH FRAME 就是显示整个区域的边框
TITLE TEXT-001 就是给整个区域命名。TEXT-001 可以在文本元素里给整个 BLOCK 添加描述
Radio button 单选框 单选框，用来做选择。
选择大于努力
PARAMETERS: p_xxxx RADIOBUTTON GROUP g1 DEFAULT 'X', p_xxxx RADIOBUTTON GROUP g1. 有的时候还要加上 USER-COMMAND 关键字用于获取用户的选择，以便动态更改屏幕
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b02535ec5ed469674d432a4b95f19fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256251f1758550d2d9e2c18f98605228/" rel="bookmark">
			【大话通信】第七章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第七章-通信网络基础框架透视 传送网——一切通信网的基础 传送网主要用于多种业务的传送保障，使每个业务网的不同节点之间、不同业务网之间连接在一起。这一行业管这个领域叫“传输专业”。
语音网 为用户提供相互之间的语音通信，包括固定网（PSTN）和移动网（PLMN）的语音通信。一般研究的技术有A/D和D/A转换、交换原理、电话号码管理、传真技术、语音压缩技术等。这一行业管这个领域叫“交换专业”。
数据网 用来传输数据信息的，包括互联网数据、DDN、帧中继、VPN、视频业务等。数据网研究的介质实体包括路由器、交换机、防火墙、服务器、视频终端。一般研究的技术类型有帧中继技术、ATM技术、流媒体等。这一行业管这个领域叫“数据专
业”。
支撑网 支撑网中传递相应的监测和控制信号。支撑网包括同步系统、公共信道信令网、传输监控系统、计费、认证和营账系统以及网络管理系统等。这一行业管这个领域叫“支撑专业”。
综合网 MSTP：将以太网技术、IP技术和SDH技术结合在一起，解决城域网中IP传送的安全问题。NGN：无法判断NGN属于语音网还是数据网，NGN和移动网的IMS只是一种网络架构，由多种网络混合而成。ATM网络，利用固定的ATM技术，承载数据业务、语音业务和视频业务，其统计复用的特点，能够同时将多种业务根据各自服务要求在同一个网络上传送。ATM网络使综合性的数据网络技术。ASON：超越了常规意义上的“传送网”和“数据网”的概念，是传送网的一个发展方向。 各种网络的结构关系 从底层的光纤网络到SDH/OTN再到IP、MPLS、PSTN再到SDN时代被抽象出来的Overlay网络，每个层面都有各自的拓扑结构，也都有各自所担负的职责。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc5e3e8270922270f11f0b69c2a307d/" rel="bookmark">
			Staple目标跟踪算法C&#43;&#43;代码测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 Staple综合了局部特征HOG和全局特征颜色直方图用于目标跟踪的算法。
首先作者发现颜色分布不足以将目标和背景区分开来。局部特征这样的模板在应对剧烈形变的时候效果往往很差。
作者针对这两个问题做了一些相关工作得到以下结论。
卷积滤波器对剧烈形变不鲁棒。在线学习可能会带来模型漂移，也就是算法是将预测作为正样本来训练，更新模型。如果一旦预测不对，后面也跟着错。颜色直方图是不考虑像素位置的，这在一定程度上可以减少形变的影响。相关滤波CF的鲁棒性比较强，在目标颜色和背景颜色区分力度不够时可以发挥作用。 因此作者结合了这些实现目标跟踪。
二、理论方法 2.1 总体方法 p t = a r g m a x p ∈ S t f ( T ( x t , p ) ; θ t − 1 ) p_t=argmax_{p{\in}S_t} f(T(x_t,p);{\theta}_{t-1}) pt​=argmaxp∈St​​f(T(xt​,p);θt−1​)
对于 t t t帧，可以通过矩形 p t p_t pt​在图像 x t x_t xt​中选择一个目标，并令得分函数的值最大。
（ f f f是矩形窗口 p p p的得分函数，得分函数 T T T是一种图像变换， θ \theta θ是模型参数）
θ t = a r g m i n θ ∈ Q { L ( θ ; X t + λ R ( θ ) } \theta_t=argmin_{\theta \in Q}\{L(\theta;X_t+\lambda R(\theta)\} θt​=argminθ∈Q​{L(θ;Xt​+λR(θ)}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dc5e3e8270922270f11f0b69c2a307d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045a9b31def9c16e77fc93f08d15ab9e/" rel="bookmark">
			Vue3的权限控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3之权限控制 假设
新增有【‘sys:home:add1’,‘sys:home:edit’,‘sys:home:edit2’】这几个权限
删除有【‘sys:home:add’,‘sys:home:edit3’,‘sys:home:edit’】这几个权限
导出有【‘sys:home:add’,‘sys:home:edit’,‘sys:home:edit’】这几个权限
&lt;!-- 第一个权限与后台传输过来的就不匹配，所以不显示 --&gt; &lt;a-button v-perms="['sys:home:add1','sys:home:edit','sys:home:edit2']"&gt;新增&lt;/a-button&gt; &lt;!-- 其中有一个权限与后台传输过来的就不匹配，所以不显示 --&gt; &lt;a-button v-perms="['sys:home:add','sys:home:edit3','sys:home:edit']"&gt;删除&lt;/a-button&gt; &lt;!-- 所有的权限都是匹配的，才显示 --&gt; &lt;a-button v-perms="['sys:home:add','sys:home:edit','sys:home:edit']"&gt;导出&lt;/a-button&gt; 最终代码
import { createApp } from 'vue' import App from './App.vue' import router from './router' import store from './store' import Antd from 'ant-design-vue' import 'ant-design-vue/dist/antd.css' import * as Icons from '@ant-design/icons-vue' const app = createApp(App); // 自定义一个全局权限指令 `v-perms` app.directive('perms', (el, binding) =&gt; { const perms = binding.value; //按钮的权限 const permissions = store.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/045a9b31def9c16e77fc93f08d15ab9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32bdb37870ef72ba38ded22f39ad138f/" rel="bookmark">
			E5 调用API续订服务：Microsoft 365 E5 Renew X
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft 365 E5 Renew X Microsoft 365 E5 Renew X是一款网页版的E5续订服务，其依赖网页浏览器呈现支持用户多端操作，完全将E5账户API调用托管在了服务器端因此用户无需电脑也可使用。
Microsoft 365 E5 Renew X 由来 Microsoft 365 E5 Renew X为Microsoft 365 E5 Web的升级版，相对于旧版其增强了管理功能且更容易部署，API调用内核继承于续订桌面版软件Microsoft 365 E5 Renew Plus。
主要功能 用户端 两种可选的调用权限：用户未登录作为守护程序调用(需要客户端密码)、程序以登录用户身份直接调用(需要账户密码)API种类齐全：41/30个可选的Microsoft Graph REST API Beta中的API(未来可能会继续添加)完全随机的API调用模式：从已选定的API序列中随机抽取一个或几个进行调用（个数和API随机）完全随机的API调用时间间隔：随机区段1000s-2000s固定完全随机的API内容(仅部分API支持)：发送邮件的内容随机 Onedirve上传文件的内容随机邮件通知服务：支持设置通知邮箱，调用异常会通过邮件通知无需反复登录查看 部署端 平台兼容性：使用Asp.Net Core 作为跨平台框架增适用于 Windows|Linux|MacOS x64|x86|ARM64|ARM灵活部署：支持开放站点部署和私享部署，私享部署不再强制要求配置Https和OAuth无需数据库：不需要后台数据库支持，前后台一体化程序用户后台管理：可修改用户的E5账户数量，以及封删管理系统状态监视：系统占用率一目了然，可控的站点注册通道更容易控制系统用户数量自定义页面：支持自定义HTML静态页面，可设置支付宝、微信收款码显示ICP备案：支持ICP备案文字显示，可在国内备案建站无人值守 运行自动暂停：可自动暂停有错误率过高的账号API调用无人值守 自动恢复运行：可定期自动恢复全部账号的API调用，防止因微软网络原因触发大量账号停止API调用进而导致的账号续期失败 用户端使用教程(请勿开启账号的双重验证功能) 可用站点 主站 主站：https://e5.sundayrx.net（由 SundayRX 运营）(可登录不可注册)
分站：https://ms-e5-renew.leeskyler.top:11015（由 leeskyler 运营）(已关停)
分站：https://ms-e5-renew-3.eastern.moe（由 leeskyler 运营）(已关停)
自建共享站点 自建共享站：https://ew.chirmyram.com（由 七米蓝 运营）(可登录不可注册)
自建共享站：https://e5.hm0420.cc（由 小冰酱 运营）
自建共享站：https://ms-e5.hm0420.cc（由 小冰酱 运营）
自建共享站：https://e5.xzh.gs（由 XZH 运营）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32bdb37870ef72ba38ded22f39ad138f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c3cfab0a5540d3d30ce83cd1caf893/" rel="bookmark">
			mybatis-plus-generator 通过模板引擎 一键生成增删改查代码（CRUD）,
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-plus-generator 官网地址
mybatis-plus-generator 代码生成器， 可以生成controller 、service/serviceImpl，以及mapper/mapper.xml、entity以及通过模板引擎配置生成
生成业务代码，一般的增删改查都可以生成
源码的话我放在了阿里云盘上面了：不然太多代码在这上，看着也头疼
第一步复制mybatis-plus-generator里面交互式
第二步：修改连接信息，以及包名重点修改我标记出来的地方
第三步修改配置模板 ：这张图中标记的是，生成的模板位置
mybatis-plus-generator默认生成代码的的格式就是来着这个模板，只不过我重写了
在mybatis-plus-generator的jar中我们可以找到这个模板
第四步重写模板：比如我重写的模板
到时候生成的时候就会根据这个模板来生成一些通用的增删改查代码，当然我这里没有列举完。
第五步： 然后启动这个类。就会有交互式的生成代码
会遇到一些问题的地方：
当然如果只看图片是有问题的，比如说这边个demo里面直接启动springboot的话，会出现一些问题
比如说：
Could not autowire field: private lf.service.UserService lf.controllers.UserController.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [lf.service.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} 这个是没有设置mybatis的mapper路径，@MapperScan没有设置 ，在springboot启动类上加上这个注解然后设置扫描路径，
还有一点要在applictaion.properties文件里面设置数据库连接信息，比如说url，username,password ,driverclassname什么的 不然启动也是启动不了的
就像：
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c3cfab0a5540d3d30ce83cd1caf893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef7d45d65b41cb51056a56776ff583c6/" rel="bookmark">
			软考初级信息处理技术员基础知识考点（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不要看小看初级哦~还是有很多知识点需要背诵的呢~
考点1. 信息与数据
基本概念：①信息是客观事物在其运动、演化以及相互作用等过程中所呈现的现象、属性、关系与规律等。②数据是信息载体上所反映的信息内容、接收者可以识别的符号。不仅指数字，而且包括字符、文字和图形等。
重点记忆：①信息同物质、能量并列为世界三大资源。同时，智能是第四大资源。②数据是信息的具体表现形式，信息是数据的本质含义。即：数据是信息的载体，信息是数据的内涵。信息与载体的性质无关，而数据的具体形式则取决于载体的性质。③数据的基本性质：普遍性、客观性、识别性、动态性、时效性、传递性、共享性、价值性、不完全性，注意信息可以共享，可以反复利用。数据具有时效性，即过了一段时间，这个信息可能不再有价值。
这个知识点考的频率很高，每年都会考到，所以一定要加以掌握。
考点2. 问卷设计 社会化问卷调查设计要点：
1) 问题要明确，不含糊，让人易于理解，不产生误解；
2) 问卷中所选问句必须紧扣主题，先易后难；
3) 问卷的设计还要考虑到回收后便于处理（包括校验、整理和统计等)；
4) 要以选择答案题型为主，让人容易答；
5) 不要有诱导性、侮辱性、泄露隐私性的问题等；
6) 社会调查中一般不需要提供敏感的个人信息，包括姓名和联系方式等。
7) 问题中应尽量以通俗的术语来说明，过于专业的术语（如医学名词、化学名词）会让大众远离问答。
考点3. 数列、排列和组合 等差数列的数列项和数列和计算： an=a1+(n-1) × d Sn=n×a1 +n×(n-1) ×d/2
等比数列的数列项和数列和计算：an=a1 × qn-1 Sn= a1 × (1-qn)/(1-q) (q≠1)
组合：从n个不同的元素中，任取m（m&lt;n）个元素并组成一组，叫做从n个不同元素中取出m个元素的组合
排列：从n个不同的元素中，任取m（m&lt;n）个元素按照一定的顺序排成一列，叫做从n个不同的元素中取出m个元素的一个排列
考点4. 数据的简单统计 1、 总体（母体）：调查对象的全体；个体：总体中每一个考察对象；样本：总体中所抽取的一部分个体；样本容量：样本中个体的数目
2、 众数：一组数据出现次数最多的数据；中位数：一组数据从小到大的顺序依次排序，处于中间位置的一个数或最中间两个数的平均数；平均数：所有数据求和，然后除以总个数。
3、 方差和标准差： 测算离散趋势最重要、最常用的指标。当数据分布比较分散时，各个数据与平均数的差的平方和较大，方差就较大；当数据分布比较集中时，各个数据与平均数的差的平方和较小。因此方差越大，数据的波动越大；方差越小，数据的波动就越小。
4、 简单表：主辞未分组；分组表：主辞按一个标志分组；复合表：主辞按两个以上标志分组；列联表：多个变量分类时所出现的频率。
考点5. 统计图表 直方图：由一系列高度不等的纵向条纹或线段表示数据分布的情况。显示一段时间内数据的变化或显示不同项目之间的对比。
直条图：用等宽直条的长短来表示相互独立的各指标的数值大小。显示不同项目之间的对比。
折线图：用线段的升降表示事物在时间上的变化趋势, 或某现象随另一现象变动的情况。适用于显示在相等时间间隔下数据的趋势。
散点图：用点的密集程度和变化趋势表示两种现象之间的相互关系。适用于双变量资料。
饼形图：用圆的面积代表事物的全部, 用各扇形的面积代表事物的构成比。
面积图：强调数量随时间或类别而变化的程度，或引起人们对总值趋势的注意。
雷达图：即一个评估内容的各项指标的评分项目集中划在一个圆形的图表上，来表现一个其各项情况。适用于多属性体系结构描述的对象作出全局性、整体性评价。
圆环图：显示各个部分与整体之间的关系，且可以包含多个数据系列。
考点6. 数据收集 1、 数据收集前必须要先制定收集计划、设计详细的调查方案。数据收集阶段将耗费大量人力物力财力，且时间长。信息收集工作的好坏，直接关系到整个信息管理工作的质量。信息分成原始信息（一手数据）和加工信息（二手数据）。数据收集要客观、真实，一定要注意不要按照预想的或者公司希望的、或者说符合统计结果等方向去收集数据。另外，数据力求真实，尽量不从论坛、社交网站上去搜索大家发布的数据，要力求数据的真实和权威性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef7d45d65b41cb51056a56776ff583c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859b1c287460bdbb09bbe173e6bff66d/" rel="bookmark">
			[Error] range-based ‘for‘ loops are not allowed in C&#43;&#43;98 mode解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 vector&lt;int&gt; postion; // A for(vector&lt;int&gt;::iterator i = postion.begin(); i &lt; postion.end(); i++) cout &lt;&lt; *i &lt;&lt;endl; // B	for(int i : postion) cout &lt;&lt; i &lt;&lt;endl; 代码A和代码B都是一样的作用：遍历输出容器postion的元素，很显然代码B更简洁。
代码B报错解决方法 工具 - 程序，添加 -std=c++11（前面有空格隔开），即可。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/145/">«</a>
	<span class="pagination__item pagination__item--current">146/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/147/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>