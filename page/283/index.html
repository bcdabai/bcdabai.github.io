<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438e3f9d7bdb0fa7c8c0920e57df2d74/" rel="bookmark">
			n个数依次入栈，出栈顺序有多少种？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考网址：参考1 ，参考2
原题 有一个容量足够大的栈，n个元素以一定的顺序入栈，出栈顺序有多少种？
比如，AB两个元素，入栈顺序为AB，出栈情况有两种：
（1）入A，出A，入B，出B，出栈顺序为AB；
（2）入A，入B，出B，出A，出栈顺序为BA。
因此，2个元素时，结果为2。
分析：设f(n)为“n个元素以一定的顺序入栈，出栈顺序的种类数”。显然f(1)=1,f(2)=2。我们现在来分析一般情况。一般情况下，我们可以按照“第一个入栈的元素，在出栈序列中的位置”作为分类手段。
举个例子，我们假设入栈元素为A，B，C，D。我们按照“A在出栈序列中的位置”分类讨论：
（1）当A第一个出栈时，A先进，然后马上出栈。这种情况下，共有“BCD出栈顺序的种类数”种方案。也就是f(n-1)。
（2）当A第二个出栈时，A先进，B再进，之后B需要马上出来（这样才能确保A排第二）。此时共有f(n-2)种方案。
（3）当A第三个出栈时，A先进，之后只要确保排在A后面两个的元素比A先出即可。此时共有f(2)*f(n-3)种方案。f(2)是指“BC入栈出栈顺序的种类数”，f(n-3)是指”D入栈出栈的种类数”。
……
分析到这里，规律就很显然了。
从第一项开始，分别是第一个入栈元素在第i+1个出栈的情况数。
上式中，令f(0)=1 。
这个实际上是卡特兰数（Catalan number，又称卡塔兰数）。
若编程实现，需要维护一个一维数组，时间复杂度为O(n^2)。（递归实现的时间复杂度太高）。
卡塔兰数的通项公式为h(n)=C(2n,n)-C(2n,n+1)(n=0,1,2,...)。
元素A、B、C、D依次进栈,写出所有可能的出栈序列
应该有14种情况
A第一个出栈：ABCD;ACBD;ACDB;ABDC;ADCB;
A第二个出栈：BACD;BADC;
A第三个出栈：CBAD;BCAD;
A第四个出栈：BCDA;CBDA;CDBA;BDCA;DCBA.
卡特兰数 卡特兰数前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ...
令h(0)=1,h(1)=1，catalan数满足递推式：　h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n&gt;=2)
例如：h(2)=h(0)*h(1)+h(1)*h(0)=1*1+1*1=2　h(3)=h(0)*h(2)+h(1)*h(1)+h(2)*h(0)=1*2+1*1+2*1=5　另类递推式：　h(n)=h(n-1)*(4*n-2)/(n+1);　递推关系的解为：　h(n)=C(2n,n)/(n+1) (n=1,2,3,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/438e3f9d7bdb0fa7c8c0920e57df2d74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae4369e3c66f00fe8872ad8be0de634/" rel="bookmark">
			git clone下载时遇到的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在下载代码时遇到过两次同样的问题，因此特将解决办法在此记录下去，希望可以帮助也有共同困扰的小伙伴！ 在git clone下载代码时遇到如下错误： Username for 'https://github.com': Newbie Password for 'https://Newbie@github.com': Counting objects: 11507, done. Delta compression using up to 4 threads. Compressing objects: 100% (8210/8210), done. Writing objects: 100% (11506/11506), 21.75 MiB | 0 bytes/s, done. Total 11506 (delta 2213), reused 11504 (delta 2211) efrror: RPC failed; result=56, HTTP code = 200 atal: The remote end hung up unexpectedly fatal: The remote end hung up unexpectedly Everything up-to-date 在百度之后有如下两种解决方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ae4369e3c66f00fe8872ad8be0de634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6599051b43efb255503fdef3de2a06a/" rel="bookmark">
			Wind10下 Redis 服务无法启动，错误 1067 进程意外终止解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 Redis服务无法启动，查看redis日志
提示 Can't open the append-only file: Permission denied
到安装目录Redis-x64-2.8.2103中将appendonly.aof文件只读属性去掉即可，亲测可用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01842479f2ab60d45bb10ef188d59ba6/" rel="bookmark">
			TCP/IP 模型 与 OSI 七层模型的对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP 模型与 OSI 七层模型 七层有底向上分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
简化后的四层分别是：主机到网络层（比特）、网络层（数据帧）、传输层（数据包）、应用层（数据段）。
每一层对于上一层来讲是透明的，上层只需要使用下层提供的接口，并不关心下层是如何实现的 TCP/IP 模型： （1）数据链路层
主要提供链路控制（同步，异步，二进制，HDLC），差错控制（重发机制），流量控制（窗口机制）
1） MAC：媒体接入控制，主要功能是调度，把逻辑信道映射到传输信道，负责根据逻辑信道的瞬时源速率为各个传输信道选择适当的传输格式。MAC层主要有3类逻辑实体，第一类是MAC-b，负责处理广播信道数据；第二类是MAC-c，负责处理公共信道数据；第三类是MAC-d，负责处理专用信道数据。
2）RLC：无线链路控制，不仅能载控制面的数据，而且也承载用户面的数据。RLC子层有三种工作模式，分别是透明模式、非确认模式和确认模式，针对不同的业务采用不同的模式。
3）BMC：广播/组播控制，负责控制多播/组播业务。
4）PDCP：分组数据汇聚协议，负责对IP包的报头进行压缩和解压缩，以提高空中接口无线资源的利用率。
（2）网络层
提供阻塞控制，路由选择（静态路由，动态路由）等
1）IP：IP协议提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。IP地址是重要概念
2）ARP：地址解析协议。基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。以太网中的数据帧从一个主机到达网内的另一台主机是根据48位的以太网地址（硬件地址）来确定接口的，而不是根据32位的IP地址。内核必须知道目的端的硬件地址才能发送数据。P2P的连接是不需要ARP的。 3）RARP：反向地址转换协议。允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。局域网网关路由器中存有一个表以映射MAC和与其对应的 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向路由器上的 RARP 服务器请求相应的 IP 地址。假设在路由表中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器。
4）IGMP：组播协议包括组成员管理协议和组播路由协议。组成员管理协议用于管理组播组成员的加入和离开，组播路由协议负责在路由器之间交互信息来建立组播树。IGMP属于前者，是组播路由器用来维护组播组成员信息的协议，运行于主机和和组播路由器之间。IGMP 信息封装在IP报文中，其IP的协议号为2。
5）ICMP：Internet控制报文协议。用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。
6) BGP :边界网关协议。处理像因特网大小的网络和不相关路由域间的多路连接。
7）RIP：路由信息协议。是一种分布式的基于距离矢量的路由选择协议。
（3）传输层
提供分割与重组数据，按端口号寻址，连接管理差错控制和流量控制,纠错的功能。传输层要向会话层提供通信服务的可靠性，避免报文的出错、丢失、延迟时间紊乱、重复、乱序等差错。
1）TCP: 一种面向连接的、可靠的、基于字节流的传输层通信协议。
2) UDP: 用户数据报协议，一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。
3）RTP： 实时传输协议，为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。
4）SCTP： 一个面向连接的流控制传输协议，它可以在两个端点之间提供稳定、有序的数据传递服务。SCTP可以看做是TCP协议的改进，它继承了TCP较为完善的拥塞控制并改进TCP的一些不足：
a. SCTP是多宿主连接，而TCP是单地址连接。
b.一个TCP连接只能支持一个流，一个SCTP连接可以支持多个流。
c.SCTP有更好的安全性。
（4）应用层
1）HTTP：超文本传输协议，基于TCP，是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。
2）SMTP：简单邮件传输协议,是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。
3）SNMP：简单网络管理协议，由一组网络管理的标准组成，包含一个应用层协议、数据库模型和一组资源对象。
4）FTP：文件传输协议，用于Internet上的控制文件的双向传输。同时也是一个应用程序。
5）Telnet：是Internet远程登陆服务的标准协议和主要方式。为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。
6）SSH：安全外壳协议，为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。
7）NFS：网络文件系统，是FreeBSD支持的文件系统中的一种，允许网络中的计算机之间通过TCP/IP网络共享资源。
OSI 七层模型： 【1】物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01842479f2ab60d45bb10ef188d59ba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27de7027074d7cca733ab8ae2290a3f4/" rel="bookmark">
			pdf.js详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pdf.js可以实现在html下直接浏览pdf文档，是一款开源的pdf文档读取解析插件
pdf.js主要包含两个库文件，一个pdf.js和一个pdf.worker.js，一个负责API解析，一个负责核心解析。
pdf.js可通过pdf文件的地址或pdf数据流获取pdf，具体实现是调用接口函数 PDFJs.getDocument(url/buffer)将pdf载入html，通过canvas处理, 然后渲染pdf文件。将pdf转换成数据流，因为转换成流的话可以解决pdf.js的跨域问题。
pdfjs是在canvas上又盖了一个div，把文本显示在里面的各个小div里的，记得是pdfjs有一个API page.getTextContent().then(function(textContent) ， 需要用到的可以查一下如何实现。
官网用的viewer.js：http://mozilla.github.io/pdf.js/web/viewer.html，首先底图是一个Canvas，内容和PDF一样（通过下面介绍的page.render方法可以得到），底图之上是一个textLayer，这一层就是通过page.getTextContent()得到了字体的位置和样式，再覆盖在Canvas上。
可以实现在html下直接浏览pdf文档，是一款开源的pdf文档读取解析插件
pdf.js主要包含两个库文件，一个pdf.js和一个pdf.worker.js，一个负责API解析，一个负责核心解析。
pdf.js可通过pdf文件的地址或pdf数据流获取pdf，具体实现是调用接口函数 PDFJs.getDocument(url/buffer)将pdf载入html，通过canvas处理, 然后渲染pdf文件。将pdf转换成数据流，因为转换成流的话可以解决pdf.js的跨域问题。
pdfjs是在canvas上又盖了一个div，把文本显示在里面的各个小div里的，记得是pdfjs有一个API page.getTextContent().then(function(textContent) ， 需要用到的可以查一下如何实现。
官网用的viewer.js：http://mozilla.github.io/pdf.js/web/viewer.html，首先底图是一个Canvas，内容和PDF一样（通过下面介绍的page.render方法可以得到），底图之上是一个textLayer，这一层就是通过page.getTextContent()得到了字体的位置和样式，再覆盖在Canvas上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbcd3f97819d5b1b2c3803857aac0a4/" rel="bookmark">
			java byte数组异或校验时出现负数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 最近由于需要对接校园的刷卡机支付，协议需要用到异或校验。参照校验的流程对相邻数组进行异或，得出的结果却与示例的不一样，而且还是负数。 起先以为自己的算法或者数据有问题，但是检查了一遍后还是一样。
分析原因 由于协议中有字段表示的数值大于127，如协议中该字段16进制为0XA2，本来数值应该是162，结果转变成byte时变成了-94，异或校验后该字段的数值变为了负数，导致异或校验的结果不正确，这是因为java中的byte是有符号位的byte，这点和c++不一样，因此可表示的数据为-127~127（最高位为符号位）。知道了原因，剩下的就是问题的解决了。
解决方法 既然是数值太大导致byte溢出了，那么只要解决溢出的问题就好了。在这里我们只关心校验的结果，因此把byte用int类型来表示就能解决数值的问题了。 可以将异或的结果使用int类型表示（这是为了防止结果出现负数）,在异或的过程中，将溢出的byte数据（即数值超出127的）通过&amp;0xff将符号为变成正数，同时由于byte保存不了变为正数的数据，需要分配一个临时变量来保存并参与运算。
以下为解决的代码：
/** 获取指令异或值 * @param datas * @return */ private int getXOR(byte[] datas) { int temp = datas[1]; // 此处首位取1是因为本协议中第一个数据不参数异或校验，转为int防止结果出现溢出变成负数 for (int i = 2; i &lt; datas.length; i++) { int preTemp = temp; int iData; if (datas[i] &lt; 0) { iData = datas[i] &amp; 0xff; // 变为正数计算 } else { iData = datas[i]; } if (temp &lt; 0) { temp = temp &amp; 0xff; // 变为正数 } temp ^= iData; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbcd3f97819d5b1b2c3803857aac0a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df475e3f884f19f393c26cf1edfef193/" rel="bookmark">
			vue 在使用element-ui时import &#39;element-ui/lib/theme-chalk/index.css‘时一直报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在package.json中确认style-loader是否下载，如果下载，是否在config文件中进行配置
配置文件如下：
{ test: /\.css$/, loader: 'style-loader!css-loader', exclude: /node_modules/ } 如果仍然无法正常运行，则是因为在elment-ui中css中运用了饿了么的字体库，即.wtff文件，
这导致任然缺少一个解析器，即url-loader
cnpm i url-loader -D 然后再配置文件中，加上
{ test: /\.(woff|svg|eot|ttf)\??.*$/, loader: 'url-loader' }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736064f91d9fd8d5ab3f6fdbb485d9ca/" rel="bookmark">
			Android--从本地相册获取图片并显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android--从本地相册获取图片并显示 很多博客讲这部分内容会和其他的混在一起讲，看起来会比较费劲，为了更方便的调用，特意写了如何从本地获取图片以及 显示这部分代码。
1、布局文件：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.choose_photo.MainActivity"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="choose" android:id="@+id/choose"/&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/imageview"/&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 2、Maintivity
package com.example.choose_photo; import android.content.Intent; import android.graphics.Bitmap; import android.net.Uri; import android.provider.MediaStore; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.ImageView; import java.io.IOException; public class MainActivity extends AppCompatActivity { private Button button; private ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736064f91d9fd8d5ab3f6fdbb485d9ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c52cb06619c984ff9e6c975ec6d7a64/" rel="bookmark">
			PHP5与PHP7兼用性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串赋值问题
在修改已有的游戏后台代码中，发现有许多功能无法正常显示出来，都是乱码的格式。之后追查问题的时候，发现之前的代码是$a=''这样子来赋值的。但是之后的操作又是数组赋值操作，看到这里我就发现问题的所在了。PHP7其实是不支持类型转换的，也就是$a=''后就是字符串了，然而PHP7之前是支持直接转类型的。所以就导致了在升级PHP版本后后台乱码出现。 PHP5： PHP7： 总结： 代码的规范很重要，明明是使用数组来操作的，但是却使用字符串赋值，这很明显就是规范不好，导致代码不能向后兼容。正常的思维都是数组操作赋值$a=[]这样子的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3042f76ba099b134800b0d01e264c34/" rel="bookmark">
			VMware配置linux网络及端口问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.VMware网络配置
2.三种网络模式详解
2.1 桥接模式
2.2 NAT模式（地址转换模式）
2.3Host-Only（仅主机模式）
3.虚拟机的网络配置
3.1进入我们的linux系统，先查看linux的网络状态
3.2配置网络文件，根据自己电脑的网卡修改相应的xxx文件
3.3编辑完成，保存退出，然后重启虚拟机网卡
4.防火墙配置，关于访问ip+端口无法访问的问题
4.1使用centos7默认安装的firewalld（推荐使用）
4.2启动防火墙
4.3测试访问tomcat
5.iptables防火墙命令（扩展）
今天讲一讲在linux配置网络中遇到的坑及总结。
这里我的linux是安装在虚拟机VMware上的，先配置VMware的网络，这里我配置的是桥接模式，后面有三种模式的讲解。
详细教程可以参考： https://www.linuxidc.com/Linux/2016-09/135521p2.htm
1.VMware网络配置 打开VM的编辑---&gt;虚拟网路编辑器--&gt;桥接模式--&gt;自动
接着，编辑虚拟机设置---&gt;网络适配器--&gt;选择 桥接模式
2.三种网络模式详解 2.1 桥接模式 桥接模式是三种模式中最简单的一种，VMware安装的时候默认就使用这种配置方式。在这种模式下，虚拟机相当于局域网中的一台独立机器，和主机处于同一个网段，公用同一个网关。桥接模式使用的是虚拟机的VMnet0网卡，一般情况下，在虚拟机中将网络设置成自动获取IP就能直接联网。
总结，直接连接路由器，相当于公司另一台电脑
2.2 NAT模式（地址转换模式） 如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。
在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。
总结，直接连接主机，相当于把主机当路由器，通过虚拟NAT连接外网。
2.3Host-Only（仅主机模式） Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯
总结，只于主机连接，通过主机连接外网。
3.虚拟机的网络配置 3.1进入我们的linux系统，先查看linux的网络状态 # ifconfig
3.2配置网络文件，根据自己电脑的网卡修改相应的xxx文件 # vim /etc/sysconfig/network-scripts/ifcfg-xxx文件
嫌麻烦的话可以配置动态网络，将bootproto设置dhcp即可
配置静态网络
3.3编辑完成，保存退出，然后重启虚拟机网卡 # systemctl restart network
测试能不能ping通外网
# ping www.baidu.com
测试能不能ping通主机，这里用你们本地电脑的ip，可以去运行--&gt;cmd---&gt;ipconfig查看本机ip
# ping 192.168.0.xxxx
4.防火墙配置，关于访问ip+端口无法访问的问题 当我们ping www.baidu.com 外网连接没问题，ping 192.168.0.1 本地连接也没问题时，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3042f76ba099b134800b0d01e264c34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d24a16c1f6c5047135b451e64b0ba04/" rel="bookmark">
			JAVA面向过程（三十三）  语句块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语句块(有时叫做复合语句)，是用花括号扩起的任意数量的简单Java语句。块确定了局部变量的作用域。块中的程序代码，作为一个整体，是要被一起执行的。块可以被嵌套在另一个块中，但是不能在两个嵌套的块内声明同名的变量。语句块可以使用外部的变量，而外部不能使用语句块中定义的变量，因为语句块中定义的变量作用域只限于语句块。
测试语句块　：
1
2
3
4
5
6
7
8
9
10
public class Test19 {
public static void main(String[] args) {
int n;
int a;
{
int k;
int n; //编译错误：不能重复定义变量n
} //变量k的作用域到此为止
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5cb3cc42e0bf86ea59233b5ea909f1a/" rel="bookmark">
			JAVA面向过程（三十二）  带标签的break和continue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在Java语言中得到正式使用;Java没有goto语句。然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子---带标签的break和continue。
“标签”是指后面跟一个冒号的标识符，例如：“label:”。对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。
在 “goto有害”论中，最有问题的就是标签，而非goto， 随着标签在一个程序里数量的增多，产生错误的机会也越来越多。 但Java标签不会造成这方面的问题，因为它们的活动场所已被限死，不可通过特别的方式到处传递程序的控制权。由此也引出了一个有趣的问题：通过限制语句的能力，反而能使一项语言特性更加有用。
测试带标签break和continue：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927251d52de351f618624b606a51a117/" rel="bookmark">
			JAVA面向过程（三十一）  break和continue区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。 测试break语句：
continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。 注意事项
1. continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。
2. continue用在for循环中，跳到for循环的迭代因子部分。
测试continue语句：把100~150之间不能被3整除的数输出，并且每行输出5个
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5d145c0611be6fedca902acceb7594/" rel="bookmark">
			table表格做一个表头斜线样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体代码实现如下:
&lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;带表头斜线的表格&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } table { border: 1px solid #fff; /*去掉表格之间的空隙*/ border-collapse:collapse; margin: 100px auto; } caption { font-size: 20px; font-weight: bold; } th,td{ border: 1px solid #ccc; width: 80px; font-size: 14px; line-height: 40px; text-align: center; } /*模拟对角线*/ .out{ border-top:40px #D6D3D6 solid;/*上边框宽度等于表格第一行行高*/ width:0px;/*让容器宽度为0*/ height:0px;/*让容器高度为0*/ border-left:80px #BDBABD solid;/*左边框宽度等于表格第一行第一格宽度*/ position:relative;/*让里面的两个子容器绝对定位*/ } b{ font-style:normal; display:block; position:absolute; top:-40px; left:-40px; width:50px; } em{ font-style:normal; display:block; position:absolute; top:-25px; left:-70px; width:55px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;caption&gt;我是标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a5d145c0611be6fedca902acceb7594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc99a5dd631ee2a81714f034aa612520/" rel="bookmark">
			【Mongo】mongo更新字段为另一字段的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新字段为另一字段的值 db.postMongo.find(过滤条件).forEach( function(item){ db.postMongo.update({"_id":item._id},{"$set":{"summary":item.content}},false,true) } ) db.postMongo.find({'summary':{$exists:false},'content':{$exists:1} }).forEach( function(item){ db.postMongo.update({"_id":item._id},{"$set":{"summary":item.content}},false,true) } ) 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/29096438/viewspace-2212784/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/29096438/viewspace-2212784/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a29bdd47ee721fc156521a61306424/" rel="bookmark">
			突变点检测：Mann-Kendall突变点检测（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不废话，直接上python代码
# Mann-Kendall突变点检测 # 数据序列y # 结果序列UF，UB #-------------------------------------------- import numpy as np import matplotlib.pyplot as plt plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签 plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 def Kendall_change_point_detection(inputdata): inputdata = np.array(inputdata) n=inputdata.shape[0] # 正序列计算--------------------------------- # 定义累计量序列Sk，初始值=0 Sk = [0] # 定义统计量UFk，初始值 =0 UFk = [0] # 定义Sk序列元素s，初始值 =0 s = 0 Exp_value = [0] Var_value = [0] # i从1开始，因为根据统计量UFk公式，i=0时，Sk(0)、E(0)、Var(0)均为0 # 此时UFk无意义，因此公式中，令UFk(0)=0 for i in range(1,n): for j in range(i): if inputdata[i] &gt; inputdata[j]: s = s+1 else: s = s+0 Sk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a29bdd47ee721fc156521a61306424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968e1c40b31413194e3e77e2752148da/" rel="bookmark">
			【My SQL】常见语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库 1、创建数据库 fruit
CREATE DATABASE fruit; 2、选择数据库
USE fruit; 3、删除数据库
DROP fruit; 4.查看数据库
SHOW fruit; 二、表 1.创建表 apple
CREATE TABLE apple; 2.更新表
①向表中增加新列 color
ALTER TABLE fruit.apple ADD COLUMN color char(10); ②删除表中多余的列
ALTER TABLE fruit.apple; DROP COLUMN color; 3.重命名表
RENAME TABLE fruit to vegetables 4.删除表
DROP TABLE apple 5.查看表
SHOW fruit.apple; 6.显示数据库中所有的表
USE fruit; Database changed SHOW TABLES; 7.显示表的结构
SHOW COLUMNS FROM apple; 或 DESC fruit.apple; 三、索引 1.创建索引
①升序索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968e1c40b31413194e3e77e2752148da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2d882c3e87263ca0a3de2ddcebc2fe/" rel="bookmark">
			滑动窗口和拥塞窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，滑动窗口 窗口：发送者发送的连续字节序列的集合
滑动：发送的窗口可以随发送过程而变化。
为什么需要窗口：不必每一个段进行一次确认应答，而是以一个窗口的大小进行确认。减少往返时间，提高速度。（TCP在发送时其实是以字节为单位的）
窗口控制和重发机制：
1，数据已到达对端，但确认ack丢失，这种情况是不需要重发的。如果没有使用窗口机制则需要重发。某一个ack丢失，在窗口机制下可以通过下一个确认ack进行应答。在滑动窗口下，就算某些应答丢失也不会重发。
2，某个报文段丢失，一直重发发送确认ack。但对端该发送的还在发送。如果发送方连续收到3次同一个确认ack，就会重发数据。但是此时数据已经乱序了。这就是快速重发。
滑动窗口的功能：
1，保证数据的可靠传递
未确认的数据必须被发送方缓存起来确认的数据将会移除缓冲区 2，保证数据的有序传输
乱序的数据必须被接收方缓存起来 3，提供End-to-End的流控机制
发送方发送太快就必须阻塞等待 什么是流量控制：
所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制。主要的方式就是返回的ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送
流量控制的两个极端：
一次发送一个字节(停等协议，效率极低)发送拥有的所有数据(可能使接收方来不及接收，原端也无法尽快知道数据包的丢失) TCP使用折中的方式：滑动窗口协议，发送方和接收方都有滑动窗口。
发送方滑动窗口：
窗口移动：
1，关闭，即窗口左边界右移。当已发送数据得到ack时，窗口会减小。
2，打开，右边界右移，使得可发送数据量增大。当确认数据得到处理，接收端可用缓冲区变大，窗口也随着变大。
3，收缩，窗口右边界右移，不允许这种做法。
一个字节探测包和0通告窗口：
接收方发送了一个通告窗口为0的ACK，这种情况下发送方必须暂停发送数据，直到一个新的带非零窗口的通告(ACK)收到为止。为了避免非零窗口的通告丢失，发送方在收到零窗口后启用persistence timer，发送1个字节的探测数据包，直到窗口重新打开为止。 注意：
实际发送窗口大小是rwnd（接收端TCP报文的窗口大小字段）和cwnd（拥塞窗口大小）中的较小值。源端并非必须要发送整个窗口大小的数据。 接收方滑动窗口：
第一部分，是已接收到了并确认的，但是还没被进程消耗。此时还需要占用接收缓冲区
第二部分，是接收窗口，接收后将会保存。
第三部分，不能接收。
二，拥塞窗口 拥塞：路由器因无法处理高速到达的流量而被迫丢弃数据信息的现象称为拥塞。
为什么有的流量控制，还需要拥塞控制？
流控只简单地表明了接收方的处理能力，并不能代表中间网络的处理能力 如果一开始把流控窗口内的数据全部发送出去，中间路由器可能一时处理不了如此多的突发流量 拥塞窗口（cwnd）和通告窗口（awnd）
实际的发送窗口：W=min(cwnd,awnd)。两者之间较小的。
如果接收方慢：W=awnd
如果网络慢：W=cwnd
拥塞控制算法：
慢启动拥塞避免超时重传快速重发快速恢复 慢启动：
初始化：cwnd=1mss；以后每收到一个ack，cwnd+=1mss；相当于指数增大 拥塞避免： 当cwnd超过ssthresh（慢启动阈值）时，每收到一个ack，cwnd+=1/cwnd；相当于加法增大 超时重传：
cwnd越来越大，导致有包丢失。这时需要重传数据。ssthresh=max(cwnd/2, 2) 这个的意思是cwnd/2 但是至少是2个报文段cwnd=1，重新进入慢启动 下图为以上描述的整个过程
快速重传：
发送方收到3次重复的ack，就立即重传数据。ssthresh=max(cwnd/2, 2)； 快速恢复：
cwnd=ssthresh+3MSS；每收到重复的ack，cwnd+=1MSS； 当收到新的ack时，cwnd重设为ssthresh，并退出快速恢复阶段。cwnd=ssthresh，然后进入加法增大（拥塞避免）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a8e78906fd6e5ac3803725c45d7a9c1/" rel="bookmark">
			The following packages have unmet dependencies错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当出现类似这类错误：
The following packages have unmet dependencies: python-dev : Depends: python (= 2.7.5-5ubuntu3) but 2.7.12-1~16.04 is to be installed Depends: libpython-dev (= 2.7.5-5ubuntu3) but it is not going to be installed Depends: python2.7-dev (&gt;= 2.7.5-1~) but it is not going to be installed E: Unable to correct problems, you have held broken packages. 这是由于安装包的版本太新，其依赖包和旧版本冲突导致。
网上常见解决方法：apt-get -f install，but it doesn't work for me，或者说使用aptitude的，试了下很慢。
后来我把阿里源换回Ubuntu原生的源就可以安装了，因为阿里源的包太新。
转载于:https://www.cnblogs.com/willaty/p/9522591.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1666092290c13b32a4ffaa3d337483bf/" rel="bookmark">
			js中 value、innerHTML、innerText和textContent的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		value：应用于表单的输入框（textarea除外）innerHTML:可以写入HTML代码，写入的HTML代码可以被解析，获得时候也可以获得HTML代码innerText：获得内容的时候，会忽略HTML代码，写入HTML代码不能解析。获得内容与HTML解析的内容一样textContent：获得内容的时候，会忽略HTML代码，写入HTML代码不能解析。获取的内容与源码内容一样 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;修改元素的文本&lt;/title&gt; &lt;style type="text/css"&gt; div{ width:300px; height:300px; float:left; border:1px solid blue; margin-left:50px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;p&gt;i love you&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;J 哥 最 帅&lt;/p&gt; &lt;a href="http://www.xxoo.com"&gt;xx oo&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var divs=document.getElementsByTagName('div'); /* value :应用于表单的输入框---textarea innerHTML：与后两者的区别，可以写入html代码会被解析，并且可以获得html代码 innerText:获得内容的时候，都会忽略html代码 textContent:获得内容的时候，都会忽略html代码 */ //读取内容 console.log(divs[0].innerHTML); console.log(divs[0].innerText); console.log(divs[0].textContent); //写入内容 divs[1].innerHTML='&lt;p&gt;i miss you&lt;/p&gt;'; divs[2].innerText='&lt;p&gt;i miss you&lt;/p&gt;'; divs[3].textContent='&lt;p&gt;i miss you&lt;/p&gt;'; /* 比较innerText和textContent的区别 innerText 获取的内容和html解析的内容一样 textContent获取的内容与源代码的内容一样 */ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1666092290c13b32a4ffaa3d337483bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33e8d904a9f0b1c2dcaccb5a334e053/" rel="bookmark">
			SecurityUtils.getSubject().getPrincipal() 为null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用shiro时，如果正常登陆（执行subject.login(token)成功）就能在全局通过SecurityUtils.getSubject().getPrincipal()获取用户信息。
之前的项目是OK的，新项目中突然出问题。现在给出我自己问题的解决方案。 shiro的配置中有个use-prefix选项，其配置有两点需要注意：
要在配置文件的最上边（或者相关属性的最前边）；一定要先于其它相关配置生效。 我原先的配置文件中的部分内容如下：
@Configuration public class ShiroConfig { @Autowired private ManagerAccessControlFilter managerAccessControlFilter; @Bean public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() { return new LifecycleBeanPostProcessor(); } @Bean public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator(){ DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator=new DefaultAdvisorAutoProxyCreator(); defaultAdvisorAutoProxyCreator.setUsePrefix(true); return defaultAdvisorAutoProxyCreator; } 我的filter是通过spring注解引用的，而且配置是在setUsePrefix前（这个时候这个倒是其次，即使放前边也是不生效的）。 如果使用spring的注解，在进入配置文件前肯定是优先被加载的。所以将其更改如下：
@Bean public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() { return new LifecycleBeanPostProcessor(); } @Bean public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator(){ DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator=new DefaultAdvisorAutoProxyCreator(); defaultAdvisorAutoProxyCreator.setUsePrefix(true); return defaultAdvisorAutoProxyCreator; } /** * ShiroFilterFactoryBean 处理拦截资源文件问题。 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，因为在 * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager * Filter Chain定义说明 1、一个URL可以配置多个Filter，使用逗号分隔 2、当设置多个过滤器时，全部验证通过，才视为通过 3、部分过滤器可指定参数，如perms，roles * */ @Bean public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager){ ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33e8d904a9f0b1c2dcaccb5a334e053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b817e7ee4c45312d1004843f8c2234/" rel="bookmark">
			keybd_event()使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		keybd_event()使用方法 函数说明 函数功能：keybd_event函数模拟一次击键事件。系统可使用这种模拟的击键事件来产生WM_KEYUP或WM_KEYDOWN消息，键盘驱动程序的中断处理程序调用keybd_event函数。在Windows NT中该函数己被使用SendInput来替代它完成操作。
函数原型；VOID keybd_event（BYTE bVk，BYTE bScan，DWORD dwFlags，DWORD dwExtralnfo）；
函数参数：
bVk：定义一个虚拟键码，键码值必须在1～254之间。
bScan：定义该键的硬件扫描码。
dwFlags：定义函数操作的各个方面的一个标志位集。应用程序可使用如下一些预定义常数的组合设置标志位：
KEYEVENTF_EXTENDEDKEY：若指定该值，则扫描码前一个值为OXEO（224）的前缀字节。KEYEVENTF_KEYUP：若指定该值，该键将被释放；若未指定该值，该键将被按下。 dwExtralnfo：定义与击键相关的附加的32位值。
返回值：该函数无返回值。
#include&amp;lt;afx.h&amp;gt;
#include&amp;lt;WinUser.h&amp;gt;
#include&amp;lt;Windows.h&amp;gt;
voidmain()
{
keybd_event(16,0,0,0); // 按下Shift键
keybd_event('A',0,0,0); // 按下a键
Sleep(100);
keybd_event('A',0,KEYEVENTF_KEYUP,0);// 松开a键
keybd_event(16,0,KEYEVENTF_KEYUP,0);// 松开Shift键
// 构成组合键----&amp;gt;按下Shift的同时按下a，形成A
}
使用说明 尽管keybd_event函数传递一个与OEM相关的硬件扫描码给系统，但应用程序不能用此扫描码。系统在内部将扫描码转换成虚拟键码，并且在传送给应用程序前清除键码的UP/DOWN位。应用程序可以摸拟PRINTSCREEN键的按下来获得一个屏幕快照，并把它存放到剪切板中。若要做到这一点，则要将keybd_event的bVk参数置为VK_SNAPSHOT，bScan参数置为0（用以获得全屏快照）或hScan置为1（仅获得活动窗口的快照）。
Windows CE：WindowsCE支持dwFlags参数附加的标志位，即使用KEYEVENTF_SILENT标志模拟击键，而不产生敲击的声音。
Windows CE不支持KEYEVENTF_EXTENDEDKEY标志。
适用版本 速查：Windows NT：3.1及以上版本；Windows：95及以上版本 ；Windows CE：1.0及以上版本；头文件：winuser.h；库文件：user32.lib。
详细说明 Windows提供了一个模拟键盘操作的API函数keybd_event()，使用该函数可以模拟相应的键盘动作。keybd_event()函数能触发一个按键事件，也就是说会产生一个WM_KEYDOWN或WM_KEYUP消息。该函数原型如下：
VOID keybd_event(
BYTE bVk, // virtual-key code
BYTE bScan, // hardware scan code
DWORD dwFlags, // flags specifying various function options
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30b817e7ee4c45312d1004843f8c2234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1dd4a7c6ad1b30db09d89006e4ca754/" rel="bookmark">
			js将图片转换为base64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js将图片转换为base64
前端向后端传输图片等文件数据，经常会将图片或者文章转换成base64字符串，再由后端解密base64字符串存储，或直接存储base64字符串。
文件多来自于本地文件，如何将图片转换成base64,
实现代码：
var img = "imgurl";//imgurl 就是你的图片路径 function getBase64Image(img) { var canvas = document.createElement("canvas"); canvas.width = img.width; canvas.height = img.height; var ctx = canvas.getContext("2d"); ctx.drawImage(img, 0, 0, img.width, img.height); var ext = img.src.substring(img.src.lastIndexOf(".")+1).toLowerCase(); var dataURL = canvas.toDataURL("image/"+ext); return dataURL; } var image = new Image(); image.src = img; image.onload = function(){ var base64 = getBase64Image(image); console.log(base64); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be950f121f48e4e514e6ecd1029503ad/" rel="bookmark">
			tensorflow serving 动态加载更新模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorflow serving是tensorflow用户服务器部署的方案，对于机器学习模型来说，是一个灵活的、高效能的服务系统，用来设计生产环境。tensorflow服务器保证相同的服务器架构和API，使得开发新的算法和实验变得容易。在这里不做过多介绍。 目前，tfs的模型加载有两种方式，第一种是通过在执行命令行时加载一个单模型的model_base_path的路径。：
bazel-bin/tensorflow_serving/model_servers/tensorflow_model_server --port=8500 --model_name=test --model_base_path=/models/test/ 或者使用一个模型配置文件，示例如下：
/usr/local/bin/tensorflow_model_server --port=9000 --model_config_file=/serving/models.conf 这个模型配置文件格式官网上是没有的，得去github上去看，为了伸手党看着方便我直接放出来：
model_config_list: { config: { name: "mymodel", base_path: "/some/filesystem/path", model_platform: "tensorflow", model_version_policy: { specific: { versions: 101, versions: 202 } } }, config: { name: "mymodel2", base_path: "/some/filesystem/path2", model_platform: "tensorflow", model_version_policy: { latest: { num_versions: N } } }, } tensorflow模型支持同一个模型的不同版本的更新，但是现在模型加载了如果要新加一个模型的话除了重启服务外，暂时没有办法，通过在github里面的issue和pr里面各种找啊找，包括在源码里面看，总算找到了他的一种通过gRPC的接口进行模型热更新的方法，不需要重启服务，直接更新就可以了。但是还是个实验阶段，所以不一定能保证万无一失，为了伸手党们看着方便，我直接放代码了，要看懂的话，还是要对protobuf和gRPC的使用有一些了解。
from tensorflow_serving.apis import model_service_pb2 from tensorflow_serving.apis import model_service_pb2_grpc from tensorflow_serving.apis import model_management_pb2 from tensorflow_serving.config import model_server_config_pb2 from tensorflow_serving.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be950f121f48e4e514e6ecd1029503ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aff9bf2f5767d7ebcc831caac8a80d88/" rel="bookmark">
			遍历文件夹的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遍历文件夹的三种方法实例 直接进入正题，第一种方法：递归法 public static void test(File file) { File[] list = file.listFiles(); for (File file2 : list) { if (file2.isDirectory()) { System.out.println(file2); test(file2); }else { System.out.print(file2); } } } public static void main(String[] args) throws FileNotFoundException { File file = new File("bin"); test(file); } 递归函数的本质在于自己调用自己，通过不断调用自己，更新参数，来达到逐级深入。
第二种方法：BFS 广度优先搜索 public static void main(String[] args) { File files = new File("bin"); ArrayList&lt;File&gt; temp = new ArrayList&lt;File&gt;(); temp.add(files); for (int i = 0; i &lt; temp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aff9bf2f5767d7ebcc831caac8a80d88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad43b7ee6ca4247a7a660b9f366e3124/" rel="bookmark">
			RTSP录制，推流，VGA录制小工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了测试的方便，最近写了一款集录制rtsp，rtmp，推流于一体的小软件，与大家分享下。由于不同品牌摄像机rtsp流地址有所区别，目前只支持海康、威海德等，后面会继续完善，提供不同品牌的流地址配置。
下载地址：https://download.csdn.net/download/unfound/10619406
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a67bc6444c2b850a34b674cc21fe6f8/" rel="bookmark">
			HCNA认证课程—VRP基础操作总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VRP基础操作
VRP：Versatile Routing Platform（通用路由平台） Console口：控制台接口
终端设备： 1：AR：路由器 2：HUB：集线器 3：cloud：云
CLI：命令行界面
用户视图：查看运行状态或者其他参数 系统视图：配置设备的系统参数 接口视图：配置接口参数 协议视图：配置路由协议
快捷键（HotKey）： CTRL_C: 停止当前正在执行的功能。 CTRL_Z: 返回到用户视图。 CTRL_] : 终止呼入的连接或重定向连接。 ? : 帮助功能，显示当前情况下可以输入的命令 Command+‘ ’+？：提示当前情况下，紧跟着可以输入的的内容（命令或者参数） Tab ：根据已有的前面几个字母，补全剩余的单词或者词组
基础命令行： 进入系统试图：system-view 进入接口：interface g0/0… 退出到上一级视图： quit 退出到用户视图：return
VRP命令操作： 1、显示时钟：display clock
2、修改时间： 2.1 、修改时区：clock timezone CST（中国标准时间） add 8（东八时区） 2.2 、修改具体时间：clock datetime 17：15：0 2018-8-21 3、标题信息： 3.1 、login：header login information #。。。。。。#（登陆之前显示的信息） 3.2 、shell：header shell information #。。。。。。# （登陆之后显示的信息） 4、 等级： 4.1 、用户等级：0–15（等级大于3的可以执行所有命令） 4.2 、命令等级：0–3 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a67bc6444c2b850a34b674cc21fe6f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0f07c5218f235fa1bacc9a6bc02bcf/" rel="bookmark">
			设计模式的六大原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、"开放－封闭"原则(OCP) Open-Closed Principle原则讲的是：一个软件实体应当对扩展开放，对修改关闭
二、 里氏代换原则（LSP） Liskov Substitution Principle（里氏代换原则）：子类型(subtype)必须能够替换它们的基类型。
三、 依赖倒置原则(DIP) 依赖倒置（Dependence Inversion Principle）原则讲的是：要依赖于抽象，不要依赖于具体。
抽象不应当依赖于细节；细节应当依赖于抽象；要针对接口编程，不针对实现编程。
四、 接口隔离原则（ISP） 接口隔离原则（Interface Segregation Principle）讲的是：使用多个专门的接口比使用单一的总接口总要好。换而言之，从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。
实现方法：
1、 使用委托分离接口
2、 使用多重继承分离接口
五、 合成/聚合复用原则（CARP） 合成/聚合复用原则（Composite/Aggregate Reuse Principle或CARP）经常又叫做合成复用原则（Composite Reuse Principle或CRP），就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新对象通过向这些对象的委派达到复用已有功能的目的。
简而言之，要尽量使用合成/聚合，尽量不要使用继承。
区分"Has-A"与"Is-A"
"Is-A"是严格的分类学意义上定义，意思是一个类是另一个类的"一种"。而"Has-A"则不同，它表示某一个角色具有某一项责任。
六、 迪米特法则（LoD） 迪米特法则（Law of Demeter或简写LoD）又叫最少知识原则（Least Knowledge Principle或简写为LKP），也就是说，一个对象应当对其它对象有尽可能少的了解。
迪米特法则与设计模式
Facade模式、Mediator模式
创建型模式种类 • Singleton单例模式，保证一个类仅有一个实例
• Factory Method工厂方法模式，定义一个创建对象的接口，并控制用哪一个类进行实例化
• Abstract Factory–抽象工厂模式，创建一系列相关或相互依赖的对象
• Prototype–原型模式，通过拷贝现有对象来生成新对象（克隆方法）
• Builder–生成器模式，将构造对象实例的代码逻辑移到类的外部
结构型模式 • 结构型模式涉及到如何组合类或对象，以获得更大的结构
• 结构型类模式采用继承机制来组合接口或实现
• 结构型对象模式描述了如何对一些对象进行组合，从而实现新功能的一些方法
Adapter适配器模式，将一个类的接口转换成客户希望的另外一个接口，使得原本由于
接口不兼容而不能一起工作的那些类可以一起工作适配器（Adapter）模式
•桥梁（Bridge）模式，将抽象部分与它的实现部分分离，使它们都可以独立地变化
• Composite组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性合成（Composite）模式
• Decorator 装饰模式，动态地给一个对象添加一些额外的职责装饰（Decorator）模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0f07c5218f235fa1bacc9a6bc02bcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb661e5250a6807a5e1530de69e9cc6/" rel="bookmark">
			1031. 等腰三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述： 输入一个正整数n，输出高为n的由*组成的等腰三角形。
输入： 输入一个正整数。 输出： 输出高为n的由*组成的等腰三角形。
样例输入： 3 样例输出： 代码如下：
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=n-i;j++) cout&lt;&lt;" "; //两个for循环用来计数，十分重要 for(j=1;j&lt;=2*i-1;j++) cout&lt;&lt;"*"; cout&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845df404dc2f5eab1028f2ef7a8dcf4a/" rel="bookmark">
			Boost lockfree deque 生产者与消费者多对多线程应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		boost库中有一个boost::lockfree::queue类型的 队列，对于一般的需要队列的程序，其效率都算不错的了，下面使用一个用例来说明。
程序是一个典型的生产者与消费者的关系，都可以使用多线程，其效率要比使用上层的互斥锁要快很多，因为它直接使用底层的原子操作来进行同步数据的。
freedeque.h
1 #pragma once#ifndef INCLUDED_UTILS_LFRINGQUEUE 2 #define INCLUDED_UTILS_LFRINGQUEUE 3 4 #define _ENABLE_ATOMIC_ALIGNMENT_FIX 5 #define ATOMIC_FLAG_INIT 0 6 7 8 #pragma once 9 10 11 #include &lt;vector&gt; 12 #include &lt;mutex&gt; 13 #include &lt;thread&gt; 14 #include &lt;atomic&gt; 15 #include &lt;chrono&gt; 16 #include &lt;cstring&gt; 17 #include &lt;iostream&gt; 18 19 // Lock free ring queue 20 21 template &lt; typename _TyData, long _uiCount = 100000 &gt; 22 class lfringqueue 23 { 24 public: 25 lfringqueue(long uiCount = _uiCount) : m_lTailIterator(0), m_lHeadIterator(0), m_uiCount(uiCount) 26 { 27 m_queue = new _TyData*[m_uiCount]; 28 memset(m_queue, 0, sizeof(_TyData*) * m_uiCount); 29 } 30 31 ~lfringqueue() 32 { 33 if (m_queue) 34 delete[] m_queue; 35 } 36 37 bool enqueue(_TyData *pdata, unsigned int uiRetries = 1000) 38 { 39 if (NULL == pdata) 40 { 41 // Null enqueues are not allowed 42 return false; 43 } 44 45 unsigned int uiCurrRetries = 0; 46 while (uiCurrRetries &lt; uiRetries) 47 { 48 // Release fence in order to prevent memory reordering 49 // of any read or write with following write 50 std::atomic_thread_fence(std::memory_order_release); 51 52 long lHeadIterator = m_lHeadIterator; 53 54 if (NULL == m_queue[lHeadIterator]) 55 { 56 long lHeadIteratorOrig = lHeadIterator; 57 58 ++lHeadIterator; 59 if (lHeadIterator &gt;= m_uiCount) 60 lHeadIterator = 0; 61 62 // Don't worry if this CAS fails.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845df404dc2f5eab1028f2ef7a8dcf4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ea1eeb1a6ac0776492095be0b75a2e/" rel="bookmark">
			软件测试-白盒测试（六种覆盖准则）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		白盒测试过程中：
六种覆盖方法中：覆盖强度由弱到强的顺序依次是：
语句覆盖判定逻辑覆盖条件逻辑覆盖‘判断逻辑条件覆盖条件组合覆盖路径覆盖 举例：
if(a&amp;&amp;b) { c=a+b; } else { c=a-b; } 1.语句覆盖：
语句覆盖就是每个语句至少被执行一次。
2.判定条件覆盖 每个判断的分支取真分支和取假分支至少经历一次
只需要a为真b为真或是a/b中有一个为真，一个为假即可这两种情况。
3.条件逻辑覆盖
使得判定的每个条件都需要至少满足一次。
比如上面：a如false和true。b取false和true两种情况。
4.判断逻辑条件覆盖
使得每个判断取到可能的结果，并且判断中的每个条件也要取到可能的结果。判断和条件都必须满足
即if/else两个判断都要执行到，if中的条件a取false和true，b取false和b取true
5.条件组合判断
即每个判定中条件的各种取值组合至少出现一次
比如上面的if为真的条件中; a为真，b为真 一组 a为真，b为假 二组 a为假，b为真 三组 a为假，b为假 四组kaolv
6.路径覆盖
执行所有可能执行的路径
总结： 路径覆盖肯定包含判定覆盖，与条件没有直接关系。 判定套件覆盖一定包含判定覆盖和条件覆盖
条件判定并不等同于判定覆盖。一个关注条件的真假，一个关注判定的分支。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e18d37fbc09ec2c494a598a2238b7e8/" rel="bookmark">
			laravel模型的建立查询数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Route::get('test3','PhotoController@test3'); //代码在PhotoController public function test3(){ $res = PhotoModel::all(); dd($res);//集合 } $res = PhotoModel::find(2); dd($res);//模型对象 $res = PhotoModel::findOrFail('2');//2 99 没有会报错 dd($res);//模型对象 $res = PhotoModel::get(); dd($res);//查询所有 $res = PhotoModel::where('Id','&gt;','20')-&gt;orderBy('age','desc')-&gt;first(); dd($res); PhotoModel::chunk(2,function($res){ echo '&lt;pre&gt;'; var_dump($res); echo '&lt;/pre&gt;'; });//一次查询两条数据 object(Illuminate\Database\Eloquent\Collection)#476 (1) { ["items":protected]=&gt; array(2) { [0]=&gt; object(App\PhotoModel)#473 (26) { ["table":protected]=&gt; string(5) "photo" ["primaryKey":protected]=&gt; string(2) "Id" ["connection":protected]=&gt; string(5) "mysql" ["keyType":protected]=&gt; string(3) "int" ["incrementing"]=&gt; bool(true) ["with":protected]=&gt; array(0) { } ["withCount":protected]=&gt; array(0) { } ["perPage":protected]=&gt; int(15) ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e18d37fbc09ec2c494a598a2238b7e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d475fd34cdbc8ce0c4978653d33a33f1/" rel="bookmark">
			eclipse无法添加tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然现在都用idea了，但有个老项目还是用的eclipse。今天在添加toccat的时候遇到了这个问题
Cannot create a server using the selected type
如下图表示
就是红色打叉的地方不显示，上面蓝色地方显示 Cannot create a server using the selected type
怎么解决这个问题呢？
到该项目的wordspace目录下 /.metadata/.plugins/org.eclipse.core.runtime/.settings/中
删除 org.eclipse.wst.server.core.prefs 和 org.eclipse.jst.server.tomcat.core.prefs 文件
重启eclipse即可。
最后 由于春运快到了，给大家安利一个抢火车票的小程序心到抢票，微信扫码关注点击立即抢票即可
个人亲测效率很高，大家也可以加他们官方微信 xdticket 咨询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f19d2f0ed6e642129230a615a55114/" rel="bookmark">
			关于多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程
一 并发 与 并行 并行：指两个或多个事件在 同一时刻 发生（同时发生）
并发：值两个或多个时间在 同一个时间段内 发生， 即同一段时间内宏观上有多程序同时运行，微观上是分时的交替运行，多线程是实现并发机制的一种有效手段。
注：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同
理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个
线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为
线程调度。
二 进程 与 线程
1.进程 指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；
进程也是程序的依次执行过程，是系统运行程序的基本单位；
系统运行一个程序即是一个进程从创建、运行到消亡的过程。
2.线程 进程内部的一个独立执行单元，一个进程可以同时并发的运行多个线程
3.进程 与 线程 的区别
1）进程 有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。
2）线程 堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。
注意：
1）因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于
CPU 的调度，程序员是干涉不了的。而这也就造成的多线程的随机性。
2）Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，用于启动子线程，另外一个是垃圾回收机制线程，负责垃圾回收。每
当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个
进程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程---main线程 和 gc线程。
3） 由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建
多线程，而不是创建多进程。
4.线程调度
计算机通常只有一个CPU时,在任意时刻只能执行一条计算机指令,每一个线程只有获得CPU的使用权才能执行指
令。所谓多线程并发运行,从宏观上看,其实是各个线程轮流获得CPU的使用权,分别执行各自的任务。那么,在可运行
池中,会有多个线程处于就绪状态等到CPU,JVM就负责了线程的调度。JVM采用的是 抢占式调度 ,没有采用分时调度,
因此可以能造成多线程执行结果的的随机性。
5.线程类
java.lang.Thread类代表线程，所有的线程UI想都必须是Tread类或者其子类的实例
1）创建并启动多线程步骤
（1） 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把
run()方法称为线程执行体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03f19d2f0ed6e642129230a615a55114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98ce5d5a7501b049ca6cbb0b94e5f51/" rel="bookmark">
			Kaggle Titanic 生存问题 - Java 机器学习实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kaggle Titanic 生存问题 - Java 机器学习实战 Kaggle Titanic 生存问题 - Java 机器学习实战 1. Kaggle Titanic 介绍 1.1 Kaggle 竞赛1.2 Titanic 问题 2. 数据探索 2.1 数据初探2.2 特征分析 2.2.1 Pclass2.2.2 Sex2.2.3 Age2.2.4 SibSp2.2.5 Parch2.2.6 Embark2.2.7 Fare2.2.8 Cabin2.2.9 Name &amp; Ticket 3. 数据预处理 3.1 缺失值处理3.2 格式转换3.3 数据归一化 4. 逻辑回归、参数调优 4.1 基本的逻辑回归4.2 使用 CV 进行模型选择 5. 输出结果6. 参考资料 1. Kaggle Titanic 介绍 1.1 Kaggle 竞赛 Kaggle 是目前全球最有影响力的机器学习竞赛平台。
企业或者研究者可以将数据、问题描述、期望的指标发布到Kaggle上，以竞赛的形式向广大的数据科学家征集解决方案，类似于KDD-CUP（国际知识发现和数据挖掘竞赛）。Kaggle上的参赛者将数据下载下来，分析数据，然后运用机器学习、深度学习、数据挖掘等知识，建立算法模型，解决问题得出结果，最后将结果提交，如果提交的结果符合指标要求（比如logloss，mse等）并且在参赛者中排名第一，将获得比赛丰厚的奖金。
Titanic 竞赛是 Kaggle 提供的一个机器学习入门级比赛。主要是给新手练手用的（当然也没有奖金）。目前已经有将近1万只队伍参加过这个比赛了。
下面我们来具体看看 Titanic 问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98ce5d5a7501b049ca6cbb0b94e5f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62f8a9e9bde36f9dd7eb2264f5d6c6d/" rel="bookmark">
			mysql 中存储表情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql存储emoji表情时需要的设置：
1.数据库的type为varchar，重点是需要将character set 设置为utf8mb4，collation设置为utf8mb4_general_ci。
2.将配置mysql链接时需要增加配置，我用的是springboot，mysql链接参数直接写在配置文件中，如下高亮部分
这样上传的表情之类的就直接可以保存在db中了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c7a67e4ca7003dfc0e4e5411c73e77/" rel="bookmark">
			编程练习2:找两个数中最大者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：本题要求对两个整数a和b，输出其中较大的数。函数接口定义：max (int a,int b);
解析：需要使用判定语句if(a&gt;b)，如果a是大者就将a赋值给Max
代码：
#include&lt;stdio.h&gt; int max(int a,int b) { int max; if(a&gt;b) max=a; else max=b; return max; } int main() { int a,b; scanf("%d %d",&amp;a,&amp;b); max(a,b); printf("max=%d",max(a,b)); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72cae0e5608a920f759dc0876ecde88/" rel="bookmark">
			编程练习1:求 m 到n的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 来源：pat
题目：本题要求实现一个计算m~n（m&lt;n）之间所有整数的和的简单函数。函数接口定义：
int sum (int m,int n); 解析：编写sum函数，从m 加到n是一个循环的过程，所以需要用for循环，需要先初始化sum，然后令for(i=m; i&lt;=n; i++)
最后sum+=i
代码：
#include&lt;stdio.h&gt; int sum(int m,int n) { int sum=0; for(int i=m; i&lt;=n; i++){ sum+=i; } return sum; } int main() { int m,n; scanf("%d %d",&amp;m,&amp;n); sum(m,n); printf("sum=%d",sum(m,n)); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280a2e33db8e11837e42036089f11f1a/" rel="bookmark">
			反爬虫中chrome无头浏览器的几种检测与绕过方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chrome无头浏览器的几种检测方式 本文测试使用的chrome版本为 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3514.2 Safari/537.36
1.UserAgent检测 无头模式下的UA会带有HeadlessChrome关键字
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/70.0.3521.2 Safari/537.36 因此可以检查UA中的关键字
if (/HeadlessChrome/.test(navigator.userAgent)) { // headless... } 2.Webdriver检测 无头模式下navigator.webdriver为true，因此可以进行如下检测。
// Webdriver Test if (navigator.webdriver) { // headless... } 为了绕过这个检测，重新设置该属性即可。
Object.defineProperty(navigator, 'webdriver', { get: () =&gt; false, }); 建议通过原型删除该属性
delete navigator.__proto__.webdriver; 补充说明：大麦网或淘宝网的滑块验证码首先就会检测环境，
通常会利用sufei_data文件检测当前浏览器信息，其中检测webdriver代码如下
function r() { return "$cdc_asdjflasutopfhvcZLmcfl_"in u || f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280a2e33db8e11837e42036089f11f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80c3474f670998beca27826596e99c78/" rel="bookmark">
			学习笔记---------jsp的三种页面跳转from表单,a链接,js点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jsp的三种页面跳转方式 1.from表单提交 from表单的页面跳转有post和get两种跳转方式,其中get是不加密的,通过地址栏传递数据,post是加密的 在index.jsp页面写上from表单
&lt;!-- 表单提交页面跳转 --&gt; &lt;!-- 跳转方式有两种:post和get --&gt; &lt;!-- action后面接要跳转的地址 method接跳转的方式 --&gt; &lt;form action="indexServlet.jsp" method="post"&gt; &lt;input type="text" name="a"&gt; &lt;input type="text" name="b"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; 在要跳转的indexServlet.jsp页面获取数据并打印 &lt;% &lt;!--在post跳转方式下,在要跳转的页面可能会出现乱码的问题,这里需要加上编码的声明,若不会出现乱码则不用加 --&gt; &lt;!--request.setCharacterEncoding("UTF-8");--&gt; String a = request.getParameter("a"); String b = request.getParameter("b"); out.print("第一个数据为:" + a + "&lt;br/&gt;第二个数据为:" + b); %&gt; a链接 是采用地址栏传参的方式,属于get方式
&lt;!-- a链接页面跳转 --&gt; &lt;!-- 传递的参数可以用字符串拼接的方式 --&gt; &lt;a href="indexServlet.jsp?a=5&amp;b=20"&gt;链接&lt;/a&gt; js页面跳转是采用鼠标事件的方式,通过dom操作获取参数,同样是通过地址栏传递参数,属于get方式
&lt;!-- js页面跳转 --&gt; 请输入第一个数据:&lt;input type="text" id="a"/&gt;&lt;br/&gt; 请输入第二个数据:&lt;input type="text" id="b"/&gt;&lt;br/&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80c3474f670998beca27826596e99c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3577349a4e522950090a517aa0a8eb7/" rel="bookmark">
			JavaScript导出图片和数据到Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下方法可以利用json数据将图片地址生成图片导出到Excel，同样也可以将数据导出到Excel。解决网上许多方法关于导出图片到Excel却无法让图片在单元格内显示的问题，也解决了各类浏览器兼容问题。话不多少，先上车吧（哈哈）
1、安装依赖
npm install js-table2excel
2、在页面中引入,并注入数据。栗子
const column = [ { title: 'Name', key: 'name', type: 'text' }, { title: 'Pic', key: 'pic', type: 'image', width: 80, height: 50 } ] /** column数据的说明 */ // 1.title为列名 // 2.key为data数据每个对象对应的key // 3.若为图片格式, 需要加type为image的说明,并且可以设置图片的宽高 const data = [ { name: 'xiao', age: '18', pic: 'https://profile.csdnimg.cn/9/8/3/2_xiaoxiaojie12321' }, { name: 'jie', age: '18', pic: 'https://profile.csdnimg.cn/9/8/3/2_xiaoxiaojie12321' } ] const excelName = 'boy' table2excel(column, data, excelName) 3、生成的Excel表格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3577349a4e522950090a517aa0a8eb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab973b60d83847924636097ca99b6a4/" rel="bookmark">
			sql常用函数详解（一）——字符串截取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.substring函数——截取字符串 SUBSTRING ( expression, start, length )
expression——字符串、二进制字符串、文本、图像、列或包含列的表达式。请勿使用包含聚合函数的表达式。
start——整数或可以隐式转换为int 的表达式，指定子字符串的开始位置。
length——整数或可以隐式转换为 int 的表达式，指定子字符串的长度
left(field,length) ——函数返回field最左边的length个长度的字符串
right(field,length)——函数返回field最右边的length个长度的字符串
eg1:取定长定位置的字符串
select substring('abdcsef',1,3) result: abd
2.CHARINDEX函数——返回字符或者字符串在另一个字符串中的起始位置 CHARINDEX ( expression1 , expression2 [ , start_location ] ) —— CHARINDEX函数返回一个整数，返回的整数是要找的字符串在被找的字符串中的位置。Expression1是要到expression2中寻找的字符中，start_location是CHARINDEX函数开始在expression2中找expression1的位置。 CHARINDEX('SQL', 'Microsoft SQL Server') 这个函数命令将返回在“Microsoft SQL Server”中“SQL”的起始位置，在这个例子中，CHARINDEX函数将返回“S”在“Microsoft SQL Server”中的位置11。
eg1:取不定长不同位置的字符串
我们只想要得到'roomno'中的房间号，发现起始字符位置并不是固定的，而且，我们需要的房间号长度也不固定。
此时，我们可以运用‘charindex’这个函数就可以轻松搞定，它是用来定位某个特定字符在该字符串中的位置，即该函数
得到的结果是一个用来表示某个特定字符位置的数字。执行如下代码：
select room_stand=substring(roomno,charindex('元',roomno)+1,charindex('室',roomno)-charindex('元',roomno)-1) from PROPERTY_room where roomno like '%单元%室%' result:
3.STUFF函数——删除指定长度的字符，并在指定的起点处插入另一组字符。 STUFF ( character_expression , start , length ,character_expression )
SELECT STUFF('abcde', 2, 3, '123') result： a123e
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab973b60d83847924636097ca99b6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f1c9f6b423b71b69c9e93ff0d5b4c0/" rel="bookmark">
			windows 下 python调用Qt C&#43;&#43;( PyQt5 &#43; sip4.19)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先编译sip
windows下使用nmake编译，进入vs工具 x86 Native Tools Command Prompt for VS 2015
进入sip目录，依次输入
python configure.py --platform win32-msvc2015 nmake nmake install 成功后python目录下会生成sip.exe,sip.pyd等
2.接下来编译PyQt，PyQt对sip版本有要求，PyQt5一般需要sip版本在4.19.3以上，PyQt目录下configure.py中有描述。
进入PyQt目录，还是使用nmake
python configure.py --disable=QtNfc namke nmake install 必须禁用Qt的Nfc模块，编译过程略长，大概半个小时
3.为要被python调用的c++代码编写sip文件，参见http://pyqt.sourceforge.net/Docs/sip4/directives.html
4.编写configure.py文件，参见http://pyqt.sourceforge.net/Docs/sip4/using.html#a-more-complex-c-example
5.进入configure.py目录
python configure.py 6.编译sip生成的cpp文件，生成后缀为pyd的dll文件可供pyhton调用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202a3bb13619c35b268d0d5cf0a360ef/" rel="bookmark">
			学习金字塔理论有感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们从出生到现在一直在学习，而且每个人都是在同一基础，同一个课堂上教出来的学生，但是还是有很大的差距，是什么导致有的人学的时间长反而学习平庸，有的人学习时间短却成绩非常好。里面的学习方法肯定是不一样的。
这段时间看到了一个文章，讲述的是“学习金字塔”，如图：
上图是当时美国教育学家埃德加 · 戴尔（Engar Dale）研究出的“学习金字塔”（The Cone of Learning）。“学习金字塔”表明，阅读和听讲是最不效率的学习方式，主动方式（教授、实践、讨论）才是最有效的学习方式。而且这两种学习方式之间知识的留存率差距极大。
这和目前我们所接触的主流学习方式是很不同的，并非只有读书，听讲才是“学习”，其实这恰恰是信息留存率最低的（它的优点是信息获取的速度和数量）。我们的教育体系也主要通过阅读和听讲进行教学，而缺少讨论实践。
现在看来，我们现在的教育，提高最快的是老师。但是教育的目的，不应该是让学生们能够去主动的去学习吗？这也就是老师长提的“授之于渔”。我们应该在老师的帮助下去主动的学习，掌握学习的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de53805b2b9def1930c8e887b94393d/" rel="bookmark">
			SpringBoot &#43; Nginx配置SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 由于小程序访问服务器地址需要强制使用https，因此需要加服务器加SSL证书。springboot本身也可以通过tomat配置证书或者将证书集成到jar包里面，但是放在jar程序的证书格式局限在.p12格式，而生成的证书一般是crt或pem，因此转换起来很不方便。这时可以使用nginx代理https请求，从而达到用nginx配置SSL证书的目的。
安装及配置nginx 安装和配置nginx这里就不提了，可以参考之前的文章 Ubuntu安装nginx
申请SSL证书 粗略去阿里云上面看了一下，SSL证书一年要好几千，如果不是特别高要求的话，可以使用免费的SSL证书。听说阿里云也有免费的SSL证书，但是我阿里云网站证书相关的选项下没发现有免费的证书，估计是取消了。 可以尝试去腾讯云上面找，但是网站内容多，不稍加注意，也是不太好找的。这里贴出免费证书申请的链接：腾讯云免费SSL证书链接 点击立即选购下方的免费申请域名证书后，会弹出证书品牌商的选择框，这里我们选择默认的就好了。 点击确定之后会弹出要绑定证书的域名等资料填写，如实填写就可以了。 点击下一步后会生成一些需要域名网站验证的信息，这时将这些信息添加到自己域名的DNS解析就可以了。这里以阿里云申请的域名为例： 登陆阿里云网站，选择产品与服务-》域名： 选择“管理”，然后在弹出的网页中再选择“域名解析”项： 这里我们再选择“添加记录”，然后在弹出的框中将之前申请SSL证书生成的一串数据对应填写进去就可以了。 记录值就填生成的那个记录值就好了，然后确定保存。填写后回到腾讯云刚才生成证书那里测试验证，等几分钟后就会有通知你下载证书了。
上传SSL证书和配置nginx 将申请到的证书下载下来并解压，可以看到有专门nginx文件夹命名的证书。 将文件夹里面.crt和.key结尾的两个证书上传到服务器某个位置，这里以usr/local/nginx文件夹为例（即之前安装nginx的文件夹），在该文件夹下创建专门存放证书的文件夹cert。 生成文件夹指令：
mkdir cert 创建成功后可以看到nginx目录下多了个cert的文件夹，使用上传工具将这两个证书上传到这个文件夹下就可以了。 上传成功后，再进入旁边conf文件夹，然后编辑文件夹下nginx.conf文件（该文件主要用来配置nginx） 使用vim nginx.conf 编辑文件。 由于我们要配置的是https，nginx默认配置的是http，因此这里先把http部分的配置注释起来。
然后把https的注释解开，配置自己证书及域名。 到这里就可以配置完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5517379f41a1412f8c41b7131704668f/" rel="bookmark">
			C#学习之实现只读窗口及下拉框的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比Android简单太多了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31001c63537d351f507bc865e4f97f63/" rel="bookmark">
			js操作localstorage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 localstorage是web前端常用的本地存储服务，它相对于cookie，有几个优势：
①数据存储量大
②不会携带给后台，避免传输没用的数据
③操作简便
1、首先，封装一个全局方法，以便各个地方调用
export function handleLocalStorage(method, key, value) { switch (method) { case 'get' : { let temp = window.localStorage.getItem(key); if (temp) { return temp } else { return false } } case 'set' : { window.localStorage.setItem(key, value); break } case 'remove': { window.localStorage.removeItem(key); break } default : { return false } } } 2、调用方法
①存储
handleLocalStorage('set', 'userName', 'Tom'); ②获取
handleLocalStorage('get', 'userName'); ③删除
handleLocalStorage('remove', 'userName'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4560b05e0d7bf4ac1595c2c499cd8cff/" rel="bookmark">
			[Python图像处理] 一.图像处理基础知识及OpenCV入门函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该系列文章是讲解Python OpenCV图像处理知识，前期主要讲解图像入门、OpenCV基础用法，中期讲解图像处理的各种算法，包括图像锐化算子、图像增强技术、图像分割等，后期结合深度学习研究图像识别、图像分类应用。希望文章对您有所帮助，如果有不足之处，还请海涵~
本篇文章作为第一篇，将讲解图像处理基础知识和OpenCV入门函数，知识点如下：
1.图像基础知识2.OpenCV读写图像3.OpenCV像素处理 PS: 文章也学习了网易云高登教育的知识，推荐大家学习。
该系列在github所有源代码：
https://github.com/eastmountyxz/ImageProcessing-Python PS：请求帮忙点个Star，哈哈，第一次使用Github，以后会分享更多代码，一起加油。
同时推荐作者的C++图像系列知识：
[数字图像处理] 一.MFC详解显示BMP格式图片[数字图像处理] 二.MFC单文档分割窗口显示图片[数字图像处理] 三.MFC实现图像灰度、采样和量化功能详解[数字图像处理] 四.MFC对话框绘制灰度直方图[数字图像处理] 五.MFC图像点运算之灰度线性变化、灰度非线性变化、阈值化和均衡化处理详解[数字图像处理] 六.MFC空间几何变换之图像平移、镜像、旋转、缩放详解[数字图像处理] 七.MFC图像增强之图像普通平滑、高斯平滑、Laplacian、Sobel、Prewitt锐化详解 PSS：2019年1~2月作者参加了CSDN2018年博客评选，希望您能投出宝贵的一票。我是59号，Eastmount，杨秀璋。投票地址：https://bss.csdn.net/m/topic/blog_star2018/index
五年来写了314篇博客，12个专栏，是真的热爱分享，热爱CSDN这个平台，也想帮助更多的人，专栏包括Python、数据挖掘、网络爬虫、图像处理、C#、Android等。现在也当了两年老师，更是觉得有义务教好每一个学生，让贵州学子好好写点代码，学点技术，“师者，传到授业解惑也”，提前祝大家新年快乐。2019我们携手共进，为爱而生。
一.图像基础知识 图像都是由像素(pixel)构成的，即图像中的小方格，这些小方格都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置就决定该图像所呈现出来的样子。像素是图像中的最小单位，每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。
图像通常包括二值图像、灰度图像和彩色图像。
1.二值图像
二值图像中任何一个点非黑即白，要么为白色（像素为255），要么为黑色（像素为0）。将灰度图像转换为二值图像的过程，常通过依次遍历判断实现，如果像素&gt;=127则设置为255，否则设置为0。
2.灰度图像
灰度图像除了黑和白，还有灰色，它把灰度划分为256个不同的颜色，图像看着也更为清晰。将彩色图像转换为灰度图是图像处理的最基本预处理操作，通常包括下面几种方法：
(1) 浮点算法：Gray=R0.3+G0.59+B0.11
(2) 整数方法：Gray=(R30+G59+B11)/100
(3) 移位方法：Gray=(R28+G151+B77)&gt;&gt;8;
(4) 平均值法：Gray=（R+G+B）/3;(此程序采用算法)
(5) 仅取绿色：Gray=G；
(6) 加权平均值算法：根据光的亮度特性，公式: R=G=B=R0.299+G*0.587+B0.144
通过上述任一种方法求得Gray后，将原来的RGB(R,G,B)中的R,G,B统一用Gray替换，形成新的颜色RGB(Gray,Gray,Gray)，用它替换原来的RGB(R,G,B)就是灰度图了。改变象素矩阵的RGB值，来达到彩色图转变为灰度图。
3.彩色图像
彩色图像是RGB图像，RGB表示红、绿、蓝三原色，计算机里所有颜色都是三原色不同比例组成的，即三色通道。
二.OpenCV读写图像 本文主要使用Python2.7和OpenCV进行讲解，首先调用"pip install opencv-python"安装OpenCV库，如下图所示：
1.读入图像
OpenCV读图像主要调用下面函数实现：
img = cv2.imread(文件名,[,参数])
参数(1) cv2.IMREAD_UNCHANGED (图像不可变)
参数(2) cv2.IMREAD_GRAYSCALE (灰度图像)
参数(3) cv2.IMREAD_COLOR (读入彩色图像)
参数(4) cv2.COLOR_BGR2RGB (图像通道BGR转成RGB)
2.显示图像
显示图像调用函数如下：
cv2.imshow(窗口名, 图像名)
3.窗口等待
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4560b05e0d7bf4ac1595c2c499cd8cff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d62b6f7a36ac0a4ff78f8b81fb4f4cee/" rel="bookmark">
			java线程的5种状态及其转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的线程的生命周期大体可分为5种状态。
1. 新建(NEW)：新创建了一个线程对象。
2. 可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。
3. 运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。
4. 阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：
(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
5. 死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。
线程状态图 二.初始状态
实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态
三.可运行状态
可运行状态只是说你资格运行，调度程序没有挑选到你，你就永远是可运行状态。
调用线程的start()方法，此线程进入可运行状态。
当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入可运行状态。
当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入可运行状态。
锁池里的线程拿到对象锁后，进入可运行状态。
四.运行状态
线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。
五.死亡状态
当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。
在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
六.阻塞状态
当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态。
运行在当前线程里的其它线程t2调用join()方法，当前线程进入阻塞状态。
等待用户输入的时候，当前线程进入阻塞状态。
八.锁池状态
当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入锁池状态。简言之，锁池里面放的都是想争夺对象锁的线程。
当一个线程1被另外一个线程2唤醒时，1线程进入锁池状态，去争夺对象锁。
锁池是在同步的环境下才有的概念，一个对象对应一个锁池。
九.几个方法的比较
Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可运行状态。作用：给其它线程执行机会的最佳方式。
Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。
t.join()/t.join(long millis)，当前线程里调用其它线程1的join方法，当前线程阻塞，但不释放对象锁，直到线程1执行完毕或者millis时间到，当前线程进入可运行状态。
obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。
obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e5291f7ea886808a6e80b9d6104c2f/" rel="bookmark">
			Matlab 基础知识——矩阵操作及运算（矩阵、数组区别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看论文时，经常看到矩阵，但在记忆里又看到数组。那么问题来了，矩阵和数组分别是什么？二者有什么区别？看论文时，经常看到矩阵，但在记忆里又看到数组。那么问题来了，矩阵和数组分别是什么？二者有什么区别？
在数学上，定义m×n个数(i=1, 2…, m ; j=1, 2,… n)排成的m行n列的数表示为m行n列的矩阵，并且用大写加粗黑色字母表示。
只有一行的矩阵：，也称之为行向量；
只有一列的矩阵，也称之为列向量。
矩阵最早来自于方程组的系数即常数所构成的方阵，这一个概念有19世纪英国数学家凯利首先提出。
数组是在程序设计中，为了处理方便，把具有相同类型的若干变量按有序的形式组织起来的一种形式。这些按序排列的同类数据元素的集合称之为数组。
在Matlab中，一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。因此按数组元素的类型不同，数组又可以分为数值数组、字符数组、单元数组、结构数组等各种类别。
看完上面的内容，矩阵和数组的区别似乎懂了一点。矩阵和数组在Matlab中存在很多方面的区别：
（1）矩阵是数学的概念，而数组是计算机程序设计领域的概念；
（2）作为一种变换或映射算符的体现，矩阵运算有着明确而严格的数学规则。而数组运算是Matlab软件定义的规则，其目的是为了使数据管理方便，操作简单，命令形式自然，执行计算有效。
二者联系主要体现在：在Matlab中，矩阵是以数组的形式存在的。因此，一维数组相当于向量；二维数组相当于矩阵。所以矩阵是数组的子集。
对矩阵的基本操作，主要有矩阵的构建、矩阵维度和矩阵大小的改变、矩阵的索引、矩阵的属性信息的获取、矩阵结构的改变等。对于这些操作，Matlab中都有固定的指令或者相应的库函数与之相对应。在程序用到的时候，每次都要上网查，网上的很散。这里，我对我经常用的做了总结。以后用到可以查阅。
1、矩阵下表引用 表达式(Matlab程序)
函数功能
1
A(1)
将二维矩阵A重组为一维数组，返回数组中第一个元素
2
A(: , j)
返回二维矩阵A中第 j 列 列向量
3
A( i , :)
返回二维矩阵A中第 i 行 行向量
4
A(: , j : k)
返回二维矩阵A中第 j 列到第 k列 列向量组成的子矩阵
5
A( i : k , :)
返回二维矩阵A中第 i 行到第 k行 行向量组成的子矩阵
6
A( i : k , j : m)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e5291f7ea886808a6e80b9d6104c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56144f2e4a6a940d9aa40489941323c2/" rel="bookmark">
			已解决：Pycharm中Django找不到已经安装的模块(ModuleNotFoundError: No module named &#39;XXXXX&#39;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已解决：Django找不到已经安装的模块(ModuleNotFoundError: No module named 'XXXXX')
修改为project default
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0628012f50bc235b77e17d9de8302ce1/" rel="bookmark">
			Ubuntu 安装php5.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 apt install python-software-properties -y 二、安装ppa源 apt install software-properties-common python-software-properties 三、 LC_ALL=C.UTF-8 add-apt-repository ppa:ondrej/php 四、更新源 apt update 五、升级源 apt upgrade -y 六、安装php apt install php5.6 php5.6-fpm php5.6-mysql php5.6-gd php5.6-mbstring php5.6-curl php5.6-soap php5.6-redis php5.6-xml php5.6-apcu php5.6-mcrypt -y 七、配置Nginx支持PHP扩展 vim /etc/nginx/fastcgi_params # 在文档最后添加一下代码： fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; 八、创建站点文件及php测试文件 1、mkdir -p /www/test 2、vim /www/test/info.php 输入内容 &lt;?php phpinfo(); 九、站点配置文件修改 vim /etc/nginx/conf.d/default.conf # 清空文档，把以下内容复制到文档中： server { listen 80; # server_name localhost; root /www/test; index index.php index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0628012f50bc235b77e17d9de8302ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3460b32d3352e129eff70681b6e002/" rel="bookmark">
			ArcGIS Pro 使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 ArcGIS目前有两个主要桌面应用程序是 ArcMap 和 ArcGIS Pro，且二者均为 ArcGIS Desktop 的一部分。ArcGIS Pro是ESRI公司最新的一款桌面GIS产品，在 2D 和 3D 模式下创建并编辑、轻松自动执行任务和工作流、实现信息共享和组织内协作并最大程度地利用现代硬件。
ArcGIS Pro是为新一代Web GIS平台，面向GIS专业人士（例如GIS工程师、GIS科研人员、地理设计人员、地理数据分析师等），全新打造的一款具有高效、强大生产力的桌面应用程序。ArcGIS Pro除了良好的继承了传统桌面软件（ArcMap）的强大的数据管理、制图、空间分析等能力，还具有其独有的特色功能，例如二三维一体化、矢量切片制作及发布、任务工作流等。 并且ArcGIS Pro整合了ArcGlobe, ArcScene, ArcCatalog, City Engine等软件的功能，集成于一款软件，使得制作与开发更加便捷。ArcGIS Pro 是真正的纯 64 位、多线程应用程序，ArcGIS Pro的运算及渲染效果更加强大，是 GIS 专业人员的主要应用程序。并能够与ArcMap在同一环境下工作，不存在环境冲突。
2、环境要求 基于2.1版本.
2.1 支持的操作系统 操作系统
经测试的最新更新或补丁包
Windows 10 家庭版、专业版和企业版（64 位）
秋季创作者更新
Windows 8.1 专业版和企业版（64 位）
更新：2017 年 11 月
Windows 7 旗舰版、专业版和企业版（64 位）
SP1 和 KB2533623
Windows Server 2016 标准版和数据中心版（64 位）
更新：2017 年 11 月
Windows Server 2012 R2 标准版和数据中心版（64 位）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f3460b32d3352e129eff70681b6e002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0b516e712f009505cd3eeccaeda0d0/" rel="bookmark">
			基于SpringMVC的文件上传下载及显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，不得不感慨spring框架的强大，学习了很久还是发现很多东西都只是理解了皮毛，但是往往你所能想到的功能，都可以用编码来实现，只不过效率高低取决于采取什么方法。 今天在完善我的《教务信息管理系统》项目时，构想如下： 教师登录自己的教师系统，可以查看到自己所教授的课程，同时可以进行给学生打分、上传课件等操作； 学生登录自己的学生系统，在已选课程列表可以查看某课程的具体信息，并且下载某课程对应的课件。 为了实现这个功能，我开始上网找资料，了解到可以用SpringMVC来解决。 项目基于ssm+shiro,具体配置建上一篇介绍。实现步骤如下： 1、pom.xml配置commons-io和commons-fileload，maven会根据对应版本去下载依赖：
&lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 2、配置springmvc.xml文件：定义文件上传解析器： 文件不可能无限大的上传，所以一定要设置文件大小的限制。
&lt;!-- 定义文件上传解析器 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt; &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt; &lt;property name="maxUploadSize" value="5242880" /&gt; &lt;property name="maxInMemorySize" value="4096" /&gt; &lt;/bean&gt; 3、接下来是实现文件上传、文件下载及上传文件显示的后端代码： controller层： （1）文件上传：
/* * 上传课件 */ //文件上传:表单：POST请求，file类型，enctype="multipart/form-data" @RequestMapping(value = "fileUpload", method = RequestMethod.POST) public String testUpload(HttpServletRequest request, @RequestParam(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0b516e712f009505cd3eeccaeda0d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32351601986efbf2163b7715044a869f/" rel="bookmark">
			Error:could not open &#39;...jvm.cfg&#39;解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一天打开dos窗口执行Java命令报错，错误如下图所示
从网上搜索解决方法，说需要删除C盘如下几个文件
c:/windows/system32/java.exe
c:/windows/system32/javaw.exe
c:/windows/system32/javaws.exe
但是我的电脑路径下并没有所说的几个文件，
最终的解决方法是：将环境变量PATH中JAVA_HOME放在最前面，
如图，问题解决，当然首先要检查自己的环境变量配置的是否正确
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89ee38ad1369b1b08b770fbfc01519b/" rel="bookmark">
			百度网盘如何设置代理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 百度网盘登陆不了，通过选择：设置，然后在类型那里选 HTTP、再把代理地址和端口号写进去，最后确定就可以登陆了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19a8b17b435a28c540afce8e8f8809b/" rel="bookmark">
			postgresql允许远程访问配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：PostgreSQL允许远程访问设置方法 https://sxfblog.com/archives/510
远程访问Windows版postgresql数据库 http://johnsmith9th.iteye.com/blog/2380033
安装PostgreSQL数据库之后，默认只能本地访问连接。如果想在其他主机上访问PostgreSQL数据库服务器，就需要进行相应的配置。
1、修改postgresql.conf文件 在安装目录下data/postgresql.confi文件中将
#listen_addresses='localhost’修改为listen_addresses = '*' 2、修改pg_hba.conf文件 在data/pg_hba.conf中
# TYPE DATABASE USER ADDRESS METHOD # IPv4 local connections:
host all all 127.0.0.1/32 md5
host all all 0.0.0.0/0 md5 其中0.0.0.0/0表示运行任意ip地址访问。
若设置为 192.168.1.0/24 则表示允许来自ip为192.168.1.0 ~ 192.168.1.255之间的访问。
3、设置好后重启服务即可被远程连接。 4、开放端口 1. 控制面板--&gt;系统与安全--&gt;Windows防火墙
2. 点击左侧“高级设置”功能
3. 选择左侧树上“入站规则”，再点击右侧操作树上的“新建规则”
4. 在弹出的向导对话框中选择"端口"，然后点击“下一步”
5. 在特定本地端口的输入框里输入"5432",然后一直“下一步”到最后一页，随便给规则起个名字如“postgresql rule”。
5、远程连接 开启数据库时host为服务器ip地址，port默认为5432。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3d1a9578601d8a26d4c16858a5d12d/" rel="bookmark">
			hadoop简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop介绍 大数据解决四大核心问题： 1、数据的存储（Big Data Storage），海量数据需要处理和分析，但前提是要进行有效的存储。Hadoop的诞生突破了传统数据文件系统的单机模式。HDFS使得数据可以跨越不同的机器与设备，并且用一个路径去管理不同平台上的数据。
2、数据的计算（Data Calculation），在数据有效存储的基础上，对数据的统计和分析本质上就是数据的计算。在大数据领域常见的计算工具有MapReduce、Spark等。
3、数据的查询（Consensus Data），对大数据进行有效管理的核心指标是数据查询技术。其中NoSQL (Not Only SQL)应用较为广泛，能较有效解决数据的随机查询，其中就主要包括Hbase等。从本质而言，依旧是Hadoop模式下的数据查询。
4、数据的挖掘（Data mining），Hive数据仓库为数据的挖掘提供了基础，通过分类、预测、相关性分析来建立模型进行模式识别、机器学习从而构建专家系统。
Hadoop之父 他是Lucene、Nutch 、Hadoop等项目的发起人。是他，把高深莫测的搜索技术形成产品，贡献给普通大众；还是他，打造了在云计算和大数据领域里如日中天的Hadoop。他是某种意义上的盗火者（普罗米修斯盗火造福人类），他就是Doug Cutting。
hadoop概述 Hadoop是项目的总称。主要是由HDFS和MapReduce组成。HDFS是Google File System（GFS）的开源实现。MapReduce是Google MapReduce的开源实现。
Hadoop的诞生突破了传统数据文件系统的单机模式。使得数据可以跨越不同的机器与设备，并且用一个路径去管理不同平台上的数据。
MapReduce的计算模型分为Map和Reduce两个过程。在日常经验里，我们统计数据需要分类，分类越细、参与统计的人数越多，计算的时间就越短，这就是Map的形象比喻，在大数据计算中，成百上千台机器同时读取目标文件的各个部分，然后对每个部分的统计量进行计算，Map就是负责这一工作的；而Reduce就是对分类计数之后的合计，是大数据计算的第二阶段。可见，数据的计算过程就是在HDFS基础上进行分类汇总。
HDFS把节点分成两类：NameNode和DataNode。NameNode是唯一的，程序与之通信，然后从DataNode上存取文件。这些操作是透明的，与普通的文件系统API没有区别。
MapReduce则是JobTracker节点为主，分配工作以及负责和用户程序通信。
HDFS和MapReduce实现是完全分离的，并不是没有HDFS就不能MapReduce运算。
Hadoop也跟其他云计算项目有共同点和目标：实现海量数据的计算。而进行海量计算需要一个稳定的，安全的数据容器，才有了Hadoop分布式文件系统（HDFS，Hadoop Distributed File System）。
HDFS通信部分使用org.apache.hadoop.ipc，可以很快使用RPC.Server.start()构造一个节点，具体业务功能还需自己实现。针对HDFS的业务则为数据流的读写，NameNode/DataNode的通信等。
MapReduce主要在org.apache.hadoop.mapred，实现提供的接口类，并完成节点通信（可以不是hadoop通信接口），就能进行MapReduce运算。
hadoop生态模型 Hadoop Common： 在0.20及以前的版本中，包含HDFS、MapReduce和其他项目公共内容，从0.21开始HDFS和MapReduce被分离为独立的子项目，其余内容为Hadoop Common
HDFS：Hadoop分布式文件系统(Distributed File System) － HDFS (Hadoop Distributed File System)。
MapReduce：并行计算框架，0.20前使用 org.apache.hadoop.mapred 旧接口，0.20版本开始引入org.apache.hadoop.mapreduce的新API。
HBase： 类似Google BigTable的分布式NoSQL列数据库。（HBase和Avro已经于2010年5月成为顶级 Apache 项目）。
Hive：数据仓库工具，由Facebook贡献。
Zookeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。
Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的序列化机制。
Pig： 大数据分析平台，为用户提供多种接口。
Ambari：Hadoop管理工具，可以快捷的监控、部署、管理集群。
Sqoop：用于HADOOP与传统的数据库（mysql、Oracle等）间进行数据的传递。
hadoop1.0和hadoop2.0架构 1.0和2.0的区别是2.0新增YARN，负责集群的资源管理、调度、分配等。
初步了解了hadoop相关概念，我们就可以一起来搭建hadoop集群环境了。想要了解和学习hadoop集群环境搭建的小伙伴可以参看我的这篇博文：hadoop集群环境搭建教程。
版权所有，转载请说明转载地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db09acfa0693b871c70deeef9e8917e9/" rel="bookmark">
			plsql中文乱码问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早上一进门，妹纸同事惊呼，啊，我的表数据怎么全是问号了，快来帮我看看，老夫答，字符集问题，百度看看，然后妹纸各种百度，搜狗，搜了一堆的解决方案，仍然未解决。老夫看了一下，那些博文，真是误人子弟啊。于是就有了这片文章，废话不多说，看问题
如图NLS_LANGUAGE 表示“语言”，NLS_TERRITORY 表示“地域”，NLS_CHARACTSET 表示“字符集”，将他们三个按照“语言_地域.字符集”的格式拼接起来，就有了“AMERICAN_AMERICA.AL32UTF8”【注意：这里要根据你自己的ORACLE服务器的这三个值进行拼接哦，注意有个点“.”】
然后
进入 我的电脑,属性,高级,环境变量，添加变量: NLS_LANG="AMERICAN_AMERICA.AL32UTF8"
关掉plsql 重启，就正常了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae710e5aece64036f7b5f31b5a6973a5/" rel="bookmark">
			Eureka--4、使用Peer实现Eureka Server高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单独的Eureka Server仍然可以保持很高的弹性 因为客户端本地也会存有一份服务的map，所以即使所有的注册中心全部挂掉，也不影响client的相互访问。并且会在注册中心可用的情况下第一时间进行通信，同步数据。即使只有一个Eureka Server，也可以让系统又比较高的弹性。
但是对于大型项目，天生就要求有多个Zone的存在。每个Zone中又会有至少一个Eureka Server。这些Eureka Server应该互为peer。peer会从所有的兄弟peer那里同步服务列表。从其它节点那里同步到的服务列表和本机的服务列表一样，也可以同步给客户端。
实现高可用的Eureka集群 我们前面已经把eureka-server和拆成了两个，但是用来演示高可用，两个是不够的。
我们假定有两个zone，nj1，nj2，假设用来演示一个zone下有多个eureka server，需要四个server，我们把server继续拆成nj1a、nj1b，nj2a,nj2b。同时把client拆成两个。
然后把Server改成不用defaultZone的配置。具体注释放在yml中，所有配置如下。
需要继续去hosts里面添加hostName 127.0.0.1 eureka-server3
127.0.0.1 eureka-server4
配置Eureka Client 加载配置的顺序为先加载bootstrap.yml，再加载application.yml，如果有后缀，也就是profile，则会先加载原始的，再加载带后缀的，后面的配置会覆盖前面的配置。因为我们使用了config，所以bootstrap.yml必不可少，我们在bootstrap.yml中配置config需要的信息。在application.yml中配置公共信息。在application-xxx.xml中配置各自的信息。
bootstrap.yml省略 application.yml eureka:
instance:
hostname: localhost
client:
# 假设指定region为江苏
region: js
availability-zones:
#假设江苏下面有南京的两个region
js: nj1,nj2
service-url:
# 客户端应该根据所在zone，兄弟zone的顺序，列出所有的可连接service-url
nj1: http://eureka-server1:8761/eureka,http://eureka-server2:8762/eureka
nj2: http://eureka-server3:8763/eureka,http://eureka-server4:8764/eureka
application-web1.yml server:
port: 8080
eureka:
instance:
metadata-map:
zone: nj1
application-web2.yml server:
port: 8081
eureka:
instance:
metadata-map:
zone: nj2
配置Eureka Server 注意前俩metadateMap.zone是nj1，后俩是nj2，虽然不知道啥用，我们先按照“假设这俩是用来指定server真正属于哪个zone”的逻辑来设置
前俩是availabilityZones是js: nj1,nj2 后俩是js: nj2,nj1
hostname是eureka-server1，eurea-server2，eurea-server3，eurea-server4顺着排下去
前俩service-url，nj1在前面，后俩nj2在前面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae710e5aece64036f7b5f31b5a6973a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e269c3e8eb27a09235d47db3b826a6/" rel="bookmark">
			Eureka--3、高可用注册中心的第一步，通过defaultZone深入理解zone和serviceUrl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		defaultZone与serviceUrl的获取 我们平时都是用defaultZone，这个defaultZone到底是什么，为什么一定要用defaultZone，换个别的行不行。网上很多文章都是入门的，不会讲到这一点。
default-zone != defaultZone 我是用idea来写application.yml，里面对于属性的提示值不是采用骆驼命名法，而是使用短横线"-"隔开。
本来配置属性都有自动提示的，会发现defaultZone并不会提示，我天真的以为写成default-zone也可以，其实eureka并不认识这个。其它的属性使用短横线隔开和骆驼命名，是提前做了处理。而serviceUrl是真正的属性，service-url的配置内容是map，map的内容是可以自己发挥的，只要是key: value格式就行（注意有个空格）。有很多map类型的配置，比如availabilityZones，metadata-map都是的，内容虽然是key: value格式，但是都是可以自由发挥。其中metadata-map比较特殊，里面有个zone的属性，会被eureka client解析，当成客户端默认指向的zone来处理。（目前没有尝试出来效果）
其实写作default-zone的时候，eureka经过一系列的解析，最终认定，这个客户端没有配置有效的seviceUrls。。。然后自己加一个defaultZone，默认使用http://localhost:8761/eureka/作为地址，而我恰好也用8761作为地址，造成了很多误会。
源码解读： 我们来看service-url是如何获取的。
Eureka Client的属性都在EurekaClientConfig类接口中定义处理方法。
查看实现会有两个实现，我们用的是spring的，我们主要看getAvailabilityZones()和getEurekaServerServiceUrls()两个方法的实现。
// 根据region，从availabilityZones这个Map中获取key值对应的配置。 // availabilityZones是通过eureka.client.availability-zones配置的， // 可以配置多个availabilityZones，key表示region，value表region对应的zones // 假设有多个zones，用逗号隔开。 // region通过eureka.client.region来设置，假设不设置，默认为"us-east-1c"。 public String[] getAvailabilityZones(String region) { String value = (String)this.availabilityZones.get(region); if (value == null) { value = "defaultZone"; } return value.split(","); } // 根据zone来获取serviceUrls，假设用逗号隔开会拆分成数组。 public List&lt;String&gt; getEurekaServerServiceUrls(String myZone) { String serviceUrls = (String)this.serviceUrl.get(myZone); if (serviceUrls == null || serviceUrls.isEmpty()) { serviceUrls = (String)this.serviceUrl.get("defaultZone"); } if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e269c3e8eb27a09235d47db3b826a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6210d5896c3a14e597744e3577325101/" rel="bookmark">
			用原生Tensorflow编写的Inception-ResNet-V1网络（想了解模型实现细节的看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# prepare input data IMAGE_HEI = 128 IMAGE_WID = 128 IMAGE_CHA = 3 CLASS_NUM = 2 X = tf.placeholder(tf.float32, [None, IMAGE_HEI, IMAGE_WID, IMAGE_CHA]) Y_= tf.placeholder(tf.float32, [None, CLASS_NUM]) keep_prob = tf.placeholder(tf.float32) lr = tf.placeholder(tf.float32) # learning rate 下边的代码片段实现了Inception-ResNet-V1网络的：Stem，Inception-resnet-A，Reduction-A，Inception-resnet-B，Reduction-B，Inception-resnet-C五个模块。
#---------- Stem Block ------------------------------------------# # Input layer out: 128 * 128 * 3 # | # 3*3 conv 32 out: 128 * 128 * 32 # | # 3*3 conv 32, stride=2 (we use max_pool instead) out: 64 * 64 * 32 # | # 3*3 conv 64 out: 64 * 64 * 64 # | # 3*3 conv 64, stride=2 (we use max_pool instead) out: 32 * 32 * 64 # | # 3*3 conv 128 out: 32 * 32 * 128 # | # 3*3 conv 128,stride=2 (we use max_pool instead) out: 16 * 16 * 128 # | # relu (output 16*16*128) out: 16 * 16 * 128 stem_conv1_k = 32 stem_conv1_w = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6210d5896c3a14e597744e3577325101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b70ca8ea7e43d063ebc471f912426fe/" rel="bookmark">
			如何在Ubuntu 18.04上安装Git与入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：https://www.linuxidc.com/Linux/2018-05/152610.htm
在本教程中，我们将向您展示如何在Ubuntu 18.04上安装Git。 我们还将安装并配置其必要条件。 Git是一个分布式版本控制程序，您可以在开发软件时使用它监视代码的变化（版本）。 Git提供了恢复到前一阶段，多个工作流程，邻居分支以及其他许多功能的功能。 这使Git成为最好的版本控制系统之一，这也是许多软件开发人员使用Git的原因。
我建议使用最小的Ubuntu服务器设置作为本教程的基础，可以是虚拟或根服务器映像，使用Ubuntu 18.04 LTS Bionic Beaver最小化安装，或者使用我们的最小服务器教程安装 服务器从零开始。
在Ubuntu 18.04上安装Git
步骤1.首先，通过运行以下命令确保您的系统和apt包列表完全更新：
apt-get update -y
apt-get upgrade -y
第2步。在Ubuntu 18.04上安装Git。
现在让我们安装git：
apt install git
您可以使用以下命令来检查已安装的git版本：
$ git --version
git version 2.15.1
第3步。在Ubuntu 18.04上配置Git。
安装后您可能想要做的第一件事是在Git中配置自己的名称和电子邮件地址，以便您提交的更改包含正确的信息。 您可以通过使用以下命令来完成此操作：
linuxidc@linuxidc:~$ git config --global user.name "linuxidc"
linuxidc@linuxidc:~$ git config --global user.email "root@linuxidc.net"
接下来，我们将通过查看.gitconfig来验证配置更改：
linuxidc@linuxidc:~$ git config --list
user.name=linuxidc
user.email=root@linuxidc.net
有关更多信息和命令行选项，可以使用-help标签：
git --help
linuxidc@linuxidc:~$ git --help
用法：git [--version] [--help] [-C &lt;path&gt;] [-c &lt;键名&gt;=&lt;值&gt;]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b70ca8ea7e43d063ebc471f912426fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854193fc67c3faca725748c4cac95c9b/" rel="bookmark">
			第三方css文件导致网页不能上下滚动的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天改一个web项目，改着改着，发现页面无法滚动了，超出的内容一律看不见，怎么办？
本来是页面自动上下滚动的，现在突然就不行了，原因在哪里？
想了半天，因为并没有主动去做类似的设置，所以只可能是在引入某些css文件的时候，可能该css文件中导致了这个问题。
于是尝试逐个注释本周新添加的css引用，轮到其中一个的时候，页面可以滚动了，问题解决。
&lt;!--注销某些css的引用--&gt; &lt;!--&lt;link rel="stylesheet" href="css/orgchart/style.css"&gt;--&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1dc74ad4d797a68931e377a1cda43c/" rel="bookmark">
			（八）Mybatis的入门教程—— 动态sql之if标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：查询员工要求——携带了哪个字段，查询条件就带上这个字段的值
接口
public interface EmployeeMapperDynamicSQL{ //携带了哪个字段查询条件就带上这个字段的值 public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee); } 映射文件
使用if 标签
test：判断表达式（使用OGNL语言），test等号右边的数值是从参数中取值进行判断
OGNL：对象图导航语言，这是一种强大的表达式语言，通过它可以非常方便的来操作对象属性。类似于EL，SqEL等。它的使用方法参考官方文档好了。
&lt;select id="getEmpsByConditionIf" resultType="com.mybatis.bean.Employee"&gt; select * from tbl_employee where &lt;if test="id!=null"&gt; id=#{id} &lt;/if&gt; &lt;if test="lastName!=null &amp;amp;&amp;amp; lastName!=''"&gt; and last_name like #{lastName} &lt;/if&gt; &lt;if test="email!=null and email.trim()!=&amp;quot;&amp;quot;"&gt; and email=#{email} &lt;/if&gt; &lt;if test="gender==0 or gender==1"&gt; and gender=#{gender} &lt;/if&gt; &lt;/select&gt; 在XML文档中遇见特殊符号应该去写转义字符
在OGNL中使用lastName!=' '这种判断方式是可行的，如果写成lastName!=" "反而是不对的。
在XML文档中使用&amp;&amp;是不对的，可以使用and，也可以使用转义字符。
OGNL会自动进行字符串与数字的转换判断，默认"0" 是等于 0 的。
测试
@Test public void testDynamicSql(){ SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1dc74ad4d797a68931e377a1cda43c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06dee136ef2f0b99aff1ea028f9b16b2/" rel="bookmark">
			vue按需加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue-cli构建的vue项目，在打包的时候，会把所有vue模板打包成一个app.js包，在项目页面比较多的时候，这个文件会非常的大。用户第一次访问，要加载vendor.js依赖包和app.js两个比较大的文件，响应非常慢。
那么，就要把app.js拆分开来，打包成多个文件，访问哪个模板路由，就加载哪一个。不需要一次把所有模板页面全部加载。
解决办法：在router/index.js文件中，把模板引入方式改成函数引入：
import Vue from 'vue' import Router from 'vue-router' const Detail = () =&gt; import('@/views/detail'); const Error = () =&gt; import('@/views/error'); 原理：
不直接import模板文件，通过函数调用方式，访问到哪一个路由，函数才会调用该路由对应的模板，进行加载。
再次打包，发现dist/static/js文件夹下面，被拆分成了很多个模板文件。
（友情提示）webpack打包默认会生成map文件，用来处理错误信息，如果不想生成该文件，则修改config/index.js
productionSourceMap: false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/637d83339f36d39415f75437091d7588/" rel="bookmark">
			C&#43;&#43;传值与传地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; struct Object { int id; char name[256]; }; //传值方式 void Text1(Object a) { printf("id: %d,name: %s", a.id, a.name); } //传地址方式 void Text2(Object* a) { printf("id: %d,name: %s", a-&gt;id, a-&gt;name); } int main() { Object obj = { 123, "zhangsan" }; Text1(obj); Text2(&amp;obj); return 0; } 1.传值方式 函数的形参是传入的实参的一份拷贝，形参是函数的局部变量，只在函数内部有效。 在函数Text1被调用时，有两个Object对象，其中一个叫obj,定义在main函数里，另一个叫a，是函数Test1里的局部变量。 在传值调用时，讲obj的值赋给了变量a.相当于： Object a = obj; 因此说，对象a是obj的一个拷贝，下面分析这一部操作的资源消耗： （1）从内存资源消耗上看（空间角度），对象a耗费260个字节的内存。 （2）从CPU资源的耗费上看（时间角度），从对象obj到对象a需要复制260个字节。 2.传地址方式 在函数Text2被调用时，传入一个对象obj的地址，既有一个Object*指针来表示对象obj的地址 Object *p = &amp;obj; 下面分析这一部操作的资源消耗： （1）从内存资源消耗上看（空间角度），指针p占据4个字节，所有的指针其实只是一个整数（表示内存地址） （2）从CPU资源的耗费上看（时间角度），不需要复制数据，只需传递一个整数地址。 通过比较发现，传地址方式在性能上远远优于传值方式，它使用了较少的资源完成了相同的事情。在内存上，传地址方式使用了较少的内存，在CPU消耗上，传地址方式耗费的CPU操作也非常少。 所以在C/C++里，当一个对象的体积较大时（结构体。数组），总是使用传地址方式来传递参数
指针变量为什么占4个(8个)字节？ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/637d83339f36d39415f75437091d7588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2d873b01458d7938c99847a80c2fa3/" rel="bookmark">
			Eureka--2、第一个Eureka程序，Eureka Client的自启动原理和简要过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的Spring Cloud Config的基础上，搭建简单的Eureka Server
没有代码，很多试验做不起来，我们先创建个Eureka Server再说。
本篇主要讲如何创建Eureka Server和Eureka Client，还有个重点是通过源码分析Eureka Client是如何自动启动的。
创建Eureka Server 1、通过idea创建Eureka Server 通过Spring Initializr创建，选择Web和Cloud Discovery里面的Eureka Server
使用intellij创建spring boot项目的时候，选择Cloud Discovery下面Eureka有两个选项，Eureka Server和Eureka Discovery。一个是Eureka Server，一个是Eureka Client。
查看生成的pom，区别就在引入的jar包不同，一个是spring-cloud-starter-netflix-eureka-client，一个是spring-cloud-starter-netflix-eureka-server。netflix的starter几经修改，变成了现在的样子，大家在网上看一些老的帖子，有可能那时候的pom.xml中的dependency和现在是不一样的。
2、配置eureka server server application.yml配置文件
spring: application: name: eureka-server server: #指定服务端口 port: 8761 eureka: #指定主机名称 instance: hostname: localhost #server一定程度上也是client，互为client， client: #由于自己就是服务器，不需要注册到自己 register-with-eureka: false #由于自己就是服务器，不需要从服务器获取注册信息 fetch-registry: false #服务地址 service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3、在启动类上添加@EnableEurekaServer
4、启动项目，输入localhost:8761 看一下效果先
5、我们先创建完客户端，配置完客户端，再来看配置项的意义
创建Eureka Client 1、添加依赖项，使项目成为Eureka Client 从idea创建时，Eureka client使用Eureka Discovery创建，会自动添加依赖项。我们不新建，把之前的Config Client项目增加Eureka Client依赖，到maven repository那些网站搜spring eureka client，就能找到依赖的xml，注意不要弄成spring boot的starter，是spring cloud的，贴到之前的配置客户端中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b2d873b01458d7938c99847a80c2fa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84df618e1a00e036122f6307c1d7a179/" rel="bookmark">
			C 语言实现面向对象编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C 语言实现面向对象编程 1、引言 面向对象编程（OOP）并不是一种特定的语言或者工具，它只是一种设计方法、设计思想。它表现出来的三个最基本的特性就是封装、继承与多态。很多面向对象的编程语言已经包含这三个特性了，例如 Smalltalk、C++、Java。但是你也可以用几乎所有的编程语言来实现面向对象编程，例如 ANSI-C。要记住，面向对象是一种思想，一种方法，不要太拘泥于编程语言。
2、封装 封装就是把数据和方法打包到一个类里面。其实C语言编程者应该都已经接触过了，C 标准库 中的 fopen(), fclose(), fread(), fwrite()等函数的操作对象就是 FILE。数据内容就是 FILE，数据的读写操作就是 fread()、fwrite()，fopen() 类比于构造函数，fclose() 就是析构函数。这个看起来似乎很好理解，那下面我们实现一下基本的封装特性。
#ifndef SHAPE_H #define SHAPE_H #include &lt;stdint.h&gt; // Shape 的属性 typedef struct { int16_t x; int16_t y; } Shape; // Shape 的操作函数，接口函数 void Shape_ctor(Shape * const me, int16_t x, int16_t y); void Shape_moveBy(Shape * const me, int16_t dx, int16_t dy); int16_t Shape_getX(Shape const * const me); int16_t Shape_getY(Shape const * const me); #endif /* SHAPE_H */ 这是 Shape 类的声明，非常简单，很好理解。一般会把声明放到头文件里面 “Shape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84df618e1a00e036122f6307c1d7a179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cf49e8b0b8e5517e39df63acf40fc5/" rel="bookmark">
			laravel 目录添加n个app应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Laravel —— 应用目录结构
方法/步骤
Laravel —— 应用目录结构 Laravel应用默认的目录结构试图为不管是大型应用还是小型应用提供一个好的起点，当然，你可以自己按照喜好重新组织应用目录结构，Laravel 对类在何处被加载没有任何限制——只要 Composer 可以自动载入它们即可。
方法/步骤 新安装的 Laravel 应用包含许多文件夹：
app 目录包含了应用的核心代码；
bootstrap 目录包含了少许文件用于框架的启动和自动载入配置，还有一个 cache 文件夹用于包含框架生成的启动文件以提高性能；
config 目录包含了应用所有的配置文件；
database 目录包含了数据迁移及填充文件，如果你喜欢的话还可以将其作为 SQLite 数据库存放目录；
public 目录包含了前端控制器和资源文件（图片、JavaScript、CSS等）；
resources 目录包含了视图文件及原生资源文件（LESS、SASS、CoffeeScript），以及本地化文件；
storage 目录包含了编译过的Blade模板、基于文件的session、文件缓存，以及其它由框架生成的文件，该文件夹被细分为成 app 、 framework 和 logs子 目录， app 目录用于存放应用要使用的文件， framework 目录用于存放框架生成的文件和缓存，最后， logs 目录包含应用的日志文件；
tests 目录包含自动化测试，其中已经提供了一个开箱即用的 PHPUnit 示例；
vendor 目录包含 Composer 依赖；
应用的核心代码位于 app 目录下，默认情况下，该目录位于命名空间 App 下， 并且被 Composer 通过 PSR-4自动载入标准 自动加载。你可以通过Artisan命令 app:name 来修改该命名空间。
app 目录下包含多个子目录，如 Console 、 Http 、 Providers 等。 Console 和 Http 目录提供了进入应用核心的API，HTTP协议和CLI是和应用进行交互的两种机制，但实际上并不包含应用逻辑。换句话说，它们只是两个向应用发布命令的方式。 Console 目录包含了所有的Artisan命令， Http 目录包含了控制器、中间件和请求等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5cf49e8b0b8e5517e39df63acf40fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7f0fa233179cd877b32fc8e399f237/" rel="bookmark">
			C&#43;&#43;继承与多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，继承 1，继承的基本特性 子类继承父类所有方法和属性子类是特殊的父类子类对象可以当作父类对象使用子类可以拥有父类没有的方法和属性 2，访问级别 public：可以被外界访问private：只能在类中被访问protected：可以在当前类和子类中访问 限制级别：private&gt;protected&gt;public
3，继承方式和访问级别 父类成员在子类对外访问属性：= Max{ 继承方式, 父类成员访问级别 }
4，多继承和多重继承 多继承：
class man
{
};
class girl
{
};
class student:public man,public girl
{
};
多重继承：
class man
{
};
class girl：public man
{
};
class student:public girl
{
};
多重继承任意的父子对象，都满足赋值兼容性原则
5，赋值兼容性原则 子类对象可以当作父类对象使用
子类对象可以直接赋值给父类对象
子类对象可以直接初始化父类对象
父类指针可以指向子类对象
父类引用可以直接引用子类对象
6，继承和构造，析构 子类对象在创建时会首先调用父类的构造函数
父类构造函数执行结束后，执行子类的构造函数
当父类的构造函数有参数时，需要在子类的初始化列表中显示调用
析构函数调用的先后顺序与构造函数相反
7，继承和组合 口诀：先父母，后客人，再自己。
如果前面两个没有默认构造函数，则需要在初始化列表进行初始化
8，同名成员 当子类成员变量与父类成员变量同名时
子类依然从父类继承同名成员在子类中通过作用域分别符::进行同名成员区分同名成员存储在内存中的不同位置如果不用::则子类将隐藏父类成员变量 二，函数重写 1，函数重写 子类定义了与父类原型相同的函数函数的重写只能发生在子类与父类之间父类的被重写的函数依然被子类继承了默认情况下父类的被重写的函数会被子类隐藏在子类中可以用作用域分辨符::调用父类被重写的函数 2，函数重写与赋值兼容性 父类指针或者引用指向子类对象时，此时调用的函数是父类的函数
原因：c++是静态编译语言。由于程序没有运行，所以不知道父类指针具体指向的是父类对象还是子类对象，从编译器的安全角度出发，编译器假设父类的指针指向的是父类对象。
3，多态 同样的调用语句有多种不同的表现形态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed7f0fa233179cd877b32fc8e399f237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea2d3a029a6e4be939952920f00c983/" rel="bookmark">
			vue i18n国际化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装i18n插件，配合使用饿了么UI框架 http://element-cn.eleme.io/#/zh-CN/
npm install vue-i18n -S npm install element-ui -S 饿了么UI的组件语言也会一同更改，如图（英文状态）：
2、在src目录下，创建多语言目录i18n
langs目录下为语言配置文件，languages目录下为语言json文件, i18n.js为配置文件
3、在main.js里面添加
import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import i18n from './i18n/i18n'; Vue.use(ElementUI); new Vue({ el: '#app', router, i18n, //在此添加i18n组件 components: { App }, template: '&lt;App/&gt;' }); 4、i18n目录下，i18n.js
import Vue from 'vue' import locale from 'element-ui/lib/locale'; import VueI18n from 'vue-i18n' import messages from './langs' Vue.use(VueI18n); //从localStorage中拿到用户的语言选择，如果没有，那默认英文。 const i18n = new VueI18n({ locale: localStorage.lang || 'en', messages }); locale.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea2d3a029a6e4be939952920f00c983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/187c05c63409b4c7a113e6277cbc6dab/" rel="bookmark">
			NOIp2011数字反转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题解：本题考查循环的使用和用一个数字表示一个多位数。 代码如下：
#include&lt;iostream&gt; using namespace std; int main() { int n,a=0; cin&gt;&gt;n; while(n!=0) { a=a*10+n%10; n=n/10; } cout&lt;&lt;a; return 0; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ca5ad411df50ec66b16c17140c36e1/" rel="bookmark">
			secureCRT运行命令脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过VBS的secureCRT脚本， 功能太少了，改成python的
# $language = "python" # $interface = "1.0" #----------------------------------------------------------------------------------- import os import time g_szConfigFile = "D:/Desktop/FTP/python3/secureCRT/test/info.txt" g_szCommandFile = "D:/Desktop/FTP/python3/secureCRT/test/cmd.txt" g_szDesktopFolder = "D:/Desktop" def connectFun(szIPAddr, szUserName = "username", szPassWd = "password"): szSSH2cmd = "/SSH2 /L %s /PASSWORD %s %s" % (szUserName, szPassWd, szIPAddr) szTelnetcmd = "/Telnet %s" % (szIPAddr) result = False try: crt.Session.ConnectInTab(szSSH2cmd) result = True except: try: crt.Session.ConnectInTab(szTelnetcmd) crt.Screen.WaitForString("name") crt.Screen.Send(szUserName + "\r") crt.Screen.WaitForString("ass") crt.Screen.Send(szPassWd + "\r") result = True except: crt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ca5ad411df50ec66b16c17140c36e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3aa854be5bace88c36cbcbc7cf6d853/" rel="bookmark">
			java  斜杠转义问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我把一段 路径字符串 替换到前台接受的时候 字符串中的 \ 消失了
例如 apache-tomcat-8.5.27\webapps\bgb\imgPath \ 消失不见
解决方法：将字符串中的"\"替换成"\\"
例如：
String pic_Path=" apache-tomcat-8.5.27\webapps\bgb\imgPath ";
String pic_Page1=pic_Page.replaceAll("\\\\","\\\\\\\\");
再把pic_Path1传过去
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2eb5a5832854caf44f9c043076d7c0/" rel="bookmark">
			Linux 磁盘配额 quota
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 磁盘配额 quota
Quota一直就是个很有用的东西。如果您曾经申请过网络的mail服务时，那么肯定就会明白什么是20MB的邮件空间、 30MB的免费网页空间，这个20MB，30MB就是quota这个东西搞出来的。如果我们要限制用户使用硬盘的容量使用大小，就需要quota来处理。
一、什么是quota
简单的说就是限制用户对磁盘空间的使用量。
在Linux系统中，由于是多人多任务的环境，所以会有多人共同使用一个硬盘空间的情况发生，如果其中有少数几个使用者大量的占掉了硬盘空间的话，那势必压缩其它使用者的使用权力，因此管理员应该适当的开放硬盘的权限给使用者，以妥善的分配系统资源。为了合理的分配磁盘空间，于是就有了quota的出现。
二、quota的用途
quota命令用于显示用户或者工作组的磁盘配额信息。输出信息包括磁盘使用和配额限制。
作用对象：
针对Web服务器，例如：每个人的网页空间的容量限制。
针对Mail服务器，例如：每个人的邮件空间限制。
针对File服务器，例如：每个人最大的可用网络硬盘空间。
三、quota的使用限制 仅针对整个partition：quota实际在运作的时候，是针对『整个partition』进行限制的，例如：如果你的/dev/hda5是挂载在/home底下，那么在/home底下的所有目录都会受到限制！
核心必须支持quota：Linux系统核心必须有支持quota这个模块才行。如果您是使用FC4的预设核心，系统已经预设有开放quota这个模块。如果您是自行编译核心的，那么请特别留意您是否已经开启了quota这个模块。
只对一般身份使用者有效：并不是所有在Linux上面的账号都可以设定quota，例如root就不能设定quota，因为整个系统所有的数据几乎都是他的。
四、quota的使用
quota 选项 参数
选项： -g：列出群组的磁盘空间限制；
-q：简明列表，只列出超过限制的部分；
-u：列出用户的磁盘空间限制；
-v：显示该用户或群组，在所有挂入系统的存储设备的空间限制；
-V：显示版本信息。
参数:
用户或者工作组：指定要显示的用户或者工作组
[root@localhost(yuaning) ~]# quota -vs -u liubei #查看指定用户quota quota: Cannot open quotafile /mydata/aquota.user: No such file or directory quota: Cannot open quotafile /root/ccc/aquota.user: No such file or directory Disk quotas for user liubei (uid 1001): Filesystem space quota limit grace files quota limit grace /dev/md6 0K 0K 0K 0 0 0 [root@localhost(yuaning) ~]# quota -guvs # 查看当前用户的quota限制 quota: Cannot open quotafile /mydata/aquota.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f2eb5a5832854caf44f9c043076d7c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78b10ccb85f9b3cc09453ffe05e872b/" rel="bookmark">
			python-高级排序(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分治法 很多有用的算法结构上是递归的，为了解决一个特定的问题，算法一次或者多次递归调用其自身以解决若干子问题。这些算法典型地遵循分治法的思想:将原问题分解为几个规模较小但是类似于原问题的子问题，递归求解这些子问题，然后再合并这些问题的解来建立原问题的解。
分治法在每层递归时有三个步骤: 1.分解原问题为若干子问题，这些子问题是原问题的规模最小的实例 2.解决这些子问题，递归地求解这些子问题。当子问题的规模足够小，就可以直接求解 3.合并这些子问题的解成原问题的解
归并排序 现在我们就来看下归并排序是如何利用分治法解决问题的。 1.分解:将待排序的n个元素分成各包含n/2个元素的子序列 2.解决:使用归并排序递归排序两个子序列 3.合并:合并两个已经排序的子序列以产生已排序的答案 考虑到我们排序这个数组:[10,23,51,18,4,31,13,5],我们递归地将数组进行分解 当数组被完全分隔成只有单个元素的数组时，我们需要把它们合并回去，每次两两合并成一个有序的序列. 上图关于下标指针归并两个数组的具体实现原理: def merge_sort(seq): if len(seq) &lt;= 1: return seq else: mid = int(len(seq)/2) left_half = merge_sort(seq[:mid]) right_half = merge_sort(seq[mid:]) #合并两个有序数组 new_seq = merge_sorted_list(left_half,right_half) return new_seq def merge_sorted_list(sorted_a,sorted_b): length_a,length_b = len(sorted_a),len(sorted_b) #定义两个有序数组的指针即下标 a = b = 0 new_sorted_seq = list() while a &lt; length_a and b &lt; length_b: if sorted_a[a] &lt; sorted_b[b]: new_sorted_seq.append(sorted_a[a]) a += 1 else: new_sorted_seq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b78b10ccb85f9b3cc09453ffe05e872b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599937805fa6211f2653e2520caf573f/" rel="bookmark">
			with root cause 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：1.工程在启动的时候无异常，当页面加载到包含spring:message标签的页面时，在后台报空指针异常，同时控制 台会显示with root cause提示；
2.注释掉spring:message相关标签后，无异常，但是本应该显示具体内容的地方却显示标签中code的值；
3.同是这个工程，在别人的电脑上可以使用，在我电脑上不可用；
4.eclipse上可用，myeclipse上不可用；
原因：tomcat的安装路径出现空格；
解决：将部署 项目的tomcat放到没有空格的路径下，比如根目录下。
以上为我遇到的现象以及解决办法，如果还有什么其他现象以及解决办法欢迎补充。
转载于:https://www.cnblogs.com/borter/p/9468341.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4aed12f541153a4fd51f06c64fa803/" rel="bookmark">
			android.os.Build详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 android.os.Build是安卓的一个类，获取安卓的一些系统信息 android.os.Build.VERSION.RELEASE 获取当前系统版本号字符串：4.4.2
android.os.Build.MODEL 获取手机型号
android.os.Build.VERSION.SDK_INT 获取当前系统版本号数字：19
android.os.Build.BRAND 手机定制商 Build.BOARD // 主板 Build.CPU_ABI // cpu指令集 Build.DEVICE // 设备参数 Build.DISPLAY // 显示屏参数 Build.FINGERPRINT // 硬件名称 Build.HOST Build.ID // 修订版本列表 Build.MANUFACTURER // 硬件制造商 Build.MODEL // 版本 Build.PRODUCT // 手机制造商 Build.TAGS // 描述build的标签 Build.TIME Build.TYPE // builder类型 Build.USER 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b08748293d89fc125a145e24854dac92/" rel="bookmark">
			使用swoole&#43;php监控服务器端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;?php class Server { const PORT = 80; public function port() { $shell = "netstat -anp 2&gt;/dev/null | grep ".self::PORT." | grep LISTEN | wc -l"; $result = shell_exec($shell); if($result &lt;&gt; 1) { echo date("ymd H:i:s")."error".PHP_EOL; } else { echo date("ymd H:i:s")."success".PHP_EOL; } } } swoole_timer_tick(2000, function($timer_id) { (new Server())-&gt;port(); echo "time-start".PHP_EOL; }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded0faa1203f15af87fe65a3d28547d4/" rel="bookmark">
			原生JS中的三大家族（offset/scroll/client）与jQuery中对应的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS中的offset家族：
一、offsetEWidth与offsetHeight：
获取的是元素的实际宽高 = width + border + padding
注意点： 1.可以获取行内及内嵌的宽高 2.获取到的值是一个number类型，不带单位 3.获取的宽高包含border和padding 4.只能读取，不能设置
console.log ( box.offsetWidth );//width + border + padding console.log ( box.offsetHeight );//height + border + padding 二：offsetLeft与offsetTop:
offsetLeft:获取自己左外边框与offsetParent的左内边框的距离
offsetTop:获取自己上外边框与offsetParent的上内边框的距离
三：offsetParent:获取最近的定位父元素 （自己定位参照的父元素）
注意点： 1.如果元素自身是固定定位（fixed），则定位父级是null 2.如果元素自身是非固定定位,并且所有的父元素都没有定位，那么他的定位父级是body 3.body的定位父级是null
jQuery中获取宽高的方法： 一、width()/height()方法：获取到的是不带边框以及内边距的宽高 注意点： 1.获取到的就是内容的宽高,不带px的number类型的值. 2.获取不传参 3.传参代表的是设置内容的宽高
//模拟响应式布局. $(window).on('resize', function () { if($(this).width() &gt; 1200){ $('body').css('backgroundColor','red'); }else if($(this).width() &gt; 900){ $('body').css('backgroundColor','yellow'); } else if($(this).width() &gt; 600){ $('body').css('backgroundColor','pink'); }else if($(this).width() &gt; 400){ $('body').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ded0faa1203f15af87fe65a3d28547d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f03156676b9a0f31b6621faef00c521/" rel="bookmark">
			Win10家庭版彻底关闭自动更新的方法（本地组策略编辑器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用的一个笔记本是Thinkpad X1 Carbon，预装了Win 10家庭版，目前用的时候不知道怎么回事，每次Windows Update都会使风扇一直转。联想+微软Win10真是不靠谱到极致。所以想看看怎么把自动更新关掉。
有些教程里介绍用服务设置，例如：https://blog.csdn.net/MileyPriencess/article/details/78176259
（在左下角视窗图标上点右键——计算机管理——服务和应用程序——服务）
但是把自动更新服务禁掉后，过两天它又自动开启了。而Win 10家庭版是不带组策略编辑器的，其实可以安装。具体方法为：新建一个文本文件——把下面这些代码拷贝进去：
pushd "%~dp0" dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i" 然后把文本文件命名为“组策略.bat”，右键管理员身份运行，运行完后按键盘上“Windows图标+r”，输入gpedit.msc，就可以打开本地组策略编辑器了，然后选择“计算机配置”——“管理模板”——“Windows组件”——“Windows更新”——右侧列表中选择“配置自动更新”双击——选择“已禁用”，就可以彻底关闭自动更新了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d507bda27e50ca888c548ea668484007/" rel="bookmark">
			DQPSK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、QPSK的原理与概念 在PSK(相位调制)中，四相调制是一种被常用的多进制调制方式。四相调制又被分为四相绝对移相调制（也成为四相绝对移相键控，记为4PSK）和四相相对移相调制（也称为四相相对移相键控，记为4DPSK）
4PSK:将输入的二级制数据进行分组，每两个二进制数据为一组，然后根据其组合情况，用四种不同的载波相位去表征他们。其中每个双比特码元中的两个数据是按照格雷码来编写的。由于4PSK可以看作是两个正交的二相绝对移相调制的合成，所以4PSK也被称为QPSK。
4DPSK（也称为DQPSK）:在4PSK的基础上加上差分编码，即将双比特码元进行查分编码，然后进行相应的处理。
2、QPSK的实现 DQPSK信号的产生有两种方式，调相法和相位选择法。
2.1 调相法 实现框图如下：
成型滤波器的作用：在DQPSK调制系统中，由于原始信号的带宽无限大，但90%的能量均集中在主瓣带宽内，因此，为提高发射端的功率利用率，降低噪声的影响，通常需要在调制之前对原始基带信号进行成形滤波，以滤除主瓣外的信号和噪声。
串并转换：将一比特的数据流转换为两比特的数据流
成形滤波：消除码间串扰，以及抑制主瓣带外频率分量功率的目的，通常会在平衡调制器之前增加一级成形滤波器。这里采用的是低通滤波器。
2.2 相位选择法 四相载波发生器分别送出调相所需要的四种不同相位的载波， 安装串并转换器输出的不同双比特码元，选择输出相应相位的载波。这调制方式无法在数据调制前增加成形滤波器。只能依靠对已调信号进行带通滤波，实现降低主瓣带外功率的目的。达到降低码间串扰，达到滤除边带信号频谱的目的。
3. DQPSK的实现 总体框图如下：
在QPSK的基础上添加了差分编码，来减小误码率。差分编码将绝对码转换为相对码。
4、解调部分
低通滤波：滤除高频分量
环路滤波：环路滤波器用于衰减由输入信号噪声引起的快速变化的相位误差和平滑相位检测器泄露的高频分量，即滤波,
载波恢复：采用极性科斯塔斯环来实现，输入信号分别乘上同相和正交两路载波信号，载波信号的频率由环路滤波器的输出来控制。以下为载波恢复：
位定时采用锁相环位同步法来实现：
位同步锁相环的基本原理：在接收端利用鉴相器比较码元和本地产生的位同步信号的相位，若两者相位不一致（超前或者滞后），鉴相器就产生误差信号去调整位同步信号的相位，直至获得准确的位同步信号为止。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41885a3e314f290b77d22947f68fb9a4/" rel="bookmark">
			微信小程序UI组件、开发框架、实用库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UI组件 weui-wxss ★852 - 同微信原生视觉体验一致的基础样式库Wa-UI ★122 - 针对微信小程序整合的一套UI库wx-charts ★105 - 微信小程序图表工具wemark ★85 - 微信小程序Markdown渲染库WeZRender ★36 - 微信小程序Canvas增强组件wetoast ★21 - 仿照微信小程序提供的showToast功能wxapp-charts ★20 - 微信小程序图表charts组件WeiXinProject ★18 - 列表的上拉刷新和上拉加载citySelect ★16 - 微信小程序城市选择器 开发框架 Labrador ★391 - 微信小程序模块化开发框架wepy ★383 - 小程序组件化开发框架wxapp-devFrame ★27 - 小程序基本的开发框架 实用库 wxParse ★412 - 微信小程序富文本解析自定义组件wechat-weapp-redux ★102 - 微信小程序Redux绑定wilddog-weapp ★44 - 野狗微信小程序客户SDKwafer-client-sdk ★40 - 微信小程序客户端腾讯云增强 SDKWxNotificationCenter ★29 - 微信小程序通知广播模式类 开发工具 weapp-ide-crack ★4454 - 微信小程序IDE及破解攻略wept ★799 - 实时微信小程序开发工具weapp-quick ★296 - “微信Web开发者”拷贝工具Wxapp.vim ★155 - 微信小程序开发 Vim 插件Matchmaker ★80 - 专为微信小程序开发的插件wechat_web_devtools ★72 - 微信开发者工具Linux版miniapps ★67 - 小程序项目脚手架工具 服务端 NAMI ★28 - 专为小程序而生的服务端开发容器Wafer 服务端 SDK - Java ★28 - 企业级微信小程序全栈方案m-mall-admin ★26 - 创建REST API的样板应用weapp-php-server-sdk ★23 - 腾讯云微信小程序云端解决方案weapp-node-server-demo ★20 - Wafer 服务端 Demo 其他 wxapp-redux-starter ★58 - 提供方便快捷的微信小程序开发环境 Demo weapp-demo ★727 - 仿豆瓣电影微信小程序wechat-weapp-gank ★537 - Gank微信小程序SmallAppForQQ ★460 - 微信小程序高仿QQ应用wechat-weapp-mall ★430 - 微信小程序移动端商城weapp-wechat-zhihu ★297 - 微信中的知乎wecqupt ★255 - 在微信内被便捷地获取和传播仿芒果TV ★188 - 微信小程序demoweChatApp-Run ★173 - 跑步微信小程序Demowechat-v2ex ★173 - 简单的v2ex微信小程序wechat-weapp-taobao ★153 - 微信小程序demo 仿手机淘宝weapp-weipiao ★141 - 微信小程序-微票wechat-app-zhihudaily ★134 - 微信小程序-知乎日报fenda-mock ★125 - 使用微信小程序实现分答这款APP的基础功能weapp-boilerplate ★112 - 一个为微信小程序开发准备的基础骨架腾讯云微信小程序 ★111 - 一站式解决方案客户端示例wechat_mall_applet ★103 - 巴爷微信商城的简单版本wechat-app-music ★91 - 微信小程序： 音乐播放器wechat-weapp-mapdemo ★76 - 微信小程序开发demo-地图定位m-mall ★67 - 实现一个移动端小商城wechat-weapp-movie ★66 - 微信小程序 - 电影推荐wechat-weapp-redux-todos ★61 - 微信小程序集成Redux实现的Todo listwxapp-socket-io ★61 - 微信小程序的SocketIO客户端weapp-douban-film ★59 - 微信小程序 - 豆瓣电影weapp-demo-session ★58 - 微信小程序示例一笔到底Artand ★55 - 微信小程序wepy-wechat-demo ★54 - wepy仿微信聊天界面weapp-one ★47 - 仿 「ONE · 一个」 的微信小程序BearDiary ★44 - 微信小程序之小熊の日记wechat-chat ★44 - 微信小程序版聊天室wxapp-sCalc ★41 - 微信小程序版简易计算器，适合入门练手wechat-weapp-demo ★41 - 一个简单的微信小程序购物车DEMOwxflex ★38 - 微信小程序的Flex布局demo番茄时钟 ★35 - 番茄时钟微信小程序版weapp-newsapp ★35 - 微信小程序-公众号热门文章信息流wxapp-hiapp ★33 - HiApp 微信小程序版weapp-github ★33 - 微信小程序的简单尝试weapp-girls ★31 - 通过Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41885a3e314f290b77d22947f68fb9a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba508e849c043e658838a366120c8516/" rel="bookmark">
			Python string 去掉标点符号 最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 字符串去掉标点符号最佳实践 方法一： str.isalnum：
S.isalnum() -&gt; bool
Return True if all characters in S are alphanumeric and there is at least one character in S, False otherwise.
&gt;&gt;&gt; string = "Special $#! characters spaces 888323" &gt;&gt;&gt; ''.join(e for e in string if e.isalnum()) 'Specialcharactersspaces888323' 特点：
只能识别字母和数字，杀伤力大，会把中文、空格之类的也干掉 方法二： string.punctuation
import re, string s ="string. With. Punctuation?" # Sample string # 写法一： out = s.translate(string.maketrans("",""), string.punctuation) # 写法二： out = s.translate(None, string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba508e849c043e658838a366120c8516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e4c5275677bdb3bd49b060baf0658e/" rel="bookmark">
			hdu 5890（01背包&#43; bitset 优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eighty seven Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 102400/102400 K (Java/Others)
Total Submission(s): 1605 Accepted Submission(s): 515
Problem Description
Mr. Fib is a mathematics teacher of a primary school. In the next lesson, he is planning to teach children how to add numbers up. Before the class, he will prepare Ncards with numbers. The number on the i-th card is ai. In class, each turn he will remove no more than 3 cards and let students choose any ten cards, the sum of the numbers on which is 87.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e4c5275677bdb3bd49b060baf0658e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d50b481b87041579a98ddb14c55e164/" rel="bookmark">
			区块链-私链创建与智能合约部署实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备：
ECS+ubuntu 16.0+go+go-ethereum
1.创世链节点：
{
"config": { "chainId": 12345, "homesteadBlock":0, "eip155Block":0, "eip158Block":0 }, “coinbase”:”0x0000000000000000000000000000000000000000”,
“difficulty”:”0x400”,
“extraData”:”0x123456”,
“gasLimit”:”0xffffffff”,
“nonce”:”0x0000000000000042”,
“mixhash”:”0x0000000000000000000000000000000000000000000000000000000000000000”, “parentHash”: “0x0000000000000000000000000000000000000000000000000000000000000000”,
“timestamp”:”0x00”,
“alloc”: { }
}
字段讲解：
mixhash：与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊
nonce: nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper,
difficulty: 设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度
alloc: 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。
coinbase: 矿工的账号，随便填
timestamp: 设置创世块的时间戳
parentHash: 上一个区块的hash值，因为是创世块，所以这个值是0
extraData: 附加信息，随便填，可以填你的个性信息，必须为十六进制的偶位字符串
gasLimit: 该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。
2.geth –datadir “./” init genesis.json 建立创世节点
3.geth –datadir “./” –nodiscover console 2&gt;&gt;geth.log 新建私有链，且日志输出到geth.log
4.启动节点 进入控制台：geth –datadir ./ –networkid 314590 –ipcdisable –port 61910 –rpcport 8200 console
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d50b481b87041579a98ddb14c55e164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b10b691e920f47c63c40aa4b4e65b8/" rel="bookmark">
			使用Unicode字符集出现乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MFC中Unicode与ASCII码转换
Unicode码与ASCII码 Unicode码：Unicode码也是一种国际标准编码，采用二个字节编码，与ASCII码不兼容。它前128个字符就是ASCII码，之后是扩展码。
ASCII码：American Standard Code for Information Interchange，美国信息交换标准代码。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。
MFC中工程中的设置字符集 Mfc工程中字符集的设置
在mfc工程属性-&gt;配置属性中-&gt;常规中-&gt;项目默认值-&gt;字符集中，有使用Unicode字符集的设置。
该字符集设置为Unicode字符集后，常用的CString的初始化，格式化接口，需要用到_T宏。此外，在char型数组转化为CString中，常常有乱码出现。下面总结一下，出现乱码后的解决方法。
当字符集设置成”使用多字节字符集”时，
将CString转化成char型数据指针:
CString file;
char* pFile = (LPSTR)(LPCSTR)file;
将char型数据转化为CString，不需要添加_T宏:
CString info;
char version[20];
info.AppendFormat("ldmp Sn: [%s] ..", version);
当字符集设置成”使用Unicode字符集”时,
CString与char型数据相互转化如下：
void CStringToChar(CString str,char *dst)
{
#ifdef _UNICODE
wchar_t *wChar = str.GetBuffer(str.GetLength());
str.ReleaseBuffer();
// 将得到的wchar* 类型转为 char*类型
size_t len = wcslen(wChar) + 1;
size_t converted = 0;
char *cChar;
cChar = (char*)malloc(len * sizeof(char));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18b10b691e920f47c63c40aa4b4e65b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c3bc87505c1d888fd4d35df4f0da76/" rel="bookmark">
			代码优化方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，优化算法时间复杂度：
算法时间复杂度对程序的执行效率影响最大，通过选择合适的数据结构优化时间算法复杂度，不同场合不同的哟欧华方式，异步有分治，分治界限，贪心，动态规划等思想
2，减少冗余数据
上三角或者下三角的方式去保存一个大的对称矩阵， 稀疏矩阵。
3，合理使用copy和deepcopy
dict和list数据结构的对象，直接赋予引用，不需要复制整个对象，可以使用copy和deepcopy，不同之处在与后者是递归复制的效率不同
4，使用dictionary和set查找元素 hash类型数据 dicti效率高
5，合理使用生成器和yield
6，优化循环
7，优化包含多个判断表达式的顺序
8，使用join合并迭代器中的字符串
9，选择合适的格式化字符方式
10，不借助中间变量交换两个字符
11，使用if is 而不是 if ==
12，使用联级比较 x&lt;y&lt;z
13，while 1 比while True快 python2中True是全局变量而不是关键字
14，使用** 而不是pow 10倍
15，使用cProfile,cStringIO 和cPickle等用c实现的相同功能 profile StringIOn pickle
16，使用最佳的反序列化方式
17，使用C扩展 cpython
18，并行编程 多线程CPU密集型程序 多进程IO秘籍型程序 分布式 multiprocessing
19，终级大杀器：PYPY
20，使用性能分析工具
python -m cProfile filename.py，filename.py 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。
详情可以参考：http://python.jobbole.com/81956/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1871179cdcdf404aad989476644e4978/" rel="bookmark">
			CSS中关于滚动条样式设置的代码实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为在模拟开发冒险岛2游戏官网的时候,遇到一个关于滚动条样式设置的问题,如果我们不设置滚动条的样式,那么如下图所示:(特别丑陋)
但是在冒险岛的官网上呈现的样式却是:
明显感觉到视觉上的不同,那么现在我们就来设置滚动条的样式: 在所有浏览器，滚动条可定制性最强的当属webkit内核的浏览器了。因为源代码开放的原因，市面上基于webkit内核的浏览器也是很难穷举完。例如有：Google Chrome、Opera（opera最近宣布使用webkit内核了）、360极速浏览器，猎豹浏览器等，搜狗浏览器······
下面我们来看一下webkit浏览器是如何强大的吧！首先来了解它的属性:
滚动条的设置 1. ::-webkit-scrollbar 滚动条整体部分，可以设置宽度等 2. ::-webkit-scrollbar-button 滚动条两端的按钮 3. ::-webkit-scrollbar-track 外层轨道 4. ::-webkit-scrollbar-track-piece 内层滚动槽 5. ::-webkit-scrollbar-thumb 滚动的滑块 6. ::-webkit-scrollbar-corner 边角 7. ::-webkit-resizer 定义右下角拖动块的样式 ::-webkit-scrollbar ：滚动条整体部分，其中的属性: width,height,background,border等。
::-webkit-scrollbar-button ：滚动条两端的按钮。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。
::-webkit-scrollbar-track ：外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。
::-webkit-scrollbar-track-piece ：内层轨道，具体区别看下面gif图，需要注意的就是它会覆盖第三个属性的样式。
::-webkit-scrollbar-thumb ：滚动条里面可以拖动的那部分
::-webkit-scrollbar-corner ：边角，两个滚动条交汇处
::-webkit-resizer ：两个滚动条交汇处用于拖动调整元素大小的小控件（基本用不上）
下面举一个简单的例子来说明:
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;style&gt; div { width: 100px; height: 300px; border: 2px solid red; overflow-x: scroll; overflow-y: scroll; } /* 设置滚动条的样式 */ ::-webkit-scrollbar { width:12px; background-color: aqua; } /* 滚动槽 */ ::-webkit-scrollbar-track { border-radius:10px; } /* 滚动条滑块 */ ::-webkit-scrollbar-thumb { border-radius:10px; background:black; } &lt;/style&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1871179cdcdf404aad989476644e4978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a141b8939370acd695e8edf99953e8/" rel="bookmark">
			01背包问题-——饭卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDU- 2546 电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。 某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。 Input 多组数据。对于每组数据： 第一行为正整数n，表示菜的数量。n&lt;=1000。 第二行包括n个正整数，表示每种菜的价格。价格不超过50。 第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。 n=0表示数据结束。 Output 对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。 Sample Input 1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0 Sample Output -45 32 分析：这个题是01背包问题，只不过加了个限制条件，要换个角度想，既然要&gt;=5块才能买东西，那就先把&lt;5块的分个类，直接输出就行；&gt;= 5块的，假设金额为m，可以先求m-5的可以买的最大值，使它尽可能接近5，还要先把最贵的那个菜留下来，到最后的时候用m-5剩下钱的+5然后减去这个菜就行了。
#include&lt;stdio.h&gt; #include&lt;algorithm&gt; #include&lt;string.h&gt; using namespace std; int dp[1010],w[1010]; int main() { int n,i,j; while(~scanf("%d",&amp;n) &amp;&amp; n) { memset(dp,0,sizeof(dp)); for(i = 0;i &lt; n; i++) scanf("%d",&amp;w[i]); int m; scanf("%d",&amp;m); if(m &lt; 5){ printf("%d\n",m); continue; } sort(w,w+n); int s = m-5; for(i = 0;i &lt; n-1; i++) for(j = s;j &gt;= w[i]; j--) dp[j]=max(dp[j],dp[j-w[i]]+w[i]); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a141b8939370acd695e8edf99953e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af920fa70733ca99e6af8637c45f5af/" rel="bookmark">
			bundlefusion之环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bundlefusioin可以说是目前3D重建方面，做的非常优秀的一个开源算法，很值得学习一下。这篇博客 简要说明的还阔以，给个链接：https://blog.csdn.net/fuxingyin/article/details/52921958
写在文章前：
在这个重建方面，我还只是个菜鸡，所以有错误请勿喷。如果给您提供了帮助，请各位留言“作者大大真帅”，如果有疑问，请留言“菜鸡作者，XXXXXXXX（你的问题）”
bundlefusion环境配置时，github上给的说明还挺详细的，照着做慢慢来总会配通的。。
下面是我的配置过程，以及已经修改过后的工程。
工程链接见右========&gt;(mmp，csdn资源上传有限制，下面的东东，各位就借鉴借鉴吧)
哈哈哈哈哈哈哈，想要看我的配置过程？不存在的，too young too simple！
好吧配置过程和github上没有差别，各位还是去看正版的吧，我就不抄作业了，下面是根据我遇到的一些小坑写的总结，各位看看笑笑即可
It`s important!!!!!
It`s important!!!!!
It`s important!!!!!
重要事情说三遍
1.务必使用vs2013来编译。。。。
不然的话mLib库需要你自己重新编译，还有一系列问题，具体问题请谷歌
2.cuda版本为8.0
不是的话，请按照vs的提示修改，百度一下你就知道
3.在工程里，你要重新配置openNI2的路径
4.不同的传感器使用，需要修改代码(默认的是kinect，忘了1代还是2代了)
修改部分一个在GlobalAppState.h下，另一个在zParametersDefault.txt下，两个都要改
At the end：
我的环境配置是：win10，cuda8.0, vs2013, RGBD传感器用的华硕的prime sensor
(所以是通过openni来获取的，如果你的是kinect的话，可以使用kinect sdk来获取，这个配置下环境就好，很简单；
如果你是orbbec的传感器的话，那么要修改下代码，通过opencv来获取图像)
如果你是按照我的环境要求来的话，那么只需要做两步，只要两步：
1）安装DirectX的驱动，这个安装包里提供了，如果已经安装过，请忽略
2）在工程中重新定义一下你的openni2路径，编译应该就没问题了。
but，orbbec的传感器请记得使用“官翻”的openni，并将openni2的某一些文件(自己看openni/readme)拷贝到可执行文件目录下！！！！
转载请说明来处，谢谢~
best wishes，
超
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7249684d1dddf4a4584fcf54d3c84665/" rel="bookmark">
			Unity XLua Hotfix热更新配置笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity XLUA Hotfix热更新配置笔记 目录 Unity XLUA Hotfix热更新配置笔记
配置热更新步骤：
下载XLUA下载压缩包解压 复制xlua 和plugins到assets开启热补丁特性 先添加宏 HOTFIX_ENABLE;INJECT_WITHOUT_TOOL报“This delegate/interface must add to CSharpCallLua : XXX”异常怎么解决？.require XXX 调用Lua脚本 具体脚本参考官方文档 lua文件放在Resources下Tips： 下载XLua 传送门 官网：
https://github.com/Tencent/xLua
配置文档：
https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/hotfix.md
官方FAQ：
https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/faq.md
代码生成引擎：
https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/custom_generate.md
Lua5.3官方手册：
https://www.lua.org/manual/5.3/manual.html
下载压缩包解压 复制XLua和plugins到assets，Tool复制在Assets同级目录下 开启热补丁特性 先添加宏 HOTFIX_ENABLE;INJECT_WITHOUT_TOOL 注意：两个宏都要添加（），官方FAQ说
报“This delegate/interface must add to CSharpCallLua : XXX”异常怎么解决？ 在编辑器下xLua不生成代码都可以运行，出现这种提示，要么是该类型没加CSharpCallLua，要么是加之前生成过代码，没重新执行生成。
解决办法，确认XXX（类型名）加上CSharpCallLua后，清除代码后运行。
如果编辑器下没问题，发布到手机报这错，表示你发布前没生成代码（执行“XLua/Generate Code”）。
亲测两个宏都必须要加
HOTFIX_ENABLE：开启热更新特性，编辑器，各手机平台需要手动单独设置，如果是自动化打包，要注意在代码里用API设置的宏是不生效的，需要在编辑器里设置。
INJECT_WITHOUT_TOOL：采用内嵌到编辑器的方式注入。添加了该宏之后，在菜单栏XLUA里才能够进行【Hotfix inject in Editor】的操作；在构建手机包的时候这个步骤会在构建时自动进行，编辑器模式下开发补丁需要手动执行Hotfix inject in Editor进行注入。
定义INJECT_WITHOUT_TOOL宏后，热补丁特性依赖Cecil，添加HOTFIX_ENABLE宏之后，可能会报找不到Cecil。这时你需要到Unity安装目录下找到Mono.Cecil.dll，Mono.Cecil.Pdb.dll，Mono.Cecil.Mdb.dll，拷贝到项目里头。
注意：如果你的Unity安装目录没有Mono.Cecil.Pdb.dll，Mono.Cecil.Mdb.dll（往往是一些老版本），那就只拷贝Mono.Cecil.dll（你从别的版本的Unity拷贝一套可能会导致编辑器不稳定），这时你需要定义HOTFIX_SYMBOLS_DISABLE，
这会导致C#代码没法调试以及Log的栈源文件及行号错乱（所以赶紧升级Unity）。
以上两个宏若是不开启，或者在没有成功进行Hotfix inject in Editor操作直接运行的话，系统会抛出 LuaException: xlua.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7249684d1dddf4a4584fcf54d3c84665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401ba1718abb4331cbbae7bc5cc440ea/" rel="bookmark">
			构造函数中为什么不能调用虚函数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构造函数中为什么不能调用虚函数？ 构造函数调用层次会导致一个有趣的两难选择。试想：如果我们在构造函数中并且调用了虚函数，那么会发生什么现象呢？在普通的成员函数中，我们可以想象所发生的情况——虚函数的调用是在运行时决定的。这是因为编译时这个对象并不能知道它是属于这个成员函数所在的那个类，还是属于由它派生出来的某个类。于是，我们也许会认为在构造函数中也会发生同样的事情。
然而，情况并非如此。对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。
这种行为有两个理由：
第一个理由是概念上的。
在概念上，构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象——我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员，这将导致灾难发生。
第二个理由是机械上的。
当一个构造函数被调用时，它做的首要的事情之一就是初始化它的VPTR。然而，它只能知道它属于“当前”类——即构造函数所在的类。于是它完全不知道这个对象是否是基于其它类。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE。但如果接着还有一个更晚派生类的构造函数被调用，那么这个构造函数又将设置VPTR指向它的VTABLE，以此类推，直到最后的构造函数结束。VRTP的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是按照从基类到最晚派生类的顺序的另一个理由。
但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置VPTR指向它自己的VTABLE。如果函数调用使用虚机制，它将只产生通过它自己的VTABLE的调用，而不是最后派生的VTABLE（所有构造函数被调用后才会有最后派生的VTABLE）。另外，许多编译器认识到，如果在构造函数中进行虚函数调用，应该使用早绑定，因为它们知道晚绑定将只对本地函数产生调用。无论哪种情况，在构造函数中调用虚函数都不能得到预期的结果。
——来自《C++编程思想》合订本第386页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776a699dff0975b9aff64a5f683ed496/" rel="bookmark">
			Java instanceof用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。
instanceof instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。
这里说明下：
类的实例包含本身的实例，以及所有直接或间接子类的实例
instanceof左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误
instanceof用法 左边的对象实例不能是基础数据类型 左边的对象实例和右边的类不在同一个继承树上 null用instanceof跟任何类型比较时都是false 代码示例：
public interface A { } public class B implements A{ } public class C extends B{ } 测试代码示例：
public class InstanceofTest3 { public static void main(String[] args) { A a = null; B b = null; boolean result; result = a instanceof A; System.out.println(result); // 结果：false null用instanceof跟任何类型比较时都是false result = b instanceof B; System.out.println(result); // 结果：false null用instanceof跟任何类型比较时都是false a = new B(); b = new B(); result = a instanceof A; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776a699dff0975b9aff64a5f683ed496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a4a46ffcd02f943c254f8e30ac5f59/" rel="bookmark">
			JS   鼠标事件onmouseover：鼠标移到某元素之上;onmouseout：鼠标从某元素移开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload=function(){ var img=document.getElementsByTagName("img")[0]; img.onmouseover=function(){ document.getElementById("msg").innerHTML="over..."; } img.onmouseout=function(){ document.getElementById("msg").innerHTML="out..."; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="image/ad-03.jpg" /&gt; &lt;div id="msg"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f516954ac9b566ac0495a81b02aef1/" rel="bookmark">
			python正则表达式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言正则表达式是一个特殊的字符序列，用来判断一个字符串与我们所设定的字符序列是否相匹配。实现快速检索文本和一些替换文本的操作。 在Python中我们有专门的正则表达式模块re，re 模块使 Python 语言拥有全部的正则表达式功能。compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。
一.常见函数 1.re.match re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 *函数语法：*re.match(pattern, string, flags=0) 函数参数说明： pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.match方法返回一个匹配的对象，否则返回None。
可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 例：
import re re.match(r'l','liuyan1').group() #返回l re.match(r'y','liuyan1') #返回None 2.re.search re.search 扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(pattern, string, flags=0) 函数参数说明： pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.search方法返回一个匹配的对象，否则返回None。 例：
import re re.search(r'y','liuyan1').group() #返回y 3.re.findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。(注意： match 和 search 是匹配一次 findall 匹配所有) 函数语法： findall(string[, pos[, endpos]]) 参数： string 待匹配的字符串。 pos 可选参数，指定字符串的起始位置，默认为 0。 endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 例： import re a='C55C++66Java77C#88Python99Javascript' print(re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9f516954ac9b566ac0495a81b02aef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3c71b63fc913f312e1b232635532ce/" rel="bookmark">
			Spring Boot WebMvcConfigurerAdapter已过时的解决办法和一些坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 2.0.4.RELEASE中WebMvcConfigurerAdapter已过时，百度上好多解决办法，但大多雷同，且有些还存在一定的误导性，可能导致最终的配置无效，不起作用。
百度后我查到的解决方案这样的 两种方法，并且都还强烈推荐第二种方法 // 方法一：实现WebMvcConfigurer接口 public class WebConfig implements WebMvcConfigurer{ // ... } // 方法二：继承WebMvcConfigurationSupport类 public class WebConfig extends WebMvcConfigurationSupport{ // ... } 于是就直接用了第二种方法，写完跑了项目发现没啥效果，打日志也出不来。然后又改回第一种方法，果然，有效果了。
其实机智的人可能早就发现了，过时的这个只不过是个适配器（适配器模式），那就可以直接使用它所实现的那个接口啊，就是WebMvcConfigurer呗。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0474fd9bbc70e591ff9c18d8536ba3/" rel="bookmark">
			RichTextBox获取当前行、列，统计行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 此代码根据网上代码更改
//当前光标所在位置 //当前行的索引 int index = this.richTxt.GetFirstCharIndexOfCurrentLine(); //共有行数 int intLines = this.richTxt.GetLineFromCharIndex(this.richTxt.TextLength) + 1; //得到光标的行号 int line = this.richTxt.GetLineFromCharIndex(index) + 1; //得到光标列的索引 /*SelectionStart得到光标所在位置的索引 再减去 当前行第一个字符的索引 = 光标所在的列数(从0开始） */ int column = this.richTxt.SelectionStart - index + 1; //this.richTxt.Paste(Clipboard.GetDataObject()); this.toolStripStatusLabel_Row.Text = string.Format("第{0}行{1}列,共{2}行", line.ToString(), column.ToString(), intLines.ToString()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873a4db1a2c8c0770e3ada59c08b5544/" rel="bookmark">
			关于各种网站音频mp3的外链地址，真实的外链播放地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来一个醒目的大标题，入了一下午的坑，总算找到了； 首先，是我最喜欢的网易云音乐 第一步，百度找到您想要的音乐 打开后台调试，依次点击network 和 xhr，然后刷新页面，出现第三个红框里面的内容，点击，出现右侧数据，最下面红框里就是这个音频真实的外链地址了 代码 &lt;audio id="bgMusic" loop="loop" preload="preload" autoplay="autoplay"&gt; &lt;source src="http://m10.music.126.net/20180809173001/070d716213a3cf7cb910b5b88b638eb8/ymusic/687c/a444/e9e3/66452e1efb0e3f108d6b899010c13ba8.mp3" type="audio/mp3"&gt; &lt;/audio&gt; 第二个，是酷我音乐mp3外链地址 第一步：找到酷我音乐网站上的您需要的音频页面 可以看到地址栏里面的最后一串数字，这是当前这首歌的id，然后将该数字串拼接到 http://player.kuwo.cn/webmusic/st/getNewMuiseByRid?rid=MUSIC_后面，即 http://player.kuwo.cn/webmusic/st/getNewMuiseByRid?rid=MUSIC_24165853出现的是该音频的xml信息 找到mp3path（音频尾部地址）和mp3dl（音频头部地址）打开新组建的网址，http://+音频头部地址+/resource/+音频尾部地址，如下： http://other.web.ri01.sycdn.kuwo.cn/resource/n2/96/19/2142954236.mp3 这就是该音频的真实外链地址喽 哈哈，学会了吗？其实我又发现了一个网址，点开直接搜索你想要打的音频，就可以获得你想要的网址，都是专业的音乐平台的地址哦，放心用；传送门http://music.liuzhijin.cn/点我 感谢刘志进实验室，应该不算侵权吧
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/282/">«</a>
	<span class="pagination__item pagination__item--current">283/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/284/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>