<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27bcbec6b3378c2e27fb30a1a96b896/" rel="bookmark">
			《由浅入深学Java》视频课程更新啦！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几年，穆哥学堂为零基础学员量身打造了一门Java语言的教学视频课程《由浅入深学Java》，这门课程受到了广大学员的喜爱。该课程总共分为三大板块，分别是：《零基础学Java》、《零基础学Java习题精讲》和《Java高级语法》。
《零基础学Java》的目标是带领零基础的学员学会Java语言的最基本语法，达到快速入门的目的。该课程主要讲解Java基本常识、Java基础语法、面向对象思想及相关语法细节，以及异常的概念和处理方法。
学员掌握了基础语法之后，紧接着做的事情就是夯实理论基础以及提高实战能力。第二板块《零基础学Java习题精讲》就是为此目标而精心设计的。该课程分为两部分，分别是《选择问答篇》和《编程篇》。《选择问答篇》中精选了很多有代表性的题目，帮助学员进一步理解Java语法细节，并扫除那些掌握不扎实的知识漏洞。《编程篇》则精选了几十个经典编程题，帮助学员提升逻辑思维能力和解决问题的实战能力！
第三板块《Java高级语法》是Java语法的进阶课程。主要讲解Java语言的高级语法：如位运算符、内部类、泛型、Lambda表达式等知识点。
课程虽然受到了广大学员的喜爱，但随着时代的发展以及Java技术的不断进步，原有的课程逐渐有点过时了，为了能够使课程能够适应时代，穆哥学堂近期重新对第一个板块的内容进行了重新录制，此次录制采用目前流行的JDK17和IntelliJ IDEA作为开发环境，并引入和很多新的知识点，如switch表达式、密封类、Java8新型接口等内容，同时更新了课件和源代码。其他两个板块也会在近期内更新。希望小伙伴们能够一如既往的支持穆哥学堂！
课程传送门如下：
由浅入深学Java
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a520a3122eaddf82e3a3b0e92ac89bdc/" rel="bookmark">
			vue高德天气接口，加上自定义天气图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web端使用高德api获取天气 先获取城市，再通过城市获取天气
1.登录https://lbs.amap.com/，控制台-&gt;应用管理-&gt;我的应用-&gt;创建应用-&gt;添加key
*切记选择web端(JS API)
2.在index.html中 引入高德地图的css和js
&lt;!-- 高德地图js插件--&gt;
&lt;script type="text/javascript"&gt;
window._AMapSecurityConfig = {
securityJsCode: '安全密钥jscode',
}
&lt;/script&gt;
&lt;script type="text/javascript"
src="https://webapi.amap.com/maps?v=1.4.15&amp;key=key值&amp;plugin=AMap.DistrictSearch,AMap.Geocoder,AMap.DistrictLayer,AMap.AutoComplete,AMap.PlaceSearch"&gt;
&lt;/script&gt;
3.在页面调用高德天气接口
&lt;div class="date"&gt;{{reportTime}}&lt;/div&gt;
&lt;div class="weather"&gt;
&lt;span class="weather-pic"&gt;&lt;img :src="imgUrl"&gt;&lt;/span&gt;
&lt;span&gt;{{weather}}&lt;/span&gt;
&lt;span&gt;{{temperature}}°C&lt;/span&gt;
&lt;/div&gt;
data(){
return{
weatherList: [
{ id: 1, name: "大雪", url: require("@/assets/icon/01.png") },
{ id: 2, name: "大雨", url: require("@/assets/icon/02.png") },
{ id: 3, name: "小雪", url: require("@/assets/icon/03.png") },
{ id: 4, name: "小雨", url: require("@/assets/icon/04.png") },
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a520a3122eaddf82e3a3b0e92ac89bdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df02ea2f97f6dd4b80eec92a61ec7297/" rel="bookmark">
			软考押题策略揭秘：这些题目最容易被考！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软考马上就要考试啦！各科目考前最常考的题目整理完毕！如图！
考前冲刺重点：
选择题：
1.考前冲刺必做真题（不仅仅要选对，还要理解记忆背后考的大知识点）
2.考前重点总结资料，每天早上看看，尽可能的读熟重点。
案例分析：
1.十大管理的知识点（过程、输入、输出、工具）→结合口诀背
2.给出一段案例，分析不规范的地方 → 案例万金油&amp;；十大管理
3.计算题 进度、网络、挣值分析、预测技术 →把题目书上所有相关真题刷一遍，确保都会做
论文：
1.一定要动手写2篇以上论文，防止临场现编
2.准备好模板 背景→过渡→某一项管理的过程、输入、输出→总结
3.背景最好是自己参加过的真实项目，内容也不要天马星空，压着考点写（预算、工期、组织结构等）
最重要是子题目，一般是考察某项管理的一个细节，这也是防止有人上来就套已经准备好的论文，这样肯定是不过的~ 我的思路是：定位子题目所在的某个过程，按照题目要求在这个过程中回答，不包含子题目的其他过程就随便写，凑字数即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0b56dd1553872fd896226b92c2c33a/" rel="bookmark">
			关于使用Echarts进行数组遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不多说，直接挂代码
draw_pieChart() { var pieChart = echarts.init(this.$refs.pieChart); var resArray = []; axios .get( "https://mock.mengxuegu.com/mock/642f630132affa39a121cd8d/example/CtssProAnalysis" ) .then((res) =&gt; { for (var i = 0; i &lt; res.data.data.length; i++) { resArray.push({ value: res.data.data[i].issueNum, name: res.data.data[i].projectName, }); } console.log(resArray); //软件品牌月度问题统计..饼图 let pieOption = { title: { text: "软件品牌月度问题统计", left: "center", top: "10%", }, tooltip: { trigger: "item", }, legend: { orient: "horizontal", bottom: "left", }, series: [ { type: "pie", radius: "50%", data: resArray, emphasis: { itemStyle: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f0b56dd1553872fd896226b92c2c33a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248e6bd4ab8584542861a65697fe66f9/" rel="bookmark">
			头歌平台python数据分析——（9）Matplotlib图形配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：配置颜色条 ，根据输入数据绘制热成像图并隐藏坐标轴，具体要求如下：
图形的figsize为(10, 10)；
图形保存到Task1/img/T1.png。
第2关：设置注释 根据函数参数file_name读取文件，统计每年births的总和并作折线图，为最高/最低出生数年份设置注释，具体要求如下：
对数据进行去空值处理；
注释文字的坐标位置为被注释的坐标点减5；
折线图的figsize为(10, 10)；
图形需保存到Task2/img2/T5.png。
第3关：自定义坐标刻度 根据file_path读取文件，统计不同二级类的数量做折线图并旋转x坐标轴90度，具体要求如下：
图形的figsize为(10, 10)；
图形需保存到Task3/img/T1.png。
数据内容如下：
第4关：配置文件与样式表 根据输入数据绘制直方图调整直方图颜色为红色透明度0.7为，并设置组合样式classic和bmh，具体要求如下：
折线图的figsize为(10, 10)
图形需保存到Task4/img/T1.png
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f0181f2c9b31cad2734a1285c94862/" rel="bookmark">
			头歌平台python数据分析——（6）数据清洗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：数据去重 利用pandas将‘basketball.csv’中的数据导入名为dataset的DataFrame对象中，并使用drop_duplicates()函数对dataset中的Date列进行去重，不保留副本。将去重结果dealed和dataset返回。
第2关：处理空值 在收集数据的过程中，可能会有一些空行或空项。有空值的数据不经过处理，通常是不可以直接使用的。本关卡将使用pandas查找数据集中的空值，并对空值进行处理。
在本关卡中，我们为你提供了一个鸢尾花的数据集。数据集总共有五个字段，分别是：
sepal.length
sepal.width
petal.length
petal.width
variety
除了variety字段内容是字符串外，其他字段的内容均是浮点数。你要完成的任务包括：
找出每项字段中各有多少空值，并按上文给出的字段顺序打印出来。
前四项字段的空值，各用该空值所在列的均值填充。
第五项字段的空值，统一填充为’Unknown’.
处理均值后的数据命名为dealed_data，并返回
注：pandas中均值的计算可以使用means()函数。示例：data[‘a’].means()的结果就是a字段的均值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f01487217148011d2be9787565d3a944/" rel="bookmark">
			升级xcode14.3打包报错 Command PhaseScriptExecution failed with a nonzero exit code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级了xcode14.3，在打包工程后出现报错：
rsync error: some files could not be transferred (code 23) at …/rsync/main.c(996)
Command PhaseScriptExecution failed with a nonzero exit code
解决方案：
在Xcode项目目录中进入 Pods -&gt; Targets Support Files -&gt; Pods-项目名 -&gt; Pods-项目名-frameworks.sh 中搜索source="$(readlink "${source}")"，找到后将其替换为source="$(readlink -f "${source}")"，然后重新进行打包操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0fda5b6bf281882202eefb5242908e1/" rel="bookmark">
			数字设计小思 - 谈谈复位那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本系列整理数字系统设计的相关知识体系架构，为了方便后续自己查阅与求职准备。在FPGA和ASIC设计中，对于复位这个问题可以算是老生常谈了，但是也是最容易忽略的点。本文结合FPGA的相关示例，再谈一谈复位。
（本文长度约六千字，请耐心阅读，本人水平有限，如有纰漏与错误，欢迎留言讨论）
复位的用途 复位信号几乎是除了时钟信号外最常用的信号了，几乎所有数字系统在上电的时候都会进行复位，这样才能保持设计者确定该系统的系统模式的状态，以便于更好的进行电子设计，并且在任意时刻，确保使用者总能对电路系统进行复位，使电路从初始的状态开始工作。
总结下来用途如下：
使电路在仿真时具有可知的初始值 ：通常在仿真时未给入初试状态又未经复位，那么这段代码的初始值是不定态，会经常会出现X或者Z，也就未知态。使实际电路在复位后从确定的初始状态开始运行 ：在数字系统中，很多电路都要求从给定的初始状态上开始运行，避免电路工作于不可预知的状态，并因此导致异常或者致命的故障。使电路在陷入异常状态时能通过复位回到可控的初始状态 ：通常一个设计者无法保证所设计的数字逻辑电路在任何情况下都不会发生异常或者出现故障，假如电路无法自己返回正常状态，可以使用复位电路，强制使电路从初始状态开始工作。 尽管复位极为重要，但是复位电路在设计中是最常忽视的方面。一个不正确设计的复位本身可以表现为一个不可重复的逻辑错误。
复位电平的选择 有关复位电平，实际上是与FPGA芯片内部的触发器结构有关，在之前的博文有提到过。作为xilinx 7系列触发器，其 R 端口既可用作同步置位/复位端口，也可用作异步预设/清除端口，但无论哪种方式，都是高电平有效。Altera的是低电平有效。
如果RTL代码采用了低电平有效的复位模式，综合器将在复位信号驱动寄存器SR控制端之前的插入一个反相器（interver）。你必须使用一个查找表（look up table）来实现反向器，以利用LUT的输入端口。低电平有效的控制信号带来的额外的逻辑可能拉长了执行时间（runtime），将导致更低的FPGA资源利用率，也将影响时序和功耗。
同步复位 同步低复位 同步低复位的代码如下：
module reset( input clk, input rst, input [1:0] in, output reg [1:0] out ); always @ (posedge clk) begin if (rst == 'b0) out &lt;= 'd0 ; else out &lt;= in ; end endmodule 在使用vivado RTL 分析对应的电路结构如下：
使用vivado综合后结构如下：
由于xilinx的器件结构中的触发器为高复位，所以会引入LUT实现复位信号的功能，引入额外的逻辑资源。
同步高复位 同步高复位的代码如下：
module reset( input clk, input rst, input [1:0] in, output reg [1:0] out ); always @ (posedge clk) begin if (rst == 'b1) out &lt;= 'd0 ; else out &lt;= in ; end endmodule 在使用vivado RTL 分析对应的电路结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0fda5b6bf281882202eefb5242908e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b64d9f46ae407bd2e20ce2b901f8a5/" rel="bookmark">
			xshell传输文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装一款lrzsz工具，命令如下 yum install lrzsz -y 检查是否安装成功： rpm -qa | grep lrzsz 上传文件的执行命令： # 输入rz回车，会弹出一个文件对话框，选择文件，确定就可以上传到当前所在目录 rz # 如果想覆盖文件，使用如下命令 rz -y 下载文件 # 输入如下命令，会弹出本地保存文件对话框 sz 文件 Alt+P打开属性框 ● 打开文件传输，这里可以调整传输的一些属性
● 下载文件，可以执行下载目录，下载文件时就不会再询问
● 上传文件，可以直接拖动文件到Xshell上传，很方便
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4fd227f0fd7af51d3fa6a80a947c9e1/" rel="bookmark">
			centOS7忘记登录密码该如何重新修改登录密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、重新修改登录密码1.1、第一步1.2、第二步1.3、第三步1.4、第四步1.5、第五步1.6、第六步1.7、第七步1.8、第八步 前言 忘记密码并不可怕，只要学会方法，密码随时都可以找回。
一、重新修改登录密码 1.1、第一步 当打开centOS7之后忘记了登录密码时，第一步重启该虚拟机，然后一直按 e。准确来说因该是在进入系统时迅速按e（进入系统的画面如下图所示）。但是可能有一部分人反应不过来，所以可以选择在重启之后就开始一直按e。
1.2、第二步 如果在第一步你及时按下了e则会进入编辑界面，如下图所示。然后按向下箭头找到linux16开头的那一段，并且在这一段的结尾加上init=/bin/sh（友情提示：在加上这个命令之前别忘了敲一个空格）
1.3、第三步 在完成第二步之后，按下Ctrl+x进入单用户模式。 1.4、第四步 输入 mount -o remount, rw /。再啰嗦一下，该有的空格别忘了。
1.5、第五步 输入 “passwd + 用户名 ” 回车（修改root的话只输入passwd即可）例如： #假如你的用户名时是zhangsan passwd zhangsan #如果是root passwd root 或者 passwd 输入之后如果出现下面页面所出现的乱码，则首先一直按回车，直至重新出现sh-4.2#，然后输入LANG=en。
输入之后，在重新输入passwd + 用户名，则进入下图。然后在对应的位置输入自己重新设置的密码。
1.6、第六步 输入 touch /.autorelable，然后回车。（如果你在按下回车之后提示你.autorelable文件是一个only-read文件，不用理，接着执行第七步即可）。
1.7、第七步 输入 exec /sbin/init，重启centOS 。这一步可能比较慢，耐心等待即可。
1.8、第八步 输入你新改的密码，重新登录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7e0e54e4dbe2854f78e3e2694d6dee/" rel="bookmark">
			仿牛客论坛项目总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.数据库中每一张表有哪些字段
user表 用户表
（1）id 用户的id （2） username 用户名 （3）password 密码 （4）salt 盐 （5）emai邮箱
（6）type 类型 （7）status 状态 （8）activationCode 激活码 （9）headerUrl 头像存放路径
（10） createTime 创建时间
discuss_post 帖子表
（1）id 每一个帖子的id
（2）user_id 记录这个帖子由哪个用户发布的，记录这个用户的id，显然，这个字段是可以用来和user表进行关联的
（3）title 帖子的标题
（4）content 帖子的内容，由于帖子的内容比较长，所以这个字段的数据类型是text类型
（5）type 帖子的类型，0表示这是一个普通帖子，1表示这是一个置顶帖子
（6）status 帖子的状态，0表示这是一个正常的帖子，1表示是精华帖，2表示被拉黑了
（7）create_time 帖子的创建时间 数据类型是timestamp
（8）comment_count表示这个帖子的评论的数量
（9）score 帖子的分数，用来给帖子进行排名用的
comment评论表
（1）id 主键
（2）user_id 是谁评论的
（3）entity_type 对谁进行评论（比如说1代表对帖子进行评论 2代表对帖子评论进行评论）
（4）entity_id 对谁进行评论的id，比如对帖子A进行评论，那就是帖子A的主键ID
（5）content 评论的具体内容
（6）status 状态0表示正常，状态1表示不可用
（7）create_time 创建时间
login_ticket 登录凭证表
（1）id主键字段
（2）user_id 表明这一行是哪个用户的登录凭证
（3）ticket凭证 一个随机字符串，作为唯一标识
（4）status 状态，凭证是否有效，0表示正常，1表示无效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7e0e54e4dbe2854f78e3e2694d6dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d87b2c47656929ddf2b651897e76bd2/" rel="bookmark">
			阿里云配置ssl证书（阿里云 ssl证书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本篇文章给大家谈谈阿里云配置ssl证书，以及阿里云 ssl证书对应的知识点，希望对各位有所帮助，不要忘了收藏本站喔。
本文目录一览： 1、在阿里云购买的域名如何添加ssl证书2、阿里云ECS云服务器怎么安装配置SSL证书3、后台配置完SSL之后部分接口数据量大之后无响应 在阿里云购买的域名如何添加ssl证书 SSL证咐改书是安装到服务器的，并不是安装在域名上面。
具体添加SSL证书方法：
确定需要SSL证书的域名，然后进入Gworg拿到SSL证书淘宝里面可以直衡盯判接找到。
根据Gworg要求进入域名注册商添加解析认证。
获得SSL证书，并且安装到服务器，如果不会安装可以根据教程或者让Gworg安装。
快速解决办法：Gworg拿到则戚15分钟左右拿到SSL证书，服务器不支持安装的让Gworg做接入。
阿里云ECS云服务器怎么安装配置SSL证书 Gworg申请SSL证书茄羡后根据以下高缓文档配置。
SSL证戚纳模书安装教程阿里云配置ssl证书：
后台配置完SSL之后部分接口数据量大之后无响应 阿里云配置ssl证书常见碰到几个问题：
1、SSL证书安装完毕后浏览器无法访问。解决方案：登陆阿里云控制面板、云安全规则设置：允许443端口。
2、SSL证书安装完毕后显示证书不信任。解决方案：可能由于网站启用了CDN，如果启动了，需要去支持SSL证书的CDN提供商安装。如果没有启用CDN，但是也是不信任的情况下，需要您重新安装启稿证书，查看域名是否直接解析到自己的服务器IP，如果没有需要重新解析到自己的服务器，证书安装到哪台服务器，服务器就需要解析到哪里。
3、SSL证书安装完毕后发现部分浏览器无法访问或不信任。解决方案历旁纤：说明您的SSL证书不信任，可以联系您肢仿的签发机构重新办理与检测SSL是否全面，如果不全需要SSL证书重新签发，当然也可以淘宝：Gworg 获取信任的SSL证书。
4、SSL证书安装完毕后提示到期无效等界面。解决方案：需要重新办理新的SSL证书安装。
5、配置SSL证书发现打开网站不是自己的。解决方案：根据HTTP配置文档配置，因为WEB没有明确到自己的，所以错误了，需要依照HTTP配置的基本信息配置。
关于阿里云配置ssl证书和阿里云 ssl证书的介绍到此就结束了，不知道你从中找到你需要的信息了吗 ？如果你还想了解更多这方面的信息，记得收藏关注本站。
版权声明：本站文章如无特别标注，均为本站原创文章，于2023-05-08，由admin发表，共 997个字。转载请注明出处：admin，如有疑问，请联系我们本文地址：阿里云配置ssl证书（阿里云 ssl证书）-天马云 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43795461f0bf6f2f42f2ea170dbd5fd4/" rel="bookmark">
			python获取文件夹内所有文件并改名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可以使用Python中的os模块和os.path模块来获取文件夹中的所有文件，并使用os.rename()函数来更改文件名。下面是一个示例代码：
复制import os folder_path = "/path/to/folder" # 文件夹路径 new_name = "new_file_name" # 新文件名 # 遍历文件夹中所有文件 for filename in os.listdir(folder_path): # 获取文件的完整路径 file_path = os.path.join(folder_path, filename) # 判断是否为文件 if os.path.isfile(file_path): # 获取文件的扩展名 file_ext = os.path.splitext(filename)[1] # 拼接新的文件名 new_file_path = os.path.join(folder_path, new_name + file_ext) # 更改文件名 os.rename(file_path, new_file_path) 上述代码将文件夹中的所有文件改名为new_file_name，并保留原始文件的扩展名。你可以根据自己的需求修改文件路径和新的文件名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec264e93af52fcc8ba4d9159ac39383/" rel="bookmark">
			《挑战不用macOS逆向iOS APP》之ObjC语法、iOS应用开发、及Objection自动化hook入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 《挑战不用macOS逆向iOS APP》之ObjC语法、iOS应用开发、及Objection自动化hook入门Intro1.Objective-C 基础语法 与消息传递(1)类的声明与实现(2)类方法和实例方法的声明与实现①类方法②实例方法 (3)变量与属性(4)消息传递 2.iOS开发简述(1)ios架构(2)系统架构各层功能模块视图：(3)使用Xcode建立简单MVC程序①打开xcode新建项目，这里xcode版本为14②选择iOS APP 模版③填入项目相关信息④保存后生成项目可以看到自动生成的项目模版文件⑤设计界面⑥使用控件⑦创建并连接输出口和操作⑧绑定⑨设置启动视图⑩项目启动流程简单分析： (4)demo打包签名生成IPA(5)IPA文件结构分析 3.iOS签名相关了解(1).iOS签名原理(2).不同账号区别(3).签名相关问题解释(4)AltStore工具实操 4.Objection自动化逆向与hook简述5.Objection破解简单CrackMe 《挑战不用macOS逆向iOS APP》之ObjC语法、iOS应用开发、及Objection自动化hook入门 Intro 本篇文章是《挑战不用macOS逆向iOS APP》系列的第二课iOS逆向基础知识主要为了了解在iOS APP逆向过程中一些常见知识，具体内容如下:
ObjC基础语法与消息传递iOS开发简单了解iOS签名相关了解 为什么企业签名可以卖钱?可以白嫖签名吗？不花钱那种？网上下载的IPA能长期无痛使用吗？第三方软件商店能用吗？感受如何？AltStore第三方软件商店体验实操 Objection自动化逆向与hookObjection破解简单CrackMe 该系列为学员优秀作品系列，附件apk、代码等位于我的项目中，大家可以自取：
https://github.com/r0ysue/AndroidSecurityStudy
1.Objective-C 基础语法 与消息传递 我们通过最简单的“Hello World！”源码来学习ObjC的基础语法知识。
(1)类的声明与实现 声明：所有的类都继承自NSObject类 @interface test : NSObject { } @end 实现： #import "test.h" @implementation test @end (2)类方法和实例方法的声明与实现 ①类方法 声明： +(void) class_method; 实现： +(void) class_method; { NSLog(@"This is class_method"); } ②实例方法 声明： -(void) instance_method; 实现： -(void) instance_method; { NSLog(@"This is instance_method"); test *test1 = [test new]; } (3)变量与属性 Objective- C类中的变量默认是private权限的，对象无法直接访问，否则会报错，属性则是使用@property声明，声明的属性可以选择是否自动生成getter() 和setter()方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec264e93af52fcc8ba4d9159ac39383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329b3c53030947d88d6f7a43d8400bed/" rel="bookmark">
			leetcode-040-组合总和2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目及测试
package pid040; /* 40. 组合总和 II 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 输出: [ [1,2,2], [5] ] 提示: 1 &lt;= candidates.length &lt;= 100 1 &lt;= candidates[i] &lt;= 50 1 &lt;= target &lt;= 30 */ import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/329b3c53030947d88d6f7a43d8400bed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90f8d1b6ef0f23c0dd8400b5893862a7/" rel="bookmark">
			Spring Cloud微服务实战教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好的，下面是Spring Cloud微服务实战教程，共分为以下部分：
1. 什么是微服务架构
2. Spring Cloud简介
3. 构建微服务应用
4. 服务注册与发现
5. 配置中心
6. 服务网关
7. 服务熔断与降级
8. 服务追踪与监控
9. 部署与运维
10. 总结与展望
## 1. 什么是微服务架构
微服务架构是一种分布式系统架构，其基本思想是将一个大型的单体应用拆分成多个小型的服务，每个服务都可以独立地部署、扩展和维护。每个服务都只负责完成自己的功能，与其他服务通过接口进行通信，从而实现系统的松耦合。
微服务架构具有以下优点：
- 灵活性高：每个服务都可以独立地开发、部署、扩展和维护，可以根据业务需要进行快速迭代和上线。
- 可靠性高：由于每个服务都是独立的，因此一个服务的故障不会影响其他服务的正常运行，系统的容错性和可恢复性得到提高。
- 可扩展性高：每个服务都可以根据需要进行横向和纵向扩展，可以实现更高的并发和负载能力。
- 技术栈多样性：每个服务都可以使用不同的技术栈，可以选择最适合自己的技术和框架，从而提高开发效率和代码质量。
- 易于管理：由于每个服务都是独立的，因此可以更加细粒度地进行管理和监控，也更容易实现自动化运维。
## 2. Spring Cloud简介
Spring Cloud是一套用于构建分布式系统的开发工具包，基于Spring Boot构建。它提供了许多常用的分布式系统开发组件和服务，包括服务注册与发现、配置中心、服务网关、负载均衡、熔断器、链路追踪、消息总线等。
Spring Cloud具有以下特点：
- 简单易用：Spring Cloud提供了一套简单易用的API和注解，开发者可以很方便地构建和部署微服务应用。
- 易于集成：Spring Cloud与Spring Boot集成非常紧密，可以通过依赖注入、自动配置等方式来快速集成各种组件和服务。
- 可扩展性强：Spring Cloud的组件和服务可以根据需要进行自定义和扩展，可以满足不同场景
接下来，我们将逐步完成Spring Cloud微服务实战教程。请按照以下步骤进行：
### 第一步：创建Eureka Server
1. 在IDE中创建一个新的Spring Boot项目，并将其命名为"eureka-server"。
2. 在项目的pom.xml文件中添加以下依赖：
```xml
&lt;dependency&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90f8d1b6ef0f23c0dd8400b5893862a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a51eff3b7a3671783d92b94a2242f985/" rel="bookmark">
			nn.Embedding(num_embeddings, embedding_dim, padding_idx)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nn.Embedding(num_embeddings, embedding_dim, padding_idx) 简单来说就是一个嵌入层，输入词表大小和词表示的维度，输出词表中的每个词用embedding_dim维的向量表示的结果。
定义：存储固定大小字典的词嵌入查找表input：任意形状的 IntTensor或LongTensor (n, d)，其中的元素要小于num_embeddingsoutput：(n, d, a) # 词数，词维度，词向量维度参数：词表大小----词嵌入表示维度-----填充索引， num_embeddings &gt;= nd为了保持句子长度等长，所以需要对较短句子进行padding 举例 实例化词嵌入对象 embeder = torch.nn.Embedding(5, 4, padding_idx=2) embeder.weight """在这里，padding_idx代表需要填充的词索引，默认填充0""" Parameter containing: tensor([[-0.9215, -0.6851, -0.1972, -1.2832], [-0.2189, 0.5643, -1.2452, 0.9586], [ 0.0000, 0.0000, 0.0000, 0.0000], [-1.4466, -0.0685, 0.3057, 2.1399], [-1.9602, -0.9143, 0.6579, -1.0564]], requires_grad=True) 词嵌入表示 words = torch.LongTensor([[1, 2], [3, 4]) # 长度一个是1，一个是2，所以第一个要补零哦 embeder(words) # 把每个词用4维向量表示 """这里的话，words中需要填充的位置设成padding_idx, 表示时就可以填充了""" tensor([[[-0.2189, 0.5643, -1.2452, 0.9586], [ 0.0000, 0.0000, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a51eff3b7a3671783d92b94a2242f985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846db08c102a8248e4936eddb053d013/" rel="bookmark">
			详细解读ChatGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、ChatGPT的本质二、语言模型的发展阶段三、语言模型的能力边界四、ChatGPT如何回答问题？五、ChatGPT的缺陷六、ChatGPT需要的资源七、人工智能的边界在哪里？ 前言 ChatGPT是什么？我调用了api_key对它提问，大家可以先来看一下它自己是如何介绍自己的。
一、ChatGPT的本质 chatgpt是基于语言模型的自然语言处理系统，语言模型是由数学公式构建的模型。
chatgpt只做了两件事：
1、理解自然语言，明白人类的意图。
2、产生自然语言的文本，满足人的要求。
二、语言模型的发展阶段 1、20世纪70年代，贾里尼克博士（数学、通信）研究语音识别方向，首次提出了语言模型的概念。语音识别技术利用了通信中的编码、解码等算法，后来又加入了上下文信息。20世纪90年代，彼得∙布朗利用语言模型实现了英语和法语之间的自动翻译。
2、20世纪90年代后，语言模型中加入了语法信息和语义信息，可以在不增加数据量的情况下大大提高语言模型的能力，但是计算量变得非常大，所以后来的研究人员致力于提高计算机算力及算法效率。
3、2010年前后，Google开发了深度学习的工具Google大脑：一方面，能更有效地利用计算资源，这使得语言模型能够越做越大；另一方面，也让模型计算出的概率越来越准确。语言模型的发展由此进入第三阶段。今天，计算机通过句子的语法结构，可以理解常见的名词、动词和形容词，于是，它就能理解这句话的含义。
三、语言模型的能力边界 语言模型能做的事情可以分为三类:
1、信息形式转换：这是将信息从一种形式转换为另一种形式，无论是语音识别还是机器翻译，都属于这一类。
2、根据要求产生文本：目前像回答问题、回复邮件、书写简单的段落，都属于这一类。向chatgpt提要求，让它反复修改可以提升文本质量。
3、信息精简：为论文撰写摘要、按要求进行数据分析等。
四、ChatGPT如何回答问题？ 人类是如何回答问题的呢？人类遇到问题时，有三种途径能够回答。
1、知道答案直接回答；
2、根据现有知识推出答案；
3、通过实验和探索研究得出答案。
chatgpt如何回答问题呢？
1、简单问题：利用语言模型回答问题，不是一个问题对一个答案这样简单的匹配，而是对于问题给出多个答案，而且最近的内容赋予较高的权重，然后根据答案的概率排序，返回一个最可能的答案。
2、复杂问题：chatgpt回答问题、写作都基于它对语言数据库中的信息进行抽取和整合，或者说归纳总结。你输入给它什么训练数据，它就给你写出什么样的文章。
五、ChatGPT的缺陷 1、chatgpt的训练数据不足(数据未更新)导致的输出错误，写作具有明显的AI特征。
2、优质数据，优质输出。垃圾数据，垃圾输出。
3、chatgpt训练过程需要进行大量的数据标注，数据标注人员的意识形态和错误会在一定程度上影响模型的客观性。
六、ChatGPT需要的资源 1、数据：chatgpt的训练数据主要来自于互联网上的大规模文本语料库，其中包括维基百科、新闻文章、社交媒体、网络论坛等。此外，还有一些特定领域的数据集，如医疗、法律等。总之，训练数据集规模庞大，来源广泛，尽可能的涵盖了不同领域和场景的语言表达。
2、算力：训练 GPT-3 模型时，OpenAI 使用了数千块 V100 GPU 和数百块 TPU，并且每个 GPU 或 TPU 都有 16GB 或者更多的显存。而且训练过程需要多次迭代和优化，因此需要大量的计算和存储资源，以及高速的数据传输资源。
3、算法：
①分词算法：将一段文本分割成单词粒度，比如基于空格分词或者基于模式匹配分词。
②词向量算法：将每个单词转换成低维稠密向量，在计算机中无法直接操作单词，将其转换为向量能够更好的让计算机了解表意。
③序列编码算法： 例如，LSTM和GRU等循环神经网络(RNN)，能够理解先前输入的内容对后续内容有什么影响。
④解码器算法：这是生成自然语言文本的过程，类似与对数据进行自动生成，例如，Transformer等。
七、人工智能的边界在哪里？ ChatGPT的边界是人工智能的边界，而人工智能的边界是数学的边界，数学是有边界的。
1、在1931年，25岁的数学家哥德尔证明了，数学体系不可能既完备又一致。
2、上个世纪60年代末，22岁的马季亚谢维奇得出：对于某一类数学问题（不定方程整数解的问题），没有一个方法，通过有限步就能判断它有没有解。
3、图灵发明了一种叫作图灵机的装置，它能够在有限时间内，判断哪一类问题能够在有限的步骤内计算出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706c65502c73e9b57ceb69c1933bffba/" rel="bookmark">
			mac 系统下通过docker 运行mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mac 系统下通过docker 运行mysql 创建网络mysql 安装执行相关代码配置参数 /workspace/docker/mysql/conf/my.cnf启动： 创建网络 docker network create dev-network mysql 安装 https://hub.docker.com/_/mysql?tab=description&amp;page=1&amp;ordering=last_updated
执行相关代码 #创建本机目录： mkdir /workspace/docker/mysql/conf mkdir /workspace/docker/mysql/data docker pull mysql:5.7.32 docker run --name mysql --network dev-network -p 3306:3306 -v /workspace/docker/mysql/conf:/etc/mysql/conf.d -v /workspace/docker/mysql/data:/var/lib/mysql -v /workspace/logs:/workspace/logs -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7.32 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci #测试连接 mysql -h 127.0.0.1 -u root -proot #备份所有数据库-mysql备份 docker exec mysql sh -c 'exec mysqldump --all-databases -uroot -p"$MYSQL_ROOT_PASSWORD"' &gt; ./all-databases.sql 配置参数 /workspace/docker/mysql/conf/my.cnf [mysqld] port = 3306 skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8mb4 log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed server-id = 1 [mysqldump] quick max_allowed_packet = 16M 启动： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424711ac8d75ce0e4b0ab9cbfc97af37/" rel="bookmark">
			java中级面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.假如有两个线程共同操作数据库，以乐观锁的角度考虑，怎么确保不会发生并发问题？
PS：考点是CAS，比较并替换。CAS中有三个值，内存中的值，新值，旧值。
假如内存中的值是2000，要进行--操作，A,B两个线程分别从主内存中拉去数据，当A线程进行--操作，新值变成了1999，旧值与主内存中的值一致，将新值替换掉主内存中的值，此时主内存值为1999。当B线程进行--操作，新值也是1999，比较主内存值1999与旧值2000不一致，拉去主内存值，在--，此时旧值变成了1999，新值变成了1998……
依次类推，AB线程共同操作共享资源，数据也不会出现并发问题。
2. redis缓存击穿、穿透、雪崩
击穿：数据库中有，缓存中没有的数据。
解决办法：
设置热点数据永不过期加互斥锁 穿透：缓存和数据库中都没有的数据。
解决办法：
将value的值赋为null在接口层增加校验布隆过滤器：快速检索一个元素是否在集合中,不存在的一定能检索到 雪崩：同一时间大量数据请求数据库，导致数据库压力大而宕机。
解决办法：
过期时间设置随机，避免同一时间多个缓存同时过期设置热点数据永不过期使用锁或队列的方式保证不会有大量线程对数据库一次性进行读写 3.数据库优化 一方面从sql优化、索引优化入手，另一方面从数据库的表设计方面入手。
对于sql优化、索引优化。具体包括以下几点：
利用好索引，避免全表扫描优化子查询，使用inner join代替子查询减少无效数据查询，使用select字段名来代替select * 对于表设计方面包括：
尽量使用固定长度的字段限制字段长度分库分表 从IO角度考虑，还可以增加缓冲区
索引包括哪些？
普通索引唯一索引主键索引联合索引 导致索引失效的几种情况：
遇到null值模糊查询 xxx%使用or最左匹配原则where 1=1=前边有表达式或函数使用！=类型隐式转化，比如a是varchar类型，sql中写a=1这样 4.redis过期键的删除策论有哪些？
定时删除
通过使用定时器来删除，保证过期键尽可能的删除，并释放过期键占用的内存。
对内存友好，对CPU不友好。
惰性删除
获取键时对键进行过期检测，不会在删除其他无关过期键花费CPU
对CPU友好，对内存不友好
定期删除
定时删除和惰性删除的一种折中策略，每隔一段时间执行一次删除过期键操作
5.快速失败中，为什么在foreach的过程中，使用remove或者改变集合长度会抛异常
在使用迭代器Iterator的时候，调用集合本身的方法。多线程会导致数据不安全。
在循环或迭代中，首先会创建一个迭代实例，这个迭代实例的expectedModCount赋值为集合的modCount，每当迭代器使用next（）获得下一个之前，会检测 modCount 变量与expectedModCount 值是否相等，相等的话就返回遍历；否则就抛出异常【ConcurrentModificationException】，终⽌遍历。
循环中添加或删除元素，是直接调用集合的add,remove方法【导致了modCount增加或减少】，但这些方法不会修改迭代实例中的expectedModCount，导致在迭代实例中expectedModCount 与 modCount的值不相等，抛出ConcurrentModificationException异常
6.mybatis分页是如何实现的？
通过page对象作为分页依据
通过count作为查询总条数限制
对原有sql通过limit进行分页
7.like %和like _的区别
%代表任意多个字符；_代表任意一个字符。
8.为什么redis最常用的数据类型是String
因为String类型的数据结构简单，存储空间占据小。我们知道redis缓存中的数据是要存到内存中的，而内存的空间毕竟有有限的，所以能用String时，尽量用String
9.POI和easyExcel的区别
POI是将内容先写到内存，再加载到文件；easyExcel是读一行解析一行
10.java的内存模型
java的内存模型分为工作内存和主内存。
工作内存是线程私有的，主内存是线程共享的。
当线程工作时，需要从主内存中拉取到自己的工作内存，在工作内存中读取和修改，当当前线程修改了共享变量后，其他线程不可见。这就导致了“内存不可见”问题。
上升到CPU是各级缓存与主内存不可见问题，采用缓存一致性来解决这个问题
java采用内存屏障来解决，即synchronized，volidate。volidate对线程共享资源修改后会立即同步到主内存，并且其他线程共享变量副本失效，使用时重新从主内存中拉取。
11. 三种线程池的适用场景
线程池的作用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/424711ac8d75ce0e4b0ab9cbfc97af37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/381bc968616374db0ec403418c50fbcc/" rel="bookmark">
			Hadoop框架---MapReduce框架原理(中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一.MapReduce框架原理(中)1.1 Shuffle机制1.1.1 Shuffle机制1.1.2 Partition分区1.1.3 Partition分区案例实操1.1.4 WritableComparable排序1.1.5 WritableComparable排序案例实操(全排序)1.1.6 WritableComparable排序案例实操(区内排序)1.1.7 Combiner合并1.1.8 Combiner合并案例实操 一.MapReduce框架原理(中) 1.1 Shuffle机制 1.1.1 Shuffle机制 Map 方法之后，Reduce 方法之前的数据处理过程称之为 Shuffle。
1.1.2 Partition分区 1、问题引出
要求将统计结果按照条件输出到不同文件中（分区）。比如：将统计结果按照手机归属地不同省份输出到不同文件中(分区)。
2.默认Partition分区
public class HashPartitioner&lt;K, V&gt; extends Partitioner&lt;K, V&gt; { public int getPartition(K key, V value, int numReduceTasks) { return (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks; } } 由源码可以看出：默认分区是根据key的hashCode对ReduceTasks个数取模得到的。用户没法控制哪个key存储到哪个分区。
没有重写getPartition方法时，由于numReduceTasks的数量是设定好的，所以每一个key存放在哪个文件中取决于该key对应的hashcode值!
3、自定义Partitioner步骤
（1）自定义类继承Partitioner，重写getPartition()方法
（2）在Job驱动中，设置自定义Partitioner
(3)自定义Partition后，要根据自定义Partitioner的逻辑设置相应数量的ReduceTask
1.1.3 Partition分区案例实操 1）需求
将统计结果按照手机归属地不同省份输出到不同文件中（分区）
(1)输入数据
（2）期望输出数据
手机号 136、137、138、139 开头都分别放到一个独立的 4 个文件中，其他开头的放到一个文件中。
2）需求分析
3）在案例 Hadoop框架—Hadoop序列化中已有的Mapper，Reducer，Driver类的基础上，增加一个分区类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/381bc968616374db0ec403418c50fbcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d1485440c1219a648246b1d585fed6/" rel="bookmark">
			Java使用poi导出excel针对不同数据列配置设置不同单元格格式(适用于通用导出excel数据)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java使用poi导出excel针对不同数据配置设置不同单元格格式 背景第一版实现方案 第二版理想中的方案可实行的方案 结束 背景 公司大部分业务都是查询相关的业务, 所以建了一个项目专门做数据查询, 数据中转等抽象通用的业务, 有一天给我安排了一个功能, 做excel导出, 配置好查询sql和表头字段映射后即可导出excel, 无需修改代码
后来因为导出数据要求保留几位小数或者转换成百分比等设置单元格格式需要支持配置化, 由于做数据中转有些系统需要的数据是不需要约束小数的, 所以数据层面不能做约束, 否则就不是真正意义上的通用了
第一版 项目中使用了hutool工具类库, 封装了很多的方法, 大大的降低了开发成本
第一版代码, 想着hutool工具里面有个ExcelUtil的类, 里面的方法对使用poi导出excel进行了封装简化于是就这么写了
实现方案 此处以商品订单为例, 不考虑一笔订单多个商品的情况, 不做单元格合并操作
这里使用的Hutool版本是5.8.15
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.15&lt;/version&gt; &lt;/dependency&gt; BaseFileUtils.java
public abstract class BaseFileUtils { /** * 创建xlsx表格 * @param fileName 文件名 * @param headList 列头信息 * @param dataList 数据集 * @param response / */ public static void writeXlsxByData(String fileName, List&lt;Object&gt; headList, List&lt;List&lt;Object&gt;&gt; dataList, HttpServletResponse response) { //创建xlsx格式 ExcelWriter writer = ExcelUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d1485440c1219a648246b1d585fed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43cee8e14cb71a562635df21aa631499/" rel="bookmark">
			【9种】ElasticSearch分词器详解，一文get！！！| 博学谷狂野架构师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch 分词器 作者: 博学谷狂野架构师GitHub：GitHub地址 （有我精心准备的130本电子书PDF） 只分享干货、不吹水，让我们一起加油！😄
概述 分词器的主要作用将用户输入的一段文本，按照一定逻辑，分析成多个词语的一种工具
什么是分词器 顾名思义，文本分析就是把全文本转换成一系列单词（term/token）的过程，也叫分词。在 ES 中，Analysis 是通过分词器（Analyzer） 来实现的，可使用 ES 内置的分析器或者按需定制化分析器。
举一个分词简单的例子：比如你输入 Mastering Elasticsearch，会自动帮你分成两个单词，一个是 mastering，另一个是 elasticsearch，可以看出单词也被转化成了小写的。
分词器的构成 分词器是专门处理分词的组件，分词器由以下三部分组成：
组成部分 character filter 接收原字符流，通过添加、删除或者替换操作改变原字符流
例如：去除文本中的html标签，或者将罗马数字转换成阿拉伯数字等。一个字符过滤器可以有零个或者多个
tokenizer 简单的说就是将一整段文本拆分成一个个的词。
例如拆分英文，通过空格能将句子拆分成一个个的词，但是对于中文来说，无法使用这种方式来实现。在一个分词器中,有且只有一个tokenizeer
token filters 将切分的单词添加、删除或者改变
例如将所有英文单词小写，或者将英文中的停词a删除等，在token filters中，不允许将token(分出的词)的position或者offset改变。同时，在一个分词器中，可以有零个或者多个token filters.
分词顺序 同时 Analyzer 三个部分也是有顺序的，从图中可以看出，从上到下依次经过 Character Filters，Tokenizer 以及 Token Filters，这个顺序比较好理解，一个文本进来肯定要先对文本数据进行处理，再去分词，最后对分词的结果进行过滤。
索引和搜索分词 文本分词会发生在两个地方：
创建索引：当索引文档字符类型为text时，在建立索引时将会对该字段进行分词。搜索：当对一个text类型的字段进行全文检索时，会对用户输入的文本进行分词。 配置分词器 默认ES使用standard analyzer，如果默认的分词器无法符合你的要求，可以自己配置
分词器测试 可以通过_analyzerAPI来测试分词的效果。
COPY# 过滤html 标签 POST _analyze { "tokenizer":"keyword", #原样输出 "char_filter":["html_strip"], # 过滤html标签 "text":"&lt;b&gt;hello world&lt;b&gt;" # 输入的文本 } 指定分词器 使用地方 分词器的使用地方有两个：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43cee8e14cb71a562635df21aa631499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b11bef5d5ab63f84c4abe18a734d6a/" rel="bookmark">
			控制台flask db init执行后，出现flask : 无法将“flask”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制台flask db init执行后，出现flask : 无法将“flask”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。
很多人说因为flask没装上，或者位置不对，但是重装好几遍也没解决，尝试控制台执行：
python -m flask db init
成功
纪念一下这条弹幕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867b8e546e8b3e933d4455beb68eb76f/" rel="bookmark">
			Vue3项目中在线编辑组件，codemirror-editor-vue3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#安装
npm install codemirror-editor-vue3 codemirror@5.x -S #组件中使用
&lt;template&gt; &lt;Codemirror v-model:value="code" :options="cmOptions" border ref="cmRef" height="400" width="600" @change="onChange" @input="onInput" @ready="onReady" &gt; &lt;/Codemirror&gt; &lt;!-- &lt;el-button type="primary" @click="handleSave"&gt;保存&lt;/el-button&gt; --&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, reactive, onMounted,onUnmounted } from 'vue' import "codemirror/mode/javascript/javascript.js" import Codemirror from "codemirror-editor-vue3" import "codemirror/theme/ayu-mirage.css"; import "codemirror/theme/neo.css"; const code = ref( `var i = 0; for (; i &lt; 9; i++) { console.log(i); // more statements } ` ) const cmRef = ref() const cmOptions = reactive({ mode: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867b8e546e8b3e933d4455beb68eb76f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d090dac6819981bd8a76f1306ffd513d/" rel="bookmark">
			【Linux】2.2 环境基础开发工具使用——vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是 vimvim 的基本操作vim 指令集Normal mode 指令集插入模式复制粘贴撤销剪切光标移动删除 last line mode 指令集列出行号跳到文件中的某一行查找字符保存文件 vim 的配置 什么是 vim Linux editor —— vim ——多模式的编辑器每种模式有差异，模式之间可以相互转换vim 常用的 三~五 种模式 Normal mode（正常/普通/命令模式）Insert mode （插入模式）last line mode（末行/底行模式）替换模式视图模式 vim 的基本操作 进入vim之后，是处于 [正常模式] ，要切换到 [插入模式] 才能够输入文字。[正常模式] 切换至[插入模式] 输入a输入i输入o 退出vim及保存文件，在 [正常模式] 下，按一下 : 冒号键进入 「Last line mode」，例如: : w （保存当前文件）: wq (输入「wq」，存盘并退出vim): q! (输入q!，不存盘强制退出vim) vim 指令集 Normal mode 指令集 （大部分指令都是在 Normal mode 下进行的）
插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 按「a」进入插入模式：（注意观察光标随模式改变的变化）
按「o」进入插入模式：（注意观察光标随模式改变的变化）
复制 yy：copy 本行nyy：copy 当前行在内的以下n行的内容 ps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d090dac6819981bd8a76f1306ffd513d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/897e7d7bf98db6ef3a9e2325c545a34b/" rel="bookmark">
			Java基础面试题50题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，""空字符串的作用 package com.neuedu.nineteen; public class Test { public static void main(String[] args) { String s=""; for (char i = 'a'; i &lt; 'd'; i++) { s=s+i;//输出abc // s=i+s;//输出cba } System.out.println(s); } } 如题所示，当进行s=s+i的时候，s在前和s在后输出的结果是相反的。空字符串在前时是正着输出，空字符串在后是逆着输出
2.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? 第一种情况，s1是short类型，在计算s1=s1+1时，前边是short型，后边是int型，不能自动转换。由于没有强转，要报类型错误。
第二种情况，使用了+=这个java自带的运算符，java内部会对其进行处理，所以编译通过，不会报错。
3.说说&amp;和&amp;&amp;的区别。 &amp;和&amp;&amp;都表示与的意思，既表达式俩边都成立，结果才成立。
&amp;&amp;是逻辑运算符，&amp;&amp;有短路作用，既当表达式左边为假时，不需要计算右边，整个的结果直接为假；&amp;没有
&amp;是位运算符，&amp;的左右俩边可以是布尔类型，也可以是数值；&amp;&amp;俩边只能是布尔类型
4.Integer与int的区别 int是八大基本数据类型之一，Integer是int的封装类。
int的默认值是0，Integer的默认值是null，此时的0代表这个数赋值0，而null代表没接收到这个值
Integer提供了与整数相关的操作，int没有
5.==与equals的区别 从表面上看，对于基本数据类型==是判断的值是否相等；对于引用数据类型是判断是否为同一个对象
从本质上看，是看是否为一个引用地址
equals是判断值是否相等
6.override(重写)和overload(重载)的区别 重载是在一个类中，方法名相同，参数列表不同（参数类型和参数个数）的一种现象
1.重载与返回值类型无关
2.不能通过访问修饰符进行重载
如下是重载：
public void a(int x){ x++; } public int a(int x,int y){ return x+y; } protected double a(double d){ return d; } 重写是在父子类中，子类重写父类的方法，要求方法名与参数列表，返回值类型完全相同。子类重写父类规范要在子类的方法前加注解@Override
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/897e7d7bf98db6ef3a9e2325c545a34b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fdc5b45a0c7c921b6b5b8eb33cc6886/" rel="bookmark">
			【经验】使用Postman轻松搞定文件上传测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postman经常用于接口测试，但是上传文件参数还是蛮复杂的，记录下过程
01 上传文件参数
1.选择请求方式
选择post请求方式，输入请求地址
2.填写Headers
Key：Content-Type ；
Value：multipart/form-data
如下图
3.填写body
选择form-data，key选择file类型后value会出现按钮，点击按钮选择文件，最后点击Send发送即可。
4.上传多个文件
需要将字段加上[]中括号，然后选择文件的时候可以选择多个文件
Get请求方式添加参数在params里面
02 上传数组参数
发送数组参数
总结：工具就在那里，多点点会发现它的很多神奇之处
最后： 下方这份完整的软件测试视频学习教程已经整理上传完成，朋友们如果需要可以自行免费领取【保证100%免费】
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/276abc6e2d79ef5e188ec656f3910b1f/" rel="bookmark">
			将list 对象复制给另一个list 对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import com.alibaba.spring.util.BeanUtils; import java.util.ArrayList; import java.util.List; import java.util.function.Supplier; import static org.springframework.beans.BeanUtils.copyProperties; public class ListBeanUtils extends BeanUtils { public static &lt;S, T&gt; List&lt;T&gt; copyListProperties(List&lt;S&gt; sources, Supplier&lt;T&gt; target) { return copyListProperties(sources, target, null); } /** * @author zjk * 使用场景：Entity、Bo、Vo层数据的复制，因为BeanUtils.copyProperties只能给目标对象的属性赋值，却不能在List集合下循环赋值，因此添加该方法 * 如：List&lt;AdminEntity&gt; 赋值到 List&lt;AdminVo&gt; ，List&lt;AdminVo&gt;中的 AdminVo 属性都会被赋予到值 * S: 数据源类 ，T: 目标类::new(eg: AdminVo::new) */ public static &lt;S, T&gt; List&lt;T&gt; copyListProperties(List&lt;S&gt; sources, Supplier&lt;T&gt; target, ListBeanUtilsCallBack&lt;S, T&gt; callBack) { List&lt;T&gt; list = new ArrayList&lt;&gt;(sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/276abc6e2d79ef5e188ec656f3910b1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4bfe718f666e1d86ab70b464ce5538/" rel="bookmark">
			使用J-Link的J-Scope功能查看数据实时波形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用串口打印波形的不便之处
对于要查看的实时变量，一般可以用串口打印到可以查看波形的上位机上。但是这种办法有几个不方便的地方：
需要根据配套上位机的通讯协议，在单片机上编写上传数据的代码
单片机CPU需要浪费部分时间在串口数据上传上
对于很高频率的变量，比如IMU的数据，可能上传速率会达到200HZ，也就是5ms上传一次。单片机这边仅测试，上传数据应该没问题。但是此时上位机上由于并不是响应很快的RTOS系统，可能会导致部分数据丢失，导致看到的波形未必是实际的波形。这对调试是有很大的影响的。
0.3.使用J-scope的好处
使用J-scope查看变量波形，相当于单片机处于debug模式，可以实时查看变量，并绘制变量的波形。也就是说这个数据是J-Link仿真器直接读的，不是串口发的，速度自然快很多，丢帧的可能性也非常小。并且无须任何额外的代码。
根据上面的分类，那J-Scope的2种方式就分别对应了上面的2个类别。
J-Scope RTT &lt;----&gt; 侵入式
J-Scope HSS &lt;----&gt; 非侵入式
特别是这个J-Scope HSS模式，直接在非调试状态下，就可以看到程序中用到的globle static变量的值，还是很有用的，不过有时候我并不需要以图形化的界面展示， 既然能够图形化展示，那以列表展示就更加没问题了。
当需要高速数据分析时，可以用RTT模式。
————————————————
一般使用HSS模式 就是每次需要将keil工程编译生成的.axf文件重现装载
注意使用J-scope 调试显示数据波形，其数据需要设置为全局变量。
J-SCOPE工具可以读取单片机上的全局变量、数组等数据，并绘制成波形。
使用汇总：
①https://blog.csdn.net/LeonSUST/article/details/89889694
②https://blog.csdn.net/qq_30760601/article/details/107246319
③https://www.cnblogs.com/zhaoyanan/p/7875698.html
④https://blog.csdn.net/qq_31441951/article/details/88879477
J-Scope软件的配置 新建工程
在Target Device处选择对应的单片机型号，要加载工程生成的axf文件
配置如图所示，点击OK完成配置
在底部右键 Add
选择要观察的变量
点击红色按钮开始运行
测试代码工程下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0816e897b6f163b3656b7b5f34ba03be/" rel="bookmark">
			ubuntu 通过 apt-get 安装软件失败时的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在 vmware上的ubuntu系统下安装 软件时出现安装失败情况，在网上搜了一通，终于找到了解决方案。遇到的问题和解决方案如下：
一、 apt-get install vim二、 apt-get update时网络连接失败三、 提示镜像秘钥丢失四、提示apt源版本不一致四、 高版本安装低版本的软件 一、 apt-get install vim 提示如下：
“E: Package ‘vim’ has no installation candidate”
解决方案：
sudo apt-get update
二、 apt-get update时网络连接失败 解决方案为替换软件镜像：
sudo vi /etc/apt/sources.list
将内存容替换为阿里云的镜像地址：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0816e897b6f163b3656b7b5f34ba03be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283e9aeda853cd4ce894303306ba9c07/" rel="bookmark">
			eNSP网络模拟器-小白笔记-查看路由表功能命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看所有路由表信息命令：display ip routing-table
2、查看指定IP路由命令：display ip routing-table 100.100.100.100
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd8e38f02721d8f471e88d93b18301e/" rel="bookmark">
			eNSP网络模拟器-小白笔记-跨网段访问功能命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是整个结构图 其实非常的简单，只要向路由器端口中添加相对应的网关就可以了，例如：这张图上面的3个网段，分别是：0，1，2口，添加的方法都是一样的，
1、先进到int g0/0/0
2、然后 ip add 192.168.1.1 255.255.255.0
看一下是否能通
没有任何问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0142216c9532b23ac6295a31a0825c/" rel="bookmark">
			使用Arcgis属性表的字段计算器对字段按类别批量赋值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抄题：如图所示属性表，我的NAME2字段有不同类别，而我想添加新的列，使用数字代表不同类别，方便后面运算。因此，使用Arcgis的属性表计算器对字段分类批量赋值（python脚本）
过程：
创建新字段，然后使用字段计算器
结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346cb43d395fb2ce4e782c66c55ffa52/" rel="bookmark">
			ensp网络模拟器-小白笔记-开启DHCP功能命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习目标： 掌握 ensp 入门知识开启DHCP功能命令 学习内容： 搭建 ensp 环境（有很多教程这里不在记录）掌握开启 DHCP 命令 添加一个路由器并启动它 2、进入到系统设置模式命令：system-view 回车
3、先进到0口：int g0/0/0
4、配置路由器IP地址：192.168.1.1，命令：ip add 192.168.1.1 255.255.255.0
5、然后在添加一台交换机和3台PC机并启动，（多少台根据自己的要求来）
6、 回到我们的路由器开启DHCP命令：dhcp enable
7、绑定那个接口需要开通DHCP服务命令：dhcp select interface
8、这样路由器就开通了这个DHCP服务的功能，然后在PC机上面设置DHCP方法
9、在命令行查看是否自动获取到IP地址：ipconfig
10、能够自动获取到，实验成功！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/039fec85ac9af40d15c16bf92ece6e0b/" rel="bookmark">
			Docker部署主从Mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[1]安装docker curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
[2]docker安装mysql 8.0
docker pull mysql:8.0
[3]配置并启动mysql
（1）获取docker的ip
docker inspect --format='{{.NetworkSettings.IPAddress}}' mysql-master
得到172.17.0.2
docker inspect --format='{{.NetworkSettings.IPAddress}}' mysql-slaver
得到172.17.0.3
（2）创建mysql配置文件，并映射到宿主机
master配置：
[mysqld]
## 同一局域网内注意要唯一
server-id=100 ## 开启二进制日志功能，可以随便取（关键）
log-bin=mysql-bin
在master创建用户给从库执行同步binlog
root@asdfadf:/# mysql -uroot -p123456
CREATE USER 'slave'@'%' IDENTIFIED BY '123456';
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';
此外，如果是mysql8.0及以上，为了方便测试，可以使用下面的方式创建用户
ALTER USER 'slave'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
slaver配置：
[mysqld] ## 设置server_id,注意要唯一 server-id=101 ## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用 log-bin=mysql-slave-bin ## relay_log配置中继日志 relay_log=edu-mysql-relay-bin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/039fec85ac9af40d15c16bf92ece6e0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c115ab85a76dec7c77271c89752a86/" rel="bookmark">
			AttributeError: module ‘numpy‘ has no attribute ‘bool‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误结果：
错误原因：AttributeError: module 'numpy' has no attribute 'bool'.
`np.bool` was a deprecated alias for the builtin `bool`. To avoid this error in existing code, use `bool` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.bool_` here.
The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c115ab85a76dec7c77271c89752a86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96520edd498b7cf57b1344ed1cd7d58/" rel="bookmark">
			Golang使用Redis示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github.com/gomodule/redigo/redis package main import ( "fmt" "github.com/gomodule/redigo/redis" ) // Background返回一个非空的Context。 它永远不会被取消，没有值，也没有期限。 // 它通常在main函数，初始化和测试时使用，并用作传入请求的顶级上下文。 func main() { c, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil { fmt.Println("Connect to redis error", err) return } defer c.Close() _, err = c.Do("SET", "mykey", "Test001") if err != nil { fmt.Println("redis set failed:", err) } username, err := redis.String(c.Do("GET", "mykey")) if err != nil { fmt.Println("redis get failed:", err) } else { fmt.Printf("Get mykey: %v \n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d96520edd498b7cf57b1344ed1cd7d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b51464397cf0fdce9fa7d0ae78dee7/" rel="bookmark">
			【Linux已解决】解压文件报错tar: /usr/local: Not found in archivetar: Exiting with failure status due to
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
这里是小编成长之路的历程，也是小编的学习之路。希望和各位大佬们一起成长！
以下为小编最喜欢的两句话：
要有最朴素的生活和最遥远的梦想，即使明天天寒地冻，山高水远，路远马亡。
一个人为什么要努力？ 我见过最好的答案就是：因为我喜欢的东西都很贵，我想去的地方都很远，我爱的人超完美。因此，小编想说：共勉！
本篇文章是小编记录Linux的系统学习
目录
问题描述：
解决方法：
问题描述： root@ubuntu:~# tar -xvf /usr/lib/java/apache-tomcat-9.0.48.tar.gz /usr/local
tar: /usr/local: Not found in archive
tar: Exiting with failure status due to previous errors
翻译如下：
tar： /usr/local： 未在存档中找到
tar：由于以前的错误而退出并处于失败状态
解决方法： 原因是因为压缩文件使用的相对路径 在当前目录下找不到 /usr/local目录，通过使用-C指定解压目录可解决此问题
tar -xvf /usr/lib/java/apache-tomcat-9.0.48.tar.gz -C /usr/local/ 小编的错误原因是没有加-C 然后在/usr/local后面没有加/
最后解压成功 以上就是小编所实践的内容，希望能够帮助到大家，感谢各位大佬的观看！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cb6ef0006cb101508152e18fa7d81a/" rel="bookmark">
			启动Rabbit时出现Plugin configuration unchanged无法启动问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述问题解决新问题 问题描述 在安装好Erlang和RabbitMQ并配置好环境变量后, 运行rabbitmq-plugins enable rabbitmq_management 命令, 出现如下问题
在启动Rabbit时出现以下内容
The folwing plugins have been configured:
rabbitmq_management
rabbitmq_management_agent
rabbitmq_web_dispatch
Plugin configuration unchanged
然后就无法访问到 http://localhost:15672/
问题解决 先看看我安装的Rabbit和Erlang版本
在安装完RabbitMQ并且配置好环境变量之后.首先使用管理员权限打开命令控制符
注意要使用管理员权限打开cmd, 不然可能会权限不够
打开之后进入到安装RabbitMQ的安装目录sbin 下, 然后用命令进入到这个路径下
进入到这里之后, 在终端执行rabbitmq-service.bat remove 命令
然后执行set RABBITMQ_BASE=E:\RabbitMQ\RabbitData
后面的路径写自己的文件夹, 可以创建一个data, 此项操作是因为默认的路径在c盘用户的文件夹下
此项操作可以改变默认路径
然后执行下载命令: rabbitmq-service.bat install
执行完此命令之后再次执行: rabbitmq-plugins enable rabbitmq_management
还没完,紧接着执行RabbitMQ启动命令: rabbitmq-server.bat start
如上则是启动成功,之后去浏览器打开RabbitMQ的Web端管理网页: localhost:15672
默认用户名和密码都是guest,点击登录即可.
新问题 完成这些不走之后依然无法访问，解决方法：
Win+R 输入services.msc 打开进程，找到 RabbitMQ 右键启动
然后在访问地址就行了！！！
原文(侵删):安装RabbitMQ出现Plugin configuration unchanged.问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863948bd68585c86b5279e02dd784811/" rel="bookmark">
			Qt 多语言界面设计概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、多语言界面设计概述
有些软件需要开发多语言界面版本，如中文版和英文版，并且在软件里可以方便地切换界面语言。Qt 为多语言界面提供了很好的支持，使用 Qt 的一些规则和工具，可以很方便地为应用程序开发提供多语言界面支持。
用 Qt 开发多语言界面应用程序，主要包括以下几个步骤：
(1)在程序设计阶段，程序代码中每一个用户可见的字符串都用 tr()函数封装，以便 Qt 提取界面字符串用于生成翻译资源文件。用UI设计器可视化设计窗体时统一用一种语言，如汉语。
(2)在项目配置文件 (.pro 文件)中设置需要导出的翻译文件 (.ts 文件)名称，使用 lupdate工具扫描项目文件中需要翻译的字符串，并生成翻译文件。
(3)使用 Qt 的 Linguist程序打开生成的翻译文件，将程序中的字符串翻译为需要的语言，如将所有中文字符串翻译为英文。
(4)使用 lrelease工具编译翻译好的翻译文件，生成更为紧凑的“.qm”文件。
(5)在应用程序中用QTranslator 调用不同的“.qm”文件，实现不同的语言界面。
2、tr()函数的使用
为了让 Qt 能自动提取程序中用户可见的字符串，对于每个字符串都需要使用 tr()函数封装。tr()是 QObject 的一个静态函数，在使用了Q_OBJECT 宏定义的类或QObiect 的子类中，都可以直接使用 tr()函数，否则需要使用 QObiect::tr()进行调用。或者在类定义中用 Q_DECLARE_TR_FUNCTIONS 宏把tr()函数添加到类中之后，再直接调用 tr()函数。
tr()函数的定义是：
QString QObject::tr(const char *sourceText, const char *disambiguation = Q_NULLPTR, int n = -1) 其中，sourceText 是源字符串，disambiguation 是为翻译者提供额外信息的字符串，用于对些容易混淆的地方作说明，内容如下:
LabCellPos = new QLabel(tr("当前单元格:"),this); QMessageBox::information(this，tr("信息")，tr("信息提示?“)，QMessageBox::Yes); QString strl=tr("左右"，"大约的意思”) ; QString str2=tr("左右”，"掌握、控制的意思") ; 使用 tr()函数，需要注意以下一些事项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863948bd68585c86b5279e02dd784811/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3107a3532f615e8f60b4ff0996a23c96/" rel="bookmark">
			QT自制软键盘 最完美、最简单、跟自带虚拟键盘一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT自制软键盘 最完美、最简单、跟自带虚拟键盘一样 [1] QT自制软键盘 最完美、最简单、跟自带虚拟键盘一样一、本自制虚拟键盘特点二、windows打开系统自带软键盘三、让键盘界面保持在最上方、不改变底层界面焦点四、长按按键重复输入键盘内容五、模拟键盘点击事件完成虚拟键盘输入六、键盘符号输入七、界面八、头文件代码九、源文件代码十、使用示例十一、效果 [2] Qt在Win下调用系统的软键盘，区分win7\win8\win10 [1] QT自制软键盘 最完美、最简单、跟自带虚拟键盘一样 原文链接：https://blog.csdn.net/qq_41632571/article/details/125808787
一、本自制虚拟键盘特点 1.键盘界面保持在所有界面最上方。
2.点击键盘按钮不会改变底层文本输入框焦点。
3.通过模拟键盘点击事件完成键盘输入文本信息。
4.包含各种键盘自带符号输入。
5.长按按键可以持续重复输入键盘内容。
6.支持win7、win10、Linux等各个系统。
7.界面好看。
总之跟真的虚拟键盘一样，不会有不爽的地方
二、windows打开系统自带软键盘 QDesktopServices::openUrl(QUrl("osk.exe", QUrl::TolerantMode)); 传统打开系统自带虚拟键盘的方法如上，一行代码即可，但是系统自带的虚拟键盘不一定好用，有的按键太小，有的电脑上可能没有自带的软键盘，干脆直接写一个。
三、让键盘界面保持在最上方、不改变底层界面焦点 很多自制键盘时不知道怎么使键盘保持在最顶层，发现点击键盘界面后系统焦点在键盘界面上了，光标不在底层的行输入框里，就通过输入完成后点击确定的方式将键盘内容传到底层界面，显得不nice，其实这两个问题都很简单能够解决，代码如下
this-&gt;setWindowFlags(Qt::WindowStaysOnTopHint | Qt::WindowDoesNotAcceptFocus); Qt::WindowStaysOnTopHint 设置窗口置顶
Qt::WindowDoesNotAcceptFocus 设置无焦点窗口
四、长按按键重复输入键盘内容 特别是我们点击退格删除键时，文本比较多是我们使用真实键盘就会长按退格键把十多个文本挨个删除，而使用虚拟键盘时要按十多次退格键，显得不nice。那么我们使用QPushButton的setAutoRepeat为true，就可以实现按键长按功能了，设置重复操作延时为500ms差不多了，按下的时长超过500ms后马上再次执行按键槽函数。
pbtn-&gt;setAutoRepeat(true); //允许自动重复 pbtn-&gt;setAutoRepeatDelay(500);//设置重复操作的时延 五、模拟键盘点击事件完成虚拟键盘输入 一些自制虚拟键盘完成键盘输入的方式是同传递文本到输入框的方式，话不多说，就是不nice。点击虚拟按键直接发送对应的按键点击事件就很nice，这样其实就不会太死，甚至中文输入也可以，我们写的是键盘，不是写中文输入法，那些下载网上含有中文输入法的库的大可不必，输入法你系统用的什么就是什么。如果你想中文输入，系统下载的有搜狗输入法，你的键盘只需按下ctrl+shift切换输入法即可，而不是在键盘里实现中文输入法的功能。那样不nice，模拟发送按键点击事件代码如下。
QPushButton* pbtn = (QPushButton*)sender(); if (pbtn-&gt;text() &gt;= 'a' &amp;&amp; pbtn-&gt;text() &lt;= 'z') { QKeyEvent keyPress(QEvent::KeyPress, int(pbtn-&gt;text().at(0).toLatin1()) - 32, Qt::NoModifier, pbtn-&gt;text()); QKeyEvent keyRelease(QEvent::KeyRelease, int(pbtn-&gt;text().at(0).toLatin1()) - 32, Qt::NoModifier, pbtn-&gt;text()); QApplication::sendEvent(m_focusWidget-&gt;focusWidget(), &amp;keyPress); QApplication::sendEvent(m_focusWidget-&gt;focusWidget(), &amp;keyRelease); } 通过QApplication::sendEvent发送一个按键按下和按键松开的事件就相当于模拟一个按键按下事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3107a3532f615e8f60b4ff0996a23c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a898f48295f1e03b3a4737479a97bf/" rel="bookmark">
			服务器购买到宝塔网站搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、阿里云服务器购买 进入云服务器 ECS购买页面
云服务器 ECS购买
自定义购买–&gt;按量付费(若想长期持有也可包年包月)–&gt;地域的话按需选取就行了
实例和镜像 存储
自带的4.0G也是够用了，感觉不够的可以在添加数据盘处自己添加
带宽和安全组
带宽峰值选择80Mbps的话就是8毛钱1GB，安全组的话把下面端口全部选上就行
管理设置
这边可以先设置登录密码(远程登录时会用到)
也可以创建后进行设置
购买完成后，需要设置"安全组"，防止端口号被拦截
当端口被拦截时，可以通过"手动添加"或者"快速添加"的方式添加端口 优先级：100协议类型：自定义TCP端口号：例如端口号为8888，就填8888/8888，不要只填8888授权对象：源:0.0.0.0/0
二、远程桌面连接阿里云服务器 购买完成后，启动阿里云服务器(第一次启动需要等待几分钟)
Win+R输入mstsc打开远程桌面连接
输入上图中公网IP地址，点击连接 计算机：公网地址用户名：都是administrator(这个在购买服务器中管理设置时可以看见)注：始终要求凭据无需勾选
输入凭据 这里的密码就是购买服务器时设置的密码
安全风险提醒 点是就完了
这样就可以登录到申请的云服务器上了
三、购买域名 创建信息模版
主要是填写邮箱进行邮箱验证(QQ邮箱不行)，上传身份证照片，其余信息如实填写即可，然后点击提交，等着审核完毕就行了
选择域名，查询域名是否被注册，没被注册的话将其加入清单 域名注册网站 加入清单后，点击域名清单，在弹出的对话框中立即购买即可
选择购买年限，选择实名的信息模版，点击提交订单，付钱就完了，然后需要一点时间去审核
审核成功后就可以在域名控制台看到申请成功的域名了
四、域名解析 在域名列表，点击解析
点击添加记录
填写相关信息 记录类型：一般都是A，指向一个IPV4主机记录，就是域名前缀记录值：云服务器的IPTTL：默认就行
五、使用宝塔一键部署网站 在宝塔网站下载
宝塔官网 选择windows面板，点击立即安装
下载安装包将其拖入并解压至远程桌面连接的阿里云服务器中，安装完成后会显示登录的网址即账号密码回到物理桌面，按照提供的信息登录即可 下载相应运行环境
软件商店–&gt;运行环境
一键部署网站
点击提交后，使用填写的域名登录即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0067fed2236f08e3e57bba631e76587e/" rel="bookmark">
			安装ros时遇到Website may be down
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开终端
cd /usr/lib/python3/dist-packages/ find . -type f | xargs grep "raw.githubusercontent" 修改文件
第一个文件
sudo gedit ./rosdistro/__init__.py 找到文件对应位置内容替换为
gitee.com/zhao-xuzuo/rosdistro/raw/master 第二个文件
sudo gedit ./rosdep2/gbpdistro_support.py 第三个文件
sudo gedit ./rosdep2/sources_list.py 第四个文件
sudo gedit ./rosdep2/rep3.py 新开终端
sudo rosdep init rosdep update 测试ros
首先启动三个命令行(ctrl + alt + T) 命令行1键入:roscore 命令行2键入:rosrun turtlesim turtlesim_node(此时会弹出图形化界面) 命令行3键入:rosrun turtlesim turtle_teleop_key(在3中可以通过上下左右控制2中乌龟的运动) gazebo roscore 新开窗口 rviz 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64933e3edd4527179e9986298be0a964/" rel="bookmark">
			头歌机器学习---Pandas数值统计​ Pandas数据清洗​​
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关 Pandas数值统计 因为series和dataframe是两个不同的对象，所以它们有自己独特的方法。接下来让我们看一个series方法的例子—Series.value_counts()方法。此方法按顺序显示列中的每个非空值及其计数。
首先，我们将从f500的dataframe中选择一个列：
sectors = f500["sector"]print(type(sectors)) 输出结果：
class 'pandas.core.series.Series' 接下来，我们将把Series.value_counts()中的“Series”替换为sectors，如下所示：
sectors_value_counts = sectors.value_counts()print(sectors_value_counts) 输出结果：
Financials 118Energy 80Technology 44Motor Vehicles &amp; Parts 34Wholesalers 28Health Care 27Food &amp; Drug Stores 20Transportation 19Telecommunications 18Retailing 17Food, Beverages &amp; Tobacco 16Materials 16Industrials 15Aerospace &amp; Defense 14Engineering &amp; Construction 13Chemicals 7Media 3Hotels, Restaurants &amp; Leisure 3Business Services 3Household Products 3Apparel 2Name: sector, dtype: int64 我们可以看到列中每个非空值及其计数。
让我们看看当我们尝试对dataframe使用Series.value_counts()方法时会发生什么。首先，我们将选择sector和industry列来创建一个名为sectors_industries的dataframe：
sectors_industries = f500[["sector", "industry"]]
print(type(sectors_industries))
输出结果：
&lt; class 'pandas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64933e3edd4527179e9986298be0a964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b05176db65fa5a1439999e4b4ef8ea/" rel="bookmark">
			机器学习笔记（吴恩达）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第1周
1.引言(Introduction)
1.3 监督学习
1.4 无监督学习
2.单变量线性回归（Linear Regression with One Variable）
2.1模型表示
2.2 代价函数
2.5 梯度下降
2.7 梯度下降的线性回归
第2周
4.多变量线性回归(Linear Regression with Multiple Variables）
4.1 多维特征
4.2 多变量梯度下降
4.3 梯度下降法实践1-特征缩放
4.5 特征和多项式回归
4.6 正规方程
5.6 向量化
第3周
6.逻辑回归(Logistic Regression)
6.1 分类问题
6.2 假说表示
6.3 判定边界
6.4 代价函数
6.5 简化的成本函数和梯度下降
6.7 多类别分类：一对多
7.正则化(Regularization)
7.1 过拟合的问题
7.2 代价函数
7.3 正则化线性回归
7.4 正则化的逻辑回归模型
第4周
8. 神经网络的表述(Neural Networks: Representation)
8.3 模型表示1
8.4 模型表示2 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b05176db65fa5a1439999e4b4ef8ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382aa0de8b853ca52fea73eab9559546/" rel="bookmark">
			Tre靶场通关过程（linpeas使用&#43;启动项编辑器提权）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tre靶场通关 通过信息收集获得到了普通用户账号密码，利用PEASS-ng的linpeas脚本进行提权的信息收集，根据已有信息进行提权。
靶机下载地址：
https://download.vulnhub.com/tre/Tre.zip
信息收集 靶机IP探测：192.168.0.129
arp-scan -l 端口扫描
nmap -p 1-65535 -sV -A 192.168.0.129 22 80 8082 目录扫描
python dirsearch.py -u "http://192.168.0.129" info.php
adminer.php
dirsearch默认字典没扫除其他有用信息，看别人通关原来是字典的原因，利用dirb大字典扫描目录
dirb http://192.168.0.129 /usr/share/wordlists/dirb/big.txt dirb扫描文件用以下命令
dirb http://192.168.0.129 /usr/share/wordlists/dirb/big.txt -X .php 在扫描的
http://192.168.0.129/mantisbt/config/ 目录下的a.txt文件发现数据库的信息
# --- Database Configuration --- $g_hostname = 'localhost'; $g_db_username = 'mantissuser'; $g_db_password = 'password@123AS'; $g_database_name = 'mantis'; $g_db_type = 'mysqli'; 在adminer.php页面进行登录
找到了用户密码信息
其中Tre用户可以直接ssh登录
usr:tre pwd:Tr3@123456A! ssh tre@192.168.0.129 提权阶段 接下来对tre用户进行提权
主要学习下LinPEAS这个提权脚本（Linux/Unix/MacOS），同PEASS-ng里还有Windows的提权脚本WinPEAS
wget https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/382aa0de8b853ca52fea73eab9559546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbad11db849fd98d2e11e5ab35e67e8/" rel="bookmark">
			高并发秒杀系统解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		秒杀系统场景特点 1, 秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增。
2, 秒杀一般是访问请求数量远远大于库存数量，只有少部分用户能够秒杀成功。
3, 秒杀业务流程比较简单，一般就是下订单减库存。
秒杀系统技术要求 1, 高并发：秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增。是时间极短、瞬间用户量极大。面对瞬间的流量涌入，如何保证服务还能平稳运行。
2, 超卖：高效益的产品不可能无限量供应，在总额度有限的前提下，如果发生超卖的情况，不仅会损失金钱，也会引发用户投诉，降低用户口碑。
3, 恶意请求：对于恶意的请求，即便不法用户最后未能抢到商品，但在恶意请求的期间，这种行为也会给服务器、数据库、带宽等造成压力，导致其他用户体验下降，对于脚本等恶意行为应该迅速拦截。
4, 数据库：项目使用 MySQL 数据库，在高 QPS 的场景下，如果流量瞬间涌入数据库后让数据库挂掉，导致其他服务也无法使用，带来的灾难将是不可预估的。
5, 链接暴露：为了防止不法分子提前知道秒杀活动的地址并发起请求，需设计一个随机算法生成秒杀链接。
同时还有以下问题需要被考虑：
时间同步：多个客户端的时间保持同步，也就是让大家看到时间是一致的。
高可扩：随着时间的推移，系统可能对功能，性能等方面有新的要求。
技术方案 很明显，要让大规模用户能够同时打开抢货的网页，势必要用要到 CDN。同时利用我们分布式中限流、网关等知识，将请求层层筛选，降低最后连接到数据库的请求。即使用 CDN 的边缘结点来扛流量，然后过滤用户请求（限流用户请求），来保护数据中心的系统。
CDN 主要作用有两个：
将一些不会改变的静态资源放到离客户端较近的边缘服务器上。这样客户端请求数据的时候可以直接从边缘服务器获取，降低中心服务器的压力。
可以把小服务部署到 CDN 结点上去，这样，当前端页面来访问开没开始时，这个小服务除了告诉前端是否开始外，它还可以统计下有多少人在线。
每个小服务会把当前在线等待秒杀的人数每隔一段时间就回传给我们的数据中心，于是我们就知道全网总共在线的人数有多少。
利用 CDN 将静态资源分发在边缘服务器上，当进行服务请求时，先进行鉴权，鉴权主要是筛选机器人等非人工抢购，根据实际经验，鉴权可以筛选很大一部分用户，例如是否登录。
当鉴权确定是真实有效的用户之后，通过负载均衡，也就是 LVS+Keepalived 将请求分配到不同的 Nginx 上。
一般会建立 Nginx 集群，然后再通过网关集群，即使这样还是要增加一些限流措施。
如果到这一步还是有很多请求压到数据库势必撑不住，那么可以采取服务限流、服务降级等措施，进行削峰处理。
到这儿理论上流量就不高了，如果还是很高，后面就将热点数据放进缓存集群中进行预热，同时设置定时任务。
一方面关注数据库与缓存的一致性，另一方面关闭超时未支付的订单，当订单提交之后交给任务队列，生成订单、修改数据库、做好持久化工作。
架构图如下（可点击查看大图）：
针对超卖问题 超卖的原因 假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。
在上面的这个图中，就导致了并发用户B也“抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。
悲观锁思路 解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。
悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。
乐观锁思路 这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。
有很多软件和服务都有“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。
秒杀实现方案 MQ削峰 请求先放到MQ，给客户端返回：正在排队中…客户端起定时任务，向服务端轮询执行结果 Redis预减 //请求url：/miaosha/product/12234 //服务端controller： @PostMapping("/product/miaosha/{productId}") public boolean miaosha(@PathVariable("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fbad11db849fd98d2e11e5ab35e67e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0a582b5fc858a727ab7a45e131ad42/" rel="bookmark">
			安装服务器Ubuntu16&#43;Rsync&#43;Nginx&#43;php7.3&#43;MySQL&#43;Node&#43;npm&#43;Vue&#43;composer&#43;Laravel5.8&#43;let‘sEncrypt自动证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装一台服务器 安装服务器MacOS下使用证书登陆SSH腾讯云安装配置rsync安装Nginx和PHP7+MySQL安装node.js 和 npm安装 VUE安装Laravel 5.8Rsync命令参数详解通过指令从腾讯云SSL的CRT文件生成PEM文件ubuntu 下 安装 Let’s Encrypt 自动更新SSL证书白痴也会写Cron定时器表达式 安装服务器 MacOS下使用证书登陆SSH腾讯云 cd ~/.ssh 腾讯云证书复制进来
ssh-keygen -t rsa 看看config，里面应该是：
Host aliasname1 HostName 10.10.10.10 Port 22 User ubuntu IdentityFile ~/.ssh/zhengshumingzi Host aliasname2 HostName 11.11.11.11 Port 22 User ubuntu IdentityFile ~/.ssh/zhengshumingzi 如果出错：
Permissions 0755 for ‘zhengshu’ are too open.
则：chmod 400 *
Warning: Permanently added '8.8.8.8 (ECDSA) to the list of known hosts.
则：ssh-keygen -R 8.8.8.8
然后直接 ssh aliasname1 就可以登陆服务器了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab0a582b5fc858a727ab7a45e131ad42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7679e26c361f7a72cfc4c4d62ff7cf7/" rel="bookmark">
			微信小程序如何通过fastadmin的api获取openid和手机号码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要通过Fastadmin的API获取微信小程序的用户openid和手机号码，需要进行以下步骤：
在Fastadmin后台管理系统中，创建一个新的API接口。在添加API接口的过程中，需要将“请求方式”设置为“POST”，“返回参数类型”设置为“Json”，并设置“请求头”中的“Content-Type”为“application/json”。
在“请求参数”中，添加一个参数名为“code”的参数。这个参数将会接收微信小程序的登录凭证，用来获取用户的openid和session_key。
在“请求参数”中，再添加一个参数名为“encryptedData”的参数和一个参数名为“iv”的参数。这两个参数是用来解密用户的手机号码的。
在“返回参数”中，添加一个参数名为“openid”的参数和一个参数名为“mobile”的参数。这两个参数将会返回给小程序端。
在Fastadmin后台管理系统中，打开“系统管理”-&gt;“小程序管理”，获取需要的小程序的“AppID”和“AppSecret”。
在小程序端的代码中，调用微信小程序的wx.login函数，获取用户的登录凭证code。
在小程序端的代码中，编写一个函数，在该函数中调用Fastadmin的API接口，向Fastadmin发送一个POST请求。在请求的“data”数据中，包含三个字段：code（用户登录凭证）、encryptedData（加密的用户手机号码）和iv（解密用户手机号码所需要的加密算法初始向量）。
在接收到Fastadmin返回的数据之后，解析出其中的openid和手机号码，并将它们保存到小程序端的全局变量中。
下面是具体的代码实现，供您参考：
在Fastadmin中创建一个新的API接口：
请求方式：POST
请求地址：/api/wx_login
返回参数类型：JSON
请求头：
Content-Type: application/json
请求参数：
code: String
encryptedData: String
iv: String
返回参数：
openid: String
mobile: String
在小程序端代码中的实现：
function wx_login(code, encryptedData, iv) { wx.request({ url: 'https://your.fastadmin.host/api/wx_login', method: 'POST', data: { code: code, encryptedData: encryptedData, iv: iv }, success: function(res) { console.log(res.data); // 解析并保存openid和mobile } }); } 在后台接口文件中的实现：
public function wx_login($code = '', $encryptedData = '', $iv = '') { $appid = 'your_appid'; $appsecret = 'your_appsecret'; $url = 'https://api.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7679e26c361f7a72cfc4c4d62ff7cf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24c8cd3596c32ee6614d2871dc9f801/" rel="bookmark">
			thinkphp 的 whereIN() 、where IN 如何使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 ThinkPHP 中，可以通过 whereIN 方法来构建 WHERE IN 子句。以下是 whereIN 方法的语法：
$result = Db::table('table_name')-&gt;whereIn('column', $array)-&gt;select(); table_name：表示表名；column：表示要查询的列名；$array：表示包含要查询的值的数组。 例如，如果要查询用户表中 user_id 列的值在 1, 2, 3 之间的所有用户，可以按如下方式编写查询：
$result = Db::table('user')-&gt;whereIn('user_id', array(1,2,3))-&gt;select(); 此查询将返回一个包含匹配行的二维数组。
在 ThinkPHP 中，使用 where 方法进行 SQL 查询，可以通过 whereIn 方法来构建 where in 子句。whereIn 方法允许您将多个值传递给 in 子句，以查找在某个列中具有任何这些值的行。
以下是 whereIn 方法的语法：
$where['column'] = array('in', $array); $result = Db::table('table_name')-&gt;where($where)-&gt;select(); 其中，$where 数组是用来存储查询条件的数组，'column' 是要查询的列名，$array 是一个包含要查询的值的数组。在 where 方法中，将 $where 作为参数进行传递，然后执行查询即可。
例如，假设您要查询用户表中 user_id 列的值在 1, 2, 3 之间的所有用户，可以按如下方式编写查询：
$where['user_id'] = array('in', array(1,2,3)); $result = Db::table('user')-&gt;where($where)-&gt;select(); 这将返回一个包含匹配行的二维数组。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50057ebfafa86ece967b1c497cefde4f/" rel="bookmark">
			fastadmin中，bootstrapTable有哪些参数可以使用？应该如何在php控制器中读取一个列表并使用bootstrapTable显示？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fastadmin框架的BootstrapTable（以下简称BTable）组件可以使用很多参数，下面是一些常用的参数：
url: 指定从哪个地址获取数据。columns: 定义表格的列头和数据源字段名。pagination: 是否启用分页。pageSize: 定义一页显示的记录条数。sidePagination: 定义分页在客户端还是服务端进行。search: 是否启用搜索框。showRefresh: 是否显示刷新按钮。showExport: 是否显示导出按钮。 在PHP控制器中读取列表并使用BootstrapTable显示，可以按照以下步骤：
创建控制器，处理前端请求返回所需数据。
定义获取数据源的方法，如从数据库中读取，组装成数组格式。
将获取到的数据按照BootstrapTable要求的格式组装成JSON格式。
返回组装好的JSON数据。
示例代码如下：
public function index() { return $this-&gt;fetch(); } public function getTableData() { // 从数据库获取数据 $list = Db::name('user')-&gt;select(); // 按照BootstrapTable格式组装数据 $data = [ 'total' =&gt; count($list), 'rows' =&gt; $list ]; // 将数据转换成JSON格式返回 return json_encode($data); } 在前端的模板文件中，可以使用以下代码来加载BootstrapTable：
&lt;table id="table"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th data-field="id"&gt;ID&lt;/th&gt; &lt;th data-field="username"&gt;Username&lt;/th&gt; &lt;th data-field="email"&gt;Email&lt;/th&gt; &lt;th data-field="status"&gt;Status&lt;/th&gt; &lt;th data-field="date"&gt;Date&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;script&gt; $(function() { $('#table').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50057ebfafa86ece967b1c497cefde4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42ceb674d35856e7b04fd44f87719f0/" rel="bookmark">
			Linux搭建Docker环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.确定是CentOS7及以上版本 cat /etc/redhat-release 2.linux可以联网 ping www.baidu.com 3.root用户安装yum yum -y install gcc yum -y install gcc-c++ yum install -y yum-utils 4.设置stable镜像仓库 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 5.更新yum软件包索引 yum makecache fast 6.安装DOCKER CE yum -y install docker-ce docker-ce-cli containerd.io 7.启动docker systemctl start docker docker version systemctl status docker systemctl enable docker 8.镜像加速 mkdir -p /etc/docker tee /etc/docker/daemon.json &lt;&lt;-'EOF' { "registry-mirrors": ["https://uta146oq.mirror.aliyuncs.com"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 9.安装docker-compose sudo curl -L https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a42ceb674d35856e7b04fd44f87719f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cebb399f74cba5ea5b32020334adca1/" rel="bookmark">
			数据库系统工程师考点笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第1章 计算机系统知识1.1 计算机硬件基础知识 11.1.1 中央处理单元 11.1.2 存储器 41.1.3 总线 71.1.4 输入输出控制 10 1.2 计算机体系结构 141.2.1 CISC和RISC…… 151.2.2 流水线技术 161.2.3 阵列处理机、并行处理机和多处理机 19 1.3 存储系统 201.3.1 高速缓存 211.3.2 虚拟存储器 241.3.3 相联存储器 251.3.4 磁盘阵列技术 251.3.5 存储域网络 26 1.4 安全性、可靠性与系统性能评测基础知识 261.4.1 计算机安全概述 261.4.2 加密技术和认证技术 281.4.3 计算机可靠性 351.4.4 计算机系统的性能评价 38 补充知识点1. 多媒体基础知识1.1 多媒体计算机系统1.2 声音1.3 图形和图像1.4 动画和视频1.5 虚拟现实 2. 数据表示和校验3. 逻辑运算 第2章 程序语言基础知识2.1 程序语言概述…… 422.1.1 程序语言的基本概念…… 422.1.2 程序语言的基本成分…… 46 2.2 程序语言翻译基础…… 522.2.1 汇编程序基本原理…… 522.2.2 编译程序基本原理…… 542.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cebb399f74cba5ea5b32020334adca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978f8f7016fb67f852511d5299ba0dcf/" rel="bookmark">
			灰度发布策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝绿部署 蓝绿部署中，一共有两套系统：一套是正在提供服务系统，标记为“绿色”；另一套是准备发布的系统，标记为“蓝色”。两套系统都是功能完善的，并且正在运行的系统，只是系统版本和对外服务情况不同。
蓝绿部署的目的是减少发布时的中断时间、能够快速撤回发布。
金丝雀发布 金丝雀发布（Canary）也是一种发布策略，和国内常说的灰度发布是同一类策略。
蓝绿部署是准备两套系统，在两套系统之间进行切换，金丝雀策略是只有一套系统，逐渐替换这套系统。
譬如说，目标系统是一组无状态的Web服务器，但是数量非常多，假设有一万台。
这时候，蓝绿部署就不能用了，因为你不可能申请一万台服务器专门用来部署蓝色系统（在蓝绿部署的定义中，蓝色的系统要能够承接所有访问）。
可以想到的一个方法是：
只准备几台服务器，在上面部署新版本的系统并测试验证。测试通过之后，担心出现意外，还不敢立即更新所有的服务器。 先将线上的一万台服务器中的10台更新为最新的系统，然后观察验证。确认没有异常之后，再将剩余的所有服务器更新。
这个方法就是金丝雀发布。
实际操作中还可以做更多控制，譬如说，给最初更新的10台服务器设置较低的权重、控制发送给这10台服务器的请求数，然后逐渐提高权重、增加请求数。
这个控制叫做“流量切分”，既可以用于金丝雀发布，也可以用于后面的A/B测试。
A/B测试 首先需要明确的是，A/B测试和蓝绿部署以及金丝雀，完全是两回事。
蓝绿部署和金丝雀是发布策略，目标是确保新上线的系统稳定，关注的是新系统的BUG、隐患。
蓝绿部署和金丝雀是发布策略，目标是确保新上线的系统稳定，关注的是新系统的BUG、隐患。
A/B测试是效果测试，同一时间有多个版本的服务对外服务，这些服务都是经过足够测试，达到了上线标准的服务，有差异但是没有新旧之分（它们上线时可能采用了蓝绿部署的方式）。
A/B测试关注的是不同版本的服务的实际效果，譬如说转化率、订单情况等。
A/B测试时，线上同时运行多个版本的服务，这些服务通常会有一些体验上的差异，譬如说页面样式、颜色、操作流程不同。相关人员通过分析各个版本服务的实际效果，选出效果最好的版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500ee435d37b2ec8f46b5d7c00a2f000/" rel="bookmark">
			JavaWeb监听器Listener
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Listener 监听器介绍 Listener 监听器是 JavaWeb 三大组件之一。JavaWeb 的三大组件分别是：Servlet 程 序、Listener 监听器、Filter 过滤器。
监听器是用于监听某种变化(对象创建/销毁, 增删改等等属性变化)，某个变化都有自己对应的调用方法。
继承对应监听器的接口并重写方法，就可以使用监听器完成自己想要的功能，方法的实现功能由程序员决定。
JavaWeb 的监听器 ServletContextListener 监听（比较常用） 作用：监听 ServletContext 创建或销毁（ Web 应用启动时，会自动创建 ServletContext)， 即生命周期监听。例如：加载初始化的配置文件。
ServletContextListener 监听 方法 void contextInitialized(ServletContextEvent servletContextEvent) 监听Servletcontext 被创建行为 void contextDestroyed(ServletContextEvent servletContextEvent) 监听Servletcontex被销毁 行为
ServletContextAttributeListener 监听器 作用：监听 ServletContext 属性变化
ServletContextAttributeListener 监听方法 void attributeAdded(ServletContextAttributeEvent event) 添加属性
void attributeReplaced(ServletContextAttributeEvent event) 替换属性
void attributeRemoved(ServletContextAttributeEvent event) 移除属性
public class MyServletContextAttributeListener implements ServletContextAttributeListener { @Override public void attributeAdded(ServletContextAttributeEvent servletContextAttributeEvent) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/500ee435d37b2ec8f46b5d7c00a2f000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0a4dd4a3560bc95132a847dee1c065/" rel="bookmark">
			深度学习中的token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		token包含：class token、patch token，在NLP叫每一个单词为token，然后有一个标注句子语义的标注是CLS，在CV中就是把图像切割成不重叠的patch序列（其实就是token）。
Tokenization is a way of separating a piece pf text into smaller units called tokens.And tokens are the building blocks of Natural Language,which can be either words, characters, or subwords.
举个例子，“Never give up”，Tokenization 成words tokens：Never-give-up。
再举个例子，“smarter”，characters tokens：s-m-a-r-t-e-r ；subword tokens：smart-er。
在大型语言模型中，"token"是指文本中的一个最小单位。通常，一个token可以是一个单词、一个标点符号、一个数字、一个符号等。在自然语言处理中，tokenization是将一个句子或文本分成tokens的过程。
在大型语言模型的训练和应用中，模型接收一串tokens作为输入，并尝试预测下一个最可能的token。对于很多模型来说，tokens还可以通过embedding操作转换为向量表示，以便在神经网络中进行处理。由于大型语言模型处理的文本非常大，因此对于处理速度和内存占用等方面的考虑，通常会使用特定的tokenization方法，例如基于字节对编码（byte-pair encoding，BPE）或者WordPiece等算法。
世界被字节化以后，再次会被 token化
在NLP比如BERT，输入一段句子，分词器会将句子中的单词、符号转换成一个个token。对于视觉Transformer，把每个像素看作是一个token的话并不现实，因为一张224x224的图片铺平后就有4万多个token，计算量太大了，BERT都限制了token最长只能512。所以ViT把一张图切分成一个个16x16的patch（具体数值可以自己修改）每个patch看作是一个token，这样一共就只有（224/16）*(224/16)=196个token了。当然了，单单的切分还不够，还要做一个线性映射+位置编码等等。不同的Transformer在处理细节上也会有不同，比如最近看的Swin-T加入了多尺度，从最开始的4*4的patch缩放到后边的32*32
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9348b183c439340562a2e24b89d7a4/" rel="bookmark">
			医学图像分割之U-Net
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景及问题
二、U-Net的创新点
三、U-Net的结构体
一、背景及问题 在过去两年中，在很多视觉识别任务重，深度卷积网络的表现优于当时最先进的方法。但这些深度卷积网络的发展受限于网络模型的大小以及训练数据集的规模。虽然这个限制有过突破，也是在更深的网络、更大的数据集中产生的更好的性能。
卷积网络的典型使用是在图像分类任务上，即输入一个图像，输入该图像对应的一个标签。在很多视觉任务中，尤其是医学图像任务中，希望得到每个像素对应的类别以及定位，而不是一整个图像的类别。在医学图像分割中，还存在着训练集规模不大的问题。Ciresan基于此提出了通过滑动窗口训练模型，通过环绕像素的局部区域（patch）作为输入，来预测该像素对应的类别。
Ciresan提出的方法的优点有两个，一是网络能定位；二是通过patch的训练集数据比训练图像的数量大很多。该模型还获得了当时的EM分割比赛。该方法的缺点也有两个，一是网络需要训练每个像素对应的patch，导致速度非常慢；而且patches存在重叠，出现很多多余信息，也就是投入网络中的训练数据集存在大量的冗余信息，降低了训练速度，浪费时间以及显存。二是在定位的精确度以及上下文的使用上有一个权衡。较大的patches需要更多的池化层，这样就会导致降低定位的精确度；而使用较小的patches，就会只能使用较小的文本信息，也就是可利用的上下文信息范围太小。于是就提出，同时有较精确的定位、稍大范围文本信息的可能。
二、U-Net的创新点 通过Ciresan的方法的缺点，以及“同时存在好的定位和较大文本信息的可能”的启发，也就有了作者更改扩延FCN结构的想法，目标是：使它用非常少的训练图像，产生更准确的分割。
使用连续的层补充contracting网络，用上采样操作替代池化操作，这些层会提高输出分辨率。为了定位，将来自contracting 路径的高分辨率与上采样的输出特征图进行组合。 基于以上两个创新，使得最终的输出结果更加精确。 三、U-Net的结构体 由于the contracting path（也称之为编码层），也就是U-Net结构的左半部分，与the expansive path（也称之为解码层），两部分或多或少是对称的，所以将该模型称之为U型结构。
图1 U-Net的网络结构
the contracting path（编码层） 编码层由5层构成，每层是由两个不填充（padding=0）的conv3*3构成，每个conv3*3后面跟着一个ReLU；然后是下采样，下采样是一个2*2、stride=2的最大池操作，以及将特征图的特征通道变至2倍。最大池用来增大感受野的，此时为原来的2倍感受野（？是否是2倍，此处不是很确定，欢迎交流），特征图的分辨率变为原来的1/2。
具体实现以二分类进行讲解，即输入的图像类别 channels=3，输出类别 num_classes=2. 输入图像分辨率（h, w）= (512, 512).
encoder1: 两个conv3*3，padding=0，channel由3至64. (h, w)= (512, 512)不变。maxpooling: channel=64,不变；(h, w)= (256, 256)，变为一半。encoder2: 两个conv3*3，padding=0，channel由64至128. (h, w)= (256, 256)不变。maxpooling: channel=128,不变；(h, w)= (128,128)，变为一半。encoder3: 两个conv3*3，padding=0，channel由128至256. (h, w)= (128,128)不变。maxpooling: channel=256,不变；(h, w)= (64,64)，变为一半。encoder4: 两个conv3*3，padding=0，channel由256至512. (h, w)=(64,64)不变。maxpooling: channel=512,不变；(h, w)= (32,32)，变为一半。encoder5: 两个conv3*3，padding=0，channel由512至1024. (h, w)=(32,32)不变。 2. the expansive path（解码层）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db9348b183c439340562a2e24b89d7a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00ee04fd074265168bed619eed319c8/" rel="bookmark">
			「网站服务器硬件配置」网站服务器配置要求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈网站服务器硬件配置，以及网站服务器配置要求对应的知识点，希望对各位有所帮助，不要忘了收藏本站喔。
本文目录一览： 1、列出小型电子商务网站服务器的简要硬件指标，3-5万远的服务器硬件配置2、web服务器硬件配置要求？？？3、建立网站需要哪些软件与硬件配置？4、网站建设的硬件要求有哪些申请哪种域名更好5、服务器配置参数有哪些？ 列出小型电子商务网站服务器的简要硬件指标，3-5万远的服务器硬件配置 列出小型电子商务网站服务器的简要硬件指标，3-5万远的服务器硬件配置
3-5万元的服务器硬件已经非常的不错了。。电子商务网站相对于新闻网站对服务器的要求性能高很多，因为大多都是asp，php，jsp+数据库的程序构成，互动性要求比较高，这样对服务器的性能相对于的开销是10倍以上，所以像京东之类的，前台页面清一色的，但是设计到交易型的，就不得不用aspx（.）的动态程序。
至于服务器的选择，cpu的核心数，线程数自然是越多越好，内存容量越大越好，硬盘需要有raid阵列，保护安全，带宽根据访问量来，可以循序渐进的找机房升级加带宽。
你可以看看国产品牌正睿的这款双路八核服务器，标配一个Xeon E5-2650八核心十六线程处理器、16G DDR3 REG ECC容错校验内存，SAS 300G 15000转高速企业级硬盘，2U热插拔机构，可以在不关机的情况下增加或更换硬盘，四个千兆网卡。如果以后随着业务量的增长，觉得性能不够用了，还可以扩展到两颗处理器，达成16颗处理核心32条计算线程（任务管理器那里可以看到32个处理器格子，相当恐怖- -~），最大支持512GB DDR3 REG ECC高速容错校验内存，怎么也够用了。
产品型号：I22S2-8888HV
产品类型：双路八核机架式服务器
处 理 器：Xeon E5-2650
内 存：16G DDR3 REG ECC
硬 盘：SAS 300G
机 构：2U机架式
价 格：￥24900
银牌服务
全国三年免费上门售后服务，关键部件三年以上免费质保。
建议你把cpu升级行腔掘到2个，硬盘升级到3个，做raid阵列，总价在36000左右。这样有16个计算核心，32个计算线程，用户每一个查询数据库的操作都能分配到足够的cpu线程计算资源，开网页，那个速度只能用飞来形容。
给你推荐的是国产品牌正睿的服务器产品，他们的产品性价比很高，做工很专业，兼容性，质量之类的都有保障，售后也很完善，3年免费质保，3年免费上门售后服务，在业界口碑很不错。
电子商务网站服务器租用
一是 要根据你的客户群体来确定线路。电信 网通还是双线 不同得线路机房价格也都是不一样得，
再者就是根据你得网站来确定你的机器配置。
主要就是这两方面了。
电子商务网站服务器需要什么配置
电子商务网站服务器需要的配置如下：
服务器安全加密；
遵从PCI法规；
SSL证书服务等配置。
电子商务网站服务器安全问题
服务器安全无非就是 权限 组件 软件 被攻击了 病毒了 入侵了也就是因为前面的几个原因 具体配置可以参考 :examda./soft/aqjs/staq/20090225/091047968-5. 另外的话自己有服务器的话最好还是托管在正规机房 一般都会7*24*365的技术 所以一般不会有什么问题 即使是有 也可以第一时间解决 用自己的服务器放在自己公司的话 这样网络不稳定 没有接入商也不好网站备案 托管在机房 技术统一管理 24小时驻机房 网络稳定性和速度都比放在自己公司的要好 而且安全配置也不是一天两天的事情 互联网每天都在更新 谁会有那么大的精力每天去关注这些呢 要安全的话是不可能不劳而获的 一般电子商务网站每天信息量也比较大的 若配置不得当 由于各种原因引起服务器宕机所造成的损失可是不小的哦
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00ee04fd074265168bed619eed319c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec93ea81445ae32f988437832477e3fd/" rel="bookmark">
			STM32F4_定时器输入捕获详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 输入捕获简介
2. 输入捕获框图
3. 输入捕获模式
4. 相关寄存器
4.1 TIMx_ARR、TIMx_PSC
4.2 捕获/比较寄存器1：TIMx_CCMR1
4.3 捕获/比较使能寄存器 TIMx_CCER
4.4 中断使能寄存器 TIMx_DIER
5. 库函数配置输入捕获高电平脉冲宽度
6. 实验程序
6.1 main.c
6.2 IntputCapture.c
6.3 IntputCapture.h
1. 输入捕获简介 STM32定时器可以分为相关时钟、时基单元、输入捕获、输出比较。在上一节我们已经学习了STM32的输出PWM比较功能，本节我们将学习STM32的输入捕获功能。
输入捕获模式可以用来测量脉冲宽度或者测量频率。STM32F4系列拥有14个定时器，除了TIM6和TIM7，其他定时器都有输入捕获功能。
输入捕获功能就是通过检测TIMx_CHx上的边沿信号，在边沿信号发生跳变(比如说上升沿/下降沿)的时候，将当前定时器的值TIMx_CNT存放到对应通道的捕获/比较寄存器TIMx_CCRx里面，完成一次捕获。同时还可以配置捕获时是否触发中断/DMA等。
2. 输入捕获框图 输入捕获的过程：输入阶段对TIx输入进行采样，通过滤波器生成一个滤波信号TIxF，然后通过一个带有极性选择的边沿检测器（极性选择就是确定高电平有效还是低电平有效）生成一个信号（TIxFPx），信号一方面可以用作模式控制器的触发输入，另一方面可以捕获命令，通过分频器分频以后传给捕获/比较寄存器。
3. 输入捕获模式 在输入捕获模式下，当相应的ICx信号（ ICx称作输入捕获、OCx称作输出比较 ）检测到跳变沿(上升沿、下降沿)后，将会使用TIMx_CCRx捕获/比较寄存器来存储这一时候计数器的值。发生捕获事件时，会将状态寄存器TIMx_SR的CCXIF位置1，并且这一时刻在使能的状态下可以发送中断或者DMA请求。如果发生捕获事件时CCxIF标志已经处于高位1，那么会将重复捕获标志状态寄存器的CCxOF位置1。可以通过写程序的方式给CCxIF位写入0来将CCxIF位清0，或者读取存储在TIMx_CCRx寄存器中的已捕获数据。
发生输入捕获时：
发生有效跳变沿时，TIMx_CCR1寄存器会获取计数器的值，保存下来。
将CC1IF标志位置1。如果至少发生了两次连续捕获，但CC1IF标志未被清0，则CC1OF捕获溢出标志位会被置1。
根据CC1IE位生成中断。
根据CC1DE位生成DMA请求。
输入捕获测量脉宽的原理：
假定定时器工作在向上计数模式，图中的t1~t2时间，就是我们要测量的高电平时间；首先设置定时器通道x为上升沿捕获，这样在t1时刻会进行第一次捕获，记为CCRx1，记录当前计数器CNT的值；立即清0 CNT，设置定时器通道x为下降沿捕获，在t2时刻，会进行第二次捕获，记录这时的计数器值，记为CCRx2，这样，根据时钟值得到计数器的计数频率，就能算出t1~t2的时间，从而得到高电平脉宽。
如图，在t1到t2之间，可能会产生N次定时器溢出，为了防止高电平太长，导致数据不准确，需要计算CNT计数的次数：N*ARR+CCRx2，用计数次数乘以CNT的计数周期，就可以得到t2~t1的时间长度。
4. 相关寄存器 4.1 TIMx_ARR、TIMx_PSC 这两个寄存器在过去学习定时器功能时，常常用到；分别是自动重装载值寄存器和时钟预分频寄存器。
4.2 捕获/比较寄存器1：TIMx_CCMR1 捕获/比较寄存器1：TIMx_CCMR1（capture/compare mode register 1）
在PWM输出中，已经介绍了该寄存器的输出位配置；这次我们着重看输入部分：也就是第二行ICxx；
第二行的输入部分的高8位是2通道IC2x；低8位是1通道IC1x；3 4通道显然是TIMx_CCMR2捕获/比较寄存器2控制的。
位1:0 捕获/比较1选择 00：CC1通道配置为输出 01：CC1通道配置为输入，IC1映射到TI1上 这里我们配置01，因为框图上通道1对应IC1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec93ea81445ae32f988437832477e3fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75dc62309bfe5cd3909171de5edd5cd/" rel="bookmark">
			JavaScript实现在键盘输入按键，浏览器进行显示的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下为实现在键盘输入按键，浏览器进行显示的代码和运行截图
目录
前言
一、在键盘输入按键，浏览器进行显示
1.1 运行流程及思想
1.2 代码段
1.3 JavaScript语句代码
1.4 运行截图
前言 1.若有选择，您可以在目录里进行快速查找；
2.本博文代码可以根据题目要求实现相关使用功能。同时可以实现自定义的设置；
3.本文介绍的是JavaScript代码习题，本博文使用的软件是HBuilder X3.7.9编写的代码，原则上其他软件如DW、VSCode或DW较低或较高版本的软件都是兼容的，若您有需要且编写软件不是HBX等软件原则上都是可以能正常运行的；
图1 编写软件举例（部分）
4.这里要特别说明，因为我使用的是HBX，所以是网页格式，我也单独把&lt;script&gt;语句粘贴了出来，有需要可直接复制&lt;script&gt;&lt;/script&gt;语句；
5.本博文代码是我在上学时写的，有一些地方没能完美实现，请包涵也请多赐教，若您发现了问题也请麻烦您将问题反馈给我，我好更正错误、总结完善、持续改善！ 6.博文通常需要在浏览器运行，通常会弹出表单，输入数值并得出结果。本文使用的是谷歌浏览器，推荐使用谷歌浏览器；
7.若涉及侵权，请联系删除；
提示：以下是本篇文章正文内容，下面案例可供参考
一、在键盘输入按键，浏览器进行显示 1.1 运行流程及思想 这是通过event.keyCode=="？"的编码，其中？及时可代替的数值，本文程序讲的是上下左右键的使用，若选择其他数值，需要讲数值更改到需要的，并将弹出文本进行修改即可。具体思想流程如下:
1.2 代码段 代码如下（示例）：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; function check() { if(event.keyCode=="37") alert('您选项了左键'); if(event.keyCode=="38") alert('您选项了上键'); if(event.keyCode=="39") alert('您选项了右键'); if(event.keyCode=="40") alert('您选项了下键'); } &lt;/script&gt; &lt;/head&gt; &lt;body onkeydown="check()"&gt; &lt;/body&gt; &lt;/html&gt; 1.3 JavaScript语句代码 代码如下（示例）：
&lt;script type="text/javascript"&gt; function check() { if(event.keyCode=="37") alert('您选项了左键'); if(event.keyCode=="38") alert('您选项了上键'); if(event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75dc62309bfe5cd3909171de5edd5cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf5696465e33aa34bef988901cc2b97/" rel="bookmark">
			LDC1314应用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈ldc1314，以及LDC1314应用手册对应的知识点，希望对各位有所帮助，不要忘了收藏本站喔。
本文目录一览： 1、07Excel如果用函数查找同列的重复数2、eda中晶振怎么接线 07Excel如果用函数查找同列的重复数 这么大的数据量，用数组公式（Ctrl+Shift+Enter）根本不现实，会死机的。
还是=COUNTIF(K:K,K2)1，然后用筛选靠谱。但你说不行，我不明白。只有一种可能拿早唯下会出错，就是长于15位的数字文本（比如身份证号），只要前15位一样，COUNTIF就认为是一样的。但这和你说的“很多重复值不显示"也不一样啊。
如果没有长于15位的数消培字文睁答本，我还是倾向于用COUNTIF，数据量太大了。
eda中晶振怎么接线 eda中晶振怎么接线？
1.可清核以将晶振答型掘的一端接地，另一端接到时钟输入租拦端，在靠近引脚端分别接两个匹配电容到地。
LDC1314如果不使用外部时钟，也可以采用内部晶振。
关于ldc1314和LDC1314应用手册的介绍到此就结束了，不知道你从中找到你需要的信息了吗 ？如果你还想了解更多这方面的信息，记得收藏关注本站。
版权声明：本站文章如无特别标注，均为本站原创文章，于2023-05-06，由admin发表，共 501个字。转载请注明出处：admin，如有疑问，请联系我们本文地址：【ldc1314】LDC1314应用手册-天马云 标签：ldc1314
分享： 上一篇:compoundbutton用法 compoundbutton
下一篇:php虚拟主机（php虚拟主机配置）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c99ed7c8ac3cabdf909e2143c5e4cc0e/" rel="bookmark">
			前端埋点数据上传的一些方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据埋点 数据采集领域的术语，指的是针对用户行为或特定事件进行捕获、处理和发送的相关技术及其实施过程，是对特定事件或者用户行为的数据监控和数据上传。
数据类型 我们从三个维度出发去监控一个项目，即系统所面向的某一个主体，系统单个局部面向使用不同使用主体的差异的情况监控，系统面向运行过程的总体统筹监控这三个方面；也就是用户的行为，页面的性能，产品的异常。从而我们可以划分三个类别出来：
1、数据监控（涉及用户行为及其相应的事件）
2、性能监控（涉及页面的性能及渲染交互）
3、异常监控（涉及产品系统的运行时异常）
同时我们可以给出一个大致的数据结构范围：
pv：页面访问量
uv：用户访问量
关于用户的自定义事件
关于页面性能加载数据
报错的异常信息
前端埋点方式 了解了怎样前端埋点的相关概念，下面说说埋点有哪些方式，也就是可以使用哪些方式来做埋点的数据监控。
一、 XMLHttpRequest 这种使用方式其实就是约定一个接口，然后通过提交请求去进行数据上报的，如：
function buryingPoint(data) { return new Promise((resolve, reject) =&gt; { // 创建XMLHttpRequest const xhr = new XMLHttpRequest(); // 定义请求接口 xhr.open("post", '/buryingPoint', true); // 发送数据 xhr.send(data); }); } let info = {} buryingPoint(info) // 这样就成功上报了info的对象 当我们去调用这个buryingPoint方法时，也就将数据进行了服务端的上报了。
但是，这种传统方式的请求埋点，一般会存在跨域的风险，并且他必须是同步的，否则会容易中断请求。
二、 script及link 通过以传统的请求方式进行数据埋点我们可以看出，实现数据上报并不强调前后端的交互的，因此我们也可以通过一些支持跨域的标签去实现数据上报功能。如：
let a = document.createElement('script') a.src = 'https://www.test.com/web/buryingPoint/test.js?test=123' document.body.appendChild(a) 创建一个script标签，src地址后面带上我们需要传递的数据，并将这个标签挂载中页面，这样就实现script+link方式的数据上报。
使用script标签还有一个好处就是，它是兼容的，可以适应不同的浏览器。
但是，这种方式也有缺点，那就是需要挂载到页面上，而反复操作dom会造成页面性能受影响，并且载入js/css资源还会阻塞页面渲染，影响用户体验，频繁上报是不适合这种方式的。
三、 img 不同于script标签，使用img标签的好处是，无需挂载到页面上，反复操作dom；而且img的加载不会阻塞html的解析，img加载后并不渲染，它需要等待Render Tree生成完后才和Render Tree一起渲染出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c99ed7c8ac3cabdf909e2143c5e4cc0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3874df9db5f9e4c385fb5fe55c1b7ef1/" rel="bookmark">
			Python基础(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Python的标识符和保留字
1、 标识符和保留字的定义
2、Python命名规则
二、变量的定义和使用
1、变量
2、变量的组成
3、变量的多次赋值
三、Python中常见的数据类型
一、常见数据类型
二、整数类型
1、表示
2、整数的不同进制表示方式
三、浮点数类型
1、组成
2、注意事项
四、布尔类型
1、布尔类型表示
五、字符串类型
1、字符串表示
2、可以使用单引号，双引号，以及三引号来定义
3、 单引号和双引号定义的字符串必须定义在同一行
4、三引号定义的字符串可以分布在连续的多行
一、Python的标识符和保留字 1、 标识符和保留字的定义 标识符：
变量、函数、类、模块和其他对象的起的名字就叫标识符
保留字：
某些单词被Python赋予了特定的意义，这些单词你在给你的任何对象起名字的时候都不能用
保留字均为以下：
可以通过以下代码来查看Python的保留字
import keyword print(keyword.kwlist) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3874df9db5f9e4c385fb5fe55c1b7ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc77698a03e8a6bb94874c7e0c214688/" rel="bookmark">
			mac中JAVA环境变量配置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、JDK的下载、安装和配置二、JDK 的安装三、JDK环境配置四、配置环境变量4.1 新建并打开配置文件 .bash_profile （已有这个文件的话，直接编辑就好） 一、JDK的下载、安装和配置 从官网上下jdk
1、输入下载地址：https://www.oracle.com/downloads/
01 点击 Products，往下滑看到 java
02 点击 Download Java
03 往下滑 选择 java8 --&gt; macOS(Windows系统选择Windows) --&gt; 下载
04 点击下载（会显示登入oracle，你可以搜账号密码也可以注册一个，登入之后直接下载）
二、JDK 的安装 下载完成后，我们得到一个 dmg 的安装包，如图所示：
双击下载好的安装包文件
然后就安装完成了，路径是自己默认的
三、JDK环境配置 打开终端窗口，执行如下命令
/usr/libexec/java_home -V 四、配置环境变量 4.1 新建并打开配置文件 .bash_profile （已有这个文件的话，直接编辑就好） 1、我这里是已经有了 .bash_profile文件的
vim .bash_profile 为了更好演示我先删除
2、删除命令
rm -f ~/.bash_profile 3、新建并打开配置文件 .bash_profile
touch .bash_profile 新建 open -e .bash_profile 打开 4、把配置信息复制进去
JAVA_HOME=我的jdk路径 PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH 复制进去后ctrl+s保存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc77698a03e8a6bb94874c7e0c214688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda710c3de8dc2252a089a4ee29e7459/" rel="bookmark">
			【TCP 重传、滑动窗口、流量控制、拥塞控制】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 重传机制超时重传快速重传SACK方法Duplicate SACK 滑动窗口流量控制那操作系统的缓冲区，是如何影响发送窗口和接收窗口的呢？窗口关闭 拥塞控制慢启动拥塞避免拥塞发生快速恢复 重传机制 TCP 实现可靠传输的方式之一，是通过序列号与确认应答。常见的重传机制： 超时重传快速重传SACKD-SACK 超时重传 重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据TCP 会在以下两种情况发生超时重传： 数据包丢失确认应答丢失 超时时间应该设置为多少呢？
RTT指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。RTO指超时重传时间,两种超时时间不同的情况： 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。 因此超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。
超时重传问题?
「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境超时触发重传存在的问题是，超时周期可能相对较长差，不宜频繁反复发送。 快速重传 它不以时间为驱动，而是以数据驱动重传。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。 快速重传流程
第一份 Seq1 先送到了，于是就 Ack 回 2；结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。 快速重传问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda710c3de8dc2252a089a4ee29e7459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0f59ed06cfd124ec04292176fb04e2/" rel="bookmark">
			C# Winform 中使用 Webview2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 目前的windows/Linux下的UI方案，以Qt为主，Flutter, Electron为辅，其他的各种UI都是不堪大用。众所周知，Electron的资源占用和内容占用太大，效率不行，所以有了后续各种跨语言的Web套壳方案：
walls go语言下web套壳tarui Rust下的web套壳 除了使用CEF的Qt/C++/C#方案，Qt+WebEngine, 目前在Windows下各家的最终归路都转向Webview2方案，可以极大地减少发布的程序的大小。
备注：
VS2019支持.Net Framework(~4.8), 对于Net Core 3 和Net 5 支持并不是很完善，并且已过了维护期VS2022对Net 6, 7以及Net Framework 4.8 的支持都很完善，建议使用此搭配 C# Winform下Webview2方案Demo .Net Framework 使用4.8
UI Form核心Code:
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.IO; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace webview { public partial class Form1 : Form { private webTool tool; public Form1() { InitializeComponent(); // https://blog.csdn.net/bashendixie5/article/details/126432821 tool = new webTool(ref webView2_main); initWebview2(); } private async void initWebview2() { var userData = Path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f0f59ed06cfd124ec04292176fb04e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6df00a7b4b6d8a8f3db3d18f91a65cd/" rel="bookmark">
			[NOIP2017 普及组] 棋盘(dfs记忆化搜索 | bfs优先队列双解法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：[NOIP2017 普及组] 棋盘 - 洛谷 题目描述 有一个m×mm×m的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。
任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 11个金币。
另外， 你可以花费 22 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。
现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？
输入格式 第一行包含两个正整数m,nm,n，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。
接下来的nn行，每行三个正整数x,y,cx,y,c， 分别表示坐标为(x,y)(x,y)的格子有颜色cc。
其中c=1c=1 代表黄色，c=0c=0 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为(1,1)(1,1)，右下角的坐标为(m,m)(m,m)。
棋盘上其余的格子都是无色。保证棋盘的左上角，也就是(1,1)(1,1) 一定是有颜色的。
输出格式 一个整数，表示花费的金币的最小值，如果无法到达，输出−1−1。
输入输出样例 输入 #1
5 7 1 1 0 1 2 0 2 2 1 3 3 1 3 4 0 4 4 1 5 5 0 输出 #1
8 输入 #2
5 5 1 1 0 1 2 0 2 2 1 3 3 1 5 5 0 输出 #2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6df00a7b4b6d8a8f3db3d18f91a65cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62abab4202abdb3a6b5297722abc3b39/" rel="bookmark">
			RabbitMQ快速上手（包含秒杀案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 MQ概念 1.1 MQ 介绍 MQ（Message Queue）消息队列，是基础数据结构中“先进先出”的一种数据结构。一般用来解决应用解耦，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构。
1.2 MQ应用场景 MQ的优势
1.2.1异步解耦
以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。
1.2.2 削峰填谷
举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。
1.2.3 消息分发
在实际开发中一个系统的数据有的时候需要分发个不同的系统中， 拿电商举例在双11的时候有很多会场，每一个会场可能都需要用到一个商品的数据，那么我们需要把数据分发到不同的会场中，假设有加了一个会场我们还需要把数据分发给新的会场
常见消息中间件对比图
1.4 RabbitMQ简介 AMQP，即 Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议 的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中 间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。
2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。 Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。
1.5 RabbitMQ中的核心概念 Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker
Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网 络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62abab4202abdb3a6b5297722abc3b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28645dd2df082220d22f9a5da5f2cce/" rel="bookmark">
			SpringBoot 配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
本篇主要介绍两种配置文件格式，分别为properties与yml(yaml)。
需要注意的是：
两个配置文件从功能上来讲是可以同时存在的，但是企业中通常会规定使用某一种格式的配置文件。如果同一个配置出现在两种格式的配置文件中的话，那么以properties为主。 目录
一、配置文件的作用
二、配置文件的格式
三、properties配置文件说明
3.1 properties基本语法
3.2 读取配置文件
3.3 properties缺点分析
四、yml配置文件说明
4.1 yml基本语法
4.2 读取配置文件
4.3 yml优点分析
4.4 yml配置不同数据类型及null
4.5 yml中的单双引号问题
4.6 yml配置对象
五、properties VS yml
六、设置不同环境的配置文件
一、配置文件的作用 整个项目中所有的重要的数据都是在配置文件中配置的，比如：
数据库的连接信息（包含用户名和密码的设置）；项目的启动端口；第三方系统的调用密钥等信息；用于发现和定位问题的普通日志和异常日志等。 配置文件可以定义应用程序的属性，日志，数据源等各种方面的配置。在应用程序启动时，SpringBoot会自动加载并解析这些配置文件，并将配置信息注入到应用程序的各个组件中。
二、配置文件的格式 Spring Boot 配置文件主要分为以下两种格式：
.properties.yml 如下图所示：
其中properties文件于yml就是一个旧版本和新版本的区别，就像小米6和小米13一样，yml文件相比于properties文件做了一些优化，如yml文件天然支持中文字符，而properties文件默认不支持中文字符，如果不进行字符配置的话，那么输入的中文字符就会乱码。
如何配置properties文件默认字符编码呢？
过程如下图所示：
需要注意的是：设置两个Settings，一个是当前项目的配置文件，另一个是所有新项目的配置文件:
在设置完成后需要删除原先的application.properties，创建一个新的application.properties。
说明：
理论上讲properties可以和yml一起存在于一个项目中，当properties和yml一起存在一个项目中时，如果配置文件中出现了同样的配置，比如properties和yml中都配置了”server.port“，那么这个会以properties中的配置为主，也就是.properties配置文件的优先级最高，但加载完.properties文件之后，也会加载.yml文件的配置信息。虽然理论上来讲.properties可以和.yml共存，但在实际业务中，我们通常会采取一种统一的配置文件格式，这样可以更好的维护（降低故障率）。 三、properties配置文件说明 properties配置文件是最早期的配置文件格式，也是创建Spring Boot项目默认的配置文件。
3.1 properties基本语法 properties是以键值的形式配置格式，key 和 value 之间是以”=“ 连接的，如：
# 配置项⽬端⼝号 server.port=8084 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testdb?characterEncoding= utf8 spring.datasource.username=root spring.datasource.password=root 在配置文件中，使用”#“来添加注释信息。
3.2 读取配置文件 如果在项目中，想要主动的读取配置文件中的内容，可以使用@Value注解来实现，@Value注解使用”${}“的格式读取，如下代码所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28645dd2df082220d22f9a5da5f2cce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7b66d5b88cdc26485e8fabe3ed042e/" rel="bookmark">
			要在main.js中连接WebSocket并获取数据，你可以使用原生的WebSocket API或使用相应的WebSocket库。下面是两种常见的方法：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要在main.js中连接WebSocket并获取数据，你可以使用原生的WebSocket API或使用相应的WebSocket库。下面是两种常见的方法：
方法1：使用原生的WebSocket API
javascript复制代码
// 创建WebSocket实例 const socket = new WebSocket('ws://your-websocket-url'); // 监听WebSocket事件 socket.onopen = function() { console.log('WebSocket连接已打开'); }; socket.onmessage = function(event) { console.log('收到WebSocket消息:', event.data); // 在这里处理接收到的消息 }; socket.onclose = function() { console.log('WebSocket连接已关闭'); }; socket.onerror = function(error) { console.error('WebSocket错误:', error); }; 你可以将上述代码放在main.js文件中的适当位置，以在应用程序加载时连接到WebSocket服务器并监听消息。
方法2：使用WebSocket库
如果你想使用库来简化WebSocket的连接和消息处理，可以考虑以下几个常用的WebSocket库：
socket.io：提供了更高级的功能，例如事件处理、广播等。你可以在main.js中使用socket.io-client库。vue-native-websocket：它是一个专门为Vue.js设计的WebSocket插件，提供了Vue风格的API和一些附加功能。 以下是使用vue-native-websocket插件的示例代码：
javascript复制代码
import Vue from 'vue'; import VueNativeSock from 'vue-native-websocket'; Vue.use(VueNativeSock, 'ws://your-websocket-url', { reconnection: true, reconnectionDelay: 3000, }); 将ws://your-websocket-url替换为你实际的WebSocket服务器URL。这将在main.js中配置WebSocket连接并启用重新连接功能。
使用上述方法之一，你可以在main.js中连接到WebSocket服务器并监听接收到的消息。具体如何处理接收到的消息取决于你的应用程序逻辑。你可以将数据存储在Vue实例中，使用Vuex进行状态管理，或者在组件之间进行事件传递等。
各类语言学习资料 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ba269c15a154ca6f23ec3f6f74acaf/" rel="bookmark">
			STM32F4_外部中断详解(EXTI)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. EXTI 是什么？
2. EXTI主要特性
3. EXTI框图
3.1 外部中断/事件线映射
4. EXTI寄存器
4.1 中断屏蔽寄存器 EXTI_IMR
4.2 事件屏蔽寄存器 EXTI_EMR
4.3 上升沿触发选择寄存器 EXTI_RTSR
4.4 下降沿触发选择寄存器 EXTI_FTSR
4.5 软件中断事件寄存器 EXTI_SWIER
4.6 挂起寄存器 EXTI_PR
5. 库函数配置外部中断的步骤
6. STM32外部中断程序
6.1 main.c
6.2 exti.c
6.3 exti.h
1. EXTI 是什么？ EXTI：外部中断/事件控制器包含多达23个用于产生事件/中断请求的边沿检测器。每根输入线都可以单独进行配置，以选择类型 (中断或事件) 和相应的触发事件(上升沿触发、下降沿触发或边沿触发)。每根输入线还可以单独屏蔽。挂起寄存器用于保持中断请求的状态线。是用来专门的管理所有的GPIO用来处理中断和事件的。
中断的意思就是程序在执行过程中，中断就如同一个小插曲，中断或者事件一来，优先执行中断事件，完成中断以后，再执行未完成的程序。（举个简单的例子就是：打比方我们正在家里学习，学习的同时可能你在开水，这个时候，突然门铃响了，门铃响就是一个中断，这个时候就打断了你正在执行的事（学习），你需要先去开门，看一下是否有重要的事；倘若没有很重要的事（处理完中断事件了），你回到座位上重新开始学习；这个时候突然水壶响了，同样水壶响了也是一个中断，需要再一次打断你正在学习的状态，去关一下水壶（再次去处理中断事件）；）
2. EXTI主要特性 1. 每个中断/事件线上都具有独立的触发和屏蔽。
2. 每个中断线都具有专用的状态位。
3. 支持多达23个软件事件/中断请求。
4. 检测脉冲宽度低于APB2时钟宽度的外部信号。
3. EXTI框图 要产生中断，必须先配置好并使能中断线。根据需要的边沿检测设置2个触发寄存器，同时在中断屏蔽寄存器的相应位写 1 使能中断请求。当外部中断线上出现选定信号沿时，便会产生中断请求，对应的挂起位会置1。在挂起寄存器的对应位写 1 ，将清除该中断请求。
要产生事件，必须先配置好并使能事件线。根据需要的边沿检测设置2个触发寄存器，同时在事件屏蔽寄存器的相应位写 1 允许事件请求。当事件线上出现选定信号沿时，便会产生事件脉冲，对应的挂起位不会置 1。
通过在软件中对软件中断/事件寄存器写 1 ，也可以产生中断/事件请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00ba269c15a154ca6f23ec3f6f74acaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c338f94009357b085fdd5e1fda5e5830/" rel="bookmark">
			STM32F4_模数转换器(ADC)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. ADC是什么
2. ADC主要特性
3. ADC框图
3.1 ADC开关控制
3.2 ADC时钟
3.3 通道选择
3.4 单次转换模式和连续转换模式
3.5 时序图
3.6 模拟看门狗
4 温度传感器
5. ADC中断
6. ADC初始化结构体
6.1 ADC相关实验配置
7. 相关寄存器
7.1 ADC控制寄存器：ADC_CR1和ADC_CR2
7.2 ADC通用控制寄存器：ADC_CCR
7.3 ADC采样时间寄存器：ADC_SMPR1和ADC_SMPR2
7.4 ADC规则序列寄存器：ADC_SQRx（x取值1~3）
7.5 ADC规则数据寄存器：ADC_DR
7.6 ADC状态寄存器：ADC_SR
8. 库函数配置ADC1的通道5进行AD转换 9. 实验程序
9.1 main.c
9.2 ADC.c
9.3 ADC.h
首先明确，这里提到的ADC不是我们游戏中的ADC，这里提及的ADC是STM32的一种重要外设功能，ADC英文全程：Analog to Digital，又叫做模拟数字转换器。 1. ADC是什么 在高中的物理中，我们学习过电压表、电流表和万用表的使用，这些器件可以用来测量电路中的分路电流、电压值；强大的STM32单片机中也存在着这样的外设，称作模数转换器ADC；
很好理解，模数转换器就是把模拟量转换成数字量；数字对于我们来说是很亲切的，之所以存在这样的外设，也是为了更方便于使用者的理解和操作。
模拟量就如电压值、光敏电阻阻值、热敏电阻阻值等，通过该转换器可以转换为我们肉眼可见的数字。
STM32F4的ADC是12位逐次趋近型模数转换器。具有多达19个复用通道，可测量来自16个外部源、两个内部源通道的信号。ADC的结果存储在一个左对齐或者右对齐的16位数据寄存器中。
ADC具有模拟看门狗特性，允许应用检测输入电压是否超过了用户自定义的阈值上限或者下限。
STM32F4xx系列一般都有3个ADC，这些ADC可以独立使用，也可以使用双重/三重模样，来提高采样率。STM32F4的ADC是12位逐次逼近型的模拟数字转换器，它有19个通道，可以测16个外部源、2个内部源和Vbat通道的信号。STM32F4的ADC最大的转换速率为2.4Mhz，也就是转换时间为0.41us。
2. ADC主要特性 可配置12位、10位、8位或6位分辨率在转换结束、注入转换结束以及发生模拟看门狗或溢出事件时产生中断单次和连续转换模式用于自动将通道0转换为通道“n”的扫描模式数据对齐以保持内置数据一致性可独立设置各通道采样时间外部触发器选项，可为规则转换和注入转换配置极性ADC电源要求：全速运行时2.4V到3.6V，慢速运行时1.8V 3. ADC框图 1. 电压输入范围：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c338f94009357b085fdd5e1fda5e5830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b13033c86f240c2c754dc18d1485dd/" rel="bookmark">
			Pytorch框架实现Pix2Pix(Image-to-image)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.pix2pix研究背景
2.Pix2Pix基本原理
（1）原理图
（2）条件GAN(cGAN)
（3）公式原理
3.Pix2Pix网络模型
（1）从像素GAN到块级GAN到图像级GAN(From PixelGANs to PatchGANs to ImageGANs)
（2）判别模型
（3）生成模型
4.数据集下载
5.pix2pix代码实现
6.mainWindow窗口显示生成器生成的图片
7.模型下载 1.pix2pix研究背景 提示：pix2pix主页
数字图像任务 计算机视觉( Computer Vision)模仿人眼和大脑对视觉信息的处理和理解图像分类，目标检测，人脸识别计算机图形学( Computer Graphics） 在数字空间中模拟物理世界的视觉感知动画制作，3D建模，虚拟现实数字图像处理( Digital Image Processing) 依据先验知识，对图像的展现形式进行转换图像增强，图像修复，相机ISP图像翻译（Image Translation)图像与图像之间以不同形式的转换。根据sorce domain 的图像生成target domain中对应图像，约束生成的图像和source 图像的分布在某个维度上尽量一致 图像修复视频插帧图像编辑风格迁移超分辨率 图像质量评价(Image Quality Assessment,IQA)
像素损失（MSE)
结构性损失（SSIM)
色彩损失
锐度损失(GMSD)
感知损失(用ImagNet预训练模型提取图像的feature，再比较feature之间的损失）
2.Pix2Pix基本原理 （1）原理图 提示：这是将图像边缘转手机拍照图的过程。 生成器模型 首先是生成模型对于输入的边缘图（区别于GAN输入的噪声）经过转换之后得到一张假的手机拍照图。生成模型的目的就是使得生成的拍照图骗过判别器。判别器模型 第一部分 将生成模型生成的拍照图和对应的真实边缘图一起输入到判别器进行判别。输出判别器结果尽量判别为假。第二部分 将真实的边缘图和对应的真实的拍照图输入到判别器进行判别。输出判别结果尽量判别为真。 （2）条件GAN(cGAN) 原始GAN 原始的GAN是在模型训练过程让生成模型(Generator Model)和判别模型(Discriminator Model)不断的进行对抗，互相的优化，最终让生成模型去逼近真实数据的概率分布，最后只要将噪声输入到生成模型当中，即可生成服从真实图片概率分布以假乱真的图像。条件GAN（cGAN） 条件GAN（cGANs）限制在离散标签、文本以及图像上。图像条件模型已经处理了来自正常映射的图像预测、未来帧预测、照片生成来自稀疏注释的图像生成。y可以是任何形式的辅助信息，比如说类别标签或者其他模式的数据。可以通过增加额外的输入层来将y同时输入生成器和判别器，来实施条件模型。 在生成器模型中，将真实数据x作为输入，输出对应的数据y'; 在判别器模型中，x和y被作为输入送入判别模型判别真假，同时将x和y'也作为输入，输入到判别模型当中，判别生成模型生成的数据真假。总结 总的来说，条件GAN中生成模型的目的还是让生成的图像尽量骗过判别器；判别模型的目的还是尽量将生成模型生成的图像判别为假，真实的输入图像尽量判别为真。 （3）公式原理 提示：之所以会加上L1损失，也是从实验中发现加了L1损失之后效果是最好的，如下图：
提示：通过学习相关的GAN知识点，可以发现GAN领域是将数学公式和代码之间结合最好的。
3.Pix2Pix网络模型 （1）从像素GAN到块级GAN到图像级GAN(From PixelGANs to PatchGANs to ImageGANs) 提示：论文中给出从像素级GAN到块级GAN，最后到图像级GAN。Patch大小为70 x 70的时候效果和大小为完整图像的Patch效果差不错，但是质量稍微较低。 从如下图可以看到，在街景图的标签(labels-&gt;photos)上，对于输入大小为256 x 256分辨率的图像（更大的图像使用0填充），通过FCN-scores评估对于不同判别器（Discriminator）感受野大小的结果，感受野为70 x 70的判别器效果最好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b13033c86f240c2c754dc18d1485dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cff42276c9f65ea15b83dd3139e8c11/" rel="bookmark">
			U盘在电脑上读不出来怎么办？详细解决方法在这！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例：u盘在电脑上读不出来
【不知道为什么，我把u盘插入电脑后电脑完全读不出。我也不知道到底哪里出现了问题，有人可以帮我解答一下吗？】
U盘作为我们生活中经常使用的存储工具，其能帮我们存储大量的文件，但在使用u盘的过程中，其也会出现各种各样的问题，比如u盘乱码、u盘在电脑上读不出来等。
今天小编主要给大家分享u盘在电脑上读不出来的详细解决方法！
一、u盘在电脑上读不出来怎么办？ U盘作为存储工具，给我们的日常生活带来了很大的方便，但如果我们把u盘插入电脑后，出现u盘能识别但无法读取的情况怎么办？可以采用下述方法。
方法1：确保U盘插入正确的USB接口 遇到u盘没坏但u盘识别不到的情况时，请确保您将U盘插入了正确的USB接口。有些电脑有多个USB插口，但其中某些插口可能会有问题。尝试使用另一个USB插口，看看是否能够读取U盘。
如果插入U盘后没有任何反应，请尝试将U盘插入其他电脑的USB插口，以确保U盘本身没有问题。
方法2：重新插入U盘 如果您尝试了多个USB插口仍然无法读取U盘，那么请尝试重新插入U盘。有时候U盘连接不良会导致读取问题。先将U盘拔下来，等待几秒钟后再次插入，看看是否能够读取。
方法3：使用磁盘管理工具 如果重新插入U盘仍然无法读取，那么您可以尝试使用磁盘管理工具来查看U盘是否被识别。操作步骤如下：
1.按下【Win+X】键，在弹出的快捷菜单中选择【磁盘管理】；
2.在磁盘管理窗口中，您应该能够看到U盘的磁盘编号。如果看到U盘的磁盘编号，请右键单击它，选择【更改驱动器号和路径】；
3.然后选择一个未被使用的驱动器号码分配给U盘。这样，您应该就能够在【此电脑】中看到U盘了。
方法4：检查驱动程序 如果您尝试了以上方法，但仍然无法读取U盘，那么可能是由于您的驱动程序已过时或损坏。您可以对u盘进行相关的检查，看看u盘具体出现了哪些问题。
二、操作过程数据丢失怎么办？ 遇到u盘在电脑上读不出来的情况时，可以采用上述方法来解决。如果在进行操作后u盘仍然无法读出，或u盘可读出但部分数据丢失，u盘文件损坏怎么恢复数据？
小编推荐一款良心软件。我们可以借助该软件对丢失的数据进行恢复，软件操作方便，且具有免费扫描功能，我们可以先进行扫描体验后再决定是否进行后续的激活操作，其操作步骤如下：
操作环境： 演示机型：惠普(HP)战X 系统版本：Windows 10 1.将u盘与电脑连接后，运行软件，点击要扫描的文件类型，点击u盘盘符，执行【扫描】命令；
提示：扫描分为快速扫描和深度扫描，首次扫描为快速扫描，若没有完全找到需要恢复的文件，可使用深度扫描功能。 2.扫描结束后，可在页面左侧对需要恢复的文件类型进行选择，也可直接利用筛选器定位文件，选择完毕后，点击【恢复】并为扫描后的文件选择适当的保存位置即可。
提示：文件的保存位置不要选择所扫描的u盘。 总结： 使用u盘的过程中，如果遇到u盘在电脑上读不出来的情况，别担心，简单的4个方法已经帮你总结好啦！可以跟着以上方法进行操作。如果遇到数据丢失的情况，不妨试试使用上方软件。
往期推荐：
Word如何插入图片？最全方法总结（2023新版）https://blog.csdn.net/datarecover/article/details/130339600
360文件恢复怎么做？3种文件恢复方法分享！https://blog.csdn.net/datarecover/article/details/130360696
Win10分辨率怎么看？2种必须学会的方法！https://blog.csdn.net/datarecover/article/details/130361699
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad69e38c4a733c69bfa6cd5abcb2425a/" rel="bookmark">
			Ubuntu上面安装go语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载go语言安装包 官方地址：https://golang.google.cn/dl/
我这里下载的是go1.18.4.linux-amd64.tar.gz版本
二、把压缩包传入linux系统中 1.可以通过xshell连接Ubuntu系统，但需要配ip地址，然后通过xftp把go的压缩包传入系统。
2.可以通过虚拟机的共享文件功能把文件传到Ubuntu系统中。打开虚拟机的设置功能，点击选项，点击共享文件，点击总是启用，然后把windows的桌面路径添加进去就行了。注意最好把系统关机了再设置这些。
/mnt/hgfs/Desktop/
这个目录就是你windows桌面文件存放的位置了，然后通过cp命令把windows桌面的文件移到ubuntu系统中。
例如：cp /mnt/hgfs/Desktop/工具箱.txt /home/liang/
三、安装go编译器 1.将下载的源码包解压至 /usr/local目录 tar -C /usr/local -xzf go1.18.4.linux-amd64.tar.gz
2.将 /usr/local/go/bin 目录添加至PATH环境变量
export PATH=$PATH:/usr/local/go/bin （这是临时配置，重新启动就会失效）
3.永久配置：
sudo vim ~/.bashrc export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 4.保存退出：source ~/.bashrc
5.输入go env 把GO111MODULE关了，可以通过export GO111MODULE=“off” ,也可以在vim ~/.bashrc 写永久配置
四、测试go编译器安装成功 出现这种情况说明安装成功了。
五、编程验证 写一个vim test.go的文件
package main import "fmt" func main() { fmt.Println("Hello, World!") } 然后 go run test.go
出现Hello, World 就成功了。
讲一下go run和 go build的区别：go run命令将编译和行指令合二为一， go build 命令进行编译时，目标文件只编译不执行，编译成可执行程序，在linux系统中，执行可执行程序用的是路径地址。例如在当前目录下就 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad69e38c4a733c69bfa6cd5abcb2425a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9f347388ba1c55eb6a1130d4175c93/" rel="bookmark">
			Windows搭建C&#43;&#43;开发环境（visual studio 2022）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开发环境的搭建 开发工具：vscode、visual studio 2022、visual studio 2019、2015、2010 .. 安装步骤（以Windows下visual studio2022为例）： 打开官网地址 Visual Studio 2022 IDE - 适用于软件开发人员的编程工具 (microsoft.com) 下载社区版2022 下载完成后打开 步骤如下 安装完成后会自动打开出现以下界面
选择空项目，点击创建 点击源文件，鼠标右键选择添加-&gt;新建项 此时就可以在在此文件中，安安静静地编写你的C++代码了。 点击绿色的三角符号运行该程序
此时屏幕上打印出 Hello World ，运行成功！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc37f12b19db087bd85f2f6a9c0da782/" rel="bookmark">
			Qt多媒体模块功能概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多媒体功能指的主要是计算机的音频和视频的输入、输出、显示和播放等功能，Qt 的多媒体模块为音频和视频播放、录音、摄像头拍照和录像等提供支持，甚至还提供数字收音机的支持。本文将介绍Qt 多媒体模块的功能和使用。
Qt 多媒体模块提供了很多类，可以实现如下的一些功能：
1）访问原始音频设备进行输入或输出;
2）低延迟播放音效文件，如 WAV 文件;
3）使用播放列表播放压缩的音频和视频文件，如mp3、wmv 等录制声音并且压制文件;
4）使用摄像头进行预览、拍照和视频录制;
5）音频文件解码到内存进行处理:
6）录制音频或视频时，访问其视频帧或音频缓冲区:数字广播调谐和收听。
要在C++项目中使用Qt多媒体模块，需要在项目配置文件中添加如下一行语句:
Qt += multimedia
如果在项目中使用视频播放功能，还需要加入下面的一行，以使用 QVideoWidget 或QGraphicsVideoItem 进行视频播放。
Qt += multimediawidqets
Qt 多媒体模块包括多个类，下表是一些典型的多媒体应用所需要用到的主要的类。
应用功能
用到的类
播放压缩音频(MP3、AAC等)
播放音效文件(WAV 文件)
播放低延迟的音频
访问原始音频输入数据
录制编码的音频数据
发现音频设备
视频播放
视频处理
摄像头取景框
取景框预览处理
摄像头拍照
摄像头录像
收听数字广播
QMediaPlayer，QMediaPlaylist
QSoundEffect，QSound
QAudioOutput
QAudioInput
QAudioRecorder
QAudioDevicelnfo
QMediaPlayer，QVideoWidget，QGraphicsVideoltem
QMediaPlayer，QVideoFrame，QAbstractVideoSurface
QCamera，QVideoWidget，QGraphicsVideoltem
QCamera，QAbstractVideoSurface，QVideoFrame
QCamera，QCameralmageCapture
QCamera，QMediaRecorder
QRadioTuner，QRadioData
利用 Qt 多媒体模块提供的各种类，可以实现一般的音频、视频的输入和输出。这在一些实际应用中是需要的，如语音识别需要录制音频并对音频数据进行处理，车牌自动识别需要先拍照然后进行图像处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4794786debfe73993ac572cbc05b83/" rel="bookmark">
			Mybatisplus-【3/3】高级操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、自定义类
自动填充功能-扩展MetaObjectHandler
类型处理器-扩展TypeHandler
自定义ID生成器-扩展IdentifierGenerator
二、插件
动态获取表名称-DynamicTableNameInnerInterceptor插件
防止全表更新或删除操作-BlockAttackInnerInterceptor插件
乐观锁-OptimisticLockerInnerInterceptor插件
分页-PaginationInnerInterceptor插件
三、注解
逻辑删除-@TableLogic
实体映射-@ResultMap
这部分功能不是太常用，但一旦有合适的场景会省很多麻烦，同时也要和开发同学制定好规范，主要的使用有几下几类场景
一、自定义类 自动填充功能-扩展MetaObjectHandler //这块一般会做成一个BaseEntity.java类 public class User { @TableField(fill = FieldFill.INSERT_UPDATE) private String operator; } @Component public class MyMetaObjectHandler implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { log.info("start insert fill ...."); this.strictInsertFill(metaObject, "operator", String.class, "Jetty"); } @Override public void updateFill(MetaObject metaObject) { log.info("start update fill ...."); this.strictUpdateFill(metaObject, "operator", String.class, "Tom"); } } this.strictUpdateFill(metaObject, "updateDatetime1", LocalDateTime.class, LocalDateTime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e4794786debfe73993ac572cbc05b83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64987e329f501abcb829fb27e6e69a02/" rel="bookmark">
			centos7 nbd 挂在qcow2或qcow，raw，虚机镜像，virsh，virt，使用qemu-nbd挂载qcow2镜像文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本原理 nbd（网络块设备: Network Block Device），利用qemu-nbd将qemu虚拟机镜像挂载到Linux上。
展开来讲，nbd可以将一个远程主机的磁盘空间，当作一个块设备来使用，就像一块硬盘一样。使用它,你可以很方便的将另一台服务器的硬盘空间,增加到本地服务器上。
NBD与NFS有所不同：NFS只是提供一个挂载点供客户端使用，客户端无法改变这个挂载点的分区格式；而NBD提供的是一个块设备，客户端可以把这个块设备格式化成各种类型的分区，更便于用户的使用。
NBD是一个内核模块，大部分Linux发行版都已包含它。
在centos中, 编译成模块NBD, 保存在 /lib/modules/$version/kernel/driver/block/
远程服务器是一段轻量级的守护进程代码，它提供对远程设备的访问，而且该守护进程并不需要运行在linux平台之上。本地操作系统必须是linux，而且要支持Linux内核NBD驱动，并且能够运行本地客户端进程。
图1.NBD在本地客户端代表远程资源
文件系统能被挂载到NBD上（上图），而且NBD设备也能够用来组成冗余磁盘阵列（RAID）。在本地Linux上挂载一个EXT2文件系统到NBD，其传输率要比在同样的远程机器上挂载一个NFS快。
操作步骤 1.加载NBD驱动 某些版本的 Linux 不加 max_part 参数会导致没有设备节点 /dev/nbd0p{1,2,3,4…} 等。用 kpartx 也不行。
查看有没有加载nbd模块 sudo lsmod |grep nbd
加载nbd模块 sudo modprobe nbd max_part=16
备注信息：查看Linux 模块信息（modinfo），例如查看nbd模块的参数【执行命令modinfo nbd】 。 加载后，在/dev/目录下，根据参数创建nbdxx块设备文件。
2. 连接 qemu-nbd qemu-nbd -c nbd设备路径 虚拟机镜像路径 [$ sudo qemu-nbd -c /dev/nbd0 centos.qcow2]
这里注意查看分区: sudo fdisk -l nbd设备[sudo fdisk -l /dev/nbd0]，可能虚拟机不止一个分区（一般还会有一个boot分区）
3.挂载 sudo mount nbd分区 挂载路径 [$ sudo mount /dev/nbd0p1 /mnt/test1 ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64987e329f501abcb829fb27e6e69a02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa9ab833cc8c2eabb85cbde30603698/" rel="bookmark">
			如何使用 SigNoz 快速搭建一个可观测系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号关注 「奇妙的 Linux 世界」
设为「星标」，每天带你玩转 Linux ！
前言 SigNoz是一个开源的应用程序性能监控工具，可以帮助你监控你的应用程序并排除故障，它可以进行链路追踪、基础设施监控以及日志管理，可以说是Datalog的开源版本。
具体的能力如下：
监控应用程序指标，如延迟、每秒请求、错误率等
监测基础设施指标，如CPU利用率或内存使用情况
追踪跨服务的用户请求
对指标设置警报
通过查找导致问题的确切痕迹，找到问题的根本原因
查看单个请求追踪的详细火焰图
SigNoz包括以下组件。
OpenTelemetry Collector：从你的服务和应用中收集遥测数据。
ClickHouse：一个开源的、高性能的列式OLAP数据库管理系统。
Query Service：前端和ClickHouse之间的接口
Frontend：用户界面，用ReactJS和TypeScript构建。
安装 前提 Kubernetes &gt;= 1.21
仅支持x86/amd64架构
helm &gt;= 3.8
最低资源需求4C8G30G
有可用的默认storageclass
安装 （1）添加helm仓库
helm repo add signoz https://charts.signoz.io helm repo update （2）创建名称空间
kubectl create ns signoz （3）部署signoz
helm install sigonz -n signoz signoz/signoz （4）检查安装情况
# kubectl get po -n signoz NAME READY STATUS RESTARTS AGE chi-signoz-clickhouse-cluster-0-0-0 1/1 Running 0 46m signoz-alertmanager-0 1/1 Running 0 48m signoz-clickhouse-operator-7d4677bb47-dzbzm 2/2 Running 0 48m signoz-frontend-67db9bcf9b-l8x5h 1/1 Running 0 48m signoz-k8s-infra-otel-agent-hhjxb 1/1 Running 0 48m signoz-k8s-infra-otel-agent-t9wjr 1/1 Running 0 48m signoz-k8s-infra-otel-deployment-74fbb7d79-vkm2j 1/1 Running 0 48m signoz-otel-collector-789cf754fd-nsf6f 1/1 Running 0 48m signoz-otel-collector-metrics-67449f79f9-cgkm4 1/1 Running 0 48m signoz-query-service-0 1/1 Running 0 48m signoz-zookeeper-0 1/1 Running 0 48m （5）使用nodeport访问前端应用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa9ab833cc8c2eabb85cbde30603698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfeaa2b3ede5c8c89a38acee1c3802c/" rel="bookmark">
			Warshall algorithm (transitive closure)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description of Warshall I do not wanna describe the specific principle of the Warshall, I just would like to use a simple example to demonstrate the working function of the Warshall.
Simple example I assume an array named M with the size of 4*4. 4 is the number of row and 4 is the number of colume.
step1: Look at the colume 1 of M, M(3,1)=1 and M(4,1)=1. So we will add the row 1 to the row 3 and row 4 seperately.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bfeaa2b3ede5c8c89a38acee1c3802c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23391bb51478dc825f0aceb6b61a9f3a/" rel="bookmark">
			如何使用Angular构建桌面应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Angular构建桌面应用程序需要使用Electron作为框架，并结合Angular进行开发。下面是详细的教程：
1. 安装Node.js和Angular CLI
首先需要安装Node.js和Angular CLI，具体步骤可以参考官方文档。安装完成后，可以通过命令行检查是否安装成功：
```
node -v
ng --version
```
2. 安装Electron
使用npm安装Electron：
```
npm install electron --save-dev
```
3. 创建Angular项目
使用Angular CLI创建一个新的项目：
```
ng new my-electron-app
```
4. 配置Electron
在Angular项目的根目录下创建一个新的文件夹，命名为electron。在electron文件夹中创建一个新的main.js文件，内容如下：
```
const { app, BrowserWindow } = require('electron');
function createWindow () {
const win = new BrowserWindow({
width: 800,
height: 600,
webPreferences: {
nodeIntegration: true
}
});
win.loadFile('dist/my-electron-app/index.html');
win.webContents.openDevTools();
}
app.whenReady().then(() =&gt; {
createWindow();
app.on('activate', () =&gt; {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23391bb51478dc825f0aceb6b61a9f3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a9b593bfd8fab36eb3c0f39ac270e3/" rel="bookmark">
			关于renren-fast-vue部署npm install报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在失败一晚上后偶然看到一位大佬的分享解决了，现在整理一下
Node.js 版本的话建议安装 V14 的，16以上都不建议使用。
首先执行命令 npm cache clean --force 清除一下缓存（由于我使用的是WebStorm不在演示详细过程）
执行 npm install
如果报错为npm ERR! chromedriver@2.27.2....
删除掉 node_moudules 文件夹，并执行
npm install chromedriver@2.27.2 --ignore-scripts；（你看你的 @ 之后是什么就写什么命令）可以看到npm执行成功
执行 npm run dev 命令运行项目
但是我运行项目运行报错
下载 npm 成功，但是不能运行项目执行这个命令
npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/
下载成功了，再执行 npm run dev
可以看到
浏览器访问
http://localhost:8001显示
表示成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3d99c98f79acd57021808767973f97/" rel="bookmark">
			遥感影像深度学习样本对制作教程3——从GEE下载训练数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号GeodataAnalysis，回复20230505获取示例数据和代码，这三章的代码都放在一起，上手运行一下代码更容易弄懂。
遥感数据多种多样，存储格式各异，处理起来很麻烦。比如很多MODIS数据都是采用HDF格式存储的，在制作深度学习样本时，需要把它转换为GeoTiff格式，可能还需要进行重投影或重采样的操作。
GEE在这方面的主要有以下优点
数据全面，不仅有很多官方数据，还有个人上传的数据。全球数据统一，不用考虑数据分景的问题。导出时可以方便的指定分辨率、坐标系。可以批量下载。 下面介绍一下怎么从GEE下载训练数据。
1 确定数据的空间范围 训练数据往往在空间分布上是零散的，如下图所示。在时间上可能各个位置也需要不同时间的数据。这个时候就需要先确定每一块的空间范围和时间。
空间范围的信息为，这一块影像的上下左右的四个坐标值，以及坐标系（每一块影像的坐标系可能不同）。时间信息为年、月、日等。
上两章我们用Langdsat8数据为例，这次也以两景Landsat8数据为例，提取这两景数据对应的相同时间相同空间位置的MODIS数据。数据存储格式如下
- data - LC08_L1TP_018030_20150907_20200908_02_T1 - LC08_L1TP_018030_20150907_20200908_02_T1_B1.TIF - LC08_L1TP_039035_20160304_20200907_02_T1 - LC08_L1TP_039035_20160304_20200907_02_T1_B1.TIF 以下代码用于提取两景影像的空间范围：
df = pd.DataFrame(columns=['id', 'year', 'left', 'top', 'right', 'bottom', 'crs']) for i, id in enumerate(os.listdir('./data/')): src = rio.open( os.path.join('./data/', id, id+'_B1.TIF') ) df.loc[i, 'id'] = id df.loc[i, 'year'] = int(id[17:21]) df.loc[i, 'left'] = src.bounds.left df.loc[i, 'bottom'] = src.bounds.bottom df.loc[i, 'right'] = src.bounds.right df.loc[i, 'top'] = src.bounds.top df.loc[i, 'crs'] = src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd3d99c98f79acd57021808767973f97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f236a067668c97f603472af08b6c90/" rel="bookmark">
			【Android入门到项目实战-- 9.1】—— 传感器的使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
传感器的定义
三大类型传感器
1、运动传感器
2、环境传感器
3、位置传感器
传感器开发框架
1、SensorManager
2、Sensor
3、SensorEvent
4、SensorEventListener
一、使用传感器开发步骤
1、获取传感器信息
1)、获取传感器管理器
2)、获取设备的传感器对象列表
3)、迭代获取Sensor对象，调用对应方法获取相关信息
2、获取传感器传回数据
1）获得传感器管理器
2）调用特定方法获得需要的传感器
3）实现SensorEventListener接口，重写onSensorChanged和onAccuracyChanged方法
4）SensorManager对象调用registerListener注册监听器
5）监听器的取消注册
二、获取传感器信息的实例
三、获取传感器传回数据的实例
原理
传感器的应用如微信的摇一摇功能、NFC、手机自带的指南针等等。下面将学习Android传感器的使用。
传感器的定义 一种物理设备或者生物器官，能够探测、感受外界的信号，物理条件(如光，热， 湿度)或化学组成（如烟雾），并将探知的信息传递给其他的设备或者器官。
三大类型传感器 1、运动传感器 –运动传感器测量加速力和旋转力，它们包括加速度计，重力传感器，陀螺仪和旋转矢量传感器。
2、环境传感器 –环境传感器测量各种周围环境情况，如环境温度、气压、光强、湿度等。包括气压计，光度计和温度计。
3、位置传感器 –位置传感器测量设备的物理位置信息，包括方向传感器和磁力计。
传感器开发框架 1、SensorManager –可以使用此类创建传感器服务的实例。这个类提供了多种方法来访问和列出传感器，注册和注销传感器事件监听器，并获取方向信息。该类还提供了几个传感器常量，用于报告传感器的精度，设置数据采集速率和校准传感器。
2、Sensor –可以使用此类创建特定传感器的实例。这个类提供了各种方法，让你确定一个传感器的能力。
3、SensorEvent –系统使用此类创建传感器事件对象，该对象提供有关传感器事件的信息。传感器事件对象包括以下信息：原始传感器数据，生成事件的传感器类型，数据的准确性以及事件的时间戳。
4、SensorEventListener –可以使用此界面创建两种回传方法，当传感器值更改或传感器准确度发生变化时，会接收通知（传感器事件）。
一、使用传感器开发步骤 1、获取传感器信息 传感器的开发首先需要获取传感器的一些信息，获取信息需要以下步骤：
1)、获取传感器管理器 Android提供了一个sensorManager管理器，通过这个类可以获取到都有哪些传感器，获取sensorManager对象代码如下：
SensorManager sm = (SensorManager)getSystemService(SENSOR_SERVICE); 2)、获取设备的传感器对象列表 通过sensorManager管理器的getSensorList()方法，可以获取传感器对象列表，具体代码如下：
List&lt;Sensor&gt; allSensors = sm.getSensorList(Sensor.TYPE_ALL); 3)、迭代获取Sensor对象，调用对应方法获取相关信息 for(Sensor s:allSensors){ sensor.getName(); //获得传感器名称 sensor.getType(); //获得传感器种类 sensor.getVendor(); //获得传感器供应商 sensor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f236a067668c97f603472af08b6c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ba53a59296443233ede9bc129ff90d/" rel="bookmark">
			Windows环境下NVM安装后Node/NPM命令无法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：Windows环境下安装nvm后，无法使用nvm安装nodejs 官网下载nvm安装包，Releases · coreybutler/nvm-windows (github.com) 点击exe安装包，将目录修改为非系统盘（C）例如：D:\SoftWork\nvm，同时nodejs的安装目录选择和nvm同目录下例如：D:\SoftWork\nodejs 在Windows图标右键找到终端Windows PowerShell管理员，执行nvm install version 如果第3步长时间没有响应，大家可以在终端中执行以下命令，将nvm的安装镜像地址修改为淘宝的镜像地址：node_mirror: CNPM Binaries Mirror node_mirror: CNPM Binaries Mirror 如果npm不可用那么也可以将其修改为淘宝镜像地址，但是一般来说这个是非必须的：npm_mirror: https://npm.taobao.org/mirrors/npm/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 问题：Windows环境下安装nvm后，使用nvm安装node，无法使用node相关命令。 解决方案：注意安装的时候有两个路径，第一个是nvm所在的路径，第二个是nodejs所在的路径，大家需要在对应的目录下找到路径，并新建nodejs文件夹即可。
下载地址：Releases · coreybutler/nvm-windows (github.com)
图文安装教程：
以上是nvm的安装包下载位置，安装过程中大家需要注意两个路径：
1、这个是安装nvm的路径，这个无需修改
2、这个是nodejs的路径，稍后将会在这个路径下，创建nodejs文件夹，貌似是由于权限不足无法创建nodejs文件夹所导致
NVM的所有命令如下：
nvm arch [32|64]: 显示节点是以32位还是64位模式运行。指定32或64以覆盖默认体系结构。nvm check: 检查NVM4W进程是否存在已知问题。nvm current: 显示活动版本。nvm install &lt;version&gt; [arch]: 版本可以是特定版本，“最新”表示当前最新版本，“lts”表示最新的lts版本。（可选）指定是安装32位版本还是64位版本（默认为system arch）。将[arch]设置为“all”以安装32 AND 64位版本。在该命令的末尾添加--unsecurity，以绕过远程下载服务器的SSL验证。nvm list [available]: 列出node.js的安装。在末尾键入available以显示可供下载的版本列表。nvm on: 启用node.js版本管理。nvm off: 禁用node.js版本管理（不卸载任何内容）。nvm proxy [url]: 设置用于下载的代理。将[url]留空以查看当前代理。将[url]设置为“none”以删除代理。nvm uninstall &lt;version&gt;: 卸载特定版本。nvm use &lt;version&gt; [arch]: 切换到使用指定的版本。可以选择使用最新版本、lts或最新版本。最新版本是最新安装的版本。可选地指定32/64位体系结构。nvm使用＜arch＞将继续使用所选版本，但切换到32/64位模式。nvm root &lt;path&gt;: 设置nvm存储不同版本node.js的目录。如果没有设置＜path＞，则显示当前的root。nvm version: 显示当前运行的Windows nvm版本。nvm node_mirror &lt;node_mirror_url&gt;: 设置节点镜像。中国可以使用CNPM二进制镜像 CNPM Binaries Mirrornvm npm_mirror &lt;npm_mirror_url&gt;: 设置npm镜像。中国可以使用CNPM二进制镜像CNPM Binaries Mirror 问题：Windows环境下，pnpm无法找到命令使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74ba53a59296443233ede9bc129ff90d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395135759bad126e71d07cc7588509ba/" rel="bookmark">
			cmd指令无法从C盘切到D盘或E盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常现象 在windos下使用cd指令的时候，发现可以在当前磁盘切换，不能跨磁盘切换，如下所示
# 直接使用cd 指令无法切换；还是返回当前路径 C:\Users\duqiu&gt;cd e: E:\test C:\Users\duqiu&gt; # 加上 /d 之后可以进行切换 C:\Users\duqiu&gt;cd /d E: E:\&gt;cd /d c: C:\Users\duqiu&gt;cd E:	# 这里切换又失败了 E:\ # 加上 /d 之后切换成功 C:\Users\duqiu&gt;cd /d E: E:\&gt;cd /d C: # 不需要cd，直接进行磁盘切换 C:\Users\duqiu&gt;e: E:\&gt;cd test\ # 跨磁盘切换还是失败 E:\test&gt;cd C: C:\Users\duqiu E:\test&gt; 原因解释： 1：cd命令的功能是：在同一个磁盘下切换不同的工作路径；
2：切换工作磁盘，其命令形式是 [盘符]冒号，比如 “E:”
3：“cd /d xxx” 表示直接转换到后面的路径;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/198db8dc79a73d9859580cb2b9f039fd/" rel="bookmark">
			批次标准化（batch normalization）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批次标准化（batch normalization） 当一个模型的多个输入差异比较大时（比如 x 1 x_1 x1​在0-1， x 2 x_2 x2​在100-200之间，那么 x 1 x_1 x1​如果发生改变对最后Loss的影响一定是远大于 x 2 x_2 x2​的，因此我们希望让不同维度的输入有一致的范围，让优化更简单
feature Normalization（特征归一化） 我们将每个维度的输入都转化为同一范围的量的过程称为标准化，如上图所示即为标准化的过程，但是图中的标准化mean和 σ i \sigma_i σi​的来源都是所有资料，但是我们知道，我们正常是要分成很多个batch，那么该怎么办呢？
batch Normalization 每个batch并不是同步进行的，为了完成feature Normalization的过程，我们可以将求所有资料的mean和 σ \sigma σ变为这个batch的。
多次标准化 在深度学习中，是有多层layer的，上一个layer的输出也是下一个layer的输入，第一层输入做了feature Normalization，但后面的输出却没有做，这显然是不合理的，因此我们可以对每层的输出都做一个feature Normalization。至于这个feature Normalization放在sigmoid这类激化函数前后都是可以的（不过sigmoid一般建议放在前面，因为sigmoid函数在0附近grandient较大)。
在某些情况下，我们希望最后的输出并不是以0为mean的，因此在输出精确到一定程度后可以对其进行变换：
testing时的batch Normalization 在实际使用的测试过程中，可能一次输入并没有一个batch，这时batch Normalization可能会出现问题，pytorch给了解决方案，即在训练时每一个batch，都会将其mean和 σ \sigma σ拿来做一个平均值，之后用来作为测试时的mean和标准差
做一个平均值，之后用来作为测试时的mean和标准差
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c2b93f7d27026c4e6bb1c19cfa5742/" rel="bookmark">
			MySQL Server 连接工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySQL自带客户端工具链接MySQL
第三方工具Navicat链接MySQL
MySQL自带客户端工具链接MySQL C:\Program Files\MySQL\MySQL Server 5.7\bin 目录下，mysql.exe为MySQL Server自带的客户端工具，通过在目录栏里直接输入cmd，进入该目录下的命令窗口。
通过MySQL自带的客户端工具链接MySQL。
通过MySQL客户端工具的快捷方式连接MySQL
第三方工具Navicat链接MySQL navicat是一款绿色的链接MySQL的客户端工具。可直接点击Navicat.exe运行。
（1）启动navicat
（2）链接数据库。连接名是自定义，本机的主机名就是localhost，数据库管理系统端口一般默认为3306，输入root用户密码。
（3）点击展示所有数据库。所有的MySQL客户端链接器的交互都是依据SQL语句，例如运行navicat，链接本地数据库后，点击连接名展示四个数据库名，这个操作等价于：show databases;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e58da959a81285f944f311c32331d844/" rel="bookmark">
			pip使用国内镜像源（附加全局修改）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 豆瓣镜像 -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com --user # 清华镜像 -i https://pypi.tuna.tsinghua.edu.cn/simple 设为全局默认 # 设置清华源 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 其他国内镜像 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 现在学校的感觉有点不行，明显慢于企业镜像，可以多尝试企业镜像 豆瓣：-i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com 阿里云：-i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com pip临时使用国内镜像源 # 清华镜像 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple somepackage # 实例 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas 可以在使用pip的时候，加上参数-i和镜像地址
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas pip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorflow==1.2.0 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple django==2.2 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyjwt pip install -i https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e58da959a81285f944f311c32331d844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2ebaa251112749be6e610a2ff4f679/" rel="bookmark">
			CentOS7下离线安装MySQL8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在hw外包干久了，要废了，什么都要忘记了，感觉和外面脱节太大了，太危险了，赶紧复习一下压压惊。
准备rpm安装包 下载地址：https://www.mysql.com/cn/downloads/
图1：
图2：
图3：
开始安装 解压
依次执行以下安装
rpm -ivh mysql-community-common-8.0.33-1.el7.x86_64.rpm
rpm -ivh mysql-community-client-plugins-8.0.33-1.el7.x86_64.rpm
rpm -ivh mysql-community-libs-8.0.33-1.el7.x86_64.rpm
rpm -ivh mysql-community-client-8.0.33-1.el7.x86_64.rpm
rpm -ivh mysql-community-icu-data-files-8.0.33-1.el7.x86_64.rpm
rpm -ivh mysql-community-server-8.0.33-1.el7.x86_64.rpm
说明：
不同版本，可能安装不同，可以根据提示进行安装： [root@host31 mysql]# rpm -ivh mysql-community-server-8.0.33-1.el7.x86_64.rpm warning: mysql-community-server-8.0.33-1.el7.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 3a79bd29: NOKEY error: Failed dependencies: mysql-community-icu-data-files = 8.0.33-1.el7 is needed by mysql-community-server-8.0.33-1.el7.x86_64 [root@host31 mysql]# rpm -ivh mysql-community-icu-data-files-8.0.33-1.el7.x86_64.rpm 如上是缺少icu-data-file，所以需要先安装它。
3. 启动mysql并且修改root密码，设置远程连接
启动：systemctl start mysqld
查看首次登录用户密码：cat /var/log/mysqld.log | grep password
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2ebaa251112749be6e610a2ff4f679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d233513d30435d3eb9cf3d2d3eb42a3/" rel="bookmark">
			C&#43;&#43;中常用的容器String、vector、list、map（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、String容器
初始化
string对象上的操作 二、vector容器
初始化
区分是列表初始化还是值初始化：
其他操作
三、list容器
四、map容器
这里主要讲C++中经常用到的一些保存数据的容器，其中也会介绍string。
在C++11中提到了很多容器，这里主要介绍：vector、list、map。还有一些其他的容器就不做介绍了。
一、String容器 这是我们用得最多的用来表示字符串的类型了 ，下面介绍一下String的一些知识：
初始化 string s1; //这里默认初始化，s1是一个空字符串
string s2 = s1; //s2是s1的副本，此时s2和s1是里面保存的是一样的内容
string s3 = "hiya"; //s3是该字符串字面值的副本
string s3("hiya"); //等价于上面的s3
string s4(10, 'c'); //s4的内容是cccccccccc。（10个c）
string对象上的操作 os&lt;&lt;s; 将s写到输出流os当中，返回os
is&gt;&gt;s; 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s) 从is中读取一行赋给s，返回is
s.empty(); s为空返回true，否则返回false
s.size(); 返回s中字符的个数
s[n]; 返回s中第n个字符的引用，位置从0计起
s1 + s2; 返回s1和s2连接后的结果
s1 = s2; 用s2的副本代替s1中原来的字符；
s1 == s2； 如果s1和s2中所含字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感
s1 != s2; &lt;,&lt;=,&gt;,&gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感
这里对于string类型的数据，我们可以像访问数组元素一样访问string中的对应字符。
注：还可以使用迭代器来对字符串类型做一些操作，如
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d233513d30435d3eb9cf3d2d3eb42a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c698a4de10be2aa6a210615d2c7686/" rel="bookmark">
			二叉树基础详解和Python代码定义，各种二叉树遍历方式详解和Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树基础详解 二叉树的种类 满二叉树 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
完全二叉树 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点。
二叉搜索树 前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。
●若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
●若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
●它的左、右子树也分别为二叉排序树
平衡搜索二叉树 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
二叉树的储存方式 二叉树可以链式存储，也可以顺序存储。
但我们一般都用链式储存
那么链式存储方式就用指针， 顺序存储的方式就是用数组。
顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。
二叉树的遍历方式 二叉树主要有两种遍历方式：
深度优先遍历：先往深走，遇到叶子节点再往回走。
广度优先遍历：一层一层的去遍历。
这两种遍历是图论中最基本的两种遍历方式，后面在介绍图论的时候 还会介绍到。
那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：
深度优先遍历
●前序遍历（递归法，迭代法）
●中序遍历（递归法，迭代法）
●后序遍历（递归法，迭代法）
广度优先遍历
层次遍历（迭代法）
在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。
这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。
看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式
●前序遍历：中左右
●中序遍历：左中右
●后序遍历：左右中
大家可以对着如下图，看看自己理解的前后中序有没有问题。
最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。
二叉树的定义（Python） class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None 二叉树的深度优先遍历（递归）： 前序遍历（中左右） 力扣144. 二叉树的前序遍历
class Solution: def preorderTraversal(self, root: Optional[TreeNode])-&gt; List[int]: result = [] #保存结果 def transfer(root): if root==None: return result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c698a4de10be2aa6a210615d2c7686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648bc9605b650144cc456660232e436b/" rel="bookmark">
			Docker安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找 &amp; 安装Redis # 查找redis版本 docker search redis # 安装redis docker pull &lt;镜像名称&gt;:&lt;版本号&gt; # 不带版本号就是最新版本 latest docker pull redis # 查看已经安装的镜像 docker images Docker挂载配置文件 将redis 的配置文件进行挂载，以配置文件方式启动redis 容器。
挂载：即将宿主的文件和容器内部目录相关联，相互绑定，在宿主机内修改文件的话也随之修改容器内部文件）
redis.conf 官方文档链接：https://redis.io/docs/management/config-file/
liunx 下redis.conf文件位置： /home/redis/myredis/redis.conf liunx 下redis的data文件位置 ： /home/redis/myredis/data 启动 docker run --restart=always --log-opt max-size=100m --log-opt max-file=2 -p 6379:6379 --name myredis -v /home/redis/myredis/myredis.conf:/etc/redis/redis.conf -v /home/redis/myredis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes --restart=always 总是开机启动 --log是日志方面的 -p 6379:6379 将6379端口挂载出去 --name 给这个容器取一个名字 -v 数据卷挂载 - /home/redis/myredis/myredis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/648bc9605b650144cc456660232e436b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77974db3f3be00b17577c5bb68633af/" rel="bookmark">
			nginx的基础命令(启动、重启、关闭)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 指定配置文件配置文件启动nginx。 nginx -c /usr/local/nginx/conf/nginx.conf 重启服务 service nginx restart 快速停止或关闭Nginx nginx -s stop 正常停止或关闭Nginx nginx -s quit 配置文件修改重装载命令 nginx -s reload 配置文件修改后校验命令 nginx -t -c /etc/nginx/nginx.conf 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e779ccf6e5e36abbaccc24bb638cfa35/" rel="bookmark">
			MySQL数据库基础知识及命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
📢数据库基础操作命令📢
✍显示数据库
✍创建数据库
​编辑
✍删除数据库
✍使用数据库
📢表的基础操作命令📢
✍创建表
✍查看表
✍删除表
📢表的增删查改📢
✍新增
单行数据 + 全列插入
多行数据 + 指定列插入
✍查询
全列查询
指定列查询
查询字段为表达式
别名 as
​编辑
去重 distinct
排序 order by
条件查询 where
分页查询 limit ✍ 聚合查询
group by
✍联合查询
内连接
外连接
自连接
✍子查询
✍合并查询
✍修改
✍删除
📢数据库基础操作命令📢 ✍显示数据库 show databases; 注意这里的 database 是复数形式,需要 + s ✍创建数据库 create database if not exists da_name 数据库名称 (可选) character set charset_name 字符集名称 (可选) collate collation_name; 排序规则名称 if not exists - 如果不存在 此命令代表着如果不存在这个名称的数据库就会执行创建此库 当然后面俩行指定字符集和指定排序规则可以不用写, 如果在 MySQL 中创建数据库时不指定字符集和排序规则，MySQL 将使用默认的字符集和排序规则。在 MySQL 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e779ccf6e5e36abbaccc24bb638cfa35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18f49ebec658183f232a50d1b43bb00/" rel="bookmark">
			谷粒商城中使用人人开源发现的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用人人开源开发后台时发现代码依赖都正确但是运行时调用方法的地方爆红
导致的原因是lombok的版本和spring版本不一致导致的
因此修改renren-fast的pom
在properties中找到&lt;lombok.version&gt;修改如下
后即可正常运行（pom一直爆红不用管）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0efb6ee57859039a8c4409c29e96504/" rel="bookmark">
			CC2530串口收发数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZigBee/CC2530 发送数据 发送字符 void Send_Byte(unsigned char content) { U0DBUF = content; while(UTX0IF == 0); UTX0IF = 0; } 发送字符串 void Send_String(unsigned char *content) { while(*content != '\0') { Send_Byte(*content++); } } 接收数据 接收字符数据 #pragma vector = URX0_VECTOR __interrupt void URX0_ISR(void) { if(U0DBUF == 0xA1) P1_0 = !P1_0; } 接收字符串数据 unsigned char usart_rx_data_buffer[16]; //数据缓冲数组 unsigned char usart_buffer = 0; //数据缓冲字符 int usart_rx_index = 0, utx0if = 0; //串口数据接收索引 串口接收标识符 /* 数据接收中断，每次只能接收单字符，两个紧挨数据接收时间间隔较短，要注意的是在中断函数中接收数据缓冲区只能用单字符 */ #pragma vector = URX0_VECTOR __interrupt void URX0_ISR(){ usart_buffer = U0DBUF; utx0if = 1; } /* 清理缓冲区数据 */ void ClearData(){ usart_rx_index = 0; memset(usart_rx_data_buffer, 0, sizeof(usart_rx_data_buffer)); } /********************MAIN************************/ void main(void) { halBoardInit();//选手不得在此函数内添加代码 ConfigRf_Init();//选手不得在此函数内添加代码 while(1) { /* user code start */ //注意接收数据请不要加延时以免造成原数据被覆盖导致丢失数据 //判断标志位为1，已接收数据，可以读取 if(utx0if){ //清除标志位 utx0if = 0; //为数据接收缓冲区赋值，索引加1 usart_rx_data_buffer[usart_rx_index++] = usart_buffer; //数据缓冲字符区域清空 usart_buffer = 0; //判断接收到的字符串是否与下面条件成立 if(strcmp("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0efb6ee57859039a8c4409c29e96504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7ef481736cf3fa74741f5b95fc1472/" rel="bookmark">
			清理日志脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 打开终端（Linux或Mac平台），使用Vi或Nano等编辑器，创建一个新脚本文件，并设置相应的权限：
vi clean_logs.shchmod +x clean_logs.sh 2. 编写清理日志的命令，可以使用find命令查找一定日期以前的日志文件，并使用rm命令清理掉找到的文件：
#!/bin/bashlog_dir=/var/log/appexpire_days=30cd $log_dirfind . -mtime +$expire_days -type f -name "*.log" -exec rm -f {} \; 3. 上述代码将清理掉$log_dir目录下超过$expire_days天的，后缀名为log的所有文件。
4. 使用crontab命令，对这个脚本进行定时任务的设置。例如每天凌晨检查清理：
crontab -e 在文件底部添加如下一行命令：
0 0 * * * /path/to/clean_logs.sh 其中0 0 * * *表示每天凌晨执行，/path/to/clean_logs.sh表示脚本文件的绝对路径。根据需求可以修改对应的时间，例如0 2 * * * 表示每天凌晨2点清理日志。
5. 保存退出，定时任务设置完成。
使用上述方法，您就可以编写一个简单的定时清理日志的shell脚本，定时清理您的应用程序日志。注意备份所有重要日志文件。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/88/">«</a>
	<span class="pagination__item pagination__item--current">89/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/90/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>