<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcae09ac891c6840fcc8e7d28b98ca8c/" rel="bookmark">
			gibbs采样算法的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		马尔科夫过程：
构造一个马氏链，使得为平稳分布时，当t足够大，有：
有：
上式表明，从中采样一个样本的概率，等于前一时刻从分布中采到样本时,再从分布中采一个样本的概率。
因此，从中采样，等价于从采样。
问题转为，要选择一个合适的状态转移概率来构造马氏链，使得为平稳分布。
在满足以下细致平衡条件，状态转移概率构造的马氏链，可使得为平稳分布：
（充分不必要条件）
直接构造状态转移概率很困难，定义接受率：
其中可以是任意容易采样的分布。定义状态转移概率
，
可以证明，，满足细致平稳条件。
已有一个从分布的样本，可以从分布采样，作为下一个样本。如何从分布中采样？
直接从采样不容易，可以采用接受拒绝方法采样。从提议分布，再以为接受率来决定是否接受该样本。
从中采集样本，计算样本在分布下的概率，如果等于1,则保留该样本，否则，利用拒绝接受采样方法来决定是否保留该样本。
gibbs采样
当X为高维的随机变量时，定义
则接受率：
所以，gibbs采样是接受率恒等于1的MH采样。
无向图模型未归一化的概率分布：
，必须除以配分系数Z，才能获得有效分布
其中配分系数是未归一化概率所有状态的积分（或求和）：
由于难以通过解析法计算Z,可以用mcmc采样来计算Z的近似解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c7b58cf11fa13a59a3ee442c2dca4a/" rel="bookmark">
			无迹卡尔曼滤波_卡尔曼滤波家族
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写完了
David LEE：卡尔曼滤波：从入门到精通​zhuanlan.zhihu.com 之后一直说要写非线性情况下的推导。但后来想想，EKF不过就是做了一阶泰勒展开而已，要写成一篇文章实在是太短，感觉也没有太多干货，就一直没有动笔。最近在看 《概率机器人》，觉得关于贝叶斯滤波器确实也可以稍作总结，于是就写了这篇卡尔曼滤波家族。
本文对于扩展卡尔曼滤波、无迹卡尔曼滤波仅仅做了一些简要介绍，不再想上次的文章那样做详细地推导了。但只要看过之前写的卡尔曼滤波，相信这篇文章对于你来说也是很好理解的。
本文配图均来自《概率机器人》
扩展卡尔曼滤波 假设状态转移概率和测量概率分别由非线性函数g和h控制，而不再是一个线性变换： 这种情况下，由于线性变换的关系不在了，因此概率分布也不再是高斯分布。整个系统不再有闭式解，这是最让人头疼的。
而EKF 的主要思想就是线性化：通过一个在高斯函数的均值处与非线性函数g相切的线性函数来近似g。 线性化的主要优点就是效率，一旦对g和h进行了线性化，KEF和KF就是等效的。 EKF采用一阶泰勒展开的方式来进行线性化，其根据g的值和斜率构造一个函数g的线性近似函数： 线性点的选择依据的是在线性化点附近自变量最有可能的状态。对于高斯函数，最可能的状态自然就是后验的均值 ： 同理，将测量函数h线性化，有 最后，整个EKF算法的流程如下： 运动更新： 2. 测量更新 很显然，EKF 能否成功应用取决于两个因素： 被近似的函数的局部非线性化程度；概率分布自身的不确定度（协方差）。 上两图就明确展示了非线性函数在近似点非线性程度越高、概率分布本身越不确定，所得到的近似结果就越差。此时，采用扩展卡尔曼滤波的效果往往很差，甚至会导致发散。
无迹卡尔曼滤波 不同于EKF使用线性化来近似非线性函数，UKF通过无损变换来近似一个高斯分布，它通过使用加权统计线性回归过程来实现随机线性化。 下面就介绍些UKF无损变换的思想。
UKF明确地从高斯分布中提取 几个
点，并将这些 点经过函数g变换。这些 点分别位于均值处、对称分布于主轴的协方差处。对于具有均值 和协方差 的n维高斯分布，对应的2n+1个 点 根据如下规则进行选择： 其中， ， 是确定 点分布在离均值多远的范围内的比例参数（就是你的采样范围）。 每个 有两个与之相关的权值： 在计算均值时使用； 在计算高斯协方差的时候使用。 选择参数 对高斯分布的附加的高阶分布信息进行编码。如果概率分布是精确的高斯分布，则 。 然后， 点经过函数g变换，来探测非线性函数g如何改变了高斯分布的形状： 所得的结果高斯分布的参数 由映射的 点 获得： 将以上过程分别代入到运动更新和测量更新中就可以得到无迹卡尔曼滤波了。 运动更新 1. 计算 点： 2. 非线性函数映射 3. 进行运动更新 测量更新 1. 依据运动更新的结果计算新的 点 2. 计算每个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c7b58cf11fa13a59a3ee442c2dca4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eabff35d98ed8ec1e2e17f33285c652/" rel="bookmark">
			距离向量路由算法实现java_距离向量路由协议及优化链路状态路由协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、距离向量路由算
距离向量路由算法要求每个路由器维护一张距离表和路由表，并在表中给出到每个已知目的地的最短距离和路径。在距离表中，列表示和这个节点直接相连的邻居，表中的行表示目的节点，而表中的元素表示“距离”，“距离”可以是跳跃次数、时延或丢失的数据包的数量等。距离向量路由算法通过路由表之间周期性的交换数据来更新网络拓扑结构。
距离向量路由选择算法的缺陷：收敛时间较长是此路由选择算法所遇到的一个重要问题，网络收敛缓慢产生了相矛盾的路由选择条目，这种条件下数据包会一直在网络上循环发送，因此就产生了路由环路。
可用的解决方法有：
1、定义最大值
2、简单水平分割
3、带毒性的逆转水平分割
4、触发更新
5、抑制计时
实际中较常使用的是定义最大值、触发更新、抑制计时。
2、链路状态路由算法(Link State Routing)[2]
链路状态路由算法需要每个路由器保存一份最新的关于整个网络的拓扑结构数据库。
算法描述：
1、每个路由器与邻机会话。
2、每个路由器构建一个“链路状态包(Link-State Packets)”，包含邻机名字及费用。
3、LSP被传送到所有别的路由器，每个路由器都有其他路由器最新的LSP所有路由器都会根据搜集到的信息建立全网的拓扑数据库(L-S图)。
4、每个路由器计算出到每个目的地址的路由，建立路由表。
图表4 LSR泛洪法示意图
(同样的，路由器A在接收到路由器C的LSP后,同样会通过洪泛法转发来自路由器C的LSP)
计算路由的方法：
1、每个路由器根据其最新的链路状态包(LSP)构建链路状态数据库。
2、PATH由ID、路径代价、转发方向构成。
3、TENT由ID、路径代价、转发方向形式(可能的最佳路径)，当路径被证实是最佳的后，该节点将从TENT移到PATH中。
4、转发数据库，包括ID、转发方向。
每台路由器使用数据库构建一个完整的拓扑图并计算通向每个目的网络的最佳路径。就像拥有了地图一样，路由器现在拥有关于拓扑中所有目的地以及通向各个目的地的路由的详图。所有的路由器将会有共同的拓扑图或拓扑树，但是每一个路由器独立确定到达拓扑内每一个网络的最佳路径。
3、优化链路状态路由算法(OptimizedLink State Routing,OLSR)
在链路状态算法中，所有相邻的节点都会转发状态包。这样在相邻节点较多的情况下，泛洪开销较大；如果我们选择部分特定的节点泛洪转发数据包，使得网络中所有路由器同样可以收到数据包，可以大大减少泛洪开销，这就是OLSR算法的基本思想。
OLSR中的关键概念是多点转播(MPRs)，MPRs是在广播洪泛的过程中挑选的转发广播的节点。传统的链路状态协议每个节点都转发它收到信息的第一份拷贝，同它相比，OLSR很大程度上减少了转发的信息。在OLSR协议中，链路状态信息都是由被挑选为MPRs的节点产生的，这样减少了在网络中洪泛的控制信息，实现了第二步优化。第三步优化是MPR节点只选择在MPR或者MPR选择者之间传递链接状态信息。因此，同传统LS协议相比，在网络中分布着部分链路状态信息，这些信息将用于路由计算。
MPR的选择分为两步：
1、首先选择能够覆盖「孤立二跳邻居节点」的一跳邻居节点。这里孤立二跳邻居节点是指仅通过一个邻居节点同目标节点相连的二跳邻居节点；
2、在余下的一跳邻居节点中，按照覆盖二跳邻居节点的数量从高到低依次选择，直到覆盖所有的二跳邻居节点。
图表5 MPR选择算法
以图表5为例，首先二跳邻居节点为1、2、3、4、5、6、7，孤立二跳邻居节点为1、5，其对应的一跳节点为A、E,将A和E加入MPR列表中，此时1、2、3、5均被覆盖；在剩余的一跳节点中，将覆盖最多二跳节点的B加入MPR，然后是E，最后是G，在G加入MPR后，所有的二跳邻居节点都被MPR覆盖，此时MPR即为我们选择的MPR全集。
MPR表会通过Hello信息同步给下一跳邻居节点。这样每个节点能够建立本地的MPR Selector表，此表表明节点自己应该转发来自哪些节点的广播消息。
网络节点可能会经常性的撤销旧节点、增加新节点，网络拓扑结构也会因此改变，在OLSR算法中通过MPR节点周期性地泛洪拓扑控制(Topology Control,TC)消息来实现网络拓扑结构的维护。OLSR算法相比于LSR算法减少了泛洪开销，但也需要TC消息维护拓扑结构，增加了网络中的控制开销，并且固定的泛洪周期还会造成网络带宽的浪费。
为此，文献[3]提出了一种基于优化链路状态路由的低开销的拓扑维护算法。通过减少MPR节点的个数从而减少了TC消息产生的数量和转发次数；同时通过对比上一次发送周期的MPR选择集的变动情况，在不变量和删减量中选择较小的和新增量一起组成TC消息进行发送，最后根据网络拓扑的变化情况动态地调整TC消息的发送周期。仿真结果表明，该算法能有效降低网络的控制开销和端到端时延，提升网络的吞吐量。
参考文献 [1]王宏宇,李晗静．距离向量路由选择算法浅析[J]．智能计算机与应用,2003,000(003):16-17
[2]黄劲荣,李振坤,林穗．浅析两种分布式路由选择算法[J]．现代计算机(专业版),2004,000(011):81-83
[3]任智，周舟，吴本源，陈加林．基于优化链路状态路由的低开销拓扑维护算法[J]．计算机工程.https://doi.org/10.19678/j.issn.1000-3428.0059016
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7a4f79358f215b75ca8f07f3af0b7e7/" rel="bookmark">
			PyCharm中PyQt的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyCharm中PyQt的使用方法 简单说明本文范例软件安装PyQt及相关软件PyCharm中设定:QtDesignerPyCharm中设定: PyUIC (模块方式)PyCharm中设定: PyUIC (直接使用)PyCharm中设定: PyRCC在Qt Designer中新增资源文件总结一下 配置完PyCharmTools中已经有快捷方式打开Qt Designer则可以创建窗口，拖拽各种需要的控件保存的地址便是上面加ui的文件夹Qt Desinger中创建一个简单的界面保存为test.ui选中并且点选PyUIC、生成test_designed.pyA.如何使用这个生成的py文件呢？ 直接使用运行后如下图效果代码有两处告警提示 B.如何使用这个生成的py文件呢？ 继承方式引用中错误的处理方式选择Suppress for statement也可消除提示 题外话、修正自动生成的代码 简单说明 PyQt是Python与Qt的融合，做为Python的一个模块使用，有很多工具包。且Qt Designer可以快速的搭建应用程序的前台界面、类似Visual Studio的拖放操作，且可以配合PyCharm使用，让Python的开发效率更上一层楼。
本文范例软件 本文的前提是安装好了PyCharm以及Python(以下是范例中使用的版本)
PyCharm Community Edition 2020.2.1 x64Python 3.7.0 x32 安装PyQt及相关软件 pip install pyqt5 pip install pyqt5-tools pip install pyqt5-stubs 如果慢的话可以改用清华及其它的镜像地址
pip install 安装包 -i https://pypi.tuna.tsinghua.edu.cn/simple pip install pyqt5 -i https://pypi.tuna.tsinghua.edu.cn/simple PyCharm中设定:QtDesigner 完成后在PyCharm中设定QtDesigner以及PyUIC
QtDesigner
Name、Program、Working directory分别填入
#名称方便调用 QtDesigner #你的designer文件地址 C:\Python\Python37-32\Lib\site-packages\qt5_applications\Qt\bin\designer.exe #项目文件夹下ui文件夹内 $ProjectFileDir$\ui PyCharm中设定: PyUIC (模块方式) PyUIC这里有两种方式
一，以模块方式调用pyuci
Name、Program、 Arguments、Working directory分别填入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7a4f79358f215b75ca8f07f3af0b7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbb240db0a94dc129d06919e5b02ae8/" rel="bookmark">
			Module containing this breakpoint has not yet loaded or the breakpoint address not be obtained
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Module containing this breakpoint has not yet loaded or the breakpoint address not be obtained
gcc/g++ 加上-g选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8290727b51c1659d08ef96778f06682/" rel="bookmark">
			Python数字货币量化交易开发——绘图优化回测结果的可读性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 为验证回测的有效性和增强可读性，所以需要在完成回测时生成如matlab一样的图表。
_
_
Episode 3. 绘图优化回测结果的可读性 用到的库是数据分析常用的matplotlib库。
构思一下，应当分为2个子表，1个显示在时间轴中的买卖点，1个显示随时间推移的收益率曲线，所以在之前的main()函数中加入图表的生成部分。
time_x=[] price_y=[] rate_y=[] for i in range(begin_progress,max_step+1): time_x.append(step_dict[i]['time']) price_y.append(step_dict[i]['close']) rate_y.append((plot_data[i]['market_value']/ini_market_value-1)*100) plt.subplots_adjust(left=0.08,right=0.95,bottom=0.1,top=0.95) plt.figure(figsize=(18,9)) #数据图1 买卖标注 plt.subplot(211) plt.grid(axis='y') plt.xlabel('Time') plt.ylabel('Price') plt.title('Trade History') plt.xticks([]) plt.plot(time_x,price_y,color='c') for k,v in order_history.items(): if v[0] == 'buy': plt.plot(k, v[1]-1, '^', c ='red',label='买入点',markersize=10) plt.text(k, v[1]-6, 'buy') if v[0] == 'sell':	plt.plot(k, v[1]+1, 'v', c ='green',label='卖出点',markersize=10) plt.text(k, v[1]+3, 'sell') #数据图2 收益曲线 plt.subplot(212) plt.grid(axis='y') plt.xlabel('Time') plt.ylabel('Rate') plt.title('Profit Rate') plt.gca().yaxis.set_major_formatter(mtick.FormatStrFormatter('%.2f%%')) plt.xticks([]) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8290727b51c1659d08ef96778f06682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb92518e7cd3b74e98804d8fb30df9f8/" rel="bookmark">
			一、ubuntu16.04下无法连接wifi（试遍所有方法及解决方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：前一天正常使用，第二天突然没网，右上角网络标识无连接（非扇形），且不显示附近的wifi信息。
注：由于安装的是双系统不是虚拟机，在win下解决的方案未尝试。
操作１：
以前也遇到过，等等或者重启就好了，这次不想等，彻底解决一下。
操作２：更改NetworkManager值。
网络管理器(NetworManager)是检测网络、自动连接网络的程序，可以管理有线网络连接和无线网络连接。
1.#打开终端 2.cd /etc/NetworkManager #进入/etc/NetworkManager文件夹. 3.sudo vim NetworkManager.conf #编辑NetworkManager.conf文件 。 ４．#若有如下显示，将false改为true并保存 [ifupdown] managed=false 重启验证，操作２失败。
３. 操作３：从无线模块入手查看问题。
rfkill是一个内核级别的管理工具，可以打开和关闭设备的蓝牙和wifi。
博主rfkill list all后与该文一致，不多赘述。
rfkill list all#列出所有可用设备 sudo modprobe -r ideapad_laptop　#移除ideapad的无线模块 #在/etc/rc.local文件中添加命令sudo modprobe -r ideapad_laptop (个人认为该解决方案是不完整的，应该是更改模块开关权限，而非移除．轻喷)
与操作3同类型解决方案１（更全更详细，三种方法都试了，失败）
----后来才意识到这里有问题，没网，根本update不了。 至于其他帖子里没提如何在“没网”状态下就能update，、、、
与操作３同类型解决方案２
提示切换到root用户。尝试过，失败。
与操作３同类型解决方案３
sudo nano /etc/modprobe.d/blacklist.conf #在最后一行添加： blacklist acer-wmi 尝试过，失败。
４. 操作４：命令行连接wifi。
ifconfig#查看网络信息 ip addr sudo iw dev#查看无线设备 sudo iw dev wlan0 link#检查无线设备情况（假设无线网卡是wlan0） sudo ip link set wlan0 up#开启无线设备电源： sudo iw wlan0 connect [essid]#连接wifi（根据essid连接就是无线名） sudo dhclient wlan0#通过DHCP获取IP地址 尝试过，失败。（不识别wlan命令，未安装对应依赖）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb92518e7cd3b74e98804d8fb30df9f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98fff00f27c3def2032bed71c8e51a7/" rel="bookmark">
			使用Token请求数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Token?原文 token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。简单token的组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。 2.为什么要用Token? Token 完全由应用管理，所以它可以避开同源策略Token 可以避免 CSRF攻击（跨站请求伪造）
1.验证 HTTP Referer 字段（记录了 HTTP 请求的来源地址，存在被黑客篡改的可能）
2.在请求地址中添加 token 并验证（所有请求中加入token的字段，麻烦）
3.在 HTTP 头中自定义属性并验证（在请求头中加入token）
axios.defaults.headers.common[‘Token’] = tokenMessage;Token 可以是无状态的，可以在多个服务间共享 3.基于token机制的身份认证（流程） 客户端使用用户名和密码请求登录。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。客户端每次向服务端发送请求的时候都需要带上服务端发给的token。服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。(如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。) 4. cookie 和session的区别原文 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。
3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
考虑到减轻服务器性能方面，应当使用COOKIE。
4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
5、所以个人建议：
将登陆信息等重要信息存放为SESSION
其他信息如果需要保留，可以放在COOKIE中
5.token和cookie 1.在安全性方面，token 能防止 csrf 攻击。
2.在扩展性方面，token 可以处理多端的身份验证，不仅仅局限于浏览器，只要客户端能对 token 进行储存就行。
3.token 在跨域共享资源上表现惊艳，只要不同域的服务器之间约定好签名规则，大家都是一家人！
4.token 可以携带丰富的用户信息，只要不怕别人知道，你想传什么随你便！
5.Cookie 大小4KB，Cookie过期时间一般为1个月。
6.关于token，session，cookie的概念和区别 1.token是 服务经过计算发给客户端的，服务不保存，每次客户端来请求，经过解密等计算来验证是否是自己下发的
2.session是服务本地保存，发给客户端，客户端每次访问都带着，直接和服务的session比对
3.cookie是保存在客户端上的一些基本信息，服务不保存，每次请求时客户端带上cookie，里面有一些账户密码，浏览记录什么的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31ec35d339104912f49b3431bb6d05b/" rel="bookmark">
			pintos实验三文档_《计算机网络:自顶向下方法》Wireshark实验二：HTTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wireshark实验官方网站：知乎 - 安全中心
在Wireshark实验一里，我们已经初步使用了Wireshark分组嗅探器，我们现在可以操作Wireshark来查看网络协议。在这个实验中，我们会探索HTTP协议的几个方面：基本的GET/response交互，HTTP报文格式，检索大的HTML文件，检索具有内嵌对象的HTML文件，HTTP鉴别和安全性。在开始这些实验之前，您可能需要复习书中第2.2节。
一、基本的HTTP GET/response交互 我们开始探索HTTP，方法是下载一个非常简单的HTML文件，非常短，并且不包含内嵌对象。执行以下操作：
1）启动您的浏览器。
2）启动Wireshark分组嗅探器，如Wireshark实验-入门所述（还没开始分组捕获）。在display-filter-specification窗口中输入“http”（只是字母，不含引号标记），这样就在稍后的分组列表窗口中只捕获HTTP报文。（我们只对HTTP协议感兴趣，不想看到其他所有的混乱的分组）。
3）稍等一会儿（我们将会明白为什么不久），然后开始Wireshark分组捕获。
4）在浏览器中输入以下内容 http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html 您的浏览器应显示非常简单的单行HTML文件。
5）停止Wireshark分组捕获。
注释：你的Wireshark窗口应该类似于图1所示的窗口。如果你无法连接网络并运行Wireshark，您可以根据后面的步骤下载已捕获的数据包：
下载zip文件 http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip
解压缩文件 http-ethereal-trace-1。这个zip文件中的数据是由本书作者之一使用Wireshark在作者电脑上收集的，并且是按照Wireshark实验中的步骤做的。 如果你下载了数据文件，你可以将其加载到Wireshark中，并使用文件菜单选择打开并查看数据，然后选择http-ethereal-trace-1文件。 结果显示应与图1类似。（在不同的操作系统上，或不同的Wireshark版本上，Wireshark的界面会不同）。
图1中的示例在分组列表窗口中显示了两个被捕获的HTTP消息：GET报文（从您的浏览器发送到http://gaia.cs.umass.edu 的web服务器）和从服务器到浏览器的响应报文。分组内容窗口显示所选报文的详细信息（在这种情况下为HTTP OK消息，其在分组列表窗口中高亮显示）。回想一下，因为HTTP报文被装载在TCP报文段内，该报文段被装载在IP数据报中，该IP数据报又被装载在以太网帧中，所以界面中显示了帧，以太网，IP，TCP各个部分的分组信息以及HTTP报文信息。我们想最小化非HTTP数据的显示（我们这里只对HTTP感兴趣，其他协议将在以后的实验中研究），所以需要将帧，以太网，IP和TCP行的信息隐藏。注意左边有一个加号或一个向右的三角形（这意味着有信息被隐藏），而HTTP行具有减号或向下三角形（表示显示有关HTTP报文的所有信息）。
（注意：您应该忽略与favicon.ico相关的任何HTTP GET和response。 如果你看到一个关于这个文件的引用，这是你的浏览器自动询问服务器是否有一个图标文件应显示在浏览器的URL旁边。 我们会忽略这个引起麻烦的引用。）
通过查看HTTP GET报文和响应报文中的信息，回答以下问题。 在回答以下问题时，您应该打印出GET和响应报文（请参阅Wireshark-入门实验以获取信息），并指出您在消息中的哪个具体位置找到了回答以下问题的信息。 当您上交作业时，请注明输出，显示您在哪些地方表示了您的答案（例如，对于我们的课程，我们要求学生用笔标记纸质副本，或用彩色字体在电子副本的中注释文本）。
1）您的浏览器是否运行HTTP版本1.0或1.1？服务器运行什么版本的HTTP？
答：HTTP/1.1；HTTP/1.1。
2）您的浏览器向服务器指示了它能接受哪种语言（如果有的话）？
答：
3）您的计算机的IP地址是什么？ http://gaia.cs.umass.edu服务器地址呢？
答：192.168.3.4；128.119.245.12。
4）服务器返回到浏览器的状态代码是什么？
答：200。
5）服务器上HTML文件的最近一次修改是什么时候？
答：
6）服务器返回多少字节的内容到您的浏览器？
答：
7）通过检查分组内容窗口中的原始数据，你是否看到有协议头在分组列表窗口中未显示？ 如果是，请举一个例子。
答：否
在您对上述问题5的回答中，您可能会惊讶地发现您刚才检索的文档在下载文档之前最近一次修改是一分钟前。 那是因为（对于这个特定文件）http://gaia.cs.umass.edu服务器将文件的最后修改时间设置为当前时间，并且每分钟执行一次。 因此，如果您在两次访问之间等待一分钟，则该文件看起来已被修改，因此您的浏览器将下载文档的“新”副本。
二、HTTP的条件Get/response交互 回顾书的第2.2.5节，大多数Web浏览器使用对象缓存，从而在检索HTTP对象时执行条件GET。执行以下步骤之前，请确保浏览器的缓存为空。（要在Firefox下执行此操作，请选择“工具” - &gt; “清除最近历史记录”，然后检查缓存框，对于Internet Explorer，选择“工具” - &gt;“Internet选项” - &gt;“删除文件”；这些操作将从浏览器缓存中删除缓存文件。 现在按下列步骤操作：
启动您的浏览器，并确保您的浏览器的缓存被清除，如上所述。启动Wireshark分组嗅探器。在浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html 您的浏览器应显示一个非常简单的五行HTML文件。再次快速地将相同的URL输入到浏览器中（或者只需在浏览器中点击刷新按钮）。停止Wireshark分组捕获，并在display-filter-specification窗口中输入“http”，以便只捕获HTTP消息，并在分组列表窗口中显示。（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-2数据包跟踪来回答以下问题；请参见上文注释。） 回答下列问题：
8）检查第一个从您浏览器到服务器的HTTP GET请求的内容。您在HTTP GET中看到了“IF-MODIFIED-SINCE”首部字段吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b31ec35d339104912f49b3431bb6d05b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b4293547ca85a57bc82c78b03d3128/" rel="bookmark">
			输入寄存器和保持寄存器区别_发那科机器人应用-数值寄存器 R[]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数值寄存器R
数值寄存器指令 数值寄存器指令是进行寄存器的算术运算的指令。数值寄存器用来存储某一整数值或小数值得变量（有关数值寄存器， 见 7.3 节）。标准情况下提供有 200 个数值寄存器。 R[i] =（值） R[i] =（值）指令，将某一值代入数值寄存器。 R［ｉ］＝ 值 数值寄存器号码 （１～２００） 常数 ＧＩ［ i ］：组输入信号 R［ i ］：数值寄存器[i]的值 PR［ i ， j ］：位置寄存器要素[i, j]的值 AR［i］ ＧＯ［ i ］：组输出信号 ＡＩ［ i ］：模拟输入信号 ＡＯ［ i ］：模拟输出信号 ＤＩ［ i ］：数字输入信号 ＤＯ［ i ］：数字输出信号 ＲＩ［ i ］：机器人输入信号 ＲＯ［ i ］：机器人输出信号 ＳＩ［ i ］：操作面板输入信号 ＳＯ［ i ］：操作面板输出信号 ＵＩ［ i ］：外围设备输入信号 ＵＯ［ i ］：外围设备输出信号 TIMER［ i ］：程序计时器[i]的值 TIMER_OVERFLOW［ i ］ ：程序计时器[i]的 溢出旗标 ０：计时器没有溢出 １：计时器溢出 ＊计时器溢出旗标通过 TIMER[i]＝复位的指令被清除。 图 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1b4293547ca85a57bc82c78b03d3128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67dbc2a4133671e2a437daf4473292a1/" rel="bookmark">
			js高级 第二天 数据/变量/内存 内存图 变量在内存中 变量的赋值 函数传参 声明全局变量的三种方式 回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js高级 第二天 文章目录 js高级 第二天数据/变量/内存内存图变量在内存中变量的赋值函数传参声明全局变量的三种方式回调函数 数据/变量/内存 数据：计算机中的数据以二进制表示，比如00101 变量： 1.可变的量 2.存储数据的容器 3.在内存开辟的空间 内存： 通电开机时，内存产生 关机断电时，内存消失 内存和硬盘的区别： 内存：临时存储空间 读取速度快 存储空间小 硬盘：永久存储空间 读取速度慢 存储空间大 内存,数据, 变量三者之间的关系 * 内存用来存储数据的空间 * 变量是内存的标识，在内存中，数据是通过变量进行处理 内存图 内存图分区： 栈：保存基本数据类型 存储的数据类型	number/string/boolean/null/undefined 特点：后进先出 堆：保存的是复合数据类型 存储的是 对象/数组/函数 代码区：存储代码 变量在内存中 基本数据类型：在内存中，变量保存的是数值
var a;//声明变量 开辟空间 a = 2;//赋值 将值存到空间a中 console.log(a); 复合数据类型：在内存中，变量保存的是地址
var obj = { name:"尼古拉斯*刘能", sex:"公" } console.log(obj); 变量的赋值 基本数据类型：赋值时，变量传递的是：数值
var b = 3; var c = b; console.log(b,c); 复合数据类型：赋值时，变量传递的是地址
var obj = { name:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67dbc2a4133671e2a437daf4473292a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f988ce689b3e2c0b6a776ed47e4ff3c/" rel="bookmark">
			（六）UVC基本框架代码分析 --转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（六）UVC基本框架代码分析 --转
转载地址：https://www.cnblogs.com/blogs-of-lxl/p/5118384.html
仿照内核的自带UVC（usb video class）驱动程序写的一版简化驱动，仅供学习，实际项目开发中应该尽量使用内核自带的驱动，除非内核自带的驱动不支持此款硬件才需要自己写驱动。
下面就直接上代码了，要根据自己的设备信息修改相关配置参数。
#include &lt;linux/kernel.h&gt;
#include &lt;linux/list.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/usb.h&gt;
#include &lt;linux/videodev2.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;linux/wait.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;asm/atomic.h&gt;
#include &lt;asm/unaligned.h&gt;
#include &lt;media/v4l2-common.h&gt;
#include &lt;media/v4l2-ioctl.h&gt;
#include &lt;media/videobuf-core.h&gt;
#include “uvcvideo.h”
#define sheldon_UVC_URBS 3
/* Values for bmHeaderInfo (Video and Still Image Payload Headers, 2.4.3.3) */
#define UVC_STREAM_EOH (1 &lt;&lt; 7)
#define UVC_STREAM_ERR (1 &lt;&lt; 6)
#define UVC_STREAM_STI (1 &lt;&lt; 5)
#define UVC_STREAM_RES (1 &lt;&lt; 4)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f988ce689b3e2c0b6a776ed47e4ff3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e239a13f07d18d84e54326121c79bd8a/" rel="bookmark">
			工业光源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工 业 光 源 工业光源 工业光源 可见光是电磁波谱中人眼可以感知的部分人眼可以感知的电磁波长在380—780纳米
一 光谱图 二 颜色合成及互补 物体反射和它颜色接近的光，吸收和它颜色相反的光
三 光源的必要性 （选择合适的形状、颜色、角度的光源,通过主动光源照明,把需要的特征表达出来,而干
扰的特征能够抑制掉）
干扰必然存在 干扰介绍材质检测对象的材质的变化，造成光学特性的变化，使得图像信息发生变化。一致性检测对象在生产制造的过程中因为制造工艺的问题而造成产品的一致性不佳，使得图像信息发生变化。杂光检测设备所处的位置可能存在外界环境光的干扰，使得检测效果随着环境光的变化而变化。环境检测对象的材质的变化，造成光学特性的变化，使得图像信息发生变化。 四 光源的作用 好的照明就是将特征与背景信息做到最佳最稳定的分离。
不可能有一种光源可以满足所有的检测需求。
一定是根据检测需求来设计照明系统的，当需求变化时，照明系统未必适用。
提高对比度增加均匀性消隐背景增加一致性 五 光源基本种类1 LED光源的优势
寿命长:使用寿命约30000小时,
亮度高:可以使用多个LED达到高亮度
照明稳定:直流供电，没有频闪。
灵活:同时可组合不同的形状
功耗低:耗电低
指向性好:光线照射方向性好
响应快:能达到10us
颜色多:可以选择各种不同的颜色的灯珠
六 光源基本种类2 七 光源控制器的作用 1.通常工业光源的供电为24v，可以直接使用24V光源点亮。但在实际使用中都会采用专用的光源控制器。
2.光源控制器可以控制光源的亮度，实现高速频闪的功能,保证照明的稳定性及延长光源的寿命。
3.光源控制器分为模拟控制和数字控制。
模拟控制:使用电位器调节光源的亮度。 数字控制:可精确设定亮度的数值，可使用远程控制的方式实现光源亮度的调节。 八 技巧 背光源放置与待测物体的正下方，相机垂直于待测物和光源拍照。可以获得轮廓边界清晰的图片。
光源面积够用即可,面积过大会影响边缘效果。光源离物体远一些，更接近与平行照明，边缘更锐利一些。配合远心镜使用效果更好。
光线从正上方打向待测物体，平面的部分会反光形成明场，而高低起伏的部分，光会发散，进不了相机，形成暗区域。多用于细节的观察和表面高低不平的伤缺、划痕。
正面高角度打光的均匀性调节有一定的难度。成像的效果靠的是反光特性，不同材质的物体，反光特性差异很大。
光线从侧面以很低的角度打向待测物体，平面的部分因为反光形成暗场，而不平整的部分，光的反射杂乱会进入相机，形成亮区域。多用于有一定高低起伏的轮廓特征的提取。
光线从各个方向均匀的照射到待测物体上，使得层次复杂的物体能够获得均匀的照明。
同轴光照明
特点:类似于平行光的应用，光源前面带漫反射板，形二次光源,光线主要趋于平行。
用于半导体、PCB板、以及金属零件的表面成像检测，微小元件的外形、尺寸测量。(同轴光源，平行同轴光源)
颜色过滤和加强
利用待测物不同的颜色，通过互补或者相同颜色的照明可以把需要的特征强化和消除。
互补色照明,该颜色会变暗。同色照明，该颜色会变亮。
九 红外和紫外 红外
红外光源有很强的穿透性,能穿透较薄的塑料、液体和纺织物。但无法穿透金属物体。常用于金属物体探测。
紫外
紫外光源有很好的荧光效应和散射效应但波长较短的紫外光对人体会有伤害，因此在食品行业和某些特殊应用场合。
十 光源选型步骤 Step 1:根据物体的特征和检测要求，构想期望的照明效果。
Step 2:根据打光的基本原理，设计合适的照射角度、距离和颜色。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e239a13f07d18d84e54326121c79bd8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f80d13dad09bd6ab47033747a7c9105/" rel="bookmark">
			SpringBoot整合Redis,使用RedisTemplate存取List集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本文仅对使用RedisTemplate操作list(对象)集合过程中遇到的一些问题，进行记录。
SpringBoot版本：2.2.2.RELEASE
Redis版本：3.2.1.0.0
导入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; SpringBoot为我们操作Redis提供了两个API，StringRedisTemplate(默认采用的是StringRedisSerializer序列化策略)、RedisTemplate&lt;String,Object&gt;（默认采用的是JdkSerializationRedisSerializer序列化策略），前者主要是对key value都是字符串的数据进行操作，后者的value可以放对象。本质上StringRedisTemplate继承的是RedisTemplate&lt;String,String&gt;。
使用默认的序列化策略JdkSerializationRedisSerializer操作集合对象List。 @SpringBootTest(classes = RedisstuApplication.class) class Test01 { @Autowired private RedisTemplate redisTemplate; @Test void testRedisTemplate(){ ListOperations&lt;String,User&gt; listOps = redisTemplate.opsForList(); User user = new User("李四",18,new Date()); ArrayList&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(user); userList.add(user); listOps.leftPushAll("users",userList); List&lt;User&gt; lists = listOps.range("users", 0, -1); lists.forEach(x-&gt; System.out.println(x.getUserName()+"=="+x.getBir())); } } 控制台看出可以正常获取对象。但是可视化工具里面可以看出实际存储的是JDK序列化后的数据。
使用Jackson2JsonRedisSerializer序列化规则操作集合对象。 修改RedisTemplate默认的序列化配置。修改后key使用StringRedisSerializer序列化规则，value使用Jackson2JsonRedisSerializer序列化规则。 package com.pec.redisstu.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f80d13dad09bd6ab47033747a7c9105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af36cd7495c6bbad501fd8fed5e91e86/" rel="bookmark">
			机器学习pdf_2020年新书-《机器学习算法入门》免费pdf分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本书介绍
一种最常见和最广泛使用的机器学习模型是线性回归。线性回归是一种非常直观的监督学习算法，顾名思义，它是一种回归技术。这意味着当我们有连续值的标签时，例如汽车价格或房间温度，就会使用它。此外，正如它的名字所暗示的那样，线性回归寻求的是对线状数据的模糊处理。这是什么意思？
本书最新免费pdf下载地址： 个人主页“私信”，回复关键字“nmln”获取下载地址。
想象一下，你收到了一个由汽车组成的数据集，其中每辆汽车的行驶里程数以及价格。在这种情况下，让我们假设您正在尝试训练一个机器学习系统，该系统接收关于每辆车的信息，即行驶里程数及其相关价格。这里，对于给定的汽车，行驶里程是输入，价格是输出。该数据可以表示为(X，Y)坐标。
本书目录
内容截图
本书免费pdf下载地址
个人主页“私信”，回复关键字“nmln”获取下载地址。
往期精品内容推荐
个人主页点击“私信”，回复关键字“his”获取文章地址。
最近几年-基于深度学习自然语言处理的推荐系统-必读论文整理分享
机器学习基础教材-《数据驱动的科学与工程-机器学习、动态系统与控制》免费pdf分享
Fast.ai-《程序员深度学习实战课程2020》最新视频分享(带中英双字幕)
2020年新书-《神经网络新手入门必备数学基础》免费pdf分享
2020年AI统计学新书-《数据科学、机器学习、人工智能基础》免费pdf分享
机器学习经典书籍-《贝叶斯推理与机器学习》免费分享
NLP必读圣经《自然语言处理综述》2020最新版免费分享
深度学习架构论文3-批量标准(BN)减少内部偏移加速模型训练
自然语言处理任务相关经典论文、免费书籍、博客、tf代码整理分享
机器学习基础-《统计学习-SLT》教材分享
斯坦福大学《分布式算法与优化》课程(2020)视频及ppt免费分享
李宏毅-《深度学习人类语言处理2020》中文视频课程及ppt分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfad97615a58291bc80322be96b0f533/" rel="bookmark">
			C4D随笔录——“实例”生成器运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C4D—“实例”生成器是个奇怪的东西，跟克隆一样，但又支持旋转。
操作：
1、创建个box，然后C掉，随便编辑。我这里把它的XYZ的分段式都改成2，每一块随便添加颜色
2、然后点击“实例”
把立方体拖到“实例”图层——对象——参考对象中。
没拖动之前，实例图层是打叉的。
这时候“实例”就是复制出来的一个立方体
3、随便编辑原来的立方体，然后实例也跟着改变，这时候可以多添加有几个“实例”，添加之后默认是复制立方体。
4、这时候旋转原来立方体与“实例”都互不影响，但是“实例”都不能编辑或是修改大小，只能是原立方体才能修改，修改之后会影响其他“实例”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9235191e803d1f2e8e637363ca86eed6/" rel="bookmark">
			MySQL基础语法使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 使用方法简单教程
目录
MySQL 使用方法简单教程 1
1、启动MySQL服务器 1
2、进入mysql交互操作界面 1
3、退出MySQL操作界面 1
4、第一条命令 1
5、多行语句 2
6、使用SHOW语句找出在服务器上当前存在什么数据库： 2
7、创建一个数据库abccs 2
8、选择你所创建的数据库 3
9、 创建一个数据库表 3
10、显示表的结构： 3
11、查询所有数据： 4
12、修正错误记录： 4
14、 多表操作 5
1、查看第一个表mytable的内容： 5
2、创建第二个表title（包括作者、文章标题、发表日期）: 5
3、多表查询 6
15、增加一列： 6
16、修改记录 6
17、增加记录 7
18、删除记录 7
再显示一下结果： 8
19、删除表： 8
21、数据库的备份： 8
22、用批处理方式使用MySQL: 8
23. 请先用root登录到mysql,方法： 9
24.创建一个用户 9
chinacodec 2010-08-08 18:01:00 99840 收藏 45
展开
1、启动MySQL服务器 实际上上篇已讲到如何启动MySQL。两种方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9235191e803d1f2e8e637363ca86eed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73399b1f479c705812d0d5a85dfbaa3f/" rel="bookmark">
			h5模型转pb转tflite实现及报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		h5模型转pb转tflite实现及报错解决 这里我已Mask R-CNN训练出来的模型为例，我的h5文件不保存模型结构，我的代码有转为带结构的h5文件。话不多说，直接上代码。
def save_model(path): """ 将训练的仅保存参数的h5文件转换为将整个model结构及参数保存的H5 model :param path: h5 model path :return: """ test_config = InferenceConfig() model = MaskRCNN(config=test_config, mode="inference", name="strip", model_dir=root) model.load_weights(path, by_name=True) model.keras_model.save('maskrcnnstrip.h5') def to_pb(): with K.get_session() as sess: export_path = '../logs/saved_model' builder = tf.saved_model.builder.SavedModelBuilder(export_path) signature_inputs = { 'input_image': tf.saved_model.utils.build_tensor_info(model.input[0]), 'input_image_meta': tf.saved_model.utils.build_tensor_info(model.input[1]), 'input_anchors': tf.saved_model.utils.build_tensor_info(model.input[2]), } signature_outputs = { 'mrcnn_detection': tf.saved_model.utils.build_tensor_info(model.output[0]), 'mrcnn_class': tf.saved_model.utils.build_tensor_info(model.output[1]), 'mrcnn_bbox': tf.saved_model.utils.build_tensor_info(model.output[2]), 'mrcnn_mask': tf.saved_model.utils.build_tensor_info(model.output[3]), 'ROI': tf.saved_model.utils.build_tensor_info(model.output[4]), 'rpn_class': tf.saved_model.utils.build_tensor_info(model.output[5]), 'rpn_bbox': tf.saved_model.utils.build_tensor_info(model.output[6]), } classification_signature_def = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73399b1f479c705812d0d5a85dfbaa3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db16fd5975e6cf4fae295ca119ce61fb/" rel="bookmark">
			vue中@click与@click.native，及其vue事件机制的分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue维护了自己的事件机制。
所以就有了原生DOM事件和自定义事件的区别，比如下面这段官网原话。
用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。
本文也将围绕这一句话展开。
想必大家都会在自定义组件中自定义事件。
&lt;my-component v-on:my-event="doSomething"&gt;&lt;/my-component&gt; 那么如何给自定义组价添加原生事件呢，其实想一想理论上是不可行的，因为自定义组件最终不会渲染到页面上，怎么加？
所以Vue给自定义组件绑定原生事件的做法是：把原生事件绑定到组件的根节点，根节点就只有一个嘛…
但是你要告诉vue，当前要给原生节点绑定DOM事件，而不是自定义事件。如下：
&lt;!-- 以下无论你怎么点击hello都不会触发父组件的事件的 --&gt; &lt;!-- 除非加上@click="$emit('click')"，也就是触发自定义事件 --&gt; &lt;template&gt; &lt;div class="hello"&gt; hello &lt;/div&gt; &lt;/template&gt; &lt;template&gt; &lt;div id="app"&gt; &lt;HelloWorld msg="Welcome to Your Vue.js App" @click="clickEvent"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; methods: { clickEvent(){ console.log('事件触发') } } &lt;/script&gt; 或者直接简单的使用.native。
&lt;HelloWorld msg="Welcome to Your Vue.js App" @click.native="clickEvent"/&gt; 好了，你已经了解了.native的用途。接下来，再说一说原生节点绑定自定义DOM事件。直接看代码如下：
&lt;template&gt; &lt;div id="app" @customizedEvent="myEvent"&gt; &lt;HelloWorld msg="Welcome to Your Vue.js App"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import HelloWorld from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db16fd5975e6cf4fae295ca119ce61fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c70344e67e7dd85158b0854ddd1a726a/" rel="bookmark">
			Python可视化库Pandas_Alive，动态图表随意做
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的文字及图片来源于网络,仅供学习、交流使用,不具有任何商业用途,如有问题请及时联系我们以作处理。
以下文章一级法纳斯特 ，作者小F
前言 最近发现汉语中类似的一个可视化图库「Pandas_Alive」，不仅包含动态条形图，还可以绘制动态曲线图产品，气泡图，饼状图，地图在等。
同样也是几行代码就能完成动态图表的替换。
GitHub地址：
https://github.com/JackMcKew/pandas_alive 使用文档：
https://jackmckew.github.io/pandas_alive/ 安装版本建议是0.2.3， matplotlib版本是3.2.1。
同时需自行安装tqdm（显示进度条）和descartes（放置地图相关库）。
要不然会出现报错，估计是作者的requestment.txt没包含这两个库。
好了，成功安装后就可以约会这个第三方库，直接选择加载本地文件。
import pandas_alive as pd import pandas covid_df = pd.read_csv（'data / covid19.csv'，index_col = 0，parse_dates = [ 0 ]） covid_df.plot_animated（filename = 'examples / example-barh-chart.gif'，n_visible = 15） 生成了一个GIF图，具体如下。
刚开始学习这个库的时候，大家可以减少数据，这样生成GIF的时间就会快一些。
例如在接下来的实践中，基本都只挑选了20天左右的数据。
对于其他图表，我们可以查看官方文档的API说明，得以了解。
下面我们就来看看其他动态图表的替换方法吧！
动态条形图 elec_df = pd.read_csv（“ data / Aus_Elec_Gen_1980_2018.csv”，index_col = 0，parse_dates = [ 0 ]，千元= '，'） elec_df = elec_df.iloc [：20，：] elec_df.fillna（0）.plot_animated（'examples / example-electricity- generation -australia.gif'，period_fmt = “％Y”，title = '1980-2018年澳大利亚发电来源'） 02动态柱状图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c70344e67e7dd85158b0854ddd1a726a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0f4adb5f9ec45580954a3cfb1b44cc/" rel="bookmark">
			对一个ArrayList的元素去重,元素类型为自定义对象.请给出自定义类的关键代码和去重算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.自定义类中关键代码 //User类中的equals方法 @Override public boolean equals(Object o) { User user = (User) o; return age == user.age &amp;&amp; Objects.equals(name, user.name); } 二.去重算法----选择排序 ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;(); //去除ArrayList重复元素 for (int i = 0; i &lt; list.size() - 1; i++) { for (int j = i + 1; j &lt; list.size(); j++) { if (list.get(i).equals(list.get(j))) { list.remove(list.get(j)); j--; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3103c79faba9170b822e2e6429093e53/" rel="bookmark">
			号称offer收割机，涨薪必备技能——Spring全家桶：文档&#43;面试题&#43;学习笔记&#43;思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。
Spring框架自诞生以来一直备受开发者青睐，今天在这里分享的是一套Spring全家桶集合。其中包括了Spring、SpringBoot、SpringCloud、SpringMVC四个实战文档，以及Spring面试文档，都是经过BAT实战精选过的重点内容。当然，这必然是一个痛苦而又漫长的心路历程，请你拿出把妹的勇气和毅力。（注：有需要这份Spring全家桶的朋友可以一键三连之后添加上小助手微信：bj070701快速获取）
《Spring原理部分》 Spring特点Spring核心组件Spring常用模块Spring主要包Spring常用注解Spring第三方结合Spring I0C原理Spring APO原理Spring MVC原理Spring Boot原理JPA原理Mybatis缓存Tomcat架构 《SpringBoot核心笔记》 《SpringCloud Alibaba笔记》 微服务介绍微服务环境搭建Nacos Discovery--服务治理Sentinel--服务容错Gateway--服务网关Sleuth--链路追踪Rocketmq消息驱动SMS- -短信服务Nacos Config服务配置Seata--分布式事务Dubbo--rpc通信 《SpringMVC实战开发及源代码文档》 SpringMVC实战开发目录及部分内容：
spring mvc核心类与接口spring mvc核心流程图spring mvc DispatcherServlet说明spring mvc双亲上下文的说明springMVC-mvc.xml配置文件片段讲解spring mvc如何访问到静态的文件,如jpg,js,css ?spring mvc请求如何映射到具体的Action中的方法?spring mvc中的拦截器:spring mvc如何使用拦截器?spring mvc如何实现全局的异常处理?spring mvc如何把全局异常记录到日志中?如何给spring3 MVC中的Action做JUnit单元测试?spring mvc转发与重定向spring mvc处理ajax请求spring mvc关于写几个配置文件的说明spring mvc如何取得Spring管理的beanspring mvc多视图控制器&lt;mvc:annotation-driven /&gt;到底做了什么工作 SpringMVC源代码目录及部分内容展示：
Spring面试文档 一、 基本概念面试题集( Spring 相关概念梳理)
二、应用场景面试题集(各知识点不同使用场景选型)
三、深度度知识面试题集(底层实现原理详解)
四、拓展内容面试题集(Spring Boot相关题集)
1.谈谈对Spring loC的理解?
2.谈谈对Spring DI的理解?
3. BeanFactory接口和ApplicationContext接口不同点是什么?
4.请介绍你熟悉的Spring核心类，并说明有什么作用?
5.介绍- -下Spring的事务的了解?
6.介绍一下Spring的事务实现方式?
7.解释AOP模块
8. Spring的通知类型有哪些，请简单介绍一下?
9. Spring通知类型使用场景分别有哪些?
10.请介绍一-下你对Spring Beans的理解?
11. Spring有哪些优点?
12.在Spring中使用hibernate的方法步骤
13. Spring和Struts的区别?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3103c79faba9170b822e2e6429093e53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/637c129162d6e449466b2ff696736a5c/" rel="bookmark">
			IDEA Scala报错 ”cannot access XXXXX“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
File --&gt; Invalidate Caches/Restart --&gt; Invalidate and Restart
亲测有效，idea重启下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c4c057943240d8b958884f5b257357/" rel="bookmark">
			虚拟机winserver-2016添加的新磁盘没有操作权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机winserver-2016添加的新磁盘没有操作权限，无论是添加磁盘还是删除磁盘都没有权限 主要是在策略里检查配置问题：
1. win + R 输入 gpedit.msc
2.计算机配置----&gt;管理模板----&gt;系统----&gt;所有可移动存储类 或者其他磁盘存储 ---&gt;启用 点击应用 确认
如图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4543a8b64946056e2112d73c73bd049/" rel="bookmark">
			B端产品经理是一种什么样的存在？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：产品一二一 微信公众号：产品一二一 （转载已取得作者授权）
作为一名产品汪，说来惭愧，接触过的产品书籍不多，而且大部分只是简单翻过。称得上整体翻看下来的，更是屈指可数，比如：
苏杰：《人人都是产品经理》
后显慧：《产品的视角——从热闹到门道》
刘志远：《电商产品产品经理宝典——电商后台系统产品逻辑全解析》
唐韧：《产品经理必懂的技术那点事儿》
这些书籍都在我的不同阶段，给过我不同程度的启发和指导。但因为我一直做的to B的产品，在我的当前阶段，感觉共鸣最多、解决了我许多疑惑、期待继续深入挖掘的，要属这本：
李宽：《B端产品经理必修课——从业务逻辑到产品构建全攻略》
怀揣着“将作者的产品干货学为己用”的初心，这份笔记心得，努力呈现书中20%的精益思想。相信你可以在这里，找到你想知道的B端产品经理那些事儿。
文章内容较长，以下是目录，方便大家定位到自己感兴趣的内容。
一、如何定义B端产品
1. B端产品 B端产品可以为公司的管理服务，如：HR系统、OA系统；也可以为公司的运营服务，如：供应链系统、ERP系统的。
不论哪种，其终局都是为企业流程效率服务，让分散的、低效的个体，更好地连接合作，发挥集成化的、系统化的更大作用。
相较于C端产品，B端产品最大的特点是：面向特定领域用户，且数量少得多，但更注重对用户专业领域操作流程的深度挖掘——也就是专业性更强，与业务的结合更紧密。
2. B端产品经理 B端产品经理重点关注：如何解决业务痛点？在业务逻辑的基础上，如何调度各类角色，提升各角色的工作效率、以及互相配合的流畅度？
正因为如此，做好B端产品经理的基础是：需要极其熟悉所属业务，否则工作容易浮于表面，甚至无从下手。
B端产品经理工作：
B端产品经理技能树：
要掌握的技能虽多，但不是每一种都需精通，可借鉴“二八原则”：真正重要的知识，或者在实践中被反复使用的知识，只占全部知识的20%。也就是说，20%的知识是需要反复修炼形成骨架的，剩下的80%在此基础上不断更新迭代。
总的来讲，在我看来，产品的核心能力是：能抓住问题本质，可提出合理解决方案，并将之执行落地的能力。
B端产品经理职业生涯：
一般产品经理的职业发展路径这张表可以作为产品对自己当前阶段的参照比对，也可以作为迈向下一阶段的方向指引。
B端产品经理的终局：
产品经理的职业成功之路，是成为某个领域的产品专家，而做B端产品经理是一条成功率极高的路。
因为进入某一领域做B端产品经理，需要具备某一领域的行业知识——即有入门槛。因此，B端产经理的职业发展容易形成护城河，更易成为某一行业的B端产品专家。
作者的这个论点，相信可以视为很多B端产品同行的福音。
二、各阶段的产品方法总结
1. 规划阶段
竞品调研：
调研方法：
B端产品经理的一个痛点是很难找到竞品。切入方法有：
明确查询方向后再起步。
从跟业务同事的沟通中发掘竞品。
通过专有名词进而搜索更多资料。
通过试用渠道体验竞品。拓宽搜索渠道：百度、谷歌是首选，知乎、简书找文章思路，知网、万方找专业信息。
调研结论：
竞品分析报告，应包括：行业发展状况，“有哪些竞品？”，竞品使用者和特性的描述，自己的产品与竞品之间的比较，通过分析得到的结论和信息等。
商业需求文档，应包括：产品创意产生的背景、产品或解决方案介绍、产品规划、产品成本、产品收益、产品风险等。
用户调研：
调研方法：
用户访谈的一般流程：请教——刨根问底——核实，具体为三段式问法。
发现问题：你正在做什么申请？做的过程中有什么不舒服的地方吗？遇到了什么问题？
分析流程：你现在用什么方法来解决这个问题？
探索机会：为了更好地解决这个问题，你认为有什么办法能帮到你？或者哪些地方可以优化一下？
调研结论：
用户调研报告，应该包括：对使用者的描述、通过分析得到的结论等。
产品规划：
战略规划整体分三步走
分析和预测需求：了解用户的期望，以及限制条件。
现状分析：用户已经从现有功能中得到什么，是否满意。
缩小差距：采取什么手段可以缩小未来（期待）与现状的差距。
具体产品路线可落地为:
需求分析：
需求应有的特征：
痛点：好的需求犹如根治用户痛处的良药。B端产品通过调研用户基本可提炼出痛点。
收益：需求应有可量化的结果导向。
明确、可行、简单的第一步：挖掘需求就是降低需求中的含混性，使之明确。如果在需求落地成型阶段才发现含混性，这个时候的改正成本实在是太高了。
需求可行性=（需求的当前价值+未来价值）/（需求的实现成本+维护成本）
解析需求：
探索需求的重要方式是以数据驱动的思路去探索业务。因为行为产生数据，数据联系（指导）行为。比如：用户下单产生订单（数据），订单传递给库房的生成人员指导他们发货。
用图形（流程图、实体关系图、数据流程图、用例图）来明晰业务和需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4543a8b64946056e2112d73c73bd049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d12d7d59b01e477e3be1c4b1b39bdb/" rel="bookmark">
			关于UEditor销毁，还原原来标签的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于UEditor销毁，还原原来标签的问题 主要是我在想设计一个textarea的点击展示ueditor，点击个保存还原成textarea的功能，查找了挺多博客，想找这个销毁的功能，官网文档跳来跳去，就是跳不出github，网上搜了destroy()方法压根不管用，最后自己看的源码
//这个方法渲染一个id 为 editor的标签 变成ueditor Ueditor.ue = UE.getEditor('editor'); //销毁靠这个 UE.delEditor('editor'); 靠这个，我们就可以实现光标focus时展示ueditor，保存（自己新增的tool按钮）或失去时还原
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c1f9b62f8fa2a619d4ea5b11c060f5/" rel="bookmark">
			MyBatis：Error evaluating expression ‘‘‘‘. Return value () was not iterable错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出错原因：xml文件中遍历List 时，该参数的实际值为非List数据。
&lt;foreach&gt;遍历的不是数组或集合，看了xml，原本没有加不等于空字符串，加上后解决！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d096d024cfa6fcc1172ba2a69e32f8/" rel="bookmark">
			多个蓝牙音箱同步app_用Bose的两台蓝牙音箱播放时，我能“听音辨位”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在不少的年轻人手中都会有那么一个蓝牙音箱，用来听听歌，不用像以前那样用线材连接那么麻烦，打开蓝牙就可以连接手机、平板、电脑等播放设备。而我手上的Bose蓝牙音箱用起来也差不多，除了用来连手机之外，偶尔还会用来连下笔记本。
后来在网上看到有人体验Bose SoundLink系列的派对模式和立体声模式，心血来潮的我不禁想到，这么好玩的东西为什么不体验一下呢？在向朋友借了几台SoundLink系列蓝牙音箱之后，马上开始了这次的体验。
本次体验的“主人公”是Revolve+系列，因为我本身就有一个黑色的Revolve+，所以我是非常想感受下它们组成的派对模式和立体声模式会有怎样的表现？往深一层讲，在Revolve+那么多特点种，我非常喜欢的360°环绕立体声如果由两台Revolve+来播放，会产生怎样的“奇妙反应”？
在体验派对模式和立体声模式之前，首先要在手机了下载安装Bose的官方APP，Bose Connect。它可以说是Bose非常经典的一款APP了，能适配Bose的大多数产品，无论是耳机还是蓝牙音箱。
安装好APP和准备好两台Revolve+后，先用手机连接其中一台的Revolve+，这时候把另外一台Revolve+设置为(蓝牙)配对状态，两台Revolve+就连接在一起组成派对模式了，在APP上也会有相关的显示，整个操作流程基本上没什么难度，即使是初次使用派对模式的我也很快就弄完了。
经过一番体验之后，我基本清楚派对模式和单个音箱有什么不同了，它相当于把两台蓝牙音箱的播放完全同步了，两者在同时放同一首歌，但带来的音量是成倍地增加，用来听一些带节奏感的低频音乐是再合适不过了。此外，回到“派对模式”的本意上，它本身就是为举行派对而准备的，把它们各自放到客厅或户外的对角位置，两者的声音基本能覆盖现场空间。
立体声模式同样也是可以在APP上开启，刚开始我还以为立体声模式和派对模式没啥区别，后来体验之后发现两者的区别还是蛮大的，例如当两台音箱在播放时，派对模式相当于一台音箱完全“复制”了另外一台音箱，两者播放的内容、音量等完全是一样的。而立体声就不同了，当在播放时，两台音箱分别担任音源输出的左、右声道，两者播放的内容并不完全是一样的，就跟我们的耳机播放时差不多。
在立体声模式下，两台音箱输出的左右声道其实是组成了一个小小的立体声声场，当把它们分别分在我左右耳的侧前方时，立体声和声音定位的感觉就非常明显了，你能明显感觉周围的声音都带有方向感，像我就非常喜欢用立体声模式来听人声流行曲、看电影和玩游戏。
经过这次的体验之后，我发现Bose的产品中真的有很多隐藏的功能点等着我们去发掘。在感受到立体声的魅力之后，我还有了购买第二台SoundLink蓝牙音箱的想法，无论是在家或在室外都可以轻轻松松组建派对或立体声模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3eadf253e32989972d3796e822a33e4/" rel="bookmark">
			virtio驱动_VIRTIO &amp;amp; VHOST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在虚拟化领域，virtio 随处可见。当前，virtio 可以加速 IO、network子系统。
在 IO 子系统，主要有 virtio-blk, virtio-scsi。同时，有 vhost 相关的 vhost-blk, vhost-scsi, vhost-nvme 这些。
看起来东西很多很乱，其实只要理解了本质，就可以轻松化解如此多virtio*让人困扰的问题了。
本质是什么呢？本质就是 virtio 的数据结构，以及操作。
virtio基本结构 virtio 的基本数据结构是一个 ring，这个 ring 是一段连续的内存。有了一段内存，就可以为所欲为了。
virtio 把这段内存分成3个部分，依次是 desc，avail，used。每一块是一个数组，可以顺序索引。他们的元素个数是一样，也就是是 ring 的 长度。 virtio &amp; vhost数据流动 以VHOST为例，来解释一下数据是如何流动的：
client（qemu）创建共享内存，然后通过ioctl与内核通信，告知内核共享内存的信息，这种就是kernel作为server的vhost；或者通过Unix domain来跟其他的进程通信，这叫做vhost-user。下面以Unix domain为例。Unix domain可以使用sendmsg/recvmsg来传递文件描述符，这样效率更高一些；client创建好共享内存，发送描述符到server，server直接mmap这个描述符就可以了，少了一个open的操作。Client和Server可以有多段共享内存，每段之间不连续。每一段都是一个vring。Client初始化好每一段共享内存vring，Server不用初始化。Client发送vring的desc，avail，used这些地址给server，然后server在重新mmap之后，可以根据这个地址算出desc，avail，used这些在server用户进程的地址，然后就可以直接读写了。注意，由于数据指针是client地址，在Server处理读的时候需要转换。读写：以net为例，两个vring，一个tx，一个rx共享内存存放desc，avail，used这些信息，以及avail-&gt;idx, used-&gt;idx这些信息。当client写的时候，数据放在vring-&gt;last_avail_idx这个描述符里，注意last_avail_idx、last_used_idx这两个值，在client和server看到的是不一样的，各自维护自己的信息，作为链表头尾。添加id到avail里面，shared.avail.idx++。注意，client此处的last_avail_idx指向的是描述符的id，而不是avail数组的id，这个跟Server上的last_avail_idx的意思不一样。为什么这样做呢？ last_avail_idx 表示可用的数据项，可以直接拿出来用，用完之后，取当前的next;当回收的时候，也就是client在处理used的时候，可以直接插入到last_avail_idx的前面，类似链表插入到表头；Server收到信号后，从自己记录的last_avail_idx开始读数据，读到avail-&gt;idx这里，区间就是[server.last_avail_idx, shared.avail.idx)。Server处理每处理完一条请求，自己的 last_avail_idx ++; 同时插入 id 到 used 里面，插入的位置是 shared.used.idx，然后 shared.used.ix+ +。used.idx此时就像avail-&gt;idx一样，表示最新的used的位置。Server通知client处理完数据后，client就可以回收used的描述符了，可回收的区间是[client.last_used_idx, shared.used.idx)。Kickfd，callfd都是在client创建，然后通过unix domain发送给server。client通知server叫kick。 Vhost是什么 virtio offload到host叫做vhost。可以在内核态或者用户态实现。在内核态的实现主要在Linux的kernel实现。
kernel代码位置：drivers/vhost Vhost作为字符设备使用，来与qemu进行交互。跟其他的很多driver一样，利用ioctl。vhost-net 驱动会创建一个名为 /dev/vhost-net 的字符型设备，当 QEMU 通过-netdev tap,fd=,id=hostnet0,vhost=on,vhostfd=这样的参数启动时，QEMU 会打开这个设备（你可以通过 lsof -p $PID 查看，$PID 为 QEMU 的进程号）并通过 ioctl 初始化设备。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3eadf253e32989972d3796e822a33e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e2a79863b7fb5a2b35d4e3da2be8e40/" rel="bookmark">
			SoftRoCE实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 SoftRoCE是RDMA的一种纯软件实现的方式，因此不需要特定的硬件支持，但是其性能与硬件支持的RDMA还是有一些差距的。通过softRoCE我们可以在传统的以太网进行RoCE通信。自4.9.0之后的内核已经内置sofrRoCE驱动，我们直接使用即可。
环境搭建 实验环境 ServerClientubuntu 18.04ubuntu 18.04kernel 5.4.0kernel 5.4.0x86x86 安装相关软件 sudo apt-get install libibverbs-dev librdmacm-dev rdma-core #备注 - libibverbs-dev - Development files for the libibverbs library - librdmacm-dev - Development files for the librdmacm library - rdma-core - RDMA core userspace infrastructure and documentation 联通测试 1.在server端和client端创建RoCE interface：
sudo rxe_cfg start sudo rxe_cfg add enp3s0 成功后出现： 2. 测试前准备
查看rdma设备：
ibv_devices ibv_devinfo 3.开始测试
采用rping命令
#server: rping -s -a [server-ip] -v -C 10 #client: rping -c -a [server-ip] -v -C 10 测试结果（server）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e2a79863b7fb5a2b35d4e3da2be8e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2973d82e26f6677610652e0da75b8c05/" rel="bookmark">
			串联滞后校正对系统的影响_固相萃取超高效液相色谱串联质谱法测定水体中4种解热镇痛类药物...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		色谱 2020, Vol. 38 Issue (12): 1465-1471
DOI: 10.3724/SP.J.1123.2020.07002
朱峰, 姚志建, 霍宗利, 吉文亮, 刘华良, 周庆, 李爱民, 焦伟, 谷静*
固相萃取-超高效液相色谱-串联质谱法测定水体中4种解热镇痛类药物 近年来，环境水体中出现的药物及个人护理品污染物受到人们越来越多的关注，其中就包括解热镇痛类药物。传统的固相萃取材料对水体中解热镇痛类药物的富集效率较低。为此，开发了一种亲水亲脂型的双亲多孔吸附聚合物材料(GCHM)。以N-乙烯基吡咯烷酮和二乙烯基苯为原料，利用乳液胶束-分步反应法成功制备出GCHM。基于自主研发的固相萃取柱，采用超高效液相色谱-串联质谱技术，建立了水体中4种解热镇痛类药物的检测方法。水样经GCHM固相萃取柱富集净化后上机检测，以0.1%(v/v)甲酸水溶液和乙腈作为流动相进行梯度洗脱，目标分析物在ACQUITY UPLC® HSS T3色谱柱(100 mm×2.1 mm，1.8 μm)上实现分离，在电喷雾正离子模式下进行多反应监测(MRM)，内标法定量。比较Oasis HLB、Bond Elut Plexa和GCHM 3种固相萃取柱的富集效率，结果表明GCHM固相萃取柱总体效果最优。在不同pH值下比较了GCHM固相萃取柱对目标分析物的富集效果，并对基质效应进行了评估。结果表明，当pH为7时，4种目标分析物在固相萃取柱上的富集效果最好；各物质的基质效应均在82.8%~102.2%之间，表明水样经GCHM固相萃取柱净化后，基质去除明显。4种目标分析物在1~100 μg/L范围内线性关系良好，相关系数(r)均大于0.995，方法定量限(S/N=10)在1~5 ng/L之间，在3个加标水平下的回收率均在85.6%~106.4%之间，相对标准偏差(RSD)均低于5.6%。GCHM固相萃取柱成本低，效果好，适用于水体中4种解热镇痛类药物的检测，较商品化的进口固相萃取柱具有潜在的优势，值得推广应用。
解热镇痛类药物主要分为非甾体类药物和甾体类糖皮质激素类药物, 常被用来退热、抗炎、镇痛、抗风湿等, 例如吡罗昔康能减轻不同关节炎的疼痛以及治疗术后炎症。 该类药物不能全部被机体吸收, 通过人体排泄的方式以原型药物或代谢药物的形式进入环境水体中, 不易降解, 且具有较强的生物毒性和富集性。 近年来, 解热镇痛类药物的研究多集中于中成药的非法添加、兽药的非法添加、茶叶等食品的非法添加以及生物样本的检测, 鲜有检测环境水体中解热镇痛类药物的文献报道。 美国EPA-1694方法中仅涵盖了一种解热镇痛类药物。环境水体中药物的残留质量浓度很低, 一般都在ng/L水平, 通常需要通过富集浓缩才满足仪器的检测需求。 目前, 环境水体中的痕量药物残留通常采用固相萃取法、分子印迹法、磁性固相萃取法等进行富集浓缩, 其中固相萃取技术的使用最为广泛。 该方法不仅富集倍数高, 且操作简单、方便, 但固相萃取柱价格相对较高。 课题组基于前期工作, 以亲水性的N-乙烯基吡咯烷酮(NVP)以及疏水性的二乙烯苯(DVB)作为原料, 将NVP、DVB和2-乙基乙烯苯共聚制得一种亲水亲油型的双亲性聚合材料(GCHM), 并将此材料填入装有筛板的SPE管中, 从而获得GCHM固相萃取柱, 成功用于水体中4种解热镇痛类药物的富集浓缩, 不仅成本低且效果好。 目前, 解热镇痛类药的检测手段主要有表面增强拉曼光谱法、薄层色谱法、电化学传感器、液相色谱法、液相色谱-质谱联用法。 其中液相色谱-质谱联用法具有灵敏度高、定性能力强的特点, 因此, 更适合于水体中痕量解热镇痛类药物的检测需求。 本文建立了环境水体中4种解热镇痛类药物残留的超高效液相色谱-串联质谱法检测技术, 并比较了基于课题组自主研发的固相萃取柱和商业化的固相萃取柱。结果表明, 本方法简单方便、成本低、效果好, 适合环境水体中痕量水平解热镇痛类药物的检测。 液相色谱条件 分析柱为ACQUITY UPLC® HSS T3色谱柱(100 mm×2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2973d82e26f6677610652e0da75b8c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dfd2cdf3f00df198cb9193c0906b084/" rel="bookmark">
			python实现搜索引擎，数据检索项目：职业查询系统（基本的搜索引擎&#43;爬虫拉勾网职业数据库），搜索引擎可以学习用户的标记，职业网站爬虫生成数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 信息检索小组项目，队友已同意上传
用spider爬拉钩网站
排序文档基于tfidf和cosine相似性
从搜索历史和用户标记的相关和不相关的结果中学习IDE规则方法，优化结果
基于Tkinter的UI
标准登录模块
主搜索窗口与页面切换
这里我只放出我贡献相关的部分，原文为英文，懒得翻译就机翻一下，文末给出文件链接
正文 数据处理搜索引擎 我们遵循基本的管道，并实现了排名搜索引擎与一些经典的算法，我们已经研究过。
首先，我们将每个记录中的元素组合成字符串，并将这些字符串作为文档。 然后我们标记它们。 中文文本需要通过分词来获得单个单词，所以我们导入jieba库来对我们从抓取数据的结果中得到的中文数据进行标记。 杰巴库是一个优秀的中文分词第三方库。 解巴库分词原理：用一个汉语词库来确定汉字之间的相关概率，汉字之间概率较高的单词形成短语形成分词结果。
杰巴库提供了三种分割模式：1)精确模式，返回没有冗余的列表式分词结果。 2)Full模式，返回具有冗余的列表类型分词结果。 3)搜索引擎模式返回一个列表类型的分词结果与冗余，细分较长的单词。 在这里我们选择精确的模式。 此外，我们还使用nltk来标记英语数据，如果有的话。 然后用nltk删除英文的stopword，哈尔滨工业大学中文的stopword列表。 为了将具有相同含义的单词结合起来，对于英语，我们在nltk中使用porterstemmer；对于汉语，HITIR-LabTongyiciCilin(Extended)可以在未来使用，但在这里我们不做汉语同义词合并。 然后，我们将每个文档中单词的频率计数成一个频率矩阵。 接下来，我们用归一化计算tfidf矩阵。 tfidf矩阵是tf矩阵和idf矩阵的乘法结果。 计算tf矩阵为，其中f为频率矩阵。 以国防军是关于整个语料库的，计算为，其中N是所有文档的数量，分母是包含这个术语的文档数量。
我们为数据库存储tfidf矩阵，并读取我们的搜索引擎每次启动，所以除了第一次，我们不必计算它。 计算需要时间。 以色列国防军也储存起来进行后续计算。
用户标记为相关或无关的查询和记录首先与记录相同，计算tfidf，但对整个语料库使用存储的IDF。 然后用标准rocchio公式：
a为1 b为0.75 y为0.25
新query=第一条query+b标记的所有相关记录的和-y标记的所有不相关记录和
，生成一个带有权重的新查询，对查询和标记的记录列表进行处理。 如果选择无历史记录的简单搜索模式，则跳过此步骤，直接使用查询频率向量。
最后，计算了数据库的加权查询与TFIDF矩阵之间的余弦相似度。 然后执行快速排序。 快速排序主要是利用分治思想。 也就是说，首先将原问题划分或缩小为较小的子问题，然后递归或迭代求解子问题，最后合成子问题，得到原问题的解。 最后，我们得到了具有文档索引及其相似性分数的排序列表。然后我们回去，通过索引找到文档并显示它们。
图4。 我们系统的管道
UI和运行 我们在python中使用tkinter来构建我们的用户界面。 我们使用pickle来序列化用户信息。 我们做了一个标准登录系统的完整功能，我们有登录和注册功能，我们有验证，处理任何无效的操作。
图5.6。 登录窗口
主窗口上方是输入框和按钮，左边是记录用户标记的按钮，右边是显示结果的表格。 在左侧底部，我们还提供了页面快速显示更多的结果。、
图7。 简单的搜索与“阿里巴巴杭州2000人以上”
我们的用户可以通过点击左边的按钮将文档标记为相关和无关的，我们的系统可以从记录中学习。 例如，如果我们选择第11条记录作为相关的记录，那么我们使用学习搜索时的结果如图8所示。 请注意，我们的学习搜索没有考虑到当前的输入。
图8。 学习了搜索例子
注意事项：
数字，例如5到10年，小行将被消除，因为停止词和两个数字将成为一起。 所以，我们必须确保数字之间至少有一个空格，我基本上在标记之前用一个空格替换这些空格。
识别信息的重复性可能会影响我们的结果。 例如，每个公司都有一个独特的名称和一个独特的公司ID，所以当我们的系统从标记的文档中学习时，它会从中学到更多的东西，这意味着重复的识别在学习时会有更高的权重，从其他角度来看，同一公司比同一信息更有可能上升排名。
评价：
我们缺乏政府标准。 当我们试图在我们的系统和拉古网站上使用一些示例查询并进行比较以评估我们的结果时，由于我们的数据集相对于整个拉古数据库来说相对较小，它显示出问题，许多相关记录出现在我们的数据库中。 当我们的数据库接近拉古数据库时，我们将来可能会做有意义的评估。 但我们仍然在这里展示了一些评估方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dfd2cdf3f00df198cb9193c0906b084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676c64f5877a29febbdd8d9d4d3554d4/" rel="bookmark">
			使用Spring Data Neo4j操作Neo4j数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Neo4j是目前最为流行的图数据库，如何在Java中对其进行简单的节点操作呢？Spring Data Neo4j为我们提供了方便的接口对Neo4j进行简单的操作。
引入依赖 在Spring Boot中使用Spring Data Neo4j首先需要引入依赖，使用maven进行管理如下
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt; &lt;/dependency&gt; 接着配置neo4j数据库的连接，在其中指定数据库uri、用户名和密码
# neo4j配置 spring.neo4j.uri=bolt://localhost:7687 spring.neo4j.authentication.username=neo4j spring.neo4j.authentication.password=123456 定义实体类 定义一个电影的实体类如下，首先通过@Node注解声明这是图数据库中的一个节点，指定节点名称为“Movie”。
接着利用@Id注解指定主键，@Property指定名为“tagline”的属性.
通过@Relationship指定类型为"ACTED_IN"、"DIRECTED"的关系，该关系默认指向List定义的Actor节点，也可以自己对关系进行定义。只要将一个Actor对象添加到actors的List中，就会自动创建指向本节点的关系。
@Node("Movie") public class Movie { @Id private final String title; @Property("tagline") private final String description; @Relationship(type = "ACTED_IN", direction = Direction.INCOMING) private List&lt;Actor&gt; actors = new ArrayList&lt;&gt;();	//自定义Actor关系 @Relationship(type = "DIRECTED", direction = Direction.INCOMING) private List&lt;Person&gt; directors = new ArrayList&lt;&gt;();	//默认指向Person节点的关系 private Integer released; public Movie(String title, String description) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676c64f5877a29febbdd8d9d4d3554d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bdfe7c1166328eb4fadd9c699c8abaa/" rel="bookmark">
			Arcgis连接sql server发布地图服务详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arcgis+sql server发布地图服务详解 1.ArcGIS中创建企业地理数据库 通过ArcGIS创建一个地理数据库至SQLServer数据库中。
1、需要有一个登陆ArcGIS的管理员账号，可以是sa，必须要有足够的权限：1）允许连接到数据库引擎 2）允许远程连接服务器
2.使用ArcGIS创建企业级地理数据库，比如创建TEST数据库至SQLServer中
1）数据库平台：SQL_Server
2)实例：指的是你连接的数据库地址，我是本地所以是127.0.0.1，也就是下面红框中的内容：
3）数据库：TEST，是在SQL_Server中为ArcGIS准备的数据库名称
4）数据库管理员：SQL_Server的管理员账号
5）地理数据库管理员：ArcGIS管理员的账号
6）授权文件：ArcGIS10.2授权文件地址:链接：https://pan.baidu.com/s/1JdHLdjLEZ8Ma6Uoyw1y2MA
提取码：1xlu
3.OK后就可以在SQL_Server中看到用GIS创建的地理数据库了。
可以参考：
1: https://blog.csdn.net/miss_yingHao/article/details/88826465?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160777196316780277882473%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160777196316780277882473&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v29-3-88826465.nonecase&amp;utm_term=arcgis%E5%88%9B%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5sql%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1&amp;spm=1018.2118.3001.4449.
2: https://blog.csdn.net/nju_zjy/article/details/81332975?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160777214519725271022915%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160777214519725271022915&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v29-6-81332975.nonecase&amp;utm_term=arcgis%E5%88%9B%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1&amp;spm=1018.2118.3001.4449.
2.Arcgis server下载 要在ArcGIS中创建服务，需要先下载ArcGIS Server，下面阐述以下怎么下载ArcGIS Server:
ArcGIS for Server可用于创建和发布自己的地图服务。
ArcGIS Server的用途：http://www.esri.com/software/arcgis/arcgisserver
（一）所需文件
(1)ArcGIS Server10.2 安装文件。
(2)ArcGIS Server10.2 授权文件。
链接：https://pan.baidu.com/s/1PyDKbIrqg6B7dqcznG5Fyw 密码：q5rn
解压后，授权文件Arcgis_Server_10.2.1.ecp 也在其中。
（二）安装&amp;授权
1.我的arcgis server 是安装在用户名为Administrator账户下的。首先需要激活win10下的该账户，在【开始】菜单下找到cmd 右击选择【以管理员身份运行】，在命令行下输入net user administrator /active:yes
2.设置Administrator用户的登录密码。右击【此电脑】-【管理】-【本地用户和组】-【用户】 右击选择Administrator 设置密码。
————————————没有附中的问题请跳到3————————
（附：可能会出现找不到本地用户和组的情况，原因是使用的操作系统是win10家庭版，win10家庭版相比于win10专业版缺少了很多功能，win10家庭版不支持“本地用户和组”，于是本人把家庭版进行了一下升级，升级到专业版。）
如何升级操作系统？ 鼠标桌面右击—显示设置—关于—Windows规格—“更改产品密钥或升级Windows”—更改产品密钥。 把产品密钥粘贴进去就OK啦，按步骤操作，系统自动进入升级状态。 从网上找了许多产品密钥，试过之后，密钥有效的很少，接下的第一个密钥是亲测有效的，希望能帮助到大家。
产品密钥（亲测有效）：J7QT3-3GCPG-9GVWT-CH2XR-GMRJM
产品密钥（尚未测试）：VK7JG-NPHTM-C97JM-9MPGT-3V66T
注意！！！ 系统升级完成之后就结束了吗？并没有，我们还需要查看一下升级后的系统是否已激活？
如何查看系统是否已激活？（推荐第二、三种） 第一，控制面板—系统和安全—系统—Windows激活—Windows已激活；（可能只是表面上显示已激活，实则有失效日期，没有将过期时间直接呈现给我们用户） 第二，Windows+R—输入cmd—输入命令slmgr -dlv，稍等一会儿，系统自动弹出一个框。 如果有批量激活过期（比如：7天）字样，说明系统没有完全激活，如果没有这样的字样，那恭喜你，已经完全激活啦。 第三，Windows+R—输入cmd—输入命令winver，如果没有显示过期时间字样，那同样恭喜你，系统已永久激活。 当系统显示未激活状态，我们应该如何解决呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bdfe7c1166328eb4fadd9c699c8abaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a7746fd1620fc83c4f44f62cc80e96/" rel="bookmark">
			操作系统原理_操作系统原理解析与ucore（开篇介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天开始，我将为大家在公众号持续更新一个新的专题 《操作系统原理解析与ucore》 ，而这个专题的开启也标志着我们的公众号也将要进入正轨，做真正的技术分享。我知道这将会是一条艰难的路，但是我会尽我所能，给大家分享能让大家真正学到东西、有所收获的内容。我的小伙伴也会分享一些其他领域的内容，同时也欢迎大家分享自己的学习心得和学习建议。 决定更新这个专题有以下几个原因： 1、我本人在研究生阶段的研究方向为操作系统方向，因此在操作系统基本原理和实现的学习上必须不遗余力，打好根基。尽管之前我已经学习过操作系统以及ucore但是毕竟是为了应付考试，舍弃了其中相当一部分的内容。而现在，os成为了我的方向，我便必须要直面挑战了。弄懂ucore的全部核心代码并且能够将其深入浅出的解析出来对我来说必然是一个重大的挑战，但是如果我可以做到，那么我必然能够获益匪浅。 2、我的公众号目前的关注主体主要为考研er，而对各位来说，无论是迎战408还是912亦或者是其他cs高校的专业课，操作系统都是必须要迈过去的坎。与实实在在的“计算机组成原理”、完全存在于抽象中的”数据结构”不同，操作系统是抽象与具体的结合产物，因此，操作系统本身的存在就显得更加飘忽不定、难以理解，很多人对于操作系统的认识都是一种很模糊的感知，甚至只是对几个诸如“银行家算法”、“PV操作”等孤立知识点的强行记忆，却缺乏一种整体化的感知，更遑论实现。在越来越飘忽不定的计算机命题趋势下，这种浅层次的孤立理解显然难以在以后的考试中取得优秀的成绩，因此，实实在在的理解操作系统究竟是什么，如何具体工作就至关重要。而对于计算机科学来说，代码是最精确、最实实在在的东西，当你真正能够理解代码的时候，你就准确把握了问题本身。 3、选择ucore是因为ucore是我比较熟悉的东西，主体编程语言也是大家都比较熟悉的C语言。如果大家能够在我的解析下深刻理解了ucore本身，那么便可以发挥自己的能力，对ucore进行扩充，而这就可以解决考研党们普遍存在的没有项目的窘境。要知道，操作系统项目在当今环境下是具有极高的含金量的，本人也正是凭借对ucore的扩展在清华计算机系学硕的面试中取得了一个不错的分数最终得以录取。 4、CSer乐园不仅仅是cs考研党的乐园，更应该是所有喜爱计算机这个领域的同道们的乐园。所以我也希望通过这个专题，结识更多对操作系统有兴趣的朋友，一起互相借鉴学习，扬长避短，共同进步！ 下面我就谈谈如果你要学习操作系统、研究操作系统必须分清的最根本的东西： 第一，是要分清视界与实际内容的区别。 何为视界，何为实际内容？先举一个生活中的例子吧。比方说你是一个企业的总公司的老板，你的电脑上存储着企业所有员工的名单，你的一切调配都可以通过在电脑上修改表格来实现，表格对你来说就是视界，而由于你的级别足够高，你对视界的修改也会对应到现实中的具体操作，所以你看到的视界实际上是现实内容的一种对应。 同样的道理，操作系统作为整个计算机系统的“大老板” ，它可以观测到计算机上所有进程、内存、文件等的视界，例如进程控制块、文件控制块等，操作系统从视界中获取信息，然后命令 硬件进行实际的操作，最后再根据操作的内容修改视界，这就是操作系统管理计算机的逻辑。 所以os源码充斥着数据结构的修改+内联汇编，便是这种视界 与实际 操作交替的逻辑 。 第二，是要分清哪些工作属于软件功能，哪些工作属于硬件功能。 我们学习的操作系统，从本质上来说还是一种软件，因此硬件系统对我们来说更多的是一种黑盒子的功能，我们必须对这一点有很清晰的认识。例如中断的实现，系统根据 IDTR(一个特定寄存器)中存储的地址寻找到IDT(中断描述符表)的初始地址，再根据触发中断的类型(例如时钟中断)给出特定的中断号(每一种中断类型对应的中断号是硬件决定的而不是软件)，利用该中断号便可以在IDT中找到对应的中断描述符从而进行中断服务例程了。在这个过程中，IDT如何填写，中断服务例程如何实现，则是我们需要编写的软件功能。分清软件和硬件，是正确认识操作系统的一个根本要求。 操作系统中还有很多我们需要去掌握，去认识的东西，现在的我甚至我的老师也不敢说全盘掌握。但是我希望能够在学习与分享的过程当中，与大家一起去享受剖析知识、深入本质的乐趣，这无论对于我还是对于大家来说可能都是一个不小的挑战，但是正是因为有挑战，我们的努力才更有意义，不是吗？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0164e7feda2f299dc714df9843c710e8/" rel="bookmark">
			multiprocessing.pool  中pool.map 传多个值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 在如今讲究速度的年代，单线程干活已经满足不了我们了，所以多线程干活肯定跑不了，下面讲一下，python中multiprocessing 中的线程使用，且传多个值的方法。 思路： 这个方法 是没发一次传多个值的所有我们这一个值的话传一个集合。
格式：item=[(1,2,3),(3,4,5),(6,7,8)]
代码 from multiprocessing.pool import ThreadPool def p(item): (x,y,z)=item print(x,y,z) if __name__ == '__main__': pool = ThreadPool(2) item=[(1,2,3),(3,4,5)] # item=list(itertools.product(range(10), range(10), range(10))) pool.map(p, item) # # 关闭线程池 pool.close() # # 线程等待 pool.join() # print() 注意：本文归作者所有，未经作者允许，不得转载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e71fd083823578dc8db56364ba3dcf/" rel="bookmark">
			python列表中元素相加_将所有嵌套列表中的元素相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，为Python程序员展示了一个通用的反模式，不要循环索引，循环对象本身。E、 g组：for item in b:
do_something(item)
而不是：
^{pr2}$
它更清晰、更简单、更快。在
也就是说，你遇到的主要问题是其中一项不是列表，所以它没有长度。在
这里一个更好的选择是用生成器表达式和^{}展开列表，然后使用the ^{} builtin function对元素求和。在&gt;&gt;&gt; import collections
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; b = [[1,2], [3,4], [5,6], 1]
&gt;&gt;&gt; list(itertools.chain.from_iterable(item if isinstance(item, collections.Iterable) else [item] for item in b))
[1, 2, 3, 4, 5, 6, 1]
&gt;&gt;&gt; sum(itertools.chain.from_iterable(item if isinstance(item, collections.Iterable) else [item] for item in b))
22
我们需要生成器表达式，因为itertools.chain()不能处理不可编辑的项，因此我们将任何表达式放入一个列表中以解决这一问题。在
另一种方法是制造自己的发电机：def chain_mixed(iterable):
for item in iterable:
try:
for subitem in item:
yield subitem
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09e71fd083823578dc8db56364ba3dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854f33a5438d872605793b96dc927d86/" rel="bookmark">
			静态方法存放在jvm哪里_11道 JVM面试 真题（含答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.假定str0,…,str4后序代码都是只读引用。Java 7中，以下述代码为基础，在发生过一次FullGC后，上述代码在Heap空间(不包括PermGen)保留的字符数为() static String str0="0123456789";
static String str1="0123456789";
String str2=str1.substring(5);
String str3=new String(str2);
String str4=new String(str3.toCharArray());
str0=null;
15
str0和str1 在常量池。
str2，substring实际是new，5字符
str3和str4也都是new，每个5字符
以上三个分别都会创建新的对象，存放在堆。
常量池是PermGen的。(永久代：存储的是final常量，static变量，常量池。)
经过fullgc之后，年老区的内存回收，则年轻区的占了15个，不算PermGen，因此一共15字符
2、对语句行 test.hello(). 描述正确的有() package NowCoder;
class Test {
public static void hello() {
System.out.println("hello");
}
}
public class MyApplication {
public static void main(String[] args) {
// TODO Auto-generated method stub
Test test=null;
test.hello();
}
}
A 能编译通过，并正确运行
B 因为使用了未初始化的变量，所以不能编译通过
C 以错误的方式访问了静态方法
D 能编译通过，但因变量为null，不能正常运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/854f33a5438d872605793b96dc927d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6334ae15ddf731eb4a3233b2ee494c68/" rel="bookmark">
			python爬虫数据提取脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 使用scrapy_redis框架时，为了利用redis高效的io，通常回把数据放到redis上。在任务结束后则需要将redis里的结果数据迁移。
场景 将爬虫数据从redis迁移到mongodb，并且提取生成一份excel格式的文件
使用方法 参数2：指定爬虫结果集
参数3~：指定指定结果集中键在excel中的别名
python export.py [spider_name]:items redis_key1=excel_title1 redis_key2=excel_title2
脚本 有些地方些的不太好，后续优化~
import sys import time import redis import pymongo import json import openpyxl # 配置 REDIS_HOST = "redis host" REDIS_PORT = 6379 REDIS_DB = 0 REDIS_PWD = "redis password" REDIS_COL = "" # 导出数据的目标集合 MONGO_HOST = "mongodb host" MONGO_PORT = 27017 MONGO_DB = "" # 数据存储的库名 MONGO_COL = "" # 数据存储的集合名 MONGO_USER = "mongodb username" MONGO_PWD = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6334ae15ddf731eb4a3233b2ee494c68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f89899f8686d293f9778b2d893174d/" rel="bookmark">
			使用OpenSSL自建一个HTTPS服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 理论知识 1.1 什么是https 传统的 HTTP 协议以明文方式进行通信，不提供任何方式的数据加密，很容易被中间攻击者破解通信内容或者伪装成服务器与客户端通信，在安全性上存在很大问题。
HTTPS 协议是由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。
关于非对称加密以及公钥私钥相关知识不在赘述，可自行了解。
PS: TLS 是传输层加密协议，前身是由网景公司1995年发布的 SSL 协议，不过在很多场合还是用 SSL 指代 TLS/SSL。
1.2 https的通信过程 下图来源：菜鸟教程
1、客户端发起 HTTPS 请求
用户访问 https 网址，连接到服务器的 443 端口，请求信息中包含了客户端支持的对称加密算法列表。
2、服务端的配置
支持 HTTPS 协议的服务器必须要有包含自己认证信息和公钥的数字证书以及自己的私钥。
3、下发证书
服务器下发自己的数字证书，这一步其实还包括从客户端支持的对称加密算法列表中选出来用于双向通信的算法，因为非对称加密是一个很耗费资源的过程，所以一般只用来协商之后用于通信的对称加密算法。
当然这一步只是明文协商了对称加密算法的名字，后面会用非对称加密来传输用于对称加密算法的秘钥，由于非对称加密的有效性，这个秘钥是不会被破解的，后续的对称加密传输也就不会被破解。
4、客户端验证证书有效性
客户端验证证书的有效性，如果证书没有问题，那么就生成一个随机值（对称加密秘钥），然后用证书中的公钥对该随机值进行加密。
5、传送用于对称通信的秘钥
用公钥加密的随机值被发送到服务端。
6、服务端解密秘钥
服务端用自己的私钥解密后，得到了客户端传过来的随机值（对称加密秘钥）。
7、双向对称加密通信
接下来就使用之前协商好的对称加密算法以及加密传输的秘钥进行通信即可。
1.3 SSL证书的签发流程 上面的 https 通信过程中，最关键的一步就是客户端如何验证服务端下发证书的有效性，因为下发证书是一个明文传输的过程，证书可能在传输过程中被拦截，被调包，被篡改，那么客户端怎么确定自己收到的就是自己想访问的网站的证书呢？
由于客户端是发起通信的一方，双方没有协商好的加密算法，服务端也不可能持有客户端的公钥信息，所以证书不能被加密发送，那么要解决这个问题就必须引入第三方可信机构（CA），客户端信任它，它就可以对服务器证书做出认证，具体来说就是使用自己的私钥对服务器证书进行签名，签名后的信息包含在证书内，这样客户端只需要持有各个 CA 的公钥，便可以对签名信息进行解密来验证证书的有效性。
上图就是 SSL 证书的签发流程：
浏览器需要记住各大CA。浏览器是怎么样记住CA的呢？在浏览器开发的时候，各个CA就把自己的根证书交给了浏览器，那么 CA 根证书中最重要的信息就是该 CA 机构的公钥了，此外还有 CA 机构的标识信息以便匹配服务器证书中声明对它签名的机构。
各大网站，如支付宝，将自己的证书交给CA。CA此时需要做的事情是，通过各种法定机构，验证网站的身份。如果CA确定该网站是真的，那么就需要用自己的私钥给网站的证书签名。网站交给 CA 的证书中除了包含自己的 URL 等标识信息外，还必须有网站自己的公钥信息，因为签完名之后证书就不能动了，而后面客户端需要服务器的公钥来加密信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8f89899f8686d293f9778b2d893174d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ad5f0944d35c5ceb3c6c1ca83d9435/" rel="bookmark">
			rgmii信号是否可以直接在mac和mac互联_电脑显示器无信号输入怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好呀，近期微信公众号改版，为了防止错过我们的消息，希望大家可以动动小手将公众号添加到“ 星标⭐”，非常感谢呀? 经常有人遇到电脑开机电源、CPU风扇正常转动，但是显示器提示无信号输入的问题，不知道怎么处理，那么今天小王就来给大家讲讲引起这个问题的原因及解决办法，希望对你有所帮助！
一、引起问题的原因
电脑主机和显示器的连接线未连接或连接线损坏方法一、
检查一下显示器后面的VGA连接线是否安装正常，还有主机后面的连接口也需要检查，有部分用户的台式电脑有两个VGA口，记住要插在独立显款的连接口上才能正常开机，当然也可以更换连接线测试。主机没有正常启动故障方法二、
如果电脑没有移动过，那么主机出现故障不能正常开机导致显示屏不能接受到信号是很大原因：1、打开机箱侧盖；2、对内存进行重新拔插；3、对显卡重新拔插；4、检查各电源连接线是否接好；5、对机箱灰尘进行全面清理；6、对CMOS电池进行放电，必要时更换电池；
7、开机后显示器无信号但有报警声，电脑开机启动时，系统BIOS开始进行加电自检，当检测到电脑中某一设备有错误时，便发出声音报告错误。因此可能出现显示器无信号有报警声的故障。对于电脑开机后显示器无信号有报警声故障，可以根据BIOS报警声的含义，来检查出现故障的设备，以排除故障；
8、如通过上面几个步骤还不能解决，建议主机送至专业人员维修。
通过以上电脑开机后显示器无信号的解决方法的介绍，当你遇到同样的情况的时候应该知道怎么解决了吧，希望本文的分享对大家有所帮助。
●对不起了,网易云！
●福利篇！趁还未被封杀赶紧下载
●稀缺软件，请务必低调使用！
●偷偷分享！某知名APP特殊版本！谨慎传播！
3元共享一个月百度云超级会员帐号点击下面图片 ↓ 直接拍宝贝就可以 ↓ (亲测稳定不掉线) 24小时自动发货平台：http://xiaowang.ms8.store/mobile 个人运营+日更不容易-支持小王的可以点击右上角“三个黑点”转发推文到朋友圈，或点击右下角的“在看”鸭~你的支持能让小王走的更远
目前6000+人已关注加入我们
【声明：一切资源均搜集于互联网及网友分享，经我方整理、个人干货分享汇总呈现，仅供学习交流，请在下载后24小时内删除；如果侵犯到你的权益，及时联系我们删除该资源：310246650@qq.com，有什么不对还请指出。】
戳
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17cddaf9ba6cb4a6ff352b5dcf08fc0a/" rel="bookmark">
			在vue中使用better-scroll，完成平滑滚动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue中使用Better-Scroll，完成平滑滚动效果 BScroll官方文档
此博客参考于以上的官方文档，并加以vue的小Demo建立。
引言、BetterScroll 是什么 BetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。
BetterScroll 是使用纯 JavaScript 实现的，这意味着它是无依赖的。
结构示例：
&lt;div class="wrapper"&gt; &lt;ul class="content"&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;!-- 这里可以放一些其它的 DOM，但不会影响滚动 --&gt; &lt;/div&gt; 上面的代码中 BetterScroll 是作用在外层 wrapper 容器上的，滚动的部分是 content 元素。这里要注意的是，BetterScroll 默认处理容器（wrapper）的第一个子元素（content）的滚动，其它的元素都会被忽略。
最简单的初始化代码如下：
import BScroll from '@better-scroll/core' let wrapper = document.querySelector('.wrapper') let scroll = new BScroll(wrapper) BetterScroll 提供了一个类，实例化的第一个参数是一个原生的 DOM 对象。当然，如果传递的是一个字符串，BetterScroll 内部会尝试调用 querySelector 去获取这个 DOM 对象。
浏览器的滚动原理
浏览器的滚动条大家都会遇到，当页面内容的高度超过视口高度的时候，会出现纵向滚动条；当页面内容的宽度超过视口宽度的时候，会出现横向滚动条。也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。
BetterScroll 也是一样的原理，我们可以用一张图更直观的感受一下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17cddaf9ba6cb4a6ff352b5dcf08fc0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada65e0bbb2cd2dd5454f1a78ea69bc2/" rel="bookmark">
			为什么C&#43;&#43;永不过时？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linus曾说过：
“C++是一门很恐怖的语言，而比它更恐怖的是很多不合格的程序员在使用着它！”
这足以说明C++有多难！
不过，你也要明白。
难度越高意味着含金量与竞争力越高，越能把你和别人区分开，拿到超过大多数人的薪资。
但是，如果你只是一时兴起，那么我很不建议你学它。
如果，你已经在学习，并且想学好，用在工作上，那么你可以继续读下去！
虽然，学习C++不容易，但并不意味着没有方法！
很多人只是单纯看书、看网上的视频资料，最大的弊端是遇到问题没人能请教。
而且也不能阶段性的看到反馈，很难评估自己学到什么程度。
因此，今天要给你推荐1个C++直播训练营。
会有ACM金牌老师直播授课，并且全程有答疑。
你在训练营遇到的问题，包括平时学习遇到的问题，都可以向老师提问，随时获得答案，学习效率比自己摸索高5倍不止。
而且，这个训练营会有项目实践。
你在课上学的知识，课下就要用来开发项目。
在这个过程，你既能检验自己的学习效果，查漏补缺，还能获得真实的项目经验和能力，对后续的深入学习非常有帮助。
此外，这个项目也可以写到你的简历。
因为它用到的技术都是工作中非常重要的点，写出来对HR极具吸引力，获得的面试邀请要比自己瞎写简历高不知道多少倍！
但是，这个训练营原本是收费的，我只搞到了 100 个 免费 名额。
由于名额有限，我想更多的给到大三、大四和刚毕业不久的读者。
如果你想快速提升自己的C++技能，那么可以扫描下方二维码免费报名学习！
仅有100个免费，先到先得！
长按3秒 即可扫码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3b1766332ed31150d5f3e49066b959/" rel="bookmark">
			url中 斜杠如何传输_如何在父子页面中传输数据(layer)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近组长给了一个需求, 需要将网址的ie弹窗兼容chrome, 因为这个网址架构实在太老了,有些棘手, 在解决后记录一下自己的解决方案, 方便回顾. 原来代码中用的window.showModalDialog这个方法, 这个方法因为是同步的, chrome认为不安全, 已经过时了, 在chrome中会报错, 因此, 需要找一个异步的替代方法, 我第一时间想到了window.open, 可惜并不好用, 然后在网上找到了layer这个ui框架, 它提供了方便好看的iframe组件. 知道这个, 就可以开始做准备, 一开始直接使用时遇到一些问题, 因为有些子页面是通用页面, 有一些父页面不是, 就导致了必须把全部的showModalDialog换成layer.open, 并且测试也需要很多时间, 无奈之下需要做兼容,保证 无论是在ie或者chrome下都能正常运行, 于是动手写了一个全局方法, 代码部分如下
在图中可以看到, 用try-catch来判断浏览器是否为ie内核, 在chrome下window.showModalDialog.length这行代码是会报错的, 从而转到catch去调用layer.open. 接下来看一下如何调用这个方法, 代码图片如下
我们在改造原来代码时, 把原来的showModalDialog剪贴到end回调中, 并且加一个判断是否是ie, 如果用户使用的是ie浏览器, 代码会执行到try那部分, 那么他就会回到这个回调中, 继续使用这个过时的函数, 并且下面也是同步的将子页面的返回数据进行下一步的操作. 如果用户使用的是谷歌浏览器, 那么代码就会执行到catch那部分, 使用layer.open, 在用户关闭子页面时再回到end回调中, 第二个参数就是子页面返回的数据, js也能拿着数据进行下一步的操作. 到这里, 调用子页面的逻辑是自洽的. 接下来我们需要考虑在子页面返回数据了, 其实也很简单, 原来的子页面是用window.returnValue来返回数据, 我们需要改成以下代码
我们在utils文件中也写了这个兼容方法, 原理是一样的. 解决方案就是这样, 接下来的工作就是无聊的复制粘贴了. 如果你对我写的文章感兴趣, 麻烦动动小手点个赞关注一下, 遇到问题也可以直接私信问我, 我会尽量帮你. 我是vscoderwhy, 一个正在实习的小前端. 我们下篇文章再见.
------------------------------------分割线-----------------------------------
最近发现可以添加一个新功能, 在上面的代码中我们只考虑了将子页面的数据传到父页面, 忽略了怎么把父页面的数据传到子页面, 下面是代码示例图: 首先, 我们在utils这个全局对象中添加一个属性, 用来存储需要传输的数据, 再写一个方法, 从而在父页面中调用这个方法, 把数据传进去.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3b1766332ed31150d5f3e49066b959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ffc237aeb908ef9e4a74f64f56750e/" rel="bookmark">
			windows8从安装到优化详细全过程——超详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自BX教程网www.benxitj.com:整理编辑 - 原文出处 www.benxitj.com/Article/?11795/62.html 转载注明
win8
经常在网上看到一些网友问到怎么装系统、win8怎么装……，现在win8已经面世很久了，但还有很多朋友不知道怎么安装。现在网络上的教程都是针对性比较强的，对于新手来说会比较不方便。这里就专门为新手准备了一份图文教程。。，从win8的安装、设置……到备份。这一片文章图片比较多，也比较详细，篇幅比较长，请耐心阅读，觉得太罗嗦的同志们，就当是没看到吧。
本文将从以下几个方面详细讲解：
1·Win8 各个版本区别对比
2·Win8系统下载
3·系统安装
4·安装过程
5·优化设置
6·Win8系统备份
Win8 各个版本区别对比
面对琳琅满目的Win8版本，想必大家一定和我一样头大了，这些版本都有什么区别!?哪个版本更加适合我!?又有那些功能是我暂时用不着的!?通过下面的对比图，就可以更加方便的挑出适合自己的Win8了!
通过上面的大图，我们想必大家一定找到了适合自己得Win8版本了吧!?那么我们就开始下载吧!
一、Win8系统下载
现在最新的应该是Win8 MSDN版本的了，系统之家Win8栏目里里可以下载，大家可以点击查看:http://xitongzhijia.net/windows8/。
二、系统安装
·U盘安装
U盘安装系统已经成为当下趋势，不仅制作起来方便，安装起来还更加快速!这里需要用到一款软件 UltraISO。
用软件打开Win8镜像后，按“启动”——“写入硬盘镜像”。
选择自己的U盘即可!当然， U盘最好不要低于4G。格式化之后写入即可!
通过这种方法制作的启动盘，还是可以继续当U盘一样存文件的哦。
此方法不仅适合全新安装，也适合双系统安装。
·硬盘安装
用虚拟机加载，然后再Win7下安装。此方法只适合双系统的安装。双击里面的setup文件即可!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd0bf846df2d6f71ca63a5d302e2c9a/" rel="bookmark">
			矩阵函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 矩阵函数的定义一些常见的矩阵函数矩阵函数的性质通过相似对角化求矩阵函数通过Jordan标准形求矩阵函数待定系数法求矩阵函数 矩阵函数的定义 一些常见的矩阵函数 矩阵函数的性质 通过相似对角化求矩阵函数 本段摘自 程云鹏. 矩阵论(第二版)[M]// 矩阵论（第二版）. 西北工业大学出版社, 2000. p158
通过Jordan标准形求矩阵函数 本段摘自 程云鹏. 矩阵论(第二版)[M]// 矩阵论（第二版）. 西北工业大学出版社, 2000. p159
待定系数法求矩阵函数 本段摘自 程云鹏. 矩阵论(第二版)[M]// 矩阵论（第二版）. 西北工业大学出版社, 2000. p153
摘自 张绍飞, 赵迪. 矩阵论教程[M]. 机械工业出版社, 2012. 4.4节 矩阵函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a583085786684031232aa76661954f/" rel="bookmark">
			Linux直接通过端口号杀对应进程，lsof命令无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查看端口号被谁占用 我的某端口号被占用，想查看该端口号究竟被谁占用了
命令(8080是你想查看的端口号)：
netstat -anp | grep 8080
运行结果：
发现是java的某进程占用了我们的端口
二、直接通过端口号杀对应进程 这方法比上一个还要简单，不用管究竟是谁占用了端口号，都可以强制杀死该进程(8080是你想杀的端口号)：
下面这一行 是 `` 不是 ’ ’ !!!
kill -9 `lsof -ti:8080` 但是我跑了一下该代码，却发现linux不认识lsof这个命令：
我的系统是CentOS7，解决方案是使用yum来安装lsof，命令如下：
yum install lsof 安装完成后，再执行
kill -9 `lsof -ti:8080` 这样我们端口号对应的进程就被直接结束掉了，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d601efb40cbd187cdace3e83560122bb/" rel="bookmark">
			【Debug】本地JDK和阿里云服务器JDK不一致，jar包在Linux上跑不起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 我在本地有一个SpirngBoot项目，首先我使用maven工具来对jar包打包：
打包之后在target目录下找到该jar包，并将其推送到远程的Linux服务器中：
在Linux上面运行该jar包，但是却报了如下错误：
经过网上多方搜索，发现原因是：我在本地的开发环境是用jdk12开发的，但是阿里云上面的jdk是8。这样打包过去的jar包当然不能运行
解决方案 打开该工程的pom.xml，找到下面几行：
将其改成1.8即可实现指定jdk版本打包
重新打包并推送到服务器上，jar包正常运行。至此问题解决
但是如果你还想在本地继续使用高版本的jdk来进行开发，打包完成后别忘了将你的jdk版本改回12
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048bfad3e2b2510ed974765bc204deae/" rel="bookmark">
			严重: testWhileIdle is true, validationQuery not set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：使用的JDK-13， MYSQL8版本数据库，1.0.9Druid的jar包；
使用1.0.9Druid的jar包
这两行报错，是因为没有SpringBoot框架xml配置，在不使用框架的情况下，如何解决
一：严重: testWhileIdle is true, validationQuery not set 原来properties文件配置如下；
driverClassName=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/logindata?serverTimezone=GMT%2B8&amp;useSSL=false username=root password=186373 需要在properties配置文件下添加一些配置；
filters=stat initialSize=2 maxActive=300 maxWait=60000 timeBetweenEvictionRunsMillis=60000 minEvictableIdleTimeMillis=300000 validationQuery=SELECT 1 testWhileIdle=true testOnBorrow=false testOnReturn=false poolPreparedStatements=false maxPoolPreparedStatementPerConnectionSize=200 再次运行
报错2；
信息: {dataSource-1} inited
这是日志信息，没有错Druid采用了日志打印机制，这不是报错；
连接池采用了懒加载，真正用到的时候才初始化；
名词解释及原文https://blog.csdn.net/weixin_42323802/article/details/82726267
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae87882012f3b76febbfa5e418855140/" rel="bookmark">
			Jetpack Compose - Row、Column
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetpack Compose - Row、Column 0、介绍1、属性一览2、使用示例3、版本更新4、未解决问题 Compose系列文章，请点原文阅读。原文，是时候学习Compose了！
0、介绍 首先大致了解下这两个布局：
Row ：水平布局，官方介绍如下 可以组合的布局，会将其子级 横向 进行放置。
如果需要 竖向 进行放置，请参考Column。
如果需要子级可以 横向滚动 ，请参考ScrollableRow。
如果需要只展示当前可见项 的 横向滚动列表请参考 LazyRow。
Column 可以组合的布局，会将其子级 竖向 进行放置。
如果需要 横向 进行放置，请参考Row。
如果需要子级可以 横向滚动 ，请参考ScrollableColumn。
如果需要只展示当前可见项 的 横向滚动列表请参考 LazyColumn。
所以根据官方介绍我们可以明确知道，Row和Column就是我们之前的LinearLayout，只不过官方细分了，直接分出来两个布局。 而且这两个布局没有滚动效果，当内容过长的时候会超出屏幕而无法看到内容项。
再多说一点，其实要想实现ScrollView的效果，就需要使用ScrollableXXX布局。要想实现RecyclerView的效果，就需要使用LazyXXX布局。
1、属性一览 【目前基于alpha08版本】请看Row布局支持的函数：
@Composable inline fun Row( modifier: Modifier = Modifier, horizontalArrangement: Arrangement.Horizontal = Arrangement.Start, verticalAlignment: Alignment.Vertical = Alignment.Top, content: RowScope.() -&gt; Unit ): Unit 属性参数含义：
参数含义modifier: Modifier = Modifier应用于布局的修饰符horizontalArrangement: Arrangement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae87882012f3b76febbfa5e418855140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ea16eb93826df867ac63275173804b/" rel="bookmark">
			websocket连接不稳定_帮你解决WiFi卡顿：拒绝连接不稳定、网速慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：太平洋电脑网
作为一名90后科技宅，家庭的微信群是必不可少的存在。平日里在群里除了聊聊家庭的琐事，最多的还是处理一些IT类的“疑难杂症”，其中最多的就是家里的网络问题了，于是就有了接下来的对话：
虽然不想承认，但事实上一名科技宅已经成功的沦落成了一名“家庭网管”。
的确，对于很多父母这一代人或者网络小白用户而言，当家里的Wi-Fi网络频繁出现卡顿时，第一反应就是家里的网络被入侵了，甚至出现了黑客攻击，最起码也是有人在蹭家里的Wi-Fi。于是为了防止蹭网，使用的手段更是层出不绝。
小白用户一般会采用长串数字+复杂字母的形式，让自家的Wi-Fi密码变得极为复杂。
究竟复杂到什么程度，最终有可能自己都会忘记密码，只能把Wi-Fi密码贴在路由器的底部。而稍微高阶的用户则是会查看网络设备的连接情况，来判断是否有外来用户蹭网。
甚至一些稍微懂网络的用户会彻底关闭SSID广播，让其他用户根本无法搜索到自家的Wi-Fi，可以说是让蹭网者无从下手。
但最终事实证明，复杂的密码最后难为的是自己。而查看网络设备也是一无所获，最终网络卡顿的问题还是没有得到解决。
所以说，网络卡顿就一定是被蹭网了吗？科技宅表示真的不是这么回事。
很多人都忽略了，路由器要定期断电
你家的路由器有关闭过吗？相信大多数人的回答是从未关闭过。如果是这样，那么家里的网络出现卡顿也就“理所当然”了。想要保障家里的Wi-Fi能够更加稳定的运行，定期的给路由器断电是一件必须的事情。很多人会认为，路由器自身的功率很小，也不费电，并且散热量也不大，所以说给路由器断电是完全没有必要的，但事实却并非如此。
事实上，家庭中的路由器经过长时间不间断的运行，也会非常容易导致设备的过热，这样会大幅度加速设备内部电子元件的老化。后果除了会降低设备的使用寿命外，还会增加设备出现故障的概率，当然也会引起网络的卡顿。
其实不仅如此，如果家用路由器长期处于高负荷的运转，那么路由器本身也会出现较多的缓存。从而让内存不足，会导致信号变弱，因此我们会感觉到网速越来越慢，而关闭路由器可以将这些缓存释放，让内存空间空出来，这样你就不会感到网速慢了，因此正确的做法是定期关闭路由器。在通常情况下可以通过路由器内部的软件来清理缓存，如果觉得方法过于复杂，那么直接给路由器断电重启则更为简单粗暴。
那么究竟该多久给路由器重启一次呢？其实路由器在设计之初，是可以保持较长时间的稳定工作。但是路由器毕竟属于电子设备，长时间工作产生的热量会造成寿命的缩短。所以虽然不建议每天都关闭路由器，但是有规律性的关闭重启路由器还是很有必要的。这里建议大家可以每周关闭路由器一次，对路由器是十分有好处的。并且现在市面上大多数路由器都有定时开关功能，可以智能的帮我们控制路由器。
定期升级固件很重要
除了要定期重启路由器外，及时给路由器更新固件也是很有必要的。为了能了解到家用路由器最新固件中是否存在已知的安全漏洞，德国弗劳恩霍夫通信研究院对来自七个品牌，共127 款产品进行了检查，结果让人十分担忧。据悉，在过去的一年当中，有46款家用路由器没有做过一次安全更新，并且其中很多路由器都受到了数百个已知漏洞的影响，可见路由器的安全漏洞问题并没有受到厂商以及用户的重视。
更令人不敢相信的是，部分厂商甚至在未修复已知漏洞的情况之下就发布了固件的更新。这样就会造成很多家庭用户明明已经升级了最新的固件，但事实上路由器仍然处于易受攻击的状态。并且大约有不少于90%的路由器使用的是Linux系统，但制造商并未使用Linux维护人员提供的修复程序来更新系统。
综合来看，虽然我们不能左右厂商的固件更新。但我们依然要定期更新我们的路由器固件，在一定程度上是可以提高网络的安全性，总比一直都不更新要强的多。并且进行路由器固件的更新，可以最大程度上修复已知的漏洞。并且Wi-Fi的信号强度也会得到改善，从而让家庭的网络变得更为顺畅。
最后附上更新路由器固件的方法，一般在设备管理中会有升级的选项。我们以一款华为路由器为例，在APP中的“更多功能”中找到“升级管理”，就可以搜索到最新的固件，点击“一键升级”就可以了。
重启了更新了还是卡顿，问题可能在这
如果说我们定期重启了路由器，并且也更新了路由器的安全固件，网络的卡顿问题还是得不到解决，那么可以从这三方面来看。
首先，可以从路由器本身的穿墙问题来看。如果穿墙能力差，那么在家庭中一些离路由器较远的位置就会出现信号的盲点，也就造成了某一个点位网络的不顺畅。并且这里很多人会认为路由器的天线数量越多，Wi-Fi的信号就会越强，其实这两者并没有直接的关系。其实天线的作用看来只能作为提升传输速率的一个硬件辅助，而天线的数量也和信号、覆盖范围等因素都无关。所以说，为了能享受到更为顺畅的网络，挑选一台信号覆盖广，穿墙能力强的路由器是很有必要的，当然使用多个路由器组建Mesh网络也是个不错的解决方案，可以让多个路由器的Wi-Fi网络达到无缝连接。
其次，路由器的摆放位置其实也会大大影响到Wi-Fi的流畅程度。一般来讲，为了让房间的信号覆盖更广，建议将路由器放在家中开阔的位置，按照路由常用的棒状天线的增益原理，在减少遮挡阻隔的情况下，信号传输将会更为顺畅。同时，在我们的日常生活中，家中的电器有时也会阻碍我们的Wi-Fi。因为家中使用的蓝牙、无线USB、微波炉等，其实都工作在2.4GHz频段。这无疑是给拥堵的2.4GHz频段雪上加霜，所以想让你家的Wi-Fi畅通无阻，一定要远离它们。
最后，我们就要从网络的运营商找问题了。要知道，即使你家中的网络设备已经非常高配，如果小区接入的运营商网络带宽不够，宽带速度也是起不来的，并且在人流量过多的时候也会出现卡顿的现象。所以说，在尽可能条件允许的情况下，一定要选择一家靠谱的运营商。
最后来聊聊Wi-Fi 6路由器
看到这里，相信大家对于网络不顺畅的问题都有了更深层次的认知。那么下面我们一起来简单聊下近年来大热的话题——Wi-Fi 6路由器，在广大的宣传中都表示Wi-Fi 6的速度相比于Wi-Fi 5提升了将近4倍，并且还采用了能多设备数据同时收发的OFDMA正交频分多址技术，以及新一代加密安全协议WPA3等等优点。
但对于普通的家庭用户来讲，Wi-Fi 6路由器真的有必要更换吗？这里大家要知道，想要体验上Wi-Fi 6的网络，单单有Wi-Fi 6的路由器是远远不够的，同时上网的设备也需要支持Wi-Fi 6。也就是说如果你的手机、电脑等设备支持Wi-Fi 6，那么更换Wi-Fi 6的路由器是很有必要的，但如果设备不支持，升级路由也就不是那么必要了。但Wi-Fi 6毕竟是未来的趋势，提早更换也未尝不可，这就取决于你的钱包了。
梳理一下本文知识点
1、定期重启路由器，建议大家可以每周关闭路由器一次。
2、随时更新安全固件，万一更新后网络就改善了呢。
3、选择信号覆盖广、穿墙能力强的路由器，当然Mesh也是个不错的方案。
4、路由器摆放的位置很重要，尽量在空旷的位置，远离微波炉这样有干扰的电器。
5、选择一家靠谱的运营商，出现问题找源头。
6、至于Wi-Fi 6路由器嘛，毕竟是未来的趋势，有条件就买吧，价格也不贵。
写在最后
综合来看，网络出现了卡顿，其实影响的因素是多方面的。而并非只是单单被蹭网了，或者该换设备了。这些看似难以解决的网络“疑难杂症”，其实只需要简单的操作就可以解决问题。所以说，家里的网络出现卡顿，千万别再更换复杂的密码来难为自己了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea2022ab9d9be19089677202332bb4f4/" rel="bookmark">
			WebMvcConfigurer接口为啥可以不用全部实现？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就是一个普通的接口：
实现上面接口，但并没全部实现，为何不报错，而且能正常运行？
谁知道原因啊？
仔细看了下，接口居然全部是有方法体的，尽管 java1.8可以有default 和 static的可以有方法体，但第一图中有这么多的普通方法，是合乎语法的么？自己编写的为何不行？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5fba0289cc6490038e65fb3f7f88b5/" rel="bookmark">
			电磁波波长越短能量越强_哪些因素与“雷达波长”相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击图片放大可看清
频率与波长的关系
首先，与“雷达波长”不得不说的关系就是频率，这也是大家都知道的一个关系：波长越长，频率越低；波长越短，频率越高；波长与频率的乘积是固定值光速。
天线孔径和增益与波长的关系
我们知道天线的孔径大小和增益都会受到波长的制约，且看公式：
其中，G表示天线增益，Ae表示天线有效孔径。从上图公式可以直观的看出，在天线有效孔径大小相同的情况下，较短波长，可以获得较大的天线增益，成平方的反比关系；而要获得同样的天线增益值，天线有效孔径与波长的平方成正比关系，也就是波长越短，需要的天线有效孔径越小，所以想小型化需要利用更高的频率。
例如，同样都想达到40dB的天线增益，X波段需要的有效孔径不到1m2，而UHF波段的雷达需要数百平方米的天线孔径。所以，我们常见的机载火控雷达通常是X波段，而UHF反隐身雷达总是具有很大的块头。
雷达发射功率与波长的关系
由于波长对天线孔径尺寸的影响，也会间接影响到雷达的发射功率，因为雷达的发射功率会在很大程度上受到电压梯度和散热要求的限制。因此，毫不奇怪的是米波雷达可以发射数兆瓦的平均功率，而毫米波雷达仅可达到数百瓦。当然，雷达功率并不是说能多大就需要做到多大，而是综合考虑探测距离、重量、成本等因素。甚至是发射功率也可以自适应控制，在探测到目标后便减少到仅需的功率用以跟踪目标。
雷达波束宽度与波长的关系
从上述公式可以看出，获得较窄的波束宽度，需要较短的波长和较大的天线尺寸，这与天线增益的公式是对应的，因为窄的波束会带来高的增益。
空间拓展损耗与波长的关系
其中自由空间的损耗单位是dB，常数32.45是在距离单位是km和频率单位是MHz情况下计算出来的。波长越短，频率越高，空间拓展损耗越大。除了发射功率，空间拓展损耗大也是毫米波相比于米波雷达作用距离较近的一个原因。
大气损耗与波长的关系
大气损耗是指电磁波和大气中的水蒸气和氧气分子共振情况下产生的衰减，在10GHz以下一般忽略不计，但是随着更高频率的使用，其影响就不可忽略了，大气损耗与雷达频率(波长)的关系如下图：
从上图可以看出虽然有很大衰减， 但还是存在一些窗口可以利用，例如汽车雷达常用的24GHz/77GHz频段，另外还有35GHz以及94GHz频段附近的毫米波雷达。从上图还可以看出大气中的云和雨也会对电磁波产生较大影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0f215867beef91901153dbdebcbc95/" rel="bookmark">
			await is only valid in async function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误的意思是await只能放到async函数内部，言下之意：
await必须放到函数里函数必须有async修饰符 错误1： 没有放到函数里
const myFun = async () =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1) },1000) }) } // 错误： 没有放在函数里 res1 = await myFun(); console.log(res1); // SyntaxError: await is only valid in async function 错误2： 函数没有async修饰符
const myFun = async () =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1) },1000) }) } // 错误： 函数没有async修饰符 const myFun2 = () =&gt; { res1 = await myFun(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0f215867beef91901153dbdebcbc95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76d019c732ffb14279821e207acebce/" rel="bookmark">
			百度地图 js 在安卓端手指缩放无效_利用百度地图绘制3D轨迹演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 百度地图很强大，也为开发者提供很好的开发接口。今天用3D地图上路线轨迹可视化的小功能。
使用 第一步：申请ak ak申请介绍
创建的时候选择 浏览器端~ 第二步：填写ak 有了 ak 后，复制下面的 hellomap.html 文件到 templates 文件夹里，并在hellomap.html 文件写入你申请的ak
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no" /&gt; &lt;style type="text/css"&gt; body, html,#allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";} &lt;/style&gt; &lt;script type="text/javascript" src="//api.map.baidu.com/api?type=webgl&amp;v=1.0&amp;ak=（此处填写申请的ak）"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="//api.map.baidu.com/library/TrackAnimation/src/TrackAnimation_min.js"&gt;&lt;/script&gt; &lt;title&gt;绘制轨迹&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="allmap"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type="text/javascript"&gt; // GL版命名空间为BMapGL // 按住鼠标右键，修改倾斜角和角度 var bmap = new BMapGL.Map("allmap"); // 创建Map实例 bmap.centerAndZoom(new BMapGL.Point(116.297611, 40.047363), 17); // 初始化地图,设置中心点坐标和地图级别 bmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e76d019c732ffb14279821e207acebce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a6c5e4a0124f15c490c72a1f1bc97e/" rel="bookmark">
			2020软件测试工程师面试题汇总（内含答案）-看完BATJ面试官对你竖起大拇指！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试技术面试题 1、什么是兼容性测试？兼容性测试侧重哪些方面？ 参考答案：
兼容测试主要是检查软件在不同的硬件平台、软件平台上是否可以正常的运行，即是通常说的软件的可移植性。
兼容的类型，如果细分的话，有平台的兼容，网络兼容，数据库兼容，以及数据格式的兼容。
兼容测试的重点是，对兼容环境的分析。通常，是在运行软件的环境不是很确定的情况下，才需要做兼容。根据软件运行的需要，或者根据需求文档，一般都能够得出用户会在什么环境下使用该软件，把这些环境整理成表单，就得出做兼容测试的兼容环境了。
兼容和配置测试的区别在于，做配置测试通常不是Clean OS下做测试，而兼容测试多是在Clean OS的环境下做的。
2、我现在有个程序，发现在Windows上运行得很慢，怎么判别是程序存在问题还是软硬件系统存在问题？ 参考答案：
1、检查系统是否有中毒的特征；
2、检查软件/硬件的配置是否符合软件的推荐标准；
3、确认当前的系统是否是独立，即没有对外提供什么消耗CPU资源的服务；
4、如果是C/S或者B/S结构的软件，需要检查是不是因为与服务器的连接有问题，或者访问有问题造成的；
5、在系统没有任何负载的情况下，查看性能监视器，确认应用程序对CPU/内存的访问情况。
3、测试的策略有哪些？ 参考答案：
黑盒/白盒，静态/动态，手工/自动，冒烟测试，回归测试，公测（Beta测试的策略）
4、正交表测试用例设计方法的特点是什么？ 参考答案：
用最少的实验覆盖最多的操作，测试用例设计很少，效率高，但是很复杂；
对于基本的验证功能，以及二次集成引起的缺陷，一般都能找出来；但是更深的缺陷，更复杂的缺陷，还是无能为力的；
具体的环境下，正交表一般都很难做的。大多数，只在系统测试的时候使用此方法。
5、描述使用bugzilla缺陷管理工具对软件缺陷（BUG）跟踪的管理的流程？ 参考答案：
就是Bugzilla的状态转换图。
6、描述测试用例设计的完整过程？ 参考答案：
需求分析 + 需求变更的维护工作；
根据需求 得出测试需求；
设计测试方案，评审测试方案；
方案评审通过后，设计测试用例，再对测试用例进行评审；
7、单元测试的策略有哪些？ 参考答案：
逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、景泰数据流分析
8、什么是并发？在lordrunner中，如何进行并发的测试？集合点失败了会怎么样？ 参考答案：
在同一时间点，支持多个不同的操作。
LoadRunner中提供IP伪装，集合点，配合虚拟用户的设计，以及在多台电脑上设置，可以比较好的模拟真实的并发。
集合点，即是多个用户在某个时刻，某个特定的环境下同时进行虚拟用户的操作的。集合点失败，则集合点的才操作就会取消，测试就不能进行。
9、QTP中的Action有什么作用？有几种？ 参考答案：
Action的作用
n 用Action可以对步骤集进行分组
n 步骤重组，然后被整体调用
n 拥有自己的sheet
n 组合有相同需求的步骤，整体操作
n 具有独立的对象仓库
Action的种类
n 可复用Action
n 不可复用Action
n 外部Action
10、你所熟悉的软件测试类型都有哪些？请试着分别比较这些不同的测试类型的区别与联系（如功能测试、性能测试……）？ 参考答案：
Compatibility Testing（兼容性测试），也称“Configuration testing（配置测试）”，兼容性测试是将验证软件与其所依赖的环境的依赖程度，包括对硬件的依赖程度，对平台软件，其它软件的依赖程度，来检查程序能正常的运行的测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27a6c5e4a0124f15c490c72a1f1bc97e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26e3df616a4f12c78a4b05140d1e0dd/" rel="bookmark">
			C_review_1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言回顾（一） 1.对编程的理解 编程不是在与计算机交谈，我们写的每一行代码都是在告诉计算机如何一步步地完成一件事情，至于如何让计算机把事情完成的快，完成的好，就是算法的优劣体现。
2.写代码前的工作 拿到一个问题，立马开始编写代码，这种做法在遇到简单问题时还能奏效，长期以来只会让思维简单化。下面结合经典书籍《C Primer Plus》中的编程七步，说说我的理解。
明确问题的最终目标
拿到问题先分析最终要达到什么效果，以这个效果发散开来
设计实现方案
编程三段式：需要什么输入，将会产生什么输出，中间将经过什么计算
进而考虑以什么形式保存输入，考虑计算的方式，最后到考虑以什么形式输出结果
编写代码
在完成目标定义，提出初步的实现方案后，正式开始编写代码
测试与调试
一般来说程序难以一次成功，总有些问题，或显或隐，通过输入测试用例，打断点查看程序运行过程等方式
检查程序中的bug
借鉴与优化
主要从两方面：代码与算法
即使代码已能实现最终目标，但我的实现未必是最好的，此时参考他人的实现，吸取他人代码中的巧妙部分，
再对自身代码进行改进（如数据的存储方式等）
或者代码上已问题不大，但实现思路较复杂，借鉴他人的简洁思路，重新编写更优质的代码实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c71fb31744193a3ec622d8a97f7ef9d6/" rel="bookmark">
			verilog复习与vhdl入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		verilog复习与vhdl入门 1.Verilog回顾 基本结构 verilog以module为单位，module的基本结构：
（1）模块声明（内含端口定义），如：
​ module (
​ input wire clk,
​ input wire rst_n,
​ output reg q
​ );
​ …
​ endmodule
（2）内部信号定义，内部参数定义，如：
​ reg [7:0] cnt；
​ parameter IDLE = 3‘b001；
（3）逻辑功能实现，如：
​ always @ (a or b) begin
​ if (!a) b &lt;= 0;
​ else b &lt;= 1;
​ end (组合逻辑)
​ always @ (posedge clk) begin
​ if (cnt == 3’b000) q &lt;= 1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c71fb31744193a3ec622d8a97f7ef9d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598718c73ede53c4f6830bf65bcb7aa2/" rel="bookmark">
			LeetCode第 842 题：将数组拆分成斐波那契序列(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		842. 将数组拆分成斐波那契序列 - 力扣（LeetCode）
标准的枚举题型了，由于存在不能拆分的情况，所以应该使用带返回值的回溯，需要枚举前两个数字，然后根据前两个数字依次检查后面是否存在合法的序列，如果有，则返回true，否则返回false。
class Solution { public: vector&lt;int&gt; res; bool dfs(string &amp;s, int idx){//idx表示当前下标 if(idx == s.size()) return res.size() &gt; 2;//回溯出口即用尽s中的字符 long cur = 0;//记录数值 for(int i = idx; i &lt; s.size(); ++i){ cur = 10 * cur + s[i] - '0';//每次循环增加一位数 if(cur &gt; INT_MAX) break;//非int直接break if(res.size() &gt;= 2 &amp;&amp; cur - res[res.size()-1] &gt; res[res.size()-2]) break;//再往后加一位cur只会更大 if(res.size() &lt;= 1 || cur - res[res.size()-1] == res[res.size()-2]){//减法防止溢出 res.push_back(cur);//做出选择 if(dfs(s, i+1)) return true;//只需要找到一种组合即可 res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/598718c73ede53c4f6830bf65bcb7aa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09fd755dec913e9f3d3d61b339a86d46/" rel="bookmark">
			Jetpack Compose - Box
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetpack Compose - Box 0、介绍1、属性一览2、使用示例3、版本更新4、未解决问题 Compose系列文章，请点原文阅读。原文，是时候学习Compose了！
0、介绍 针对Box布局，官方介绍如下：
可以和内容组合的布局，Box会根据传入的限制（我理解为：Box的Modifier修饰符属性以及content包含的属性）自行调整大小以适应内容。
如果需要指定content的对齐方式，请使用Alignment。
如果Box中包含多个布局子级时，这些子级将按照组成顺序 “堆叠” 起来（所以，这就类似FrameLayout布局了）。
1、属性一览 【目前基于alpha08版本的属性】首先请看Box的两个函数：
@Composable fun Box(modifier: Modifier): Unit @Composable inline fun Box( modifier: Modifier = Modifier, contentAlignment: Alignment = Alignment.TopStart, content: BoxScope.() -&gt; Unit ): Unit 属性参数含义：
参数含义modifier: Modifier = Modifier应用于布局的修饰符contentAlignment: Alignment = Alignment.TopStartBox中内容的默认对齐方式content: BoxScope.() -&gt; UnitBox中的内容 2、使用示例 我们首先声明一个 360*200 背景为红色的Box，然后定义该Box中内容的对齐属性为 contentAlignment = Alignment.Center居中对齐 ，然后我们在Box中定义它的内容为另一个Box1，Box1的背景为黑色，宽高属性为 fillMaxSize，这个属性意思是“全部填充父容器”，它有一个默认参数表示所占父容器的百分比，所以fillMaxSize(0.5f) 的意思就是：内容Box1的宽高是父Box宽高的一半。Box2的就不具体解释了，代码如下：
@Composable fun BoxDemo() { Box( modifier = Modifier .width(360.dp) .height(200.dp) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09fd755dec913e9f3d3d61b339a86d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce516552768b5909197180de998db8a/" rel="bookmark">
			React.FC函数组件内怎么监听路由变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import React, { useEffect } from 'react'; import { useHistory } from 'react-router-dom'; // 自定义的函数式组件 const MyComponent: React.FC = () =&gt; { // 拿到history const history = useHistory(); // useEffect(effectFunc, []) 类似于 componentDidMount useEffect(() =&gt; { // 组件第一次渲染会执行这个方法 // console.log('useEffect --- '); // 添加路由监听函数 history.listen(historyLocation =&gt; { // 每次路由变化都会执行这个方法 // console.log('route history , ', history); // console.log('route history location , ', historyLocation); }) }, [history]); return ( &lt;div&gt;&lt;/div&gt; ); } export default MyComponent; 开发环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bce516552768b5909197180de998db8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b42d365bbf5d376f9450f60e43663a8/" rel="bookmark">
			NFR_24L01无线SPI模块使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块发射功率：1MA 接口模式：SPI SLAVE, MSBit
协议功能：
1. 可控发射功率，可视接收信号强度。SPI接口最大速率10M，
2. 1-32可变负载长度。发射和接收缓存分别有3个FIFO缓冲器。
3. 自动封包解包
4. 自动包确认、重发包​。协议会自动在发射完一个包后切换到接收状态，等待接收者的确包。接收者则会在接收到包后自动发送一个确认包。如果在一定的等待后发射者没有接收到确认包，则回自动重发。重发前的等待时间和重发次数都可以进行设置。
封包结构：LSByte to MSByte
1字节起始位+4-5字节地址+2字节保护位+​9bit控制位+0-32字节负载内容+1-2字节CRC
起始位用于同步接收端的解调器。
地址位是标记接收者用的。
保护位功能未知。
控制位包含了​6bit负载长度，2bit包身份标记，1bit无需确认标记。包身份标记（PID）是用来标记包是否重复发送。每次一个新的负载进入缓存后，PID会自动+1。如果接收者连续收到两个PID相同的包，则会自动比较两个包的CRC。如果CRC一致，则认为两个包是因为某种原因（比如未收到确认包）而重复发送的，第二次收到的包会被舍弃。这就意味着如果发送者通过同一个TX_BUF连续发送相同的包，是会被接受者忽略的！
负载内容长度位0-32字节。
CRC无需说明。​
5. 共有6个逻辑通讯通道，对应6个不同的接收地址。6个地址的高位都相同，只有最低一个字节可以自定义。实际上6个通讯地址都对应着同一个频率和收发配置，只是接收的地址不一样而已。
6. 中断功能。接收、发射、寄存器满都会产生中断。通过对状态寄存器中相应的位写1，可以请空中断标志
​
模块共5种有效的模式：
1. ​​掉电模式。寄存器中PWR_UP=0，4ua
2.空闲1。CE=0的状态，低功耗，待机状态。30ua
3.空闲2。TX状态下，CE=1，发射缓存已经清空的状态下，进入该状态。当有内容进入发射缓存的时候，会立刻进行发射。一种待发射状态。900ua
4.接收状态。​PRIM_RX=1，CE=1的时候进入接收状态，无线机构接收所有信号并筛选出发给指定地址的包。在该状态下，还能督导RPD也就是接收信号强度值。18.5ma
5.发射状态。​PRIM_RX=0，CE=1的时候进入发射状态，无线机构将负载内容组装成包发射出去。当发射缓存清空而CE还是1的时候，进入空闲2。该状态也可以通过一个20us以上的CE脉冲来触发，完成发射后会自动返回空闲1状态。17ma
​
关于 频率、地址和管道：​
模块工作的频率为2.4-2.525G。具体设置的频率F=2400+RF_CH，单位是MHZ。RF_CH&lt;125;
当工作在2M时，为了保证频道之间不重叠，频率间隔必须高于2M，其它情况下间隔1M。
即使工作在同频率上，还可以用地址加以区分。​模块会接受当前频率上所有的信息，但是会先对包地址进行过滤，只保存针对自己地址的包。每个包只包含了接受者的地址。
每个模块可以接受6个管道发来的信息。每个管道​的地址前4字节相同，只有最后一个字节不一样。也就是说，可以同时接受6个地址发送来的信息。每个管道可以分别设置一些参数，比如负载长度。但是每次发送只能使用一个地址。也就是说，这个模块是多收单发的！
在发射状态下，除了需要设置TX_ADDR，还需要将接收管道P0的RX_ADDR_P0设置为相同的地址，用来接收自动ACK。也就是说，来自接受者的自动ACK包里的地址是当前接收者的地址。
在接收状态下，只需要设置每个管道的​接收地址RX_ADDR， 自动ACK包的地址会复制接收到包的地址。
​
通讯过程解析：
填写图片摘要（选填）
操作过程：
注：只有在空闲或者掉电状态下，才能向模块写控制寄存器！只要​CSN下拉，模块必然会自动输出8位状态寄存器，高位优先。而所有的读写操作，在操作SPI前必须将CSN下拉，并在结束后上拉。
与NRF芯片通讯的顺序是：（指令+地址）+数据​。
指令包括​：读写寄存器（都要加地址），读写缓冲，冲洗缓冲，连续发送，读取接收缓冲宽度，写ACK负载，等等
1. 在掉电状态或者空闲状态下，设置基本参数。包括RF频道、地址、等等。
2. 向发射内容缓冲器写入发射内容。在写入前最好用FLUSH指令清空一下缓冲器，否则容易产生发送错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa40304dc123d47dde6585c8728be1d9/" rel="bookmark">
			Android中监听软键盘弹出收起以及隐藏软键盘，显示软键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android中使用EditText会牵扯到软键盘，没少踩坑，今天总结一下 1，Android中阻止activity弹出软键盘
android:windowSoftInputMode="stateAlwaysHidden|stateHidden" 2，隐藏软键盘
/** * 隐藏键盘 */ protected void hideInput() { InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE); View v = getWindow().peekDecorView(); if (null != v) { imm.hideSoftInputFromWindow(v.getWindowToken(), 0); } } 3，显示软键盘
getActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE); 4，监听软键盘弹出还是收起
public class SoftKeyboardStateHelper implements ViewTreeObserver.OnGlobalLayoutListener { public interface SoftKeyboardStateListener { void onSoftKeyboardOpened(int keyboardHeightInPx); void onSoftKeyboardClosed(); } private final List&lt;SoftKeyboardStateListener&gt; listeners = new LinkedList&lt;SoftKeyboardStateListener&gt;(); private final View activityRootView; private int lastSoftKeyboardHeightInPx; private boolean isSoftKeyboardOpened; public SoftKeyboardStateHelper(View activityRootView) { this(activityRootView, false); } public SoftKeyboardStateHelper(View activityRootView, boolean isSoftKeyboardOpened) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa40304dc123d47dde6585c8728be1d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706436a4ef9d08124428b70e60f69963/" rel="bookmark">
			python读取list一列_Python 列表(List)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 列表(List)
序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。
Python有6个序列的内置类型，但最常见的是列表和元组。
序列都可以进行的操作包括索引，切片，加，乘，检查成员。
此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。
列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。
列表的数据项不需要具有相同的类型
创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：
list1 = ['physics', 'chemistry', 1997, 2000]
list2 = [1, 2, 3, 4, 5 ]
list3 = ["a", "b", "c", "d"]
与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。
访问列表中的值
使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示：
实例(Python 2.0+)
#!/usr/bin/python
list1 = ['physics', 'chemistry', 1997, 2000]
list2 = [1, 2, 3, 4, 5, 6, 7 ]
print "list1[0]: ", list1[0]
print "list2[1:5]: ", list2[1:5]
以上实例输出结果：
list1[0]: physics
list2[1:5]: [2, 3, 4, 5]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706436a4ef9d08124428b70e60f69963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e857c1f9ade593aa67fb26e4ad6200/" rel="bookmark">
			cesium 加载bim模型_BIM&#43;GIS跨界融合，打造智能未来新利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		城市是人类集聚生活的主要场所，随着智慧城市、智慧园区、智慧工程、智慧建筑等建设的深入发展，“BIM+GIS+物联网+云技术”已经成为智慧城市建设最基础的技术架构。GIS与BIM融合为城市的建设管理提供了新的方法和手段。
GIS为当今城市的建设和管理提供了基础框架，BIM为城市建设管理提供单栋建筑的精确信息模型。BIM与GIS的跨界融合，使微观领域的BIM信息与宏观领域的GIS信息实现交换和互操作，提升了BIM应用深度，将BIM的应用从单体延伸到建筑群甚至城市级，为GIS行业发展带来了新的契机。
BIM和GIS已从各自领域的应用逐步走向两个领域的融合：
▶BIM需要GIS，将BIM带入更宏观的场景，实现对宏观情况的全盘掌握、统筹安排；
▶GIS需要BIM，使GIS从室外走向室内，实现室内外一体化。
备战智能未来的“四招”利器
1、原生支持Revit，并支持更广泛的数据格式
目前，Esri与Autodesk建立了战略合作关系，并在此基础上构建了从设计、施工到运维的完整BIM解决方案：一方面，Autodesk的Infraworks支持ArcGIS Online/ArcGIS Enterprise上的基础地图数据，并基于此直接在Autodesk中完成BIM的设计；另一方面，ArcGIS Pro原生支持Autodesk的Revit数据，并在此基础上进行编辑、分析与服务发布，从而实现在GIS环境中的BIM运维。
除此之外，ArcGIS平台还提供了更多源BIM数据支持，包括对Microstation(Bentley)、CATIA、Tekla、PDMS等主流BIM软件的支持。具体支持形式如下：①原生支持：在最新发布的ArcGIS Pro2.2版本中，Autodesk的Revit数据可直接作为ArcGIS平台的数据源;②交换格式支持：STEP，IFC。例如，CATIA、SolidWorks、Tekla等可通过导出为STEP或IFC交换格式，进行支持;③插件支持：基于在Microstation、CATIA等BIM设计软件中开发的转换插件，进行支持。
2、大体量、多源BIM轻量化
大体量、多源BIM的轻量化技术，是BIM与GIS一体化的关键技术。基于计算机图形算法进行大规模BIM数据处理，处理的结果可以作为三维渲染引擎场景数据调度算法的输入，从而提高三维渲染的帧率；在基于图形算法进行处理时，通过少量的几个数字指标即可平衡数据量与模型细节层次之间的矛盾，从而实现在不同尺度上的平滑加载。
作为建筑行业互联网平台服务商，智汇云立足工程领域，凭借丰富的建筑行业软件开发经验及全面BIM应用产品开启了轻量化BIM应用新时代。当然，轻量化BIM应用不仅体现在产品体系上，它还体现在服务体系、价格体系和实施方法等各个方面。
3、3OGC I3S标准的三维服务能力
ArcGIS SLPK是遵从OGC I3S标准的三维切片格式，一方面可直接在ArcGIS Pro、ArcGIS Earth以及用户开发定制的PC端、移动端上直接使用，另一方面可直接发布到ArcGIS Enterprise或ArcGIS Online上，进而在为用户开发定制的PC端或移动端上使用。
SLPK格式具有如下满足BIM需求的优势：
①.支持的数据量特别大，可支持十亿级别的面片数量；
②.支持LOD，可极大地提升数据在前端加载的效率；
③.支持I3S标准，可直接对接ArcGIS Enterprise/ArcGIS Online，可良好地运行在Web端、移动端，满足轻量化使用的需求。
4、高效、快速的前端数据加载
ArcGIS平台支持三维数据在PC端、移动端的高效加载。在PC端采用无插件的WebGL技术，可通过三种技术提高数据在前端加载的效率：
①.引入IndexDB支持前端缓存：通过IndexDB可以缓存从数据库到转换过程从而提高数据二次加载的效率；
②.流方式加载模式：优化数据加载方式，从人体视觉出发采用从前往后的加载模式；
③.逐步加载方式：采用从粗模到精模的逐步加载方式，优先看到全局数据，逐步细化显示。
应用：BIM+GIS为校园提供生命周期管理
通过对BIM+GIS的综合应用，能够实现校园资产的全生命周期管理。智汇云自主研发的智慧校园平台不仅可以对整个校园不同系统的数据进行集成和标准化，还能为整个校园的运营、管理和服务等功能提供支撑。平台作为一个资产管理系统，对数据/资产进行搜集、管理、分析、规划、设计和建设。此外，改系统还研发与空间规划、智慧教室、能耗监测、中控系统、智能消防、人员定位等相关的其他应用。
未来计划
BIM数据是一种特殊的数据，其最大的特点是数据高度密集；BIM应用有其自身的特点，在使用时需要考虑在不同尺度上(如构件级、建筑级等)有不同的使用方法和使用场景。智汇云就针对BIM的数据特点、应用特点，基于BIM理论梳理了未来BIM路线图。面对智能未来，还将根据BIM运维需求进一步加强对BIM的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4a7701919c0fda001a59df7c39774f/" rel="bookmark">
			uniapp  npm run dev:mp-weixin报错：cross-env NODE_ENV=development
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下
cross-env NODE_ENV=development UNI_PLATFORM=mp-weixin vue-cli-service uni-build --watch
缺少平台 mp-weixin 插件
首先你需要装一下cross-env，执行： npm install --save-dev cross-env --no-bin-links
或者你也可以全局安装一下cross-env，以防止以后在其他项目也出现类似错误：
npm install -g cross-env --no-bin-links
如果还不行
安装完成删除package-lock，及modules,然后二次重装，重新引入项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f5804d420d5204d352f5c27bc5b4f0/" rel="bookmark">
			Win8怎么加快桌面图标刷新速度？提高图标刷新速度的方法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自BX教程网www.benxitj.com:整理编辑 - 原文出处 www.benxitj.com/Article/?11804/62.html 转载注明
window8
很多时候由于各种内存或者系统原因导致我们安装完一个新应用以后，桌面图标出来的很慢，就算是按F5刷新桌面图标，也是刷新的非常慢，其实出现这一问题的时候，我们可以设置加快桌面图标刷新速度。那么，Win8怎么加快桌面图标刷新速度呢？下面我们就一起往下看看提高图标刷新速度的方法解析。
方法/步骤
1、按键盘上的组合键【Win+R】把运行调出来，在运行中输入【regedit】再点击确定进入注册表；
2、定位至HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer，然后在右侧窗口中找到字符串值“Max Cached Icons”（如果没有，则新建一个名为“Max Cached Icons”的字符串值）；
3、把数值改为为4096或更大，但不能超过8192。点击确定，这样就把桌面图标缓存增加到了4MB以上，重启后图标刷新速度就会有改善。
以上就是Win8加快桌面图标刷新速度的方法解析，按照以上方法将Explorer下的Max Cached Icons的数值改为更大一点即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e55d995a12a43a1745cba4a57e05d41/" rel="bookmark">
			微信小程序自定义tabBar以及图标-使用vant-weapp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序整合vant weapp可以看《微信小程序vant weapp安装与使用》
微信官方文档有介绍自定义tabBar
1、在小程序根目录下创建custom-tab-bar文件夹，并创建以下文件。（这个是作为入口文件的） custom-tab-bar/index.js
custom-tab-bar/index.json
custom-tab-bar/index.wxml
custom-tab-bar/index.wxss
2、修改custom-tab-bar/index.js （清除初始化的内容） Component({ data: { selected: 0, list: [ { pagePath: "/pages/checkin/checkin", text: "打卡", normal: '/images/tabbar/position.png', active: '/images/tabbar/position-green.png' }, { pagePath: "/pages/idcard/idcard", text: "上传", normal: '/images/tabbar/idcard.png', active: '/images/tabbar/idcard-green.png' } ] }, methods: { onChange(e) { console.log(e,'e') this.setData({ active: e.detail }); wx.switchTab({ url: this.data.list[e.detail].pagePath }); }, init() { const page = getCurrentPages().pop(); this.setData({ active: this.data.list.findIndex(item =&gt; item.pagePath === `/${page.route}`) }); } } }) 3、修改custom-tab-bar/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e55d995a12a43a1745cba4a57e05d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bbfbf7cc40be171867d5da95cc23d3f/" rel="bookmark">
			产品经理岗位职责说明_研发部：职能概述、组织结构、职能分解、岗位职责、考核制度...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 阅读导航→
01 研发部职能概述
02 研发部组织结构
03 研发部职能分解
04 研发总监岗位职责
05 研发经理岗位职责
06 设计经理岗位职责
07 研发主管岗位职责
08 技术研发人员绩效考核制度
研发部职能概述 根据企业性质、企业研发策略不同，研发部的职能会有所区别。一般来说，研发部主要职能是根据公司的发展战略，在公司高层团队的领导下开展的新产品（新技术、新服务）开发、技术支持和管理、试验管理、工艺管理等工作。具体包括行业技术研究、新产品（新技术、新服务）项目的规划与设计、新产品（新技术、新服务）及新材料的开发与应用、产品（技术、服务）改良升级、研发技术与工艺技术管理、技术信息资料管理、研发知识产权管理等的全部或部分职能。
研发部组织结构 不同的企业由于其业务的不同，会设置不同的研发组织，以保证研发部职能的实现。在进行研发组织结构设计时，应根据企业研发业务的不同，设置相应的研发组织，确保研发的高效性与灵活性。
（一）产品研发类的研发部组织结构设计
产品研发类的研发部组织结构形式如下所示，这种结构比较适用于进行产品研发的企业。
（二）工艺研发类的研发部组织结构设计
工艺研发类的研发部组织结构如下所示。
（三）软件研发类的研发部组织结构设计
软件研发类的研发部组织结构如下所示。
研发部职能分解 研发部职能分解，即将研发部的职能逐级分解为可执行的作业项目，具体分解结果如下所示。
研发总监岗位职责 研发总监是在总经理的授权下，全面负责产品研发设计管理工作，规划本企业技术发展路线与新产品开发工作，对技术研究、产品开发、分析测试、中试研究等过程进行监督和控制。其具体职责如下所示。
研发经理岗位职责 研发经理的主要职责是根据研发设计总监的要求，具体落实各项研发工作计划，负责组织企业研发方面的日常管理工作，推进技术研究、产品开发、分析测试、中试研究等工作的开展，确保企业技术研究、产品开发目标实现。具体职责如下。
设计经理岗位职责 设计经理的主要工作职责是负责企业设计工作的日常管理，并确保设计质量。其具体职责如下所示。
研发主管岗位职责 研发主管的主要职责是在研发经理的领导下，负责新产品开发、产品改进的组织实施及产品技术标准的制定，确保企业产品的开发工作满足市场需求。其具体职责如下所示。
技术研发人员绩效考核制度 原文链接
研发部：职能概述、组织结构、职能分解、岗位职责、考核制度​mp.weixin.qq.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0de4e39fc4a5b57ba46c0c0190e3fa/" rel="bookmark">
			dbscan聚类python_20分钟学会DBSCAN聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DBSCAN是一种非常著名的基于密度的聚类算法。其英文全称是 Density-Based Spatial Clustering of Applications with Noise，意即：一种基于密度，对噪声鲁棒的空间聚类算法。直观效果上看，DBSCAN算法可以找到样本点的全部密集区域，并把这些密集区域当做一个一个的聚类簇。
DBSCAN算法具有以下特点：
基于密度，对远离密度核心的噪声点鲁棒
无需知道聚类簇的数量
可以发现任意形状的聚类簇
DBSCAN通常适合于对较低维度数据进行聚类分析。
公众号后台回复关键字："源码"，获取本文全部代码和对应插图PPT。
一，基本概念
DBSCAN的基本概念可以用1，2，3，4来总结。
1个核心思想：基于密度。
直观效果上看，DBSCAN算法可以找到样本点的全部密集区域，并把这些密集区域当做一个一个的聚类簇。
2个算法参数：邻域半径R和最少点数目minpoints。 这两个算法参数实际可以刻画什么叫密集——当邻域半径R内的点的个数大于最少点数目minpoints时，就是密集。
3种点的类别：核心点，边界点和噪声点。
邻域半径R内样本点的数量大于等于minpoints的点叫做核心点。不属于核心点但在某个核心点的邻域内的点叫做边界点。既不是核心点也不是边界点的是噪声点。
4种点的关系：密度直达，密度可达，密度相连，非密度相连。
如果P为核心点，Q在P的R邻域内，那么称P到Q密度直达。任何核心点到其自身密度直达，密度直达不具有对称性，如果P到Q密度直达，那么Q到P不一定密度直达。
如果存在核心点P2，P3，……，Pn，且P1到P2密度直达，P2到P3密度直达，……，P(n-1)到Pn密度直达，Pn到Q密度直达，则P1到Q密度可达。密度可达也不具有对称性。
如果存在核心点S，使得S到P和Q都密度可达，则P和Q密度相连。密度相连具有对称性，如果P和Q密度相连，那么Q和P也一定密度相连。密度相连的两个点属于同一个聚类簇。
如果两个点不属于密度相连关系，则两个点非密度相连。非密度相连的两个点属于不同的聚类簇，或者其中存在噪声点。
二，DBSCAN算法步骤
DBSCAN的算法步骤分成两步。
1，寻找核心点形成临时聚类簇。
扫描全部样本点，如果某个样本点R半径范围内点数目&gt;=MinPoints，则将其纳入核心点列表，并将其密度直达的点形成对应的临时聚类簇。
2，合并临时聚类簇得到聚类簇。
对于每一个临时聚类簇，检查其中的点是否为核心点，如果是，将该点对应的临时聚类簇和当前临时聚类簇合并，得到新的临时聚类簇。
重复此操作，直到当前临时聚类簇中的每一个点要么不在核心点列表，要么其密度直达的点都已经在该临时聚类簇，该临时聚类簇升级成为聚类簇。
继续对剩余的临时聚类簇进行相同的合并操作，直到全部临时聚类簇被处理。
三，DBSCAN使用范例
1，生成样本点
import numpy as npimport pandas as pdfrom sklearn import datasets%matplotlib inlineX,_ = datasets.make_moons(500,noise = 0.1,random_state=1)df = pd.DataFrame(X,columns = ['feature1','feature2'])df.plot.scatter('feature1','feature2', s = 100,alpha = 0.6, title = 'dataset by make_moon')
2，调用dbscan接口完成聚类
from sklearn.cluster import dbscan# eps为邻域半径，min_samples为最少点数目core_samples,cluster_ids = dbscan(X, eps = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f0de4e39fc4a5b57ba46c0c0190e3fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a414a6be67f442cfe2067baf103a966/" rel="bookmark">
			python脚本开头怎么写_浅谈Python脚本开头及导包注释自动添加方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅谈Python脚本开头及导包注释自动添加方法
1、开头：#!/usr/bin/python和# -*- coding: utf-8 -*-的作用 – 指定
#!/usr/bin/python
是用来说明脚本语言是python的
是要用/usr/bin下面的程序(工具)python，这个解释器，来解释python脚本，来运行python脚本的。
#!/usr/bin/python：是告诉操作系统执行这个脚本的时候，调用 /usr/bin 下的 python 解释器；
#!/usr/bin/env python(推荐)：这种用法是为了防止操作系统用户没有将 python 装在默认的 /usr/bin 路径里。当系统看到这一行的时候，首先会到 env 设置里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作。
#!/usr/bin/python 相当于写死了python路径;
#!/usr/bin/env python 会去环境设置寻找 python 目录,推荐这种写法
# -*- coding: utf-8 -*-
在python脚本(.py文件)的第一行声明#-*- coding = utf-8后即可在文件中使用中文注释。这句话用来说明你的Python源程序文件用使用的编码。缺省情况下你的程序需要使用ascii码来写，但如果在其中写中文的话，python解释器一般会报错，但如果加上你所用的文件编码，python就会自动处理不再报错。
2、自动添加头设置方法：
File-&gt;settings-&gt;Editor-&gt;File and Code Templates-&gt;Python Script
以上这篇浅谈Python脚本开头及导包注释自动添加方法就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持我们。
时间： 2018-10-26
1.选择File -&gt; Settings 2.选择 File and Code Templates -&gt; Files -&gt; Python Script 编辑代码的样式 #!/usr/bin/env python # encoding: utf-8 ''' @author: caopeng @license: (C) Copyright 2013-2017, Node Supply Chain Manager Corporation Limited.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a414a6be67f442cfe2067baf103a966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8675fd740ae98b7ac4d960314a2ee1d8/" rel="bookmark">
			秋招面试知识点----机网，linux等其他篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rpc 远程过程调用，主要是
1、服务消费者（client客户端）通过本地调用的方式调用服务
2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息
**序列化（**组装）成能够进行网络传输的消息体
3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端
4、服务端存根（server stub）收到消息后进行解码（反序列化操作）
5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理
6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）
7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方
8、客户端存根（client stub）接收到消息，并进行解码（反序列化）
9、服务消费方得到最终结果
linux 查看端口占用
netstat -pan | grep 5623
然后查看进程那个程序的
ps -aux | grep pid
停止进程，-9强制停止
kill -9 pid
telnet ip 端口号
杀死进程
ps -ef | grep 进程名
kill pid
cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行rz上传sz下载scp跨主机传文件 grep - A 5 ‘a’ 文件 #查找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8675fd740ae98b7ac4d960314a2ee1d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ffe9c04060b076797cb5c473aa283c7/" rel="bookmark">
			神经网络 python 多类别_Keras入门（一）搭建深度神经网络（DNN）解决多分类问题...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keras介绍
Keras是一个开源的高层神经网络API，由纯Python编写而成，其后端可以基于Tensorflow、Theano、MXNet以及CNTK。Keras 为支持快速实验而生，能够把你的idea迅速转换为结果。Keras适用的Python版本是：Python 2.7-3.6。
Keras，在希腊语中意为“角”(horn)，于2015年3月份第一次发行，它可以在Windows, Linux, Mac等系统中运行。那么，既然有了TensorFlow(或Theano、MXNet、CNTK)，为什么还需要Keras呢？这是因为，尽管我们可以用TensorFlow等来创建深度神经网络系统，但Tensorflow等使用相对低级的抽象，直接编写TensorFlow代码具有一定的挑战性，而Keras在TensorFlow的基础上，增加了较易使用的抽象层，使用起来更加简单、高效。
什么样的场合适合用Keras呢？如果你有如下需求，请选择Keras：
简易和快速的原型设计(keras具有高度模块化，极简，和可扩充特性)
支持CNN和RNN，或二者的结合
无缝CPU和GPU切换
如果想用在你的电脑上使用Keras，需要以下工具：
Python
TensorFlow
Keras
在这里，我们选择TensorFlow作为Keras的后端工具。使用以下Python代码，可以输出Python、TensorFlow以及Keras的版本号：
import sys
import keras as K
import tensorflow as tf
py_ver = sys.version
k_ver = K.__version__
tf_ver = tf.__version__
print("Using Python version " + str(py_ver))
print("Using Keras version " + str(k_ver))
print("Using TensorFlow version " + str(tf_ver))
在笔者的电脑上，输出的结果如下：
Using TensorFlow backend.
Using Python version 3.5.1 (v3.5.1:37a07cee5969, Dec 6 2015, 01:54:25) [MSC v.1900 64 bit (AMD64)]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ffe9c04060b076797cb5c473aa283c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08d7c389b373bdfb6c582326c2e47af/" rel="bookmark">
			秋招面试知识点----框架篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IoC 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，就是new 对象，对象的创建由程序自己控制，直接写死的，但是这样的话框架的开发者不知道我们写的类名，没法写死在程序，所以就反射进行创建，放到bean工厂里面，就是ioc容器，用的时候就是@autowore，resoruse使用，默认是单例，个人认为所谓控制反转就是：获得依赖对象的方式反转了
就是为了解耦，减少对象之间的联系
依赖注入
：注入！(配置文件，注解)
依赖：bean对象的创建依赖于容器注入：bean对象的所有属性，由有容器注入 ioc业务层就是父容器，向ioc表现层子容器注入
要求被注入的属性 , 必须有set方法 ,
bean周期 1.扫描xml创建容器，根据bean的名字（注解名字首字母小写）和calss解析出全限定类名，反射newInstence获取实例，默认是单例2，DI注入属性或是其他bean的引用，就像service曾调用doa层的方法，引入dao的bean，就是配置的value3.在初始化前aop思想加入后置处理器，在初始刷前后分别进行操作，浙江继承了泛型的类，就是工厂模式这是需要加入ioc的，所有bean都会执行4.进行初始化，这函数在xml中，配置initMathod5.使用bean，初始化成了就能用了6.销毁，就是容器applicationContext或是BeanFactory销毁，就是也要配置销毁方法 aop 就是在不改变代码基础上，增强方法，比如日志，
使用注解实现
@Aspect加在类上配置文件配置可用注解方法加@Before，@After jdk，cglib
jdk就是实现 InvocationHandler 接口，用反射直接拿到反射机制获得动态代理类的构造函数，必须要有接口
为配置文件中所有的bean创建对象，都那个配置
cglib就是基于类的继承机制，对代理对象类的class文件加载，通过修改其字节码生成子类来处理。
jdk都有，就是默认java，没借口的话就是cglib，可以强制设制。
切面类：就是要执行的增强的方法所在的类，比如咱们例子里的MyTransaction类通知（执行方法）：切面类里的方法目标方法：要执行的目标方法织入：把通知和目标方法进行结合，形成代理对象的过程就叫织入 springAOP的具体加载步骤：
1、当spring容器启动的时候，加载了spring的配置文件
2、为配置文件中所有的bean创建对象
3、spring容器在创建对象的时候它会解析aop:config的配置
解析切入点表达式，用切入点表达式和纳入spring容器中的bean做匹配
如果匹配成功，则会为该bean创建代理对象，代理对象的方法=目标方法+通知
如果匹配不成功，则为该bean创建正常的对象
其实就是你通过表达式告诉Spring哪些bean需要它帮你生成代理对象而不是生成原有的正常对象
理解这一点相当重要！
4、在客户端利用context.getBean获取对象时，如果该对象有代理对象则返回代理对象，如果没有代理对象，则返回目标对象
说明：如果目标类没有实现接口，spring容器会采用cglib的方式产生代理对象，如果实现了接口，则会采用jdk的动态代理产生代理对象
Springmvc流程 首先在web.xml中进行注册，实质上注册的时启动类。 springBoot在内置tomcat中默认的加入了这些配置。springBoot表面上不用注册，实质上内部已经完成了注册。
在tomcat启动之后，tomcat会通过dom操作读取xml配置文件，我在阅读源码时发现这个dom操作和HTML的dom操作基本相似。通过dom操作获取框架启动类的路径。通过反射拿到启动类的实例，然后通过代理调用主方法，由此触发框架自定义类的启动。当自定义类启动之后，会扫描根目录下的子文件，把java文件都会筛选出来，筛选之后通过路径进行反射，反射之后通过反射信息看哪些带有自定义的@controller注解。把这些带有注解的类挑选出来之后，再去挑选带有注解的方法。把带有@requestmapping的方法挑选出来。挑选出来之后挑选出来注解里面的路径值。把路径值作为Key，方法的实例作为value存到HashMap中。（启动完毕）
**等待前端请求。**当前端发送请求到端口之后，tomcat会把数据从端口中拿过来。Tomcat把数据拿过来之后，会把他封装成Httpresqest和httpresponse。然后把它交到DispatcherServlet（它就是普通的servlet）里面，（springmvc/boot里面有封装的servlet作为沟通）。当DispatcherServlet接收到这两个参数之后，会httpresquest里面读取url路径，{url组成：ip/域名+端口号+项目路径+内部路径（静态资源路径/controller里定义的路径）}。在DispatcherServlet会把内部路径提取出来，这个内部路径就是controller里面resquesemapping里的路径，当拿到这个路径之后会从HashMap里匹配，拿到对应的方法实例，用java的代理去执行，就是invoke方法。invoke有三个参数（要执行的方法所属的对象实例，方法实例，入参（通过httpresquest里获得））。执行完invoke表明整个调用结束，然后可以给前端返回值。
tomcat流程 原来是servlet+tomact，当时就觉得tomcat很神秘，想了解一下她的实现，喂什么要配合才能使用，为的是可以解析servlet，静态的界面浏览器就能搞定。dopost，doget，就是前台的不同请求，url，form表单提交，默认get。servlet没有主方法，tomcat 就是完全由java写的，这是合成的项目，不象springboot内置tomcat。
tomcat分成了两个阶段，分别是启动阶段和接收转发阶段。
启动阶段：
他会扫描webapp所有的子目录和文件，然后把目录下的.class跳出来，拿到Java全限定类名，用class.formname去获取class信息，遍历每一个类的信息，然后去类里面查@WebServlet注解，生new Instence（），就是tomcat的开发者不知道我们写的servlet的名字和包，又要所有开发者能用，就是反射，只要拿到全限定类名就能生成实例，属性，方法都可以用，就是privite要设置通行，用diclare获取。然后就是拿到实例的method，就是doget，还拿到了注解的路径值，key是路径，势力是value放到map
请求转发：
tomcat收到请求，监听socket端口，用的是natty的socket，借助natty拿到http请求后就会放到线程池中，避免同时来1很多请求撑爆内存，最好不用excuter，会导致请求拥塞，那麽就去自己建线程池七大参数，四种拒绝策略。
线程就开始把传过来http数据封装成httprequest，httpresponse，就是doget有的形参类型。url会被提取出来，IP：端口号：项目名，剩下的就是serverlet的地址，就是localhost：8080/login，或是前台资源就是去相应的目录下找资源，serverlet的话，就是前面注解map匹配对应的servlet实例和 method，invoke函数调用doget。
springboot流程 分为两步，创建application对象，执行run方法
原来的话，启动类就是两句话，new个对象，调run，现在成了静态方法，Springapplication。run（），内部就是new对象，点run（）
1.创建对象
就是一个构造，里面实现的是加载类路径下的上下文context的初始化，还有就是监听器的初始化
2.调那个run方法
有个监听器的start（），开始坚挺启动
再就是trycatch包着的加载springboot配置环境，放到监听器对象中
配置上下文创建，就是实例化上下文对象，就是像spring的context，创建bean工厂，读配置文件
把这监听器，上下文配置起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08d7c389b373bdfb6c582326c2e47af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bc527d625ce99aea86ebe53a8d4e5f/" rel="bookmark">
			秋招面试知识点----JVM篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.发生栈内存溢出。 描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。
栈定义 存放基本类型的变量数据和对象的引用，栈是线程私有的，他的生命周期与线程相同。每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 为什么会溢出 如果线程请求的栈深度大于虚拟机所允许的最大深度，就会抛出StackOverflowError异常。如果虚拟机在扩展栈时无法申请足够的内存空间，就会抛出OutOfMemoryError异常。 相关参数 -Xss 调整JVM栈的大小 栈溢出 无限递归，没有结束条件。
public class StackTest { public static void main(String[] args) { main(args); } } `
2.详解JVM内存模型 思路： 给面试官画一下JVM内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题，如栈溢出等。
共享的，包括 Java 堆和方法区；
私有的，包括虚拟机栈和本地方法栈，以及程序计数器这一小部分内存。
堆内存（Heap）
对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
堆内存是所有线程共有的，可以分为两个部分：年轻代和老年代。
下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代已经被移除。
​ 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )
默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： 空间利用率就是90%
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72bc527d625ce99aea86ebe53a8d4e5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18e2cefd86647d42e2a85d5de3e2547/" rel="bookmark">
			伪元素before、after和定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伪元素before、after和定位 伪元素before和after :before 选择器向选定的元素前插入内容。 使用content 属性来指定要插入的内容。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;教程&lt;/title&gt; &lt;style&gt; p::before { content:"Read this -"; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;My name is Donald&lt;/p&gt; &lt;p&gt;I live in Ducksburg&lt;/p&gt; &lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; :before 作用于 IE8,DOCTYPE 必须已经声明.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; :after选择器向选定的元素后插入内容。 使用content 属性来指定要插入的内容。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;教程&lt;/title&gt; &lt;style&gt; p::after { content:"Read this -"; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;My name is Donald&lt;/p&gt; &lt;p&gt;I live in Ducksburg&lt;/p&gt; &lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; :before 作用于 IE8,DOCTYPE 必须已经声明.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c18e2cefd86647d42e2a85d5de3e2547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e287d643b73ed94622e8c5b8e55f42ce/" rel="bookmark">
			Bean的实例化与装配（实验二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt; bean &gt;元素的常用属性及其子元素
id是一个Bean的唯一标识符，Spring容器对Bean的配置、管理都通过该属性来完成。nameSpring亦可通过该属性对容器中的Bean进行配置和管理，name可为Bean指定多个名称，每个名称用逗号或分号隔开。class该属性指定了Bean的具体实现类。它必须是一个完整的类名，使用类的全限定名。scope用来设定Bean实例的作用域，常用的有：singleton（单例），prototype（原型）。其默认值为singleton（单例）。property元素的子元素，用于调用Bean实例中的setter方法完成属性赋值，完成依赖注入，该元素的name属性指定Bean实例中的相应属性名，ref属性或value属性用于指定参数值。ref可用于指定Bean工厂中某个Bean实例的引用。value可用于直接指定一个常量值。list用于封装List或数组类型的依赖注入。set用于封装Set类型属性的依赖注入。map用于封装Map类型属性的依赖注入。entry的子元素用于设定一个键值对。 在开发过程中最常使用的就是普通的构造器实例化方法：spring容器默认调用类中的无参构造方法对Bean进行实例化。
bean的作用域
作用域描述singleton在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。prototype每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。request每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。session同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。application限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。 基于注解Annotation的装配
虽然基于xml配置文件也能实现bean的装配工作（bean的装配就是指的bean的依赖注入），但是代码过于臃肿，所以基于注解的装配就明显方便很多。
点击此处详细学习——Spring基于Annotation装配Bean
相关约束信息，可在index.html——core1.9中找到。
使用注解之后，spring容器就只需要简单的一行代码。对于spring 4.0以上版本需要导入spring-aop的jar包（在框架包的libs文件夹下）
代码：
package com.csdn1.entity; public interface UserDao { public void say(); } package com.csdn1.entity; import org.springframework.stereotype.Repository; @Repository("userDao") public class UserDaoImplement implements UserDao{ @Override public void say() { // TODO Auto-generated method stub System.out.println("com.csdn1.entity.UserDaoImplement:你已经成功创建了一个java类。。"); } } package com.csdn1.entity; public interface UserService { public void say(); } package com.csdn1.entity; import javax.annotation.Resource; import org.springframework.stereotype.Service; @Service("userService") public class UserServiceImplement implements UserService{ @Resource(name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e287d643b73ed94622e8c5b8e55f42ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325903f5cb62aaafc0b966f3d777fc1c/" rel="bookmark">
			3531交叉编译htop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交叉编译htop 工作需要，开始折腾海思芯片，从头开始，折腾。
busybox里面的top是在太丑了，看不懂，都知道htop是个界面非常友好的系统监控程序，所以决定移植。网上有很多相关内容，比如https://www.cnblogs.com/txsf/p/3713991.html，但是我按照内容操作，始终再htop的configure的时候提示我缺少libcurses，但是我确实已经编译过了，而且还验证了可执行程序再开发板上面的执行效果，所以不会有问题的。
终端显示的内容如下：
checking if compiler supports -Wextra... yes checking for refresh in -lncurses... no checking for refresh in -lncurses6... no checking for refresh in -lncurses... (cached) no checking curses.h usability... yes checking curses.h presence... yes checking for curses.h... yes checking for python... python configure: error: missing libraries: libncurses 最后只好看config.log文件了，发现里面有个奇怪的问题，提示缺少libtinfo库，和libcurses
tinfo -L/home/hero/project/ncurses-6.1/install/lib conftest.c -lncurses -lm &gt;&amp;5 /opt/hisi-linux/x86-arm/aarch64-himix200-linux/host_bin/../lib/gcc/aarch64-linux-gnu/7.3.0/../../../../aarch64-linux-gnu/bin/ld: cannot find -ltinfo collect2: error: ld returned 1 exit status configure:6210: $?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/325903f5cb62aaafc0b966f3d777fc1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0cfcd20502763d2cfe7bfcb6e446034/" rel="bookmark">
			Mysql_循环执行存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package test; import jdbc.MysqlHelper; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Calendar; import java.util.Date; import java.util.List; public class test2 { public static void main(String[] args) throws ParseException { List&lt;String&gt; dates = getDates("2020-08-1", "2020-08-18"); for(String date:dates){ SimpleDateFormat simpleDateFormat = new SimpleDateFormat( "yyyy-MM-dd");// 注意月份是MM ArrayList&lt;String&gt; time = getTime(simpleDateFormat.parse(date)); //	循环执行存储过程 for(String s:time){ String sql="CALL 存储过程名称('"+s+"');"; System.out.println(s); int executeIn = MysqlHelper.executeIn(sql); System.out.println(executeIn); } } } public static ArrayList&lt;String&gt; getTime(Date day) throws ParseException { // Date day=new Date(); SimpleDateFormat df = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0cfcd20502763d2cfe7bfcb6e446034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ce0f2612f4597971327ddeebeea00f/" rel="bookmark">
			python mk趋势检验_python改写MK趋势检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(一)关于MK检验
降雨、径流分析采用非参数检验方法曼-肯德尔法(Mann-Kendall)检验法来检测泾河合水川流域降水的长期变化趋势和突变情况。在时间序列趋势分析中，Mann-Kendall检验方法，最初由Mann和Kendall提出，许多学者不断应用Mann-Kendall方法分析降水、径流、气温和水质等要素时间序列趋势变化[6-7]。Mann-Kendall检验不需要样本遵循一定的分布，也不受少数异常值的干扰，适用于水文、气象等非正态分布的数据，计算方便。
在Mann-Kendall检验中，原假设H0为时间序列数据(X1，…,Xn),是n个独立的、随机变量同分布的样本；备择假设H1 是双边检验，对于所有的k，j≤n，且k≠j，Xk和Xj的分布是不相同的，检验的统计量S计算如下式：
Paste_Image.png
其中，
Paste_Image.png
S为正态分布，其均值为0，方差 。当n&gt;10时，标准的正态系统变量通过下式计算：
Paste_Image.png
这样，在双边的趋势检验中，在给定的α置信水平上，如果
Paste_Image.png
则原假设是不可接受的，即在α置信水平上，时间序列数据存在明显的上升或下降趋势。对于统计量Z，大于0时是上升趋势；小于0时是下降趋势。Z的绝对值在大于等于1.28、1、64和2.32时，分别表示通过了信度90%，95%，99%的显著性检验。
(二)Matlab原有代码
function [slope,zc,za,sign]=MannKendall(x)
%计算S
s=0;
len=size(x,2);
for m=1:len-1
for n=m+1:len
if x(n)&gt;x(m)
s=s+1;
elseif x(n)==x(m)
s=s+0;
else
s=s-1;
end
end
end
%计算vars和e
vars=len(len-1)(2*len+5)/18;
%计算zc
if s&gt;0
zc=(s-1)/sqrt(vars);
else
zc=(s+1)/sqrt(vars);
end
%计算za
za=var(x);
sign=0;
zc1=abs(zc);
if zc1 &gt;= za
sign=1;
else
sign=0;
end
%计算倾斜度
ndash = len * ( len - 1 ) / 2;
slope1= zeros( ndash, 1 );
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ce0f2612f4597971327ddeebeea00f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b27209dc474a4daebbf4e1372a5a2c3/" rel="bookmark">
			Python3 MySQL正常连接与ssh跳板连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、所需Python库二、连接方式1.正常连接（mysql允许远程访问）2.ssh跳板连接（适用云数据库内网ip） 一、所需Python库 1.mysql.connector(pip install mysql.connector)
2.pymysql(pip install pymysql)
3.sshtunnel(pip install sshtunnel)
二、连接方式 1.正常连接（mysql允许远程访问） import mysql.connector db = mysql.connector.connect( host = "192.168.1.1", # ip port = 3306, # 数据库端口 user = "test", # 数据库用户名 passwd = "test", # 数据库密码 database = "test" # 需连接数据库名 auth_plugin = "mysql_native_password" # mysql8需添加 ) mycursor = db.cursor() # 新建游标 mycursor.execute(sql) # 执行sql语句 print("mycursor.fetchone()") # sql查询输出方式一条，str print("mycursor.fetchmany(4)") # sql查询输出方式多条，参数为数量，list print("mycursor.fetchall()") # sql查询输出方式所有，list db.commit() # sql修改提交保存 print(mycursor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b27209dc474a4daebbf4e1372a5a2c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405b18feca71d64765f066ebabc8c9aa/" rel="bookmark">
			tekla插件_CAD三维线模导入Tekla快速建模图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天我发了个cad三维线模导入Tekla快速建模的文章，有不少朋友让我做个具体的操作视频教程，说实在的，我这把年纪你让我录个视频教程，还要语音的，那真是要我老命了，普通话都讲不好，想来想去还是做个图文教程吧。言归正传
首先要快速导入之前，需要下载两个小插件(都是完全免费的)
1、SSBIM for CAD下载地址及安装方法：
http://zt.ggditu.com/Proscenium/watchTechnic.aspx?technicID=7504
2、SSBIM for Tekla 下载地址及安装方法：(这个是不用安装，下载解压就可以使用)
http://zt.ggditu.com/Proscenium/watchTechnic.aspx?technicID=7419
教程开始
第一步，处理cad三维线模
我们收到的三维线模，一般都是按截面规格分好层的
1、线模不能是图块形式的，如果是图块就要炸开，有的需要炸好几次；完全炸开之后就点SSBIM for AutoCAD里面的“导出非SSBIM所建三维线模数据”
然后插件会提示选择三维线模，你就选择你要导出的东西，选中后回车弹出下面的对话框
点保存，得到一个txt数据文件(这个文件是可以编辑的)，这个文件导入Tekla的时候要用到
2、打开这个文件把这里的图层命名统一改成SSBIM for CAD里面的格式(P377x16~Q345B)、(H400*300*8*12~Q235B)
修改完之后就保存。
第二步，导入Tekla中
1、打开Tekla，然后再打开对应版本的SSBIM for Tekla，点下面的按钮
弹出下面的对话框，点按钮
选择刚才导出的txt文件，点打开
发现跳出警示框出错了
表示cad文件里面图层命名不规范，那我们来找找，打开txt文件，查找TABLE，一个一个下去找，呃，找到了
里面可能会有许多个，一个一个找下去，直到把这个+号全部改成~就可以了，重复前面的步骤，把这个txt文件导入tekla中来，出现下面的对话框
有朋友就会问了，这里面有好多个截面型材，怎么导进来只有一个截面了，其它的截面呢？别急，让我告诉你；这个插件在做的时候把国标的截面型材自动导入不需要手动导入，只有非国标的才会让你手动选择。那么我继续，截面形式选择圆管，因为P500x20是圆管，然后在截面数据绑定这里的500选择d，20这里选择t
完了之后点确定，插件就自动把里面的数据读出来然后在Tekla里面进行建模
等到弹出加载完成对话框后，我们关闭对话框，发现不完整，咋回事，我一查，原来是视图深度不够，于是我加高深度，整个工程效果就出来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef4ed02b5d9d168a394065c48ac5c405/" rel="bookmark">
			No EntityManager with actual transaction available for current thread - cannot reliably process
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		No EntityManager with actual transaction available for current thread - cannot reliably process ‘remove’ cal
原因是在删除操作上没有添加事务管理。
解决方法：
在对应的@Service或组件上添加@Transactional即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bec3801f89223811c77fca5722e2422/" rel="bookmark">
			python编程玩具有哪些_python 全栈开发，Day133(玩具与玩具之间的对话,基于jieba gensim  pypinyin实现的自然语言处理,打包apk)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先下载github代码，下面的操作，都是基于这个版本来的！
注意：由于涉及到版权问题，此附件没有图片和音乐。请参考链接，手动采集一下！
请参考链接：
一、玩具与玩具之间的对话
app消息提醒
之前实现了App发送语音消息给web端玩具，web端有消息提醒。现在app端，也需要消息提醒！
那么在后端，需要判断。这个消息是人还是玩具发送的消息。加一个user_type
玩具表增加user_type
修改玩具表toys。这里的小鱼，表示用户！
增加user_type
toys表的其他记录，也需要一并修改
务必保证 friend_list里面的每一条记录。都有user_type字段！
务必保证，每一个玩具都有2个好友。一个是主人，一个是除自己之外的玩具。
用户表增加user_type
修改用户表
修改第一个好友，增加user_type字段，toy表示玩具
修改另外一条记录
完整数据如下：
{"_id" : ObjectId("5b9bb768e1253281608e96eb"),"username" : "xiao","password" : "202cb962ac59075b964b07152d234b70","age" : "20","nickname" : "xiao","gender" : "1","phone" : "1234567","avatar" : "boy.jpg","bind_toy": ["5ba0f1f2e12532418089bf88","5ba21c84e1253229c4acbd12"],"friend_list": [
{"friend_id" : "5ba0f1f2e12532418089bf88","friend_name" : "小可爱","friend_remark" : "小甜甜","friend_avatar" : "girl.jpg","friend_chat" : "5ba0f1f2e12532418089bf87","user_type" : "toy"},
{"friend_id" : "5ba21c84e1253229c4acbd12","friend_name" : "嘻嘻","friend_remark" : "小豆芽","friend_avatar" : "girl.jpg","friend_chat" : "5ba21c84e1253229c4acbd11","user_type" : "toy"}
]
}
View Code
务必保证 friend_list里面的每一条记录。都有user_type字段！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bec3801f89223811c77fca5722e2422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4537cf7cc3a2405f09681db995f532df/" rel="bookmark">
			python union函数_Python NumPy ufunc 集合操作(unique、union1d、intersect1d、setdiff1d、setxor1d)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是集合
数学上的集合是唯一元素的集合。
集合用于频繁的交、并、差运算。
2、在NumPy中创建集合
我们可以使用NumPy的unique()方法从任何数组中查找唯一元素。 创建一个set数组，但请记住set数组只能是一维数组。
例如：
将具有重复元素的以下数组转换为集合：import numpy as np
arr = np.array([1, 1, 1, 2, 3, 4, 5, 5, 6, 7])
x = np.unique(arr)
print(x)
3、求并集(union1d)
要查找两个数组的唯一值，请使用union1d()方法。
例如：
计算以下两个集合数组的并集：import numpy as np
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([3, 4, 5, 6])
newarr = np.union1d(arr1, arr2)
print(newarr)
4、求交集(intersect1d)
若要仅查找两个数组中都存在的值，请使用intersect1d()方法。
例如：
计算以下两个集合数组的交集：import numpy as np
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([3, 4, 5, 6])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4537cf7cc3a2405f09681db995f532df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50f81d18b512a6609d2ef6eaa9ca0b8/" rel="bookmark">
			stm32cubemx生成不了keil工程文件_STM32CubeMx取消freeRTOS重新生成工程运行卡死
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 芯片型号：STM32F427VG
软件版本：Stm32CubeMx 5.6.0
库版本：STM32Cube FW_F4 V1.25.0
使用STM32CubeMx配置了freeRTOS，用得不爽等各种原因又不想要freeRTOS了，就取消了freeRTOS，将SYS-&gt;Timebase Souce改回SysTick，重新设置中断优先级，重新生成工程，去除工程中自己添加的和freeRTOS有关的代码，重新编译，编译没问题，下载到stm32板子上后莫名的卡死，启动就卡死，串口打印信息打印到一半就卡住了，很无语
经过艰难的检查，发现系统的SysTick_Handler中断代码不存在，代码没有自动生成，估计这是个bug，然后自己对比了之前没有配置freeRTOS前的stm32CubeMx工程文件(你的工程名称.ioc)
比较结果如下：左侧为之前没配置freeRTOS前的ioc文件内容，右侧为配置freeRTOS后又取消的ioc文件内容
​
正确配置应该为：
NVIC.SysTick_IRQn=true:0:0:false:false:true:false:true 手动修改一下ioc文件然后重新打开，重新生成工程即可
当然也可以手动添加中断函数，或者保留使用定时器方式也应该没问题
/** * @brief This function handles System tick timer. */void SysTick_Handler(void){ /* USER CODE BEGIN SysTick_IRQn 0 */ /* USER CODE END SysTick_IRQn 0 */ HAL_IncTick(); /* USER CODE BEGIN SysTick_IRQn 1 */ /* USER CODE END SysTick_IRQn 1 */} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1700d0bc3e9ac07665b6b1f5b1d1a5a4/" rel="bookmark">
			Pyhone3 从Kafka拿取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 这篇博客搭配之前写的oracle，mysql数据同步使用
一、安装pykafka pip install pykafka 二、使用步骤 1.列出所有topic from pykafka import KafkaClient client = KafkaClient(hosts="ip:9092") #连接kafka for topic in client.topics: print(topic) 2.读取数据 import json from pykafka import KafkaClient client = KafkaClient(hosts="ip:9092") # 连接 topic = client.topics['test'] # 连接的topics consumer = topic.get_simple_consumer(consumer_group="test",reset_offset_on_start=True) for message in consumer: if message is not None: print(message.offset) # 偏移量 print(message.value) # kafka数据 try: data = json.loads(message.value.decode("utf-8"))['payload']['data'] if data is not None: print(data) # 拿取同步数据 except:pass 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7862d6499194a279f75efffd0ef1bc84/" rel="bookmark">
			最通透的KMP算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 以前自己写一个字符串匹配或者主串中查找子串的程序时，都是用一个指针指向主串，另一个指针指向子串，然后两指针按字母逐一比较，看着自己写的代码运行一切正常时还沾沾自喜，现在想来 ~~，虽然这种方法也行的通，但是当字符串足够长时，效率会很低，自从看到了KMP算法，我觉得人类的智慧真的超乎想象，无论什么事情总能想出更优更简的解决方法，我们生活中也是，真的很多事情用对了方法能事半功倍，对于我们大部分人来说，自己研究出一种算法真的太难了，但是我们可以站在前人的肩膀上，学习他们的思想与经验，将它们用起来，对我们的工作也是大有裨益的！
什么是KMP算法 KMP算法是一种改进的字符串匹配算法，是由国外的三位大神提出来的，命名也是取这三位大神每人名字中的一个字母，KMP算法的核心是
利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。
网上有大把对KMP算法讲解的文章，但这一篇是我见过的讲的最通透最明白的文章了，也非常通俗易懂！
KMP算法详解 例如有一个字符串"BBC ABCDAB ABCDABCDABDE"，我想知道，里面是否包含另一个字符串"ABCDABD"？
许多算法可以完成这个任务，Knuth-Morris-Pratt算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。
这种算法不太容易理解，网上有很多解释，但读起来都很费劲。直到读到Jake Boxer的文章，我才真正理解这种算法。下面，我用自己的语言，试图写一篇比较好懂的KMP算法解释。
1.
首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。
2.
因为B与A不匹配，搜索词再往后移。
3.
就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。
4.
接着比较字符串和搜索词的下一个字符，还是相同。
5.
直到字符串有一个字符，与搜索词对应的字符不相同为止。
6.
这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移到已经比较过的位置，重比一遍。
7.
一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是"ABCDAB"。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率。
8.
怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。
9.
已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：
移动位数 = 已匹配的字符数 - 对应的部分匹配值
因为 6 - 2 等于4，所以将搜索词向后移动4位。
10.
因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（“AB”），对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。
11.
因为空格与A不匹配，继续后移一位。
12.
逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。
13.
逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。
14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7862d6499194a279f75efffd0ef1bc84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9321228b133d135e9842002abb401836/" rel="bookmark">
			vtkimage to numpy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import numpy as np import vtk from vtk.util.numpy_support import vtk_to_numpy image = *.GetOutput() #只要得到的数据类型为vtkimage即可 rows, cols, _ = image.GetDimensions() scalars = image.GetPointData().GetScalars() arr = vtk_to_numpy(scalars) arr = arr.reshape(rows, cols, -1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2271445001d3a47f7ec364bf1dc70d70/" rel="bookmark">
			【5G核心网】5GC核心网之网元AUSF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AUSF， Authentication Server Function 鉴权服务功能。网络功能（NF）鉴权服务功能（AUSF）是 5G 核心网络（5GC）中的网络实体，支持以下功能：
- 为请求者NF验证UE
- 向请求者NF提供密钥材料
- 保护请求者NF的“指导信息列表”。
Figure 4-1: AUSF in 5G System architecture 该图表示基于服务的体系结构模型中的 AUSF 体系结构。 在参考点模型中，AMF 和 AUSF 之间的接口称为 N12。 在此版本中，SEAF 功能 与 AMF 并置。 AUSF 可以向 UDM 提供服务。
AUSF 提供的服务 - Nausf_UEAuthentication
- Nausf_SoRProtection
- Nausf_UPUProtection
1. Nausf_UEAuthentication Service AUSF 充当 NF 服务生产者。 它向请求者 NF 提供 UE 认证服务。 NF 服务使用者是 AMF。对于此服务，定义了以下服务操作：
- Authenticate
该服务允许对 UE 进行身份验证，并提供一个或多个主密钥，AMF 会使用这些主密钥来派生后续密钥。
1.1 Authenticate 服务操作“Authenticate”通过向 AUSF 提供以下信息，允许请求者 NF 发起 UE 的身份验证：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2271445001d3a47f7ec364bf1dc70d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3d4e182d3486953e0c42e4beaebc98/" rel="bookmark">
			js回到顶部代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
html **
&lt;div class="index"&gt; &lt;ul&gt; &lt;li&gt; &lt;img src="https://www.jq22.com/img/cs/500x500-1.png" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://www.jq22.com/img/cs/500x500-1.png" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://www.jq22.com/img/cs/500x500-1.png" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://www.jq22.com/img/cs/500x500-1.png" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://www.jq22.com/img/cs/500x300-1.png" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://www.jq22.com/img/cs/500x300-1.png" alt=""&gt; &lt;/li&gt; &lt;li&gt; &lt;img src="https://www.jq22.com/img/cs/500x300-1.png" alt=""&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button id="btn" class="btnTop" style="display: none;"&gt; 回到顶部 &lt;/button&gt; &lt;/div&gt; **
css **
body,html { width:100%; background:rgb(247,246,246); } ul { width:90%; margin:100px auto; background:rgb(2,47,248); } ul li { width:100%; margin:30px 0; } ul li img { width:100%; height:100%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3d4e182d3486953e0c42e4beaebc98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8964d6fb7708d97030240b46c06e8fe0/" rel="bookmark">
			使用多尺度注意力进行语义分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一项重要的技术，通常用于自动驾驶、医学成像，甚至缩放虚拟背景：“语义分割。这是将图像中的像素标记为属于N类中的一个(N是任意数量的类)的过程，这些类可以是像汽车、道路、人或树这样的东西。就医学图像而言，类别对应于不同的器官或解剖结构。
NVIDIA Research正在研究语义分割，因为它是一项广泛适用的技术。我们还相信，改进语义分割的技术也可能有助于改进许多其他密集预测任务，如光流预测(预测物体的运动)，图像超分辨率，等等。
我们开发出一种新方法的语义分割方法，在两个共同的基准：Cityscapes和Mapillary Vistas上达到了SOTA的结果。。IOU是交并比，是描述语义分割预测精度的度量。
在Cityscapes中，这种方法在测试集上达到了85.4 IOU，考虑到这些分数之间的接近程度，这相对于其他方法来说是一个相当大的进步。
在Mapillary上，使用单个模型在验证集上达到了61.1 IOU，相比于其他的使用了模型集成最优结果是58.7。
预测结果
研究过程
为了开发这种新方法，我们考虑了图像的哪些特定区域需要改进。图2显示了当前语义分割模型的两种最大的失败模式：细节错误和类混淆。
图2，举例说明语义分割的由于尺度原因出现的常见错误模式。在第一行中，在缩小了0.5x的图像中，细细的邮箱被分割得不一致，但是在扩大了2.0x的图像中，预测得更好。在第二行中，较大的道路/隔离带区域在较低的分辨率(0.5x)下分割效果较好
在这个例子中，存在两个问题：细节和类混淆。
第一张图片中邮箱的细节在2倍尺度的预测中得到了最好的分辨，但在0.5倍尺度下的分辨很差。与中值分割相比，在0.5x尺度下对道路的粗预测要比在2x尺度下更好，在2x尺度下存在类混淆。 我们的解决方案在这两个问题上的性能都能好得多，类混淆几乎没有发生，对细节的预测也更加平滑和一致。
在确定了这些错误模式之后，团队试验了许多不同的策略，包括不同的网络主干(例如，WiderResnet-38、EfficientNet-B4、xcepase -71)，以及不同的分割解码器(例如，DeeperLab)。我们决定采用HRNet作为网络主干，RMI作为主要的损失函数。
HRNet已经被证明非常适合计算机视觉任务，因为它保持了比以前的网络WiderResnet38高2倍分辨率的表示。RMI损失提供了一种无需诉诸于条件随机场之类的东西就能获得结构性损失的方法。HRNet和RMI损失都有助于解决细节和类混淆。
为了进一步解决主要的错误模式，我们创新了两种方法：多尺度注意力和自动标记。
多尺度注意力
在计算机视觉模型中，通常采用多尺度推理的方法来获得最佳的结果。多尺度图像在网络中运行，并将结果使用平均池化组合起来。
使用平均池化作为一个组合策略，将所有尺度视为同等重要。然而，精细的细节通常在较高的尺度上被最好地预测，大的物体在较低的尺度上被更好地预测，在较低的尺度上，网络的感受野能够更好地理解场景。
学习如何在像素级结合多尺度预测可以帮助解决这个问题。之前就有关于这一策略的研究，Chen等人的Attention to Scale是最接近的。在这个方法中，同时学习所有尺度的注意力。我们将其称为显式方法，如下图所示。
图3，Chen等人的显式方法是学习一套固定尺度的密集注意力mask，将它们结合起来形成最终的语义预测。
受Chen方法的启发，我们提出了一个多尺度的注意力模型，该模型也学会了预测一个密集的mask，从而将多尺度的预测结合在一起。但是在这个方法中，我们学习了一个相对的注意力mask，用于在一个尺度和下一个更高的尺度之间进行注意力，如图4所示。我们将其称为层次方法。
图4，我们的分层多尺度注意力方法。上图：在训练过程中，我们的模型学会了预测两个相邻尺度对之间的注意力。下图：推理以链式/分层的方式完成，以便将多个预测尺度组合在一起。低尺度注意力决定了下一个更高尺度的贡献。
这种方法的主要好处如下：
理论训练成本比Chen方法降低了约4x。训练只在成对的尺度上进行，推理是灵活的，可以在任意数量的尺度上进行。 表3，层次多尺度注意力方法与Mapillary验证集上其他方法的比较。网络结构为DeepLab V3+和ResNet-50主干。评估尺度：用于多尺度评估的尺度。FLOPS：网络用于训练的相对flops。这种方法获得了最好的验证集分数，但是与显式方法相比，计算量只是中等。
图5显示了我们的方法的一些例子，以及已学习的注意力mask。对于左边图片中邮箱的细节，我们很少关注0.5x的预测，但是对2.0x尺度的预测非常关注。相反，对于右侧图像中非常大的道路/隔离带区域，注意力机制学会最大程度地利用较低的尺度(0.5x)，以及更少地利用错误的2.0x预测。
图5，两种不同场景的语义和注意力预测。左边的场景说明了一个精细的细节问题，而右边的场景说明了一个大的区域分割问题。白色表示较高的值(接近1.0)。给定像素在所有尺度上的注意力值总和为1.0。左：道路边的细邮箱在2倍的尺度下得到最好的分辨率，注意力成功地关注了这个尺度而不是其他尺度，这可以从2倍注意力图像中邮箱的白色中得到证明。右图：大的道路/隔离带区域在0.5x尺度下的预测效果最好，并且该区域的注意力确实成功地集中在0.5x尺度上。
自动标记
改进城市景观语义分割结果的一种常用方法是利用大量的粗标记数据。这个数据大约是基线精标注数据的7倍。过去Cityscapes上的SOTA方法会使用粗标注标签，或者使用粗标注的数据对网络进行预训练，或者将其与细标注数据混合使用。
然而，粗标注的标签是一个挑战，因为它们是有噪声的和不精确的。ground truth粗标签如图6所示为“原始粗标签”。
图6，自动生成粗图像标签的例子。自动生成的粗标签(右)提供了比原始的ground truth粗标签(中)更精细的标签细节。这种更精细的标签改善了标签的分布，因为现在小的和大的物品都有了表示，而不是只在主要的大的物品上才有。
受最近工作的启发，我们将自动标注作为一种方法，以产生更丰富的标签，以填补ground truth粗标签的标签空白。我们生成的自动标签显示了比基线粗标签更好的细节，如图6所示。我们认为，通过填补长尾类的数据分布空白，这有助于泛化。
使用自动标记的朴素方法，例如使用来自教师网络的多类概率来指导学生，将在磁盘空间上花费非常大的代价。为20,000张横跨19个类的、分辨率都为1920×1080的粗图像生成标签大约需要2tb的存储空间。这么大的代价最大的影响将是降低训练成绩。
我们使用硬阈值方法而不是软阈值方法来将生成的标签占用空间从2TB大大减少到600mb。在这个方法中，教师预测概率 &gt; 0.5是有效的，较低概率的预测被视为“忽略”类。表4显示了将粗数据添加到细数据和使用融合后的数据集训练新学生的好处。
表4，这里显示的基线方法使用HRNet-OCR作为主干和我们的多尺度注意方法。我们比较了两种模式：用ground truth 细标签 + ground truth粗标签训练到ground truth 细标签 + auto-粗标签(我们的方法)。使用自动粗化标签的方法在基线上提高了0.9的IOU。
图7，自动生成粗图像标签的例子
最后的细节
该模型使用PyTorch框架在4个DGX节点上对fp16张量核进行自动混合精度训练。
论文：https://arxiv.org/abs/2005.10821
代码：https://github.com/nvidia/semanic-segmentation
接下来，给大家介绍一下租用GPU做实验的方法，我们是在智星云租用的GPU，使用体验很好。具体大家可以参考：智星云官网： http://www.ai-galaxy.cn/，淘宝店：https://shop36573300.taobao.com/公众号: 智星AI
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1274f9c176ae55dbfa978f4bafc629d6/" rel="bookmark">
			如果你的拯救者笔记本电脑卡顿，那么可以这样试试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现拯救者电脑卡成狗。自己想着不应该啊，这么高的配置，至于卸载电脑管家或者禁用启动项应该不至于影响到电脑卡顿。
后来一阵摸索，发现发电源调成高性能就可以了。可能上一次使用时候没有插电源导致电量快耗尽了，隐约记得提示我进入节能模式。应该就这个这个模式导致的。
点击windows图标 -&gt; 点击左下侧齿轮样式的设置图标 -&gt; 点击系统
之后点击创建电源计划
我这里自己创建了一个高性能的。所以可能比你的显示多出这个。
然后选择高性能即可
如上图所示，点击下一步然后按照提示输入确定即可。经过这个调整，感觉电脑又丝般顺滑了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8eccd5757f6b1deb46982a0d9b356cc/" rel="bookmark">
			ASP数组Ubound与Lbound
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dim arr(10)
定义了这样一个数组之后，我们知道它的下标为0-10. 但如果ReDim arr(i)这样定义的一个数组呢？我们还能很一目了然的知道数组下标的上下边界吗？
a="1,2,3"
arr = split(a,",")
这段代码是我们经常用来将一个字符分割成一个数组的代码。怎么知道分割出来的数组有多少个元素呢？
1、Ubound
Ubound是用于获取数组的下标的上边界，即最大的下标。
a="1,2,3"
arr = split(a,",")
Response.Write Ubound(arr)
输出的结果为2，于是我们可以知道，要得到这个arr的数组元素的个数，可以用Ubound(arr)+1即可。
2、Lbound
Lbound与Ubound恰好相反，它用于获取ASP数组的下标的下边界，即最小值。很多兄弟就要问了，数组的下标的下边界不就是0吗，还要搞个这个函数干嘛？吃饱了撑的？呵呵，当然不是。原因是ASP中的数组还有如下一种定义方式：
dim arr(2 to 5) '下标从2到5
看到这个语句有没有傻掉了的？^_^ 现在大家知道Lbound的作用了吧，Lbound(arr)的值为2。
当然了，一般情况下，我们不会干出下标最小值不是0这样蛋疼的事情！所以Lbound这个函数，还真是一般情况下用不上。
3、二维数组的Ubound
二维数组也可以使用Ubound和Lbound，且看下面例子：
dim arr(2,5)
二维数组的第一维下标最大值，Ubound(arr)的值2；
二维数组的第二维下标最大值，Ubound(arr,2)的值为5；
二维数组的第一维下标最小值，Lbound(arr)的值0；
二维数组的第二维下标最小值，Lbound(arr,2)的值为0；
关于ASP数组Ubound与Lbound，本文就介绍这么多，希望对您有所帮助，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e159536377b4395c26b21b6c1aee802a/" rel="bookmark">
			linux系统维护篇：centos6.5 yum无法安装YumRepo Error: All mirror URLs are not using ftp, http[s] or file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用yum安装软件的时候突然提示错误：
[root@dukeServer softwares]# yum install tcp Loaded plugins: fastestmirror, security Setting up Install Process Loading mirror speeds from cached hostfile YumRepo Error: All mirror URLs are not using ftp, http[s] or file. Eg. Invalid release/repo/arch combination/ removing mirrorlist with no valid mirrors: /var/cache/yum/x86_64/6/base/mirrorlist.txt Error: Cannot find a valid baseurl for repo: base 折腾了老半天，找了N多资料，过程就不详述了，整理一个完整的解决方案。两步走。
1、备份yum的基础配置文件 [root@dukeServer softwares]# cp -ri /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 2、修改基础配置文件，可完全拷贝下面内容 # CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e159536377b4395c26b21b6c1aee802a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83ac38c1bc2f40dc3c356e4df5b57f6/" rel="bookmark">
			淘宝怎么看历史价格走势曲线?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在网购的时候，有时候可能会遇到商家先涨价，再打折的情况。为了避免购物过程被坑，今天小编教大家如何查询一件商品的历史价格和历史折扣信息。
第一步：首先，打开淘宝App，找到要查询的商品。
第二步：点击商品进入商品详情页，然后点击分享按钮。
第三步：点击图中 复制链接 按钮，复制该商品的链接。
第四步：关注并打开 历史价格速查 公众号，并把刚刚复制的内容回复给公众号后台。然后点击图中蓝色的文字。
第五步：然后，我们就可以看到这件商品的历史价格趋势，和历史折扣信息啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba831e844634556219bdaf905072c4d/" rel="bookmark">
			佳能6780清零软件_佳能G2810 3800系列出现5B00如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		佳能清零软件万能版操作手册通用于佳能所以系列如MG G TS MX MP IX等等
注意事项:请一定先打开软件再进维修模式佳能打印机清零须在维修模式下操作，未进到维维修模式清零会报错006 001 005。需要清零软件包的联系工程师 2、佳能打印机清零须用USB接上电脑操作，进了维修模式后不能断电。
3、佳能打印机清零一定要在打印机里放张纸，不放纸不提示清零成功。
4、打印机有硬件问题清零会报错009，正常关闭打印机排除硬件问题再操作
二、进入维修模式
1.先关闭打印机，再按【停止】键，然后按【电源】 键。(两个按键都不松开)
2.当电源灯点亮时，不松开【电源】按键的同时，松开【停止】按键 然后按【停止】键5次，接下来松开【电源】键。
3、当电源灯长亮时，维修模式进入成功。（G系列的机子有时会亮两个灯）
三、清零软件使用（软件授权为注册一台电脑永久使用）
打印机进入维修模式后，软件显示相应的型号，打印机里放好打印纸，并点击[清零]按钮清零，当提示[恭喜您！清零成功！]时，关闭打印机重开即可。
温馨提示：废墨计数器：一般选 主要 ，如报错002 请选择 全
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2118b37165c2dae00e49bee99a31fb1a/" rel="bookmark">
			基于K8S的hadoop集群初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人博客服务器没在续，在这里开始第一遍 1、hadoop集群1.1、基于yarn的hdfs安装1.2、使用hive 2、spark集群2.1 基于yarn的spark集群2.2 yarn资源调度流程 总结： 1、hadoop集群 1.1、基于yarn的hdfs安装 前言：yarn服务需要每个节点之间通过host进行通信，hdfs的name node也需要知道data node的host
1、基于docker-compose启动可以使用link来获取其他容器host
2、基于k8s的搭建，难点则在host的同步
本次搭建基于四台机器的集群测试搭建，基于yarn的hdfs部署，由于本次记录是为了k8s集群搭建，主要记录搭建步骤，文件的详细配置、其他安装方式如local、standalone可以参考其他文章，环境如下：
master：192.168.81.232
slave1： 192.168.81.231
slave2： 192.168.81.227
slave3： 192.168.81.228
masterslave1slave2slave3hdfsname node, data nodedata nodedata node，secondarynamenodedata nodeyarnnode managerresource manager,node managernode managernode managerhivehivesparkspark filespark filespark filespark file 1、hadoop文件配置（括号中配置主要是地址配置）：
每台机器部署jdk安装（1.8版本）core-site.xml文件配置（存储目录、name node地址）hdfs-site.xml文件配置（副本数量、secondarynamenode地址）yarn-env.sh文件配置jdk路径yarn-site.xml文件配置resourcemanager地址mapred-env.sh配置jdk路径mapred-site.xml配置mr运行在yarn 上 2、配置好的hadoop文件夹分发到4台机器上
3、在namenode上执行hdfs namenode -format
4、启动集群（没有用yarn的启动文件，所以不需要设置免密登陆，为了用k8s的启动命令）:
(nohup 命令 &amp;) ：以子进程后台启动
# master: (nohup hdfs namenode &amp;) (nohup hdfs datanode -regular &amp;) (nohup yarn nodemanager -regular &amp;) # slave1: (nohup hdfs datanode -regular &amp;) (nohup yarn nodemanager &amp;) (nohup yarn resourcemanager &amp;) # slave2: (nohup hdfs datanode -regular &amp;) (nohup yarn nodemanager &amp;) (nohup hdfs secondarynamenode &amp;) # slave3: (nohup hdfs datanode -regular &amp;) (nohup yarn nodemanager &amp;) 至此hdfs集群就已经安装成功了，如需启动name node的HA，可以启动zookeeper的k8s集群，并在hadoop的：hdfs-site.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2118b37165c2dae00e49bee99a31fb1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff81078ae4560df21a7bc4f476a1e630/" rel="bookmark">
			springboot 获取application参数_Spring Boot 配置加载顺序详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Spring Boot 会涉及到各种各样的配置，如开发、测试、线上就至少 3 套配置信息了。Spring Boot 可以轻松的帮助我们使用相同的代码就能使开发、测试、线上环境使用不同的配置。
在 Spring Boot 里面，可以使用以下几种方式来加载配置。本章内容基于 Spring Boot 2.0 进行详解。
1、properties文件；
2、YAML文件；
3、系统环境变量；
4、命令行参数；
等等……
我们可以在 Spring Beans 里面直接使用这些配置文件中加载的值，如：
1、使用 @Value 注解直接注入对应的值，这能获取到 Spring 中 Environment 的值；
2、使用 @ConfigurationProperties 注解把对应的值绑定到一个对象；
3、直接获取注入 Environment 进行获取；
配置属性的方式很多，Spring boot使用了一种独有的 PropertySource 可以很方便的覆盖属性的值。
配置属性加载的顺序如下：
1、开发者工具 `Devtools` 全局配置参数； 2、单元测试上的 `@TestPropertySource` 注解指定的参数； 3、单元测试上的 `@SpringBootTest` 注解指定的参数； 4、命令行指定的参数，如 `java -jar springboot.jar --name="Java技术栈"`； 5、命令行中的 `SPRING_APPLICATION_JSONJSON` 指定参数, 如 `java -Dspring.application.json='{"name":"Java技术栈"}' -jar springboot.jar` 6、`ServletConfig` 初始化参数； 7、`ServletContext` 初始化参数； 8、JNDI参数（如 `java:comp/env/spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff81078ae4560df21a7bc4f476a1e630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53908c1fcd2be94828bf26d0f61459be/" rel="bookmark">
			MinGW在线安装包下载失败的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想写点C程序，但是Visual Studio又大了，于是想起了VS Code比较轻量级的，度了一下，得用MinGW做解析、没想到下载了半天没成功，在线安装总有一两个包下载失败。
失败的就是那两个，于是乎想知道下载功能的包是放在那里呢？
随手找了一个安装成功的包 libz-1.2.11-1-mingw32-dll-1.tar.xz
一搜，果然在C:\MinGW\var\cache\mingw-get\packages\ 里面躺着。
OK，那么我独立下载这两个包放在里面，再run一次是不是ok?
包可以在这里下载https://sourceforge.net/projects/mingw/files/MinGW/Extension/
下了半才下下载完成，放在上面的目录下，安装还是有问题。
不得已，将MinGW删掉、在安装包之前将
gdb-7.6.1-1-mingw32-bin.tar.lzma
make-3.82.90-2-mingw32-cvs-20120902-bin.tar.lzma
放在C:\MinGW\var\cache\mingw-get\packages\
再次运行MinGW安装包，我只勾选了mingw32-base-bin 、这一次全部顺利。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/223/">«</a>
	<span class="pagination__item pagination__item--current">224/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/225/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>