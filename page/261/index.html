<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14068412f096bb11de29e1e68d585386/" rel="bookmark">
			解决nginx转发websocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 nginx.conf加入以下配置
proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_connect_timeout 60; proxy_read_timeout 600; proxy_send_timeout 600; nginx -s reload
如果nginx配置了多个监听端口代理
reload 会报下面错误
nginx: [warn] could not build optimal proxy_headers_hash, you should increase either proxy_headers_hash_max_size: 512 or proxy_headers_hash_bucket_size: 64; ignoring proxy_headers_hash_bucket_size
需要在http{
#加上这两行
proxy_headers_hash_max_size 51200; proxy_headers_hash_bucket_size 6400; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0084edde19e9f817f49697926be50e/" rel="bookmark">
			3dmax怎么清理注册表?3dmax注册表怎么删除干净?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在是越来越多的人加入自学3Dmax大军中，就有人安装了之后提示安装失败，没有成功。那么为什么3Dmax会安装失败呢?其实是注册表的问题，那么多3Dmax怎么清理注册表呢?下面就来看看这篇教程吧。
打开注册表，开始—运行，输入regedit确定，清理注册表有四个地方需要清理，大家注意看了
1、删除HKEY_CLASSES_ROOT下的.max文件夹，在HKEY_CLASSES_ROOT这个文件夹Ctrl+f查找max就行了，删除.max这个文件夹。
2、找到HKEY_CURRENT_USER—software—Autodesk—3ds Max，把3dsmax文件夹直接删除了，上面那几个max注册表文件也可以删除。
3、找到HKEY_LOCAL_MACHINE—software—Autodesk—3ds Max，把3dsmax文件夹删除即可。
4、找到HKEY_LOCAL_MACHINE—software—classes—installer，Ctrl+f找到installer文件夹，一定要全字匹配，不然是无法找到的，找到之后先不要删除(还有)。
在installer文件夹里面找到products文件夹，里面有很多注册表，挨个找，注意看右边的productname数据， 比如你安装过max2015，productname显示的就是2015的，这样的注册表不止一个，需要把products每个文件都看一下，有max记录的全部删除，把这四个注册表全部删除之后，3dsmax安装畅通无阻。
小编后来发现，直接删除最后一个注册表文件夹就差不多可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866acf96b0125fb14c2aabb0360396ee/" rel="bookmark">
			搭建1078部标流媒体服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 交通部与2016年10月份推出了JT/T 1078-2016标准，全称是《道路运输车辆卫星定位系统视频通信协议》。该标准将改变以往两客一危车辆的视频监控设备通信协议都是设备厂商私有协议的局面。
JT/T 1078协议又是对JT/T808协议的拓展，在808协议的基础上增加了对视频设备通信协议的拓展。所以如果我们之前做过808的部标协议，再着手做1078协议就会容易理解很多。
2018年时候，我本打算将基于部标1078视频监控服务完成，奈何个人精力实在有限，而且这块也不是我们的主营业务，就暂时搁置了，后面手头上的事情忙完后，就着手处理此事，其中遇到很多的难点问题，其中流媒体服务器便是最麻烦的问题所在。
流媒体实现 整体的架构 我下面用一个简单的图形来说明我当时实现的想法：
说明 首先在我们服务器网关上增加了对1078协议的一些音视频指令，应用于服务器网关之间走的是TCP通讯，做法与我们之前做的808是一样的。
当我们需要观看试试音视频时候，应用会给设备下发一个指令，该指令将用于打通设备与流媒体之间的通讯。设备返回与流媒体通讯成功的指令后，应用程序开始向流媒体进行拉去当前要观看的视频流。
视频流已经支持FLV与HLS，可以根据需要自行配置就可以了。
补充说明：这里我将实时视频与历史音视频回放分开，主要是为了将来可靠性，担心视频转成MP4进行存储时候影响流媒体整个的性能。
功能 1、目前支持FLV与HLS两张视频流拉去方式
2、支持H.264视频解码（目前市面上的视频监控设备都是H.264编解码）
3、支持G.711A，ADPCMA，AAC等常见的音频格式，如果有其他格式的设备可以与我联系我这边将其集成，目前没有找到其他格式的音频机器
4、支持主动断开设备传输：在没有客户端拉流的情况下，支持主动通知设备断开音视频的继续传输从而达到节约设备流量的目的
5、支持200路以上实时观看，目前测试情况，对内存与CPU的占用并不明显，只要网络允许就可以接入更多路同时观看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2ca11f2285fd5425744266cdbfb0bc/" rel="bookmark">
			RedisTest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Test public void test44() { Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); // map.put("powerConsumption", 80); // map.put("reportStatus", 2); // map.put("temperature", 999); // map.put("humidity", 80); // map.put("pm25", 600); map.put("batteryCapacity", 88); String key = "device:49bd573355464bfbad3dce4f68345008"; redisUtil.hmset(key, map); } @Test public void test5() { Map&lt;Object, Object&gt; map = redisUtil.hmget("device:49bd573355464bfbad3dce4f68345008"); // Map&lt;Object, Object&gt; map = redisUtil.hmget("device:WPD741705FE5210AE2096D2C05BD3466CA"); int size = map.size(); System.out.println(size); System.out.println(map); // Integer reportStatus = (Integer) map.get("reportStatus"); // Integer powerConsumption = (Integer) map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb2ca11f2285fd5425744266cdbfb0bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f055dc5911b9f6bfb3837e22845ebe/" rel="bookmark">
			NLPer，你知道最近很火的自然语言处理库么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 “NLP’s ImageNet moment has arrived.”
想象一下我们有能力构建支持谷歌翻译的自然语言处理(NLP)模型，并且在Python中仅需几行代码来完成，这听起来是不是让人非常兴奋。
而现在我们就可以坐在自己的机器前实现这个了!借助于被HuggingFace称为PyTorch-Transformers目前最先进的NLP工具。
https://github.com/huggingface/pytorch-transformers
我们可以简单地用Python导入它并进行实验。由于围绕人工智能的研究的开放文化和大量免费可用的文本数据，几乎没有什么是我们今天不能做的。
无论我再怎么强调PyTorch-Transformers对研究社区和NLP行业的影响也不为过。我相信这有可能彻底改变我们所知的自然语言处理领域。
揭开NLP的神秘面纱 本质上，自然语言处理是教计算机理解人类语言的复杂性。
在讨论PyTorch-Transformers的技术细节之前，让我们快速回顾一下该库构建的概念——NLP。我们还将理解最先进的(state-of-the-art)意味着什么。
在我们开始PyTorch-Transformers的讲解之前，这里有一些你需要了解的东西：
最先进的(state-of-the-art)是指目前对于某项任务“最好的”算法或技术。当我们说“最好的”时，我们的意思是这些算法是由像谷歌、Facebook、微软和亚马逊这样的巨头所倡导的。
NLP有许多定义明确的任务，研究人员正在研究创建智能技术来解决这些问题。一些最受欢迎的任务像机器翻译、文本摘要、问答系统等。
深度学习技术如Recurrent Neural Networks (RNNs), Sequence2Sequence, Attention,还有Word Embeddings(Glove, Word2Vec)对NLP任务来说曾是最先进的。
然而这些技术被一个叫Transformers的框架取代了，其背后是几乎所有的当前最先进的NLP模型。
注意 这篇文章将多处提及Transformers ，所以我强烈建议你阅读下面的指南,以对Transformers有个理解
https://www.analyticsvidhya.com/blog/2019/06/understanding-transformers-nlp-state-of-the-art-models/?utm_source=blog&amp;utm_medium=pytorch-transformers-nlp-python
PyTorch-Transformers是什么？ PyTorch-Transformers是一个最先进的自然语言处理预训练模型库。
我从PyTorch-Transformers的文档中选取了这一部分。这个库目前包含PyTorch实现、预训练的模型权重、使用脚本和用于以下模型的转换工具:
BERT(来自谷歌) 与论文BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding 一起发布
GPT(来自OpenAI) 与论文 Improving Language Understanding by Generative Pre-Training 一起发布
GPT-2(来自OpenAI) 与论文 Language Models are Unsupervised Multitask Learners 一起发布
Transformer-XL(来自谷歌/CMU) 与论文 Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context 一起发布
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46f055dc5911b9f6bfb3837e22845ebe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c261445f520fef2cd957a8d792dc32/" rel="bookmark">
			PHP基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP 脚本可以放在文档中的任何位置。
PHP 脚本以 &lt;?php 开始，以 ?&gt; 结束：
PHP 中的每个代码行都必须以分号结束
两种在浏览器输出文本的基础指令：echo 和 print。
PHP变量
变量以 $ 符号开始，后面跟着变量的名称
PHP 没有声明变量的命令。
变量在您第一次赋值给它的时候被创建：
PHP 是一门弱类型语言
PHP 会根据变量的值，自动把变量转换为正确的数据类型。
在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。
PHP变量的作用域
PHP 有四种不同的变量作用域：
1、local
2、global
3、static
4、parameter
局部和全局作用域
在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。
在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问：
在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字：
PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。
Static 作用域
当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除,可以使用 static关键字
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df3c58dfd8e481862c7c87e8dfe68be1/" rel="bookmark">
			keras中model.save和model.save_weights区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、保存模型model.save('**.h5')
将整个模型保存下来,以后直接载入模型与训练数据即可开始训练.
不用再定义网络和编译模型.(这种方法已经保存了模型的结构和权重,以及损失函数和优化器)
载入模型代码如下：
from keras.models import load_model
model.load_model('**.h5')
2、保存模型权重model.save_weights(’**.h5’)
只保存模型的权重,可以看作是保存模型的一部分.
载入模型权重代码如下：
model.load_weights('**.h5')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1186291e3d7da4f76433ff0289fb0448/" rel="bookmark">
			Spring注入Bean细节--解决Bean名称重复问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：org.springframework.context.annotation.ConflictingBeanDefinitionException 问题原因：在使用注解配置Bean的过程中，存在名称相同的情况，导致项目启动失败
解决办法：
1）在配置实例化注解时，指定别名
在mapper中使用@Repository注解来指定别名
//项目其他包中也存在相同的类名称DepartmentMapper，这里使用value来指定别名 //正常情况下，因为配置文件中已经配置了mapper包的扫描，所以可以省略@Repository注解，如果发生上述冲突，考虑使用别名来解决 @Repository(value="DepartmentMapper2") public interface DepartmentMapper { //此处省略各种CRUD方法 } 2)在Service中指定所依赖的mapper
//这里也指定了service的别名 @Service(value="DepartmentService2") public class DepartmentServiceImpl implements DepartmentService{ //这里指定依赖哪一个Mapper，默认情况下使用ByName按类名来指定 @Resource(name="DepartmentMapper2") private DepartmentMapper departmentMapper; //省略各种service方法 }	如果service的类名也冲突了怎么办？
在service中，使用@Service配置在实现类上，如果指定别名，可以利用value属性来指定，另外，@Service中默认括号中的字符串即是value的值，所以value可以省略
@Service("DepartmentService2") 对应Controller
@Resource(name="DepartmentService2") private DepartmentService departmentService; 小结
在配置Bean的过程中所指定的别名相当于以往XML中Bean属性id的值
&lt;bean id="beanname" class="xxx.xxx.Xxx"&gt;&lt;/bean&gt; 再复习@Resource这个注解
//@Resource注入顺序： 1.同时指定name和type,那么按照byname和bytype匹配唯一符合条件的bean装配 // 2.指定name或者type，则按照指定方式匹配，默认按name匹配，一旦指定type则不再使用属性名匹配 // 3.如果都不指定，则按照属性名（属性名为类名首字母小写）匹配，如果没有匹配到，按照属性数据类型匹配 // 以上不匹配则抛出异常 //@Resource 默认按照ByName注入Bean //也就是寻找id为“DepartmentService”的Bean @Resource private DepartmentService departmentService; //所以可以指定name属性来改变默认规则 //这样就寻找id为“DepartmentService2”的Bean @Resource(name="DepartmentService2") private DepartmentService departmentService; //也可以那个指定class来使用ByType注入 @Resource(type=DepartmentService.class) private DepartmentService departmentService; //注意import时要导正确的包 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9d4240ea532d8074d5000bb5bb297cd/" rel="bookmark">
			并发读写数据一致性保证（一）Java并发容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务开发过程，其实就是用户业务数据的处理过程，因而开发的核心任务就是维护数据一致不出错。现实场景中，多个用户会并发读写同一份数据（如秒杀），不加控制会翻车、加了控制则降低并发度，影响性能和用户体验。
如何优雅的进行并发数据控制呢？本质上需要解决两个问题：
读-写冲突写-写冲突 （想自学习编程的小伙伴请搜索圈T社区，更多行业相关资讯更有行业相关免费视频教程。完全免费哦!）
让我们看下Java经典的并发容器CopyOnWriteList以及ConcurrentHashMap是如何协调这两个问题的
CopyOnWriteList 读写策略 CopyOnWrite顾名思义即写时复制策略
针对写处理，首先加ReentrantLock锁，然后复制出一份数据副本，对副本进行更改之后，再将数据引用替换为副本数据，完成后释放锁
针对读处理，依赖volatile提供的语义保证，每次读都能读到最新的数组引用
读-写冲突 显然，CopyOnWriteList采用读写分离的思想解决并发读写的冲突
当读操作与写操作同时发生时：
如果写操作未完成引用替换，这时读操作处理的是原数组而写操作处理的数组副本，互不干扰如果写操作已完成引用替换，这时读操作与写操作处理的都是同一个数组引用 可见在读写分离的设计下，并发读写过程中，读不一定能实时看到最新的数据，也就是所谓的弱一致性。
也正是由于牺牲了强一致性，可以让读操作无锁化，支撑高并发读
写-写冲突 当多个写操作的同时发生时，先拿到锁的先执行，其他线程只能阻塞等到锁的释放
简单粗暴又行之有效，但并发性能相对较差
ConcurrentHashMap（JDK7） 读写策略 主要采用分段锁的思想，降低同时操作一份数据的概率
针对读操作：
先在数组中定位Segment并利用UNSAFE.getObjectVolatile原子读语义获取Segment接着在数组中定位HashEntry并利用UNSAFE.getObjectVolatile原子读语义获取HashEntry然后依赖final不变的next指针遍历链表找到对应的volatile值 针对写操作：
先在数组中定位Segment并利用UNSAFE.getObjectVolatile原子读语义获取Segment然后尝试加锁ReentrantLock接着在数组中定位HashEntry并利用UNSAFE.getObjectVolatile原子读语义获取HashEntry链表头节点遍历链表，若找到已存在的key，则利用UNSAFE.putOrderedObject原子写新值，若找不到，则创建一个新的节点，插入到链表头，同时利用UNSAFE.putOrderedObject原子更新链表头完成操作后释放锁 读-写冲突 若并发读写的数据不位于同一个Segment，操作是相互独立的
若位于同一个Segment，ConcurrentHashMap利用了很多Java特性来解决读写冲突，使得很多读操作都无锁化
当读操作与写操作同时发生时：
若PUT的KEY已存在，直接更新原有的value，此时读操作在volatile的保证下可以读到最新值，无需加锁若PUT的key不存在增加一个节点，或删除一个节点时，会改变原有的链表结构，注意到HashEntry的每个next指针都是final的，因此得复制链表，在更新HashEntry数组元素（即链表头节点）的时候又是通过UNSAFE提供的语义保证来完成更新的，若新链表更新前发生读操作，此时还是获取原有的链表，无需加锁，但是数据不是最新的 可见，支持无锁并发读操作还是弱一致的
写-写冲突 若并发写操作的数据不位于同一个Segment，操作是相互独立的
若位于同一个Segment，多个线程还是由于加ReentrantLock锁导致阻塞等待
ConcurrentHashMap（JDK8） 读写策略 与JDK7相比，少了Segment分段锁这一层，直接操作Node数组（链表头数组），后面称为桶
针对读操作，通过UNSAFE.getObjectVolatile原子读语义获取最新的value
针对写操作，由于采用懒惰加载的方式，刚初始化时只确定桶的数量，并没有初始默认值。当需要put值的时候先定位下标，然后该下标下桶的值是否为null，如果是，则通过
UNSAFE.comepareAndSwapObject(CAS)赋值，如果不为null,则加Synchronized锁，找到对应的链表/红黑树的节点value进行更改，后释放锁
读-写冲突 若并发读写的数据不位于同一个桶，则相互独立互不干扰
若位于同一个桶，与JDK7的版本相比，简单了许多，但还是基于Java的特性使得许多读操作无锁化
当读操作与写操作同时发生时：
若PUT的key已经存在，则直接更新值，此时读操作在volatile的保证下可以获取最新值若PUT的key不存在，会新建一个节点 或 删除一个节点的时候，会改变对原有的结构，这时next指针是volatile的，直接插入到链表尾（超过一定长度变成红黑树）等对结构的修改，此时读操作也是可以获取到最新的next 因此只要写操作happens-before读操作，volatile语义就可以保证读的数据是最新的，可以说JDK8版本的ConcurrentHashMap是强一致的（此处只关注基本读写（GET/PUT），可能会有弱一致的场景遗漏，例如扩容操作，不过应该是全局加锁的，如有错误烦请指出，共同学习）
写-写冲突 若并发读写的数据不位于同一个桶，则相互独立互不干扰
若位于同一个桶，注意到写操作在不同的场景下采取不同的策略，CAS或Synchronized
当多个写操作同时发生时，若桶为null，则CAS应对并发写，当第一个写操作赋值成功后，后面的写线程CAS失败，转为竞争Synchronized锁,阻塞等待
小结 为什么这么设计（个人观点） 对数据进行存储必然涉及数据结构的设计，任何对数据的操作都得基于数据结构
常规思路是对整个数据结构加锁，但是锁的存在会大大影响性能，所以接下来的任务，就是找到哪些可以无锁化的操作
操作主要分为两大类，读和写。
先看写，因为涉及到原有数据的改动，不加控制肯定会翻车，怎么控制呢？
写操作也分两种，一种会改变结构，一种不会
对于会改变结构的写，不管底层是数组还是链表，由于改动得基于原有的结构，必然得加锁串行化保证原子操作，优化的点就是锁层面的优化了，例如最开始HashTable等synchronized锁到
ConcurrentHashMap1.7版本的ReentrantLock锁，再到1.8版本的Synchronized改良锁 。或者数据分散化，concurrnethashmap等基于hash的数据结构比CopyOnWriteList的数据结构就多了桶分散的优势
对于不会改变结构的写，或者改动的频率不大（桶扩容频率低），由于锁的开销实在是太大了，CAS是个不错的思路。为什么CopyOnWriteList不用CAS来控制并发写，我个人觉得主要原因还是因为结构变化频繁，可以看下ActomicReferenceArray等基于CAS的数组容器，都是创建后就不允许结构发生变化的。
确保数据不会改错之后，读相对就好办了
主要考虑是不是要实时读最新的数据（等待写操作完成），也就是强一致还是弱一致的问题
强一致的话，读就得等写完成，读写竞争同一把锁，这就相互影响了读写的效率。
大多数场景下，读的数据一致性要求没有写的要求高，可以读错，但是坚决不可以写错。要是在读的这一刻，数据还没改完，读到旧数据也没关系，只要最后写完对读可见即可
还好JMM（Java内存模型）有个volatile可见性的语义，可以保证不加锁的情况下，读也能看到写更改的数据。此外还有UNSAFE包的各种内存直接操作，也可相对高性能的完成可见性语义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9d4240ea532d8074d5000bb5bb297cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6c79929015a032aa93eb84a22a489f/" rel="bookmark">
			C#编译过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人只知道c# 应用程序运行 必须有CLR（公共语言运行时）和.net框架的支持，但不知道为啥需要？
其实很简单，因为.exe只是IL指令，CIL（公共中间语言），目前的CPU还不能直接执行IL指令，但将来的CPU也许会具有这种能力。执行exe它的IL代码还必须首先被转换成为本地CPU指令，这属于CLR中即时编译器的工作。总所周知，程序入口点是Main函数，在程序执行之前，CLR检测Main中代码所引用到的所有类型，分配多个内部的数据结构，一个类对应一个数据结构，类中每个方法都会有一个对应的条目，每个条目保存有一个方法实现代码的地址。
当Main函数第一次调用程序中的某个方法时，JITCompiler函数将被调用，也就是将该方法的IL代码编译成本地的CPU指令，注意这是即时编译的，这些本地CPU指令将被保存在一个动态分配的内存块中，然后JITCompiler将前面内部数据结构中被调用方法的地址替换为包含本地CPU指令的内存块地址。最后JITCompiler将跳转到该内存块的代码上。这就是即时编译所做的工作，当该方法执行完毕，它将返回到Main函数中，继续执行下面的代码。
Main函数第二次调用程序的某个方法时，该方法的IL已经被编译成CPU指令，所以这一次执行将直接调用内存块中已有的本地代码，也正因为如此，一个方法只有在首次调用时才会产生一些性能上的损失。但所有对该方法的后续调用都将以本地代码全速执行。
JIT编译器将本地代码存储于动态内存之中，这就意味着关闭程序时，编译生成的本地代码将会被丢弃。再次运行程序依旧要把IL代码转换为CPU指令，这就是为什么每次运行都需要CLR及.net框架支持的原因。
C#语言运行时要经过两次编译，第一次编译是将源代码编译为MSIL(微软中间语言)，即可以发布软件了。当软件运行时MSIL代码载入内存时会进行第二次编译，中间语言会编译为机器语言以供计算机调用，第二次编译只在载入内存时发生，编译的结果被储存起来以备重复利用。编译时是按需编译，即只编译所用到的代码，而不是全部程序，称为JIT(即时编译)。
编译过LINUX的朋友应该都熟悉Make文件吧，在这里面可以清楚的看到使用编译器把C源代码编译成二进制源代码的流程，中间干了什么都可以看得清清楚楚。但使用VS的朋友一般都是程序写好之后直接F5就运行了，后面做了什么我们根本不知道。对于COSMOS的源代码，VS只是帮我们编译成了IL的代码，这种代码无法在没有CLR环境中运行，所以VS还需要把IL代码编译为针对CPU的本地代码。这中间的流程都由MSBuild这个东西控制。对于MSBuild的介绍可以直接查看MSDN文档。总的来说这个东西的地位就相当于Make文件的地位吧，指导VS如何生成可以引导的二进制文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48bb4a71885ed9f23d778966e6ee2b04/" rel="bookmark">
			四种配色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. #5CB85C 2. #5BC0DE 3. #F0AD4E 4. #D9534F 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b65ea1aa8f4cffc8977e410efd641ca5/" rel="bookmark">
			IDEA 重命名快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shift + F6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eecf1f9d9a7b522cdc8e2463f13c4719/" rel="bookmark">
			python中  zip()的使用和pandas中的列运算(map apply等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		map()函数语法：
map(function,iterable…) -&gt; function – 函数 iterable – 一个或多个序列
案例
s1 = [1,2,3,4,5] s2 = [6,7,8,9,10] s3 = map(lambda x,y:x*y,s1,s2) list(s3) &gt;&gt;&gt;[6, 14, 24, 36, 50] zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。
函数语法：
zip([iterable, …]) -&gt;iterabl – 一个或多个迭代器;
-&gt;返回元组列表
案例
a = [1,2,3,4] b = [5,6,7,8] zipped = zip(a,b) print(list(zipped)) zipped = zip(a,b) print(list(zip(*zipped))) &gt;&gt;&gt; [(1, 5), (2, 6), (3, 7), (4, 8)] [(1, 2, 3, 4), (5, 6, 7, 8)] 在pandas.map apply applymap中的 map(),apply(),applymap() 函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eecf1f9d9a7b522cdc8e2463f13c4719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942961c172d3402bc037defff73434fc/" rel="bookmark">
			【数据库】如何正确关闭mongodb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面 有时候我们的MongoDB被非正常关闭了，比如使用了kill -9 强制关闭或者停电宕机等。而后我们重启MongoDB时，会出现以下报错
about to fork child process, waiting until server is ready for connections. forked process: 15935 ERROR: child process failed, exited with error number 1 当然该问题是可以解决的，方法如下
1、删除dbpath路径下*.lock文件 2、修复 /usr/local/bin/mongod --repair --dbpath=&lt;dbpath&gt; 3、再次启动 不过为了避免造成不必要的错误，我们还是尽量使用正确的方式来关闭MongoDB server
方式一 Crtl+C 如果以前台方式启动 MongoDB 服务，使用“Crtl+C” 服务会关闭，这种关闭方式会等待
当前进行中的的操作完成，所以依然是干净的关闭方式。
方式二 使用数据库命令 需要使用client进入mongodb
use admin; db.shotdownServer() 方式三 使用mongod命令 mongod --shutdown --dbpath &lt;dbpath&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27866ff5e0d4e10835a60efd96dc3e86/" rel="bookmark">
			Linux之cmake的指令以及内部构建和外部构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装二、cmake编译三、语法1.基本语法2.指令（1）PROJECT()（2）CMAKE_MINIMUM_REQUIRED()（3）SET()（4）MESSAGE()（5）AUX_SOURCE_DIRECTORY()①基本含义②子目录③可添加多个 （6）ADD_SUBDIRECTORY（7）FIND_PACKAGE()（8）INCLUDE_DIRECTORIES()（9）ADD_EXECUTABLE()（10）TARGET_LINK_LIBRARIES()（11）cmake 3.总结 三、简单的内部构建1.前期准备2.构建CMakeLists.txt3.cmake+make编译 四、简单的外部构建1.在工程目录下准备好你的代码构建CMakeLists.txt2.在工程目录下创建一个build文件夹3.进入build进行cmake+make编译 一、安装 sudo apt-get install cmake 安装好后，输入
cmake -version 如果出现了cmake的版本显示，那么说明安装成功
二、cmake编译 cmake的作用就是将在IDE编译器中的编译功能拿出来，可以在终端上完成。类似于vim和文本编辑器。
cmake的编译方式：
内部构建(in-source-build)外部构建(out-of-source-build) 两者的区别仅仅是前者将生成的编译文件和源代码、CMakeLists.txt混杂在一起，后者就只是创建了一个文件夹存储生成的编译文件，更好删除编译生成的文件而已（直接删文件夹）。
三、语法 1.基本语法 指令是大小写无关的，参数和变量是大小写相关的。但推荐你全部使用大写指令。
变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名。
如：${SRC_LIST}
指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。
如：ADD_EXECUTABLE(hello main.c func.c)或者
ADD_EXECUTABLE(hello main.c;func.c)
注释：# comment
2.指令 搞清当前目录的意思：
CMakeLists.txt下的.表示当前目录是CMakeLists.txt文件所在的目录，而非执行时终端的当前目录。cmake .这条终端命令是执行时终端的当前目录。 （1）PROJECT() PROJECT(projectname [CXX] [C] [Java])
总结：定义工程名称，并可指定工程支持的语言。
定义工程名称：
如PROJECT(HELLO)，那么工程的名称就是HELLO
支持的语言列表
支持的语言列表是可以忽略的， 默认情况表示支持所有语言。
如指定C++，PROJECT(HELLO CXX)
这个指令隐式的定义了四个 cmake 变量:
&lt;projectname&gt;_BINARY_DIR以及&lt;projectname&gt;_SOURCE_DIR（格式，并非实际的变量）
对于这个工程就是HELLO_BINARY_DIR和 HELLO_SOURCE_DIR(之后就可以直接使用了这两个变量)，使用&lt;projectname&gt;_BINARY_DIR这个是无效的。PROJECT_BINARY_DIR和 PROJECT_SOURCE_DIR变量
他们的值分别跟 HELLO_BINARY_DIR与 HELLO_SOURCE_DIR一致。区别是这两个会自动根据工程名字的变化而变化。建议以后直接使用 PROJECT_BINARY_DIR，PROJECT_SOURCE_DIR，即使修改了工程名称，也不会影响这两个变量。
如：从HELLO该为WORLD，那么前者就得写成WORLD_BINARY_DIR和WORLD_SOURCE_DIR，但后者还是PROJECT_BINARY_DIR和 PROJECT_SOURCE_DIR。 （2）CMAKE_MINIMUM_REQUIRED() CMAKE_MINIMUM_REQUIRED(VERSION 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27866ff5e0d4e10835a60efd96dc3e86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bdd40f6540f46006a0c6709143fc220/" rel="bookmark">
			Linux新手入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
本文链接：https://blog.csdn.net/li3839/article/details/80658514
下面给你讲解新手第一次接触Linux操作系统
一、学习Linux：1、Linux系统、Linux命令、ssh、websever(apache)、MySQL、缓存、PHP、Python、java、必备服务
2、Linux能做什么：企业服务器、嵌入式开发
3、Linux的学习方法(强迫自己一个学习环境)：给自己一个Linux环境先给自己尝试搜索解决问题、学会读懂 Linux的错误提示
4、忘掉Windows的所有东西：没有exe安装程序、大小写是要区分的、一切皆文件、文件后缀名不是很重要， 只是为了好识别而已
5、虚拟机是什么：通过软件技术，可以在自己电脑上安装另一个操作系统，而不影响其它系统
好了，废话不多说，下面我使用的是CentOS操作系统，教你们如何装操作系统
首先，需要准备Vitualbox、CentOS。
开源虚拟机软件VirtualBox ：
Vitualbox下载：https://www.virtualbox.org/
虚拟机软件安装CentOS：
CentOS下载: https://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804
二、安装好Vitualbox和CentOS
1)运行Vitualbox软件
新建-》输入名称
配置内存，默认1024MB
也是默认现在创建虚拟磁盘
继续下一步，也是默认动态分配，再下一步
然后点击创建，就已经装好虚拟机的操作系统了。
建好操作系统，然后就可以启动操作系统了。
启动虚拟机后，输入用户名login：root和密码Password ：123456，这个看个人喜欢来设root和Password的哈
然后，可以在设置里边改一下网络，个人喜欢改为桥接网络（看个人的喜好吧）
然后，在虚拟机里边输入命令：ip addr 查看内置ip
虚拟机：Windows系统，鼠标键：按住左键+ctr键出来，Mac系统，按住command键出来
————————————————
版权声明：本文为CSDN博主「PHP，Python」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/li3839/article/details/80658514
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c13e9e714da88862d71797ab89fd89/" rel="bookmark">
			粒子群优化算法（Particle Swarm Optimization）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		粒子群算法的思想源于对鸟/鱼群捕食行为的研究，模拟鸟集群飞行觅食的行为，鸟之间通过集体的协作使群体达到最优目的，是一种基于Swarm Intelligence的优化方法。它没有遗传算法的“交叉”(Crossover) 和“变异”(Mutation) 操作，它通过追随当前搜索到的最优值来寻找全局最优。粒子群算法与其他现代优化方法相比的一个明显特色就是所需要调整的参数很少、简单易行，收敛速度快，已成为现代优化方法领域研究的热点。
粒子群算法的基本思想 设想这样一个场景：一群鸟在随机搜索食物。已知在这块区域里只有一块食物；所有的鸟都不知道食物在哪里；但它们能感受到当前的位置离食物还有多远。那么找到食物的最优策略是什么呢？
1. 搜寻目前离食物最近的鸟的周围区域
2. 根据自己飞行的经验判断食物的所在。
PSO正是从这种模型中得到了启发，PSO的基础是信息的社会共享
算法介绍 每个寻优的问题解都被想像成一只鸟，称为“粒子”。所有粒子都在一个D维空间进行搜索。
所有的粒子都由一个fitness function 确定适应值以判断目前的位置好坏。
每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置。
每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态调整。
粒子速度更新公式包含三部分： 第一部分为“惯性部分”，即对粒子先前速度的记忆；第二部分为“自我认知”部分，可理解为粒子i当前位置与自己最好位置之间的距离；第三部分为“社会经验”部分，表示粒子间的信息共享与合作，可理解为粒子i当前位置与群体最好位置之间的距离。
粒子群算法流程 第1步 在初始化范围内，对粒子群进行随机初始化，包括随机位置和速度
第2步 根据fitness function，计算每个粒子的适应值
第3步 对每个粒子，将其当前适应值与其个体历史最佳位置（pbest）对应的适应值作比较，如果当前的适应值更高，则用当前位置更新粒子个体的历史最优位置pbest
第4步 对每个粒子，将其当前适应值与全局最佳位置（gbest）对应的适应值作比较，如果当前的适应值更高，则用当前位置更新粒子群体的历史最优位置gbest
第5步 更新粒子的速度和位置
第6步 若未达到终止条件，则转第2步
【通常算法达到最大迭代次数或者最佳适应度值得增量小于某个给定的阈值时算法停止】
粒子群算法流程图如下：
计算示例 以Ras函数（Rastrigin's Function）为目标函数，求其在x1,x2∈[-5,5]上的最小值。这个函数对模拟退火、进化计算等算法具有很强的欺骗性，因为它有非常多的局部最小值点和局部最大值点，很容易使算法陷入局部最优，而不能得到全局最优解。如下图所示，该函数只在(0,0)处存在全局最小值0。
# -*- coding: utf-8 -*- import sys reload(sys) sys.setdefaultencoding('utf-8') import numpy as np import matplotlib.pyplot as plt # 目标函数定义 def ras(x): y = 20 + x[0]**2 + x[1]**2 - 10*(np.cos(2*np.pi*x[0])+np.cos(2*np.pi*x[1])) return y # 参数初始化 w = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c13e9e714da88862d71797ab89fd89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050fb852c2777bf9e69c53a39e39bde1/" rel="bookmark">
			转义URL 含有中文和特殊符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：
//这个方法被废弃了
NSString *urlString = @"https://www.cnblogs.com/huaida/#/程序员"; NSString* encodedString1 = [urlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSLog(@"encodedString1 %@",encodedString1); //这个方法一般能解决url中含有中文字符的问题，效果同上，但是同时有中文和特殊字符的话，特殊字符会被转换成%234这样的字符串，又出问题了。o(╯□╰)o
方法2：
NSString* encodedString2 = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];
NSLog(@"encodedString2 %@",encodedString2);
方法3：
//这个方法能够解决既含有中文又含有特殊字符的解决办法 NSString *encodedString3 = CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)urlString, (CFStringRef)@"!$&amp;'()*+,-./:;=?@_~%#[]", NULL, kCFStringEncodingUTF8));
NSLog(@"encodedString3 %@",encodedString3);
参考： https://www.jianshu.com/p/09988b13e804
转载于:https://www.cnblogs.com/huaida/p/11473851.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae2ac498e6bbbe89ef77ccc79297f3c/" rel="bookmark">
			python学习之路——while True做无限循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 while True做无限循环与if语句条件配合使用。
while True:#True t要大写T order_1 = input("请输入您的命令(1,2,3)：") #order要写在while True里，不然会无限循环 #input输入的格式为：默认字符串？ print("您的命令是：%s" % order_1) if order_1 in ['1','2','3']: #in 包含在容器内 pass elif order_1 == 0: print("welcom your order") break #推出循环 else: print("error,try again1,2,3：") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c7d476e7cdd3b7cb4ffb58a3fe7966/" rel="bookmark">
			微信开发者工具导入项目提示：登录用户不是该小程序的开发者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候，我们在使用微信开发者工具导入别人开发好的项目时会提示：登录用户不是该小程序的开发者。如下图所示： 这时候，找到“project.config.json”文件，我们需要修改项目中的“project.config.json”文件。 使用记事本或者其他文本编辑器（不要使用word，否则会改变文件内容）打开“project.config.json” 文件，将“appid”设置为自己的appid，然后保存并关闭文件，再次导入项目即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700c4a88abd71444ed4bacba4d376748/" rel="bookmark">
			离散数学符号大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		├ 断定符（公式在 L 中可证）
╞ 满足符（公式在 E上有效，公式在 E上可满足）
┐命题的 “非”运算
∧ 命题的 “合取 ”（“与”）运算
∨ 命题的 “析取 ”（“或”，“可兼或 ”）运算
→ 命题的 “条件 ”运算
A&lt;=&gt;B 命题 A 与 B 等价关系
A=&gt;B 命题 A 与 B 的蕴涵关系
A* 公式 A 的对偶公式
wff 合式公式
iff 当且仅当
↑ 命题的 “与非 ” 运算（ “与非门 ” ）
↓ 命题的 “或非 ”运算（ “或非门 ” ）
□模态词 “必然 ”
◇ 模态词 “可能 ”
φ 空集
∈ 属于（ ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700c4a88abd71444ed4bacba4d376748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db0cd32e3e61402949bb0e2ad45b4168/" rel="bookmark">
			Spring Cloud Stream的使用（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.learn&lt;/groupId&gt; &lt;artifactId&gt;order&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;cn.learn&lt;/groupId&gt; &lt;artifactId&gt;microcloud02&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 这个插件,可以将应用打包成一个可执行的jar包 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; server.port=8010 eureka.client.serviceUrl.defaultZone=http://admin:1234@10.40.8.152:8761/eureka spring.application.name=order eureka.instance.prefer-ip-address=true eureka.instance.instance-id=${spring.application.name}:${spring.cloud.client.ipAddress}:${spring.application.instance_id:${server.port}} spring.rabbitmq.host=59.110.158.145 spring.rabbitmq.username=guest spring.rabbitmq.password=guest spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db0cd32e3e61402949bb0e2ad45b4168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf214dbb29ff3972c258ee5614f58fcd/" rel="bookmark">
			【高数】幂级数求和函数问题：用变限积分？积分下限是0？S(0)怎么求？求和时起始项n和角标有规定吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、起因
二、概念理解
1. 牛顿莱布尼茨公式
2. 变限定积分、不定积分的关系
3. 幂级数求和可以用不定积分吗？
4. 为什么从积分下限从0开始？
三、S(0)的求法
1. 何时需要讨论S(0)？
2. S(0)什么含义？
3. 怎么求S(0)？
4. 例题
四、起始项和角标问题
五、幂级数求和函数解法
六、小结
一、起因 问题：幂级数求和函数，时而有S(0)这一项，时而又没有，令人困惑。
S(0) 什么含义？什么时候会有 S(0) 出现？应该怎么求 S(0)？
求和函数时，对幂级数的脚标有无要求？次方有无要求？
二、概念理解 1. 牛顿莱布尼茨公式 定理 设 f(x) 在 [a, b] 上可积，F(x) 在 [a, b] 上连续，且在 (a, b) 内有 F’(x)=f(x)，则
推论 设 f(x) 在 [a, b] 上可积，F(x) 在 [a, b] 上连续，且在 [a, b] 上除去有限个点外皆有 F’(x)=f(x)，则
《对牛顿-莱布尼兹公式的一点认识》：https://www.ixueshu.com/document/d91fe7d952625b8a318947a18e7f9386.html
有牛莱公式的证明和例题。
注：（1）有时F'(x)在某点处不存在，因此在解微分方程时，F(x)并不能叫做方程的解，只能叫做满足方程的函数。
（2）牛莱公式本是为解决定积分问题的，但是，也可以用于变限积分，表示的是一个函数，而非一个数值。
2. 变限定积分、不定积分的关系 因此，从该公式可以看出，当对函数进行定积分时，需要选取上下限。当上限选定为x，即变上限积分，此时下限选取为某常数m，则此时积分所得，即为 F(x)-F(m)。随着m的选取不同，该值也不同，但F(m)始终为一个常数。事实上，这就是不定积分被给了条件，而使得任意常数项C变为某个确定值，因此从一类函数变为一个确定的函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf214dbb29ff3972c258ee5614f58fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a95e59833b732319acafb20f1ca311b/" rel="bookmark">
			lucene&amp;solr入门（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Solr概述 Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务。Solr自带服务器功能，可以通过命令方式直接启动solr服务。也可以把solr部署到Jetty、Tomcat等其他Servlet容器中运行。
Solr与lucene的关系 Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索应用。Lucene仅提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索应用。Solr的目标是打造一款企业级的搜索引擎系统，它是基于Lucene一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。
二、Solv安装配置 2.1 下载Solr 下载地址：http://archive.apache.org/dist/lucene/solr/
如果是Windows版本，那么下载完成后直接解压缩到指定目录即可。目录结果如下图所示：
bin：solr的运行脚本；
contrib：solr相关的第三方扩展jar包；
dist：该目录包含build过程中产生的war和jar文件，以及相关的依赖文件；
docs：api文档；
example：solr工程的示例；
licenses：各种许可和协议；
server：solr自带的服务器目录。其中有两个比较重要的目录：
|- solr：运行Solr的配置文件都保存在这里。其中，它包含一个子文件夹configsets，该文件夹存放了solr的示例配置文件
|- solr-webapp：solr后台管理系统所在目录
2.2 启动自带solr服务 第一步：在命令行进入solr/bin目录，然后执行solr start命令即可。
solr服务默认监听8983端口。启动成功后，在浏览器上输入localhost:8983/solr即可打开solr管理界面。
2.3 创建solr core 一个solr core就是一个索引库。一个solr服务器上可以有多个solr core。
第一步：进入%solr_home%/server/solr目录，新建一个目录，该目录作为一个索引库目录存放我们创建的索引。
第二步：将%solr_home%\server\solr\configsets\sample_techproducts_configs目录下的conf文件夹拷贝到solrtest目录中。
第三步：重启solr服务。
solr restart -p 8983 例如：
启动成功后，重新访问solr管理界面。
第四步：点击左边Core Admin菜单，然后点击Add Core，在name和InstanceDir输入框中输入solr core文件夹的名称，输入完后点击蓝色的Add Core按钮。
这时候在左边core selector中可以看到我们创建的solr core。
2.4 管理界面介绍 （1）DashBoard
仪表盘，显示了该Solr实例开始启动运行的时间、版本、系统资源、jvm等信息。
（2）Logging
Solr运行日志信息。
（3）Core Admin
Solr Core管理界面，在这里可以添加SolrCore实例。
（4）Java Properties
Solr在JVM 运行环境中的属性信息，包括类路径、文件编码、jvm内存设置等信息。
（5）Thread Dump
显示Solr Server中当前活跃线程信息，同时也可以跟踪线程运行栈信息。
（6）Core Selector
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a95e59833b732319acafb20f1ca311b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b97405fbd1144a890ce0c03dd933fe3c/" rel="bookmark">
			常见文件头  文件幻数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JPEG (jpg)，文件头：FFD8FF PNG (png)，文件头：89504E47 GIF (gif)，文件头：47494638 TIFF (tif)，文件头：49492A00 Windows Bitmap (bmp)，文件头：424D CAD (dwg)，文件头：41433130 Adobe Photoshop (psd)，文件头：38425053 Rich Text Format (rtf)，文件头：7B5C727466 XML (xml)，文件头：3C3F786D6C HTML (html)，文件头：68746D6C3E Email [thorough only] (eml)，文件头：44656C69766572792D646174653A Outlook Express (dbx)，文件头：CFAD12FEC5FD746F Outlook (pst)，文件头：2142444E MS Word/Excel (xls.or.doc)，文件头：D0CF11E0 MS Access (mdb)，文件头：5374616E64617264204A WordPerfect (wpd)，文件头：FF575043 Adobe Acrobat (pdf)，文件头：255044462D312E Quicken (qdf)，文件头：AC9EBD8F Windows Password (pwl)，文件头：E3828596 ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 Wave (wav)，文件头：57415645 AVI (avi)，文件头：41564920 Real Audio (ram)，文件头：2E7261FD Real Media (rm)，文件头：2E524D46 MPEG (mpg)，文件头：000001BA MPEG (mpg)，文件头：000001B3 Quicktime (mov)，文件头：6D6F6F76 Windows Media (asf)，文件头：3026B2758E66CF11 MIDI (mid)，文件头：4D546864 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/630e59fe78d722bc2734fd021e0cf46c/" rel="bookmark">
			python爬虫--lxml，xpath
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取豆瓣正在热映的电影：豆瓣电影 import requests from lxml import etree header = { 'user-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/76.0.3809.132 Safari/537.36 ' } url = 'https://movie.douban.com/cinema/nowplaying/foshan/' req = requests.get(url, headers=header) txt = req.text html = etree.HTML(txt) ul = html.xpath('//ul[@class="lists"]')[0] #或者： # ul = html.xpath('//div[@id="nowplaying"]//ul[@class="lists"]')[0] #获取电影title存在lis中 lis = ul.xpath('./li/@data-title') for li in lis: print(li) 结果： 需要注意的几点： 第一：xpath获取的是一个list,因此需要在后面加上要获取的是list里面的第几个元素，不然就会出现“无法序列化”的情况
报错：TypeError: Type 'list' cannot be serialized.
import requests from lxml import etree header = { 'user-Agent': 'Mozilla/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/630e59fe78d722bc2734fd021e0cf46c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/654dda4db29c90a4e7c6dee8e60fc316/" rel="bookmark">
			js定时器、js函数、变量和参数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js定时器 通过使用 JavaScript，我们有能力作到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件。
定时器在javascript中的作用
1、制作动画
2、异步操作
定时器类型及语法 setInterval() - 间隔指定的毫秒数不停地执行指定的代码。
setTimeout() - 暂停指定的毫秒数后执行指定的代码 setInterval() 和 setTimeout() 是 Window对象的两个方法。
定时器： setTimeout 只执行一次的定时器 clearTimeout 关闭只执行一次的定时器 setInterval 反复执行的定时器 clearInterval 关闭反复执行的定时器 var time1 = setTimeout(myalert,2000); var time2 = setInterval(myalert,2000); /* clearTimeout(time1); clearInterval(time2); */ function myalert(){ alert('ok!'); } &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;定时器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; /* 1.单次定时器 setTimeout 格式:setTimeout(回调函数,等待时间(毫秒)) 指定等待时间之后执行特定的功能(代码) 只执行一次 清除单词定时器 clearTimeout(要清除的定时器的标识符) 2.循环定时器 setInterval() 格式:setInterval(回调函数,间隔时间(毫秒)) 间隔指定时间执行一次特定的代码块 清除定时器: 我们启动定时器之后,会返回一个标识符,通过这个标识符来清除定时器 clearInterval(要清除的多次定时器的标识符) */ function demo(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/654dda4db29c90a4e7c6dee8e60fc316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e404bd2ccc88578fc9fd330b2ab122/" rel="bookmark">
			Eclipse_彻底删除多余的工作空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景:
以前创建eclipse工作空间的时候，创建多了，最有有一个空间决定不用了，然后打算把空间删除干净。之前一直没有去研究这个，然后就顺手记下来。
1. 查看工作空间
要删除的工作空间如下：
在这边可以查看所有的工作空间，当然还可以通过查看配置文件来看。这个配置文件下面会提到，这边不做介绍。
2. 删除操作
删除对应的目录
以我自己要删除的工作空间来举例。我的目录为F:\EclipseSpace\main，然后到该目录下会有一个.metadata的文件夹。删除即可。
这时候你会发现eclipse中并没有删除对应的工作空间，并且如果你选择切换到刚刚删除的工作空间，则会在刚刚的文件夹路径会再次生成一个.metadata文件夹。 别急，我们还没完成最关键的第二步。
删除eclipse配置
找到对应的eclipse的安装空间，注意是安装空间。然后查找eclipse\configuration\.settings。我的安装路径是D:\Eclipse，所以我要查找的路径是D:\Eclipse\eclipse\configuration\.settings，然后查找一个名字为org.eclipse.ui.ide.prefs的文件。如下：
然后查找RECENT_WORKSPACES一行的属性，删除对应的工作空间路径，记得如果有多个工作空间，且你要删除的不是第一个，则要把前面的\n一块删除了。
删除前如下： RECENT_WORKSPACES=E\:\\EclipseSpace\\main\\EMA\nF\:\\EclipseSpace\\main\nE\:\\EclipseSpace\\patch\nE\:\\EclipseSpace\\main 删除后如下：
RECENT_WORKSPACES=E\:\\EclipseSpace\\main\\EMA\nE\:\\EclipseSpace\\patch\nE\:\\EclipseSpace\\main 3.结果
删除成功了，效果如下图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59bc0a0d5f96c05321c808928e59bfed/" rel="bookmark">
			lucene&amp;solr入门（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 Lucene概述 1.1 Lucene是什么 Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。
Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。
目前已经有很多应用程序的搜索功能是基于 Lucene 的，比如 Eclipse 的帮助系统的搜索功能。Lucene 能够为文本类型的数据建立索引，所以你只要能把你要索引的数据格式转化的文本的，Lucene 就能对你的文档进行索引和搜索。比如你要对一些 HTML 文档，PDF 文档进行索引的话你就首先需要把 HTML 文档和 PDF 文档转化成文本格式的，然后将转化后的内容交给 Lucene 进行索引，然后把创建好的索引文件保存到磁盘或者内存中，最后根据用户输入的查询条件在索引文件上进行查询。不指定要索引的文档的格式也使 Lucene 能够几乎适用于所有的搜索应用程序。
简单概括：
Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支 持和提供；Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻， 在Java开发环境里Lucene是一个成熟的免费开放源代码工具；Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品； 官网地址： http://lucene.apache.org/
1.2 Lucene的工作流程 索引：绿色部分表示索引。在搜索前需要先对原始内容进行索引，构建索引库。
索引过程：确定原始内容 &gt; 获得文档 &gt; 创建文档 &gt; 分析文档 &gt; 索引文档。
搜索：红色部分代表搜索。搜索即从索引库中搜索内容。
搜索过程：创建查询 &gt; 执行搜索 &gt; 从索引库搜索 &gt; 渲染搜索结果。
二、Lucene环境安装 开发环境：
JDK： 1.8.0_144
IDE： eclipse Luna
数据库： MySQL5.6.38
2.1 创建Maven工程，引入lucene相关坐标。 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;8.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59bc0a0d5f96c05321c808928e59bfed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe4fb24da65c75bc260d27369ae8c79/" rel="bookmark">
			前端 发送请求时，同时出现两次请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1事故情况：在前端ajax请求数据的时候，有时候会向后台一次性发送两次请求，，这两次请求第一次无返回数据，第二次才会返回正确数据。
2事故原因：原来对于跨域，有两种不同的请求类型。分别为简单跨域请求和复杂跨域请求(带预检的跨域请求)。
3复杂跨域：
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。
非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。
预检请求为OPTIONS请求，用于向服务器请求权限信息的。
预检请求被成功响应后，才会发出真实请求，携带真实数据。
4解决方式：而本项目，后台采用token检验机制，前台发送请求必须将token放到request header中，而请求头中携带自定义参数，浏览器就认为请求是复杂跨域请求，所以浏览器在真正 请求之前会发送一次预检请求，检测服务器是否支持真实请求进行跨域访问。
5其他问题：刚开始执行的时候，提示跨域。服务端设置Access-Control-Allow-Origin: *允许跨域
但是还报错：还是得服务端设置允许的header。
Access-Control-Allow-Headers：后面加允许的header的参数，中间用逗号隔开。
还是会发送两次请求：
后台可以通过设置Access-Control-Max-Age来控制浏览器在多长时间内（单位s）无需在请求时发送预检请求。
6补充点：Ajax设置自定义请求头的两种方法
方法一：
$.ajax({ type: "post", url:"http://---", contentType: "application/json;charset=utf-8",//header中参数服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。application/json;用来告诉服务端消息主体是序列化后的 JSON 字符串 data :{}, dataType: "json", //重点 beforeSend: function (XMLHttpRequest) { XMLHttpRequest.setRequestHeader("token", "..."); }, success: function (data) { alert(data); },error:function(error){ console.log(error); } }); 方法二： $.ajax({ type: type, headers: { 'token':$.cookie('token') }, url: url, data: data, success: function(data) { }, error: function(err) { } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437206e245b69d5202073f99466ea586/" rel="bookmark">
			maven_配置多个仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 发生背景
物联网开发计划结束，另一个项目那边有需求，于是让我们转个项目进行开发。然后在搭建新项目的时候，突然发现这个项目里面用到了自己私库的jar包，并且这些jar包在公库里找不到。
关键问题来了，就是配置多个仓库！
2. 失败的解决方法
我原本以为这个不就是在maven配置的时候加一个镜像就能解决的事情，结果并不是！
最初的样子如下:
后面加了一个私库的镜像后，如下：
结果只有没有找到私有的镜像中的包。后面去查资料才发现，配置多个mirror时，只有第一个才会生效。跟我想象的根本不一样。 3. 成功的解决方法
解决方法：设置全局多仓库。。
配置格式如下：
&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;Releases&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;Releases&lt;/id&gt; &lt;url&gt;http://XX.XX.XX.XX:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; &lt;/profiles&gt; 配置完profile后还要配置activeProfiles，其配置如下：
&lt;activeProfiles&gt; &lt;activeProfile&gt;Releases&lt;/activeProfile&gt; &lt;activeProfile&gt;aliyun&lt;/activeProfile&gt; &lt;/activeProfiles&gt; 配置完之后，便可以重两个仓库中拉取jar包，如果一个仓库中不存在，便会从另一个仓库中去拉取jar包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17a2bf0ecb1d2f73617cf009d9227de/" rel="bookmark">
			Navigation网站收藏和导航平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初衷 估计很多人和小编一样，一开始将浏览过的觉得不错的网站收藏到浏览器的收藏夹中。日积月累，网站越来越多，在收藏夹里找所需网站越来越麻烦。后来浏览器从火狐转到Chrome，收藏的网站却不能同步过来。浏览器需要登录才能同步收藏夹的内容，这很痛苦……鉴于种种原因，有这样一个收藏、搜索和分类导航平台真的是棒极了，小编就自己做了一个开源项目——Navigation网站收藏和导航平台。
实现功能 网站CRUD 搜索 登录登出 网站截图 网站导航块瀑布流 网站嵌套iframe和搜索模块 网站提交页 在线Demo 预览
简单的实现思路 本地构建 &lt;!-- 下载项目 --&gt; git clone https://github.com/qiufeihong2018/navigation-server.git &lt;!-- 安装依赖 --&gt; npm install &lt;!-- 爬取数据 --&gt; node ./creeper/index.js &lt;!-- 启动程序 --&gt; npm run dev 之后访问http://localhost:1600即可
后端 navigation-server后端代码仓库
基于express框架
express搭建web应用 特征 强大的路由专注于高性能超高的测试覆盖率HTTP助手（重定向，缓存等）查看支持14+模板引擎的系统内容协商可快速生成应用程序的可执行文件 解析 启动express服务
const express = require('express'); const app = express(); const config = require('../config')(); // start server // Set http port app.set('port', config.expressHttpPort); app.listen(config.expressHttpPort, () =&gt; { // 开启端口打印日志 log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c17a2bf0ecb1d2f73617cf009d9227de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d31caf7af80abf4a8157cee8f8eccc/" rel="bookmark">
			vue.js点击判断是否已经登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在定义路由的时候就需要多添加一个自定义字段requireAuth，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由， 否则就进入登录页面。
{ path: '/shops/users', name: 'Users', meta: { title: '用户中心', requireAuth: true, // 添加该字段，表示进入这个路由是需要登录的 }, component: Users } 定义完路由后，在main.js我们主要是利用vue-router提供的钩子函数beforeEach()对路由进行判断。
router.beforeEach((to, from, next) =&gt; { if (to.meta.requireAuth) { // 判断该路由是否需要登录权限 if (localStorage.getItem('BASEINFO')) { // 通过vuex state获取当前的用户是否存在 next(); } else { next({ path: '/shops/login', query: {redirect: to.fullPath} // 将跳转的路由path作为参数，登录成功后跳转到该路由 }) } } else { next(); } }) https://router.vuejs.org/zh/guide/#javascript
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a410a47213169f8437fdadb8ec2367f7/" rel="bookmark">
			DLL释放引起的死锁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DLL释放引起的死锁问题 一，问题介绍二，问题分析三，问题总结 一，问题介绍 最近在做代码重构，今早对前两天重构的某个组件进行自测时，突然发现停止程序运行时，出现了卡死，进程退不出，查看日志发现是FreeLibrary没有走完。打开任务管理器-》性能-》资源监视器，找到进程，右键分析分析等待链，结果如下：
出现了死锁，16800线程是主线程（调用FreeLibrary），12128是DLL中的工作线程，两个线程互相等待，导致死锁，进程退不出。
二，问题分析 打开Windbg，配好pdb文件和源码路径，attach到该进程上，输入!locks命令，查看当前进程锁的情况：
可以发现锁771f20c0处于死锁状态，它此时被30f8线程占有。再输入~*kb查看所有线程，看看哪个线程正在等待锁771f20c0：
线程42d4在等待锁771f20c0，而锁771f20c0被线程30f8占有，我们再看看30f8线程：
它也在等待，不过从代码中看得出来它在等待线程42d4的退出，而42d4线程又在等待771f20c0锁的释放，可是锁771f20c0被30f8线程占有，由此产生的死锁，导致进程退不出来：
可是我们在线程30f8中并没有看到771f20c0锁的相关信息，这个锁是在42d2线程调用LdrShutdownThread时进行等待的，我们可以在win2K中找到它的实现：
VOID LdrShutdownThread ( VOID ) /*++ Routine Description: This function is called by a thread that is terminating cleanly. It's purpose is to call all of the processes DLLs to notify them that the thread is detaching. Arguments: None Return Value: None. --*/ { PPEB Peb; PLDR_DATA_TABLE_ENTRY LdrDataTableEntry; PDLL_INIT_ROUTINE InitRoutine; PLIST_ENTRY Next; Peb = NtCurrentPeb(); RtlEnterCriticalSection(&amp;LoaderLock); try { // // Go in reverse order initialization order and build // the unload list // Next = Peb-&gt;Ldr-&gt;InInitializationOrderModuleList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a410a47213169f8437fdadb8ec2367f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8216157ee6037682a2c36d701738705/" rel="bookmark">
			SpringBoot开发日记(五)——如何在@Query中动态的判断参数是否为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码：
@Query(value = "select * from table_name where if(?1!=null and ?1!='',key=?1,1=1) and if(?2!=null and ?2!='',key2=?2,1=1),nativeQuery = true) public List&lt;User&gt; queryPage(String key，String key2); 使用条件：当有多个查询条参数且有时参数会为空时，为了避免写多个参数不同的查询函数，可以使用该方法。
理解：if(?1!=null and ?1!='',key=?1,1=1)
如果?1!=null and ?1 !=''成立，则返回key=?1，否则返回1=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df58602093fcea2fc0fc083cd3b15da6/" rel="bookmark">
			vue $nextTick方法 数据更新获取dom
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 业务场景
1.使用固定定位在顶部写了内容盒，下方用padding撑开空间，下方点击添加向上方盒子中添加内容，盒子的大小随内容增加改变，这就要求下方的盒子padding大小要随上方盒子的大小动态改变
2.处理方案。在watch中监听盒子中数据变化，数据改变，调用获取盒子高度的方法，将高度值赋值给padding。
以为这就完成了？没这么简单。你会发现只有下次点击时当前高度才会被附上，应为我们执行代码的时候新改变dom还没生成，所以此时获取的dom是上一次变化后的dom高度
3.解决方案。使用 $nextTick方法，将获取dom方法写在此方法内，并赋值
$nextTick用法官方说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM
changeDom() { var major = document.getElementById('major'); var set_target_major = document.getElementById('set_target_major'); var H = 0; this.$nextTick(() =&gt; { H = set_target_major.clientHeight + 20; major.style.paddingTop = H + 'px'; }) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c821d674b59af02d3ede39953e15796/" rel="bookmark">
			【高数】级数性质说明、找同阶通项判敛散性、几何级数p级数记忆法、常用例子、审敛法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、级数性质相关
1. 判敛散性的一个简易方法
2. 几何级数记忆法
3. p级数记忆法
二、常用例子
三、审敛法
四、小结
一、级数性质相关 1. 判敛散性的一个简易方法 针对课本上的级数性质中的某条进一步说明：
级数的数列中的各项同乘一个非零常数，不改变级数的敛散性。（即收敛的仍收敛，发散的仍发散。）
注：在需要判断敛散性时，因为不知道往收敛还是发散的方向证明，所以需要找到相对题干级数更为小发散，或大收敛的级数，最差的情况下要找到两个级数！
在用正项级数比较审敛法的极限形式时，本质上是在看，分子分母上的两个级数通项，在n→∞时，谁是更为高阶的无穷小。在高阶低阶的情况下，与比较审敛法并无差异。但是当二者同阶时，也即两级数的极限是非零常数倍的关系，此时由上可知，敛散性相同。
结合上述对级数性质的说明，可以用这样一个简便的方法。即找到与待判级数通项的同阶的通项，用新找到的级数的敛散性判断，则减少了工作量。
2. 几何级数记忆法 几何级数，就是等比级数，可以结合等比数列求和公式来记忆。公比 q ≥ 1 或 q ≤ -1，首先通项的极限就是∞了，该和不存在。而 -1 &lt;q &lt;1，收敛，此时通项极限是0，且可由公式得出极限。
（引自百度百科：https://baike.baidu.com/item/%E5%87%A0%E4%BD%95%E7%BA%A7%E6%95%B0）
3. p级数记忆法 课本上是说，p&gt;0的情况，但事实上，p&lt;0显然是有意义的，且通项的极限是∞，因此是发散的。所以可以简单记忆 p&gt;1，收敛，其余都发散。不过大多数教材及文章中，都将p级数归为正项级数，此时又称 “调和级数 ”，所以只讨论了p&gt;0的情况，具体范围如何取，应视题目而定。
（引自百度百科：https://baike.baidu.com/item/p%E7%BA%A7%E6%95%B0）
二、常用例子 1. 选择题，常用的例子整理（这里省略上下标）。
发散： （因为p级数）
收敛（指它本身收敛，而未必绝对收敛）：
2. 一个很厉害很好记的级数：
，与它同敛散的反常积分是
其敛散性与a、b有关：
可以想成因为 x 是比 lnx 大许多的无穷大，所以基本上先由它决定敛散性。所以先看a。
a&gt;1, 收敛。a&lt;1, 发散。a=1，此时看b。 b&gt;1, 收敛。b&lt;1, 发散。 疑问：级数和反常积分的关系？后面再次复习反常积分时总结。
三、审敛法 在这里放一些总结得比较全的文章，指路链接：
《级数收敛的判别方法（知识汇总）》：https://m.xianjichina.com/news/details_83466.html
《第五讲 交错级数、绝对收敛和条件收敛》：https://blog.csdn.net/qq_23940575/article/details/84610895
《P-达朗贝尔判别法及其应用》：https://www.ixueshu.com/document/7ea4c75acbc0c8e9381c0aab81c124ec.html
可以用比值判别法的，用根值判别法一定可以。反之未必。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c821d674b59af02d3ede39953e15796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40e323946f2f0edf016d3a3d0a38cdf/" rel="bookmark">
			winrar解压缩中文文件夹乱码的最简单解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用winrar解压缩文件。
提示：文件名、目录名或卷标语法不正确。
查看对应文件夹，显示是乱码。
以为是下载时文件错误。多次下载。问题依旧。
用其他电脑下载，解压缩没有问题。
相同文件复制到第一台电脑。用WINRAR打开，依然乱码。
可以判断为WINRAR问题。
偶然，右击该文件发现简单解决方法：
“打开方式”选择“Windows资源管理器”，可以直接打开压缩文件，并且文件夹显示的是中文。
选择文件夹，复制，到要解压缩的文件，右击“粘贴”。文件夹顺利解压缩！
以上在win10系统操作成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14026a0e14eb9fe57340a2f0760b4ab2/" rel="bookmark">
			C&#43;&#43; 开源框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、openFrameworks （https://openframeworks.cc） https://github.com/openframeworks/openFrameworks
openFrameworks是一个开源的 C ++工具包，旨在通过提供简单直观的实验框架来协助创作过程 二、C++轻量级通用插件框架平台 X3C
https://github.com/rhcad/x3py
三、pluma C++插件开发框架 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0852ffa0b0f9285b4882cb1af04cf8e7/" rel="bookmark">
			2019年软考程序员考试大纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019年软考程序员考试大纲 一、考试说明：二、考试科目：三、考试范围：1：计算机与软件工程基本知识2.计算机系统基础知识3.系统开发和运行知识4.程序设计语言（C语言为必选，再在C、C++、Java语言中任选一种） 一、考试说明： 1、掌握数制及其转换、数据的机内表示、算术和逻辑运算，以及相关的应用数学基础知识；
2、理解计算机的组成以及各主要部件的性能指标；
3、掌握操作系统、程序设计语言的基础知识；
4、熟练掌握计算机常用办公软件的基本操作方法；
5、熟练掌握基本数据结构和常用算法；
6、熟练掌握C程序设计语言，以及C++、Java、Visual Basic中一种程序设计语言；
7、熟悉数据库、网络和多媒体的基础知识；
8、掌握软件工程的基础知识，了解软件过程基本知识、软件开发项目管理的常识；
9、了解常用信息技术标准、安全性，以及有关法律、法规的基本知识；
10、了解信息化、计算机应用的基础知识；
11、正确阅读和理解计算机领域的简单英文资料。
二、考试科目： 1、计算机硬软件基础知识，考试时间为150分钟。
2、程序设计，考试时间为150分钟。
三、考试范围： 考试科目
1：计算机与软件工程基本知识 1.计算机科学基础
1.1数制及其转换
二进制、十进制和十六进制等常用数制及其相互转换
1.2数据的表示
数的表示
非数值数据的表示
1.3算术运算和逻辑运算
计算机中二进制数的运算方法
逻辑代数的基本运算
1.4数学应用
常用数值计算（矩阵、近似求解、插值）
排列组合、应用统计
编码基础
1.5常用数据结构
数组
线性表及链表
队列、栈
树
图
1.6常用算法
算法与数据结构的关系
算法设计和算法描述
常用的排序算法
查找算法
常用的数值计算方法
字符串处理算法
递归算法
最小生成树、拓扑排序和单源点最短路径求解算法
2.计算机系统基础知识 2.1硬件基础知识
2.1.1计算机的类型和特点
微机（PC机）、工作站、服务器、主机、大型计算机、巨型计算机、并行机
2.1.2中央处理器CPU
CPU的组成
常用的寄存器
指令系统，寻址方式
令执行控制、中断控制、处理机性能
2.1.3主存和辅存
存储介质
高速缓存（Cache）、主存
辅存设备
2.1.4I/O接口、I/O设备和通信设备
I/O接口
I/O设备（类型、特性）
通信设备（类型、特性）
I/O设备、通信设备的连接方法和连接介质类型
2.2软件基础知识
2.2.1操作系统基础知识
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0852ffa0b0f9285b4882cb1af04cf8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8eb419d6224e123398e707e4572ad43/" rel="bookmark">
			YTU OJ 2221: 两个链表之间问题(线性表)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 已知两个单链表A和B,其头指针分别为heada和headb，编写一个过程从单链表A中删除自第i个元素起的共len个元素，然后将单链表A插入到单链表B的第j个元素之前。
输入 前三个数分别表示i,len,j
一个整数m，表示A链表的长度m。
m个数表示A链表中的m个数据元素。
一个整数n，表示B链表的长度n。
n个数表示B链表中的n个数据元素。
输出 操作后的结果。
样例输入
1 3 5
11
13 5 14 62 3 43 71 5 72 34 5
15
5 20 3 53 7 81 5 42 6 8 4 6 9 10 23
样例输出
5 20 3 53 62 3 43 71 5 72 34 5 7 81 5 42 6 8 4 6 9 10 23
采用C++方式提交
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct Lnode { int data; struct Lnode *next; }LinkNode; void Init(LinkNode *&amp;L)	//初始化链表 { L=(LinkNode *)malloc(sizeof(LinkNode)); L-&gt;next=NULL; } void Delete(LinkNode *&amp;L,int i,int len) //从单链表A中删除自第i个元素起的共len个元素 { LinkNode *p=L,*pre,*q,*r; int j=0,k=0; while(j&lt;i-1 &amp;&amp; p!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8eb419d6224e123398e707e4572ad43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2495e596fe5f45e1b0927872f31e513e/" rel="bookmark">
			RT-Thread之线程的诞生与消亡史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引言 本文基于Cotex-M内核处理器分析讨论RT-Thread中线程从创建到消亡的整个详细过程。
线程的载体-控制块 RT-Thread中是用线程控制块来描述线程实体的，在 RT-Thread 中，线程控制块由结构体 struct rt_thread 表示，线程控制块是操作系统用于管理线程 的一个数据结构，它会存放线程的一些信息，例如优先级、线程名称、线程状态等，也包含线程与线程之 间连接用的链表结构，线程等待事件集合等 。所有对线程的操作归根结底都是对线程控制块中以上属性所对应变量的操作。
线程的诞生 线程不会自己产出，需要人为的去创建，RT-Thread提供了两种方式：使用 rt_thread_create() 创建一个动态线程，使用 rt_thread_init() 初始化一个静态线程，动态线程与 静态线程的区别是：动态线程是系统自动从动态内存堆上分配栈空间与线程句柄（初始化 heap 之后才能 使用 create 创建动态线程），静态线程是由用户分配栈空间与线程句柄 。
线程的消亡 线程的消亡分为人为删除和自然消亡。
自然消亡：线程结束（线程入口函数返回）后，当前线程也会随之消亡。
人为删除又分为两种情况:
情况一：对于一些使用 rt_thread_create() 创建出来的线程，当不需要使用，或者运行出错时，我们可以使用
rt_thread_delete()从系统中把线程完全删除掉。
情况二：对于用 rt_thread_init() 初始化的线程，使用 rt_thread_detach() 将使线程对象在线程队列和内核对
象管理器中被脱离（删除）。
2、线程删除细节 RT-Thread中线程删除过程分为两个步骤：
​ 第一、先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入rt_thread_defunct 僵尸队列（资源未回收、处于关闭状态的线程队列）中。
​ 第二、空闲线程会回收被删除线程的资源。
上诉第一步的处理过程的本质是，直接（直接删除）或者间接调用rt_schedule_remove_thread()来完成上诉操作。所谓直接是指人为的调用 rt_thread_delete()或者rt_thread_detach()函数，这两个函数函数内部都调用了rt_schedule_remove_thread（）函数。所谓间（自然消亡）接是指线程结束（线程入口函数返回）后，系统空闲线程 自动执行 rt_thread_exit() ，该函数中也调用了rt_schedule_remove_thread（）函数。
直接删除操作比较好理解，我们重点对自然消亡的线程删除过程进行分析。通过上面描述我们只知道线程运行结束时会自动执行 rt_thread_exit() 函数，对于如何调用rt_thread_exit()的细则一开始是一头雾水。下面经过分析源码我们将拨开这层神秘的面纱。
无论是调用rt_thread_create()创建的动态或是调用rt_thread_init()创建的静态线程，内部都是通过调用_rt_thread_init()函数来完成线程创建工作的。下面我们对 _rt_thread_init()函数进行分析
static rt_err_t _rt_thread_init(struct rt_thread *thread, const char *name, void (*entry)(void *parameter), void *parameter, void *stack_start, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick) { …… //省略部分 /*初始化线程控制坏*/ thread-&gt;sp = (void *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter, (void *)((char *)thread-&gt;stack_addr + thread-&gt;stack_size - 4), (void *)rt_thread_exit); …… //省略部分 } _rt_thread_init() 函数内部调用了rt_hw_stack_init()函数对线程控制块进行初始化，这个也是线程创建的本质。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2495e596fe5f45e1b0927872f31e513e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7daae9ec0b0133537fcf18a9b1c78b69/" rel="bookmark">
			通道与DMA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通道和DMA区别
1、通道一般用在大型计算机系统中(不是大型机)。
2、通道实质是一台能够执行有限的输入输出指令，并能被多台外设共享的小型DMA专用处理机。
3、通道的作用–解决了两个问题。
a.由cpu承担输入输出的工作。
虽然dma无需cpu进行外设与内存的数据交换工作，但是这只是减少了cpu的负担。因而dma中,输入输出的初始化仍然要由cpu来完成。
b.大型计算机系统中高速设备共享dma接口的问题。大型计算机系统的外设太多以至于不得不共享有限的dma接口(小型计算机系统比如pc机中每个高速设备分配一个dma接口)。
DMA方式，是CPU通过向DMA控制器设定若干参数，然后DMA打开了一条内存到设备的通道，这样，设备（内存）中的数据可以不通过CPUl来进行数据交互。缺点是，DMA是多少设备就需要多少DMA，而且，DMA方式下，CPU的访问设备是以数据块为周期的。
传送门1
传送门2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577659e3e6321a222addf79876f06f61/" rel="bookmark">
			GitHub 学生认证，申请 GitHub 学生包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub 面对学生推出了学生认证服务，通过认证后就可以得到学生包，学生包大概有十几项优惠，包括 DATADOG Pro 帐户、免费两年的10台服务器，Icons8 3个月的带图标，照片，插图和音乐订阅服务、JETBRAINS 专业桌面 IDE 免费订阅、name.com 一个免费域名和免费高级安全（SSL，隐私保护等）、SendGrid 每月15k的免费电子邮件、.tech 域名免费使用一年等，所有优惠项目可以在官网看到：https://education.github.com/pack
点击链接：https://education.github.com/，选择 Students
点击 Get benefits for students：
随后来到学生认证页面，认证方式分为教育邮箱认证和提交学生证照片认证两种方式，教育邮箱是学校 .edu.cn 后缀的，学校有的话可以找学校申请（大多数学校没有），没有的话只能通过提交学生证照片的方式来认证了，选择 Student，再选择一个你 GitHub 绑定的邮箱，随后会出来照片上传选项，上传你的学生证照片后再填入你学校全称和申请理由，学生证照片一定要有你的照片、入学时间等必须的内容，填写内容时使用中文英文都可以，然后提交就OK了，大概一周之内就会通过。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0391e1344172c7e66b79e7b55e367aa6/" rel="bookmark">
			Shiro无权限 控制台报错org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Shiro无权限 控制台报错org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method 控制台报错： 解决方法: 新建一个类对Exception使用Spring的@ExceptionHandler和@ControllerAdvice统一处理异常
@ControllerAdvice public class NoPermissionException { @ResponseBody @ExceptionHandler(UnauthorizedException.class) public String handleShiroException(Exception ex) { return "无权限"; } @ResponseBody @ExceptionHandler(AuthorizationException.class) public String AuthorizationException(Exception ex) { return "权限认证失败"; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248a7f7273ade9dca2dfd1b8dc0033d4/" rel="bookmark">
			C# winform Combox 下拉菜单 DropDownList 下拉选项空白无法显示文本的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Combox控件默认是可编辑的下列表，如下效果
2、设置属性-DropDownStyle：DropDownList
3、设置控件绘制模式DrawMode=OwnerDrawFixed，效果如下
默认的背景颜色是：BackColor:Window
4、设置事件-DrawItem，来控制文字的颜色，效果如下
5、设置背景颜色以及文字颜色，效果如下
代码文件下载
————来自水平一般的小5
我不是技术大牛，但是我喜欢钻研技术，更乐于帮助踏上程序道路的网友们
需要帮助可联系
QQ：1563392709@qq.com，备注：小5
微信：xgwkf566，备注：小5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a6498f6634741dc62328fd4e553921/" rel="bookmark">
			HTTP code（状态码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。
文章目录 1：消息100 Continue101 Switching Protocols102 Processing 2. 成功200 OK201 Created202 Accepted204 No Content205 Reset Content 3.重定向4.请求错误400 Bad Request401 Unauthorized402 Payment Required403 Forbidden404 Not Found405 Method Not Allowed406 Not Acceptable407 Proxy Authentication Required408 Request Timeout 5.服务器错误500 Internal Server Error501 Not Implemented502 Bad Gateway503 Service Unavailable504 Gateway Timeout505 HTTP Version Not Supported506 Variant Also Negotiates507 Insufficient Storage510 Not Extended600 Unparseable Response Headers 百度百科HTTP状态码详解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0a6498f6634741dc62328fd4e553921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc20d978449ca8dfa142f6d1dc51fa1/" rel="bookmark">
			Impala
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Apache Impala二、 Apache Impala1． Impala基本介绍2． Impala与Hive关系3． Impala与Hive异同3.1． Impala使用的优化技术3.2． 执行计划3.3． 数据流3.4． 内存使用3.5． 调度3.6． 容错3.7． 适用面 4． Impala架构4.1． Impalad4.2． Impala State Store4.3． CLI4.4． Catalogd 5． Impala查询处理过程 三、 Impala安装部署1． 安装前提2． 下载安装包、依赖包3． 虚拟机新增磁盘（可选）3.1． 关机新增磁盘3.2． 开机挂载磁盘 4． 配置本地yum源4.1． 上传安装包解压4.2． 配置本地yum源信息 5． 安装Impala5.1． 集群规划5.2． 主节点安装5.3． 从节点安装 6． 修改Hadoop、Hive配置6.1． 修改hive配置6.2． 修改hadoop配置6.3． 重启hadoop、hive6.4． 复制hadoop、hive配置文件 7． 修改impala配置7.1． 修改impala默认配置7.2． 添加mysql驱动7.3． 修改bigtop配置 8． 启动、关闭impala服务8.1． impala web ui 四、 Impala-shell命令参数1． impala-shell外部命令2． impala-shell内部命令 五、 Impala sql语法1． 数据库特定语句1.1． 创建数据库1.2． 删除数据库 2． 表特定语句2.1． create table语句2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc20d978449ca8dfa142f6d1dc51fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/232e693cd5dc6e4cccfeedb482b7c781/" rel="bookmark">
			流水线调度问题【java版本】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求
N个作业{1，2，…，n}要在由2台机器M1和M2组成的流水线上完成加工。每个作业加工的顺序都是先在M1上加工，然后在M2上加工。M1和M2加工作业i所需的时间分别为a[i]和b[i]。你可以安排每个作业的执行顺序，使得从第一个作业在机器M1上开始加工，到最后一个作业在机器M2上加工完成所需的时间最少。求这个最少的时间。
思路：
需要M2尽可能早用多用不出现空闲的状态。
将任务分成两类
第一类为a[i]&lt;b[i]，该种任务需要保证M2尽早开始，故非降序排列
第二类为a[i]&gt;=b[i],这种任务会在M1中阻塞较久时间，所以需要M2中更忙一点也就是更晚结束，故非升序排列。
因为要保证第二台机器尽早开始故将第二类任务加在第一类之后。
实现：
import java.util.Arrays; public class Johnson { public static void main(String[] args) { int[] a = {3, 4, 8, 10}; int[] b = {6, 2, 9, 15}; int sum = flowShop(a, b); System.out.println(sum); } public static int flowShop(int[] a, int[] b) { int[] order = new int[a.length]; Work[] works = new Work[a.length]; for (int i = 0; i &lt; a.length; i++) { int key = a[i] &gt; b[i] ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/232e693cd5dc6e4cccfeedb482b7c781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be8c829d6fb44326245b17e51e719ff8/" rel="bookmark">
			这21款AS插件,来走一波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GsonFormat
将 Json 字符串快速转成 JavaBean 对象，免去我们根据 Json 字符串手写对应 Java Bean 的过程.
Tips: 可以使用快捷键 alt + s (windows) / option + s (mac)
Android ButterKnife Zelezny 配合 butterknife 实现注解，不用再手动实现 findViewById 了。
Android Methods Count 显示依赖库中得方法数
Lifecycle Sorter 可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序， windows 快捷键Ctrl + alt + K . Mac 快捷键 option + command + K
Android Code Generator 根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。
CodeGlance 在右边实现代码预览，类似于 sublime ，快速定位。
FindBugs-IDEA 查找 bug 的插件。具体使用可见 freddyyao 的简书文章 -&gt; 代码缺陷扫描神器 —— FindBugs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be8c829d6fb44326245b17e51e719ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96e863ee1c704af7326289ba4b7bd4d/" rel="bookmark">
			在网站中使用VideoJs视频播放器播放视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前使用videojs用来网页中播放视频，现在做一下总结 （这里把插件下载及演示地址、使用方法及demo放出来）
视频播放插件Video.js 插件下载地址： http://www.jq22.com/jquery-info404 演示播放视频地址：http://www.jq22.com/yanshi404 （直接从浏览器打开观看效果）
Video.js 是一个通用的在网页上嵌入视频播放器的 JS 库，Video.js 自动检测浏览器对 HTML5 的支持情况，如果不支持 HTML5 则自动使用 Flash 播放器。 在页面中引用video-js.cs样式文件和video.js
&lt;link href="video-js.css" rel="stylesheet" type="text/css"&gt; &lt;script src="video.js"&gt;&lt;/script&gt; 设置flash路径，Video.js会在不支持html5的浏览中使用flash播放视频文件
&lt;script&gt; videojs.options.flash.swf = "video-js.swf"; &lt;/script&gt; html
poster="**"播放初始图。可使用三种视频格式，根据所需要格式选择对应的。
&lt;video id="example_video_1" class="video-js vjs-default-skin" controls preload="none" width="640" height="264" poster="http://video-js.zencoder.com/oceans-clip.png" data-setup="{}"&gt; &lt;source src="http://视频地址格式1.mp4" type='video/mp4' /&gt; &lt;source src="http://视频地址格式2.webm" type='video/webm' /&gt; &lt;source src="http://视频地址格式3.ogv" type='video/ogg' /&gt; &lt;track kind="captions" src="demo.captions.vtt" srclang="en" label="English"&gt;&lt;/track&gt;&lt;!-- Tracks need an ending tag thanks to IE9 --&gt; &lt;track kind="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d96e863ee1c704af7326289ba4b7bd4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c9c42971b2c943c83ecbde5407c70d/" rel="bookmark">
			Swiper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.wxml
&lt;view&gt;swiper组件&lt;/view&gt; &lt;view class='section'&gt; &lt;view class='page-body'&gt; &lt;view class='page-section page-section-spacing swiper'&gt; &lt;swiper indicator-dots="{{indicatorDots}}" autoplay="{{autoplay}}" interval="{{interval}}" current="0" duration="{{duration}}" bindchange='change' bindanimationfinish="animationfinish"&gt; &lt;block wx:for='{{background}}' wx:key='*this'&gt; &lt;swiper-item&gt; &lt;view class='swiper-item {{item}}'&gt;&lt;/view&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; &lt;/view&gt; &lt;view class='page-section' style='marggin-top:40rpx;margin-bottom:20rpx;'&gt; &lt;view class='weui-cell weui-cell_after-title'&gt; &lt;view class='weui-cell weui-cell_switch'&gt; &lt;view class='weui-cell_bd'&gt;指示点&lt;/view&gt; &lt;view class='weui-cell_ft'&gt; &lt;switch checked='{{indicatorDots}}' bindchange='changeIndicatorDots'&gt;&lt;/switch&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class='weui-cell weui-cell_switch'&gt; &lt;view class='weui-cell_bd'&gt;自动播放&lt;/view&gt; &lt;view class='weui-cell_ft'&gt; &lt;switch checked='{{autoplay}}' bindchange='changeAutoplay'&gt;&lt;/switch&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class='page-section page-section-spacing'&gt; &lt;view class='page-section-title'&gt; &lt;text&gt;幻灯片切换时长（ms）&lt;/text&gt; &lt;text class='info'&gt;{{duration}}&lt;/text&gt; &lt;/view&gt; &lt;slider bindchange='durationChange' calue='{{duration}}' min="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c9c42971b2c943c83ecbde5407c70d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3139c4354705b389b53443f8c1973c/" rel="bookmark">
			经验分享：python利用关键字做字典切片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中dataFrame或者Series类型可以使用标准方式按选定关键字对数据进行切片，但是字典类型就比较麻烦了，有没有比较简洁的方式完成呢？
例如：字典按{日期：列表}方式构成，日期是Key，字典： buy
‘2018-01-05’: [a1,a2,a3]
‘2018-01-06’: [a3,a5,a6,a9]
…
‘2019-01-04’:[a1,a2,a6,a10]
‘2019-01-05’:[a3,a4]
…
‘2019-04-04’:[a3,a7,a11,a12,a13]
…
‘2019-07-24’:[a5,a10,a11,a18,a19]
想要做2019-01-04到2019-04-04切片
stratTime=2019-01-04
endTime=2019-04-04
list_buy=list(buy.keys())
key=list_buy[list_buy.index(stratTime):list_buy.index(endTime)]
buy_subdict = {k: buy[k] for k in key}
print(‘buy part’,buy_subdict)
buy_subdict 就是切片后的字典
‘2019-01-04’:[a1,a2,a6,a10]
‘2019-01-05’:[a3,a4]
…
‘2019-04-04’:[a3,a7,a11,a12,a13]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46c7dca447fc9dcc1ffe1790d733ec1/" rel="bookmark">
			Scroll-View
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.wxml
&lt;view&gt;scroll-view组件&lt;/view&gt; &lt;view class='section'&gt; &lt;view class='section_title'&gt;竖向滚动&lt;/view&gt; &lt;scroll-view style='height:200rpx;background:red;' scroll-y bindscrolltoupper='upper' bindscrolltolower='lower' bindscroll='scroll' scroll-into-view='{{toView}}' scroll-top='{{scrollTop}}' enable-back-to-top='true' scroll-with-animation='true'&gt; &lt;view id='green' class='scroll-view-item' style='background:green;height:200rpx;'&gt;&lt;/view&gt; &lt;view id='yellow' class='scroll-view-item' style='background:yellow;height:200rpx;'&gt;&lt;/view&gt; &lt;view id='yellow' class='scroll-view-item' style='background:blue;height:200rpx;'&gt;&lt;/view&gt; &lt;view id='blue' class='scroll-view-item'&gt;&lt;/view&gt; &lt;/scroll-view&gt; &lt;view class='btn-area'&gt; &lt;button size='mini' bindtap='tap'&gt;Click me to scroll into view&lt;/button&gt; &lt;button size='mini' bindtap='tapMove'&gt;Click me to scroll&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; 2.js
var order = ['green', 'yellow','blue']; Page({ data:{ toView:'green', scrollTop:0 }, clickA(e){ console.log('click container-A'); }, clickB(e) { console.log('click container-B'); }, clickC(e) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46c7dca447fc9dcc1ffe1790d733ec1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64281194d87dc4a4096e0448acb8a72d/" rel="bookmark">
			【UR #5】怎样更有力气
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem Description 大力水手问禅师：“大师，很多事情都需要用很大力气才能完成，而我在吃了菠菜之后力气很大，于是就导致我现在非常依赖菠菜。我很讨厌我的现状，有没有办法少吃点菠菜甚至不吃菠菜却仍很有力气？”
禅师浅笑，答：“方法很简单，不过若想我教你，你需先下山徒手修路。”
山下是 \(n\) 座村庄从 \(1\) 到 \(n\) 编号，之间没有路相连。禅师给了大力水手一张草图，这张草图里 \(n\) 座村庄被 \(n — 1\) 条双向道路连接，任意一个村庄都可以通过双向道路到达其它所有村庄。
现在大力水手要根据禅师的意思在村庄间修路。禅师规定大力水手需要在 \(m\) 天内完成任务，其中大力水手的修路方式如下：
第 \(i\) 天，禅师指定了两个村庄 \(v_i\) 和 \(u_i\)，在草图上 \(v_i\) 号村庄到 \(u_i\) 号村庄的最短路径上的所有村庄（包括 \(v_i\) 和 \(u_i\)）中，大力水手需要选出若干对村庄（一个村庄可以被重复选多次，当然大力水手在这天也可以一对村庄都不选），然后在选出的每一对村庄间修建双向道路。
在实地考察中大力水手发现，有 \(p\) 个限制关系 \((t_i, a_i, b_i)\)，表示在第 \(t_i\) 天无法在 \(a_i\) 号村庄到 \(b_i\) 号村庄间修路（路是双向的，所以自然也无法在 \(b_i\) 号村庄到 \(a_i\) 号村庄间修路）。
每一天都有个修理所需力气值 \(w_i\)，表示在第 \(i\) 天每修建一条道路都要耗费 \(w_i\) 点力气值。
大力水手开始蛮力干了起来，一罐又一罐地吞食菠菜，结果经常修建一些无用的道路，每天都累得筋疲力尽。
作为一个旁观者，请你帮大力水手求出要想让 \(m\) 天后任意一对村庄之间都可以互相到达，所需要的总力气值最少是多少。注意最后修出来的道路不必和草图一致。
Input Format 第一行三个非负整数 \(n, m, p\)。保证 \(n \geq 1\)。
接下来一行 \(n — 1\) 个整数，其中第 \(i\) 个整数 \(f_{i+1}\) （\(1 \leq f_{i+1} \leq i\)）表示草图中 \(i + 1\) 号村庄与 \(f_{i+1}\) 号村庄间有一条双向道路。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64281194d87dc4a4096e0448acb8a72d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31e5d34c4166c0eb2fd68dfdb7d6240/" rel="bookmark">
			现在学java的都是傻子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不经意的看见，看到学java的都是傻子。当不经意看到，说明，这个最近已经在网上疯传了很多。说明目前这个行业真的已经不好了。所以你得自己当心了。在这个行业不知有多少学习了又放弃了。博主我也是其中之一，从博主我的名字相信大家也可以看出来，“从放弃到开始”这是博主的名称，也仅仅是自我鼓励，可能与自己性格有关吧。同时也是为那些也许与博主一样情况的，不管哪个行业。也许都会有这么一些人人学习了又放弃了，然后放弃了又学习。由感而发。（博主个人觉得以下四个原因）。
一：刚出社会的科班学生。 二：大环境的行情不好，这个已经是事实。如果不相信，请自行查询相关资料，这里博主也不与你相争。 一般是985.211的科班生刚出来的话，博主个人觉得相对来说做这行还是可以的，竞争优势明显。物竞天泽，弱肉强食，不管在哪个行业，都可以这样形容，这也是生存的法则。
三：各大培训机构的批量生产 现在很多人都觉得it行业很吃香，而java目前又是最主流的语言，当一个不知这行业的人已经知道了，说明这行真的已经饱和了。这行业的黄金期是（2008-2014年左右）那时候你只需要知道一点，真的是可以随便找工作。现在，你在进来，真的GG了。尤其是超过了30岁，学历不怎么高的，你还想转过来的话，到时候怎么GG的都不知道。非科班呢？如果是零基础转过来，博主这里告诉你，也过得是很难受的，到时候自己去写文章感悟吧！
四：企业对这个行业的要求已经变得很高了。 做这行业的，1，学习成本：科班生，一般在大学的时候，在学校的时候还是会学一些基本的算法结构等，也是会有一定的基础的。但他们也只是在学校学习了一点皮毛。但有培养的前景。一般参加个什么实习，这样大概至少也得6个月。
非科班：首先是学习的路径：从哪学？一般是从培训机构，但培训机构有很多，参差不齐。即使是同个培训机构的，不同的讲课人，讲的效果真不一样。（博主也看了很多的视频，讲同样的内容，会有天差地别的感觉）。从其他途径学？如网上视频，网上博客文章，这个得看你的学习悟性与自觉的能力（这种一般推荐那种悟性很高的人，那么作为一般人建议系统的学习）。大概分析了下。
以上从两种不同的人来说：那么最终还是会花时间与金钱。
血汗钱都去哪儿了？培训费、生活费、时间成本费：一般目前的培训机构学费，据我了解，最少得2万元左右，还不包括你自己的衣食住行，再加上你自己的生活费，差 不多最少得3万元。对于窘迫的你，有这个承担能力。虽然培训机构会帮你想办法，无法就是借贷款，当然这个是你自己要还的。所以一定要想好。对于一些有钱人来说，如果家庭不错的话，还是可以走正规途径学习，还可以交到志同道合的人。当然，这个社会，2万元，相信大多数家庭都已经有，这个得感谢伟大的祖国。那么对于真正农村走出来的，这个还是一笔不小的开支。如果走正规学习路径，那么请一定好好学习，虽然学习苦，学习累，学习还要交学费。如果你真的能学到真正的技术，还是对自己有帮助的。是不是你会问，既然说正规学习路径，那当然也有其他的学习路径。这边博主也可以告诉你，可以去哪不用花太多的金钱，但学习时间肯定是要花很多的，以及这个学习效率也是要靠你自己的。
学习路径方法如下：一，伟大的企业家马云的淘宝可以查询你需要的学习资料 二，伟大的企业家马化腾的微信公众号以及相应的it行业群 三，伟大的企业家百度李彦宏的百度云查询你学习的资料，国内的三大IT巨头（BAT）。其他的学习路径，相信你，自己可以再去摸索发现，这里就不一一举例了。方法有很多，最符合你自己的才是最好的。
java学习路线：https://blog.csdn.net/qq_30764991/article/details/89284277 2.学习内容，这个行业非常广泛。相信你可以从博主的文章就知道，需要学习的内容有多少了，博主的文章内容，很多也只是冰山一角。也并不全面，所以需要不断的去学习。（学习的内容这里博主就不详细的介绍了，因博主自己技术有限，也只能是慢慢 分享给大家，欢迎关注）
那么这行业，真的没有希望了吗？如果喜欢，有这坚持的毅力，这个请你慎重决定，一定要经过全方位的考虑，然后做出你的决定，千万不要冲动，（年轻容易冲动，博主也是其中之一，也是这样的性格，哈哈，不知什么时候，自己开始学会了自我吐槽，是不是也叫我反省呢。）到时候受伤的不止是你，还有你的家人等等。俗话说，女怕嫁错郎，男怕入错行，如果决定了，会影响你一生的命运。哈哈，博主我也是觉得我自己入错行了，但这就是命，希望我的好运早点到来。（ps，男人是命，女人是运，那个运你在哪呢?) 最后，祝大家万事如意，心想事成！！！
好了，大概就写到这了，时间不早了，已是深夜.......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee7c2299429e200d2bb3e8ec946de77/" rel="bookmark">
			在Linux系统下安装了VMware后打开提示GCC没有找到的解决方法 [GNU C Compiler (gcc) version 7.3.0 was not found.]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware Kernel Module Updater
Before you can run VMware, several modules must be compiled and loaded into the running kernel.
GCC
GNU C Compiler (gcc) version 7.3.0 was not found. If you installed it in a non-default path you can specify the path below. Otherwise refer to your distribution’s documentation for installation instructors and click Refresh to search again in default locations.
在终端中执行以下三条命令：
sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update sudo apt-get install build-essential 执行完以上三条命令gcc就安装完成了，重启虚拟机顺利打开。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ee7c2299429e200d2bb3e8ec946de77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effb14f2cfebef78f206391e6e9ebe07/" rel="bookmark">
			vue异步发送请求，渲染数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步请求
html：
&lt;table&gt; &lt;tr&gt;&lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&lt;input type="email" name="email" v-model="email"&gt;&lt;/td&gt;&lt;/tr&gt; //使用双向绑定 &lt;tr&gt;&lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&lt;input type="password" name="password" id="password" v-model="password"&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td colspan="2"&gt;&lt;input type="submit" value="登陆" @click="user()"&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; script
export default{ data() { return { email:'', #双向绑定 password:null, result:null, } }, scrip 中js异步请求，写在method中
user() { let xhr = new XMLHttpRequest() let that=this xhr.open('post','http://111.230.10.23/orange/user/login/',true) xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');#post参数请求说明 xhr.send("email="+this.email+"&amp;password="+this.password);//传递参数 xhr.onreadystatechange = function(){ if (xhr.status==200 &amp;&amp; xhr.readyState==4){ //获取返回成功的数据 let res = xhr.responseText res=JSON.parse(res) console.log(res) if (res.code==1){ that.$router.push({path:'/info'}) #跳转路由vue中 window.localhost.href = '/info/' #js跳转 window.open('/info/') #window跳转 } } }	}	vue，script的ajax写法，首先要使用Axios重新定义ajax
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effb14f2cfebef78f206391e6e9ebe07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa4911d7f466aae5fbe353fdd71f31e/" rel="bookmark">
			数学建模之粒子群算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		粒子群（鸟群算法）算法是典型的寻优算法。分为全局最优和局部最优。 基本思想：主要模拟自然界生物捕食的策略，群体迭代，粒子在解空间追随最优的例子进行搜索。是智能算法的一种。
算法特点：
简单易行。收敛速度快。设置参数少。
一般的限制条件是当达到限制步数或者达到相应的准确度的时，粒子就会停止移动。
设想一个场景：一群鸟在随机搜索食物。
已知（假设）：1.在这块区域里只有一块食物。2.所有的鸟都不知道食物在哪。3.但他们能感受到当前的位置离食物还有多远。
问题是：找到食物的最优策略是什么。
搜索目前离食物最近的鸟的周围区域，根据自己飞行经验判断食物的所在。
PSO的基础:信息的社会共享 算法介绍 每个寻优的问题解都被想象成一只鸟，称为粒子。所有粒子都在一个D维空间进行搜索。所有粒子都由一个fitness function 确定适应值以判断目前的位置好坏。每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置。每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态的调整。
D维空间中，有N个粒子；
粒子i位置：xi=(xi1,xi2,…xiD)，将xi代入适应函数f(xi)求适应值；
粒子i速度：vi=(vi1,vi2,…viD)
粒子i个体经历过的最好位置：pbesti=(pi1,pi2,…piD)
以上规定位置变化的界限和速度变化的界限。速度过快或者过慢都会对粒子寻优产生影响。粒子i的第d维速度更新公式：
粒子i的第d维位置更新公式：
变量含义：
vid ^k —第k次迭代粒子i飞行速度矢量的第d维分量
xid^k —第k次迭代粒子i位置矢量的第d维分量
c1,c2—加速度常数，调节学习最大步长
r1,r2—两个随机函数，取值范围[0，1]，以增加搜索随机性
w —惯性权重，非负数，调节对解空间的搜索范围
粒子速度更新公式包含三部分：
第一部分：粒子先前的速度。
第二部分：认知部分，表示粒子本身的思考，可以理解为粒子i当前位置与自己最好位置之间的距离。
第三部分：社会部分，表示粒子间的信息共享与合作，可以理解为粒子i当前位置与群体最好
算法基本流程： 1.初始化粒子群体（群体规模为n），包括随机位置和速度。2.根据fitness function ，评价每个粒子的适应度。3.对每个粒子，将其当前适应值与其个体历史最佳位置（pbest）对应的适应值做
比较，如果当前的适应值更高，则将用当前位置更新历史最佳位置pbest。4.对每个粒子，将其当前适应值与全局最佳位置（gbest）对应的适应值做比较，5.根据公式更新每个粒子的速度与位置。6.如未满足结束条件，则返回步骤2,通常算法达到最大迭代次数 或者最佳适应度值的增量小于某个给定的阈值时算法停止。 粒子群算法的构成要素：
群体大小m:m是一个整数。
如果m很小，陷入局部最优解的可能性很大。
如果m很大，PSO的优化能力很好，当群体数目增长到一定水平时候，再整长就不再有显著的作用。权重因子：惯性因子 W 学习因子 c1、c2粒子速度的更新主要由以下三部分组成。
如果惯性因子w=1 则是基本粒子群算法 如果w=0的话，失去对粒子本身的速度的记忆。
如果c1=0,就是无私型粒子群算法,缺点是：只有社会，没有自我，迅速丧失群体多样性，容易陷入局部最优解而无法跳出。太依赖群体了。
如果学习因子c2=0,那么是自我认知型粒子群算法。不管社会群体。 完全没有信息的社会共享，导致算法收敛速度缓慢。
如果c1、c2都不为0，称为完全型粒子群算法。完全型粒子群算法更容易保持收敛速度和搜索效果的均衡，是较好的选择。 粒子群算法的构成要素-最大速度 作用：
在于维护算法的探索能力和开发能力的平衡。Vm较大时，探索能力增强，但是容易飞过最优解。Vm较小的时候，开发能力增强，但是容易陷入局部最优解。Vm一般设为每维变化范围的10%-20%。
粒子群邻域算法的构成要素-邻域的拓扑结构 粒子群算法的邻域拓扑结构包括两种：
一种是将群体内的所有个体都作为粒子的邻域，另一种是只将群体中的部分个体作为粒子的邻域。
邻域拓扑结构决定了群体历史的最优位置。由此，将粒子群算法分为全局粒子群算法和局部粒子群算法。
全局粒子群算法包括：
1粒子自己历史最优值。2粒子群体的全局最优值（最优值由全部粒子决定）
局部粒子群算法包括1.粒子自己历史最优值2.粒子邻域内粒子的最优值（部分个体粒子来决定）。
邻域随迭代次数的增加线性变大，最后邻域扩展到整个粒子群。
经过实践证明： 全局版本的粒子群算法收敛速度快，但是容易陷入局部最优。局部版本的粒子群算法收敛速度慢，但是很难陷入局部最优。现在的粒子群算法大都在收敛速度与摆脱局部最优这两个方面下功夫。但是这两个方面存在着矛盾。只能是看如何更好折中。 粒子群算法的构成要素-停止准则 停止准则一般有以下两种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa4911d7f466aae5fbe353fdd71f31e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc14fbf4dc8e41519fd01e335263ce4/" rel="bookmark">
			ubuntu16.04&#43;anaconda3&#43;python3.6安装OpenCV3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、首先要安装anaconda3
1.下载anaconda3 for python3.6，下载地址：anaconda3
下载你需要的版本，这里我是下载的Anaconda3-5.2.0-Linux-x86_64.sh，对应的是python3.6
然后打开终端，切换到文件所在目录，并执行如下命令：
sudo sh Anaconda3-5.2.0-Linux-x86_64.sh 二、安装python对应版本的opencv
假如您不是Python3.6版本，请安装对应python版本的OpenCV！！！！
如果您想切换到Python3.6版本，可以执行如下命令：
conda install python=3.6 正文
方法一
直接在Terminal中输入命令：
conda install -c https://conda.anaconda.org/menpo opencv3 然后根据提示，输入一些简单的命令如[y]\n? 输入y，等待更新安装即可。
不过这种方法就是速度很慢，因为连接的是国外的网站，如果失败，多试几次。
亲测有效！
方法二：
直接下载编译好的opencv3包，使用conda命令安装.
根据自己的版本，去下面地址下载对应的包：
opencv安装包
比如，我这里是下载了：opencv3-3.1.0-py36_0.tar.bz2
直接使用conda命令安装：
conda install opencv3-3.1.0-py36_0.tar.bz2 在ipython交互下，import cv2不报错，即安装成功。
安装opencv的过程中， opencv已经测试安装成功，但是要运行代码时又出现了以下问题:
Intel MKL FATAL ERROR: Cannot load libmkl_avx.so or libmkl_def.so. 最后才google查到了解决方案，一句解决问题:
conda install -f numpy 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad92188f998bcf1ce30defbebbb07cf/" rel="bookmark">
			如何运行vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在师兄的推荐下入坑vue.js ，发现不知如何运行GitHub上的开源项目，很尴尬。通过查阅网上教程，成功搭建好项目环境，同时对前段工程化有了朦朦胧胧的认知，因此将环境搭建过程分享给大家。
可以看下我的github：https://github.com/padipata ，里面有我学习、工作写的一些vue项目。
言归正传~~
首先，列出来我们需要的东西： node.js环境（npm包管理器）vue-cli 脚手架构建工具cnpm npm的淘宝镜像如果是已经存在的项目，git下来的项目请从 安装项目所需的依赖 开始看 安装node.js
从node.js官网下载并安装node，安装过程很简单，一路“下一步”就可以了（傻瓜式安装）。
安装完成之后，打开命令行工具，输入 node -v，如下图，如果出现相应的版本号，则说明安装成功。
npm包管理器，是集成在node中的，所以，直接输入 npm -v就会如下图所示，显示出npm的版本信息。
OK！node环境已经安装完成，npm包管理器也有了。由于有些npm有些资源被屏蔽或者是国外资源的原因，经常会导致用npm安装依赖包的时候失败，所有我还需要npm的国内镜像---cnpm。
安装cnpm 在命令行中输入 npm install -g cnpm --registry=http://registry.npm.taobao.org 然后等待，安装完成如下图。
完成之后，我们就可以用cnpm代替npm来安装依赖包了。如果想进一步了解cnpm的，查看淘宝npm镜像官网。
安装vue-cli脚手架构建工具 在命令行中运行命令 cnpm install -g vue-cli ，然后等待安装完成。(注意，这里使用cnpm来替代npm，不然速度超级慢，会导致卡在那)
通过以上三部，我们需要准备的环境和工具都准备好了，接下来就开始使用vue-cli来构建项目。
用vue-cli构建项目 要创建项目，首先我们要选定目录，然后再命令行中把目录转到选定的目录。在这里，我选择桌面来存放新建的项目，则我们需要先把目录cd到桌面，如下图。
在桌面目录下，在命令行中运行命令 vue init webpack firstVue 。解释一下这个命令，这个命令的意思是初始化一个项目，其中webpack是构建工具，也就是整个项目是基于webpack的。其中firstVue是整个项目文件夹的名称，这个文件夹会自动生成在你指定的目录中（我的实例中，会在桌面生成该文件夹），如下图。
运行初始化命令的时候回让用户输入几个基本的选项，如项目名称，描述，作者等信息，如果不想填直接回车默认就好。
打开firstVue文件夹，项目文件如下所示。
这就是整个项目的目录结构，其中，我们主要在src目录中做修改。这个项目现在还只是一个结构框架，整个项目需要的依赖资源都还没有安装，如下图。
安装项目所需的依赖 要安装依赖包，首先cd到项目文件夹（firstVue文件夹），然后运行命令 cnpm install ，等待安装。
安装完成之后，会在我们的项目目录firstVue文件夹中多出一个node_modules文件夹，这里边就是我们项目需要的依赖包资源。
安装完依赖包之后，就可以运行整个项目了。
运行项目 在项目目录中，运行命令 npm run dev ，会用热加载的方式运行我们的应用，热加载可以让我们在修改完代码后不用手动刷新浏览器就能实时看到修改后的效果。
这里简单介绍下 npm run dev 命令，其中的“run”对应的是package.json文件中，scripts字段中的dev，也就是 node build/dev-server.js命令的一个快捷方式。
项目运行成功后，浏览器会自动打开localhost:8080（如果浏览器没有自动打开，可以手动输入）。运行成功后，会看到如下所示的界面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fad92188f998bcf1ce30defbebbb07cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fddcad24fa2837369dfa0ca7f930a09/" rel="bookmark">
			adb 无线连接手机执行调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、手机和电脑连入同一个无线网络
2、手机使用数据线连接电脑，先执行adb devices看是否能够发现设备
3、成功发现设备后，命令行输入adb tcpip 5555，出现以下提示
4、手机与电脑断开数据线连接，查看手机的ip地址，如 192.168.3.15
5、执行 adb connect 192.168.3.15:5555 ，出现如下提示，则了解成功。可使用adb devices检验。
Python自动化测试研究院： 560151970 （q群） B站主页：https://space.bilibili.com/403609135 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a14493c8301e9a97970fc8eabc82be/" rel="bookmark">
			python3 websocket客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要安装websocket-client-py3模块
try: import websocket except ImportError: print("请先安装websocket-client-py3扩展") sys.exit(1) class socket: """ socket通讯 """ address = "ws://127.0.0.1:2345" ws = None def __init__(self): websocket.enableTrace(False) self.ws = websocket.WebSocketApp(self.address, on_message=self.on_message, on_error=self.on_error, on_close=self.on_close, on_open=self.on_open) self.ws.run_forever() def on_message(self, ws, message): """ 服务端消息 :param ws: :param message: :return: """ print(message) def on_error(self, ws, error): print("错误：" + error) def on_close(self, ws): print("### closed ###") def on_open(self, ws): def run(*args): ws.send('hello') print("thread terminating...") thread.start_new_thread(run, ()) socket_client = socket() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f0410b9e8f98718eb87f46cca7030d/" rel="bookmark">
			Python 爬虫入门的教程（2小时快速入门、简单易懂、快速上手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://c.biancheng.net/view/2011.html
这是一篇详细介绍 Python 爬虫入门的教程，从实战出发，适合初学者。读者只需在阅读过程紧跟文章思路，理清相应的实现代码，30 分钟即可学会编写简单的 Python 爬虫。
这篇 Python 爬虫教程主要讲解以下 5 部分内容：
了解网页；使用 requests 库抓取网站数据；使用 Beautiful Soup 解析网页；清洗和组织数据；爬虫攻防战； 了解网页 以中国旅游网首页（http://www.cntour.cn/）为例，抓取中国旅游网首页首条信息（标题和链接），数据以明文的形式出面在源码中。在中国旅游网首页，按快捷键【Ctrl+U】打开源码页面，如图 1 所示。
图 1 中国旅游网首页源码
认识网页结构 网页一般由三部分组成，分别是 HTML（超文本标记语言）、CSS（层叠样式表）和 JScript（活动脚本语言）。
HTML
HTML 是整个网页的结构，相当于整个网站的框架。带“＜”、“＞”符号的都是属于 HTML 的标签，并且标签都是成对出现的。
常见的标签如下：
&lt;html&gt;..&lt;/html&gt; 表示标记中间的元素是网页
&lt;body&gt;..&lt;/body&gt; 表示用户可见的内容
&lt;div&gt;..&lt;/div&gt; 表示框架
&lt;p&gt;..&lt;/p&gt; 表示段落
&lt;li&gt;..&lt;/li&gt;表示列表
&lt;img&gt;..&lt;/img&gt;表示图片
&lt;h1&gt;..&lt;/h1&gt;表示标题
&lt;a href=""&gt;..&lt;/a&gt;表示超链接
CSS
CSS 表示样式，图 1 中第 13 行＜style type=＂text/css＂＞表示下面引用一个 CSS，在 CSS 中定义了外观。
JScript
JScript 表示功能。交互的内容和各种特效都在 JScript 中，JScript 描述了网站中的各种功能。
如果用人体来比喻，HTML 是人的骨架，并且定义了人的嘴巴、眼睛、耳朵等要长在哪里。CSS 是人的外观细节，如嘴巴长什么样子，眼睛是双眼皮还是单眼皮，是大眼睛还是小眼睛，皮肤是黑色的还是白色的等。JScript 表示人的技能，例如跳舞、唱歌或者演奏乐器等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5f0410b9e8f98718eb87f46cca7030d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3198542ffb20427beef49edb23d1f7f/" rel="bookmark">
			游戏：Java编程实现猜数（0——100），最多猜10次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机产生一个整数，用户输入猜的数字，系统提示猜大了或者猜小了，输入次数不超过10次；如果正确，则显示“you are so smart”，
public class guessFigure { public static void main(String[] args) { // TODO Auto-generated method stub Scanner input=new Scanner(System.in); int answer = (int) (Math.random() * 100) + 1; for(int i=1;i&lt;11;i++) { System.out.println("please input an figure between 0~100 you guess:"); double figure =input.nextDouble(); if (figure&lt;answer) System.out.println("your answer is a littlle low "); else if(figure&gt;answer) System.out.println("your answer is a littlle high "); else System.out.println("you are so smart "); if(i==10) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3198542ffb20427beef49edb23d1f7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0500aad76a9d76a2c2fe1af24f442b/" rel="bookmark">
			Java 值传递、引用传递 以及clone
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从一个问题说起：有一个产品列表界面，用户可以选中想要的产品，对于选中的产品进行高亮显示。adapter 中有两个数据集集合list，一个是全部数据，一个是选中的数据（默认全选中），当我在构建这个adapter的时候，把这个集合也初始化了，当时代码是这样写的？
public KpNewUserProductsAdapter(List&lt;KpNewUserProduct&gt; kpNewUserProducts) { mKpNewUserProducts = kpNewUserProducts; mKpNewUserSelectedProducts = mKpNewUserProducts； //mKpNewUserSelectedProducts.addAll(mKpNewUserProducts); } 我把全部的数据集合直接赋值给了选中的数据集合，后面用户可以进行自己想要的产品，这个时候选中的产品list 会变化（因为用户可能只选择了部分产品），这时候就产生了bug，发现总的产品数量会随着选中的产品list改变？
这时候我想到了java中的赋值操作的含义，重新梳理了java的值传递、引用传递；还联想到了clone，这个几个知识点其实是一致的。下面来一一说解吧。
先说上面提到的问题原因：对象的赋值操作是引用传递，它们会指向同一个地址，任意一个改变会引起另一个的变化；
在这里我显然是想要一个全部产品list的副本，但赋值操作是不行的，这时候就需要clone。clone区分深浅clone，它们的区别就是被clone的对象其字段是否包含除基本类型之外的对象，如果我们只想要clone 基本类型，则是浅拷贝，如果想要连包含的对象也拷贝就是深拷贝。
参考文章：https://blog.csdn.net/qq_33314107/article/details/80271963
问题：大家有没有注意到为什么 list 集合类在clone 时，其泛型对象为什么不需要实现cloneable接口？来，研究一下。
首先集合接口类是没有继承cloneable 接口的，但是其实现类都是实现的，比如ArrayList，不信你打开源码看看。
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 文章参考https://blog.csdn.net/qiumengchen12/article/details/45022919 然后我们在看看它的clone 实现
/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() { try { ArrayList&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a0500aad76a9d76a2c2fe1af24f442b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a1a891e57a4f63ea57b3703cc18b4f/" rel="bookmark">
			JS算法1（每篇两道）：实现阶乘（递归）&amp;&amp;整数反转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在开头：新人，17年入前端坑，刚刚两年多工作经验，今年准备跳，面了三十几家了目前，跳到怀疑人生。面试题真的越来越复杂，前端不仅仅只是切个页面调个数据了，底层原理得懂，实现机制得会，node要学，后端算法得懂一些。常常没问两句我就懵了。算了，老老实实学吧！JS基础本来就不扎实。一点点积累吧！三十岁了，也学不动了，边学，边准备回老家考公了。 1.阶乘
function factorialize(num) { if (num &lt; 0) { return -1; } else if (num === 0 || num === 1) { return 1; } else { return (num * factorialize(num - 1)); } } factorialize(5); 参考链接https://www.jianshu.com/p/a967014dbe6e
…………………………………………………………………………………………………………………………………………………………
2.整数反转
需要用到的知识点：
String()和toString()：都是将其他类型的变量转换为字符串类型。
区别：toString()无法转换null和undefined
let a; let b=null; a.toString();//Uncaught TypeError: Cannot read property 'toString' of undefined b.toString(); //Uncaught TypeError: Cannot read property 'toString' of null String(a); //"undefined" String(b);//"null" ————————————————
substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice() 来使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6a1a891e57a4f63ea57b3703cc18b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c7e1bd800888bf0d0f3753a317190c/" rel="bookmark">
			053试题 - 320/321/322/323/324/326/330/332/544/553/585/586/587/588/589/592/596/597/598/599 rman backup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
320.You are using RMAN to backup your ARCHIVELOG mode database. You have enabled control-file
autobackups. Which files are not backed up during the RMAN backup?
A. Database Datafiles
B. Database Control Files
C. Online redo logs
D. Archived redo logs
E. The database SPFILE
F. None of the above, all these files are backed up.
参考答案 C
解析
题目问，rman备份开启了控制文件自动备份。问，对数据库备份的时候，哪一类文件不会备份。
rman不会备份online redo。选择C 。
end
321.True or false: RMAN offers the equivalent of the SQL command alter database backup controlfile to trace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18c7e1bd800888bf0d0f3753a317190c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1145295e8538e4880edb2deac93fea0/" rel="bookmark">
			服务器带宽如何估算和选择?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于大多数的网站站长而言，网站的类型和性质是有所不同的，比如有小说站、论坛站、视频网站以及企业站等，那么相对来说论坛和小说站的访问量会比较大，视频网站的浏览和下载也比较耗用服务器的带宽资源，而普通企业站通常访问量比较少，所以不同的网站所需求的带宽大小也是不同的。
一般正确计算带宽的方法是：每秒钟下载文件的字节数×8/0.7 = 宽带的速率。这前提是你必须先关闭其他正在运行中的网络应用程序，不能同时下载其他网页和软件。
这里也给大家说一下流量和带宽是怎么换算的，带宽:流量=1:150；例如：1M带宽=150M的流量。
下面我们通过一些简单的例子来更深的理解服务器带宽是如何估算的?
1、举例说明，如果你的站是图片网站或者论坛网站，1M带宽就相当于200人左右在线。假如说是下载的话，那么就要看并发连接数目。最后用并发数目除以每个人所占用的带宽。
例如：2400人同时在线，2400人并发同时操作，每个人的页面30KB，那么合算成带宽就是：2400/(30KB*8)=10Mb
2、举例说明，如果你的站是视频或者音频站
例如：网络环境是并发数目是1000，高清视频码率是2Mbps，标清码率是1Mbps。假如：1：2，单节点并发按600计算，那么它的总输出带宽是多少呢？
答：2002+4001=800Mbps
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f660899673936c97a69e96b69a42c93/" rel="bookmark">
			phpstorm 正则匹配删除注释行（替换注释行为空行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用phpstorm 来编写php 和javascript 代码，感觉还是不错的，用得也很舒服。
遇到了一个需求，有时候在阅读框架源代码的时候 ， 想过滤（删除）掉源代码中的注释行，如果手动逐行删除显示不够科学。
当然想到了强大的正则匹配（regExp regular expression）, 通过写一个正则表达式，来查找出所有的注释行，并将其替换成空，即实现了需求。
ctrl + F , 输入正则表达式：(//.$)|(/*(.|\s)?*/)
ctrl + R, 不输入：
点击后面的 Replace all
但发现，这样并没有完全实现我们的需求，只是将注释行替换成了空行。
所以，下面我们再写一个正则表达式， 将空行匹配出来，删掉。
1.ctrl + F, 输入正则表达式： ^\n
2.ctrl + R, 不输入
3.点击后面的 Replace all
但发现，还是并没有全部删掉空行。（还有一些空行没删掉）
所以，我们继续来一个正则匹配删除。
1.ctrl + F, 输入正则表达式： \s\n
2.ctrl + R, 不输入
3.点击后面的 Replace all
好的，到这里，所有的空行全部删除。 开心一下 -?
其实，这三步应该可以合成一步实现的，大家可以想一想！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ec998ab03ea8cf53532b1eec404d70/" rel="bookmark">
			二D图像序列转为3D
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维图像序列转为三维数据格式 要求方法python 代码 要求 图像名称从小到大图像的空间分辨率已知 方法 确定三维图像在xyz轴的大小建立三维矩阵依序读入图像并为相应的三维矩阵赋值用SimpleITK将三维矩阵写入三维数据文件 python 代码 import cv2 import os import SimpleITK import numpy as np PATH_IMAGES = './crop/3/' # 图像序列路径 PATH_RAW = './3D/' # 三维数据存储路径 images_name = sorted(os.listdir(PATH_CROP)) # 图像序列文件名从小到大存为列表 Ref = cv2.imread(os.path.join(PATH_CROP, images_name[0])) dim = (Ref.shape[0], Ref.shape[1], len(images_name)) # 三维数据大小； cv2为yx model = np.zeros(dim) # 三维矩阵 i = 0 for image_name in images_name: image = cv2.imread(os.path.join(PATH_CROP, image_name)) gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) model[:, :, i] = gray i += 1 model = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ec998ab03ea8cf53532b1eec404d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf6c129e1738ffbe02793fabdbeaeacf/" rel="bookmark">
			windows事件三类日志 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows事件三类日志(Security、Application、System
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd73f7ae58fd9ec928314b762cbda9be/" rel="bookmark">
			匿名内部类编译时会不会生成class文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你听说过增量上线吗？我新入公司第一次听说增量上线，所谓增量上线就是把你更改的java文件在本地编译成为.class文件，然后直接将.class文件扔到服务器上面去。这就是问题所在了，我在一个java类里面引用了一个内部类，然后增量上线的时候我只是把这个java类编译的.class文件扔到了服务器上，然后就gg了。报错缺少$..类文件。找了半天才意识到时内部类也生成了一个.class文件，但是我并没有把内部类的.class文件扔上去。所以我回到idea里面去target里面找到主java文件编译生成的.class文件的文件夹路径，发现里面并没有内部类的编译文件。后来以文件管理器打开该路径居然有内部类的.class文件！！！神奇有木有！！！然后将内部类的.class文件扔到服务器上去，问题解决！！！
附录：
匿名内部类编译时会不会生成class文件，下面来验证
我们知道 在一个类里如果有内部类，则编译是会产生两个class文件，一个类class 一个是内部类class，那么匿名内部类会不会也编译出来一个class呢，我们定义一个接口（接口会单独生成一个class），然后匿名生成这个接口的实例，再编译这个类，看看结果如何：
原始类如下：
public class MyClass { private MyInterface myInterface = new MyInterface() { @Override public void onTaskClick() { } }; public interface MyInterface { void onTaskClick(); } } javac 编译后如下：
我们看到生成了一个接口的class文件和 MyClass$1.class文件，这个文件是系统自动为我们起了一个名字 1，也就是说即使我们没有为这个class命名，还是被系统赋予了名字
生成的内部类
classMyClass$1 implements MyClass.MyInterface { MyClass$1(MyClass paramMyClass) {} public void onTaskClick() {} } 结论：匿名内部类编译后会生成class文件，名称是 1、2...数字
如果我们增加接口个数并相应增加匿名内部类，再次编译，则会相应生成 MyClass$2.classMyClass$3.class...等class文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0ba06758b025f9639d43fa56d6b5a8/" rel="bookmark">
			调用接口实现类的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.当要调用接口的实现类时，有2种方法
（1）声明接口，实现类实例化
（2）通过配置文件的方式，用&lt;bean&gt;和&lt;property&gt;两个标签，决定使用接口的那个实现类
2.遇到的问题，别人写好使，我写不好使
（1）使用ssh开发，声明接口
//PeForumCommentService 是接口
private PeForumCommentService peForumCommentService;
public PeForumCommentService getPeForumCommentService() {
return peForumCommentService;
}
public void setPeForumCommentService(PeForumCommentService peForumCommentService) {
this.peForumCommentService = peForumCommentService;
}
（2）调用接口
resultMap=this.getPeForumCommentService().topicCommentDetail(topicId,type,ifTag);
（3）正常这样调用是会报空指针的，因为接口对象是null，但是没有任何反应，应该是框架为了用户友好进行处理了，但是debuge并不会进入到getPeForumCommentService()方法中，当时我考虑到的就是应该去实例化实现类，不使用getPeForumCommentService()方法，果然生效了，但是并不知道为什么通过调用getPeForumCommentService()方式，别人的就好用，而且别人没有进行接口实现类的实例化，最后才发现，实在applicationContext.xml中通过配置&lt;bean&gt;和&lt;property&gt;的方式来使用的（其实也相当于实例化，只不过实在配置文件中处理的，目前不知到这样做到底有什么好处，感觉不但费劲，而且不容易发现问题，我找了将近2天的时间才找到原因）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef530a47d754215d8d73edea15a19f4c/" rel="bookmark">
			java实现二分搜索树BST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package Tree;
import java.awt.image.RescaleOp;
import javax.sound.midi.Soundbank;
/**
* @Title: BST.java
* @Package BinarySerachTree
* @Description: TODO二分搜索树，递归的写法一般具有更高的开销
* @author YEXIN
* @date 2019年8月27日
* @version V1.0
* @Company HUST
*/
/**
*
* @author YEXIN
*二分搜索树必须的类型必须是可比较的，所以E继承Comparable
* @param &lt;E&gt;
*/
public class BST&lt;E extends Comparable&lt;E&gt;&gt; {
//节点类，对用户屏蔽
private class Node{
public E e;//节点的存储元素
public Node left,right;//节点的做孩子和右孩子
public Node(E e) {
this.e = e;
left = null;
right = null;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef530a47d754215d8d73edea15a19f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83af7027585035758d225d957fc8f097/" rel="bookmark">
			HBase 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文只涉及最基础的概念，做个记录
基础概念 Namespace namespace类似mysql的database,一个namespace含有多个table。
Table Hbase表包含许多的行(Row)
Row HBase的一行包含一个row key和一或多个其它列。HBase中Row会根据Row Key按照字典序排序。Row Key在表中会被作为索引。
Column 在HBase中，一列由column family和column qualifier组成，以 cf:cq形式展示。
Column Family (cf) Column Family包含若干Column。例如列cf1:a,cf1:b，它们都属于cf1。
Column Qualifier (cq) cq用来精确到某个列，cf描述了列族，cf:cq表示具体的一个列。
Cell cell由{row, column, version} 组成，timestamp用来表示version。HBase支持保留历史版本数据，可以根据version查询数据。
在HBase中，只有有数据的cell会被存储，所以它和常见的RDBMS不同，在mysql中，即使某一行的某一列的数据为空，这一列还是存在于mysql，只是它的值是空。
Timestamp HBase存储的每个值都带有时间戳，用来表示版本号。
基础的数据库操作 Get; 返回一行数据;Put; 插入或更新，类似upsert操作;Scans; 可以指定需要的列，获取多行数据;Delete; HBase的删除不会直接移除数据，而是对数据添加标签tombstones(墓碑标签)，在compactions时，对于墓碑标签的数据，会对其进行清理。(感觉类似kafka tombstones message) 参考文档: https://hbase.apache.org/book.html#datamodelhttps://www.jianshu.com/p/6aeceb5d49cf 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b85b3111ba47d4802dbef3e17dcfc3/" rel="bookmark">
			Spring 复习总结（一）——spring的简单配置使用 IOC控制翻转创建类对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 导入jar包 在官网下载spring相应版本的压缩文件，解压后的文件夹下有几个文件夹目录，进入libs目录下
里面都是jar包
里面的jar包分三种：
1、源码编译后的 class 文件 jar 包
2、文档包 -javadoc 结尾，在我们使用 jar 包内的类或者方法时都会有详细的解释和介绍
3、源码包 -sources 结尾，对类使用CTRL + 左键 能进入看到 Java 源码
但是注意：我们 jar 包先导编译后的 class jar包，如果导入的是其他两种jar包会出现无法使用类的情况，jar文档和源码包是在导入编译后jar包之后在追加导入的，导入方法详情请移步另一博主文章：https://blog.csdn.net/u013761606/article/details/32344061
一般最基础spring我们只需要导入四个jar包：
spring-beans-4.3.25.RELEASE.jar 、 spring-context-4.3.25.RELEASE.jar 、 spring-core-4.3.25.RELEASE.jar 、 spring-expression-4.3.25.RELEASE.jar
和一个依赖jar包：commons-logging-1.3.jar （这个包在网上百度一下就能找到下载）
2 写一个javabean 或者 操作类 在这里我就随便建了一个User类，里面给上属性和get set 方法，以及一个add（）操作测试方法，内容只是简单的输出
User类代码如下：
public class User {
private String UID;
private String username;
private String password;
public User() {}
public User(String uID, String username, String password) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b85b3111ba47d4802dbef3e17dcfc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c90115d33622a2afd14121994423d8/" rel="bookmark">
			Spring 与JMX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JMX Spring对DI的支持是通过在应用中配置bean属性，这是一种非常不错的方法。不过，一旦应用已经部署并且正在运行，单独使用DI并不能帮助我们改变应用的配置。假设我们希望深入了解正在运行的应用并要在运行时改变应用的配置，此时，就可以使用Java管理扩展（JavaManage- ment Extensions，JMX）了。
JMX这项技术能够让我们管理、监视和配置应用。这项技术最初作为Java的独立扩展，从Java 5开始，JMX已经成为标准的组件。
使用JMX管理应用的核心组件是托管bean（managed bean，MBean）。所谓的MBean就是暴露特定方法的JavaBean，这些方法定义了管理接口。JMX规范定义了如下4种类型的MBean：
标准MBean：标准MBean的管理接口是通过在固定的接口上执行反射确定的，bean类会实现这个接口；动态MBean：动态MBean的管理接口是在运行时通过调用DynamicMBean接口的方法来确定的。因为管理接口不是通过静态接口定义的，因此可以在运行时改变；开放MBean：开放MBean是一种特殊的动态MBean，其属性和方法只限定于原始类型、原始类型的包装类以及可以分解为原始类型或原始类型包装类的任意类型；模型MBean：模型MBean也是一种特殊的动态MBean，用于充当管理接口与受管资源的中介。模型Bean并不像它们所声明的那样来编写。它们通常通过工厂生成，工厂会使用元信息来组装管理接口。
Spring的JMX模块可以让我们将Spring bean导出为模型MBean，这样我们就可以查看应用程序的内部情况并且能够更改配置——甚至在应用的运行期。
二、将Spring bean导出为MBean Spring的MBeanExporter是将Spring Bean转变为MBean的关键。MBeanExporter可以把一个或多个Spring bean导出为MBean服务器（MBean server）内的模型 MBean。MBean服务器（有时候也被称为MBean代理）是MBean生存的容器。对MBean的访问，也是通过MBean服务器来实现的。
如图所示，将Spring bean导出为JMX MBean之后，可以使用基于JMX的管理工具（例如JConsole或者VisualVM）查看正在运行的应用程序，显示bean的属性并调用bean的方法。
下面的@Bean方法在Spring中声明了一个MBeanExporter，它会将spittleControllerbean导出为一个模型MBean：
配置MBeanExporter的最简单方式是为它的beans属性配置一个Map集合，该集合中的元素是我们希望暴露为JMX MBean的一个或多个bean。每个Map条目的key就是MBean的名称（由管理域的名字和一个key-value对组成，在SpittleController MBean示例中是spitter:name=HomeController），而Map条目的值则是需要暴露的Spring bean引用。在这里，我们将输出spittleControllerbean，以便它的属性可以通过JMX在运行时进行管理。
通过MBeanExporter，spittleControllerbean将作为模型MBean以SpittleController的名称导出到MBean服务器中，以实现管理功能。下图展示了通过JConsole查看SpittleControllerMBean时的情况。
SpittleController所有的public成员都被导出为MBean的操作或属性。这可能并不是我们所希望看到的结果，我们真正需要的只是可以配置spittlesPerPage属性。我们不需要调用spittles()方法或SpittleController中的其他方法或属性。因此，我们需要一个方式来筛选所需要的属性或方法。
MBean服务器从何处而来
根据以上配置，MBeanExporter会假设它正在一个应用服务器中（例如Tomcat）或提供MBean服务器的其他上下文中运行。但是，如果Spring应用程序是独立的应用或运行的容器没有提供MBean服务器，我们就需要在Spring上下文中配置一个MBean服务器。
在XML配置中，&lt;context:mbean-server&gt;元素可以为我们实现该功能。如果使用Java配置的话，我们需要更直接的方式，也就是配置类型为MBeanServerFactoryBean的bean（这也是在XML中&lt;context:mbean-server&gt;元素所作的事情）。
MBeanServerFactoryBean会创建一个MBean服务器，并将其作为Spring应用上下文中的bean。默认情况下，这个bean的ID是mbeanServer。了解到这一点，我们就可以将它装配到MBeanExporter的server属性中用来指定MBean要暴露到哪个MBean服务器中。
2.1 通过名称暴露方法
MBean信息装配器（MBean info assembler）是限制哪些方法和属性将在MBean上暴露的关键。其中有一个MBean信息装配器是MethodNameBasedMBean-InfoAssembler。这个装配器指定了需要暴露为MBean操作的方法名称列表。
managedMethods属性可以接受一个方法名称的列表，指定了哪些方法将暴露为MBean的操作。
另一个基于方法名称的装配器是MethodExclusionMBeanInfoAssembler。这个MBean信息装
配器是MethodNameBaseMBeanInfoAssembler的反操作。它不是指定哪些方法需要暴露为MBean的托管操作，MethodExclusionMBeanInfoAssembler指定了不需要暴露为MBean托管操作的方法名称列表
2.1 使用接口定义MBean的操作和属性
Spring的InterfaceBasedMBeanInfoAssembler是另一种MBean信息装配器，可以让我们通过使用接口来选择bean的哪些方法需要暴露为MBean的托管操作。InterfaceBasedMBeanInfoAssembler与基于方法名称的装配器很相似，只不过不再通过罗列方法名称来确定暴露哪些方法，而是通过列出接口来声明哪些方法需要暴露。
例如，假设我们定义了一个名为SpittleControllerManagedOperations的接口，如下所
示：
在这里，我们选择了setSpittlesPerPage()方法和getSpittlesPerPage()方法作为需要暴露的方法。再次提醒，这一对存取器方法间接暴露了spittlesPerPage属性作为MBean的托管属性。为了应用此装配器，我们只需要使用如下的assemblerbean替换之前基于方法名称的装配器即可：
2.3 使用注解驱动的MBean
Spring context配置命名空间中的&lt;context:mbean-export&gt;元素。这个便捷的元素装配了MBean导出器以及为了在Spring启用注解驱动的MBean所需要的装配器。我们所需要做的就是使用它来替换我们之前所使用的MBeanExporterbean:
现在，要把任意一个Spring bean转变为MBean，我们所需要做的仅仅是使用@ManagedResource注解标注bean并使用@ManagedOperation或@ManagedAttribute注解标注bean的方法。例如，如下的程序清单展示了如何使用注解把SpittleController导出为MBean。
在类级别使用了@ManagedResource注解来标识这个bean应该被导出为MBean。objectName属性标识了域（Spitter）和MBean的名称（SpittleController）。
们还可以使用@ManagedOperation注解替换@ManagedAttribute注解来标注存取器方法。如下所示：
2.4 处理MBean冲突
如果MBean服务器中不存在与我们MBean名字相同的已注册的MBean，那我们的MBean注册时就不会有任何问题。但是如果名字冲突时，将会发生什么呢？
默认情况下，MBeanExporter将抛出InstanceAlreadyExistsException异常，该异常表明MBean服务器中已经存在相同名字的MBean。不过，我们可以通过MBeanExporter的registrationBehaviorName属性或者&lt;context:mbean-export&gt;的registration属性指定冲突处理机制来改变默认行为。
Spring提供了3种借助registrationBehaviorName属性来处理MBean名字冲突的机制：
FAIL_ON_EXISTING：如果已存在相同名字的MBean，则失败（默认行为）；IGNORE_EXISTING：忽略冲突，同时也不注册新的MBean；REPLACING_EXISTING：用新的MBean覆盖已存在的MBean； 例如，如果我们使用MBeanExporter，我们可以通过设置registration-BehaviorName属性为RegistrationPolicy.IGNORE_EXISTING来忽略冲突，如下所示：
registrationBehaviorName属性可以接受RegistrationPolicy中所定义的枚举值，每一个取值分别对应3种冲突处理机制的一种。
三、远程MBean 3.1 暴露远程MBean
3.2 访问远程MBean
要想访问远程MBean服务器，我们需要在Spring上下文中配MbeanServerConnectionFactoryBean。下面的bean声明装配了一个MbeanServerConnectionFactoryBean，
顾名思义，MBeanServerConnectionFactoryBean是一个可用于创建MbeanServer-Connection的工厂bean。由MBeanServerConnectionFactoryBean所生成的MBeanServerConnection实际上是作为远程MBean服务器的本地代理。它能够以MBeanServerConnection的形式注入到其他bean的属性中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c90115d33622a2afd14121994423d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9bd18798d59b82ccbb01afa7d6d7d45/" rel="bookmark">
			Java实现HTTP请求GET和POST之HTTPClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文中使用的jar包有：commons-codec-1.9、commons-logging-1.2、httpclient-4.5.9、httpcore-4.4.11、httpmime-4.5.9
相关jar包下载可以直接去官网下载HTTPCLIENT的包
文中相关头信息写的不多，可以去上一篇文章“Java实现HTTP请求GET和POST之HttpURLConnection”中看
文中一些代码也是网上东摘西录的，这里仅作为一个模板思路参考，功能并不复杂
一、GET请求
public static void sumitGet() { //创建httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); //创建httpGet对象 HttpGet httpGet = new HttpGet("https://www.baidu.com"); System.out.println("executing request " + httpGet.getURI()); //设置头信息 httpGet.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36"); CloseableHttpResponse response = null; try { //执行Get请求 response = httpClient.execute(httpGet); //获取返回的全部头信息 Header headers[] = response.getAllHeaders(); //获取响应实体 HttpEntity entity = response.getEntity(); System.out.println(response.getStatusLine()); //处理响应实体 if(entity != null) { System.out.println("长度：" + entity.getContentLength()); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9bd18798d59b82ccbb01afa7d6d7d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3a74f79c30648f4dd32acc3f84cd09/" rel="bookmark">
			cocos2d图片资源解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在提取某游戏的资源时，发现资源文件是加密的
根据经验和查找资料，cocos2dx的图片资源加载, 是在Image::initWithImageData(const unsigned char * data, ssize_t dataLen) 函数；打开libcocos2djs.so，搜索这个函数可以看到解密就在这个地方
可以看到，通过判断加密后png和jpg文件的前三个字节来进行是否解密。
将解密的代码自己用代码实现，即可解密所有资源。
如下是Java实现的解密代码:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667f6fb68fc16e3749539a71072479f3/" rel="bookmark">
			JS复制自定义内容到粘贴板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：开发过程碰到需要点击一个按钮复制当前模块的链接地址
思路：给当前模块附上链接，然后点击复制
function copyValue(val){ //如果这里换为 input 则不支持换行 var temp = document.createElement('textarea'); temp.value = val; document.body.appendChild(temp); temp.select(); // 选择对象 document.execCommand("Copy"); // 执行浏览器复制命令 temp.style.display='none'; alert("复制图片链接成功！"); } $('.copyLink').click(function() { copyValue($(this).attr('linkUrl')); }); 感谢：https://www.cnblogs.com/yuxiaole/p/9301076.html
转载于:https://www.cnblogs.com/dzw159/p/11419296.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bcff80151158816ba016164546238ac/" rel="bookmark">
			Android NativeCrypto: AppData::create pipe(2) failed: Too many open files崩溃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Retrofit和OkHttpClient多实例+添加头部SharePreferences，进行频繁操作网络请求一段时间程序卡死崩溃问题的一些经历记录
一、bug复现： viewpager+FragmentStatePagerAdapter+fragment+MVP，不断滑动翻页并频繁进行网络请求导致卡死。
二、原因猜测&amp;修复尝试： 1.bug出现后第一感觉认为是fragment重复创建导致内存泄漏，然后尝试了viewpager的setOffsceenPageLimit设置，也尝试了viewpager中getItem使用fragment.newInstance()的方式创建fragment。然而崩溃还是一样存在！
2.之后以为是mvp中presenter强引用导致的内存泄漏，尝试将BasePresenter中的view引用改为WeakReference弱引用，将BasePresenter中的状态做了优化，创建初始化、销毁前属性对象等都反初始化，结果还是没解决。
3.最后根据报错的日志判断是我封装的MVP网络请求库内出了问题，报错如下：
2019-08-26 15:12:38.709 31527-31659/com.xxx E/NativeCrypto: AppData::create pipe(2) failed: Too many open files 2019-08-26 15:12:38.710 31527-31527/com.xxx D/DareLove-XObserver: │ onError()	function : dynamic/xxx request error, reason : socket already closed 2019-08-26 15:12:38.710 31527-31527/com.xxx D/DareLove-XObserver: │ onError()	function : dynamic/xxx request error, reason : javax.net.ssl.SSLException: Unable to create application data 2019-08-26 15:12:38.899 31527-31537/com.xxx E/System: Uncaught exception thrown by finalizer 2019-08-26 15:12:38.900 31527-31537/com.xxx E/System: java.net.SocketException: socket already closed at java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bcff80151158816ba016164546238ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3e800527a0fc56b9000be780c2cec87/" rel="bookmark">
			通过Anaconda安装Python时安装路径错误，提示&#34;XX is not empty ,please choose a different location.&#34;问题的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Python时出现如下提示
重新选择路径，选择D盘（因本人安装在D盘），然后手动输入Anaconda，即可正常安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e6e7c11b4477e339d9adcbd3137b39/" rel="bookmark">
			UEditor图片上传至服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 去UEditor官网下载需要的版本（https://ueditor.baidu.com/website/download.html）；
2 关于图片上传大体需要4个步骤；
2.1 修改ueditor.config.js配置文件，主要是修改后台请求地址；
window.UEDITOR_CONFIG = { //为编辑器实例添加一个路径，这个不能被注释 UEDITOR_HOME_URL: URL ,imageUrl:URL+"jsp?imageUp.jsp" ,imagePath:URL+"jsp" // 服务器统一请求接口路径，根据你后端存放的具体位置设置 , serverUrl: "http://localhost:8181/bpeClean/plug-in/ueditor/jsp/controller.jsp" 2.2 修改后台配置文件config.json
这里的controller.jsp即是刚才请求的处理接口；lib文件夹下是依赖的jar包；
config文件主要修改两个参数；
2.2.1 修改文件的相对路径：imagePathFormat
2.2.2 修改访问文件的前缀：imageUrlPrefix；
所以图片的实际访问地址是：imageUrlPrefix+imagePathFormat；
2.3 修改后台接口controller.jsp
这里是根据ueditor 自己默认的处理方式，当然也可以修改成自己需要的逻辑；还有一点就是，此处的方法可能根据jar包版本不同，参数略有不同，需根据实际情况调整；其中rootPath是当前项目的绝对地址。
默认上传的图片会放在这个位置（如果修改了imagePathFormat参数，这里就是imagePathFormat的修改后的位置）：
2.4 前端页面也是需要稍微修改一下的；
上传文件的按钮；
2.5 当然也支持直接复制文件到编辑框进行粘贴操作；
上传图片实际请求的的后台接口：
2.6 有一点需要注意的是，如果是项目是前后端分离的话，需要考虑跨域的情况；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedc4efc6f371fb0c263c734f1a7dfdb/" rel="bookmark">
			微分算子法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强行假设D是可逆的，
Dx^3 = 3x^2 -&gt; x^3 = D^(-1）*(3x^2) , 所以1/D表示积分
注意到D(exp(ax)) = aD(exp(ax)) ， 所以exp(ax)是D的特征向量，a是特征值，根据特征值的性质，有如下性质
这个定理的证明 D(exp(ax)v(x)) = Dv(x) exp(ax) + D(v(x)) a(exp(ax)) = (D+a)(v(x)exp(ax)) 这就是移位定理
遇到特征
出现exp(ax)x需要使用移位
三角函数用复数运算化为指数形式
虚根分子为0，同样求导。速算。
无穷级数运算，可能出错。
指数和x，先移位，在对x用算子运算。复数移位算法，分解， 1/D *（D+2i）, 先作用 1/(D+2i) = 1/2i*(D/2i+1) = 1/2i +1/4D
这里复数移位展开略麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6da69f17f7b1b1eda48601bae55694d/" rel="bookmark">
			CookieJar下载并使用cookies
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面写过一篇《requests下载并使用cookies》，除了用requests，用http.cookiejar同样能实现，不过步骤繁琐很多，用http.cookiejar首先需要创建一个cookiejar对象，然后再用cookiejar创建一个handler，再在handler中创建一个opener，最后在opener中传递帐号密码，获取cookies信息。
下面主要介绍两种使用方法，一种是直接获取cookies信息然后获取目标网页信息；一种是先将cookies信息下载，再加载cookies信息并获取目标网页信息。下面直接用人人网举例说明。
一、直接获取cookies信息然后获取目标网页信息 简单来说分来两步完成，先登录并获取cookies信息，再用带cookies信息的opener获取目标页面信息
from urllib import request,parse from http.cookiejar import CookieJar #1、登录 #1.1、创建一个cookiejar对象 cookiejar = CookieJar() #1.2、使用cookiejar创建一个HTTPCookieProcessor对象 handler = request.HTTPCookieProcessor(cookiejar) #1.3、使用上一步创建的Handler创建一个opener opener = request.build_opener(handler) #1.4、使用opener发送登录请求（邮箱密码） headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } data = { 'email':"你的帐号", 'password':'你的密码' } login_url = 'http://www.renren.com/PLogin.do'#登录的网址 req = request.Request(login_url,headers = headers,data=parse.urlencode(data).encode('utf-8')) opener.open(req) #2、访问个人主页 dapeng_url = 'http://www.renren.com/880151247/profile'#爬取的网址 #获取个人主页页面的时候，不要新建一个opener #应该要用上一步的那个opener，因为之前那个opener包含了登录所需要的cookie信息 req = request.Request(dapeng_url,headers=headers) resp = opener.open(req) with open('renren.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6da69f17f7b1b1eda48601bae55694d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d882c0584448fed4e1b64d4ae2d46334/" rel="bookmark">
			spring boot XSS 攻击 富文本框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2个类
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import org.apache.commons.lang3.StringEscapeUtils;
public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {
public XssHttpServletRequestWrapper(HttpServletRequest request) {
super(request);
}
public String[] getParameterValues(String parameter) {
String[] values = super.getParameterValues(parameter);
if (values == null) {
return null;
}
int count = values.length;
String[] encodedValues = new String[count];
for (int i = 0; i &lt; count; i++) {
encodedValues[i] = cleanXSS(values[i]);
}
return encodedValues;
}
public String getParameter(String parameter) {
String value = super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d882c0584448fed4e1b64d4ae2d46334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1fdef1b42db6d3fc6f7529cd20f42d/" rel="bookmark">
			【写法】三目运算符的写法简化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		===============================================
2019/8/27_第1次修改 ccb_warlock
===============================================
写这篇文章的起源是最近引入了resharp，在写三目运算符的逻辑时提示了可优化的内容，琢磨了一下就有了下面的内容。
举例，假设User实体定义如下：
public class User { public string UserName { get; set; } public string Password { get; set; } public int OrderIndex { get; set; } } 业务场景：创建新的用户记录时，需要获取新的数据号自增1（OrderIndex ），初始从1开始自增。
一般的写法：
var LastUser = getMaxOrderIndexUser(); var NewOrderIndex = LastUser == null ? 1 : LastUser.OrderIndex + 1; 这里提供一种简化写法：
var LastUser = getMaxOrderIndexUser(); var NewOrderIndex = (LastUser?.OrderIndex ?? 0) + 1; 转载于:https://www.cnblogs.com/straycats/p/11415917.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b541ff5f4d3598d9acea717cc9deadb7/" rel="bookmark">
			ASP.NET Core 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.NET Core 是 .NET Framework 的新一代版本，是微软开发的第一个具有跨平台 ( Windows、Mac OSX 、Linux ) 能力的应用程序开发框
ASP.NET Core 是 Microsoft 新开发的，基于 .NET Core 的 Web 开发框架
ASP.NET Core 是对 ASP.NET 的重新设计，变得快速，灵活，现代，并且可以跨不同平台工作。
如果你之前已经接触过 ASP.NET，有过任何 MVC 或 Web API 的经验，那么你会有很强烈的熟悉感。
在本教程中，我们将会学习如何使用 ASP.NET Core 开发网页应用程序， 创建、编辑和查看数据库中的所有数据
ASP.NET 简史 ASP.NET 设计之初，就为 Web 而生，也自那时起，该框架经历了一个稳步的演变，并最终将我们引导至其最新的 ASP.NET Core 2.1 版本
ASP.NET 的演变史，其实就是一部 Web 框架的演变史的完全版，也是过去这么多年互联网的发展史
ASP.NET Core 2.1 不是 ASP.NET 4.x 的延续，或者这么说， ASP.NET Core 1.0 不是 ASP.NET 4.6 的延续
ASP.NET Core 是一个全新的 Web 框架，它与 ASP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b541ff5f4d3598d9acea717cc9deadb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/419898d843ff774ff93a006593343185/" rel="bookmark">
			超市购物小票案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超市购物小票案例 1.1超市购物小票需求分析 模拟真实购物逻辑，以上述图片为需求原型，根据不同购买物品，完成购物小票内容打印到控制台。(简化项目逻辑，票脚部分只完成数据统计)
数据：
将超市购物小票案例中零散数据(名称、货号、单价、数量、计价单位、金额)封装为货物对象所有的货物对象放置到集合中统一管理。 逻辑：
用户循环进行三个操作：
输入购买数量，代表为所购买货物的数量赋值，从而计算每项商品金额打印小票，将已有数据打印退出系统(因为该程序为循环操作，无法终止，如果不想再进行操作，则退出系统) 1.2超市购物小票知识点分析 复习知识点:
变量定义：记录部分数据
集合的使用：用于存储多个完整数据
运算符的使用：计算变量
流程控制语句的使用：
if语句：用于判断是否购买了商品
switch语句：用于进行三个操作(输入购买数量、打印小票、退出系统)的分支
for语句：switch外部使用for循环，当执行一个操作后，继续进行下一个操 作选择
方法封装：
由于代码量比较多，可以将输入购买数量、打印小票封装为方法使用
字符串/键盘录入：
打印小票完整过程均为字符串的拼写及打印，数量输入为键盘录入Scanner 完成
步骤:
定义GoodsItem类(名称,货号,单价,数量,计价单位,金额)
成员位置定义集合，定义方法向集合中存储所有GoodsItem数据
实现主干逻辑
打印欢迎语句
使用for/while进行循环进行操作
使用switch给出操作选择：1输入购买数量2打印小票3退出
完成switch中三个case的逻辑
运用方法封装功能：将1输入购买数量、2打印小票封装为独立方法，在case中 调用，提高代码可读性。
1.3超市购物小票商品项类的定义 商品项类，将要购买的商品封装到一个GoodItems类中,编码如下:
package com.igeek_03; /** * @ClassName: GoodsItem * @Description: 商品项类 * @date 2017年11月13日 上午10:41:21 * Company www.igeekhome.com * * 定义商品项类: * 名称,货号,单价,数量,计价单位,金额 * */ public class GoodsItem { // 成员变量 /** * @Fields name : 名称 */ private String name; /** * @Fields id : 货号 */ private String id; /** * @Fields price : 单价 */ private double price; /** * @Fields number : 数量 */ private int number; /** * @Fields unit : 计价单位 */ private String unit; /** * @Fields money : 金额 */ private double money; // 构造方法 /** * @Title: GoodsItem */ public GoodsItem() { } /** * @Title: GoodsItem * @param name * @param id * @param price * @param number * @param unit * @param money */ public GoodsItem(String name, String id, double price, int number, String unit, double money) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/419898d843ff774ff93a006593343185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc2c92d07f32fe1a33bef7053c4a6cc/" rel="bookmark">
			js文件中引入js的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一，在调用文件的顶部加入下例代码 document.createElement("script").setAttribute("src", "render.js"); 注：有时你引用的文件还可能需要引用其他的js,我们需要将需要的那个js文件也以同样的方法引用进来。
方法二，在调用文件的顶部加入下例代码 function addScript(url){ document.write("&lt;script language=javascript src="+url+"&gt;&lt;/script&gt;"); } 注：有时你引用的文件还可能需要引用其他的js,我们需要将需要的那个js文件也以同样的方法引用进来。
方法三，在js中写如下代码： function addScript(url){ var script = document.createElement('script'); script.setAttribute('type','text/javascript'); script.setAttribute('src',url); document.getElementsByTagName('head')[0].appendChild(script); } 利用document.createElement(”script”)生成了一个script的标签，设置其 type属性为text/javascript。
方法四，利用es6中export和import实现模块化 一个js文件代表一个js模块 。ES6引入外部模块分两种情况：
1.导入外部的变量或函数等；
import {firstName, lastName} from './test'; 2.导入外部的模块，并立即执行
import './test' //执行test.js，但不导入任何变量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d93b6d956d297ed4c820fcb0cd7a424/" rel="bookmark">
			Python 中的类对象和实例对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 类对象： 就是类本身实例对象： 由类实例化出来的对象 In [1]: class Person(object): ...: def __init__(self): ...: pass ...: In [2]: print(Person) &lt;class '__main__.Person'&gt; In [3]: p1 = Person() In [4]: print(p1) &lt;__main__.Person object at 0x0000022E52AB0D30&gt; 上面的 Person 就是类对象，而 p1 则是这个类的实例对象 类对象的使用 类对象支持两种操作：属性引用和实例化。 In [5]: class Person(object): ...: name = "xxx" ...: age = 20 ...: ...: def __init__(self): ...: pass ...: In [6]: Person.name Out[6]: 'xxx' In [7]: Person.age Out[7]: 20 In [8]: p1 = Person() In [9]: print(p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d93b6d956d297ed4c820fcb0cd7a424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee397bec88e002110c1ace793f460fff/" rel="bookmark">
			SpringBoot两种开启方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot开启方式一： 承继spring-boot-starter-parent项目：
SpringBoot开启方式二： 导入spring-boot-dependencies项目依赖
两种开启方式的覆盖方法 继承的方式：直接修改所需要覆盖组件的版本
导入的方式：在导入之前加入需要覆盖的版本信息：
修改组建版本容易造成不兼容问题
如发现代码相同，对，是我参考了你的文章
参考文链接
https://blog.csdn.net/zl1zl2zl3/article/details/83715712
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0735da837057b7ef0a89d74383984b64/" rel="bookmark">
			【高数】收敛关系：级数与部分和、级数与数列、数列与子数列、级数与子级数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概念理解
1. 级数是什么？
二、区别与联系
1. 级数、部分和
2. 级数收敛、数列收敛
3. 数列收敛、子数列收敛
4. 级数收敛、子级数收敛
三、小结
一、概念理解 1. 级数是什么？ 疑问：级数是无穷数列的和，那为什么还有部分和，为什么还有级数的和，难道是和的和？
《高等数学》同济七版：是从圆的面积引出。求圆的面积是一个由近似到精确的过程，不断地切分出小块面积加到原来的面积中，最终趋向于一个数值。这就是级数的和。
《高数18讲》：我们把无穷数列的各项用“+”连接起来得到的记号叫做无穷级数，也就是下式左侧。
二、区别与联系 1. 级数、部分和 （1）为什么要引入部分和？
形式上是无穷项的相加求和，但实际是不可操作的，因为无穷多，所以不可能一一相加求得，必须借助极限的工具研究。所以引入了部分和数列，也就是 n=1 的和，n≤2 的和......直到 n→∞时，观察有限项的和的变化趋势，来研究部分和的数列是否存在极限，也即是级数的和是否存在。所以级数是个记号，表示的是一个和，但需要通过研究部分和的极限是否存在，来看级数是否收敛，也就是这个无穷多项的和是否存在。
（2）级数与部分和的区别？
级数是无穷多项的和。部分和，是指将级数中的前多少项（一部分项）拿出来，组成一个新的数列。
级数的和，可以理解为n→∞级数的部分和。
2. 级数收敛、数列收敛 级数 ∑an 收敛，指部分和数列的极限存在， lim(n→∞) Sn = s 存在。此时，必然有 lim(n→∞) an =0（级数收敛的必要条件）。数列 {an} 收敛，指级数通项的极限存在， lim(n→∞) an = a 存在。级数收敛，可推出对应通项的数列必然收敛；数列收敛，未必其和就收敛。 3. 数列收敛、子数列收敛 《高等数学》：数列收敛，充要条件是任意子数列都收敛。
《收敛数列的两点注记》：https://www.ixueshu.com/document/16fb6a84a74c9cb9318947a18e7f9386.html
【定理1】收敛数列lim(n→∞) an = a，其任意子数列均收敛，且均收敛于 a 。【推论】若奇子列、偶子列均收敛，且均收敛于 a，那么原数列收敛于 a。定理2没看懂…… 若奇子列、偶子列均收敛，但极限不等，则原数列发散。 《一个数列收敛性质的应用和推广》：http://www.doc88.com/p-3406764084757.html
证明了“为什么通过奇子列、偶子列收敛于同一值，可以推出数列收敛”。
《独立和子序列的完全收敛性》：https://www.ixueshu.com/document/cdbfa42ffa2bfb84318947a18e7f9386.html
（基本上是用数学符号表达的，完全没看懂。先放个链接。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0735da837057b7ef0a89d74383984b64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff0360367fa8377444d51e6fa4bccd35/" rel="bookmark">
			Mac系统中桌面图片和用户头像图片的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统中的桌面图片：
/Library/Desktop Pictures/ 用户头像图片：
根目录资源库/user pictures/ 参考：
【https://bbs.feng.com/read-htm-tid-1538536.html】
【https://www.macx.cn/thread-2121643-1-12.html】
转载于:https://www.cnblogs.com/cchHers/p/11411903.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee92c0a3f98e16981872bffc9257e9b/" rel="bookmark">
			justify-content与align-items解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 justify-content justify-content是flex布局中的一个属性，用来调整container中的items布局
flex-start (default): 每个item从起点开始依次排布flex-end: 每个item从尾部开始依次向起点排布center: items沿中心排布space-between: items从左到右依次排布，第一个item在起点，最后一个item在终点space-around: items从左到右间隔相同距离排布space-evenly: items从左到右任意连个相邻item的距离与第一个item距起点的距离以及最后一个item距终点的距离都相等 从上到下效果如图：
align-items align-item与justify-content相似，也具有多个属性值
flex-start: 每个item上边缘沿着container的上边缘线分布flex-end: 每个item下边缘沿着container的下边缘线分布center: 每个item沿着container的水平中心线分布baseline: 每个item沿着它们的基准线分布stretch (default): 每个item延长自己至与container等高分布 从上到下效果如图
注意当flex-direction: colum时，注意方向的变化 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86546ccbde684b596ae4b650538c0f1e/" rel="bookmark">
			Dom节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Dom是Document Object Model（文档对象模型）的缩写
在HTML DOM中HTML文档中所有内容都被视为节点，DOM被视为节点树的HTML。
节点分为父节点子节点和同胞，一个文档中可以有多个父节点和子节点
&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM 结构&lt;/title&gt; &lt;/head? &lt;body&gt; &lt;h1&gt;DOM 结构&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 从上面代码可以看出&lt;html&gt;&lt;/html&gt;有二个子节点分别是&lt;head&gt;和&lt;body&gt;
&lt;html&gt;为根节点，它没有父节点,它有两个子元素节点&lt;head&gt;、&lt;body&gt; &lt;head&gt;有一个子元素节点&lt;title&gt;，&lt;body&gt;有两个子元素节点&lt;h1&gt;、&lt;p&gt; &lt;title&gt;有一个子文本节点：“DOM结构”，类似&lt;h1&gt;和&lt;p&gt;也有一个子文本节点 &lt;h1&gt;和&lt;p&gt;为同胞节点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5735f41c1b5390548e65508258b1687c/" rel="bookmark">
			历届研究生数学建模赛题汇总（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一下内容转自知乎作者Gan Phua，如有侵权，联系删除。
原文链接如下：https://zhuanlan.zhihu.com/p/45798920?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=980468971551719424
本文资源来自数模知识库、数模中国.
2018赛题汇总 2018-A ：关于跳台跳水体型系数设置的建模分析
2018-B：光传送网建模与价值评估
2018-C：对恐怖袭击事件记录数据的量化分析
2018-D：基于卫星高度计海面高度异常资料获取潮汐调和常数方法及应用
2018-E：多无人机对组网雷达的协同干扰
2018-F：机场新增卫星厅对中转旅客影响的评估方法
2017赛题汇总 2017-A：无人机在抢险救灾中的优化运用
2017-B：面向下一代光通信的VCSEL激光器仿真模型 （华为命题）
2017-C：航班恢复问题
2017-D：基于监控视频的前景目标提取
2017-E：多波次导弹发射中的规划问题
2017-F：构建地下物流系统网络
2016赛题汇总 2016-A：多无人机协同任务规划
2016-B：具有遗传性疾病和性状的遗传位点分析
2016-C：基于无线通信基站的室内三维定位问题
2016-D：军事行动避空侦察的时机和路线选择
2016-E：粮食最低收购价政策问题研究
2015赛题汇总 2015-A：水面舰艇编队防空和信息化战争评估模型
2015-B：数据的多流形结构分析
2015-C：移动通信中的无线信道“指纹”特征建模
2015-D：面向节能的单/多列车优化决策问题
2015-E：数控加工刀具运动的优化控制
2015-F：旅游路线规划问题
2014赛题汇总 2014-A：小鼠视觉感受区电位信号（LFP）与视觉刺激之间的关系研究
2014-B：机动目标的跟踪与反跟踪
2014-C：无线通信中的快时变信道建模
2014-D：人体营养健康角度的中国果蔬发展战略研究
2014-E：乘用车物流运输计划问题
2013赛题汇总 2013-A：变循环发动机部件法建模及优化
2013-B：功率放大器非线性特性及预失真建模
2013-C：微蜂窝环境中无线接收信号的特性分析
2013-D：空气中PM2.5问题的研究
2013-E：中等收入定位与人口度量模型研究
2013-F：可持续的中国城乡居民养老保险体系的数学模型研究
2012赛题汇总 2012-A：基因识别问题及其算法实现
2012-B：基于卫星无源探测的空间飞行器主动段轨道估计与误差分析
2012-C：有杆抽油系统的数学建模及诊断
2012-D：基于卫星云图的风矢场（云导风）度量模型与算法探讨
2011赛题汇总 2011-A：基于光的波粒二象性一种猜想的数学仿真
2011-B：吸波材料与微波暗室问题的数学建模
2011-C：小麦发育后期茎秆抗倒性的数学模型
2011-D：房地产行业的数学建模
2010赛题汇总 2010-A：确定肿瘤的重要基因信息
2010-B：与封堵溃口有关的重物落水后运动过程的数学建模
2010-C：神经元的形态分类和识别
2010-D：特殊工件磨削加工的数学建模
2009赛题汇总 2009-A：我国就业人数或城镇登记失业率的数学建模
2009-B：枪弹头痕迹自动比对方法的研究
2009-C：多传感器数据融合与航迹预测
2009-D：110警车配置及巡逻方案
2008赛题汇总 2008-A：汶川地震中唐家山堰塞湖泄洪问题
2008-B：城市道路交通信号实时控制问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5735f41c1b5390548e65508258b1687c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1139119018e0c1470e21156e566dfd/" rel="bookmark">
			Zabbix使用命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、yum安装方式 四个服务分别是数据库、zabbix-server、httpd、zabbix-agent
[root@zabbix ~]# systemctl start mariadb #启动mariadb [root@zabbix ~]# systemctl enable mariadb #开机时启动mariadb [root@zabbix ~]# systemctl status mariadb #检查服务状态 [root@zabbix ~]# systemctl stop mariadb #停止mariadb服务 [root@zabbix ~]# systemctl restart mariadb #重新启动mariadb [root@zabbix ~]# systemctl start zabbix-server #启动zabbix-server服务 [root@zabbix ~]# systemctl enable zabbix-server #开机启动zabbix-server服务。 [root@zabbix ~]# systemctl start httpd #启动httpd服务 [root@zabbix ~]# systemctl enable httpd #设置开机启动httpd服务 [root@zabbix ~]# systemctl start zabbix-agent #启动zabbix-agent服务 [root@zabbix ~]# systemctl enable zabbix-agent #设置zabbix-agent服务开机自动启动 firewall-cmd --zone=public --add-port=10050/tcp --permanent # 开放10050端口 firewall-cmd --reload # 配置立即生效 netstat -ant | grep 10050 #查看监听端口 [root@localhost ~]# rpm -qa zabbix-web-mysql #检查当前版本 zabbix-web-mysql-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1139119018e0c1470e21156e566dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90654c2479e4f6a01a001680ec74c02/" rel="bookmark">
			前端——各种小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解决video src路径改变 但视频并不会自动刷新 之前的代码
&lt;video v-for="(x,i) in video" v-if="i&lt;4" class="ItemPicture" width="160" height="120" controls&gt; &lt;source :src="x.video_url" type="video/mp4"&gt; &lt;/video&gt; 正确的做法是。不绑定source标签里的src属性，而是绑定video标签中的src属性。改正如下：
&lt;video v-for="(x,i) in video" v-if="i&lt;4" class="ItemPicture" width="160" height="120" controls :src="x.video_url" type="video/mp4"&gt; &lt;/video&gt; 2.html显示图片，并处理图片和图片之间的距离 显示图片：
&lt;img v-for="(x,i) in pic" v-if="i&lt;4" width="140px" height="140px"class="ItemPicture" :src="x.pic_url"/&gt; 处理图片之间的间距：让图片变成块级元素，在style里面设置，通过RelativePic属性关联
&lt;div class="relative-img"&gt; &lt;img v-for="(x,i) in pic" v-if="i&lt;4" width="140px" height="140px"class="RelativePic" :src="x.pic_url"/&gt; &lt;/div&gt; &lt;!-- 格式设置 --&gt; &lt;style&gt; .class1{font-weight:bold;font-size:25px;} .class2{color:red;} .RelativePic{margin-left:5px;margin-right:5px;} &lt;/style&gt; 固定图片或容器的显示位置（绝对位置）：
&lt;style type="text/css"&gt; img{ position:absolute; &lt;! 绝对位移&gt; left:300px; top:150px; } &lt;/style&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90654c2479e4f6a01a001680ec74c02/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/260/">«</a>
	<span class="pagination__item pagination__item--current">261/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/262/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>