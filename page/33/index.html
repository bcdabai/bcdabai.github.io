<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d78dc8c344dc58e78df38495c5a166a/" rel="bookmark">
			【架构】ServerLess
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述什么是serverless无服务与传统模式架构区别serverless优缺点使用serverless的应用场景有哪些“无服务器”搭建网站Serverless的落地案例来源 概述 架构
单体（三层架构）微服务分布式ServerLess 什么是serverless无服务 serverless中文的含义是 “无服务器”，但是它真正的含义是开发者再也不用过多考虑服务器的问题，但是并不代表完全去除服务器，而是我们依靠第三方资源服务器后端，比如使用 Amazon Web Services(AWS) Lambda. 计算服务来执行代码，那么Serverless架构分为 Backend as a Service(BaaS) 和 Functions as a Service(FaaS) 两种技术，Serverless 它是由开发者实现的服务端逻辑运行在无状态的计算容器中，它是由事件触发，完全被第三方管理的。
什么是BaaS?
Baas 的英文翻译成中文的含义：后端即服务，它的应用架构由大量第三方云服务器和API组成的，使应用中关于服务器的逻辑和状态都由服务提供方来管理的。比如我们的典型的单页应用SPA和移动APP富客户端应用，前后端交互主要是以RestAPI调用为主。只需要调用服务提供方的API即可完成相应的功能，比如常见的身份验证，云端数据/文件存储，消息推送，应用数据分析等。
什么是FaaS?
FaaS可以被叫做：函数即服务。开发者可以直接将服务业务逻辑代码部署，运行在第三方提供的无状态计算容器中，开发者只需要编写业务代码即可，无需关注服务器，并且代码的执行它是由事件触发的。其中AWS Lambda是目前最佳的FaaS实现之一。
Serverless的应用架构是将BaaS和FaaS组合在一起的应用，用户只需要关注应用的业务逻辑代码，编写函数为粒度将其运行在FaaS平台上，并且和BaaS第三方服务整合在一起，最后就搭建了一个完整的系统。整个系统过程中完全无需关注服务器。
与传统模式架构区别 传统的架构模式是使用C/S架构的，在典型的web应用程序中，服务器接收前端的HTTP请求处理，在保存或查询数据库之前，数据可能会经过多个应用层，最终后端会返回一个响应。比如它可以是JSON形式或其他格式等。然后他会将响应返回给客户端，比如如下图所示：
在传统开发模式中，开发流程：设计师设计页面 -&gt; 服务端开发 和 前端分别开发，服务器开发完成后，-&gt; 服务部署 -&gt;服务部署完成后，就是前后端联调 -&gt; 前后端联调 -&gt; 前后端联调完成后就是测试了，-&gt; 测试， 测试完成需要上线，因此 -&gt; 上线，上线完成后，需要运维维护，因此 -&gt; 运维。在传统开发模式中，开发一个应用程序，从开始到上线需要不同的角色来做不同的事情，沟通成本非常大，并且运维过程中需要考虑到 服务器的负载均衡、事务、集群、缓存、
消息传递和数据冗余等等这些事情，在目前传统模式中存在如上问题。可以使用如下示意图来看下如上流程。如下图所示：
在Serverless架构中，应用业务逻辑是基于FaaS架构形成多个相互独立的功能组件的。并且以API服务的形式向外提供服务，在FaaS中，后端的应用被拆分成为一个个函数，我们只需要编写完成函数后部署到serverless服务即可。后续我们也不用关心任何服务器的操作。那么整个流程就只需要我们一个前端工程师的角色来完成所有的开发工作，那么沟通成本降低了。因此我们可以使用如下示意图来表示项目流程，如下所示：
前端工程师是居于serverless去写后端服务的，典型的就是居于 AWS Lambda 中编写代码，AWS中支持不同的语言。
Lambda计算服务它能够以大规模并行的方式执行代码来响应事件。通过使用Lambda以及使用各种功能强大的API和Web服务，开发者可以快速的构建松耦合，可扩展性及高效的架构体系。
注意：Lambda是什么？它是一种计算服务，它在AWS基础上执行用javascript、node.js、Python、C#或java编写的代码，源代码将被打包并部署到孤立的容器中，该容器有单独分配的内存、磁盘空间和处理器。代码、配置和依赖项的组合被称作为Lambda函数。
serverless优缺点 优点有如下：
降低创业公司启动成本 当一家创业公司的时候，在开发web的时候，我们需要版本管理服务器、持续集成服务器、测试服务器、应用版本管理仓库等作为基础服务。
线上运行的时候，为了应对大量的请求，我们还需要一个好的数据库服务器。当我们应用面向普通的用户时，我们需要：
1.1 邮件服务，用于发送提醒，注册等服务。
1.2 短信服务，用于注册，登录等用户授权操作。
如上一些对于大公司来讲，都有现成的基础设施。可是对于创业公司来讲。这都需要一些启动成本。但是如果我们使用serverless就可以降低这些成本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d78dc8c344dc58e78df38495c5a166a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692aa8ad7d97415301e037ab60521971/" rel="bookmark">
			Apache Commons Math: 面向Java的数学和统计库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章：引言 大家好，我是小黑，咱们今天要聊的是Apache Commons Math这个宝藏级的Java库。为啥说它是宝藏呢？因为它简直就是处理数学问题的瑞士军刀，无论你是要搞统计分析、数值计算，还是解决优化问题，这个库都能来一把。小黑今天就带大家深入浅出地了解一下它的魅力所在。
咱们处理数据不可避免地会遇到各种数学问题。这时候，如果每次都从头开始写，那得多累啊。这就像是每次做菜都要先种菜一样，效率低下不说，还容易出错。Apache Commons Math就像是厨房里的调料，帮你迅速地解决这些数学方面的难题。
那么，Apache Commons Math到底是个啥？简单来说，它是一个开源的Java库，提供了一大堆数学和统计方面的函数。你要做一些复杂的数学计算，或者是统计分析？没问题，这个库都能帮到你。它就像是数学界的瑞士军刀，无论你遇到什么问题，总能找到合适的工具。
第2章：Apache Commons Math概览 说到Apache Commons Math，这个库可是有着丰富的历史和背景。它是Apache Software Foundation旗下的一个项目，一直以来都致力于为Java开发者提供高质量的数学计算工具。它的目标就是让复杂的数学计算变得简单，让开发者能更专注于业务逻辑的实现。
Apache Commons Math包含了很多模块，每个模块都针对特定的数学或统计需求。比如说，它有线性代数模块，提供了各种矩阵运算的工具；还有统计模块，可以帮你做描述性统计、概率分布的计算；当然，也少不了优化算法，比如非线性优化、多目标优化等等。
讲到这里，可能有的小伙伴会问，这些听起来都很高大上，但具体能干嘛呢？小黑这就给咱们来个实例。比如说，咱们要计算一组数据的平均值、最大值、最小值。这可是统计分析中的基本操作，用Apache Commons Math就能轻松搞定。
下面是个简单的Java代码示例，咱们一起看看：
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics; public class StatisticsExample { public static void main(String[] args) { // 创建统计对象 DescriptiveStatistics stats = new DescriptiveStatistics(); // 加入一些数据 stats.addValue(5.0); stats.addValue(3.0); stats.addValue(8.0); // 计算平均值、最大值和最小值 double mean = stats.getMean(); // 平均值 double max = stats.getMax(); // 最大值 double min = stats.getMin(); // 最小值 // 输出结果 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/692aa8ad7d97415301e037ab60521971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cf806796029dc0c146f099ae9fc8fe/" rel="bookmark">
			HTB | Surveillance CVE-2023-41892 CVE-2023-26035
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTB | Surveillance CVE-2023-41892 CVE-2023-26035 使用nmap进行端口扫描
nmap -sV -sC -v -oN Surveillance.log 10.10.11.245 # Nmap 7.93 scan initiated Mon Dec 18 08:57:23 2023 as: nmap -sV -sC -v -oN Surveillance.log 10.10.11.245 Nmap scan report for 10.10.11.245 Host is up (0.56s latency). Not shown: 997 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 96071cc6773e07a0cc6f2419744d570b (ECDSA) |_ 256 0ba4c0cfe23b95aef6f5df7d0c88d6ce (ED25519) 80/tcp open http nginx 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5cf806796029dc0c146f099ae9fc8fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88201105986969512983c42bbd5f715/" rel="bookmark">
			四. 基于环视Camera的BEV感知算法-PETR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言0. 简述1. 算法动机&amp;开创性思路2. 主体结构3. 损失函数4. 性能对比5. PETRv2总结下载链接参考 前言 自动驾驶之心推出的《国内首个BVE感知全栈系列学习教程》，链接。记录下个人学习笔记，仅供自己参考
本次课程我们来学习下课程第四章——基于环视Camera的BEV感知算法，一起去学习下 PETR 感知算法
课程大纲可以看下面的思维导图
0. 简述 本次课程我们再一起学习一篇非常好的多视角 3D 目标检测工作叫 PETR，大家可以想一下，P 是什么，E 是什么，TR 我们知道是 Transformer，P 是 Position，E 是 Embedding，PE 合在一起是 Position Embedding 位置编码，所以说我们从题目中也能看出核心思路在哪呢，在位置编码的设计上
和之前一样我们依然从四个方面展开，也就是算法动机&amp;开创性工作、主体结构、损失函数以及性能对比
1. 算法动机&amp;开创性思路 我们在讲解 PETR 之前先带大家回顾一下 DETR3D 这篇工作，因为 PETR 是针对 DETR3D 做改进的工作，大家没有印象的可以先去复习一下之前 4.4 小节的内容
DETR3D 是一篇关于多视角图像的 3D 目标检测工作，输入是多视角的图像，输出是 3D 检测结果，对输入的多视角图像用什么处理呢，图像处理网络提取多视角的图像特征，那 DETR3D 用的是什么呢，是 ResNet 和 FPN，那 ResNet 作为 Backbone 提取图像特征，FPN 是特征金字塔网络用来处理多尺度特征，所以我们最后得到的图像特征是什么呢，我们叫多尺度的图像融合特征，有了图像特征之后我们再怎么做呢，初始化一系列的 Object Query，以 Object Query 为基础从图像中拿特征，通过这种方式 2D 特征其实被采样成一系列的 Object Query Feature，物体特征有了，我们后续自然可以拿来做检测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c88201105986969512983c42bbd5f715/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7aabcf753dc5f2d3c348863754cb8b/" rel="bookmark">
			资深老鸟整理，Java接口自动化测试总结，从0到1自动化...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几年接口自动化变得越来越热门，相对比于UI自动化，接口自动化有一些优势
1）运行比UI更稳定，让BUG更容易定位 2）UI自动化维护成本太高，接口相对低一些
接口测试其实有很多方式，主要有两种，一个是工具，最常见的有：Postman，SoupUI，Jmeter；另一个就是代码，Java和Python都可以实现。
工具的好处就是直观，快速上手，有些工具也做到了半自动化和集成，但是工具还是会有一定的限制，代码相对与工具来说是更万能，利用接口测试框架结合TestNG或者Junit，实现接口自动化。
1、REST Assured测试框架
maven坐标
&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/io.rest-assured/rest-assured --&gt; &lt;dependency&gt; &lt;groupId&gt;io.rest-assured&lt;/groupId&gt; &lt;artifactId&gt;rest-assured&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.rest-assured/json-path --&gt; &lt;dependency&gt; &lt;groupId&gt;io.rest-assured&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.rest-assured/json-schema-validator --&gt; &lt;dependency&gt; &lt;groupId&gt;io.rest-assured&lt;/groupId&gt; &lt;artifactId&gt;json-schema-validator&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 官方文档中建议静态导入
import static io.restassured.RestAssured.*; import static io.restassured.matcher.RestAssuredMatchers.*; import static org.hamcrest.Matchers.*; 语法格式
public void testExample() { given() .queryParam("wd","mp3") .when() .get("http://www.baidu.com/s") .then() .log().all() .statusCode(200); } given() 后面跟一次网络请求所需要的条件
.cookies() --cookies 是Map形式存储 .contentType() .queryParam("key","value") 用于get请求参数 .body(Jsondata) 存放Json格式类型 .body(XMLdata) 存放XML格式类型 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f7aabcf753dc5f2d3c348863754cb8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a251707c0a0f58876435325db62c63/" rel="bookmark">
			python安装pyecharts模块报错解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip install pyecharts
在使用地图前需要安装一下适合自己的地图包：
要记得安装对应的地图拓展：
选择自己需要的安装的地图模块
$ pip install echarts-countries-pypkg
$ pip install echarts-china-provinces-pypkg
$ pip install echarts-china-cities-pypkg
$ pip install echarts-china-counties-pypkg
$ pip install echarts-china-misc-pypkg
$ pip install echarts-united-kingdom-pypkg
安装地图模块时候提示以下错误：
提示错误关键信息关键信息: Getting requirements to build wheel did not run successfully
解决方法
pip install wheel setuptools pip --upgrade
继续安装的地图模块
$ pip install echarts-countries-pypkg
$ pip install echarts-china-provinces-pypkg
$ pip install echarts-china-cities-pypkg
$ pip install echarts-china-counties-pypkg
$ pip install echarts-china-misc-pypkg
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9a251707c0a0f58876435325db62c63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392de7481b527372505b71ca914f6861/" rel="bookmark">
			【干货】Shell编程心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言符合代码规范代码有注释参数要规范变量和魔鬼数字缩进有规矩命名有标准编码要统一文件可执行权限错误处理和调试回显密码要移除太长要分行勤用引号使用新写法数值计算文件结构SUID SGID SBIT勤查资料勤练习、勤分享 前言 随着技术的发展，虽然出现了许多现代的编程语言，但Shell编程由于其独特的优势——简洁性、高效性和在Linux系统中的无处不在，仍然保持着其重要性。
以下是笔者多年积累的一些Shell编程心得，这些心得涵盖了从基础语法到高级功能的各个方面，无论是初学者还是有经验的开发者，都可以从中受益。通过这些心得，你将能够编写出更加高效、健壮且易于维护的Shell脚本，为你的自动化任务和系统管理工作带来便利。
符合代码规范 shell文件开头有以”#!”开头的注释，学名Shebang，也称为Hashbang、“蛇棒”，如：
#!/bin/sh 如果编写的a.sh没有开头的注释，执行 ./a.sh时系统会默认用$SHELL指定的解释器，因解释器的兼容性等问题，会出现一些不可预料的问题。
Centos7.6 相关内容示例
推荐写法：
#!/usr/bin/env bash 代码有注释 注释的作用是让代码可读性更强，方便维护人员快速上手；也方便编写人员逻辑梳理。
一般包含以下几部分：
Shebang文件头脚本的参数脚本的用途脚本的注意事项脚本的写作时间，作者，版权等 例如：
各个函数前的说明注释
一些较复杂的单行命令注释
参数要规范 如果脚本需要接收参数，需要进行合理判断和处理需要合适的回显，方便使用者了解参数的使用 最简单的参数个数判断示例
if [[ $## != 2 ]];then echo "Parameter incorrect." exit 1 fi 变量和魔鬼数字 变量大写加下划线在文件头部定义
如：
## configurations CODE_PATH="/root/work/workspace/og-apus/og-apus" OGAPUS_RELEASE_FOLDER="/root/work/workspace/og-apus/release" OGSP4_BUILD_PATH="/root/work/ogsp4-release-env/base/images" OGAPUS_RELEASE_PATH_ON_PDD="/pdd-release/og-apus/docker-images" 避免魔鬼数字，如果必须使用数字，请用变量定义，并注意变量名称可读性，适当添加变量定义注释。
缩进有规矩 推荐使用工具自动格式化，vscode + shell-format插件
两种缩进类型：
soft tab：就是使用n个空格进行缩进(n通常是2或4)hard tab：指真实的"\t"制表符字符 不评论优劣，推荐两个空格
命名有标准 文件名规范，以.sh结尾，方便识别变量名字要有含义，不要拼错统一命名风格，shell一般用小写字母加下划线，不建议使用驼峰命名。 编码要统一 请使用UTF-8编码格式如编码格式不正确，可使用命令 dos2unix a.sh进行格式修复 常见问题：windows下未专门配置过utf8为默认编码格式的编辑器，回车换行是 \r\n， utf8下是\n
文件可执行权限 不加可执行权限： bash a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/392de7481b527372505b71ca914f6861/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d3d2ad759e1e6e5c9647326a7ca53e/" rel="bookmark">
			网址变迁权重不减：301 重定向的黄金法宝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络世界中，301 重定向是一个非常重要的概念，它对于网站的流量和搜索引擎优化起着关键作用。
你是否曾经在浏览网页时遇到过链接跳转的情况，或者在搜索引擎中输入一个网址却被自动重定向到另一个页面？这背后可能就是301重定向在起作用。301 重定向是一种将网址永久重定向到其他网址的方法。
在本文中，将解释技术背景并向您展示如何使用 htAccess 设置 301 重定向。
为什么需要 301 重定向？ 301 重定向是最著名的重定向类型。 数字 301 基于 HTTP 状态代码。 状态码 404 表明无法找到所请求的资源，而 300 代码则代表重定向。 通常，您使用 301 重定向来避免 404 错误。
以下是最重要的 HTTP 状态代码的概述：
HTTP 状态代码描述200 OK服务器在请求的地址找到资源并可以将其传回。301 Moved permanently所请求地址处的资源已被永久移动，并且服务器已从那里返回该资源。 旧地址不再有效。302 Found所请求地址处的资源已暂时移动，服务器已从那里返回该资源。 旧地址将在未来某个时候再次有效。303 See other然而，与 302 类似，打开临时地址时仅允许 GET 请求。307 TempoRARy redirect与 302 类似，但与 303 不同的是，客户端在打开临时地址时可能会改变 HTTP 方法（GET、POST、PUT 等）。404 Not found服务器无法从请求的地址找到任何资源。 为了在网络上查找内容或资源，需要使用网址。 发生内容迁移时，可以找到内容的地址会发生变化。 然而，内容本身却并非如此。 当从 HTTP 切换到 HTTPs 或将站点从一个域移动到另一个域时，通常会出现这种情况。 在优化搜索引擎的链接结构时，地址也可能会发生变化。 在所有这些情况下，您不希望尝试使用旧地址访问内容的用户登陆到空白页面。
如果服务器无法在给定地址找到资源，它将返回 HTTP 404 Not Found 错误。 此类错误往往会惹恼用户，因为他们无法访问他们想要访问的网页。 如果该地址是由网络爬虫而不是人打开的，则 404 错误可能会导致该资源取消索引。 网站运营商会尽力避免这两种情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00d3d2ad759e1e6e5c9647326a7ca53e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48646ea079e31a4b9cbd1c7b03fe5ebf/" rel="bookmark">
			Python 和 C&#43;&#43; 两种流行编程语言的优势和局限性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论你刚刚开始学习编程还是已经使用不同的编程语言很长一段时间，迟早你会遇到 python 和 C++。这两种语言是最著名且被广泛使用的编程语言之一，几十年来一直不同的社区中成长。虽然粉丝们肯定对他们选择的计算机语言有很多论据，但中立的用户想知道哪个选择更好。我们比较这两者，并解释它们的优势和不足。
然而，在我们比较 Python 和 C++ 之前，值得更仔细地了解一下这两种编程语言以及它们各自的优缺点。
Python 有哪些优缺点？ Python 是由荷兰开发者 Guido van Rossum 于 1991 年创建的一种解释性高级编程语言。如今，这个开源语言由 Python 软件基金会维护，并且可免费使用。Python 运行在所有主要操作系统上，是独立于平台的。它的重点是创建一种尽可能清晰简短的语法。Python 用于字符串操作、网站、Web 应用程序和软件开发。
Python 的优点： 易学性：其专注于简单易懂的代码意味着 Python 比大多数其他编程语言更易学习。即使是新手也能很快地取得学习成功并且很快可以编写自己的第一行代码。
用户友好性：Python 以其用户友好性而闻名，提供易于学习的代码库，便于快速理解外部项目。其逻辑结构化语法要求最少方言，使协作工作无需事先进行大量培训。
开源：Python 的持久成功根源在于其致力于开源哲学。作为一种自由和开源的编程语言，Python 促进了广泛采用，通过多样化的贡献者实现不断的开发和适应。
灵活性：Python 在多个方面突出为一种极其灵活的语言。首先，其通用性扩展到其广泛应用的各个领域，使之成为多样化项目的实用和明智解决方案。其次，Python 的平台无关性确保了最大程度的可移植性，可以在各种操作系统上无缝执行。最后，其与许多其他语言的兼容性使得无需努力即可实现无缝集成，简化开发过程并促进互操作性。
社区：Python 庞大而专注的社区为新手提供了巨大的优势。广泛的库和全面的文档可实现针对新项目或问题解决的有针对性方法。社区还提供有价值的支持，帮助解决问题并快速识别和解决用户遇到的任何错误。
用户：Python 已经在许多著名科技公司中获得了重要的推广，其中许多公司将其部分或全部依赖于该语言进行运营。例如，像谷歌和 Mozilla 这样的知名行业领导者使用 Python。
Python 的缺点： 速度：Python 在大型和复杂应用程序方面可能会比其他一些编程语言具有性能劣势。尽管新的包已被开发来解决这个问题，但是一些其他语言仍然在速度方面表现更好。
移动设备：尽管 Python 在桌面和服务器应用程序领域表现出色，但其在移动领域的性能有待改进。很少有移动应用程序使用 Python 编程语言。
内存消耗：Python 相对较高的内存消耗是其主要缺点之一，尤其是对于内存密集型项目而言。在这种情况下，其他编程语言通常提供更好的选择和更有效的内存利用方式。
运行时错误：作为一种动态类型语言，Python 存在更高的错误风险，这些错误可能只在运行时才变得明显。为了检测和解决问题，需要进行彻底的测试。
学习其他语言：Python 专注于基础知识，这可能使得切换到其他更复杂的语言有些困难。首先学习更为复杂的语言将会使学习其他语言更容易。
C++ 有哪些优缺点？ C++ 是一种面向对象的编程语言，由 Bjarne Stroustrup 于 1979 年创建。它起源于 C 语言的扩展，常用于低层编程，如虚拟机、驱动程序和操作系统。凭借简洁的关键字集，C++ 在全球范围内广受欢迎。这种语言通过 C++ 标准库实现功能，并非常适合不同的平台。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48646ea079e31a4b9cbd1c7b03fe5ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc12e0e65a911c04c2163e02ffa2c8aa/" rel="bookmark">
			软件研发中技术主R的职责
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是技术主R 在项目管理中，“项目主R"中的"R"通常是"Responsibility”（责任）的缩写，表示这个人在项目中担任主要责任。而"技术主R"一般指的是一次项目中技术侧实施负责人。技术主R并不一定要承担项目经理全部的职责，但要从项目管理的角度推进技术的落地。
其中主要有以以下工作要做，这些工作如下：
需求分析：分析需求、效果与合理性评估，在产品诉求和实现成本上做出权衡，找到平衡点。方案设计：根据需求分析结果，进行技术方案设计，使相关参与人达成一致。进度管理：识别整理项目的关键节点，及时沟通、推进，周知并解决风险 从技术负责人的视角看，项目管理可以被划分为四个阶段：需求阶段、设计阶段、开发阶段和上线阶段。作为负责人，就是确保项目生命周期中的每个阶段都被妥善处理。
2 关键职责 主R要对项目负责，在不同阶段有不同的职责
2.1 需求阶段 这个阶段主要工作是了解需求背景，明确项目的核心诉求，收益，确定需求参与方，明确各方向主R，组织需求评审，使各方对各项信息达成一致。
2.2 设计阶段 首先根据需求阶段分析的产品物，与跟各方参与者充分讨论技术方案。设计整体项目交互方案、关键过程流程图。组织需求所有相关方串讲技术方案。 其次前置识别风险，确定解决方案。最后确定方案，组织相关参与方进行排期。
2.3 开发阶段 开发阶段主要工作包含代码编写，联调，测试等。特点是周期长，问题多，通常会有突发问题。这导致进度把控难，沟通协调难度大。
在开发阶段解决这些问题问题主要手段可以通过定期的例会识别其中问题。例会中关注项目整体的推进的时间是否与计划享相符。细分后包括编码、联调及测试的进度。如项目时间节点未符合排期时间应及时反馈并调整相应的方案。开发阶段项目主R应时刻关注项目过程的中问题反馈，及时与外部协作方及上级沟通。
2.4 上线阶段 主R需要制定详细计划，包括上线与灰度方案，并严格把控过程。过程上分前、中、后三个阶段。
上线前，梳理上线方案，与参与方对齐，做好准备组织上线，并跟进过程上线后验证，跟进验证结果，分析问题，总结回顾
这个过程中 3 项目中的关键会议 启动会：明确项目参与方，主要包括研发、业务、产品、运营、测试等。统一目标，明确项目后续的关键时间节点。一个项目涉及多个部门的参与方时，最好先通过启动会将各种信息对齐。排期会：对关键过程进行规划，邀请相关参与人员明确关键阶段的时间安排。排期会影响项目的交付，是项目实施过程中必要的一环。日常例会：对日常工作进展进行追踪，贯穿于项目实施的整个阶段。目的是同步进度，及时识别风险。 例会可以根据项目的实际情况决定安排的评率。影响因素包含项目大小、优先级、参与方数。通常的形式有日会、周会、双周会等。 4 常见问题的应对 项目线上问题处理：主R作为接口人，快速协调相关参与方解决
项目进度阻塞处理：主R识别阻塞点，拉齐参与方解决，无法解决向上反馈
项目变更问题处理：变更包括需求变更、方案变更、排期变更等，周知参与方，确保相关责任人确认。根据优先级识别调整计划，重新输出方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d76cc7f1dc4909a5ec3c564f1cf9bb/" rel="bookmark">
			吃透modbus协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自b站
这节课带你吃透Modbus通信协议_哔哩哔哩_bilibili
理论 Modbus是一种应用层的报文传输协议，Modbus协议不是唯一的，有三种形式：RTU、ASCLL、TCP，他们之间既有共同点，又有不同点。
一、Modbus RTU通信协议为例： 01.存储区（数据存储区、文件存储区） 有四种：
输出线圈： 代号是0
输入线圈： 代号是1
输出（写）寄存器： 代号是4
输入（读）寄存器： 代号是3
线圈：最小单位bool，要么存的是1，要么是0。
寄存器：16位，2个字节
总结：如果用bool，就用线圈；如果要存数据，就用寄存器。
02.存储区范围 5位和6位 标准地址（5位）和扩展地址
标准地址（5位）：
YXXXX
Y表示哪个存储区，取值范围0、1、3、4
X取值范围0-9
输出线圈： 代号是0，存储范围：00001-09999
输入线圈： 代号是1，存储范围：10001-19999
输出（写）寄存器： 代号是4，存储范围：40001-49999
输入（读）寄存器： 代号是3，存储范围：30001-39999
扩展地址（6位）：
YXXXXX
输出线圈：存储范围：000001-065536
输入线圈： 代号是1，存储范围：100001-165536
输出（写）寄存器： 代号是4，存储范围：400001-465536
输入（读）寄存器： 代号是3，存储范围：300001-365536
03.通讯协议 八种动作：四个读、四个写
读输出线圈：功能码：01（十六进制）
读输入线圈：功能码：02
读输出寄存器：功能码：03
读输入寄存器：功能码：04
写单个输出线圈：功能码：05
写单个输出寄存器：功能码：06
写多个输出线圈：功能码：0f
写多个输出寄存器：功能码：10
报文格式：
从站地址（设备编号1byte）+功能码（1byte）+数据（N个byte）+校验（2个byte）
对于读取来说：
从站地址（设备编号）：为了区分是哪个设备。
功能码：是为了确定干什么。
数据：具体干嘛的细节。
校验：验证
对于写入来说
从站地址（设备编号）：为了区分是哪个设备。
功能码：是为了确定干什么。
数据：具体干嘛的细节（更多，多了个写入的具体数值）。
校验：验证
以下是一个例子：
监听com24端口：采集湿度和温度
上位机发送：01 03 00 00 00 02 C4 0B
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d76cc7f1dc4909a5ec3c564f1cf9bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef67c140e8bbf159626595b0acb03fd/" rel="bookmark">
			深入探讨DNS数据包注入与DNS中毒攻击检测 (C/C&#43;&#43;代码实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS数据包注入和DNS中毒攻击是网络安全领域中的两个重要主题。DNS（域名系统）是互联网中的一项核心服务，负责将域名转换为与之相对应的IP地址。
DNS数据包注入是指攻击者通过篡改或伪造DNS请求或响应数据包来干扰或破坏DNS服务的过程。攻击者可通过注入恶意数据包来改变DNS解析结果，将用户重定向到恶意网站或者进行钓鱼攻击。这样的攻击一般可以通过欺骗或者劫持DNS服务器、中间人攻击或者DNS缓存投毒来实现。
而DNS中毒攻击是指攻击者通过篡改或操纵DNS服务器的缓存记录，将正确的域名解析映射到错误的IP地址上。这样一来，用户在访问一个正常的网站时，却被重定向到一个恶意的站点。这种攻击方式常见于公共Wi-Fi网络，攻击者通过修改DNS服务器设置并将其置于网络中心位置，诱导用户连接到受到攻击的DNS服务器上。
怎么向DNS服务器发送恶意数据包
向DNS服务器发送恶意数据包的方式有多种，其中一种常见的方式是使用受损的端点将带有欺骗性IP地址的UDP数据包发送到DNS递归服务器。这些数据包上的欺骗性地址指向受害者的真实IP地址。每个UDP数据包都向DNS解析器发出请求，通常传递一个参数（例如“ANY”）以接收尽可能最大的响应。DNS解析器收到请求后，会向欺骗性IP地址发送较大的响应。当目标的IP地址接收响应时，其周边的网络基础设施可能会被大量流量淹没，从而导致拒绝服务。
另一种可能的攻击方式是DNS隧道攻击。这种攻击的原理是：在后门程序进行DNS查询时，如果查询的域名不在DNS服务器本机的缓存中，就会访问互联网进行查询，然后返回结果。如果互联网上存在恶意响应，那么这个响应就会被传送回请求者，从而实施攻击。
监控DNS服务器是否被攻击
Linux下可以通过以下命令监控DNS服务器是否被攻击：
1.查看系统日志信息，可以使用grep命令过滤出与DNS相关的日志，例如：grep “DNS” /var/log/messages。
2.查看网络负载情况，可以使用nload命令监控网络负载。首先需要安装nload工具，可以使用以下命令进行安装：sudo yum install nload。安装完成后，运行nload命令即可查看网络负载情况。
nload命令其他字段含义：
第一行为当前设备的网卡名称和IP地址，下面的显示可以分为两块，上面的而incoming为进入网卡的流量，下面的outgoing为从网卡流出的流量。
在每个模块的右边，有实时的网络流量状况显示，其中，curr为当前网速、avg为平均网速、min为最小网速、max为最大网速，ttl为使用的流量情况统计。
3.查看连接到您服务器的IP地址，可以使用netstat命令，例如：netstat -tuln | grep :53。
请注意，以上命令仅是示例.具体的命令可能因系统版本和配置而有所不同。如果您对Linux操作系统不熟悉，建议寻求专业的技术支持或安全机构的帮助，以确保您的网络安全和稳定。
监控DNS流量并分析流量模式
监控DNS流量并分析流量模式以及单个请求的方法包括以下几个方面：
DNS流量监控工具：使用专门的DNS流量监控工具，例如tcpdump、Wireshark、dnstop等。这些工具可以捕获网络中的DNS流量数据包，并提供详细的分析和统计信息。
DNS服务器日志分析：许多DNS服务器会记录访问日志，其中包含有关每个DNS请求的详细信息。通过分析这些日志文件，可以获得有关DNS流量模式和请求的有用信息。一些常用的DNS服务器软件如BIND、PowerDNS等提供日志记录功能。
DNS流量分析原理：DNS流量的分析通常涉及到解析数据包的相关信息，例如源IP地址、目标IP地址、域名、查询类型等。通过这些信息，可以推断网络中的通信模式和请求的特征。分析流量的目的是确定正常的流量模式，并识别异常或恶意的流量。
流量特征识别：通过监控和分析DNS流量，可以识别一些异常的流量特征，如大量的查询请求、异常的查询类型、短时间内的重复查询、不正常的响应时间等。这些特征可能暗示着DNS数据包注入或中毒攻击的发生。
数据包解析工具：使用数据包解析工具，如Wireshark，可以进一步分析捕获的DNS数据包。通过查看数据包的细节，例如查询字段、响应代码、权威服务器等信息，可以更加深入地了解每个请求的内容，并检测是否存在异常或可疑的特征。
可以监控和分析DNS流量，发现异常流量模式和单个请求中的潜在问题。这有助于及早发现和应对DNS数据包注入和中毒攻击等安全威胁，并保护网络和系统的安全。
深入探讨DNS数据包注入与DNS中毒攻击检测 (C/C++代码实现)
DNS数据包注入器以混杂模式捕获来自网络接口的流量，并试图注入对所选DNS a请求的伪造响应。DNS中毒攻击检测器检测DNS中毒攻击尝试。
dns_inject
... #define PROMISC 1 #define READ_TIME_OUT 0 #define SIZE_ETHERNET 14 #define IP_SIZE 16 #define PACKET_SIZE 8192 /* Ethernet header */ struct ethernet_header { u_char ether_dhost[ETHER_ADDR_LEN]; u_char ether_shost[ETHER_ADDR_LEN]; u_short ether_type; }; /* DNS header */ struct dns_header { char id[2]; char flags[2]; char qdcount[2]; char ancount[2]; char nscount[2]; char arcount[2]; }; /* DNS Question structure */ struct dns_question { char *qname; char qtype[2]; char qclass[2]; }; /* 文件选项的链接列表节点 */ struct node { char spoof_ip[32]; char spoof_domain[150]; struct node *next; }; void get_ip_of_attacker(char *if_name, char *ip) { struct ifreq ifr; size_t if_name_len = strlen(if_name); if (if_name_len &lt; sizeof(ifr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ef67c140e8bbf159626595b0acb03fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4be0452dd67ab3a644a38758fec6ecc/" rel="bookmark">
			idea报错Java HotSpot(TM) 64-Bit Server VM warning: Options -Xverify:none and -noverify were deprecated
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring启动
报错内容: Java HotSpot(TM) 64-Bit Server VM warning: Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.
选择下图的 Edit Configurations
然后在跳转出的界面中找到 Enable launch optimization 将其前面的对勾取消掉即可
如果没有Enable launch optimization 这个选项的同学, 可能是下面这样
然后选择 Disable lauch optimization
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11205f13572cf8eb0cdf66fffbc95a4/" rel="bookmark">
			C语言中的关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中的关键字 auto auto用于声明一个变量为自动变量
continue
continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环。continue语句只用在 while、for 循环中，常与 if 条件语句一起使用，判断条件是否成立。
enum
枚举enum就是英文enumerate的缩写，也就是列举、排列说明的意思。枚举类型是C语言中的一种特殊类型，枚举类型可以让我们的程序使用一些固定长度和固定数值的变量值范围。
restrict restrict只可以用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式.即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,而不能通过其它途径(其它变量或指针)来修改;这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码.
static
1、修饰变量——静态全局变量：全局变量前加static修饰，该变量就成为了静态全局变量。
2、修饰函数——修饰函数则该函数成为静态函数，函数的作用域仅限于本文件，而不能被其它文件调用。
unsigned
unsigned的作用就是将数字类型无符号化， 例如 int 型的范围：-2^31 ~ 2^31 - 1，而unsigned int的范围：0 ~ 2^32。看起来unsigned 是个不错的类型，尤其是用在自增或没有负数的情况。但是在实际使用中会出现一些意外的情况。
_complex
_Complex表示一种基本数据类型——复数。该类型的出现主要是为了解决工程和数学计算上很多涉及到复数计算的情况
建议调用&lt;complex.h&gt;的标准头文件，使用里面的complex代替_Complex
支持的_Complex有三种复数类型：
1. double complex a = 1.3;
2. double complex b = 2.3 + 4 * I;
3. double complex c = 5.3 * I;
使用&lt;complex.h&gt;头文件可以更方便的完成复数问题（虚数单位i写作大写的I）：
break
当 break 关键字用于 while、for循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。
default default关键字用在switch分支语句中，一般与case搭配使用，含义是缺省的其他条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d11205f13572cf8eb0cdf66fffbc95a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79fedbb13a4be788a980bdd57880726b/" rel="bookmark">
			【平面几何】三角形的内心与内切圆（性质归纳）（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【平面几何】三角形的内心与内切圆（性质归纳）（上）
性质21. △ A B C \triangle ABC △ABC 的内切圆 I I I 分别切 B C BC BC, A C AC AC, A B AB AB 于 D D D, E E E, F F F. 设 B C BC BC 所对中位线是 K L KL KL, 则 B I BI BI, K L KL KL, D E DE DE 三线共点; C I CI CI, K L KL KL, D F DF DF 三线共点.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79fedbb13a4be788a980bdd57880726b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db612eb39064a111a1c8d17cd26a53d/" rel="bookmark">
			【平面几何】三角形的内心与内切圆（性质归纳）（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【平面几何】三角形的内心与内切圆（性质归纳）
注记: 三角形内切圆半径记为 r r r, 外接圆半径记为 R R R, 顶点 A A A 点所对的旁切圆半径记为 r A r_A rA​, 以此类推.
性质1-1. △ A B C \triangle ABC △ABC 的内切圆 I I I 分别切 B C BC BC, A C AC AC, A B AB AB 于 D D D, E E E, F F F. 设直线 E F EF EF 交直线 B C BC BC 于 T T T, 则 D D D, T T T 调和分割 B C BC BC, A D AD AD 交圆 I I I 于 P P P, T P TP TP 与圆 I I I 相切.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5db612eb39064a111a1c8d17cd26a53d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277f030d8fb3c5ab41ec4fb5c4808677/" rel="bookmark">
			ES客户端RestHighLevelClient的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 RestHighLevelClient介绍 默认情况下，ElasticSearch使用两个端口来监听外部TCP流量。
9200端口：用于所有通过HTTP协议进行的API调用。包括搜索、聚合、监控、以及其他任何使用HTTP协议的请求。所有的客户端库都会使用该端口与ElasticSearch进行交互。9300端口：是一个自定义的二进制协议，用于集群中各节点之间的通信。用于诸如集群变更、主节点选举、节点加入/离开、分片分配等事项。 RestHighLevelClient是ES的Java客户端，它是通过HTTP与ES集群进行通信。
2 引入ES依赖 &lt;!--引入es-high-level-client相关依赖 start--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;7.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt; &lt;version&gt;7.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入es-high-level-client相关依赖 end--&gt; 3 使用 3.1 es的配置 # es配置 # es用户名 elasticsearch.userName=elastic # es密码 elasticsearch.password=elastic # es host ip 地址(集群)，多个以","间隔 elasticsearch.hosts=127.0.0.1:9200 # es 请求方式 elasticsearch.scheme=http # es 连接超时时间（ms） elasticsearch.connectTimeOut=1000 # es socket 连接超时时间（ms） elasticsearch.socketTimeOut=30000 # es 请求超时时间（ms） elasticsearch.connectionRequestTimeOut=500 # es 最大连接数 elasticsearch.maxConnectNum=100 # es 每个路由的最大连接数 elasticsearch.maxConnectNumPerRoute=100 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/277f030d8fb3c5ab41ec4fb5c4808677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de05da117256c8a398539d73f8095095/" rel="bookmark">
			Github 2023-12-24 开源项目日报 Top10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2023-12-24统计)共有10个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量Python项目5Jupyter Notebook项目2C项目1C++项目1Go项目1Java项目1JavaScript项目1Ruby项目1 Serverless Framework - 无服务器框架 创建周期：3169 天开发语言：JavaScript协议类型：MIT LicenseStar数量：45588 个Fork数量：5779 次关注人数：45588 人贡献人数：358 人Open Issues数量：1142 个Github地址：https://github.com/serverless/serverless.git项目首页: https://serverless.com Serverless Framework 是一个命令行工具，使用简单的 YAML 语法部署无服务器应用程序的代码和云基础设施。它支持多种语言，并通过 1000 多个插件进行扩展。它支持超高效的开发，适用于多种用例，并管理无服务器架构的整个生命周期。
Bark: 开源文本到音频模型 创建周期：261 天开发语言：Jupyter Notebook, Python协议类型：MIT LicenseStar数量：29286 个Fork数量：3435 次关注人数：29286 人贡献人数：16 人Open Issues数量：156 个Github地址：https://github.com/suno-ai/bark.git Bark是由Suno创建的开源基于变压器的文本到音频模型。它可以生成高度逼真的多语言语音，音乐，背景噪音和简单的音效。该模型还可以产生笑声、叹息和哭泣等非语言交流。预训练模型检查点可供商业用途和研究目的使用。
软件工程博客列表 创建周期：3116 天开发语言：RubyStar数量：26661 个Fork数量：1167 次关注人数：26661 人贡献人数：305 人Open Issues数量：115 个Github地址：https://github.com/kilimchoi/engineering-blogs.git 《软件工程博客》是一个精心策划的工程博客列表，为软件开发人员提供了宝贵的资源，使他们能够及时了解最新趋势、最佳实践以及来自该领域经验丰富专业人士的见解。
自动化防御塔RTS 创建周期：2429 天开发语言：Java协议类型：GNU General Public License v3.0Star数量：19987 个Fork数量：2743 次关注人数：19987 人贡献人数：378 人Open Issues数量：175 个Github地址：https://github.com/Anuken/Mindustry.git项目首页: https://mindustrygame.github.io 自动化防御塔RTS是一个用Java编写的开源项目。它包括Trello板、Wiki和Javadoc文档。
GPT PILOT: 从头开始编写可扩展的应用程序的开发工具 创建周期：129 天开发语言：Python协议类型：MIT LicenseStar数量：15777 个Fork数量：1296 次关注人数：15777 人贡献人数：35 人Open Issues数量：92 个Github地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de05da117256c8a398539d73f8095095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417b53a61c2e27c4425de8e43eaf4280/" rel="bookmark">
			群模乱舞，AI大模型盛开，国内大模型盘点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、百度的文心一言、文心一格
二、腾讯的混元大模型
三、华为的盘古大模型
四、阿里巴巴——通义大模型
五、科大讯飞——星火大模型
六、各种学院派和垂直大模型
CHATGPT的发布，打开了潘多拉的盒子，这比云计算、大数据等概念爆发时，要猛烈的凶狠的多。
真是体会到了大象在舞蹈。忽然就理解了一个事情，就是国家的军事实力，暴露和隐藏，都是有战略的。有人说，美国藏了很多高尖端武器，从AI来看，不是没有可能，庆幸的是，从AI来看，我们国家的实力也不容小觑。而且我相信，我们的应用场景更丰富，会创造和发展出更多有意思的东西。
到底都有哪些大模型呢？
一、百度的文心一言、文心一格 我最近用的比较多，生态开始完备，小工具，插件，提示词应用，App上还有社区概念。画画、唱歌，陪你练习口语，无所不能。
自动腾讯发布的混元，画图是4选1，他只用了1天就跟进了。
据人民数据、新华网等多个公开测评，文心大模型3.5支持下的文心一言综合能力超过 ChatGPT，遥遥领先于国内其他大模型。IDC 最新发布的《AI 大模型技术能力评估报告，2023》显示，文心大模型3.5拿下12项指标的7个满分，得到“综合评分第一，算法模型第一，行业覆盖第一”三个绝对第一。
但是也有个现象需要警惕，就是这玩意毕竟是一个商业公司出的，虽然百度搜索是必选的插件。 回答的结果，已经出现了大模型的筛选情况。也许这更像个人吧！
比如你问百度大模型，国内优秀的大模型，他还是闭口不答的。
大家都说信息茧房，这个没有办法，我们知道的，永远都是别人想让我们知道的。宇宙也许都是如此，更别说一个AI的回复了。
地址：文心一言
二、腾讯的混元大模型 9月公开亮相的，MAAS模型及服务的重要部分。腾讯正在持续探索大模型应用场景，目前内部超180项业务已经接入腾讯混元大模型进行内测，11月9日，腾讯集团副总裁蒋杰在2023年世界互联网大会乌镇峰会上，这样解读。
目前混元大模型需要企业实名认证后，进行申请开通。
腾讯这么toC的公司，确实向产业互联网进军，没有去做更多的GC工作，感觉直接就杀入更赚钱的领域去了。
地址：腾讯云搜大模型
三、华为的盘古大模型 盘古大模型是以盘古开天辟地神话为灵感来源，结合中国传统文化中的五行、八卦等元素，构建的一个大型的知识图谱与语义搜索引擎。它致力于将全球范围内的知识与信息进行高效、智能的整合、检索和分析，为广大用户提供全面、准确的知识服务。
华为盘古大模型由CV，NLP，多模态，预测和科学计算5大基础模型组成，可实现文本生成、图片生成、代码生成、图片理解、气象预测、智能助手打造等多种功能。
华为盘古大模型作为通用AI预训练模型，可以广泛应用于矿山、药物分子、铁路、气象、海浪、制造等领域，提供智能化的解决方案。
盘古大模型包括了三大部分：知识图谱、语义搜索和智能问答。其中，知识图谱是盘古大模型的核心，它将不同领域的知识以节点和边的形式进行表示，并形成一个庞大的知识网络。语义搜索则是基于知识图谱的检索功能，它能够进行智能化的语义理解和信息筛选。智能问答则是盘古大模型的又一重要功能，它可以实现基于自然语言的问答服务，帮助用户快速找到所需的答案。
盘古大模型的应用领域非常广泛，可以为各行各业提供智能化的知识服务。比如，在教育领域，它可以为学生提供集成化的在线学习工具；在医疗领域，它可以为医生提供智能化的诊断辅助工具；在商业领域，它可以为企业提供智能化的市场研究和预测分析。总之，盘古大模型未来的发展前景非常广阔。
申请体验地址：盘古大模型_panguLM_大模型_华为云
四、阿里巴巴——通义大模型 通义大模型是阿里大模型的统一品牌，覆盖语言、听觉、多模态等领域，致力于实现接近人类智慧的通用智能，让AI从“单一感官”到“五官全开”。
目前，阿里通过通义大模型打造了通义千问、通义万相和通义听悟3款生成式AI产品。
通义大模型是阿里巴巴的一项人工智能技术，是一种自然语言处理模型，专门用于中文语言处理。通义大模型采用了深度神经网络技术，能够对中文语言进行推理、分析和理解，并生成符合语法和语义规则的自然语言文本。这种模型可以在多种自然语言处理任务中使用，如自动语音识别、机器翻译、文本分类和情感分析等。
通义大模型是阿里巴巴在人工智能领域取得的重要成果之一，并广泛应用于阿里巴巴的各种业务领域中，包括零售、金融、物流等。
这是目前和百度很类似的大模型了。通义千问的能力也很强，由于电商基因，很注重电商直播带货脚本的生成等，这方面是更专业的。
至于根据文档进行总结，识图说话，这都是基本的能力了。
五、科大讯飞——星火大模型 科大讯飞推出的新一代认知智能星火大模型，拥有跨领域的知识和语言理解能力，能够基于自然对话方式理解与执行任务，包括语言理解、知识问答、逻辑推理、数学题解答等。
星火大模型从海量数据和大规模知识中持续进化，实现从提出、规划到解决问题的全流程闭环。
合肥，是一个科技工作者必须关注的城市，另外科大讯飞，也是一个扫地僧级别的公司，不知道他们组织架构是如何搭建的，刘庆峰董事长真是一个了不起的任务，那么的低调。
可达讯飞的AI能力，你永远可以相信，他们对C端用户的理解，你也永远可以相信。
功能丰富，全部免费。
/一键可以弹出指令集。
一键生成PPT，什么都不需要做。
看我这个例子：
PPT在配图的搜索方面，可能是由于素材的缺乏，确实不如百度文库的生成，而且的图片尺寸的控制有些大，导致生成的PPT页面少，但是达到了20M。
这一点上看，百度把这种功能，放到了文库，未来是要和文库会员捆绑销售的。 地址：讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞
讯飞认知大模型，现在提供免费试用，拥有跨领域的知识和语言理解能力，完成问答对话和文学创作等任务。持续从海量文本数据和大规模语法知识中学习进化，实现从提出问题、规划问题到解决问题的全流程闭环。
API也是免费的，清晰可见的NICE。
六、各种学院派和垂直大模型 以下大模型，大家有兴趣自己去找找玩玩吧！
大部分都是开源的，可以在GIT上获得。
清华大学——ChatGLM-6B
开源地址：https://github.com/THUDM/ChatGLM-6B
智源人工智能研究院——悟道·天鹰
开源地址：https://github.com/FlagAI-Open/FlagAI/tree/master/examples/Aquila
达观数据——"曹植"垂直大预言模型
体验地址：http://www.datagrand.com/products/aigc/
上海人工智能实验室——书生·浦语（InternLM）
开源地址：https://github.com/InternLM/InternLM
百川智能——baichuan-7B
开源地址：https://github.com/InternLM/InternLM
北京大学——ChatLaw
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417b53a61c2e27c4425de8e43eaf4280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a81c9fa29b08390318101ffc48bead/" rel="bookmark">
			【AI】Python 实现 KNN 手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KNN 算法 1. 题目介绍 K近邻（K-Nearest Neighbor, KNN）是一种最经典和最简单的有监督学习方法之一。K-近邻算法是最简单的分类器，没有显式的学习过程或训练过程，是懒惰学习（Lazy Learning）。当对数据的分布只有很少或者没有任何先验知识时，K 近邻算法是一个不错的选择。
从背景上来说，KNN 并不复杂，本文不介绍 KNN 的原理，重点关注如何使用 KNN 来实现手写数字的识别。具体来说，本文使用两种办法来实现 KNN，第一种是使用 numpy 手动实现该算法，第二种是使用 sklearn 中封装好的 KNN 接口，并会简要比较一下两种办法。
本文使用的数据集采用文本文件，每一个文件使用大小为 32 × 32 32×32 32×32 的 0-1 阵列来表示一个手写数字。我们的目标是输入一张这样的图片，然后返回对该图片的预测值。例如下面的几张图片都表示手写数字 ‘0’：
2. 代码编排 本实验使用 jupyter 完成，下面按照 cell 的顺序进行介绍。Github链接（含代码和数据集）
2.1 全局定义 首先是导入整个项目需要使用到的库，并且定义一些全局变量。training_dir 和 test_dir 分别是训练集和测试集的目录地址，虽然 KNN 中严格来说不存在“训练”和“测试”的概念，但此处把“训练集”理解作空间中已有的那些点，“测试集”就是输入的待分类的点：
import os import numpy as np import operator from sklearn.neighbors import KNeighborsClassifier as kNN import time training_dir = 'data/knn-digits/training_digits' test_dir = 'data/knn-digits/test_digits' k_global = 3 然后定义对数据集的处理方法。每个文件是 32 × 32 32×32 32×32 的 0-1 阵列，所以我们把他转化为 1 × 1024 1×1024 1×1024 的单行数据，再将单个的数据全部拼接在一起；训练集中一共有 1934 个文件，则最终得到的训练集的大小为 1934 × 1024 1934×1024 1934×1024。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a81c9fa29b08390318101ffc48bead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3451525afa23b7c4ed62517fa1c957/" rel="bookmark">
			美好的⼀天 从ActionTab开始 美观、智能、⾼效的新标签⻚&amp; iTab 新标签页iTab新标签页&amp;Atop100工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ActionTabiTab 新标签页iTab新标签页，小组件，起始页，标签页，日历，股票，浏览器扩展 https://www.actiontab.cn/
ActionTab 收费？？？？
iTab 新标签页iTab新标签页，小组件，起始页，标签页，日历，股票，浏览器扩展 免费无广告的组件式浏览器主页
https://www.itab.link/
Itab 这个AI还不如科大讯飞那个
先把AI整智能点再说收费吧。。。
豆包还是行哈
https://chatglm.cn/
智谱AI不赖
https://chatglm.cn/
https://www.aitop100.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f4bd60082bb6b8a5c7f17d36fb4923/" rel="bookmark">
			Java初中高级面试1000问，符合90%程序员的面试需求，覆盖一线大厂各种面试痛点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前有位粉丝让我写一篇怎么进大厂的文章，这是个老生常谈的问题了，但是像我这么宠粉的人必然不能拒绝，所以今天不敲代码了，聊聊我对于怎么进大厂的看法，一家之言，不喜勿喷。
大厂需要什么样的人？ 大厂对于非高 P 职位，面试标准其实很简单
能干活Java 基础要好最好熟悉些分布式框架 相信这些标准大部分公司都差不多
前段时间，帮一些粉丝进行了模拟面试，工作经验在 3 到 5 年间。
不少候选人能力其实不差，但面试时没准备或不会说，这样的人可能在进团队干活后确实能达到期望，但可能就无法通过面试，面试官总是只根据面试情况来判断。
但现实情况是，大多数人可能面试前没准备，或准备方法不得当。要知道，我们平时干活更偏重于业务，不可能大量接触到算法，数据结构，底层代码这类面试必问的问题点，换句话说，面试准备点和平时工作要点匹配度很小。
后面这些人的真正面试结果跟我预料的大差不差
所以我整理了一些面试中常考察的几个方向：
框架是重点，但别让人感觉你只会山寨别人的代码别单纯看单机版的框架，适当了解些分布式数据库方面，别就知道增删改查，得了解性能优化Java 核心方面，围绕数据结构和性能优化准备面试题Linux 方面，至少了解如何看日志排查问题通读一些底层代码，作为加分项一切的一切，把上述技能嵌入到你做过的项目里 怎么进大厂？ 除了自身技术过硬之外刷题肯定是必不可少的，毕竟现在 Java 面试都是靠八股文，所以我花了很长时间搜集整理出来了这套 Java 面试题大全，希望对大家有帮助哈，记得收藏点赞哟~
Java 10W字+面试总结 这份面试总结比较多，就不一一的详细介绍了，粗略的将主要内容展示一下，其中含有20+的知识点：
目录总览
目录详览
基础篇
JVM篇
多线程&amp;并发篇
Spring篇
MyBatis篇
SpringBoot篇
MySQL篇
SpringCloud篇
Dubbo篇
Nginx篇
MQ篇
Linux篇
Zookeeper篇
Redis篇
分布式篇
网络篇
设计模式篇
maven篇
ElasticSearch篇
tomcat篇
Git篇
软实力篇
内容一览
JVM知识点汇总
锁、线程
Mybatis
Zookeeper
TCP
写在最后的总结 最后想说的是，2024年一眨眼也要到了，对于很多人来说是跳槽的好机会，大厂面试远没有我们想的那么困难，摆好心态，做好准备，你也可以的。
另外，面试中遇到不会的问题不妨尝试讲讲自己的思路，因为有些问题不是考察我们的编程能力，而是逻辑思维表达能力；最后平时要进行自我分析与评价，做好职业规划，不断摸索，提高自己的编程能力和抽象思维能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141daae2400094369685170ea6272796/" rel="bookmark">
			MongoDB中用java查询时间段的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MongoDB中用时间查询，记录如下：
1、使用spring的org.springframework.data.mongodb.core.query包查询比较方便：
具体方法：
Criteria criteria = Criteria.where("UPLOAD_DATE")
.gte(Tools.str2Date(dayString + " 00:00:00")).lte(Tools.str2Date(dayString + " 23:59:99"));
mongoTemplate.remove(new Query().addCriteria(criteria), "collectionName");
关键点：
1、不需要时区转换
2、gte、lte中传入的，是java.util.Date对象，不需要再转来转去，Spring已经有很好的支持，不需要为时区问题烦恼。
3、Tools.str2Date，就是用来将字符串转为时间对象的，代码太简单，不再粘了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d931dece4224d38d7a1ce818cd351d9/" rel="bookmark">
			CentOS 挂载硬盘,适用于fdisk找不到硬盘的场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos 挂载硬盘 查看主机总线号重新扫描总线 正常情况下，使用以下命令就可以完成硬盘的挂载：
运行 fdisk /dev/sdc：对数据盘进行分区。依次输入n、p、1、回车、回车、wq，开始分区。 [root@localhost ~]mkfs.xfs /dev/sdc1 [root@localhost ~]mount /dev/sdc1 /data/dc/ 那有时候存在分配的硬盘找不到的情况，通过以下办法处理，且不需要重启服务器：
查看主机总线号 [root@localhost ~]ls /sys/class/scsi_host/ 重新扫描总线 [root@localhost ~]echo "- - -" &gt; /sys/class/scsi_host/host0/scan [root@localhost ~]echo "- - -" &gt; /sys/class/scsi_host/host1/scan [root@localhost ~]echo "- - -" &gt; /sys/class/scsi_host/host2/scan 说明只需要扫描的SCSI总线，没有的不需要扫描
扫描之后再重新 fdisk -l 检查，就能够发现分配的硬盘，挂载取可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157e3ef7995011f7bc58a3f994875d51/" rel="bookmark">
			常用的百兆网络变压器与RJ45网口的参考连接电路有哪些，主要注意事项在哪里呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hqst华轩盛(石门盈盛)电子导读：一起来了解常用的百兆网络变压器与RJ45网口的参考连接电路有哪些，主要注意事项在哪里呢？
第一,常用的百兆网络变压器与RJ45网口的参考连接电路
常用百兆网络变压器与网口连接器分开为独立电子元件的分离式参考电路A
常用百兆网络变压器与网口连接器分开为独立电子元件的分离式参考电路B
一种百兆网络变压器与网口连接器集成在一起的集成网口参考连接电路
第二,网络变压器与芯片和RJ45网口连接时主要注意事项在哪里呢？
网络变压器与芯片和RJ45网口连接时除了按照代码对应进行连接之外，主要注意的是网络变压器中心抽头与芯片和RJ网口连接器之间的电路连接：
首先要龙清楚使用的是什么芯片，不同的芯片设计有不同的接法，它是由使用的PHY芯片UTP口驱动类型决定的，驱动类型主要有两种，电压驱动和电流驱动。电压驱动的就要接电源 (3.3V、2.5V、1.8V)； 电流驱动的就直接接个电容到地；所以对于不同的芯片，中心抽头的接法，与PHY是有密切关系的，具体要参看芯片的datasheet和参考设计；
其次需要注意的是中心抽头不能接错，如果接错，会导致网口信号极不稳定，严重的甚至不通。
对百兆网络变压器与RJ45网口的参考连接电路和主要注意事项有所了解了吗？ 接下来Hqst 盛生将继续给大家分享网络变压器和与之配套的RJ45 网络连接器的相关知识，方便大家认识网络变压器和RJ系列网口产品，不足之处欢迎讨论；
感兴趣的朋友，可以继续关注！专业网络变压器/RJ45网口连接器，尽在Hqst；#网络变压器，#电子元器件，#网络滤波器，#脉冲变压器，#网口变压器模块；
另外，有关光猫、交换机、路由器、服务器、PCI网卡 、扩展坞 、移动打印机等生产工厂选用网络变压器模块，集成RJ45网口连接器的精准产品型号， 可详询Hqst华轩盛（石门盈盛）电子盛先生，免费领取规格书/数据表参考...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5338f1ee04acaf49016a37824ede5377/" rel="bookmark">
			Txt 和 Csv 文件读写操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-csv&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt; &lt;/dependency&gt; import org.apache.commons.csv.CSVFormat; import org.apache.commons.csv.CSVParser; import org.apache.commons.csv.CSVRecord; import org.apache.commons.io.FileUtils; import java.io.*; import java.nio.channels.FileChannel; import java.nio.channels.FileLock; import java.nio.charset.StandardCharsets; import java.util.ArrayList; import java.util.List; /** * 文件工具类 */ public class FileUtil { /** * txt 文件读取 */ public static List&lt;String&gt; txtReader(String filePath, int size) throws Exception { InputStream stream = FileUtils.openInputStream(new File(filePath)); BufferedInputStream inputStream = new BufferedInputStream(stream); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5338f1ee04acaf49016a37824ede5377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e4e7ce2a2b5cd4076a9ce22c73b081/" rel="bookmark">
			Smith标准形存在性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下文算法中 A ( λ ) \mathbf{A}(\lambda) A(λ) 指 n n n 阶 λ \lambda λ-矩阵.
算法1. 若 a 11 ≠ 0 a_{11} \neq 0 a11​=0, 且 A ( λ ) \mathbf{A}(\lambda) A(λ) 的第 1 1 1 行或第 1 1 1 列中存在元素无法被 a 11 a_{11} a11​ 整除, 通过有限次初等变换使第 1 1 1 行第 1 1 1 列中所有元素都能被 a 11 a_{11} a11​ 整除, 且 ( 1 , 1 ) (1,1) (1,1) 位置的元素次数变低.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e4e7ce2a2b5cd4076a9ce22c73b081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1324b5ecbd783e0b45c85727f5a512c3/" rel="bookmark">
			dubbo线程池为什么耗尽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章概述 大家可能都遇到过DUBBO线程池打满这个问题，报错如下，本文我们就一起分析DUBBO线程池打满这个问题。
cause: org.apache.dubbo.remoting.RemotingException: Server side(10.0.0.100,20881) thread pool is exhausted, detail msg:Thread pool is EXHAUSTED! Thread Name: DubboServerHandler-10.0.0.100:20881, Pool Size: 800 (active: 800, core: 800, max: 800, largest: 800), Task: 50397601 (completed: 50396801), Executor status:(isShutdown:false, isTerminated:false, isTerminating:false), in dubbo://10.0.0.100:20881!
1 DUBBO线程模型 先看一张图大概了解
** IO线程** IO线程的工作实际上就是处理字节流的输入输出，对消息的读取，序列化，不涉及业务操作
NettyServer中启动netty服务端，初始化boss和work线程信息
protected void doOpen() throws Throwable { bootstrap = new ServerBootstrap(); bossGroup = NettyEventLoopFactory.eventLoopGroup(1, "NettyServerBoss"); workerGroup = NettyEventLoopFactory.eventLoopGroup( getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), "NettyServerWorker"); final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this); channels = nettyServerHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1324b5ecbd783e0b45c85727f5a512c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ed15f0fcf5cb5164879d3cc0523e7c/" rel="bookmark">
			docker基础使用docker常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker ps -a ##查看所有容器
docker rm [-f] $(docker ps -qa) ##删除所有容器
docker rmi $(docker images -q -f dangling=true) ##删除虚悬镜像
docker build -t yym_image:v2 . ##制作镜像
docker run -d -it --name MOP_ac_container -v /home/yym/test/yym_logs/:/home/yym/test/yym_logs/ -p 7676:7676 -p 9999:9999 yym_image:v2 ##启动容器
docker start 8814e4d2df92 ##启动容器
docker exec -it 49fc12d95ad8 /bin/bash ##进入容器
docker restart 8814e4d2df92 ##重新启动容器
docker stop 8814e4d2df92 ##关闭容器
docker logs 12a2fe18907a ##查看容器日志
docker inspect 12a2fe18907a ##查看容器信息
docker network ls ##查看网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ed15f0fcf5cb5164879d3cc0523e7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e2588c82eb8daa27eb2ff593f87f7f/" rel="bookmark">
			Nessus详细安装-windows （保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nessus描述 Nessus 是一款广泛使用的网络漏洞扫描工具。它由 Tenable Network Security 公司开发，旨在帮助组织评估其计算机系统和网络的安全性。
Nessus 可以执行自动化的漏洞扫描，通过扫描目标系统、识别和评估可能存在的安全漏洞和弱点。它可以检测操作系统、应用程序、服务和网络设备中的各种安全问题，如已知的漏洞、配置错误、弱密码、未经授权的访问等。
Nessus 提供了丰富的报告功能，可以生成详细的漏洞报告和安全建议，帮助管理员和安全团队理解并解决系统中存在的安全问题。
一、下载地址 官网提供的下载地址：
Download Tenable Nessus | Tenable®
二、获取activation code 获取地址：Tenable Nessus Essentials Vulnerability Scanner | Tenable®
需要填写名称和用于接受注册码的邮箱，邮箱必须正确填写不然不能接受到注册码
成功之后的截图：接下来我们就等注册码，还有就是进行下一步的安装 三、安装Nessus 1. 双击下载好的msi文件 2. 同意协议，并下一步 3.选择安装目录，并下一步 4.点击install之后，等待安装完成之后，点击完成安装 5.完成之后会有个提示 Yes:表示立即重启系统
No:表示稍后重启
6. 重启电脑之后，双击如下 7. 跳转到网页版 8.安装步骤，进行下一步 9. 选择离线安装 10.点击Offline Registration之后跳转到以下界面 （1）在nessus服务上运行 nessuscli fetch --challenge 命令
在Windows下直接win+R 弹出命令提示符，以管理员的身份运行，并切换到Windows下你安装Nessus的目录或者直接在Nessus目录下直接输入cmd。
（2）输入Nessus发给你邮箱的注册码
11.点击提交之后，弹出 注意：提前下载插件
12.将license码复制到，如下位置 注意：将license全部复制包括前面的-----BEGIN TENABLE LICENSE-----和最后的-----END TENABLE LICENSE----- 否则会提=提示错误 。
13.设置用户名和密码 14.提交之后的安装完成的界面 15.下载Nessus的插件 在上述11步的时候提到的下载插件的地址，需要提前下载。并将下载好的插件放到Nessus的安装目录下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e2588c82eb8daa27eb2ff593f87f7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c03304069ec1986e34c2d6161546b8/" rel="bookmark">
			PyQt6 利用Pyinstaller打包发布程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锋哥原创的PyQt6视频教程：
2024版 PyQt6 Python桌面开发 视频教程(无废话版) 玩命更新中~_哔哩哔哩_bilibili2024版 PyQt6 Python桌面开发 视频教程(无废话版) 玩命更新中~共计53条视频，包括：2024版 PyQt6 Python桌面开发 视频教程(无废话版) 玩命更新中~、第2讲 PyQt6库和工具库QTDesigner安装与配置、第3讲 PyQt6第一个程序HelloWorld实现等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV11C4y1P7fj/PyQt6程序的打包发布，即将.py代码文件打包成可以直接双击执行的.exe文件，在Python中并没有内置可以直接打包程序的模块，而是需要借助第三方模块实现。打包Python程序的第三方模块有很多，其中最常用的就是Pyinstaller。
安装Pyinstaller pip install Pyinstaller -i https://pypi.tuna.tsinghua.edu.cn/simple 打包普通Python程序 普通Python程序指的是完全使用Python内置模块或者对象实现的程序，程序中不包括任何第三方模块。使用Pyinstaller打包普通Python程序的步骤如下。
打开系统的CMD命令窗口，使用cd命令切换到.py文件所在路径（如果.py文件不在系统盘C盘，需要先使用“盘符:”命令来切换盘符），然后输入“pyinstaller -F 文件名.py”命令进行打包
下面是一些常用的命令行选项：
-F：将所有文件打包为一个单独的可执行文件。 -D：将所有文件打包为一个目录，包含可执行文件和所有依赖的文件。 -c：将程序与命令提示符结合在一起，以便在命令提示符下运行。 -d：将调试信息打包进可执行文件中。 –onefile：将所有文件打包为一个单独的可执行文件。 -o：指定输出文件的位置。 -w：打包为窗口文件。 -p DIR, –path=DIR：设置导入路径，从而导入需要的模块
测试代码：
""" 作者 : 小锋老师 官网 : www.python222.com """ import time ​ if __name__ == '__main__': print("hello Wolrd python222") time.sleep(3000) ​
打包命令：
pyinstaller -F helloworld.py dist目录，可以找到打包生成的 helloworld.exe 可执行文件。
双击运行：
打包PyQt6程序 前面使用“pyinstaller -F”命令可以打包没有第三方模块的普通Python程序，但如果程序中用到了第三方模块，在运行打包后的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c03304069ec1986e34c2d6161546b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be952ddb3ecb9499b5b96e804f0c36c5/" rel="bookmark">
			gdb调试的时候，如何知道程序当前运行的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用gdb进行调试时，你可以通过以下几种方式来了解程序当前运行的位置：
1：使用gdb的命令where或backtrace，可以显示当前的函数调用栈信息，包括正在执行的函数以及调用关系。这可以让你知道程序当前所在的函数位置。
2：使用gdb的命令info frame，可以获取当前栈帧的信息。栈帧是函数调用过程中的一个重要概念，每个栈帧对应一个函数调用。通过查看当前栈帧的信息，你可以获知程序执行到哪个函数的哪一行代码。
3：在gdb中设置断点，然后运行程序。当程序执行到你设置的断点位置时，gdb会中断程序的执行，并且显示当前所在的文件名和行号。你可以使用命令break 文件名:行号来设置断点，或者使用break 函数名来设置在某个函数中的断点。
4：使用gdb的display命令，可以在每次程序停下来时显示某个表达式的值。你可以使用display 变量名来监视某个变量的值，或者使用display 函数名来监视某个函数的返回值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5fa37c7e4d75856380eeb46c55595d/" rel="bookmark">
			Java面试八股文大全（全网最新版）1000&#43;道大厂面试题附答案详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多 Java 工程师的技术不错，但是一面试就头疼，10 次面试 9 次都是被刷，过的那次还是去了家不知名的小公司。
问题就在于：面试有技巧，而你不会把自己的能力表达给面试官。
应届生：你该如何准备简历，面试项目和面试说辞？Spring 底层逻辑是什么？1-3 年经验的程序员：面试中你该讲哪些值钱的技术？如何用这些值钱的技术最大程度展示自己的技能？分布式组件底层逻辑是什么？3-5 年经验的程序员：k8s 怎么搭建实践？ 这些问题，相信每一位 Java 程序员都曾遇到过，甚至有的人至今也不知道要怎么解决，屡面屡败，最终导致你的面试通过率极低。
如果说简历是你求职的敲门砖，那么你回答每一个 Java 技术问题的技巧与方法，就是你面试能否通过的关键！
为了帮助各位工程师，掌握 Java 面试中每一个问题的技巧，提高面试通过率，在这分享一些大厂面试都问的高频常问面试题,这份面试题资料包括了 Spring，JVM,java 基础，Java 集合，Java 并发编程，微服务，网络，Kafka，分布式，Redis，大厂面试解决方案，分布式事务，设计模式，算法，数据结构，MySQL 等
架构师必备技能：（阿里面试必问） 多线程 &amp;并发面试题： JAVA 并发知识库：
Java 中实现多线程有几种方法继承 Thread 类实现 Runnable 接口。ExecutorSenvice. Callable. Future 有返回值线程基于线程池的方式4 种线程池如何停止一个正在运行的线程notify0 和 notifyAll0 有什么区别?sleep0 和 wait0 有什么区别?volatile 是什么?可以保证有序性吗?Thread 类中的 start0 和 run0 方法有什么区别?为什么 wait, notify 和 nfifAllI 这些方法不在 thread 类里面?为什么 wait 和 ntify 方法要在同步块中调用?Java 中 interrupted 和 isInterruptedd 方法的区别?Java 中 synchronized 和 ReentrantLock 有什么不同?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd5fa37c7e4d75856380eeb46c55595d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b262ec9849ceeacad200d58d5b3dee/" rel="bookmark">
			maven下载jar包失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置国内镜像 设置国内的仓库,比如:
&lt;!--阿里仓库--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 仓库中不存在这个包，修改仓库 参考
https://www.cnblogs.com/ziyue7575/p/14744099.html
例如：gt-main
在mvnrepository（ https://mvnrepository.com/ ）中查找gt-main
添加到pom.xml的repositories
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;osgeo&lt;/id&gt; &lt;name&gt;Open Source Geospatial Foundation Repository&lt;/name&gt; &lt;url&gt;https://repo.osgeo.org/repository/release/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339fcc641c3cc808b305257ac7517fd8/" rel="bookmark">
			java 空间几何计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GeoTools工具类 参考
Geotools(空间分析，栅格，坐标系，查询，简易地图，GP工具）-CSDN博客
geotools使用_org.geotools-CSDN博客
org.geotools是一个Java编写的开源地理空间类库，提供了一套功能强大的工具和API，用于处理地理空间数据。
引用 &lt;dependency&gt; &lt;groupId&gt;org.geotools&lt;/groupId&gt; &lt;artifactId&gt;gt-main&lt;/artifactId&gt; &lt;version&gt;28.2&lt;/version&gt; &lt;/dependency&gt; 依赖下载不下来，是仓库里没有，需要换个仓库下载，在repositories标签里
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;osgeo&lt;/id&gt; &lt;name&gt;Open Source Geospatial Foundation Repository&lt;/name&gt; &lt;url&gt;https://repo.osgeo.org/repository/release/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; GeoTools与JTS的关系 JTS提供了一套空间数据操作的核心算法,为在兼容OGC标准的空间对象模型中进行基础的几何操作提供2D空间谓词API。JTS解决了空间对象之间拓扑关系的判定和计算，并提供很多有用的算法来解决对象的面积，长度等等的问题，是处理空间数据图形关系非常好的解决方案。
JTS就相当于GeoTools中的一个“子模块”。但因为这个模块本身不是GeoTools工程的，所以在javadoc中找不到JTS的API,需要到JTS官网上面另外下载。
在具体使用上：
&lt;dependency&gt; &lt;groupId&gt;org.locationtech.jts&lt;/groupId&gt; &lt;artifactId&gt;jts-core&lt;/artifactId&gt; &lt;version&gt;1.19.0&lt;/version&gt; &lt;/dependency&gt; GeoTools会自动的附带JTS的包，不需要自己手动引入。
计算面积 GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory(); // 使用jts // GeometryFactory geometryFactory = new GeometryFactory(); CoordinateList coords=new CoordinateList(); coords.add(new Coordinate(-51.009, 87.937)); coords.add(new Coordinate(-47.710, 87.937)); coords.add(new Coordinate(-47.710, 81.675)); coords.add(new Coordinate(-51.009, 81.675)); //闭合 coords.closeRing(); Polygon polygon = geometryFactory.createPolygon(coords.toCoordinateArray()); //输出中心点 System.out.println( polygon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/339fcc641c3cc808b305257ac7517fd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b63c6c928b6911dd5e8a61c0d841b3/" rel="bookmark">
			标准化和归一化分别是什么？两者的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准化和归一化都是用于将数据集中的各个特征值缩放到相同的尺度上，以避免不同尺度的特征值对模型的影响程度不同。
标准化 标准化是指将数据集中的每个特征值都减去其均值，然后再除以其标准差，以将特征值缩放到以0为均值、1为标准差的标准正态分布上。标准化后的数据集中，每个特征值的取值范围都在[-3,3]左右，可以减小异常值对模型的影响，适用于大多数的线性模型。
归一化 归一化是指将数据集中的每个特征值都缩放到[0,1]的范围内，以保证所有特征值都在同一尺度上。归一化后的数据集中，每个特征值的取值范围都在[0,1]之间，适用于需要计算距离的算法，如KNN算法、神经网络等。
区别 两者的区别在于：
标准化是依据特征值的均值和标准差进行缩放，而归一化是依据特征值的最大值和最小值进行缩放。标准化后的数据集中，每个特征值都以0为均值、1为标准差，取值范围在[-3,3]左右；而归一化后的数据集中，每个特征值的取值范围都在[0,1]之间。标准化适用于大多数的线性模型，而归一化适用于需要计算距离的算法，如KNN算法、神经网络等。 需要根据具体情况选择标准化或归一化。如果特征值的分布近似于正态分布，可以使用标准化；如果需要计算距离或使用神经网络等算法，可以使用归一化。
为什么要做这个？ 在数据挖掘和分析中，一般情况下需要对自变量进行归一化或标准化，原因如下：
不同自变量的量纲不同。在数据挖掘和分析中，自变量可能来自不同的数据源，或者是不同的特征，这些自变量的量纲可能不同，例如，有些自变量的取值范围在几百到几千之间，而有些自变量的取值范围只有几十到几百之间。这时，如果不对自变量进行归一化或标准化，可能会导致一些自变量对模型的影响程度过大，而其他自变量的影响程度过小，从而影响模型的准确性。不同自变量的分布不同。在数据挖掘和分析中，自变量的分布可能不同，例如，有些自变量的分布近似于正态分布，而有些自变量的分布不是正态分布。这时，如果不对自变量进行归一化或标准化，可能会影响算法的收敛速度和准确性。模型需要计算距离。在一些算法中，例如KNN算法、神经网络等，需要计算自变量之间的距离，这时如果不对自变量进行归一化或标准化，可能会导致一些自变量对距离的贡献过大，而其他自变量的贡献过小，从而影响模型的准确性。 因此，对于上述情况，一般需要对自变量进行归一化或标准化，以保证自变量之间的相对大小关系不变，从而提高模型的准确性和稳定性。常用的归一化方法有最小-最大缩放法和Z-score标准化法，常用的标准化方法有Z-score标准化法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0c3c9a62ae485f236eff9d671f2c17/" rel="bookmark">
			爬虫概念简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫简述 ⼀、什么是爬虫？二、爬虫有什么用?三、爬虫的分类四、所谓的“爬虫学的好，牢饭吃到饱 !”五、爬虫的大致流程 ⼀、什么是爬虫？ ​ 简言之，爬虫可以帮助我们把网站上的信息快速提取并保存下来。
​ 我们可以把互联网比作一张大网，而爬虫 (即网络爬虫) 便是在网上爬行的蜘蛛(Spider)。把网上的节点比作一个个网页，爬虫爬到这个节点就相当于访问了该网页，就能把网页上的信息提取出来。我们可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网页的数据就可以被抓取下来了。
二、爬虫有什么用? 比如，我们在网上看到了很多精美的图片，想要保存下来，但是一次次的右键另存为就显得非常的费时费力，那么我们就可以利用爬虫将这些图片快速的抓取下来，极大地节省时间和精力。比如，我们想收集一些新闻内户上的新闻，看一下每天都发生了哪些事情，我们可以写个爬虫把新闻爬取下来，每天运行一次或者设置定时任务定时运行，这样我们可以不用进入网页就能看到新闻，也可以根据关键词进行热点分析。 另外，大家抢过的火车票、演唱会内票、茅台等等都可以利用爬虫来实现，所以说爬虫的用处十分强大
三、爬虫的分类 我们常见的爬虫有通用爬虫和聚焦爬虫
通用爬虫：针对于百度、谷歌、必应这类搜索引擎类的爬虫程序聚焦爬虫：又名定向爬虫，就是我们平时写的针对某个需求或者某个问题而写的程序 四、所谓的“爬虫学的好，牢饭吃到饱 !” ​ 时不时冒出一两个因为爬虫入狱的新闻，是不是爬虫是违法的呀，爬虫目前来说是灰色地带的东西，所以大家还是要区分好 ，避免牢底坐穿 !
​ 网上有很多关于爬虫的案件，就不一一截图，大家自己上网搜索吧。
​ 有朋友说，“为什么我学个爬虫都被抓，我犯法了吗?”
​ 这个目前还真的不好说，主要是什么，目前爬虫相关的就只有一个网站的 robots协议，这个robots是网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，也就是说robots.txt是搜索引擎访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它首先会检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。
​ 也就是说robots协议是针对于通用爬虫而言的，而聚焦爬虫(就是我们平常写的爬虫程序) 则没有一个严格法律说禁止什么的，但也没有说允许，所以目前的爬虫就处在了一个灰色地带，这个robots协议也就仅仅起到了一个”防君子不防小人“的作用，而很多情况下是真的不好判定你到底是违法还是不违法的。所以大家使用爬虫尽量不从事商业性的活动吧。
例：以百度为例
​ 在网站后添加/robots.txt：https://www.baidu.com/robots.txt；
​ 规定了哪些爬虫不允许爬取哪些页面
五、爬虫的大致流程 获取网页
​ 爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。
​ 我们用浏览器浏览网页时，其实浏览器就帮我们模拟了这个过程，浏览器向服务器发送了一个个请求，返回的响应体便是网页源代码，然后浏览器将其解析并呈现出来。所以，我们要做的爬虫其实就和浏览器类似，将网页源代码获取下来之后将内容解析出来就好了，只不过我们用的不是浏览器，而是 Python。
​ 刚才说，最关键的部分就是构造一个请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样用 Python 实现呢?
​ Python 提供了许多库来帮助我们实现这个操作，如urllib、requests等。我们可以用这些库来实现 HTTP 请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的 body 部分即可，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。
提取信息
​ 获取网页的源代码后，接下来就是分析网页的源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。
​ 另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS 选择器或 XPath 来提取网页信息的库，如 BeautifulSoup4、pyquery、Ixml 等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。
​ 提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理、清晰，以便我们后续处理和分析数据。
保存数据
​ 提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为TXT文件或JSON文件，也可以保存为我们常用的CSV文件或Excel文件，还可以保存到数据库，如 MySOL 和 MongoDB 等，这个需要看你自己的具体需求，怎样再提取数据方便就保存为什么样的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbe6672c4e3f7caaafd62d7a5162351/" rel="bookmark">
			什么叫并行处理?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并行处理是一种计算机处理的范式，其中多个计算任务被同时执行，以提高整体系统的性能和效率。在并行处理中，计算机系统能够同时处理多个任务或子任务，而不是按照传统的顺序执行。
并行处理的基本思想是将一个大问题分解成多个小问题，并通过同时处理这些小问题来加速整体计算过程。这可以通过以下几种方式实现：
数据并行处理： 将数据划分为多个部分，每个处理单元负责处理其中的一部分数据。这种方式通常用于处理大规模数据集。
任务并行处理： 将整个任务分解为多个子任务，每个处理单元负责执行其中的一个子任务。这种方式通常用于处理复杂的计算任务。
流水线并行处理： 将任务分为多个阶段，每个阶段由不同的处理单元执行。每个处理单元在完成一个阶段后将结果传递给下一个处理单元。
模型并行处理： 将一个复杂的计算模型拆分成多个部分，每个处理单元负责执行其中的一部分。这在深度学习等领域中常见。
指令级并行处理： 在单个指令中同时执行多个子操作，通常通过超标量和超流水线的方式来实现。
并行处理可以在多个处理器、多核处理器、GPU（图形处理单元）等硬件平台上实现。它有助于提高计算速度、处理大规模数据、加速科学模拟、优化图形渲染等应用。
然而，并行处理也面临一些挑战，包括任务分割和分配、数据同步、通信开销等问题。有效的并行算法设计和合理的任务划分是实现良好性能的关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de80200752331ac770b798397e1af7f/" rel="bookmark">
			AI时代Python量化交易实战：ChatGPT引领新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 《AI时代Python量化交易实战：ChatGPT让量化交易插上翅膀》关键点内容简介作者简介购买链接 《AI时代架构师修炼之道：ChatGPT让架构师插上翅膀》关键点内容简介作者简介 赠书活动 《AI时代Python量化交易实战：ChatGPT让量化交易插上翅膀》 ChatGPT让量化交易师率飞起来！
金融量化交易新模式
一本专注于帮助交易师在AI时代实现晋级、提高效率的图书
书中介绍了如何使用 ChatGPT 来完成量化交易的各个环节
并通过实战案例展示了ChatGPT在实际量化交易中的应用方法
关键点 量化交易新模式：让量化交易更高效、更快捷、更完美。全流程解析：涵盖量化交易的不同应用场景，介绍从发量化交易Python语言基础、工具库、可视化库、数据采集与分析，再到量化交易、套利策略等关键环节。实战检验：ChatGPT结合多种量化交易工具及案例实操讲解，理解更加透彻。100%提高量化交易效率：揭秘ChatGPT与量化交易高效融合的核心方法论和实践经验。赠送资源：赠送教学视频及配套工具，供读者下载学习。 内容简介 本书是一本旨在帮助架构师在人工智能时代展翅高飞的实用指南。全书以ChatGPT为核心工具，揭示了人工智能技术对架构师的角色和职责进行颠覆和重塑的关键点。本书通过共计 13 章的系统内容，深入探讨AI技术在架构
设计中的应用，以及AI对传统架构师工作方式的影响。通过学习，读者将了解如何利用ChatGPT这一强大的智能辅助工具，提升架构师的工作效率和创造力。
本书的读者主要是架构师及相关从业人员。无论你是初入职场的新手架构师还是经验丰富的专业人士，本书都将成为你的指南，帮助你在人工智能时代展现卓越的架构设计能力。通过本书的指导，你将学习如何运用ChatGPT等工具和技术，以创新的方式构建高效、可靠、可扩展的软件架构。
同时，本书也适用于对架构设计感兴趣的其他技术类从业人员，如软件工程师、系统分析师、技术顾问等。通过学习本书的内容，你可以深入了解人工智能对架构设计的影响和带来的挑战，拓展自己的技术视野，提升对软件系统整体架构的理解和把握能力。
作者简介 关东升，一个在IT领域摸爬滚打20多年的老程序员、知名培训专家、畅销书作家，精通多种信息技术。曾参与设计和开发北京市公交一卡通系统、国家农产品追溯系统、金融系统微博等移动客户端项目，并在App Store发布多款游戏和应用软件。长期为中国移动、中国联通、中国南方航空、中国工商银行和天津港务局等企事业单位提供培训服务。先后出版了50多部IT图书，广受读者欢迎。
韩文锋，计算机专业本科，工程师，智慧农业和期货交易领域专家。擅长农业信息技术和期货交易风险管理，熟练使用Python、Java等编程语言。曾参与国家农产品溯源系统设计，利用区块链技术追溯农产品质量安全；主导开发iPad和Android客户端，实现消费者扫码查验源头信息。长期从事期货交易系统开发，掌握交易策略模型。利用机器学习算法，开发大豆期货交易分析系统，支持农业生产者规避市场风险。
购买链接 当当链接：http://product.dangdang.com/29658180.html京东链接：https://item.jd.com/14297538.html 《AI时代架构师修炼之道：ChatGPT让架构师插上翅膀》 架构设计新模式
一本专注于帮助架构师在AI时代
实现晋级、提高效率的图书
书中介绍了如何使用 ChatGPT 来完成架构设计的各个环节
并通过实战案例展示了ChatGPT在实际架构设计中的应用方法
关键点 架构设计新模式：让架构设计更高效、更快捷、更完美。全流程解析：涵盖架构设计的不同应用场景，介绍从编写各种文档，到应用图形图表与UML建模、设计模式、数据库设计，再到编写代码、开发软件架构等关键环节。实战检验：ChatGPT结合多种架构设计工具及案例实操讲解，理解更加透彻。100%提高架构设计效率：揭秘ChatGPT与架构设计高效融合的核心方法论和实践经验。超值资源：赠送教学视频及配套工具，供读者下载学习。 内容简介 本书是一本旨在帮助架构师在人工智能时代展翅高飞的实用指南。全书以ChatGPT为核心工具，揭示了人工智能技术对架构师的角色和职责进行颠覆和重塑的关键点。本书通过共计 13 章的系统内容，深入探讨AI技术在架构
设计中的应用，以及AI对传统架构师工作方式的影响。通过学习，读者将了解如何利用ChatGPT这一强大的智能辅助工具，提升架构师的工作效率和创造力。
本书的读者主要是架构师及相关从业人员。无论你是初入职场的新手架构师还是经验丰富的专业人士，本书都将成为你的指南，帮助你在人工智能时代展现卓越的架构设计能力。通过本书的指导，你将学习如何运用ChatGPT等工具和技术，以创新的方式构建高效、可靠、可扩展的软件架构。
同时，本书也适用于对架构设计感兴趣的其他技术类从业人员，如软件工程师、系统分析师、技术顾问等。通过学习本书的内容，你可以深入了解人工智能对架构设计的影响和带来的挑战，拓展自己的技术视野，提升对软件系统整体架构的理解和把握能力。
作者简介 关东升，一个在IT领域摸爬滚打20多年的老程序员、知名培训专家、畅销书作家，精通多种信息技术。曾参与设计和开发北京市公交一卡通系统、国家农产品追溯系统、金融系统微博等移动客户端项目，并在App Store发布多款游戏和应用软件。长期为中国移动、中国联通、中国南方航空、中国工商银行和天津港务局等企事业单位提供培训服务。先后出版了50多部IT图书，广受读者欢迎。
当当网链接：http://product.dangdang.com/29640582.html京东的链接：https://item.jd.com/13897131.html 赠书活动 🎁本次送书1~4本，【取决于阅读量，阅读量越多，送的越多】👈⌛️活动时间：截止到2023年12月30日✳️参与方式：关注博主+三连（点赞、收藏、评论） 转载自：https://blog.csdn.net/u014727709/article/details/135165054
欢迎 👍点赞✍评论⭐收藏，欢迎指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9857ace17627def2a01bb12437226cfa/" rel="bookmark">
			下一代自动驾驶系统，少不了大模型，系统调研来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了将多模态大语言模型（MLLMs）整合到下一代自动驾驶系统中的模式。
随着大语言模型 (LLM) 和视觉基础模型 (VFM) 的出现，受益于大模型的多模态人工智能系统有潜力像人类一样全面感知现实世界、做出决策。在最近几个月里，LLM 已经在自动驾驶研究中引起了广泛关注。尽管 LLM 具有巨大潜力，但其在驾驶系统中的关键挑战、机遇和未来研究方向仍然缺乏文章对其详细阐明。
在本文中，腾讯地图、普渡大学、UIUC、弗吉尼亚大学的研究人员对这个领域进行了系统调研。该研究首先介绍了多模态大型语言模型 (MLLM) 的背景，使用 LLM 开发多模态模型的进展，以及对自动驾驶的历史进行回顾。然后，该研究概述了用于驾驶、交通和地图系统的现有 MLLM 工具，以及现有的数据集。该研究还总结了第一届 WACV 大语言和视觉模型自动驾驶研讨会 (LLVM-AD) 的相关工作，这是应用 LLM 在自动驾驶领域的首个研讨会。为了进一步推动这一领域的发展，该研究还讨论了关于如何在自动驾驶系统中应用 MLLM，以及需要由学术界和工业界共同解决的一些重要问题。
综述链接：https://arxiv.org/abs/2311.12320 研讨会链接：https://llvm-ad.github.io/ Github 链接：https://github.com/IrohXu/Awesome-Multimodal-LLM-Autonomous-Driving 综述结构 多模态大语言模型(MLLM) 最近引起了广泛的关注，其将 LLM 的推理能力与图像、视频和音频数据相结合，通过多模态对齐使它们能够更高效地执行各种任务，包括图像分类、将文本与相应的视频对齐以及语音检测。此外，一些研究已经证明 LLM 可以处理机器人领域的简单任务。然而，MLLM 在自动驾驶领域的整合依然十分缓慢，我们不禁提出疑问，像 GPT-4、PaLM-2 和 LLaMA-2 这样的 LLM 是否有潜力改良现有的自动驾驶系统？
在本综述中，研究人员认为将 LLM 整合到自动驾驶领域可以在驾驶感知、运动规划、人车交互和运动控制方面带来显著的范式转变，提供以用户为中心、适应性更强、更可信的未来交通方案。在感知方面，LLM 可以利用工具学习 (Tool Learning) 调用外部 API 来访问实时的信息源，例如高精地图、交通报告和天气信息，从而使车辆更全面地理解周围环境。自动驾驶汽车可以在读取实时交通数据后，用 LLM 推理拥堵路线并建议替代路径以提高效率和安全驾驶。对于运动规划和人车交互，LLM 可以促进以用户为中心的沟通，使乘客能够用日常语言表达他们的需求和偏好。在运动控制方面，LLM 首先使控制参数可以根据驾驶者的偏好进行定制，实现了驾驶体验的个性化。此外，LLM 还可以通过解释运动控制过程的每个步骤来提供对用户的透明化。该综述预计，在未来的 SAE L4-L5 级别的自动驾驶车辆中，乘客可以在驾驶时使用语言、手势甚至眼神来传达他们的请求，由 MLLM 通过集成视觉显示或语音响应来提供实时的车内和驾驶反馈。
自动驾驶和多模态大语言模型的发展历程
自动驾驶 MLLM 的研究总结：当前模型的 LLM 框架主要有 LLaMA、Llama 2、GPT-3.5、GPT-4、Flan5XXL、Vicuna-13b。FT、ICL 和 PT 在本表中指的是微调、上下文学习和预训练。文献链接可以参考 github repo: https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9857ace17627def2a01bb12437226cfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf052e410b74f6042fb8c7d545833e8/" rel="bookmark">
			Qt下普通成员函数和静态成员函数作为回调函数的实现（替代信号与槽）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、使用信号与槽二、什么是回调函数三、使用普通成员函数作为回调函数四、使用静态成员函数作为回调函数五、示例完整代码总结 前言 在Qt中，使用信号与槽来实现不同对象之间的通信是非常方便的，这也是Qt框架中引以为傲的一项机制，这里对此不加以介绍，可以查看参考文章。在信号与槽之前，对象间的通信可以采用回调实现，接下来我们通过下面示例来学习如何将Qt下普通成员函数和静态成员函数作为回调函数来实现不同对象的通信，希望可以帮助到大家，如有错误之处，欢迎大家批评指正。
项目效果
提示：以下是本篇文章正文内容，下面案例可供参考
一、使用信号与槽 示例主界面是Widget，在其初始化函数中创建了子界面对象CallBackAdd，并在这里进行了信号与槽的连接，下面代码中可以看到信号与槽在Qt4和Qt5的写法，实现子界面点击后将输入的两个数值相加的结果发送到主界面显示出来：
下面的initWidget()函数是在主界面Widget类的构造函数中进行了调用：
//初始化界面 void Widget::initWidget() { //创建子界面对象并显示 m_addWidget = new CallBackAdd(); m_addWidget-&gt;move(500,400); //移到指定坐标防止遮挡主界面 m_addWidget-&gt;show(); //使用信号与槽 //connect(m_addWidget,SIGNAL(signal_addNum(int)),this,SLOT(slot_addNum(int))); //Qt4写法 connect(m_addWidget,&amp;CallBackAdd::signal_addNum,this,&amp;Widget::slot_addNum); //Qt5写法 } 主界面Widget类的h文件中添加槽函数：
private slots: void slot_addNum(int addNum); Widget类的cpp文件中进行定义：
//槽函数 void Widget::slot_addNum(int addNum) { ui-&gt;le_num-&gt;setText(QString::number(addNum)); } 子界面CallBackAdd类的h文件中添加信号：
signals: void signal_addNum(int addNum); CallBackAdd类的cpp文件中点击按钮后发送信号：
//按钮点击槽函数 void CallBackAdd::on_pb_add_clicked() { int num_1 = ui-&gt;le_num_1-&gt;text().toInt(); int num_2 = ui-&gt;le_num_2-&gt;text().toInt(); int addNum = num_1 + num_2; //发送信号 emit signal_addNum(addNum); } 关于信号与槽的更多介绍可以查看该文章：C++ Qt开发：如何使用信号与槽
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cf052e410b74f6042fb8c7d545833e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5709753da16ad6177beccddcb12295/" rel="bookmark">
			Arcgis pro 字段计算器 python3常用方法二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用代码块简介
举例见下图
上例：将多边形几何面积取一位小数写入【TBYBH】字段
二、常用功能块
1、按地类名称字段值，对地类代码字段赋值，代码块名称为：DLZH
调用表达式：DLZH(!DLMC!)
块代码：
def DLZH(x): if x==u"水田": return "0101" elif x==u"水浇地": return "0102" elif x==u"旱地": return "0103" else: return "非耕地" 2、按地类代码进行土地三大类分类，代码块名称为：DL3DL
DL3DL(!DLBM!)
def DL3DL(DLFL): if (DLFL =="0101" or DLFL =="0102" or DLFL =="0103" ): return "耕地" elif (DLFL == "0201" or DLFL =="0202" or DLFL =="0203" or DLFL =="0204" or DLFL =="0301" or DLFL =="0301" or DLFL =="0302" or DLFL =="0303" or DLFL =="0304" or DLFL =="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db5709753da16ad6177beccddcb12295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0562505802be058add57db64e1ea7c/" rel="bookmark">
			2024年金三银四必备面试题之自动化测试面试题及答案大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.你如何用Selenium测试？
Selenium+Maven+TestNG+Jekins
2.如何解决问题？
先思考，然后百度，考虑网速、电脑配置等原因，这题主要看重解决问题的能力和思维。
3.你是怎么开发测试框架的？
Selenium+Maven+TestNG+Jekins
4.做自动化测试的目的？
a.用来回归 b.用来监控系统稳定性 c.提高工作效率
5.PO模型是怎么做的？
pageObject ：页面层，操作层，业务层集合成case
6.如何判断case是否通过？
断言，与预期结果比较
7.你项目中有多少case，通过率怎么样？
按实际回答，上千个，一般是70-80%左右，
8.失败截图的原理是什么？
利用监听，重写TestNG的失败方法进行截图。
9.报告哪里来，主要统计什么？
报告由测试用例执行情况，如TestNG生成，主要统计成功、失败率，截图和记录日志。
10.testNG中注解有哪些
@test @BeforeSuite @AfterSuite
@BeforeTest @AfterTest
@BeforeClass @AfterClass
@BeforeMethod @AfterMethod
11.TestNG有哪些优点
TestNG的注释非常强大和方便
TestNG允许并行测试
TestNG可以给予group方式执行测试
TestNG可以生成测试报表，并且报表展示多样化，可以在其基础上自行开发测试报告，插件以及测试监听器等
12.什么是web自动化
指的是从UI界面，也就是用户界面层面进行的自动化测试，测试人员通过编程自动化的程序也就是自动化脚本实现打开界面，操作界面的业务逻辑
13.写出selenium 中你最熟悉的接口或者类
WebDriver InternetExplorerDriver FirefoxDriver ChromeDriver WebElement WebDriverWait By
14.Xpath 是什么？
是web页面元素定位的一种方式，相当于元素dom中的一个路径，可以采用绝对路径和相对路径的方式进行定位，对于定位页面元素有很大的帮助，同时需谨慎使用，当页面结果发生变化，那么定位信息也可能需要变化
15.findElement()和findElements()方法有什么区别
两个都是查找元素的方式
findElement()查找一个页面元素，只会返回WebElement对象
findElements()查找页面是所有符合匹配的元素，返回元素集合
16.登录按钮除了click方法还有其他方式吗？
submit() ,前提是input元素的type 为submit
17.简述你知道的延迟等待方式
硬性等待，也叫线程等待，通过休眠的方式完成等待如等待5秒Thead.sleep(5000)
隐式等待，通过imlicitlyWait完成延时等待，这种事针对全局设置的等待，如设置超市10秒，使用imlicitlyWait后，如果第一次没有找到元素，会在10秒之内不断循环查找元素，如果超时间10秒还没有找到，则抛出异常
显式等待，智能等待，针对指定元素定位指定等待时间，指定的范围内进行元素查找，找到元素则直接返回，超时没有找到元素则抛出异常
18.怎么对含有验证码的功能进行自动化测试
图像识，难度大，效果不好不推荐
屏蔽验证码，邀请开发处理，在测试环境，预发和正式环境恢复
万能验证码，使用复杂的其他人无法猜到的验证码
19.如何验证复选按钮是不是被选中
可以使用元素的is selected()方法，如果返回的是true则说明被选中，否则表明未被选中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f0562505802be058add57db64e1ea7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa333ff1e63f78fa67482a473408ebc/" rel="bookmark">
			【CMake保姆级教程】包含库文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、包含库文件1.1 链接静态库1.2 链接动态库1.3 链接系统动态库1.4 链接第三方动态库 总结 前言 在软件开发中，使用库文件和记录日志是常见的任务。库文件（libraries）用于组织和共享代码。本教程将利用CMake，介绍如何在项目中包含库文件，让你轻松掌握这项基本技能。
一、包含库文件 在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。
1.1 链接静态库 在cmake中，链接静态库的命令如下：
link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...]) 参数1：指定出要链接的静态库的名字
可以是全名 libxxx.a
也可以是掐头（lib）去尾（.a）之后的名字 xxx
参数2-N：要链接的其它静态库的名字
比如，现在我的文件夹下面的build里面有.a静态库：
ubuntu@ubuntu-2204:~/C/csdn-cmake$ tree -L 2 . ├── a.cpp ├── bin │ └── app ├── build │ ├── app │ ├── CMakeCache.txt │ ├── CMakeFiles │ ├── cmake_install.cmake │ ├── libtestlib.a │ ├── libtestlib.so │ └── Makefile ├── CMakeLists.txt ├── include │ └── func.h └── src ├── func.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa333ff1e63f78fa67482a473408ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e3110e8d400bbae173025b6469f63d/" rel="bookmark">
			【CMake保姆级教程】制作动静态链接库、指定动静态库输出路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、动静态链接库的介绍1.1 动态链接库 (DLL)1.2 静态链接库 (LIB) 二、制作静态库三、制作动态库四、指定动静态库输出路径4.1 方式1 - 适用于动态库4.2 方式2 - 都适用 总结 前言 在软件开发中，我们经常听到动态链接库（Dynamic Link Library，DLL）和静态链接库（Static Link Library，LIB）的术语。它们是一种组织和共享代码的方式，有助于提高代码的可维护性和可重用性。本教程将使用CMake来创建动态链接库和静态链接库，为你提供一份简单易懂的指南，让你轻松理解这两种库的概念和制作过程。
一、动静态链接库的介绍 1.1 动态链接库 (DLL) 动态链接库是一种包含可执行代码和数据的文件，它可以在运行时被加载和执行。这种库的主要优势在于代码的共享，多个程序可以同时使用同一个动态链接库，从而减少内存占用。在不同的操作系统中，DLL的文件后缀不同：
在Windows上，动态链接库的后缀通常是.dll（比如mylibrary.dll）。
在Linux上，通常是.so，表示共享对象（Shared Object，比如libmylibrary.so）。
在macOS上，也是.dylib，表示动态库（Dynamic Library，比如libmylibrary.dylib）。
1.2 静态链接库 (LIB) 相比之下，静态链接库在编译时被嵌入到程序中，程序在运行时不再依赖外部库。这意味着每个程序都包含其所需的所有代码，但也可能导致更大的可执行文件。静态链接库的文件后缀也因操作系统而异：
在Windows上，静态链接库的后缀通常是.lib（比如mylibrary.lib）。
在Linux上，通常是.a，表示归档文件（Archive，比如libmylibrary.a）。
在macOS上，同样是.a，表示静态库（Static Library，比如libmylibrary.a）。
二、制作静态库 在cmake中，如果要制作静态库，需要使用的命令如下：
add_library(库名称 STATIC 源文件1 [源文件2] ...) STATIC后面的为你要生成静态库的源文件
在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。
在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。
首先，我们创建一个a.cpp作为示例：
. ├── a.cpp ├── bin ├── build ├── CMakeLists.txt ├── include └── src 接下来我们在cmake里面添加上这句：
add_library(testlib a.cpp) 然后我们使用cmake和make命令
Consolidate compiler generated dependencies of target app [ 60%] Built target app [ 80%] Building CXX object CMakeFiles/testlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3e3110e8d400bbae173025b6469f63d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35026cecb943d4355ce2c8a0839f45e/" rel="bookmark">
			Git的基本命令操作超详细解析教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git基础教学 1、初始化配置2、初始化仓库3、工作区域和文件状态4、添加和提交文件5、git reset 回退版本6、git diff查看差异7、删除文件git rm8、.gitignore10、分支基础应用1、本地文件提交到远程仓库 Git：一个开源的 分布式版本控制系统，它可以在本地和远程仓库之间管理源代码和文档的版本。推荐有Linux基本命令的基础学习更佳，学起来不会枯燥、乏味。 1、初始化配置 Git安装网址
安装完成后，找到键盘Win键按下后，在开始菜单中找到刚下载好的Git Bash打开git命令行窗口，准备输入后续命令
查看Git版本，检测是否安装成功
git --version 配置用户名和邮箱，保存用户名和密码，不用每一次都输入
git config --global user.name "Deng ZJ" git config --global user.email Deng@gmail.com git config --global credentia.helper store 查看配置信息
git config --global --list 结果如下
2、初始化仓库 创建仓库一般有两种方式
1、本地直接创建一个仓库
2、远程服务器上克隆一个存在的仓库
2-1 首先创建一个文件目录，切换文件路径
mkdir learn-git cd learn-git 在本地文件目录learn-git中执行命令 git init，将这个目录变成 Git 仓库。系统命令窗口回显已经初始化了一个空的仓库，且路径行出现一个master分支
git init 输入 ls -a，即查看当前目录下的文件(包括带.的隐藏文件)，-a参数：显示隐藏文件
其中.git隐藏文件里是get仓库的组成部分，不要随意增删改查
删除仓库，master标志也会消失
rm -rf .git 2-2 新建仓库，取名为my-repo的仓库，就会在my-repo文件夹下生成仓库
git init my-repo 进入my-repo仓库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c35026cecb943d4355ce2c8a0839f45e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41fca6901747649df0d03ada107e505/" rel="bookmark">
			【CMake保姆级教程】搜索文件和包含头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、搜索文件1.1 为什么需要他1.2 搜索方式11.3 搜索方法2 二、包含头文件2.1 为什么需要他？2.2 包含头文件本质include_directories: 总结 前言 CMake是一个跨平台的开源构建系统，它通过简化和自动化项目的构建过程，使软件开发变得更加容易。在CMake中，搜索文件和包含头文件是项目中必不可少的一部分。这一过程涉及到设置源文件、查找依赖项以及正确包含头文件，这对于确保项目的可维护性和可扩展性至关重要。
在这份CMake保姆级教程中，我们将深入研究如何使用CMake搜索文件和包含头文件，使你能够更有效地管理和组织你的项目。
一、搜索文件 1.1 为什么需要他 如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用aux_source_directory命令或者file命令。
1.2 搜索方式1 例如现在的文件夹层级如下，src分为一个文件夹，那我们如果要去写源文件的路径就很麻烦，那怎么办呢：
ubuntu@ubuntu-2204:~/C/csdn-cmake$ tree -L 2 . ├── bin │ └── app ├── build │ ├── app │ ├── CMakeCache.txt │ ├── CMakeFiles │ ├── cmake_install.cmake │ └── Makefile ├── CMakeLists.txt └── src ├── func.cpp ├── func.h └── main.cpp 4 directories, 9 files 在 CMake 中使用aux_source_directory 命令可以查找某个路径下的所有源文件，命令格式为：
aux_source_directory(&lt; dir &gt; &lt; variable &gt;) dir：要搜索的目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41fca6901747649df0d03ada107e505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd42425360edf8976407afe1d2a501d3/" rel="bookmark">
			【CMake保姆级教程】定义变量、指定C&#43;&#43;标准、指定输出路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、变量1.1 为什么需要变量？1.2 set的使用1.3 使用变量 二、指定C++标准2.1 为什么需要指定C++标准？2.2 指定使用的C++标准 三、指定输出路径3.1 为什么需要指定输出路径？3.2 设置输出路径 总结 前言 CMake是一个强大的构建工具，它通过简化项目的构建和配置过程，使得跨平台开发变得更加容易。CMake使用简洁的语法和自动生成的构建文件，可以帮助开发者更轻松地管理和组织项目。在本教程中，我们将学习如何使用CMake定义变量、指定C++标准以及指定输出路径。
一、变量 1.1 为什么需要变量？ 在CMake中，变量是存储数据的容器，它们用于传递信息、控制流程，以及配置构建过程。定义变量可以提高代码的可读性和可维护性，同时也方便在不同的地方共享相同的信息。通过变量，我们可以轻松地调整配置选项、文件路径等，从而适应不同的开发环境和需求。
1.2 set的使用 # SET 指令的语法是： # [] 中的参数为可选项, 如不需要可以不写 SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 在一个文件夹中，我们有下面这些文件
. ├── build ├── CMakeLists.txt ├── func.c ├── func.h └── main.c 这2个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用set。
set(SRC_LIST main.c func.c) 比如像上面这样，前面为变量名，后面为你要赋的值
1.3 使用变量 如果你想使用变量，你需要这样${变量名}
如下所示：
cmake_minimum_required(VERSION 3.0.0) project(test) set(SRC_LIST main.c func.c) add_executable(app ${SRC_LIST}) ubuntu@ubuntu-2204:~/C/csdn-cmake$ cd build/ ubuntu@ubuntu-2204:~/C/csdn-cmake/build$ cmake .. -- The C compiler identification is GNU 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd42425360edf8976407afe1d2a501d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0fd7440041e2657349366672f14f478/" rel="bookmark">
			算法设计与分析期末知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概论
1、算法设计的目标：
（1）正确性
（2）可使用性（用户友好性）
（3）可读性
（4）健壮性
（5）高效率与低存储量需求
2、算法特性：
（1）有限性
（2）确定性
（3）可行性
（4）输入性（零个或多个输入）
（5）输出性（一个或多个输出）
3、算法和数据结构的区别和联系：
数据结构时算法设计的基础。算法的操作对象是数据结构，在设计算法时通常要构建适合这种算法的数据结构。数据结构设计主要是选择数据的存储方式，例如确定求解问题中的数据采用数组存储还是链表存储等。算法设计就是在选定的存储结构上设计一个满足要求的好算法
另外，数据结构关注的是数据的逻辑结构、存储结构以及基本操作，而算法更多的是关注如何在数据结构的基础上解决实际问题。算法是编程思想，数据结构则是这些思想的逻辑基础
4、算法设计的基本步骤：
（1）分析求解问题：确定求解问题的目标（功能）、给定的条件（输入）和生成的结果（输出）
（2）选择数据结构和算法设计策略：设计数据对象的存储结构，因为算法的效率取决于数据对象的存储表示。算法设计有一些通用策略，例如迭代法、分治法、动态规划和回溯法等，需要针对求解问题选择合适的算法设计策略
（3）描述算法：在构思和设计好一个算法后必须清楚、准确地将所设计的求解步骤记录下来，即描述算法
（4）证明算法正确性
（5）算法分析：同一问题的求解算法可能有多种，可以通过算法分析找到好的算法。一般来说，一个好的算法应该比同类算法的时间和空间效率高
5、算法的执行时间主要与问题规模有关
6、渐进符号：
二、递归
1、递归的定义：
在数学与计算机科学中，递归是指在函数的定义中又调用函数自身的方法。若p函数定义中调用p函数，称之为直接递归；若p函数定义中调用q函数，而q函数定义中又调用p函数，称之为间接调用（任何间接递归都可以等价地转化为直接递归）。
2、能够用递归解决的问题应该满足以下三个条件：
（1）需要解决的问题可以转化为一个或多个子问题来解决，而这些子问题的求解方法与原问题完全相同，只是在数量规模上不同
（2）递归调用的次数必须是有限的
（3）必须有结束递归的条件来终止递归
3、何时使用递归：
（1）定义是递归的：
eg.求n！和斐波那契（Fibonacci）数列
（2）数据结构是递归的：
eg.单链表、二叉树的二叉链存储结构
（3）问题的求解方法是递归的：
eg.汉诺塔问题
4、递归算法的执行过程：
（1）递归执行是通过系统栈实现的
（2）每递归调用一次就需将参数、局部变量和返回地址等作为一个栈元素进栈一次，最多的进栈元素个数称为递归深度，n越大，递归深度越深
（3）每当遇到递归出口或本次递归调用执行完毕时需要退栈一次，并恢复参数值等，当全部执行完毕时栈应该为空
5、这种自上而下将问题分解，再自下而上求值、合并，求出最后问题解的过程称为递归求解过程，它是一种分而治之的算法设计方法
6、提取递归模型的基本模型：
（1）对原问题f(sn)进行分析，抽象出合理的小问题f(sn-1)（与数学归纳法中假设n＝k-1时等式成立相似）
（2）假设f(sn-1)是可解的，在此基础上确定f(sn)的解，即给出f(sn)与f(sn-1)之间的关系（与数学归纳法中求证n=k时等式成立的过程相似）
（3）确定一个特定情况（如f(0)或f(1)）的解，由此作为递归出口（与数学归纳法求证n = 1或n = 0时等式成立相似）
7、用递归树求解递归方程：
8、用主方法求解递归方程：
主方法中递归方程的一般形式：T(n) = aT(n/b) + f(n)
三、分治法
1、分治法所能解决的问题具有的特征：
（1）该问题的规模缩小到一定的程度就可以容易地解决
（2）该问题可以分解为若干个规模较小的相似问题
（3）利用该问题分解出的子问题的解可以合并为该问题的解
（4）该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题
2、分治法的求解步骤
（1）分解成若干个子问题：将原问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题
（2）求解子问题：若子问题规模较小，容易被解决，则直接求解，否则递归地求解各个子问题
（3）合并子问题：将各个子问题的解合并为原问题的解
3、寻找两个等长有序序列的中位数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0fd7440041e2657349366672f14f478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576451215ecfd6acad9da74e8a52f765/" rel="bookmark">
			STM32CubeMX安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、STM32CubeMX下载 官网地址：STM32CubeMX - STM32Cube初始化代码生成器 - 意法半导体STMicroelectronics
官网下载需要注册账号
网盘链接（6.8）：
链接：https://pan.baidu.com/s/1kiSD3hMxjB7ds3zk093eug?pwd=yvpq
提取码：yvpq
二、JRE下载、安装 这里STM32CubeMX使用需要JRE环境，不过现在JRE已经集成到JDK中了，不需要单独安装，所以这里直接下载JDK即可
链接：https://pan.baidu.com/s/1IuYbyeED61E9qa8hRWcl1w?pwd=bq03
提取码：bq03
由于不需要编写Java程序，所以这里的安装一切默认【或者中间修改一下安装路径】，不需要配置环境变量
三、CubeMX安装 一切默认，中间只需要更换一下安装路径
四、基本配置 1.更改存放芯片包的位置 打开软件，点击【Help】-&gt;【Updater Settings】
2.安装芯片包 点击【Help】-&gt;【Manage embedded software packages】
选择自己的开发版型号，进行安装
等待安装
安装完成后，芯片前面会变绿
五、测试 1.基本配置 新建项目,【file】-&gt;【new project】
选择芯片
芯片配置：RCC、SYS、GPIO、时钟
RCC:
SYS:
GPIO:
在右侧芯片图中点击PA2引脚，并设置为Output
在左侧进行引脚具体参数配置
时钟
2.文件生成 选择文件路径，选择【MDK-ARM】，版本为【V5】
设置生成文件
3.最终生成文件 4.打开文件，编译测试 打开工程后，找到main函数，在while循环中添加下列代码
HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin); HAL_Delay(1000); 烧录下载程序，LED灯闪烁
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a043ffa1a55a69280293dadeb51149a1/" rel="bookmark">
			计算机软考有哪些科目？都考什么内容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软考初级科目
1、程序员
考核内容：计算机相关基础知识；基本数据结构和常用算法；C程序设计语言以及C++、JAVA中的一种程序设计语言。
岗位描述：从事软件开发和调试工作的初级技术人员。
2、网络管理员
考核内容：计算机系统、网络操作系统、数据通信的基础知识；计算机网络的相关知识；以太网的性能、特点、组网方法及简单管理；主流操作系统的安装、设置和管理方法；Web网站的建立、管理与维护方法；交换机和路由器的基本配置。
岗位描述：从事小型网络系统的设计、构建、安装和调试、中小型局域网的运行维护和日常管理，构建和维护Web网站的初级技术人员。
3、信息处理技术员
考核内容：信息技术的基本概念；计算机的组成、各主要部件的功能和性能指标；操作系统和文件管理的基本操作；文字处理、电子表格、演示文稿和数据库应用的基本知识和基本操作Internet及常用软件的基本操作。
岗位描述：从事信息收集、存储、加工、分析、展示等工作，并对计算机办公系统进行日常维护的初级技术人员。
4、信息系统运行管理员
考核内容：计算机系统的组成及主要设备的基本性能指标；操作系统、数据库系统、计算机网络的基础知识；多媒体设备、电子办公设备的安装、配置和使用；信息处理基本操作；信息化及信息系统开发的基本知识。
岗位描述：从事信息系统的运行管理、安装和配置相关设备，熟练地进行信息处理操作，记录信息系统运行文档，处理信息系统运行中出现的常见问题的初级技术人员。
5、网页制作员
考核内容：Internet、网页、网站的基本知识；HTML语言及其应用；CSS及其应用；网站设计的步骤、原则、布局等知识；使用Photoshop进行平面设计的基本方法和技巧；使用Flash进行动画设计的基本方法和技巧。
岗位描述：从事网站结构与内容的策划与组织，网站的页面设计及美观优化，网站栏目内容的采编与日常维护的初级技术人员。
6、电子商务技术员
考核内容：现代电子商务的定义、作用、特点；电子商务模式；网络营销的定义和内容；现代电子商务的相关技术基础；电子商务网站的维护和管理；电子商务安全的概念和技术基础；电子支付技术。
岗位描述：从事电子商务网站的维护和管理，网络产品营销策划的初级技术人员。
7、多媒体应用制作技术员
考核内容：计算机相关基础知识；多媒体数据获取、处理及输出技术；数字音频编辑；动画和视频的制作；多媒体制作工具的使用。
岗位描述：从事多媒体系统制作的初级技术人员。
软考各科目“籽料”分享
二、软考中级科目
1、软件评测师
考核内容：操作系统、数据库、中间件、程序设计语言、计算机网络基础知识；软件工程知识；软件质量及软件质量管理基础知识；软件测试标准、测试技术及方法；软件测试项目管理知识。
岗位描述：从事软件测试工作的中级技术人员。
2、软件设计师
考核内容：计算机相关基础知识；常用数据结构和常用算法；C程序设计语言，以及C++、JAVA中的一种程序设计语言；软件工程、软件过程改进和软件开发项目管理的基础知识；软件设计的方法和技术。
岗位描述：从事软件设计与开发工作的中级技术人员。
3、网络工程师
考核内容：计算机系统、网络操作系统、数据通信的基础知识；计算机网络的相关知识，包括计算机网络体系结构和网络协议、计算机网络互联技术、网络管理和基本原理和操作方法、网络安全机制和安全协议；网络系统的性能测试和优化技术，以及可靠性设计技术；网络新技术及其发展趋势。
岗位描述：从事计算机网络系统的规划、设计，网络设备的软硬件安装调试，网络系统的运行、维护和管理的中级技术人员。
4、多媒体应用设计师
考核内容：多媒体计算机的系统结构；多媒体数据获取、处理及输出技术；多媒体数据压缩编码及其适用的国际标准；多媒体应用系统的创作过程，包括数字音频编辑、图形的绘制、动画和视频的制作、多媒体制作工具的使用等。
岗位描述：从事多媒体系统的设计、制作和集成的中级技术人员。
5、嵌入式系统设计师
考核内容：嵌入式系统的硬软件基础知识；嵌入式系统需求分析方法；嵌入式系统设计与开发的方法及步骤；嵌入式系统实施、运行、维护知识；软件过程改进和软件开发项目管理等软件工程基础知识；系统的安全性、可靠性、信息技术标准以及有关法律法规的基本知识。
岗位描述：从事嵌入式系统的设计、开发和调试的中级技术人员
6、电子商务设计师
考核内容：电子商务基本模式、模式创新及发展趋势；电子商务交易的一般流程；电子支付概念；现代物流技术和供应链技术；电子商务网站的运行、维护和管理；电子商务相关的经济学和管理学基本原理、法律法规等。
岗位描述：从事电子商务网站的建立、维护、管理和营销的中级技术人员。
7、系统集成项目管理工程师
考核内容：信息系统集成项目管理知识、方法和工具；系统集成项目管理工程师职业道德要求；信息化知识；信息安全知识与安全管理体系。
岗位描述：从事信息系统项目管理的中级管理人员、中级项目经理等。
8、信息系统监理师
考核内容：信息系统工程监理知识、方法和工具；信息系统工程监理师的职业道德要求；信息系统工程监理的有关政策、法律、法规、标准和规范。
岗位描述：从事信息系统监理的中级技术人员
9、数据库系统工程师
考核内容：数据库系统基本概念及关系理论；常用的大型数据库管理系统的应用技术；数据库应用系统的设计方法和开发过程；系统库系统的管理和维护方法。
岗位描述：从事数据库系统设计、建立、运行、维护的中级技术人员。
10、信息系统管理工程师
考核内容：信息化和信息系统基础知识；信息系统开发的的基本过程与方法；信息系统管理维护的知识、工具与方法。
岗位描述：从事对信息系统的功能与性能、日常应用、相关资源、运营成本、安全等进行监控、管理、评估、提出系统改进建议的中级技术人员。
11、信息安全工程师
考核内容：信息安全的基本知识；密码学的基本知识与应用技术；计算机安全防护与检测技术；网络安全防护与处理技术；数字水印在版权保护中的应用技术；信息安全相关的法律法规和管理规定。
岗位描述：从事信息系统安全设施的运行维护和配置管理，处理信息系统一般安全风险问题的中级技术人员。
12、计算机辅助设计师
考核内容：计算机相关基础知识；计算机辅助设计的基本知识；相关计算机辅助设计软件的使用；属性、图块与外部参照在图形绘制中的应用；图形的着色和渲染。
岗位描述：运用相关计算机辅助设计软件从事机械设计、数字制图的中级技术人员。
13、信息技术支持工程师
考核内容：信息技术知识；计算机硬件和软件知识；计算机日常系统安全与维护知识；文字处理、电子表格、演示文稿和数据库软件的操作’多媒体、信息检索与管理的基础知识；常用办公设备的使用方法。
岗位描述：从事计算机系统安全与维护，多媒体、信息检索与管理，熟练使用常用办公软件的中级技术人员。
14、计算机硬件技术工程师
考核内容：计算机硬件基础知识；数字电路基础，计算机原理；PCB设计；C语言和汇编语言编程技术；计算机常用故障现象和判断方法。
岗位描述：从事计算机相关硬件设计、开发和维护的中级技术人员。
15、软件过程能力评估师
考核内容：软件工程基础知识；软件过程能力评估模型；软件能力成熟度模型；软件过程及能力成熟度评估方法；相关认证认可基本规范。
岗位描述：从事软件过程能力及成熟度评估互动的中级技术人员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a043ffa1a55a69280293dadeb51149a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a90814d61921dc44a6c2552c96ccb9/" rel="bookmark">
			让你的作品更出色——词云Word Cloud的制作方法（基于python，WordCloud，stylecloud)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让你的作品更出色—— 词云Word Cloud的制作方法（基于python) 本文目录：
一、词云的简介
二、 实现原理和流程
1、制作词云流程图
2、词云实现原理
三、 实现词云的方式
1、安装词云相关模块库
2、WordCloud库
3、stylecloud库
四、总结
一、词云的简介 词云，又称文字云，英文名：Word Cloud。是文本数据的视觉表示形式。
就是对指定范围文本中出现频率较高的“关键词”予以视觉上的突出表现，从而过滤掉大量的文本信息，形成“关键词云层”或“关键词渲染”，使浏览网页者只要一眼扫过文本就可以领略文本的主题宗旨。
简单来说，我们看到的那种上面一堆大小不一的文字，有些是通过文字形成一个特定轮廓的那种图片或图像，我们称之为词云。一个好的词云可以直观地展示一个文章的主题，方便他人快速感知了解最突出的文字，同时自定义的美观样式和颜值也很能打。
词云的本质是点图，是在相应坐标点绘制具有特定样式的文字的结果。
由词汇组成类似云的彩色图形词云，用于展示大量文本数据。通常用于描述特定范围内的关键字元数据（标签），或可视化自由格式文本。 每个词的重要性以字体大小或颜色显示。
适合的数据条数：超过 30 条数据（较好效果）
二、 实现原理和流程 1、制作词云流程图 2、词云实现原理 某个词云就是指定文章内的关键字集合体。一篇文章我们可以拆分成多个关键词，然后把每个单词出现的频率进行统计。
比如《红楼梦诗词》文章中“林黛玉”出现了15次，“判词”出现了14次，“薛宝钗”出现了8次，这个次数就是词频。然后根据词频多少，把词频出现多的单词和词频出现少的单词根据不同的字体展示成图片，就实现了这个词云的功能。其中对文章内的关键词进行拆飞就叫做分词。
在这个流程中还会出现一些问题，比如拆分后的关键词中会有一些我们不想要的词，例如：“【、】、（、）。。。”这些没有多大意义的词和一些本次统计数据里不想被统计到的词，如果它们被统计进词频当中，会干扰词云生成正确的结果。我们把这些不想统计的词叫做停用词，为此可以做一个停用词的列表。
三、 实现词云的方式 目前主要有两种词云的实现库，一个是最基础的词云wordcloud，另一个是基于wordcloud实现的stylecloud。
1、安装词云相关模块库 Python中的主流词云生成器是wordcloud，该代码针对 Python 3.7、3.8、3.9、3.10、3.11 进行了测试。
wordcloud依赖于numpy and pillow，如果要预览或保存生成的词云图，matplotlib也是必须的。要显示统计中文数据，需要安装jieba分词 (中文分词)。
所以，我们需要安装下面几个模块包：
安装配置好python开发环境后，
pip install numpypip install pillowpip install matplotlibpip install jiebapip install wordcloudpip install stylecloud 2、WordCloud库 （1）、制作简单文本内容词云 安装好相关的python库后，我们创建一个p10.py的python文件，输入下面的代码
#-*- coding: UTF-8 -*- from wordcloud import WordCloud # 词云的文本内容 text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1a90814d61921dc44a6c2552c96ccb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a1f11900bddfa52eed74d697737656/" rel="bookmark">
			电脑文件vcruntime140.dll找不到要怎么去修复？vcruntime140.dll解决方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遭遇“vcruntime140.dll缺失”的提示是电脑使用者可能常常面临的一项技术问题，而且它通常发生在尝试安装或运行某个特定软件时。由于这种问题可能频繁出现，掌握如何处理此类DLL文件错误显得尤为重要。这不仅有助于我们在遇到相似问题时能够迅速对症下药，还可以减少在紧要关头因技术障碍带来的工作或娱乐方面的打扰。今天我们就来详细的了解一下vcruntime140.dll文件以及缺失vcruntime140.dll的解决方法吧。
一.vcruntime140.dll的作用 vcruntime140.dll是微软 Visual C++ Redistributable for Visual Studio 2015 的一部分。这个动态链接库（DLL）文件主要是用于支持使用 Visual C++ 开发的应用程序在运行时所需的运行时环境。
具体来说，vcruntime140.dll 提供了一系列函数和组件，用于处理应用程序的运行时行为，例如内存管理、异常处理、线程管理等。它包含了 Visual C++ 运行时库中的一些关键功能，以确保应用程序能够正常运行并与操作系统进行良好的交互。
当遇到缺少或损坏 vcruntime140.dll 的错误时，通常会导致无法正确启动相关应用程序，并显示类似于 "vcruntime140.dll 丢失" 或 "无法找到 vcruntime140.dll" 的错误提示。
二.修复vcruntime140.dll找不到的方法 第一种方法： 建议你看看你电脑有没有装 Visual C++ Redistributable，如果有，那么就卸载掉，并安装最新的 Visual C++ Redistributable 软件包以更新相关组件。记住可以去官网去下载，别去乱七八糟的地方下载，这东西是有官网的。其修复的理由是vcruntime140.dll是微软 Visual C++ Redistributable for Visual Studio 2015，只要我们安装了Visual C++ Redistributable，自然也能修复vcruntime140.dll这个文件。
第二种方法： 使用dll修复工具，这个工具主要是用于dll文件缺失的时候的，它会帮你检测你的电脑系统，看丢失了什么dll文件，然后再自动的帮你下载修复你所丢失的dll文件，如你找不到vcruntime140.dll文件，那么它就会帮你下载修复vcruntime140.dll文件。操作什么也比较简单，比较适合对于一些对电脑一窍不通的人。
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
第三种方法： 更新应用程序，确保您正在运行的应用程序是最新版本。开发者可能已经解决了与vcruntime140.dll相关的问题，并在新版本中进行了修复，前往应用程序的官方网站或更新渠道，下载并安装最新版本。
第四种方法： 执行系统文件检查，使用Windows的System File Checker工具（SFC）来检查系统文件的完整性并修复受损的文件，打开命令提示符窗口（以管理员身份运行），然后输入"sfc /scannow"并按下回车键。系统将扫描并自动修复发现的任何问题。
三.修复vcruntime140.dll的注意事项 确保从官方的Microsoft网站或其他可信的来源下载Visual C++ Redistributable软件包版本，以避免下载到被篡改或感染恶意软件的文件。
选择正确的软件包，根据您的操作系统架构（32位或64位），选择相应的Visual C++ Redistributable软件包版本。安装错误的版本可能无法解决问题或导致其他兼容性问题。
关注软件兼容性，如果您的应用程序有特定的依赖关系或与特定版本的Visual C++ Redistributable软件包兼容性要求，请仔细查看开发者提供的文档，并确保安装了正确的版本。
以上就是关于修复vcruntime140.dll找不到这个问题的相关分享，希望本文能帮助到大家，大家可以根据自己的实际情况去选择修复方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a92bbad7ad96e6a14e4f3abfb173fe/" rel="bookmark">
			java.util.Date 和 java.sql.Date 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.util.Date 和 java.sql.Date 是 Java 中用于表示日期和时间的两个不同的类，它们之间有一些区别。
java.util.Date:
java.util.Date 是 Java 最早的日期时间类，引入自 JDK 1.0。它表示日期和时间，包括年、月、日、时、分、秒等信息。java.util.Date 不仅包含日期和时间信息，还包含毫秒级别的时间戳，从1970年1月1日00:00:00 GMT开始计算。import java.util.Date; Date utilDate = new Date(); java.sql.Date:
java.sql.Date 是 java.util.Date 的子类，专门用于与数据库交互，引入自 JDBC 规范。它继承自 java.util.Date，但只保留了日期部分，时间部分被截断，时、分、秒和毫秒都被设为零。在处理数据库中的日期时，通常使用 java.sql.Date，因为它在 JDBC 中有更明确的语义，表示 SQL 中的日期类型。 import java.sql.Date; Date sqlDate = new Date(System.currentTimeMillis()); 总的来说，如果你需要处理日期和时间，而不涉及数据库交互，通常使用 java.util.Date。如果你需要与数据库进行交互，尤其是在处理 SQL DATE 类型时，建议使用 java.sql.Date。
需要注意的是，随着 Java 8 的引入，推荐使用 java.time 包中的新日期时间 API，例如 java.time.LocalDate 替代 java.sql.Date，java.time.LocalDateTime 替代 java.util.Date，以提供更丰富、更灵活的日期和时间处理功能。
案例记录
如果在将数据库中的 timestamp 类型的 start_time 字段映射到 Java 实体时，start_time 字段没有包含时分秒部分，有以下几个可能的原因：
数据库中的数据格式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a92bbad7ad96e6a14e4f3abfb173fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e952929e7c233837908d5fd21a91195/" rel="bookmark">
			VuePress安装及使用——使用 Markdown 创建你自己的博客网站和电子书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、依赖环境二、vuepress 安装和使用1.初始化2.将 VuePress 安装为本地依赖3. package.json 中添加脚本4. 新建 docs 文件夹5.启动6. 效果 三、进阶使用1.新增配置文件2.安装搜索插件3.config.js 中增加配置4.效果展示5.注意 四、使用主题1.安装2. 目录结构说明（1）README.md（2）.vuepress 文件夹 3. 修改配置4. 启动5. 效果 前言 VuePress 是一个以 Markdown 为中心的静态网站生成器。你可以使用 Markdown 语法来书写内容（如文档、博客等），然后 VuePress 会帮助你生成一个静态网站来展示它们。
例如：官网的 VuePress 快速开始
就是采用 VuePress 生成的，你只需要使用 Markdown 来书写文章内容，其他的 VuePress 帮你搞定。
VuePress 相比于其他以 Markdown 为中心的静态网站生成器，如、GitBook 、docusaurus、 mdBook 、Hexo、Nuxt、VitePress、Docsify 、Docute 更加简单方便，如果你会前端你还可以自己定制主题。
一、依赖环境 Node.js ，版本需要大于等于 18.16.0包管理器，如 npm 或者 pnpm、yarn 等。 若你还没安装 Node.js，可以参考 Node.js安装与配置 进行下载安装。
二、vuepress 安装和使用 1.初始化 新建一个文件夹，我这里新建的文件夹叫 vuepress ，打开 cmd 窗口进入 vuepress 文件夹所在路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e952929e7c233837908d5fd21a91195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889e188e9ee17b2e66b20c98264766a1/" rel="bookmark">
			Cannot read properties of undefined (reading: xxxxx)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日在前端开发过程中遇到了以下报错
Cannot read properties of undefined (reading: xxxxx) 在网上搜索一些解决思路，很多都说是这个属性未定义或者名称写错了，检查后发现不是。后来调试发现，是由于两个ts文件交叉引用了，于是我做了最小错误复现：
新建了两个文件a.ts与b.ts
a.tsimport { b } from './b' export enum test { j } console.log(b) b,tsimport { test } from './a' export const b = test.j 随后构建运行a.ts，成功复现错误: uncaught TypeError: Cannot read properties of undefined (reading 'j')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8c6238cedcfb18f8c486f8dc3dd17ef/" rel="bookmark">
			使用EasyCode插件，快速生成CRUD代码的简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （先解决问题，再说一下原因，解决问题是第一步，知道问题原因避免后期出现是关键） 第一步：创建一个简单的Spring Boot项目结构 第二步：插件仓库下载EasyCode插件进行安装使用 第三步：需要使用idea自带的 Database连接自己的目标数据库（这里我使用的是国产达梦数据库） 第四步：连接成功后，选择需要操作的数据表，鼠标🖱右键选择"EasyCode"下的Generate Code 第五步：首先自定义需要存放的生成文件的目录，再进行选择需要生成哪些数据 第六步：一直点击""OK"即可
看最后生成的效果，CRUD代码基本都已生成； 还在苦苦写这些代码的小伙伴，赶快去尝试一下吧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87af8384ec3942fcf652e8ba6e9d10ae/" rel="bookmark">
			2023最新版JavaSE教程——第13天：泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、泛型概述1.1 生活中的例子1.2 泛型的引入 二、使用泛型举例2.1 集合中使用泛型2.1.1 举例2.1.2 练习 2.2 比较器中使用泛型2.2.1 举例2.2.2 练习 2.3 相关使用说明 三、自定义泛型结构3.1 泛型的基础说明3.2 自定义泛型类或泛型接口3.2.1 说明3.2.2 注意3.2.2 举例3.2.3 练习 3.3 自定义泛型方法3.3.1 说明3.3.2 举例3.3.3 练习 四、泛型在继承上的体现五、通配符的使用5.1 通配符的理解5.2 通配符的读与写5.3 使用注意点5.4 有限制的通配符5.5 泛型应用举例 一、泛型概述 1.1 生活中的例子 举例1：中药店，每个抽屉外面贴着标签
举例2：超市购物架上很多瓶子，每个瓶子装的是什么，有标签
举例3：家庭厨房中：
Java 中的泛型，就类似于上述场景中的 标签。
1.2 泛型的引入 在 Java 中，我们在声明方法时，当在完成方法功能时如果有 未知的数据 需要参与，这些未知的数据需要在调用方法时才能确定，那么我们把这样的数据通过 形参 表示。在方法体中，用这个形参名来代表那个未知的数据，而调用者在调用时，对应的传入 实参 就可以了。
受以上启发，JDK1.5 设计了泛型的概念。泛型即为 "类型参数"，这个类型参数在声明它的类、接口或方法中，代表未知的某种通用类型。
举例1： 集合类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以 在JDK5.0之前只能把元素类型设计为Object，JDK5.0时Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时指定集合元素的类型。比如：List&lt;String&gt;，这表明该 List 只能保存字符串类型的对象。使用集合存储数据时，除了元素的类型不确定，其他部分是确定的(例如关于这个元素如何保存，如何管理等)。
举例2： java.lang.Comparable 接口和 java.util.Comparator 接口，是用于比较对象大小的接口。这两个接口只是限定了当一个对象大于另一个对象时返回正整数，小于返回负整数，等于返回 0，但是并不确定是什么类型的对象比较大小。JDK5.0 之前只能用 Object 类型表示，使用时既麻烦又不安全，因此 JDK5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87af8384ec3942fcf652e8ba6e9d10ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3969b3dc7c2a6fcf9f1b1b96b9f45b55/" rel="bookmark">
			mybatis的动态sql不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 Mybatis里遍历对象集合：
有一点要注意，如果运用了 一些动态sql,比如&lt; set &gt;标签这种，来做mysql的批量更新是要我们主动去设置的,需要在配置数据库连接地址中加上&amp;allowMultiQueries=true
相应的dao
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85438efbabaa32a8eeb452fcb055d054/" rel="bookmark">
			第三章 Android界面布局与高级控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android布局管理 1.1 LinearLayout线性布局 LinearLayout是一个视图组(ViewGroup)，用于使所有子视图(视图组内的组件)在单个方向(垂直或水平)保持对齐。使用android:orientation属性指定其子视图的排列方向。
定义线性布局的标签格式如下:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:orientation="vertical" android:layout_width="wrap_content" android:layout_height="wrap_content" tools:context=".MainActivity"&gt; &lt;/LinearLayout&gt; LinearLayout的所有子视图依次堆叠，因此无论子视图有多宽，设置android:orientation="vertical"时，视图内的组件在垂直(上下)方向上排列，即每行均只有一个子视图；设置android:orientation="horizontal"时，视图内的组件水平排列，水平列表将只有一行高(最高子视图的高度加上内边距)。LinearLayout会考虑子视图之间的边距以及每个子视图的对齐方式(右对齐，居中对齐或左对齐)。
线性布局内的子视图使用布局权重调节所占空间的大小。LinearLayout使用android：layout_weight属性为各个子视图分配权重。此属性会根据视图应在屏幕上占据的空间大小，向视图分配权重值。如果拥有更大的权重值，则视图便可展开，进而填充父视图中的任何剩余空间。子视图可指定权重值，然后系统会按照子视图所声明的权重值比例，为其分配视图组中的任何剩余空间。默认权重为零。
在线性布局中，让每个子视图在垂直布局中占相同大小的屏幕高度，必须将每个视图的android:layout_height设置为“0dp”；水平布局时，让每个子视图在水平方向上占用相同的宽度，必须将每个子视图的android:layout_width设置为“0dp”（针对水平布局）。然后将每个视图的android:layout_weight设置为"1"。
示例1 设置3个按钮平分水平空间
布局文件代码如下:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/button1" android:text="Button1" android:textSize="20sp" android:layout_weight="1" android:layout_width="0dp" android:layout_height="wrap_content"/&gt; &lt;Button android:id="@+id/button2" android:text="Button2" android:textSize="20sp" android:layout_weight="1" android:layout_width="0dp" android:layout_height="wrap_content"/&gt; &lt;Button android:id="@+id/button3" android:text="Button3" android:textSize="20sp" android:layout_weight="1" android:layout_width="0dp" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; 程序运行后界面显示如下图所示
如果要让子元素使用大小不同的屏幕空间，可以为子视图分配不同的权重。例如，有三个文本字段，其中两个声明权重为1，另一个未赋予权重，则没有权重的第三个文本字段将不会扩展，并且仅占据其内容1所需的区域。另一方面，另外两个文本字段将以同等幅度进行扩展，已填充测量三个字段后仍剩余的空间。如果有三个文本字段，其中两个字段声明权重为1，而为第三个字段赋予权重2（而非0），则现声明第三个字段比另外两个字段更为重要，因此，该字段将获得总剩余空间的一半，而其他两个字段均享余下的空间。
示例2 设计SendMessage的界面布局
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:orientation="vertical" android:paddingLeft="16dp" android:paddingRight="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85438efbabaa32a8eeb452fcb055d054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2666789f294983d4b1f9a1df581bf2f/" rel="bookmark">
			STM32移植LVGL图形库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、问题1：中文字符keil编译错误
解决方法：在KEIL中Options for Target 'Flash' -&gt; C/C++ -&gt; Misc Controls添加“--locale=english”。
问题2：LVGL中显示中文字符
使用 LVGL 官方的在线字体转换工具： Online font converter - TTF or WOFF fonts to C array | LVGL
在“ Range ”选项中填入文字编码范围，以确定字体的转换范围。基本汉字的编码范围 是 0x4E00-0x9FA5 ，数字、拉丁字母、标点符号的编码范围是 0x20-0x7E。 当然也可以不写，就是你要生成的文字内容。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc55f3ec3e6c295f698864d4596ee12/" rel="bookmark">
			实现strlen函数的三种方法：1.计数器法 2.递归法 3.指针减指针法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//————————————实现strlen函数的三种方法
strlen函数工作机理：函数从第一个字符开始计算字符串中字符数，直到遇到空字符，然后返回空字符前字符总个数。
1.计数器法
计数器法应该是最常见的strlen实现方法，其基本原理就是通过计数器计算循环的次数，从而实现计算字符串长度的作用
//#include&lt;stdio.h&gt;
//#include&lt;assert.h&gt;
//int my_strlen(const char *str)
//{
// assert(str);
// int count = 0;
// while (*str++ != 0)
// {
// count++;
// }
// return count;
//}
//
//int main()
//{
// char arr[] = {"abc"};
// int ret = my_strlen(arr);
// printf("%d", ret);
// return 0;
//}为了防止字符串被改变，于是使用const来保护字符串，增加代码的健壮性 2.使用assert断言是为了防止传过来的是空指针
2.递归法
递归法的主要思想就是要判断第一字符是不是\0，如果不是就1 + 下一次函数实现，总的来说就是大事化小的思想。
//递归实现strlen
//#include&lt;stdio.h&gt;
//int my_strlen(char* str)
//{
// if ((*str) != '\0')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abc55f3ec3e6c295f698864d4596ee12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e112642d349771aa75bf3ddc2454997/" rel="bookmark">
			server SQL Server (SQLEXPRESS) 服务无法启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误出现在我卸载了2014后安装新的2022server，将登录方式改混合登录后，用sa连接报错：已成功与服务器建立连接,但是在登录前的握手期间发生错误233。
按网上教程进到管理工具发现sql server express无法启动。查看日志发现是端口被占用
因为重装过server建了新的实例，每个实例都用了1433，把多余的没用的全部禁用掉，再次启动就能正常启动了。
在更改服务器名称时还有一个容易出错的地方就是最后在更改端口时，只在第一个改名的栏中加了1433，却在最后IPAII栏的端口忘了写1433也会报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab74820e38ce55696746266d27d3b5b/" rel="bookmark">
			【Java】网络编程-TCP回显服务器代码编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面我们讲了基于UDP的网络编程
UDP回显服务器 UDP字典服务器 下面我们来讲基于TCP的回显服务编写
1、服务器 import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket; import java.util.Scanner; public class Server { private static ServerSocket socket = null; public Server(int port) throws IOException { socket = new ServerSocket(port); } public static void start() throws IOException { System.out.println("服务器端启动！"); //使用多线程的方式，可以与多个客户端连接 while (true){ Socket clientSocket = socket.accept(); Thread thread = new Thread(()-&gt;{ try { procession(clientSocket); } catch (IOException e) { throw new RuntimeException(e); } }); thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab74820e38ce55696746266d27d3b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37105811c80ba971ed2d377d4d831fc/" rel="bookmark">
			操作系统期末知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章
1、操作系统：OS是一个大型的系统软件、它负责计算机的全部软件和硬件资源的管理，并为用户提供良好的应用界面，使整个计算机系统实现高效率和高度自动化
2、操作系统的形成
1）手工操作阶段
2）批处理系统（一系列作业的序列，称之为批）
（1）单道批处理系统：一批作业以脱机方式输入到存储介质上（磁带、磁盘），系统能对这批作业一个接一个连续自动处理，因在内存上只保持一道作业，故称单道批处理系统
（2）多道程序设计技术--多道批处理系统：在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制下，相互交替执行，当某道作业因某种原因不需要CPU时，管理程序将另一道作业投入运行，这样使CPU和各种设备处于忙碌状态，从而大大提高了计算机的使用效率
（多道程序设计技术的硬件支持是：中断与通道技术、使主机与外设之间可以并行工作）
（特点：①多道②宏观上并行③微观上串行
优点：①资源利用率高②系统的吞吐量大
缺点：①有时用户的响应时间较长②交互性不好）
分时技术与分时操作系统（特点：用户有较快的响应时间、交互性好）（响应时间与就绪队列中进程数目和时间片大小有关）
3、操作系统的基本类型
1）批处理操作系统
2）分时操作系统
批处理操作系统和分时操作系统的不同点：
（1）追求的目标不同：
①批处理系统：提高系统资源利用率和作业的吞吐能力为目标
②分时系统：强调公平性，对于联机用户的立即型命令要快速响应
（2）适应作业不同：
①批处理系统：已调试好的大型作业
②分时系统：正在调试的小型作业
（3）资源利用率不同：
批处理系统可以合理安排不同负载的作业，使资源利用率达到最佳，作业可分为：以计算为主；以I/O为主；计算与I/O均衡
（4）作业控制方式不同：
①批处理系统：用户通过JCB书写作业控制流，预先提交，脱机工作
②分时系统：作业由用户从键盘输入控制命令，一交互方式联机工作
3）实时操作系统（特点：及时性和高可靠性）
4、操作系统的功能
1）处理机管理：为了提高处理机的效率，操作系统对处理机的管理采用多级调度（作业调度、进程调度、线程调度）
2）存储器管理（分区存储管理、页式存储管理、段式存储管理、段页式存储管理）
3）设备管理：
（1）设备无关性：程序中只使用设备的逻辑名，屏蔽设备的物理特性，方便用户使用
（2）设备的分配：独占型设备、共享型设备、虚拟设备、静态分配、动态分配
（3）设备传输的控制方式：程序查询方式、中断方式、DMA方式、通道方式等
（4）其它：如缓冲技术、SPOOL技术等
4）文件管理：
（1）文件的逻辑结构和物理结构
（2）磁盘空间的管理
（3）目录管理
（4）文件操作
（5）文件的安全与保护
5、操作系统的特征
1）并发性：指多个时间在同一时间间隔内发生，如：I/O操作与CPU处理重叠
2）共享性：
（1）空分复用：如内存中的多道程序、磁盘上的多个文件等
（2）时分复用：如时分系统中的CPU
并发和共享是操作系统的两个最为基本的特征，它们互为存在条件：一方面，若系统不允许并发执行，自然不存在资源共享的问题；另一方面，若不能对资源共享实施有效的管理，也将影响到并发执行
3）不确定性（异步性）：
只要运行环境相同，作业经过多次运行，都将获得相同的结果
4）虚拟性：如虚拟机、虚拟内存、虚拟设备
6、UNIX特性：
（1）UNIX系统是一个多用户、多任务的分时操作系统
（2）UNIX的系统结构可分为三部分：操作系统内核（是UNIX系统核心管理和控制中心，在系统启动或常驻内存），系统调用（供程序开发者开发应用程序时调用系统组件，包括进程管理、文件管理、设备状态等），应用程序（包括各种开发工具、编译器、网络通讯处理程序等，所有应用程序都在Shell的管理和控制下为用户服务）
（3）UNIX系统大部分是由C语言编写的，这使得系统易读、易修改、易移植
（4）UNIX提供了丰富的、精心挑选的系统调用，整个系统的实现十分紧凑、简洁
（5）UNIX提供了功能强大的可编程的Shell语言（外壳语言）作为用户界面具有简洁、高效的特点
（6）UNIX系统采用树状目录结构，具有良好的安全性、保密性和可维护性
（7）UNIX系统采用进程对换的内存管理机制和请求调页的存储方式，实现了虚拟内存管理，大大提高了内存的使用效率
（8）UNIX系统提供多种通信机制，如：管道通信、软中断通信、消息通信、共享存储器通信、信号灯通信
7、在单CPU和两台I/O设备I1、I2的多道程序设计环境下，同时投入三个作业job1、job2、job3运行，这三个作业对CPU和I/O设备的使用顺序和时间如下：
Job1:I2(30ms);CPU(10ms);I1(30ms);CPU(10ms);I2(20ms);
Job2:I1(20ms);CPU(20ms);I2(40ms);
Job3:CPU(30ms);I1(20ms);CPU(10ms);I1(10ms);
假定CPU、I1、I2都能并行工作，job1的优先级最高，job2次之，job3最低，优先级高的作业进程可以抢占优先级低的作业进程的CPU，但不能抢占I1和I2
试求：
（1）三个作业从投入到完成所需的时间
（2）从投入到完成的CPU利用率
（3）I/O设备利用率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d37105811c80ba971ed2d377d4d831fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931b715596959515f06dfc9ced2db598/" rel="bookmark">
			sar生成巡检报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sar生成巡检报告 1、概述及应用场景2、安装及使用方式 1、概述及应用场景 sar命令的全称是System Activity Reporter，即系统活动报告。它是Linux系统中sysstat包的一部分，用于收集和报告系统的各种活动数据。这些数据包括CPU使用情况、内存使用情况、磁盘I/O、进程活动等，以便管理员能够全面了解系统的运行状态。
性能监控与诊断：sar命令可以用于监控系统的性能，帮助管理员诊断系统问题。例如，通过查看CPU使用率报告，可以确定是否存在CPU瓶颈；通过查看内存使用报告，可以确定是否存在内存不足的问题。
资源优化：通过分析sar报告，管理员可以了解系统的资源使用情况，从而进行针对性的优化。例如，如果发现CPU使用率过高，可能需要调整任务调度策略或升级硬件。
故障排查：当系统出现故障时，可以使用sar命令的历史记录来分析系统的活动情况，帮助确定故障原因。例如，通过查看磁盘I/O报告，可以确定磁盘是否存在问题。
审计与报告：sar命令还可以用于生成审计报告，记录系统的活动历史。这对于合规性和安全性要求较高的环境非常有用。
2、安装及使用方式 dnf install -y sysstat 查看CPU使用情况报告：此命令将显示一个报告，其中包括每个CPU核心的平均使用率、最大使用率和最小使用率。报告还提供了空闲和用户空间的CPU时间百分比。 sar -u -h Cannot open /var/log/sa/sa22: No such file or directoryast 22是指当天的日期监控 这个是因为没有建立那sa22这个文件，这能够经过参数-o让其生成file sar -o 2 3 查看内存使用情况报告：这将显示内存使用情况的报告，包括总内存、空闲内存、缓冲区内存、共享内存等的使用情况。 sar -r -h 查看进程活动报告：这将显示进程活动的报告，包括进程的创建、终止和状态变化。此外，还可以查看每个进程的CPU时间、内存使用情况等。 sar -p -h 查看磁盘I/O报告：这将显示磁盘I/O活动的报告，包括读、写和块设备的使用情况。此外，还可以查看每个设备的平均传输速率和平均请求大小等。 sar -d -h 从文件中读取活动报告：如果之前已经使用sar命令生成了报告并保存到了文件中，可以使用此命令从文件中读取报告。 sar -f /path/to/report.sar 保存活动报告到文件：如果想要将当前的活动报告保存到文件中以供将来使用，可以使用此命令将报告保存到指定文件中。 sar -o /path/to/save/report.sar 自定义报告的时间间隔和次数：此命令每1秒收集一次CPU使用率数据，共收集10次，并将结果保存到cpu_report.txt文件中。可以根据需要自定义时间间隔和收集数据的次数。 sar -u 1 10 &gt; cpu_report.txt ==每1秒收集一次CPU使用率数据，共收集10次，并将结果保存到cpu_report.txt文件中。 查看历史报告：如果之前已经生成了多个sar报告并保存在系统中，可以使用以下命令查看历史报告： sar -r -f /path/to/history/reports/ report1 ==查看历史报告中的第一个报告。可以指定不同的报告文件进行查看。 这将从指定的历史报告文件中读取并显示内存使用情况的报告。可以通过指定不同的文件来查看历史报告中的不同报告。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/931b715596959515f06dfc9ced2db598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c86784f55576965b1e621531e093e4cd/" rel="bookmark">
			信息光学·苏显渝 第二版 | 习题 | 第一章 线性系统分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为学习记录，仅供参考，非官方解答。部分题解只点出相对应的知识点或思路。
目录 1.11.21.41.51.61.71.81.91.101.111.121.13 1.1 简要说明以下系统是否有线性和平移不变性
(1) g ( x ) = d f ( x ) d x \bm{g}(x)=\cfrac{d\bm{f}(x)}{dx} g(x)=dxdf(x)​
(2) g ( x ) = ∫ f ( x ) d x \bm{g}(x)=\int \bm{f}(x) dx g(x)=∫f(x)dx
(3) g ( x ) = ∣ f ( x ) ∣ \bm{g}(x)=|\bm{f}(x)| g(x)=∣f(x)∣
(4) g ( x ) = ∫ − ∞ + ∞ f ( α ) [ h ( x − α ) ] 2 d α \bm{g}(x)=\int_{-\infty}^{+\infty} \bm{f}(\alpha)[h(x-\alpha)]^2d\alpha g(x)=∫−∞+∞​f(α)[h(x−α)]2dα
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c86784f55576965b1e621531e093e4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d3c9b743ed941365f5c56068d14329/" rel="bookmark">
			Zookeeper集群搭建，四字命令监控，Leader选举原理以及数据如何同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java学习+面试指南：https://javaxiaobear.cn
1、集群角色 Leader： 领导者。 事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性；集群内部各个服务器的调度者。对于create、setData、delete等有写操作的请求，则要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为事务。
Follower: 跟随者 处理客户端非事务（读操作）请求（可以直接响应），转发事务请求给Leader；参与集群Leader选举投票。
Observer: 观察者 对于非事务请求可以独立处理（读操作），对于事务性请求会转发给leader处理。Observer节点接收来自leader的inform信息，更新自己的本地存储，不参与提交和选举投票。通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。
Observer应用场景：
提升集群的读性能。因为Observer和不参与提交和选举的投票过程，所以可以通过往集群里面添加observer节点来提高整个集群的读性能。
跨数据中心部署。 比如需要部署一个北京和香港两地都可以使用的zookeeper集群服务，并且要求北京和香港客户的读请求延迟都很低。解决方案就是把香港的节点都设置为observer。
2、集群架构 leader节点可以处理读写请求，follower只可以处理读请求。follower在接到写请求时会把写请求转发给leader来处理。
Zookeeper数据一致性保证：
全局可线性化(Linearizable )写入∶先到达leader的写请求会被先处理，leader决定写请求的执行顺序。
客户端FIFO顺序∶来自给定客户端的请求按照发送顺序执行。
3、三节点Zookeeper集群搭建 环境准备：三台虚拟机
192.168.65.156 192.168.65.190 192.168.65.200 条件有限也可以在一台虚拟机上搭建zookeeper伪集群
1) 修改zoo.cfg配置，添加server节点配置
# 修改数据存储目录 dataDir=/data/zookeeper #三台虚拟机 zoo.cfg 文件末尾添加配置 server.1=192.168.65.156:2888:3888 server.2=192.168.65.190:2888:3888 server.3=192.168.65.200:2888:3888 server.A=B:C:D
A 是一个数字，表示这个是第几号服务器； 集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据 就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个server。
B 是这个服务器的地址；
C 是这个服务器Follower与集群中的Leader服务器交换信息的端口；
D 是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。
2）创建 myid 文件，配置服务器编号
在dataDir对应目录下创建 myid 文件，内容为对应ip的zookeeper服务器编号
cd /data/zookeeper # 在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格） vim myid 3）启动zookeeper server集群
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7d3c9b743ed941365f5c56068d14329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ac0c7bee2b28af769d405a9ca63248/" rel="bookmark">
			Node.js实现导出图片至Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方式：ExcelJS
官方文档： https://github.com/exceljs/exceljs/blob/master/README_zh.md
安装依赖 npm install exceljs 1、通过ExcelJS来构造工作簿 我们要导出的数据，可以分为两部分，一部分是表头，一部分是数据，我们先不考虑图片的情况，先 创建工作簿，然后根据创建表头， 填充数据
创建工作簿、工作表
import Excel from 'exceljs'; const workbook = new Excel.Workbook(); const worksheet = workbook.addWorksheet('Sheet1'); 2、添加表头 Ps: 目前只介绍直接插入数组 不适用键值对 键值对详细见官方文档
直接按顺序 将需要展示的数据插入第一行
worksheet.addRow(['姓名', '年龄', '图片']); 3、获取行数据 一个小demo 需要导出的数据
const arr= [{ name: '小黑', age: '18', picUrl: 'https://img.alicdn.com/bao/uploaded/i4/2214213274944/O1CN01y0sd7D1mOP3iAtHuD-2214213274944.jpg', }, { name: '小白', age: '18', picUrl: 'https://img.alicdn.com/bao/uploaded/i3/2214213274944/O1CN01jHgP4D1mOOxXTwHNs_!!0-item_pic.jpg', }]; excel表 从左上第一个表格 坐标位置为0，0 固需要输出一个二维数组
这个时候先不管图片的数据
const excelData = test.map((item, rowIndex) =&gt; { return Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62ac0c7bee2b28af769d405a9ca63248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e55d02ca0dd22a855ea93d4b7c6cda/" rel="bookmark">
			Mybatis Flex 常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Mybatis Flex 常见用法一、枚举二、自动填充2.1 方式一：@Table 配置2.2 方式二：@Column 配置 三、分页3.1 分页统一接口3.2 实现分页接口3.3 使用 四、关联查询4.1 @RelationOneToOne：一对一4.1.1 单向关联4.1.2 双向关联 4.2 @RelationOneToMany &amp;&amp; @RelationManyToOne：一对多 和 多对一4.2.1 单向关联4.2.2 双向关联 4.3 @RelationManyToMany：多对多4.3.1 单向关联4..3.2 双向关联 4.4 ByQuery 五、多数据源5.1 配置5.1.1 application.yml （必须）5.1.2 @Table(dataSource = "slave01")（选择配置）5.1.2 @UseDataSource（选择配置） 5.3 使用 六、读写分离6.1 读写分离策略6.2 配置 七、其他5.1 逻辑删除5.2 数据脱敏 Mybatis Flex 常见用法 一、枚举 枚举类
@Getter @AllArgsConstructor public enum GradeEnum { UNKNOWN(0, "未知"), SECONDARY(2, "中学"), PRIMARY(1, "小学"), HIGH(3, "高中"); @EnumValue // 数据库存储字段 private final Integer code; @JsonValue // 转 Json 字段 private final String name; } 使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2e55d02ca0dd22a855ea93d4b7c6cda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95df9d1fb2e9438bc7aaf6e1c8cbcbe5/" rel="bookmark">
			mysql统计函数round失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mysql统计函数round失效问题 目录1、问题2、找到原因3、解决办法4、类似问题欢迎品论区补充~ 目录 1、问题 我的mysql版本为：8.1.0
我在mysql使用sum对数据统计后使用round函数进行四舍五入取整，发现像16.145这样的数字取小数后2位后是16.14而非16.15。
sql：
结果：
2、找到原因 发现score字段是字符串类型，于是我做了以下测试：
select round(16.125,2) from dual 执行结果为：16.13
select round('16.125',2) from dual 执行结果为：16.12
所以结论是：mysql隐式转换会有问题！
在设计表的时候，最好设置数字类型字段为DECIMAL，不然会导致后续的其他不可预料的问题！
3、解决办法 使用CAST函数对字符串进行手动转换
CAST语法为：
CAST(expression AS TYPE); type 可以有：BINARY，CHAR，DATE，DATETIME，TIME，DECIMAL，SIGNED，UNSIGNED
示例：
# 使用cast转换成DECIMAL并指定精度 select cast('16.125' as DECIMAL(10,8) ) as num # 再使用ROUND四舍五入 select round(cast('16.125' as DECIMAL ),2) from dual 4、类似问题欢迎品论区补充~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79edf58963fe5eb12d9099b55d738783/" rel="bookmark">
			ElasticSearch配置及Kibana可视化配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是ElasticSearch es是一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控，es易于扩展，可以轻松扩展到上百台服务器，处理PB（1PB=1024TB 1TB= 1024GB）级别的数据，es自身携带分布式协调管理功能，但仅支持JSON文件格式
Es理论： 1.索引： 在Es中一个索引对应一组相关文档的存储单元，可以被看作是一种类似于数据库中的表结构，用于存储相类似的文档，每个文档都属于一个索引，索引中的文档用于被搜索和分析。
2.索引分片： 索引分片是将一个完整的索引分成多个的过程，每个分片本身是一个独立的索引，拥有自己的设置、映射、文档。Es通过将索引划分为多个分片来允许大规模数据存储，并且能够水平扩张，每个分片可以分布在集群的不同节点上，默认情况下每个索引包含五个主分片。
3.索引副本： 索引副本是每个分片的一个复制品用于提供冗余和故障的回复副本分布在不同的节点上从而增加了系统的可靠性和容错能力。
ElasticSearch核心概念 1.节点 节点是集群中的单个服务器，用于存储数据并参与集群的索引和搜索功能。每个节点都有自己的名称和唯一标识符。
2.集群 集群是由一个或多个节点组成的一组服务器，它们共同存储项目的整个数据，集群提供可高可用性和横向扩展性。
3.分片和复制 分片是将索引中的数据分割成多个部分，用于提高性能和扩展性每个分片可以被存储在集群中的一个或多个节点上。
复制是为了数据的高可用性和容错性，每个分片都会有一个或多个副本分片，这些分片会被存储在不同的节点上。
4.索引 索引是用于存储数据的地方类似于关系型数据库中的数据可以，它是一种用于存储相似性质的文档的数据结构。
5.类型 类型在ES6.0之前用于组织索引内部文档的一种方式。在ES7.0之后已经被废弃，推荐使用单一索引引用字段代替。
6.文档 文档是ES中的基本数据单元，类似于关系型数据库中的行，每个文档都是一个JSON对象，它们被存储在索引中并可以被搜索。
7.字段 字段是ES中文档的组成部分，类似于关系型数据库中的列，每个字段都有自己的数据类型（文本型、数值型等），并且包含特定的数据。
8.映射 映射定义了索引中的，每个字段的数据类型和属性，它相当于关系型数据库中的模式，告诉ES如何处理索引的每个字段。
创建索引 PUT /baidu { "settings": { "number_of_shards": 2,//主分片 "number_of_replicas": 2//副分片 }, "mappings": { "properties": { "title":{ "type": "text" } } } } 添加文档 POST /my_es/_doc { "title":"震惊，某男子竟于小猪干这件事。。。。", "content":"男子天天给小猪吃昂贵的水果，小猪更可爱了", "author":"王五", "time":"2023-12-18T11:44:20" } 查询所有 GET /my_es/_search 语法规则 _doc：用于早期的ES版本中同一个索引中单独集合映射类型。从8.x版本开始已全面废弃。
_index：创建新索引、是创建一个命名空间将相关文档聚合在一起
_create：创建新索引、是创建一个新的文档并将其添加到指定索引中
_update：用于更新文档中的一部分类容
_delete：删除文档
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79edf58963fe5eb12d9099b55d738783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2381421a95a8129710ef7000aa908d/" rel="bookmark">
			【2023年】F题和E题——基于声传播的智能定位系统/运动目标控制与自动追踪系统——舵机云台方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【2023年】F题_基于声传播的智能定位系统——舵机云台代码 PCA9685JetsonNano树莓派 代码基于JetsonNano和树莓派 二选一使用即可 使用了PCA9685 PCA9685 PCA9685是一款i2c总线控制的16通道LED控制器，针对LCD进行了优化
红/绿/蓝/琥珀色(RGBA)颜色背光应用。每个LED输出都有它的
拥有12位分辨率(4096步)固定频率的单独PWM控制器
可编程频率从典型的40hz到1000hz，占空比为
从0%到100%可调，以允许LED设置到特定的亮度值。
所有输出设置为相同的PWM频率。
每个LED输出可以关闭或打开(无PWM控制)，或设置在其单独的PWM控制器
价值。LED输出驱动器被编程为开漏，电流为25毫安
吸收能力在5v或图腾柱与25毫安的吸收，10毫安的源能力在5v。的
PCA9685工作电源电压范围为2.3 V至5.5 V，输入和
输出容忍5.5 V。可直接连接LED输出(最多可达
25 mA, 5.5 V)或控制与外部驱动器和离散的最小量
组件用于更大电流或更高电压的led。
PCA9685是新的快速模式Plus (Fm+)系列。Fm+设备提供更高
频率(高达1mhz)和更密集的总线操作(高达4000pf)
驱动代码为：
#!/usr/bin/python import time import math import smbus # ============================================================================ # Raspi PCA9685 16-Channel PWM Servo Driver # ============================================================================ class PCA9685: # Registers/etc. __SUBADR1 = 0x02 __SUBADR2 = 0x03 __SUBADR3 = 0x04 __MODE1 = 0x00 __MODE2 = 0x01 __PRESCALE = 0xFE __LED0_ON_L = 0x06 __LED0_ON_H = 0x07 __LED0_OFF_L = 0x08 __LED0_OFF_H = 0x09 __ALLLED_ON_L = 0xFA __ALLLED_ON_H = 0xFB __ALLLED_OFF_L = 0xFC __ALLLED_OFF_H = 0xFD def __init__(self, address=0x40, debug=False): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db2381421a95a8129710ef7000aa908d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48dfb1131aa2b17106f10e7dcabc5bb/" rel="bookmark">
			2023最新版JavaSE教程——第12天：集合框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、集合框架概述1.1 生活中的容器1.2 数组的特点与弊端1.3 Java集合框架体系1.4 集合的使用场景 二、Collection接口及方法2.1 添加2.2 判断2.3 删除2.4 其它 三、Iterator(迭代器)接口3.1 Iterator接口3.2 迭代器的执行原理3.3 foreach循环 四、Collection子接口1：List4.1 List接口特点4.2 List接口方法4.3 List接口主要实现类：ArrayList4.4 List的实现类之二：LinkedList4.5 List的实现类之三：Vector4.6 练习 五、Collection子接口2：Set5.1 Set接口概述5.2 Set主要实现类：HashSet5.2.1 HashSet概述5.2.2 HashSet中添加元素的过程：5.2.3 重写 hashCode() 方法的基本原则5.2.4 重写equals()方法的基本原则5.2.5 练习 5.3 Set实现类之二：LinkedHashSet5.4 Set实现类之三：TreeSet5.4.1 TreeSet概述5.4.2 举例5.4.3 练习 六、Map接口6.1 Map接口概述6.2 Map中key-value特点6.2 Map接口的常用方法6.3 Map的主要实现类：HashMap6.3.1 HashMap概述6.3.2 练习 6.4 Map实现类之二：LinkedHashMap6.5 Map实现类之三：TreeMap6.6 Map实现类之四：Hashtable6.7 Map实现类之五：Properties 七、Collections工具类7.1 常用方法7.2 举例7.3 练习 一、集合框架概述 1.1 生活中的容器 1.2 数组的特点与弊端 一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用数组存储对象方面具有 一些弊端，而 Java 集合就像一种容器，可以 动态地 把多个对象的引用放入容器中。
数组在内存存储方面的 特点： 数组初始化以后，长度就确定了。数组中的添加的元素是依次紧密排列的，有序的，可以重复的。数组声明的类型，就决定了进行元素初始化时的类型。不是此类型的变量，就不能添加。可以存储基本数据类型值，也可以存储引用数据类型的变量 数组在存储数据方面的 弊端： 数组初始化以后，长度就不可变了，不便于扩展数组中提供的属性和方法少，不便于进行添加、删除、插入、获取元素个数等操作，且效率不高。数组存储数据的特点单一，只能存储有序的、可以重复的数据 Java 集合框架中的类可以用于存储多个 对象，还可用于保存具有 映射关系 的关联数组。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48dfb1131aa2b17106f10e7dcabc5bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0ce2bc415cefcfcb01838e970d4e72/" rel="bookmark">
			【藏经阁一起读】（81）__《云原生节点管理最佳实践白皮书》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【藏经阁一起读】（81）__《云原生节点管理最佳实践白皮书》 云原生节点管理最佳实践白皮书
作者： 小龙、彭媛洪、陈海
发布时间：2023-11-15
章节数：25
一、云原生节点管理模式产生背景 随着云计算应用的普及，Kubernetes集群规模迅速增加，同时节点管理的重要性也日益凸显。作为云原生架构的关键组成部分，节点管理直接影响着整个云原生应用的稳定性和性能。然而，现有的基础架构管理方法更倾向于虚拟机管理，并缺乏对工作负载的深度感知，无法适应大规模节点管理的要求。为了应对大规模节点管理场景，云原生节点管理模式应运而生。
在云原生的浪潮下， Kubernetes 集群在规模和数量上快速增长， 进而使得在大规模集群中，节点管理的重要性日益突出。在这样的环境下，高效 的节点管理成为确保集群稳定性、性能优化和资源利用率最大化的关键因素。
计算节点作为云原生架构的关键组成部分，节点的管理直接影响着整个云原生应 用的成本和稳定性。然而，现有的基础架构管理方法更偏向于传统的虚拟机管理 理念，缺乏对工作负载的深度感知，无法适应大规模集群的节点管理要求。 面对大规模的节点管理的场景，越来越多的人愿意尝试云原生式的节点管理模式。 云原生节点管理是基于云原生理念，使用专为此目的设计的操作系统底座 ContainerOS 和配套基础设施，提供的一种有效的节点管理方案。这种新的管 理方案旨在优化云上环境的大规模节点的管理成本，并同时提供更佳的弹性、灵 活性、稳定性和安全性。
Kubernetes 是开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。 Kubernetes 的基本架构由几个核心组件组成。
二、云原生节点的定义 Worker 节点（简称节点）是构建云原生应用平台的基础，承载着管理容器生命周期和物 理资源的重要任务。
节点职责： ♦ 提供容器运行环境：节点使用容器运行时来处理容器的创建、启动、停止和销毁。通过 全生命周期管理，使容器能够始终保持在期望状态。♦ 合理分配资源：节点负责为工作负载分配所需的运行资源。包括计算资源（如 CPU 和 内存）、持久化存储和网络资源等。通过合理的资源分配，节点不仅能够满足容器的运 行需求，更能保证不同容器间的资源隔离。♦ 提供高可用和故障恢复：节点应具备基本的高可用和故障恢复能力，在可预料的异常发 生时，主动干预使工作负载向期望状态靠拢，以提供基础的稳定性和可靠性 节点局限性 ♦ 单节点无法解决非预期的错误，比如容器运行时的异常，节点的恢复手段十分有限。并且由于缺乏全局视角，在集群容量不足时，因单节点的故障导致整个集群的雪崩也时有发生。♦ 由于宿主节点自身的管理并没有被 Kubernetes 集群标准化，随着集群规模变得庞大时，千奇百怪的手动运维操作，极易使 得集群中节点的配置存在差异，加剧环境腐化。 三、云原生节点管理 云原生节点管理是指在云上环境中，利用云的弹性、可用性和计量计费等特点，最大化发挥节点的自管理能力，并通过集群化手段弥补单一节点的局限性，构建成本可控、易于管理、敏捷、安全和高可用的集群基础设施。通过云原生节点管理实践，可以有效的进行大规模集群的管理，满足不同工作负载的需求，并确保整个集群的稳定运行。这种管理实践对于构建可靠、可扩展的云原生应用平台至关重要。
节点管理成本主要涉件成本和运维成本两部分。
降低节点管理成本在构建可持续发展的云原生应用平台中十分重要。在云上环境中，我们可以利用云的标准化和弹性等特点，以通过系统化手段降低集群整体复杂度的方式，获得更可控的管理成本和更稳健的应用平台。
采用云原生节点管理实践，可以获得以下益处。 ♦ 节约计算资源成本：充分利用云上环境的极致弹性特点，对集群内的资源使用状况动态感 知，可以根据实际需求进行峰时扩容，低谷时缩容，避免资源浪费。这种灵活的资源调配 方式可以有效降低计算资源的开销，降低硬件成本。
♦ 提高运维效率：通过大规模自动化和面向终态的配置能力，减少部署和配置的复杂性。自 动化的节点管理流程可以减少人工操作的错误和时间消耗，提高运维效率，降低节点运维 成本和故障风险，使运维人员能够更专注于核心业务，提高整体运维人效。
♦ 提高可用性和安全性：一致的执行环境可以大大降低应用程序出现异常的可能性。通过节 点实时监控和节点自愈能力，可以及时发现并解决节点故障，确保应用程序的稳定运行， 减少业务中断和损失
云原生节点管理是以云原生理念为基础的实践方法论，主要目标是在满足日常运维需求的 同时，有效应地应对大规模集群节点管理的挑战。而操作系统作为节点底座，是云原生节点管理的重要组成部分。
传统操作系统在云原生场景面临的问题。 问题一：体积臃肿
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0ce2bc415cefcfcb01838e970d4e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0df1422b5c0cdc15f5ba69e597ce915/" rel="bookmark">
			【藏经阁一起读】（80）__《2023龙蜥社区白皮书》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【藏经阁一起读】（80）__《2023龙蜥社区白皮书》 2023龙蜥社区白皮书
作者： 小龙
发布时间：2023-11-15
章节数：79
内容简介：
从解决CentOS停服的问题出发为广大用户的业务连续性提供了坚定的保障，通过一云多芯、构建云原生基础设施等手段实现业务的升级，并通过拥抱人工智能等新兴技术实现操作系统面向未来的技术演进。正是在这一次次的技术革新中，龙蜥社区实现了操作系统的持续迭代和生生不息的创新发展。同时，我们通过不断扩大的朋友圈完成了越来越多的产品兼容性认证、打造了越来越丰富的上下游生态、满足了越来越广泛的用户需求。
这本书的简介里，介绍这本书是从解决CentOS停服的问题出发为广大用户的业务连续性提供了坚定的保障。。。。。CentOS 停服？CentOS 是什么？龙蜥开源操作系统又是什么？
我对龙蜥开源操作系统并不熟悉，通过查阅资料略有收获，我们从头理清一下这件事：
一、CentOS开源操作系统简介 目前全球服务器操作系统主流的代表有 Windows、Unix、Linux。Linux 服务器操作系统天然支持云计算、虚拟化和容器化等技术，又因为其源代码开放，用户可免费得到多种应用程序，因此，在服务器领域得到了广泛应用，在安全性和稳定性方面得到了用户充分的肯定。Linux 服务器操作系统在全球市场上极具竞争优势。
CentOS（Community Enterprise Operating System，社区企业操作系统）是Linux发行版之一，是免费的、开源的、可以重新分发的开源操作系统 。
CentOS Linux发行版是一个稳定的，可预测的，可管理的和可复现的平台，源于Red Hat Enterprise Linux（RHEL）依照开放源代码（大部分是GPL开源协议规定释出的源码所编译而成）。
CentOS 项目是一个由社区驱动的免费软件，提供了丰富的基础平台，供开源社区使用。它提供了两个 Linux 分发版本：CentOS Linux 和 CentOS Stream，这两者在功能上都兼容其上游来源。
CentOS 在国内有着大量的用户，几乎是所有互联网公司的标配。
2020 年，Red Hat CentOS 项目宣布，宣布未来将终止对CentOS 8 和 CentOS 7 的服务支持，包括停止对后续漏洞的更新修复。CentOS 7 将在其生命周期结束后停止维护（2024年1月30日）。CentOS 的一生走到了尽头...以后发展CentOS Stream 8。
二、CentOS 停服原因分析 红帽公司为什么要关闭 CentOS呢？我们来看一下大致的发展史：
2014年，红帽公司收购了 CentOS ，包含 CentOS 项目商标的所有权，以及大量核心开发人员，这时，旗下就有了三个主要的 Linux 发行版产品线：Fedora、RHEL、还有 CentOS 。
Fedora 作为实验版本，快速迭代更新各种新功能；而这些特性被评估为稳定版本以后则会添加到 RHEL 中；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0df1422b5c0cdc15f5ba69e597ce915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97bc0934c951663c268ebb85378a92e6/" rel="bookmark">
			ASP.NET Core基础之定时任务(二)-Quartz.NET入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文你的收获 了解任务调度框架QuartZ.NET的核心构成学会在ASP.NET Core 中使用QuartZ.NET 在项目的开发过程中，难免会遇见需要后台处理的任务，例如定时发送邮件通知、后台处理耗时的数据处理等，上次分享了ASP.NET Core中实现定时任务的第一种方式 托管服务+Timer，这种方式适用于比较简单的定时任务场景，对于更复杂的场景，我们可以使用HangFire和QuartZ.NET等成熟的任务调度框架。
这次我们对QuartZ.NET任务调度框架做一个入门。
一、什么是QuartZ.NET? Quartz.Net 是一个.NET程序集，是非常流行的 Java 作业调度系统 Quartz 的 C#实现。
Quartz.Net 是一款功能齐全的任务调度系统，从小型应用到大型企业级系统都能适用。
功能齐全体现在触发器的多样性上面，即支持简单的定时器，也支持 Cron 表达式；即能执行重复的作业任务，也支持指定例外的日历；任务也可以是多样性的，只要继承 IJob 接口即可。
对于小型应用，Quartz.Net 可以集成到你的系统中，对于企业级系统，它提供了 Routing 支持，提供了 Group 来组织和管理任务，此外还有持久化、插件功能、负载均衡和故障迁移等满足不同应用场景的需要。
二、QuartZ.NET中的核心对象 Scheduler - 调度器。与调度程序交互的主要API。IJob - 作业。你想要调度器执行的任务组件需要实现该接口 。JobDetail -用于定义作业详细信息。Trigger - 触发器。定义执行给定作业的计划的组件。JobBuilder - 用于定义/构建JobDetail 实例，用于定义作业的实例。TriggerBuilder - 用于定义/构建触发器实例。 Scheduler 的生命期，从 SchedulerFactory 创建它时开始，到 Scheduler 调用shutdown() 方法时结束；
Scheduler 被创建后，可以增加、删除和列举 Job 和 Trigger，以及执行其它与调度相关的操作（如暂停 Trigger）。
但是，Scheduler 只有在调用 start() 方法后，才会真正地触发 trigger（即执行 job）
三、入门案例 开发环境
平台版本是：.NET6
开发框架：ASP.NET Core WebApi
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97bc0934c951663c268ebb85378a92e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec452e8b50ed14469151b5347631e818/" rel="bookmark">
			spark-thrift-server 报错 Wrong FS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc]具体报错实际原因查看 hive 元数据修改 spark-thrift-server 配置修改 hive 元数据 具体报错 spark-thrift-server 执行删表语句，出现如下报错
Error: org.apache.hive.service.cli.HiveSQLException: Error running query: org.apache.spark.sql.AnalysisException: org.apache.hadoop.hive.ql.metadata.HiveException: MetaException(message:java.lang.IllegalArgumentException: Wrong FS: hdfs://RMSS02ETL:9000/user/hive/warehouse/meta_data.db/dt_segment, expected: hdfs://hadoopmaster) at org.apache.spark.sql.hive.thriftserver.SparkExecuteStatementOperation.org$apache$spark$sql$hive$thriftserver$SparkExecuteStatementOperation$$execute(SparkExecuteStatementOperation.scala:361) at org.apache.spark.sql.hive.thriftserver.SparkExecuteStatementOperation$$anon$2$$anon$3.$anonfun$run$2(SparkExecuteStatementOperation.scala:263) at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23) at org.apache.spark.sql.hive.thriftserver.SparkOperation.withLocalProperties(SparkOperation.scala:78) at org.apache.spark.sql.hive.thriftserver.SparkOperation.withLocalProperties$(SparkOperation.scala:62) at org.apache.spark.sql.hive.thriftserver.SparkExecuteStatementOperation.withLocalProperties(SparkExecuteStatementOperation.scala:43) at org.apache.spark.sql.hive.thriftserver.SparkExecuteStatementOperation$$anon$2$$anon$3.run(SparkExecuteStatementOperation.scala:263) at org.apache.spark.sql.hive.thriftserver.SparkExecuteStatementOperation$$anon$2$$anon$3.run(SparkExecuteStatementOperation.scala:258) at java.security.AccessController.doPrivileged(Native Method) at javax.security.auth.Subject.doAs(Subject.java:422) at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1746) at org.apache.spark.sql.hive.thriftserver.SparkExecuteStatementOperation$$anon$2.run(SparkExecuteStatementOperation.scala:272) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: org.apache.spark.sql.AnalysisException: org.apache.hadoop.hive.ql.metadata.HiveException: MetaException(message:java.lang.IllegalArgumentException: Wrong FS: hdfs://RMSS02ETL:9000/user/hive/warehouse/meta_data.db/dt_segment, expected: hdfs://hadoopmaster) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec452e8b50ed14469151b5347631e818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e170283672da560ebc8f62ff61207172/" rel="bookmark">
			Spring Security快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Spring Security Spring Security： Spring Security是目前Java Web领域中最流行的框架之一，它提供了一系列安全级别，包括基于认证和授权的安全保护，以及各种各样的安全校验，使得开发人员可以非常容易地为应用程序添加安全保护。Spring Security也提供了一种简单易用的方式来定制其过滤器链，以适应具体的安全需求。
（1）在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。
（2）在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。
2.工作原理和特点 原理: 认证：认证模块负责验证用户身份的合法性，生成认证令牌，并保存到服务端会话中（如TLS）。
鉴权：鉴权模块负责从服务端会话内获取用户身份信息，与访问的资源进行权限比对。
特点： 兼容性强：Spring Security是一个流行的开源框架，它可以与Spring应用程序完美集成。由于它的兼容性很好，因此可以非常方便地使用它保护Web应用程序。
功能强大：Spring Security具备众多功能，包括注销、登录、角色、权限、令牌、XSS防御、CSRF防御等等。它还支持各种身份验证、角色和权限管理方式，如基于表单的认证、基于记住我功能的认证以及OAuth认证等等。
安全可靠：Spring Security具有极高的安全性，它使用最新的安全标准和协议来保护Web应用程序。Spring Security采用安全性分层的策略来保护应用程序中的各个层，例如Web层、Service层、DAO层等等。除此之外，Spring Security还支持自定义安全策略和事件响应，从而使得开发者可以根据应用程序需求定制安全保护。
易于使用：Spring Security提供了一种高度简化的方式来保护Web应用程序。它使用简单的标签和安全注解来添加安全保护，从而使得开发者可以基本不需要手动编写代码就可以完成安全保护。
社区广泛：Spring Security是一个著名的开源框架，因此它有一个庞大的用户社区。这个社区不仅提供了大量的文档、示例和教程，而且还会解答开发者的问题、修复框架中的BUG等等。这为开发者提供了无限的支持和帮助，从而可以使用Spring Security更加自信。
3.代码实战入门 1.基于springboot创建项目 （1）导入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e170283672da560ebc8f62ff61207172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a191dcdcb8464b3afc18dd914751ab/" rel="bookmark">
			MySQL锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、全局锁 什么是全局锁
MySQL的锁定主要分为全局锁、表锁和行锁
全局锁是针对整个数据库的锁，全局锁又分为读锁和写锁。
1.读锁(共享锁)该锁会阻止其他用户更新数据库，只允许读数据库。使用该锁在一段时间内可以保持数据一致性。
2.写锁(排他锁)该锁会阻止其他用户读数据和写数据。如果在修改数据的时候不想被其他用户干扰，可以使用该锁。
使用场景：一些确保整个数据库一致性的操作，比如全库备份，全库导出。
在MySQL中可以用使用FLUSH TABLES WITH READ LOCK(FTWRL)添加全局读锁，这将阻止其他线程进行的更新操作。使用UNLOCK TABLES释放锁定。注意：全局锁的开销很大，因为它会阻止其他线程的修改操作，并且在高并发场景下会导致大量的线程等待锁定，应尽量避免在生产环境使用全局锁或减少全局锁持有的时间。
样例
此时只能读不能执行写操作
此时可以执行写操作
2、表级锁 表级锁开销小加锁快，不会出现死锁，锁定颗粒度大，出现锁冲突概率高并发度低。
在MySQL中对MyISAM读操作会自动加上读锁，对MyISAM的写操作会自动加上写锁，因为MyISAM不支持事务在高并发场景下没办法保持数据的一致性。
InnoDB在必要情况会加表锁，但主要使用行锁来实现多版本并发控制，它能够提供更好的并发性能和更少的锁冲突。
表锁读操作多，写操作少的场景。当并发高或者写操作多表锁会成为瓶颈。
哪些命令会发生锁表
ALTER TABLE修改表结构，MySQL需要锁定整张表防止在更改过程中有新的数据写入。
DROP TABLE和TRUNCATE TABLE MySQL需要锁定整张表防止在更改过程中有新的数据写入。
LOCK TABLES显式地为一个或多个表加上读锁或写锁。例如，LOCK
TABLES t1 WRITE t2 READ;命令会给表t1加上写锁，给表t2加上读锁。
全表扫描或大范围扫描`对于MyISAM存储引擎，全表扫描或大范围扫描会触发表锁。
FLUSH TABLES WITH READ LOCK(FTWRL)这个命令可以给所有表加上全局读锁，其他会话在此期间不能对数据进行修改。
加上读锁不能执行写操作。但是可以读。
加上写锁，已经卡死不能执行读操作。但是可以执行写操作。
MySQL表锁风险点
性能下降并发性能差可能导致锁等待和超时写操作影响大死锁的可能性 3、行锁 对数据库表中单独一行进行锁定。开销大加锁慢会出现死锁，锁定颗粒小出现锁冲突概率低，并发度高。
行锁只能在事务中使用，也就是说只有一个事务开始后并在事务提交或回滚之前，才能对数据进行锁定。如果在非事务环境中执行sql，那么InnoDB会在语句执行结束后立即释放所有的锁。
使用场景
高并发读写操作：在高并发读写操作场景中，行级锁可以提高性能和并发性，因为它允许多个事务并发操作不同的行。
单行操作：对单行数据进行增删改操作。
短期锁：短时间锁定某行数据，行级锁可以防止长时间阻塞其他事务。
实现并发控制：确保数据的一致性和隔离性的事务中。
复杂事务处理：对多行数据进行复杂事务处理中，可以使用行级锁来锁定这些行，防止在事务处理过程中数据被其他事务修改。
发生行锁的命令
select field from table for update：这种查询会对选定的行添加一个排他锁（X），那么其他事务就不能对这行数据执行写操作，也不能添加共享锁。 [video(video-1NuL7PQd-1702997559118)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=452384717)(image-https://img-blog.csdnimg.cn/img_convert/f3924b83fb438bca02423313f8090285.jpeg)(开启事务时为一行数据加排他锁，其他线程就不能修改该条数据，只有事务提交后其他线程才可以对该条数据执行写操作)]
select field from table lock in share dome： 添加一个共享锁（S），那么其他事务就不能对这行数据执行写操作，但能添加共享锁。insert 会自动添加排他锁（X）update 会自动添加排他锁（X）delete 会自动添加排他锁（X） 行锁的风险
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a191dcdcb8464b3afc18dd914751ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b3a84bf917d1d90e92df0de92a3c05/" rel="bookmark">
			STM32--- 蓝牙HC-08 （两模块间主从通信）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、本篇所有所用环境、程序 1.1 开发软硬环境 芯片型号：STM32F103RCT6开发软件：Keil5 （v5.31+AC5，最常用）代码用库：标准固件库蓝牙模块：HC-08 （汇承家的; 缺点：小贵 ，优点：pdf+串口助手+APP+小程序，完美）USB转TTL模块： CH9340C （Type-C接口，win10可免驱动，比CH340和CP2102爽） 1.2 代码下载链接 百度网盘
https://pan.baidu.com/s/1pAMU6Q03_DYojdlX8RNbVQ?pwd=6543
csdn资源
https://download.csdn.net/download/qq_49053936/88515308
二、HC-08 重要参数 启动时间：上电、重启后，需200ms启动时间；蓝牙协议： V4.0 BLE主从模式：主从一体; 可设置主、从；连接成功后不分主从；串口通信：默认9600-None，可设置1200~115200bps；空中速率：1Mbps最远距离：80米（空旷、极限)、室内实测10米左右;工作电流：9mA连接数量：只支持一对一 (两模块通信为一主一从、与手机通信时手机是主机模块是从机）手机通信：支持Android 4.3及以上，支持Iphone 4S及以上每帧间隔：最少间隔20ms， 详见下方章节4.4.6表格。每帧最大：未查到 三、模块引脚说明 STA：状态输出引脚。未连接-低电平、连接成功-高电平，程序中可用作指示引脚。RXD：串口接收引脚。接单片机的TX引脚（如果是5V MCU, 需串联一个220R电阻)TXD：串口发送引脚。接单片机的RX引脚GND：电源地。VCC：电源输入3.3V （注意，原模块，不能直接接5V电源）KEY：主机用于清除配对的从机地址记忆 （置高电平 200mS 以上） 正常通讯时，一般只接四线：VCC、GND、TXD、RXD。建议增加STA连接以判断状态。
四、LED指示灯状态 模块上，集成了一颗蓝色LED，用于显示当前连接状态。
慢闪：未连接长亮：已连接 五、AT指令 5.1 AT指令重点 未连接时，是AT指令模式；连接后是串口透传模式，AT指令不起效，被当成普通数据。AT指令，必须大写AT指令，无需回车换行AT指令对参数进行修改，会自动保存，掉电不丢失。上电后自动使用最后保存的参数。AT指令，成功时返回 "OK"、指定查询信息, 不成功不返回任何作息。 5.2 AT指令注意点 进入连接状态后，无论发送什么指令，都不再是指令 ，当普通数据发送给对方。没有退出连接指令。连接后，需要其中一方断电，才能断开连接。 5.3 AT指令集 5.4 常用AT命令解释 5.4.1 测试指令 AT 发送：AT 作用：测试连接 返回：OK 5.4.2 查询当前参数 AT+RX 发送：AT+RX 作用：查询模块当前参数 返回：当前参数 5.4.3 恢复出石设置 AT+DEFAULT 发送：AT+DEFAULT 作用：恢复出厂设置 返回：OK 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b3a84bf917d1d90e92df0de92a3c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea1ed16731dafe0710db0e0fd2f3c703/" rel="bookmark">
			Socket connect阻塞导致连接超时过长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在项目中，机械臂作为服务端，软件程序编写一个客户端进行连接，connect连接出现有异常时客户端线程阻塞时间过长；
分析阻塞的原因： connect()函数在三次握手的第二次返回；
当网络连接失败时，即客户端执行connect，发送SYN包给服务端，然后一直等待服务端回应的ACK包才会返回，若超时时间到达限制，则返回-1；（1、Linux 内核中对 connect 的超时时间限制是 75s。2、套接字默认为阻塞模式）
1、套接字执行 I/O 操作有阻塞和非阻塞两种模式。在阻塞模式下，在 I/O
操作完成前，执行操作的函数一直等候而不会立即返回，该函数所在的线程会阻塞在这里。相反，在非阻塞模式下，套接字函数会立即返回，而不管 I/O
是否完成，该函数所在的线程会继续运行。 2、客户端调用 connect() 发起对服务端的 socket 连接，如果客户端的 socket
描述符为阻塞模式，则connect() 会阻塞到连接建立成功或连接建立超时（Linux 内核中对 connect 的超时时间限制是
75s）。如果为非阻塞模式，则调用 connect() 后函数立即返回，如果连接不能马上建立成功（返回 -1），则 errno 设置为
EINPROGRESS，此时 TCP 三次握手仍在继续。此时可以调用 select() 检测非阻塞 connect 是否完成。select
指定的超时时间可以比 connect 的超时时间短，因此可以防止连接线程长时间阻塞在 connect 处。
分析连接异常的几种情况： 服务端出现异常时，connect连接会立刻返回-1，表示连接失败；客户端出现异常时，有以下两种情况：
● 物理网络未连接（网线连接异常），connect连接会立刻返回-1，表示连接失败；
● 物理网络连接正常，即能获取IP地址，但网络连接失败，connect连接可能发生阻塞。 解决connect阻塞的办法： 1、信号处理函数设置阻塞超时控制 核心代码：
sigset(SIGALRM, u_alarm_handle); alarm(30);//设置闹钟，30s后将发送SIGALRM信号，执行信号处理函数u_alarm_handle //尝试连接控制器 int res1 = connect(_socketfd1,(struct sockaddr *)&amp;tcp_client1,sizeof(tcp_client1));//IO socket std::cout &lt;&lt; res1 &lt;&lt; std::endl; alarm(0);//取消闹钟，不再发送SIGALRM信号 sigrelse(SIGALRM); #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea1ed16731dafe0710db0e0fd2f3c703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc32f054119d6e40089d1810ac35c9c/" rel="bookmark">
			Minio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Minio简介 MinIO是一个开源的分布式对象存储服务器，旨在实现高性能、高可用性和可扩展性。它是构建在云原生环境中的对象存储解决方案之一。
MinIO以轻量级和快速部署为特点，可以在各种硬件设备上运行，包括个人计算机、服务器和云计算平台。它使用分布式架构来存储和管理大规模数据集，并提供了简单的RESTful API接口，使应用程序能够通过标准HTTP/HTTPS协议访问和操作存储在MinIO中的对象。
MinIO支持数据的分片和复制，可以将数据在多个节点上进行存储和备份，以提高可用性和数据冗余性。它还支持数据加密、访问控制和事件通知等功能，以满足安全性和合规性需求。
Minio的安装 我们通过Doker来进行安装(以下路径更换为自己想要的即可)
docker pull minio/minio
创建 /home/minio/data ，data目录作为Minio容器内数据源映射目录
重点！！！ 因为minio容器创建的时候会在data同目录下创建一个 .minio.sys 文件夹，所以这个目录需要给予权限。
chmod -R 777 /home/minio/data
创建容器
docker run \
-d --restart=always \
-p 9000:9000 \
-p 9001:9001 \
–name minio \
-v /home/minio/data:/data:z \
-e “MINIO_ROOT_USER=MapyAdmin” \
-e “MINIO_ROOT_PASSWORD=MapyAdmin” \
minio/minio server /data --console-address “:9001”
客户端访问端口：9001 API服务端口：http://localhost:9000
ps:创建容器里面的 “” 是虚拟机行命令未结束要换行的意思，如果不换行不需要打，这里是为了傻瓜式操作，直接复制粘贴即可！！！
Minio的Java客户端使用 引入依赖
&lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;3.0.10&lt;/version&gt; &lt;/dependency&gt; 配置文件
minio客户端配置
工具类
1）上传图片
测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4624c8b2abe6000218660bfe5526fe/" rel="bookmark">
			Linux 文件实时备份 rsync&#43;lsyncd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理和说明 lsyncd官网
（一）软件说明 目的是每次只把新修改的同步，而不是全量备份。
Rsync（同步）：将一个服务器的一个文件夹的内容提交到另外一个服务器的文件夹
lsyncd（差异检测并调用rsync）：把差异的找出来，然后运行脚本
（二）本方法说明 采用的是推送模式，即需要备份文件的服务器（客户端）向备份服务器（服务端）推送
客户端：客户端的文件需要被备份
服务端：接收客户端的文件并保存的
（三）演示说明 以下的演示中，两台设备信息如下
注意，下面的备份目录根据自己情况调整
客户端（文件需要被备份）
局域网ip：192.168.0.188 系统：debian11 备份文件夹：/aaa 服务端（存放备份文件的）
局域网ip：192.168.0.199 系统：debian11 备份文件夹：/cloud/bf_1 （四）其它说明 需要先开放对应端口，默认是873。另外注意selinux，如果搞不定就关了selinx
二、服务端配置（接收备份文件的） 服务端只需要安装rsync
1.安装rsync apt-get install rsync 2.创建接收备份后保存的目录 目录不要直接抄
mkdir /cloud/bf_1 mkdir /cloud/bf_2 3.创建同步的账号密码 使用下面的命令直接写入，也可以vi打开后编辑
echo "rsync_backup:123456" &gt;/etc/rsync.password &amp;&amp; chmod 600 /etc/rsync.password 账号为：rsync_backup
密码为：123456
4.配置rsync vi /etc/rsyncd.conf 内容如下
uid = root # linux的用户 gid = root # linux的用户组 use chroot = yes max connections = 1024 timeout = 600 port=873 # 指定rsync端口。默认873 [backup] #备份的项目模块，如果有多个，也是这样设置 path = /cloud/bf_1/ # 备份保存的位置 read only = no secrets file =/etc/rsync.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4624c8b2abe6000218660bfe5526fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994deef15690611ff1d1cbb45295185e/" rel="bookmark">
			C语言--指针详解（下）--字符指针、数组指针、指针数组、函数指针、函数指针数组（转移表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言--指针详解（下）--字符指针、数组指针、指针数组、函数指针、函数指针数组（转移表） 1. 字符指针2. 数组指针3. 指针数组4. 函数指针5. 函数指针数组（转移表）6. 总结 1. 字符指针 在C语言中有一种指针类型为字符指针 char*，常用其来表示字符，使用如下：
#include &lt;stdio.h&gt; int main() { char ch = 'w'; char *pc = &amp;ch; *pc = 'w'; return 0; } 除了上述用法之外，还可以有以下的用法:
int main() { const char* pstr = "hello word"; printf("%s\n", pstr); return 0; } 在上面的代码中，字符 " hello word "是常量字符串，将"hello word"放入 pstr 指针的实质是将第一个字符 “ h " 的地址传递给了 pstr ,通过首字符 ” h " 就可以访问整个字符串。
注意：常量字符串传递给不同的字符指针变量的时候，传过去的地址是相同的，因为常量字符串是存放在静态区的，它的地址是唯一的。
如下面这道例题：
#include &lt;stdio.h&gt; int main() { char str1[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/994deef15690611ff1d1cbb45295185e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af88fa9c448df8d8778a87ca23d12fa2/" rel="bookmark">
			C语言--指针详解（中）--指针的基本使用、指针在数组中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言--指针详解（中）--指针的基本使用、指针在数组中的应用 1. 指针的基本使用1.1 传值调用和传址调用1.1.1 传值调用1.1.2 传址调用 2. 指针在数组中的应用2.1 数组名的理解2.2 使⽤指针访问数组2.3 一维数组传参的本质2.4 二级指针 3. 总结 1. 指针的基本使用 1.1 传值调用和传址调用 1.1.1 传值调用 学习指针的⽬的是使⽤指针解决问题，那什么问题，⾮指针不可呢？
例如：写⼀个函数，交换两个整型变量的值⼀番思考后，我们可能写出这样的代码：
#include &lt;stdio.h&gt; void Swap1(int x, int y) { int tmp = x; x = y; y = tmp; } int main() { int a = 0; int b = 0; scanf("%d %d", &amp;a, &amp;b); printf("交换前：a=%d b=%d\n", a, b); Swap1(a, b); printf("交换后：a=%d b=%d\n", a, b); return 0; } 结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af88fa9c448df8d8778a87ca23d12fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9403dc32de94f6d600990d2f0530cd/" rel="bookmark">
			linux 上安装 minio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步，下载 wget https://dl.minio.org.cn/server/minio/release/linux-amd64/minio 第二步，修改权限 chmod +x minio 第三步，设置 Path mv minio /usr/local/bin/ 第四步，创建 minio mkdir minio 第五步，启动 minio minio server /data/minio --console-address :9090 minio server 命令启动MinIO服务器. 这个路径参数 ~/minio 确定服务器操作的文件夹。
minio server 进程将其输出打印到系统控制台，类似于以下内容
第六步，通过浏览器访问 http://192.168.1.13:9090/
默认用户名：minioadmin
默认密码：minioadmin第六步，通过浏览器访问
第七步，改密码 如下图
对于新用户通过 linux 命令
export MINIO_ROOT_USER=username export MINIO_ROOT_PASSWORD=password 然后重启 minio 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a838d957095487a24f8fd8e9ef1effd/" rel="bookmark">
			抖音很火的圣诞树特效源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		别搜了，就是这个
先看效果 圣诞树特效
赶紧去试试吧
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Musical Christmas Lights&lt;/title&gt; &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css"&gt; &lt;style&gt; * { box-sizing: border-box; } body { margin: 0; height: 100vh; overflow: hidden; display: flex; align-items: center; justify-content: center; background: #161616; color: #c5a880; font-family: sans-serif; } label { display: inline-block; background-color: #161616; padding: 16px; border-radius: 0.3rem; cursor: pointer; margin-top: 1rem; width: 300px; border-radius: 10px; border: 1px solid #c5a880; text-align: center; } ul { list-style-type: none; padding: 0; margin: 0; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a838d957095487a24f8fd8e9ef1effd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f291eb16f82f52c5850816238f137ec/" rel="bookmark">
			声音.wav文件的读取与保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声音.wav文件的读取与保存-示例代码：
import librosa import librosa.display import numpy as np from scipy.io.wavfile import write def split_wav(): # 读取音频文件 audio_data, sample_rate = librosa.load(input_file, sr=None) # sr不指定为None，就会读取为22050Hz print("文件的采样率为： {}Hz".format(sample_rate)) # 计算音频时长 total_duration = len(audio_data) / sample_rate print("文件的总时长为： {}S".format(total_duration)) # 分割点位置 start_time = 90 # 录音开始的时长min end_time = 120 start_sample = int(start_time * 60 * sample_rate) end_sample = int(end_time * 60 * sample_rate) # 分割音频 audio_part = audio_data[start_sample:end_sample] # 保存分割后的音频文件 # 为了符合 WAV 文件的格式，我们需要将浮点数表示的归一化音频数据转换为整数。乘以 32767 是为了将范围从 [-1, 1] 映射到 [-32767, 32767]，并且将浮点数转换为整数。 write(output_file1, sample_rate, np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f291eb16f82f52c5850816238f137ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b806684ef772ee87bdfb9a81764939a/" rel="bookmark">
			js逆向-某天下房地产验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明 本文仅供学习参考，如有侵权可私信本人删除，请勿用于其他途径，违者后果自负！
如果觉得文章对你有所帮助，可以给博主点击关注和收藏哦！
前言 目标网站：aHR0cHM6Ly9wYXNzcG9ydC5mYW5nLmNvbS8=``
接口：短信验证码登录接口
在此特别感谢k哥的文章及本人的指导。
【验证码逆向专栏】房某下登录滑块逆向分析
流程分析 目标很明确，滑块验证码的识别，使用算法还原。
打开网站，输入手机号后点击【获取短信验证码】后就会弹验证码。
流程如下：
滑块划到缺口校验成功后就会发送验证码。
打开F12查看这两部分内容发包情况。
第一个包会返回chanllenge和gt，这两个参数十分关键，是整个流程的重中之重。
接下来就是将滑块的图片返回回来。
将url进行一下拼接进行请求就可以得到背景图和滑块图。需要注意的是在做距离识别时需要查看图片大小，然后进行图片的缩放或者轨迹的缩放。
实际大小和渲染大小比例大概是1:0.9375
接下来就是滑动提交滑块的接口，分别对应三个状态。
状态码含义100成功并且发送敦信101参数错误102滑动距离错误 参数分析 请求加密的地方只有后端校验滑块的接口。
其中c、a为固定参数，可以写死。start是滑块滑动的开始时间，end则对应的是结束时间，i是浏览器环境的加密，t是轨迹的加密。
gt和challenge在之前就已经获取了。
直接搜索i: 就可以定位到加密点。
可以清楚的看到加密函数是x.compress，参数是一个自执行函数，里面有大量的环境。环境的话尽量还是补全，防止后面出现问题。
跟进函数可以将整个对象都拿下来，因为在加密中都会使用到，直接一步到位
然后就是直接调用函数，将剩下需要的一些参数和所缺函数扣下来即可调用。
至此，参数i就已经拿下了。
继续看参数t
t和i相邻，直接就能看到。
老规矩将函数整体复制下来，然后自己改改就可以了。
函数的开头和结尾打上断点，关注一下入参和结果即可。
参数e是一个转换后的轨迹数组，传入之后返回了加密轨迹。
加密的函数逻辑
function (e) { for (var t = "", n = e.length / 6, r = 0; r &lt; n; r += 1) t += E.charAt(f.parseInt(e.slice(6 * r, 6 * (r + 1)), 2)); return t }(l) 逻辑并不复杂，k哥的文章也有讲到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b806684ef772ee87bdfb9a81764939a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420d483661879f66142428708bc3aa18/" rel="bookmark">
			oracle转pg日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、时间数据类型 转为时间： to_timestamp('2022-08-01 11:46:50', 'yyyy-mm-dd hh24:mi:ss') timestamp '2022-08-01 11:46:50' '2022-08-01 11:46:50'::timestamp cast('2022-08-01 11:46:50' as timestamp) -- postgresql 时间相减计算后，转化为分钟 select round(date_part('epoch', (now()-to_timestamp('2023-11-14 8:00:00','yyyy-mm-dd hh24:mi:ss')))::NUMERIC / 60, 2) || '分钟' pg不支持oracle中的，date差相除，pg时间间隔仅可除double 二、字符串 substr() – 该方法第二个参数不支持负数
substr(str, -length('1')) =&gt; sbustr(str, length(str)+1-length('1')) '' is null 判断；oracle返回true，pgsql与mysql返回false字符串拼接：
oracle：string || string 或 concat(concat(str1, str2), str3)
pgsql：string || string
mysql：concat(str1, str2[, str3…]) 三、存储过程 Oracle: declare id varchar2(50); -- 定义变量接收参数 begin proc_test(id); -- id为out输出参数 dbms_output.put_line(id); -- 输出 end; --------------------------------------------------- postgresql: call proc_test(''); -- 实际两个均为输出 ---- create or replace procedure proc_test(out id varchar) as $body$ declare name varchar(20); begin -- Routine body goes here.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420d483661879f66142428708bc3aa18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd46be7ea3e5d5abd981ecbaf36fc337/" rel="bookmark">
			鸿蒙开发 - 状态管理之@Provide和@Consume
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Provide和@Consume，应用于与后代组件的双向数据同步，应用于状态数据在多个层级之间传递的场景。不同于上文提到的父子组件之间通过命名参数机制传递，@Provide和@Consume摆脱参数传递机制的束缚，实现跨层级传递。
其中@Provide装饰的变量是在祖先节点中，可以理解为被“提供”给后代的状态变量。@Consume装饰的变量是在后代组件中，去“消费（绑定）”祖先节点提供的变量。
概述 @Provide/@Consume装饰的状态变量有以下特性：
@Provide装饰的状态变量自动对其所有后代组件可用，即该变量被“provide”给他的后代组件。由此可见，@Provide的方便之处在于，开发者不需要多次在组件之间传递变量。后代通过使用@Consume去获取@Provide提供的变量，建立在@Provide和@Consume之间的双向数据同步，与@State/@Link不同的是，前者可以在多层级的父子组件之间传递。@Provide和@Consume可以通过相同的变量名或者相同的变量别名绑定，变量类型必须相同。 // 通过相同的变量名绑定 @Provide a: number = 0; @Consume a: number; // 通过相同的变量别名绑定 @Provide('a') b: number = 0; @Consume('a') c: number; @Provide和@Consume通过相同的变量名或者相同的变量别名绑定时，@Provide修饰的变量和@Consume修饰的变量是一对多的关系。不允许在同一个自定义组件内，包括其子组件中声明多个同名或者同别名的@Provide装饰的变量。
装饰器说明 @State的规则同样适用于@Provide，差异为@Provide还作为多层后代的同步源。
@Provide变量装饰器说明装饰器参数别名：常量字符串，可选。如果指定了别名，则通过别名来绑定变量；如果未指定别名，则通过变量名绑定变量。同步类型双向同步。从@Provide变量到所有@Consume变量以及相反的方向的数据同步。双向同步的操作与@State和@Link的组合相同。允许装饰的变量类型Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化。不支持any，不支持简单类型和复杂类型的联合类型，不允许使用undefined和null。必须指定类型，@Provide变量的@Consume变量的类型必须相同。被装饰变量的初始值必须指定。 @Consume变量装饰器说明装饰器参数别名：常量字符串，可选。如果提供了别名，则必须有@Provide的变量和其有相同的别名才可以匹配成功；否则，则需要变量名相同才能匹配成功。同步类型双向：从@Provide变量到所有@Consume变量，以及相反的方向。双向同步操作与@State和@Link的组合相同。允许装饰的变量类型Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化。不支持any，不允许使用undefined和null。必须指定类型，@Provide变量的@Consume变量的类型必须相同。被装饰变量的初始值无，禁止本地初始化。 变量的传递/访问规则说明 @Provide传递/访问说明从父组件初始化和更新可选，允许父组件中常规变量、@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp装饰的变量装饰变量初始化子组件@Provide。用于初始化子组件允许，可用于初始化@State、@Link、@Prop、@Provide。和父组件同步否。和后代组件同步和@Consume双向同步。是否支持组件外访问私有，仅可以在所属组件内访问。 Provide初始化规则图示
@Consume传递/访问说明从父组件初始化和更新禁止。通过相同的变量名和alias（别名）从@Provide初始化。用于初始化子组件允许，可用于初始化@State、@Link、@Prop、@Provide。和祖先组件同步和@Provide双向同步。是否支持组件外访问私有，仅可以在所属组件内访问 观察变化和行为表现 观察变化
当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。当装饰的数据类型为class或者Object的时候，可以观察到赋值和属性赋值的变化（属性为Object.keys(observedObject)返回的所有属性）。当装饰的对象是array的时候，可以观察到数组的添加、删除、更新数组单元。 框架行为
1.初始渲染：
@Provide装饰的变量会以map的形式，传递给当前@Provide所属组件的所有子组件；子组件中如果使用@Consume变量，则会在map中查找是否有该变量名/alias（别名）对应的 @Provide的变量，如果查找不到，框架会抛出JS ERROR;在初始化@Consume变量时，和@State/@Link的流程类似，@Consume变量会保存在map中查找到的@Provide变量，并把自己注册给@Provide。 2.当@Provide装饰的数据变化时：
通过初始渲染的步骤可知，子组件@Consume已把自己注册给父组件。父组件@Provide变量变更后，会遍历更新所有依赖它的系统组件（elementid）和状态变量（@Consume）；通知@Consume更新后，子组件所有依赖@Consume的系统组件（elementId）都会被通知更新。以此实现@Provide对@Consume状态数据同步。 3.当@Consume装饰的数据变化时：
通过初始渲染的步骤可知，子组件@Consume持有@Provide的实例。在@Consume更新后调用@Provide的更新方法，将更新的数值同步回@Provide，以此实现@Consume向@Provide的同步更新。 使用场景 在下面的示例是与后代组件双向同步状态@Provide和@Consume场景。当分别点击CompA和CompD组件内Button时，reviewVotes 的更改会双向同步在CompA和CompD中。
@Component struct CompD { // @Consume装饰的变量通过相同的属性名绑定其祖先组件CompA内的@Provide装饰的变量 @Consume reviewVotes: number; build() { Column() { Text(`reviewVotes(${this.reviewVotes})`) Button(`reviewVotes(${this.reviewVotes}), give +1`) .onClick(() =&gt; this.reviewVotes += 1) } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd46be7ea3e5d5abd981ecbaf36fc337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd60a09f39338179c397dc4ad3d122b8/" rel="bookmark">
			鸿蒙开发 - 状态管理之@Link
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。
概述 @Link装饰的变量与其父组件中的数据源共享相同的值。
限制条件 @Link装饰器不能在@Entry装饰的自定义组件中使用。
装饰器使用规则说明 @Link变量装饰器说明装饰器参数无同步类型双向同步。父组件中@State, @StorageLink和@Link 和子组件@Link可以建立双向数据同步，反之亦然。允许装饰的变量类型Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化。类型必须被指定，且和双向绑定状态变量的类型相同。不支持any，不支持简单类型和复杂类型的联合类型，不允许使用undefined和null。被装饰变量的初始值无，禁止本地初始化。 变量的传递/访问规则说明 传递/访问说明从父组件初始化和更新必选。与父组件@State, @StorageLink和@Link 建立双向绑定。允许父组件中@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp装饰变量初始化子组件@Link。从API version 9开始，@Link子组件从父组件初始化@State的语法为Comp({ aLink: this.aState })。同样Comp({aLink: $aState})也支持。用于初始化子组件允许，可用于初始化常规变量、@State、@Link、@Prop、@Provide。是否支持组件外访问私有，只能在所属组件内访问。 初始化规则图示
观察变化和行为表现 观察变化
当装饰的数据类型为boolean、string、number类型时，可以同步观察到数值的变化；当装饰的数据类型为class或者Object时，可以观察到赋值和属性赋值的变化，即Object.keys(observedObject)返回的所有属性；当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。 框架行为
@Link装饰的变量和其所属的自定义组件共享生命周期。
为了了解@Link变量初始化和更新机制，有必要先了解父组件和拥有@Link变量的子组件的关系，初始渲染和双向更新的流程（以父组件为@State为例）。
1.初始渲染：执行父组件的build()函数后将创建子组件的新实例。初始化过程如下：
必须指定父组件中的@State变量，用于初始化子组件的@Link变量。子组件的@Link变量值与其父组件的数据源变量保持同步（双向数据同步）。父组件的@State状态变量包装类通过构造函数传给子组件，子组件的@Link包装类拿到父组件的@State的状态变量后，将当前@Link包装类this指针注册给父组件的@State变量。 2.@Link的数据源的更新：即父组件中状态变量更新，引起相关子组件的@Link的更新。处理步骤：
通过初始渲染的步骤可知，子组件@Link包装类把当前this指针注册给父组件。父组件@State变量变更后，会遍历更新所有依赖它的系统组件（elementid）和状态变量（比如@Link包装类）。通知@Link包装类更新后，子组件中所有依赖@Link状态变量的系统组件（elementId）都会被通知更新。以此实现父组件对子组件的状态数据同步。 3.@Link的更新：当子组件中@Link更新后，处理步骤如下（以父组件为@State为例）：
@Link更新后，调用父组件的@State包装类的set方法，将更新后的数值同步回父组件。子组件@Link和父组件@State分别遍历依赖的系统组件，进行对应的UI的更新。以此实现子组件@Link同步回父组件@State。 使用场景 1.简单类型和类对象类型的@Link
以下示例中，点击父组件ShufflingContainer中的“Parent View: Set yellowButton”和“Parent View: Set GreenButton”，可以从父组件将变化同步给子组件。
1.点击子组件GreenButton和YellowButton中的Button，子组件会发生相应变化，将变化同步给父组件。因为@Link是双向同步，会将变化同步给@State。
2.当点击父组件ShufflingContainer中的Button时，@State变化，也会同步给@Link，子组件也会发生对应的刷新。
class GreenButtonState { width: number = 0; constructor(width: number) { this.width = width; } } @Component struct GreenButton { @Link greenButtonState: GreenButtonState; build() { Button('Green Button') .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd60a09f39338179c397dc4ad3d122b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5f7b926454a9fd42a25d5eef06060f/" rel="bookmark">
			基于SpringBoot的校园电商物流云平台 JAVA简易版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 商品数据模块2.3 快递公司模块2.4 物流订单模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 商品表3.2.2 快递公司表3.2.3 物流订单表 四、系统展示五、核心代码5.1 查询商品5.2 查询快递公司5.3 查询物流订单5.4 新增物流订单5.5 快递收揽派签 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL 的校园电商物流云平台，包含了商品管理模块、快递公司模块、物流订单模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，校园电商物流云平台基于角色的访问控制，给商家、物流公司、物流管理员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 互联网和电子商务行业已成为各产业升级创新的“发动机”，也是大众创业的肥沃土壤。各大院校纷纷在基于互联网或电子商务平台的大学生创业教育方面进行了探索和尝试。依托电子商务专业教育体系，立足于高校市场资源，利用新型的社群移动电商平台开展电子商务创业教育创新实践，取得了较好效果。本文旨在建立一个面向校园电商创业的物流云平台，采用Vue、SpringBoot、MySQL技术，包含数据中心模块、商品档案模块、快递公司模块、物流订单管理模块，对物流配送实现云平台管理。
本文设计的面向校园电商创业的物流云平台的包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了商品档案模块、快递公司模块、物流订单模块这三大模块，用于存放系统的核心业务逻辑。
2.1 数据中心模块 数据中心模块包含了对面向校园电商创业的物流云平台的基础模块，比如管理谁可以登录这套系统，记录这些人登录系统做了什么，不同的人拥有不同权限的管理。
2.2 商品数据模块 商品数据模块用于对商品的数据进行管理，其中包括商品ID、商品名称、商品规格、商品图片、商品备注、归属人ID、归属人、创建人等，可以通过此模块对商品数据进行添加、编辑更新、删除、查询操作。
2.3 快递公司模块 快递公司模块是对快递公司的档案信息进行管理，快递公司是快递运输的主要参与者，快递公司字段包括公司简称、公司全名、LOGO、营业执照、地址、经营范围、备注、创建人等，管理员可以新增快递公司的数据，用户可以查询管理员发布的快递公司信息。
2.4 物流订单模块 物流订单模块是对商品数据的实例化，有了商品后，用户就可以对商品进行创建物流订单，这就产生了物流订单模块，其中包括物流单号、下单人ID、下单人、收件人、收件电话、收件地址、下单日期、订单状态、发货物流等，用户可以进行物流下单，快递公司可以操作发货，管理员可以删除物流订单。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 商品表 3.2.2 快递公司表 3.2.3 物流订单表 四、系统展示 五、核心代码 5.1 查询商品 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询商品") public Result&lt;IPage&lt;Commodity&gt;&gt; getByPage(@ModelAttribute Commodity commodity ,@ModelAttribute PageVo page){ QueryWrapper&lt;Commodity&gt; qw = new QueryWrapper&lt;&gt;(); User currUser = securityUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac5f7b926454a9fd42a25d5eef06060f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f112232142105db2cad90b08eefab0db/" rel="bookmark">
			img图片的src分别在vue2、vue3项目中如何动态赋值？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2引用示例： 方式1：直接在调用时引入 let img = new Image(); img.src = require('@/assets/icon/car.png'); this.iconLayer = new mapvgl.IconLayer({ width: 25, height: 25, icon:img, enablePicked: true, // 是否可以拾取 selectedIndex: -1, // 选中项 selectedColor: 'rgb(230,104,38)', // 选中项颜色 autoSelect: true, // 根据鼠标位置来自动设置选中项 onClick: (e) =&gt; { // 点击事件 if(e.dataIndex!=-1){} }, }); 方式2：提前在定义变量时引入 import redCar from "@/assets/icon/redCar.png" import greenCar from "@/assets/icon/greenCar.png" vue3引用示例： vue3中图标引入方法区别于vue2，是一种全新的方式
场景1：百度地图中引入 const redCar = new URL('../../../assets/icon/redCar.png', import.meta.url).href //引用图标 let icon = new BMapGL.Icon(redCar, new BMapGL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f112232142105db2cad90b08eefab0db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a421e67e48945c482724dd8c6b62c532/" rel="bookmark">
			今日头条选题经验：不再盲目跟风，文章阅读量翻倍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲们，你们好！我是你们的小编老王。今天想跟大家聊聊关于我在知名资讯app "今日头条"上的一点选题经验。自从来到这个岗位后，我已经创作了很多篇文章。通过几年的探索和总结，我现在有一套自己的高效操作方法，希望能与各位读者分享。
1.挑选热门话题
标题：如何让自己的作品更受欢迎？
为了提高您的文章吸引力，选择合适的话题显得尤为关键。我们建议您查阅"今日头条"的热门话题排行榜作为参考，但是请务必注意不要盲目跟随热点，而是要根据自己的专业知识和喜好来规划发言。
2.独特的视角
在创作过程中，我们鼓励您拥有自己独特的见解。请尽量避免直接复制他人观点，应该将自身的思维方式和理解融入其中。为了提升文章的说服力以及可读性，您可以考虑通过与读者互动或者了解相关领域专家的想法来实现。
3.生动具体的描写
艺术性的文字需通过生动与详尽的描述来吸引阅读者并帮助他们深刻理解文章内容。就如我们在描述旅行中的所见所感时，只需娓娓道来，就能让人仿佛身处其中。
4.真实详尽的内容
尊敬的用户，作为编辑人员，我们致力于保持诚实和详尽，避免夸张和杜撰事实。面对文章的主题，我们会以公正、准确的态度去解析。只有这样，才能赢得您们的信任和肯定。
5.互动评论
在'今日头条'这一优质平台上，要积极回复用户的评论。通过热情洋溢地对观众意见进行回应，与他们进行有效的互动，这样能提升您的创作水准。在此过程中，您不仅可以深入理解观众反馈，还能够获得宝贵的建议，从而增强自己的写作技能。
6.多渠道推广
除了在"今日头条"发表文章外，我们也建议您尝试利用其他工具来提高文章宣传效果。比如，利用微信公众号和微博这样的社交媒体平台分享自己的文章链接，吸引更多知音阅读。另外，参与相关平台上的讨论互动也是拓展影响力的良好方式。
7.持之以恒
在这里，我想和大家分享一下，要走上出色的写作之路需要不断磨练。只有通过学习、实践以及反思，我们才能逐渐提高自己的笔力。面对困难时，乐观自信地应对非常关键。
本文是关于我在今日头条采编文章经验的分享。期待这些信息对您有所启发。切记，只有不断进取，才能在这个舞台上赢得更多成功。加油吧，愿我们携手共进！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e764f6066fd0239ed93330048389b2a0/" rel="bookmark">
			单例模式的七种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么使用单例？
避免重复创建对象,节省内存,方便管理;一般我们在工具类中频繁使用单例模式;
1.饿汉式(静态常量)-[可用] /** * 饿汉式(静态常量) */ public class Singleton1 { private static final Singleton1 INSTANCE = new Singleton1(); private Singleton1(){} public static Singleton1 getInstance(){ return INSTANCE; } } 2.饿汉式(静态代码块)[可用] /** * 饿汉式(静态代码块) */ public class Singleton2 { private static final Singleton2 INSTANCE; static { INSTANCE = new Singleton2(); } private Singleton2(){} public static Singleton2 getInstance(){ return INSTANCE; } } 3.懒汉式(同步方法)[不推荐] /** * 懒汉式(同步方法) * 不推荐：效率太低了 */ public class Singleton3 { private static Singleton3 instance; private Singleton3(){} public synchronized static Singleton3 getInstance(){ if(instance == null){ instance = new Singleton3(); } return instance; } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e764f6066fd0239ed93330048389b2a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6039a43eb613dc0bd25cf43b8d3358ab/" rel="bookmark">
			android studio使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：倒序 十、后续的gradle就不再取默认的地址了，就会取这个地址的gradle-6.2.2版本去做构建了 flutter, zsh: command not found: gradle_zsh: command not found: gradlew-CSDN博客
九、idea下载地址 https://www.jetbrains.com/ 八、Android Gradle 插件和 Android Studio 兼容性 https://developer.android.com/studio/releases?hl=zh-cn#android_gradle_plugin_and_android_studio_compatibility
七、清理项目无用资源 来源：聊一聊 AS 的一些好用的功能
这个也很有用，比如你刚接手一个屎山的项目，里面有很多资源根本没有进行使用，但不知从何删起的话，这个功能就很 Nice 了，来看下使用方法吧：
点击 as 上面的 Code -&gt;Analyze Code -&gt; Run Inspection by Name，就会弹出如下图的对话框，在里面输入 unused resources：
然后点击回车，或者点击选项：
选择整个项目、或者 Module、亦或者是某个文件，点击 Ok 开始查询，
你需要做的就是等待刷新完成，然后你项目中的一些没有使用到的资源就会展示到你的面前，最后只需删除真正没用的资源即可。
六、设置编码方式 一，File —— Settings —— Editor —— File Encodings
1.Global Encoding 全局编码格式，设置整个AS的编码格式
2.Project Encoding 项目编码格式，设置该项目的编码格式
3.Path/Encoding 指定单个文件编码格式
4.Properties Files 设置.properties文件的编码格式
二，Help —— Edit Custom VM Options
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6039a43eb613dc0bd25cf43b8d3358ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b32756320b4649f77150489c280bab7b/" rel="bookmark">
			【亲测有效】AttributeError: ‘_process_plot_var_args‘ object has no attribute ‘prop_cycler‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：在使用librosa库分析语音.wav文件的时候，调用waveshow函数的时候，出现报错：
AttributeError: '_process_plot_var_args' object has no attribute 'prop_cycler'
解决办法：
这个时候通常做法是更改matplotlib的版本或者librosa的版本，但是其实有更简洁的办法。
这个问题其实是无法自动选择颜色，只要把代码里的waveshow增加指定颜色，问题就解决啦！
librosa.display.waveshow(audio_data, sr=sample_rate, color="blue") 参考来源：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528bf96e2d042f641eaf07777738ebd4/" rel="bookmark">
			图像篡改及防篡改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们是攻击方，发送被网站或微信屏蔽的敏感图像，分享瓜时剔除可能暴露的个人信息，在平台分享其他平台的购物记录
有时候我们是防守方，判断他人给的图有没有造假嫌疑，判断是不是网图盗图
调研了图像造假的判别方案，在cv领域，这不是一个热门的研究方向(时间点2023.07)，以下方法也只能通过pipeline的方法筛选出一部分有问题的影像，而不能实现高召回。但随着AIGC的发展，这一领域有望得到更高关注。 造假方法 下图分别是 拼接(splicing)，复制移动 (copy-move) 和擦除填充 (removal)3种造假方法下的真实图像、被篡改的图像、篡改mask。
其他攻击方法：
马赛克、压缩、涂抹（抹色、马赛克）、剪裁、截图、缩放、摄屏、高斯等模糊、社交工具传输。。。
基于图像属性的篡改辨别方法 基于Exif
图片属性中包含Photoshop from PIL import Image, ExifTags for k,v in ExifTags.TAGS.items(): print(k,v) im = Image.open('1.jpg') print(im._getexif()) print 输出如下 ... 297 PageNumber 301 TransferFunction 305 Software 306 DateTime 315 Artist ... {305: 'Adobe Photoshop CS6 (Windows)', 274: 1, 306: '2015:07:27 23:14:35', 296: 2, 34665: 164, 282: (720000, 10000), 283: (720000, 10000), 40961: 1, 40962: 4288, 40963: 2848} # 305代表Software，这里可以查询到测试图片是PS输出的 在生产数据上实验了一下，24.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528bf96e2d042f641eaf07777738ebd4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/34/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>