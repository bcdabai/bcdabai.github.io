<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e3815c6091f0fcd7eb4fcb87da43a8/" rel="bookmark">
			使用c&#43;&#43;多线程来加速adb shell input tap模拟点击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、多线程二、代码 一、多线程 C++11之线程库thread
二、代码 tap命令大致会有差不多1秒的延迟，所以简单的for循环tap命令只是看到每隔1秒点击的效果。
只要你的手机支持多点触控（现在一般都是），那么就能实现和你疯狂点击屏幕一样的速度。
方法创建多个线程，每个线程都点击屏幕。同时，让这些线程大致都隔几十毫秒执行，这样就不会造成同时点击tap而只识别了仅仅部分的情况（手机反应不过来）。
#define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; #include&lt;thread&gt; #if defined(__linux__) // Linux系统 #include&lt;unistd.h&gt; #elif defined(_WIN32) // Windows系统 #include&lt;windows.h&gt; #endif using namespace std; // 线程的个数 #define THREAD_ADVERTISEMENT_SIZE 7 // 点击的次数 #define TAP_TIME 500 /* 秒 */ void my_p_sleep(int time) { #if defined(__linux__) // Linux系统 sleep(time); #elif defined(_WIN32) // Windows系统 Sleep((time * 1000)); #endif } /* 毫秒 */ void my_m_sleep(int time) { #if defined(__linux__) // Linux系统 usleep(time * 1000); #elif defined(_WIN32) // Windows系统 Sleep(time); #endif } void tap_advertisement() { int i = TAP_TIME; while (i--) { /* 点击的位置 */ system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9e3815c6091f0fcd7eb4fcb87da43a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc4b780dfd71e05303ee95faa32d536/" rel="bookmark">
			编译原理第三版答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点此下载
第一章
1．典型的编译程序在逻辑功能上由哪几部分组成？
答：编译程序主要由以下几个部分组成：词法分析、语法分析、语义分析、中间代码生成、中间代码优化、目标代码生成、错误处理、表格管理。
2. 实现编译程序的主要方法有哪些？
答：主要有：转换法、移植法、自展法、自动生成法。
3. 将用户使用高级语言编写的程序翻译为可直接执行的机器语言程序有哪几种主要的方式？
答：编译法、解释法。
4. 编译方式和解释方式的根本区别是什么？
答：编译方式：是将源程序经编译得到可执行文件后，就可脱离源程序和编译程序单独执行，所以编译方式的效率高，执行速度快；
解释方式：在执行时，必须源程序和解释程序同时参与才能运行，其不产生可执行程序文件，效率低，执行速度慢。
第二章
乔姆斯基文法体系中将文法分为哪几类？文法的分类同程序设计语言的设计与实现关系如何？ 答：1）0型文法、1型文法、2型文法、3型文法。
2）
2. 写一个文法，使其语言是偶整数的集合，每个偶整数不以0为前导。
答：
ZàSME | B
Sà1|2|3|4|5|6|7|8|9
Màe | D | MD
Dà0|S
Bà2|4|6|8
Eà0|B
3. 设文法G为：
Nà D|ND
Dà 0|1|2|3|4|5|6|7|8|9
请给出句子123、301和75431的最右推导和最左推导。
答：NÞNDÞN3ÞND3ÞN23ÞD23Þ123
NÞNDÞNDDÞDDDÞ1DDÞ12DÞ123
NÞNDÞN1ÞND1ÞN01ÞD01Þ301
NÞNDÞNDDÞDDDÞ3DDÞ30DÞ301
NÞNDÞN1ÞND1ÞN31ÞND31ÞN431ÞND431ÞN5431ÞD5431Þ75431
NÞNDÞNDDÞNDDDÞNDDDDÞDDDDDÞ7DDDDÞ75DDDÞ754DDÞ7543DÞ75431
4. 证明文法 SàiSeS|iS| i是二义性文法。
答：对于句型iiSeS存在两个不同的最左推导：
SÞiSeSÞiiSes
SÞiSÞiiSeS
所以该文法是二义性文法。
5. 给出描述下面语言的上下文无关文法。
（1） L1={anbnci |n&gt;=1,i&gt;=0 }
（2） L2={aibj|j&gt;=i&gt;=1}
（3） L3={anbmcmdn |m,n&gt;=0}
答：
SàAB AàaAb | ab
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfc4b780dfd71e05303ee95faa32d536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b4f206f2b44d3b868bef5a0254248b6/" rel="bookmark">
			LWN：使用GCC编译生成BPF程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方蓝色“ Linux News搬运工”关注我们~ Compiling to BPF with GCC By Jonathan Corbet
LPC
自从在kernel里加上eBPF (extended BPF) 之后，诞生了很多各式各样的应用场景。不过还是只有很少人真正写过BPF代码。因为目前BPF代码就有点像其他那些汇编级语言，挺难用的。写BPF program是可以用C语言的，LLVM编译器可以把C语言编译成BPF program。不过，在2019 Linux Plumbers Conference上的Toolchains microconference中，Jose Marchesi指出，LLVM不久后会成立一个公司，所以他就在GCC编译器里也加上了BPF back-end支持。
Marchesi自己定位是一个编译器工作者，而不是BPF trace专家。他介绍说GCC的支持经过了3个阶段。首先在toolchain里添加BPF的最基本的支持，包括让GCC能支持一个新的bpf-unknown-none的target，以及binutils在5月份就支持了BPF；在会议之前，GCC的代码库里合入了BPF支持。
从现在起，GCC可以编译生成BPF program了，不过还有一个障碍：生成的BPF program必须要能通过kernel里的BPF verifier的审查。也就是说编译生成的program需要指令顺序符合规范。Marchesi认为应该还是能够做到的，随着kernel verifier也在变得更加聪明（例如支持有限次数的循环了），那么GCC生成代码这边的难度也会更加小一些。
最后一个阶段还在进行中，就是需要为开发者们创造一些新的工具。例如BPF的simulator，用来在user space运行，可以通过GDB来调试BPF program。在他看来，BPF就像是某种类型的嵌入式平台一样，需要针对这种平台创建各种工具才能让普通开发者正常进行开发。
他认为BPF virtual machine就像是一种特殊类型的平台，表面上看起来很普通，其实不然。这个虚拟机需要依赖kernel提供的各种helper功能。他打算把这些helper功能重新在GCC内部也实现出来，这种方式就跟LLVM所用的不一样了。他认为这种方案更加稳定，不过会需要长久维护这些helper功能。要想维护好这些helper，还是很有难度的，因为每个kernel版本都不一样。这就意味着GCC需要使用一个新的参数（例如-mkernel=）来指定kernel版本号，就像是-mcpu用来指定CPU一样。这样的话，编译器就能抓出来那些在目标版本kernel中并不支持的helper功能了。
Peter Zijlstra在这里插了一个问题，是否也支持各种企业版的kernel版本。这些发行版里面，kernel可能包含了很多backport patch，所以base版本号其实并不能精确反映这个信息。Marchesi的回答是他现在还只支持mainline kernel的版本号。H. Peter Anvin建议可以把这些helper信息放到kernel的UAPI头文件里面去，这样在编译时就能直接拿到了。Nick Alcock则建议说，可以利用参数上指定的kernel版本号来读取某个描述文件，从而确定支持哪些helper。还有一位听众则认为把helper函数builtin到GCC里不是个好方法。如果用户拿到新的kernel，他们就没法编译BPF来利用新增的helper功能了。
Marchesi继续介绍，他希望能对C语言支持的越完整越好。不过这个很困难，因为BPF program的限制很多。他也在建议创建一个BPF的试验性版本，称之为xBPF，这个版本的限制更加少。例如xBPF可以支持更大的stack frame，也可以有indirect call instruction（间接调用指令）。参数可以直接通过stack传递，从而增加了函数可以使用的参数数量。他还希望能支持带符号数的除法。
为什么需要创建一个xBPF呢？这里主要的吸引力来自于可以执行更详尽的编译器测试。目前来说，他得关闭几百个GCC test，因为BPF根本没法运行这些测试。此外xBPF还能让调试更加容易，能容易生成backtrace。还会让去除verifier的各种限制的试验过程更加容易一些。并且，xBPF会可以使用各种ELF链接功能。他很想让LLVM也能支持xBPF。
接下来，他会希望能有一个verifer运行在user space。BPF verifier的代码是相当复杂精致，能有一个user space版本的话，就可以更容易的发现问题。他并不打算重新开发一个verifier，而是希望能有什么办法直接利用kernel的verifier代码。
最后Marchesi问道，BPF ABI是什么？目前，它只能根据LLVM生成什么以及kernel接受什么来决定。我们需要对BPF建立文档描述清楚这个ABI，只有这样才能让多种实现版本（无论是LLVM还是GCC生成）都可以互相协作。随着BPF使用越来越广泛，他很希望能投身其中，为GNU toolchain做更多贡献。
[Your editor thanks the Linux Foundation, LWN's travel sponsor, for supporting travel to this event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b4f206f2b44d3b868bef5a0254248b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c05f7e202a5d092623a9f3d80281f4/" rel="bookmark">
			遇到的一个git for windows 疯狂占用性能问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 遇到的一个git性能占用问题 在今天进行VScode的升级换代后，出现了性能问题。一旦我打开编译器，git for window便疯狂的占用我的内存，甚至在我这可怜的有限的8G运行内存空间中横冲直撞，一度飙到了2GB的内存占用量。苦恼思索，问度娘无果，最后便想到了git的执行机制，在VScode中，一定和我的项目源代码有关。
杀死git进程=&gt;打开编辑器面板=&gt;查看项目文件夹
果然，没有.gitignore文件
缺少这个文件，我的所有的六个项目的node_modules文件夹，都成了git创建仓库和加载依赖的工作队列。而所有的node-module的文件夹大小，有1~2个G，git为了快速加载模块，疯狂申请占用内存，一个git for window进程不够，又添加了好几个。所以电脑就爆炸了。听歌时网速为零、操作卡屏操作最为基本的表现。
解决办法：
方法一关闭不包含.gitignore文件夹或项目，将后台git进程及时kill掉(可以直接使用任务管理器)在项目内添加上 .gitignore文件,并且将node_modules写进忽略名单 .gitignore写法 Git 忽略规则匹配语法
在 .gitignore 文件中，每一行的忽略规则的语法如下：
空格不匹配任意文件，可作为分隔符，可用反斜杠转义# 开头的文件标识注释，可以使用反斜杠进行转义! 开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 ! 也不会再次被包含。可以使用反斜杠进行转义/ 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件/ 开始的模式匹配项目跟目录如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录** 匹配多级目录，可在开始，中间，结束? 通用匹配单个字符[] 通用匹配单个字符列表 常用匹配示例：
bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin: 忽略根目录下的bin文件/*.c: 忽略 cat.c，不忽略 build/cat.cdebug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj**/foo: 忽略/foo, a/foo, a/b/foo等a/**/b: 忽略a/b, a/x/b, a/x/y/b等!/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件*.log: 忽略所有 .log 文件config.php: 忽略当前路径的 config.php 文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813261450f7702c4cdf25adb0a5388bb/" rel="bookmark">
			hybrid介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hybrid 即“混合”，是客户端（app）和前端混合开发，需要前端开发人员和客户端开发人员配合完成，某些环节也可能涉及到server端。
PS:不要以为自己是前端开发就不学习客户端或者server端的知识。
基础知识： webview是app中的一个组件（app可以有webview，也可以没有），用于加载h5页面，即一个小型的浏览器内核。
schema协议是前端和客户端通讯的约定。每个app可能不一样，协议前面的名称都是app自己可以定的。比如：
前端要遵守这些协议才能和客户端交互，
file:// 协议是用来加载本地文件（html,css,js）用的协议，即使是断网了依然可以加载这些资源，加载速度快。hybrid用的就是file://协议，因为快，file://协议后面跟文件的绝对路径。
http(s)协议用来加载远程文件，需要网络，会相对慢点。
hybrid存在的价值： 可以快速迭代，无需app审核。 审核再快都得一两天的样子，苹果strore审核得一个周的样子，但用了hybrid可以在不需要app审核得情况下一天上线很多次都没问题。app需要审核是因为开发app的代码有权利访问手机中涉及到用户安全和隐私的内容，比如深层次的api像地理位置、开启相机。hybrid用前端开发的那部分只是上线前端代码（html,css,js)，前端代码是没有能力获取用户的地理位置、摄像头拍照扫码等信息的，反正前端代码没这么高的权限想捣乱都没办法就不用审核了。
体验流畅（和NA体验基本类似）减少开发和沟通成本，双端公用一套代码 hybrid更新方法： 前端做好静态页面（html,js,css），将文件交给客户端，客户端拿到前端静态页面后以文件形式存储在app中，客户端在一个webview中使用file://协议加载静态文件。用户每次打开app，app都去server端看看有没有最新的前端静态文件，如果有就下载下来然后覆盖本地旧的前端静态文件，替换每个客户端的静态文件只能客户端来做，让客户端去server下载最新的静态文件，前端可以维护server的前端静态文件，把最新的前端文件上传给客户端。
分版本，有版本好，如201910111015将静态文件压缩成zip包，上传到服务端客户端每次启动都去服务端检查版本号如果服务端版本号大于客户端版本号，就去下载最新的zip包下载完后解压包，然后将现有文件覆盖
注意：服务端的版本和zip包的维护；用户在客户端更新zip包前先对比版本号，没必要启动一次下载一次；zip包下载解压和覆盖。
hybrid和h5的区别： h5在加载的时候会有一小会儿的白屏，页面上方会出现一个加载条，但在hybrid中这些都没有。所以hybrid相对h5更快更流畅。hybrid产品功能稳定，体验要求高，迭代频繁。h5大多只在单次的运营活动或不常用功能。
前端和客户端通讯： 新闻详情页适用hybrid，前端获取新闻内容不能用ajax获取，ajax获取的接口是http(s)协议，而hybrid本地用的是file://协议，协议不一样会跨域，而且http(s)线上的地址速度慢。所以用客户端获取新闻内容（这里客户端是可以提前获取新闻内容的），然后js通讯拿到内容再渲染，
基本形式：
js访问客户端能力，传递参数和回调函数，客户端通过回调函数返回内容。
封装schema方便前端使用
invoke.js
//自执行函数，防止污染全局变量 (function (window, undefined) { // 调用 schema 的封装 function _invoke(action, data, callback) { // 拼装 schema 协议 var schema = 'myapp://utils/' + action // 拼接参数 schema += '?a=a' var key for (key in data) { if (data.hasOwnProperty(key)) { schema += '&amp;' + key + data[key] } } // 处理 callback var callbackName = '' if (typeof callback === 'string') { callbackName = callback } else { callbackName = action + Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/813261450f7702c4cdf25adb0a5388bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67bbfdcc82c6f523d4ffdaa02f5f502f/" rel="bookmark">
			无限 for 循环的实现【Python】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for 循环怎么才能无限循环下去呢？ 1. 最 low 的方法：一个无限的列表 理解 for 在干什么，在遍历，那我们给他一个无限长的东西，不就无限循环了。
list_ = [None] for _ in list_: list_.append(None) # Other operations. 优点：易于理解，最容易想到的方式缺点：速度慢，占内存，最后肯定会溢出的，其实不是真正意义上的无限。 2. 实现一个无限的迭代器 理解 for 的本质，是先获取一个迭代器，再依次调用 next 。那我们自己实现一个迭代器，让它的 next 永远都不不抛出 StopIteration 异常，那不就永远 for 下去了
class MyIter: def __iter__(self): return self def __next__(self): pass for _ in MyIter(): # Other operations. 优点：真正的无限，不浪费内存缺点：依然需要个人手动实现一些东西 3. 使用内置的无限迭代器 使用别人已经造好的无限迭代器，避免自己写了
3.1 count from itertools import count for i in count(): print(i) # Other operations. 优点：近似是无限的，不需要手动实现什么，自带自定义初始值、步长的计数缺点：如果时间无限，内存有限，那么可以认为有一天计数的值会非常大，大到计算机放不下，当然不需要等到那一天，只要数字足够大，就会比其他无限迭代器浪费时间 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67bbfdcc82c6f523d4ffdaa02f5f502f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b5cca0ee97aafb5313209b09c00fdf/" rel="bookmark">
			通过 Sqoop1.4.7 将 Mysql5.7、Hive2.3.4、Hbase1.4.9 之间的数据导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转自https://mshk.top/2019/03/sqoop-mysql-hive-hbase-import-export/，博文作者：迦壹
目录
1、什么是 Sqoop？ 2、下载应用程序及配置环境变量 2.1、下载 Sqoop 1.4.7 2.2、设置环境变量 2.3、设置安装所需环境 3、安装 Sqoop 1.4.7 3.1、修改 Sqoop 配置文件 3.1.1、修改配置文件 sqoop-env.sh 3.1.2、修改配置文件 configure-sqoop 3.2、查看 Sqoop 版本 4、启动和测试 Sqoop 的数据导入、导出 4.1、Sqoop 通过 Hive 导入数据到 Sqoop 4.2、Sqoop 通过 MySql 导入数据到 Hive 4.3、Sqoop 通过 MySql 导入数据到 Hbase 1、什么是 Sqoop？
Sqoop 是一种用于在 Hadoop 和关系数据库或大型机之间传输数据的工具。
您可以使用 Sqoop 将数据从关系数据库管理系统RDBMS（如 MySQL 或 Oracle）导入 Hadoop 分布式文件系统 HDFS，转换 Hadoop MapReduce 中的数据，然后将数据导出回 RDBMS。
Sqoop 自动执行此过程的大部分过程，依靠数据库来描述要导入的数据的模式。Sqoop 使用 MapReduce 导入和导出数据，提供并行操作和容错。
2、下载应用程序及配置环境变量
2.1、下载 Sqoop 1.4.7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48b5cca0ee97aafb5313209b09c00fdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96d1db75fbf2cdf7f697dc6cc6987ea/" rel="bookmark">
			Centos7.6&#43;Hadoop 3.1.2(HA)&#43;Zookeeper3.4.13&#43;Hbase1.4.9(HA)&#43;Hive2.3.4&#43;Spark2.4.0(HA)高可用集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自https://mshk.top/2019/03/centos-hadoop-zookeeper-hbase-hive-spark-high-availability/，因为原链接打不开，故在此做一个记录。
1、前言
1.1、什么是 Hadoop?
1.1.1、什么是 YARN?
1.2、什么是 Zookeeper?
1.3、什么是 Hbase?
1.4、什么是 Hive
1.5、什么是 Spark?
2、环境准备
2.1、网络配置
2.2、更改 HOSTNAME
2.3、配置 SSH 免密码登录登录
2.4、关闭防火墙
2.7、安装 NTP
3. 下载应用程序及配置环境变量
3.1、创建安装目录
3.2、下载本文中用到的程序
3.3、设置环境变量
4. 安装 Oracle JDK 1.8.0
4.1 下载 Oracle JDK 1.8.0
4.2、配置 Oracle JDK 1.8.0
5、安装 Zookeeper3.4.13
5.1、修改配置文件 zoo.cfg
5.2、为每台服务器创建身份标识
5.3、在所有节点中启动 zookeeper
5.4、查看zookeeper 运行状态
5.5、测试 Zookeeper 是否启动成功
6、安装 Hadoop3.1.2
6.1、修改 Hadoop 配置文件
6.1.1、修改配置文件 core-site.xml
6.1.2、修改配置文件 hdfs-site.xml
6.1.3、修改配置文件 mapred-site.xml
6.1.4、修改配置文件 capacity-scheduler.xml
6.1.5、修改配置文件 yarn-site.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e96d1db75fbf2cdf7f697dc6cc6987ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f9fd04c0e8d6c299cbed3c0f0f3b10/" rel="bookmark">
			在华为跟苹果的重压下，谷歌的5G手机会有新出路？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着全球智能手机市场增速不断减缓，不少手机厂商都将5G手机视为拯救销量的关键。除了华为、三星、小米等，谷歌也加入推5G手机的队伍行列。
10月10日，据外媒报道，谷歌很有可能在10月15日在纽约市举行的硬件发布会上推出5G智能手机。作为当下智能手机领域的最热门，5G手机受到全球用户的高度期待，当然手机厂商巨头们华为、苹果、三星等在5G上的动作也是频频在科技圈引发很高的讨论热度。
作为全球瞩目的科技巨头，谷歌的搜索业务跟安卓系统算是它的两大王牌，尽管谷歌这两项业务做的人尽皆知，但它也有自己的短板业务，那就是智能手机。一提到谷歌的智能手机，外界对它最大的评价就是：不温不火，背靠谷歌按理说做智能手机还是有不少先天优势，但根据全球销量来看，可以说是跟其他手机厂商巨头早已存在天壤之别的差距。
这次谷歌抢在苹果之前率先发布5G手机，虽说在时机点上占据一点首发优势，但如今智能手机行业早已不是砸钱就能做起来的阶段，在手机厂商巨头们垄断下，其他品牌们只能分的一杯残羹。追根究底，为何谷歌的智能手机业务做不起来？作为谷歌的软肋，它还能借5G手机在智能手机领域提高存在感吗？
迎来5G手机元年 谷歌也趁机发5G新机刷存在感​
2019年被外界认为是“5G手机元年”，不同国家地区大量的移动运营商都开始采用5G网络。当然，带动5G手机热度的还是要数众多手机厂商巨头了，在他们的推波助澜下，5G手机在未来将成为智能手机增长的最大动力之一。
根据全球知名市场研究与咨询机构最新发布的研究报告《至2024年，全球88国智能手机销量预测按技术划分》预测，5年内5G手机将占所有手机销量的近一半，到2025年，5G手机的销量预计将会超过10亿。Strategy Analytics预计，2019年5G设备的销量仅占总销量的不到1%，而到2020年该份额将会接近10%。
在4G手机领域，目前全球手机厂商的局面也是一目了然。根据研究机构Gartner的最新数据报告，在2019年全球智能手机销量仍呈现缓慢的下滑态势，第二季度销量下降1.7%，为3.68亿部（低于去年同期的3.74亿部）。其中，在销量排名前5的智能手机厂商中，三星依旧稳居第一，华为、苹果、小米、OPPO位列第二到第五位。
国产手机品牌华为、小米、OPPO、vivo也用它们的实力跟销量证明了自身在智能手机领域的地位，可以说在4G手机领域这几个品牌都是赢家。但进入5G时代，对于手机厂商们来说既是机遇也是挑战，他们能否抓住5G市场红利也是至关重要。
目前已有不少手机厂商都有推5G手机，但论影响力跟关注度还是要数手机厂商巨头们的存在感最高。手机品牌推5G手机考验的还是他们的内功实力，手机在5G网络下能否给消费者带来更好的体验。截至现在，三星、华为与小米等主要手机厂商均发布5G机型，在5G大潮中，唯独苹果还未有推出新机型，在时机点上还是有点落后另外几家友商。
尽管目前市场上有好几款5G手机产品，但也并未在消费级市场掀起很高的销售热潮，最根本的原因还是由于价格让人望而退步。据悉当前同一型号机型，只因支持5G，导致价格偏高，三星手机Galaxy Note10 5G版最便宜6599元，华为Mate30 5G最低价格4999元，小米9 Pro 5G价格则在3699元。
在智能手机领域，谷歌只能说算是其中的参与者之一，手机影响力在全球都没有很高的热度，在其它手机厂商动辄几千万销量的基础上，谷歌手机却只有几百万的销量，存在的差距还是显而易见。
这次谷歌也被外媒爆出将推5G手机也算是情理之中，一方面目前5G手机的热度很高，谷歌能够推出新机型还是说明它对于智能手机业务还是很重视，另一方面这说不定对于谷歌来说也是一个机会，只是谷歌的5G手机要想出圈难度还是很大，谷歌似乎做智能手机真的行不通。
智能手机成谷歌的“心病” 扶不起的阿斗也舍不得放弃
在华为跟苹果的重压下，谷歌的5G手机会有新出路？尽管谷歌做智能手机的时间并不长，但作为全球数一数二的科技巨头，谷歌做智能手机却没能做出很大的成就，这也算是谷歌众多业务当中的一个“污点”。对于谷歌来说，本身她的安卓系统在智能手机领域是唯一能跟iOS系统抗衡的，借助自家系统研发手机应该是得天独厚的优势，但根据推出的手机市场反馈来看，几乎是雷声大雨点小，并没有为谷歌带来很高的回报。
为何谷歌的智能手机做不起来？在外界看来，谷歌没有将智能手机做成功是受多方面原因的影响，在美股研究社看来主要集中在以下几个方面。
一、 谷歌智能手机在美国没有跟运营商打好关系，没有渠道资源卖货
对于手机厂商来说，渠道的重要性不言而喻，这是他们的手机面向最广泛用户的最有利渠道之一。据悉谷歌Pixel手机的主要市场在美国，美国市场和中国市场不同，美国智能手机的出货依靠的是电信运营商，但和谷歌合作的只有Verizon，其他的三家比如AT＆T，T-Mobile，Sprint并未达成合作。
对于谷歌来说，没有运营商渠道的支持，再好的手机产品在美国市场也行不通。线下运营商在全国各地都有门店，其实是最容易触达消费者的，谷歌没有跟这些运营商打好关系，这已经让它在手机销量上面遭遇不小的阻力。苹果则不然，和这些运营商的关系十分良好，这也不难理解为何苹果在美国市场的销量一直很好。
二、 谷歌安卓系统对手机厂商开放，自身做手机受到不少限制
在智能手机领域，除了硬件很重要之外，系统就犹如智能硬件的开关，掌控了智能手机能够为手机提供什么样的功能服务。目前，智能手机领域主要是两大系统，安卓跟iOS系统。对于谷歌来说，它在2005年8月收购注资的Android系统，可以说是它收购史上最划算的一笔交易。
相对iOS的封闭系统，安卓则是采取对所有手机厂商开放的原则。根据最新的数据显示，在全球智能手机市场里，Android（安卓）系统的市场占有率已经高达87%。对于谷歌来说，开放安卓系统给它带来了巨额的回报，因为一方面它占领移动互联网入口；另一方面部署其它业务，抢占市场先机推出移动搜索、谷歌地图，谷歌商店等这些应用为它带来几百亿美元的广告营收。
尽管谷歌拥有安卓系统，但正由于该系统是对手机厂商开放，那它自身做手机其实就会有一些顾虑，有种既当运动员还做裁判员，并不利于获得外界的认可。一旦谷歌大规模的加大对手机的投入，其它厂商势必会有不良的反应，最终会影响到整个安卓系统的大生态体系。从这个角度来看，谷歌做智能手机其实处境有点尴尬。
三、 谷歌智能手机对中国市场不够重视，错失最大的市场发展红利
作为全球最大的智能手机市场，中国市场成为众多手机厂商厮杀的重点，但似乎谷歌做智能手机并没有对中国市场很重视。根据最新的一组数据来看，中国市场的智能手机销量仍然很猛。根据中国信通院发布的数据显示，2019年7月中国智能手机出货量为3295.2万部；累计方面，2019年1-7月中国智能手机出货量达到2.10亿部，同比下降4.2%，占同期手机出货量的95.6%，其中Android手机在智能手机中占比92.9%。
对于谷歌来说，不可否认的是它在中国市场面临很强劲的对手，尤其是华为、小米、OPPO、vivo等都根据自身的实力在市场上确立了不小的竞争力，但是不进军中国市场这注定让它分不到在中国市场的这块大蛋糕。虽然安卓手机在中国市场占据了绝对优势，可谷歌自家的智能手机在中国市场销量为零，不进入全球最大的智能手机市场，怎么会有销量方面的提升？
除了不重视中国市场之外，而在全球的其他市场，谷歌Pixel手机还缺少线下零售合作伙伴以及自建门店，这也让它在其它海外市场的销量并不理想。
从上面几个因素来看，可以看出谷歌智能手机没有做起来受到内外两大因素的影响，尽管谷歌各种条件都看起来很优越，但在智能手机这方面它毕竟受到很多束缚，如果不能全心做这个业务的话，谷歌的智能手机业务在未来很有可能仍然没有什么大水花。这次谷歌将推5G手机也还是看出，它对于智能手机业务并没有放弃，只是它还有机会借5G来自家手机正名吗？
5G将成谷歌智能手机最后一张车票 能否上演弯道超车待考验？
尽管现在5G手机被炒的很火热，但目前头部手机厂商还只是推出了试水的产品来试探消费级市场对于5G手机的接受程度。2019年很有可能也只是5G手机在市场上的初亮相，随着5G网络技术在明年大范围的普及，明年将会成为手机厂商们集中武器厮杀的一年。
对于谷歌来说，头部手机厂商尽管在4G智能手机领域存在感很高，但他们在5G手机领域可以说是都还处于同一起跑线，在销量上、品牌效应、消费者口碑方面，不论是华为、三星还是小米等都未在5G手机这领域并未很大的差距，对于谷歌来说这很有可能是它的5G手机的一次重要转折点。只是谷歌的5G手机要想被消费者买单难度要更大，未来要从哪些方面用心呢？
之前谷歌推出的Pixel手机系列在功能方面就受到不少用户的指责，其实对于智能手机来说没有创新突破的点还是很难以获得消费者青睐。目前市面上的5G手机价格是个不小的问题，对于谷歌而言后续5G手机定位走什么样的路线其实也很关键，毕竟在一开始要想带动消费者换机的热潮，价格因素不可忽略。因此，对于谷歌来说，如何保证自家5G手机在性能跟价格上都有很大的优势很关键。
另外在渠道方面，这算是谷歌做智能手机的一个短板，未来如何在美国市场争取到更多运营商的合作仍然很关键。海外市场虽说会让谷歌在成本投入方面有所增加，但这也是带动手机销量增长的重要市场，尤其是中国市场的智能手机出货量仍然很高，后续谷歌如何让5G手机顺利入华也很重要。
作为全球智能手机市场的新玩家，谷歌的Pixel手机系列目前市占率还不到0.5%，可以说这也算是谷歌的“屈辱”，这次要重磅推出5G手机也还是说明谷歌对智能手机仍然很重视，这也将成为谷歌在智能手机领域的最后一次出场机会，一旦它没有抓住5G的发展风口，后续可能仍然平淡无奇了。谷歌5G手机能否上演弯道超车的戏码，美股研究社也会继续关注它的后续动向。
作者：elainezhao
本文作者：美股研究社—旨在帮助中国投资者理解世界，专注报道美国科技股和中概股，对美股感兴趣的朋友赶紧关注我们
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3f90da37243bd5264f7c961a56ea401/" rel="bookmark">
			AAPT: error: resource android:attr/colorError not found 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Android studio 3.5.0 导入一个项目（比较久的）， 编译错误：
AAPT: error: resource android:attr/colorError not found 最后是把 build.gradle 的targetSdkVersion 从 23 改成 26， 即 ： targetSdkVersion 26
具体原理还不懂，后续再看看 ^
可以参考 stackoverflow 大牛的帖子：
https://stackoverflow.com/questions/51973681/aapt-error-resource-androidattr-colorerror-not-found
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3dc22956121f3da0be5eaa79d8d99ba/" rel="bookmark">
			算法：循环赛日程表_一般化（n可以为奇数，也可以为偶数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法思路：
算法思路(N可能为奇数，也可能是偶数) 总体思路：按分治策略，将所有分为两半，n个选手可以通过n/2个选手设计的比赛日程表来决定。递归地用一分为二的略对选手进行分割，直到只剩下两个选手。 对于N为奇数的情况可以虚拟多一个选手，使其编程N+1个选手的日程表，最然后忽略虚拟运动员参与的比赛。对于分割时候N/2的情况也做特殊处理, 前n/2轮比赛空选手与下一个未参赛的选手进行比赛 存储结构： 数组 a[i][j], a[i][j]表示运动员i在第j天所遇到的选手 详细思路：
详细思路： （1）分治法， Tourna（n）： If n==1 a[1][1]=1;return; tourna(n/2);//递归分割 copy(n); //填表 （2）n为偶数的情况Copy（）函数：A.将左上角递归计算出的小块的所有数字按其相对位置抄到右下角，B.将右上角的小块的所有数字加n/2后按其相对位置抄到左下角，将左下角的小块中的所有数字按其相对位置抄到右上角 Viod copy(int n){ Int m=n/2; For i=1àm For j=1---&gt;m{ a[i][j+m]=a[i][j]+m;// 小块的数值抄到右下角 a[i+m][j]=a[i][j+m];// 右上抄到左下 a[i+m][j+m]=a[i][j];// 左下抄到右上 } } ---------------------------------------------------------------------------------------------------------------------- （3）一般性描述：n为偶数; n是奇数时增加一个虚拟选手n+1，将问题转换为n是偶数的情形。 tournament（n）: if n==1 : a[1][1]=1;return;//分割到最后 if n为奇数 ：tournament（n+1）;return;//奇数的情况加上虚拟选手 tournament（n/2）;//分割 makecopy(n);//这个函数copy分n为偶数很n为奇数的情况 （4） 判断奇偶 odd(n): Return n&amp;1; （5）makecopy（）与copy相似，并区分奇偶情况 makecopy(n): if n/2&gt;1 &amp;&amp;add(n/2) copyodd(n);//对n/2为奇数的情况的处理 else copy(n);//偶数的情况 (6)copyodd(n)实现n/2为奇数的时候的复制 n/2奇数的一种处理方法：前n/2轮比赛空选手与下一个未参赛的选手进行比赛 Copyodd(n): Int m=n/2 For i=1→m b[i]=m+i;b[m+i]=b[i]; for i=1→m for j=1→m+1{ if a[i][j]&gt;m: a[i][j]=b[i];a[m+i][j]=(b[i]+m)%n; else a[m+i][j]=a[i][j]+m; for j=2→m a[i][m+j]=b[i+j-1]; a[b[i+j-1]][m+j]=i } 三、时间效率： T(n)=T(n/2)+f(n) f(n)为copy的时间 f(n)=(n/2)^2 推出：T(n)=T(n/2)+(n/2)^2 N规模的问题做logN次f(n) T(n)属于O（∑O((n/(2^k))^2)） 1&lt;=k&lt;log(n) 也就是T(n)∈O(n^2) 如有不懂参考这位博主的详解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3dc22956121f3da0be5eaa79d8d99ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b756dd53109f65c12e596e1f8aa5f4e/" rel="bookmark">
			MacOS中图片的路径表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		但凡需要UI的程序，都要涉及图片，习惯win的图片路径：
D:\test1\\a.png Mac右键“显示简介”得到的路径，“‎⁨Macintosh HD⁩ ▸ ⁨用户⁩ ▸ ⁨carrot⁩ ▸ ⁨下载⁩”emmm用不了
记录一下得到可用的图片路径办法：
用浏览器打开图片，网址栏那里就是绝对路径啦！
/Users/carrot/Downloads/a127.jpg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94323d22e8eb592dedb525f01bcc281a/" rel="bookmark">
			python打包运行在Linux上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、借助工具PyInstaller 工具在window下可以打为exe，在Linux下可以打为执行程序
# 安装PyInstaller： pip install pyinstaller # 进入程序目录，用以下命令执行你的python文件 # 会生成dist目录 pyinstaller yourprogram.py # 进入dist下yourprogram目录，运行 ./yourprogram 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c38fb0ada239f0c1fea7e9a8e50e8eb/" rel="bookmark">
			django获取数据库数据并设置select下拉框当前值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题场景： Django开发，有后台数据对象info，要select下拉框中设置从数据库中读出来的值info.credit为当前值。
解决分析 方法：要设置下拉框的当前值，要通过js实现，将select的某个值设为选中，可以通过改对应的selected属性为selected，也可以用jquery框架直接将值为某个值的选项设为选中。 取值：但是在js里面要的获取后台数据库的数据有三种途径： 在后台往模板中的js代码块部分填入后台数据。
js中的代码,{{后台填入的值}}或者写进val中不用赋值给变量，第二句是用jQuery框架直接获取元素的，设它的当前值 var credit={{info_credit | safe }} $("#id_selector").val(credit); #django中的代码 def get_info(request): obj_info=ModuleInfo.objects.get(xxx_id=xxx_id)#查询数据库得到一个结果集变量 return render(request,'模板.html',{'info':obj_info,‘info_credit’:json.dumps(obj_info.credit)}) 在js函数里通过ajax请求获得json数据给js变量赋值
var credit=0 $.ajax({ url: "/ajax_query_credit/", type: "POST", data: {"info_id": '0'}, success: function (response) { credit=response['credit'] }, dataType: 'json', }); #后台 def ajax_query_credit(request): id_info=request.POST.get('id_info') obj_info=ModuleInfo.objects.get(id_info=id_info)#查询数据库得到一个结果集变量 return HttpResponse(json.dumps({'credit':id_info.credit})) 从html文件中获取对应元素的值
由于后台传入的是一个对象info，非json数据，在html中是{{info.credit}}直接取的，在js中不行，要为json数据。 （由于不想在后台传的参数中额外加入一个json化的info.credit）所以，这里在js里搞了个小操作。 在js中获取html模板中的已经填好的值，再将html的{{info.credit}}给隐藏掉。 html：&lt;p id="hide_credit" hidden&gt;{{info.credit}}&lt;/p&gt; js: $("#id_credit_selector").val($("#hide_language").text()); 注意：写入js中的要是json数据，所以写入js的数据后台要转化字典值为json。还有在views中写好了功能函数记得在urls.py绑定url请求哦，格式path('/xxx/',views.xxx),。我用的是最后一种，用哪种根据具体情况而定。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44298c05fbe0692167ef1f986890a629/" rel="bookmark">
			一些常见的js校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来总结一下一些常用的js校验：
vernull = function(value){ //非空校验
if(value.trim(value).length == 0){
return false;
}else{
return true;
}
}
veridc = function(value){ //身份证校验
var ext = /(^\d{15}&amp;)|(^\d{18})|(^\d{17}(\d|X|x)$)/;
return ext.test(value);
}
veren = function(value){ //英文校验
var ext = /(^[a-zA-Z]+$)/;
return ext.test(value);
}
vernum = function(value){ //数字校验
var ext = /^[0-9]*$/;
return ext.test(value);
}
verdou = function(value){ //小数校验
var ext = /^[0-9]+(.[0-9]{1,3})?$/;
return ext.test(value);
}
vermail = function(value){ //邮箱校验
var ext = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((\.[a-zA-Z0-9_-]{2,3}){1,2})$/;
return ext.test(value);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44298c05fbe0692167ef1f986890a629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d5182c0e92d0a02db44137f8c5ae4e/" rel="bookmark">
			jmeter---Throughput（吞吐量）系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JMeter中吞吐量相关的组件 界面简介1，Throughput Controller（吞吐量控制器）2，Constant Throughput Timer（常数吞吐量定时器）3，jp@gc - Bytes Throughput Over Time（吞吐量和时间关系图）4，jp@gc - Transaction Throughput vs Threads（吞吐量和线程关系图）5，jp@gc - Transactions per Second（TPS曲线，分析吞吐量） 界面简介 1，Throughput Controller（吞吐量控制器） 控制该控制器下请求的执行频率，可以选择总次数和百分比两种模式。Total Executions（执行总次数，N为整数）Percent executions（执行百分比，N为1-100整数）Per User ：是否针对每个用户，在线程数为1的情况下，勾不勾选，执行效果一样百分比模式下的执行次数：线程数循环次数（N/100） 举个次数栗子：
1，设置脚本如下
2，线程设置：
3，吞吐量控制器设置：
4， 执行结果：
线程循环数是5次，控制器设置了3次，执行结果为3次
Per User 的勾选
这个按钮的作用是：勾选了之后，针对每个用户都是只执行3次，也就是对应线程中的线程数的设置
栗子：
线程设置
不勾选执行结果：
只有一个用户执行了3次
勾选执行结果：
每个用户都执行了3次
2，Constant Throughput Timer（常数吞吐量定时器） 3，jp@gc - Bytes Throughput Over Time（吞吐量和时间关系图） 4，jp@gc - Transaction Throughput vs Threads（吞吐量和线程关系图） 5，jp@gc - Transactions per Second（TPS曲线，分析吞吐量） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd2d73bf8905d79fd6f44ad6c866d0e/" rel="bookmark">
			详解java虚拟机--JVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java虚拟机概述： JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器码执行。这就是Java的能够“一次编译，到处运行”的原因。
一、类加载器 首先来看一下java程序的执行过程
1.Bootstrap class loader（引导类加载器）：
当运行java虚拟机时，这个类加载器被创建，它加载运行时核心类库比如rt.jar和一些基本的java API，包括Object这个类。需要注意的是，这个类加载器不是用java语言写的，而是用C/C++写的。
2.Extension class loader（扩展类加载器）：
这个加载器加载除了基本API之外的一些拓展类，包括一些与安全性能相关的类。
3.System Class Loader（系统类加载器，也叫APP类加载器）:
它加载应用程序中的类，也就是在你的classpath中配置的类。
4.User-Defined Class Loader:
这是开发人员通过拓展ClassLoader类定义的自定义加载器，加载程序员定义的一些类。
委派模式（Delegation Mode）
仔细看上面的层次结构，当JVM加载一个类的时候，下层的加载器会将任务委托给上一层类加载器，上一层加载检查它的命名空间中是否已经加载这个类，如果已经加载，直接使用这个类。如果没有加载，继续往上委托直到顶部。检查完了之后，按照相反的顺序进行加载，如果Bootstrap加载器找不到这个类，则往下委托，直到找到类文件。这种委托模式被称为双亲委托。为什么要采用这种模式呢？
因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。
考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被Bootstrap加载过，所以用户自定义类就不会被加载了。
双亲委托机制类加载流程：
举个具体的例子来说明，现在假如我有一个自己定义的类MyClass需要加载，如果不指定的话，一般交App（System）加载。接到任务后，System检查自己的库里是否已经有这个类，发现没有之后委托给Extension，Extension进行同样的检查，发现还是没有继续往上委托，最顶层的Boots发现自己库里也没有，于是根据它的路径（Java 核心类库，如java.lang）尝试去加载，没找到这个MyClass类，于是只好（人家看好你，交给你完成，你无能为力，只好交给别人啦）往下委托给Extension，Extension到自己的路径（JAVA_HOME/jre/lib/ext)里找，还是没找到，继续往下，此时System加载器到classpath路径寻找，找到了，于是加载到Java虚拟机。
二、JVM内存区域模型 1.方法区
它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。
运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。
2.虚拟机栈
描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。
局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。
3.本地方法栈
与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。
4.堆 也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。
由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。
新生代：
程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。
老年代：
用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。
老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。
5.程序计数器 是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。
三、垃圾回收机制的意义 Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。
内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。
内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。（参考jvm 异常分析：https://blog.csdn.net/donkeyboy001/article/details/102458501）
垃圾回收机制中的算法：
Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：
（1）发现无用信息对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd2d73bf8905d79fd6f44ad6c866d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0596680823069da7a3e48e15c33d5a47/" rel="bookmark">
			Navicat通过frm、ibd文件恢复mysql表数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、应用背景 一般正式数据库服务环境都有定时备份功能，例如我的阿里云MySql数据库服务器设置是每天备份一次，保留最近7天的数据。而我用的数据库引擎是 InnoDB，这种引擎下备份的数据表文件是frm、ibd格式的数据，直接拷贝是无法使用的。那么我们可以通过以下操作恢复某个数据表的数据（以user表作为示例）。
二、数据恢复 1、已知数据表结构 （1）、新建一个数据库，编码要一致
（2）、先创建一个一摸一样的空的同名数据表
（3）、拷贝原frm文件覆盖新建表的frm
（4）、在 Navicat Premium 中运行
alter table user discard tablespace; （5）、先停止mysql服务，拷贝ibd文件，并覆盖新建的ibd
（6）、启动mysql服务，在 Navicat Premium 中运行
alter table user import tablespace; 2、已知数据表结构 （1）、新建一个数据库，编码要一致
（2）、开启mysql的日志：关闭mysql服务，打开my.ini ，添加如下代码
[mysqld] log-error="D:\Java\mysql-5.6.21-winx64\log\mysql_log_err.txt" （3）、先创建一个空的同名数据表（user），将原数据表的frm文件拷贝到新数据库中， 重启mysql服务。
运行：select * from user; 此时会报 Table 'xxx.user' doesn't exist.错误。
打开日志文件，会看到最后几行错误如下：说明表中有4个属性字段。
（4）、关闭mysql服务，直接从数据库的文件夹里删除掉刚创建的user表的2文件，user.frm\user.ibd
（5）、启动mysql服务，重新创建包含4个属性字段的user表，字段名称随意。
选项设置为：
（6）、拷贝原frm文件覆盖新建表的frm，运行查询语句，就会发现表结构就一致了。
（7）、在 Navicat Premium 中运行
alter table user discard tablespace; （8）、先停止mysql服务，拷贝ibd文件到新建的数据库中
（9）、启动mysql服务，在 Navicat Premium 中运行
alter table user import tablespace; （10）、打开表user ,如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0596680823069da7a3e48e15c33d5a47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e720c18a69ebfd62dbd17f426936851b/" rel="bookmark">
			Zookeeper技术：分布式架构详解、分布式技术详解、分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分布式架构详解 1、分布式发展历程
1.1 单点集中式
特点：App、DB、FileServer都部署在一台机器上。并且访问请求量较少
1.2 应用服务和数据服务拆分
特点：App、DB、FileServer分别部署在独立服务器上。并且访问请求量较少
1.3 使用缓存改善性能
特点：数据库中频繁访问的数据存储在缓存服务器中，减少数据库的访问次数，降低数据库的压力
1.4 应用服务器集群
特点：多台应用服务器通过负载均衡同时对外提供服务，解决单台服务器处理能力上限的问题
1.5 数据库读写分离
特点：数据库进行读写分离（主从）设计，解决数据库的处理压力
1.6 反向代理和CDN加速
特点：采用反向代理和CDN加快系统的访问速度
1.7 分布式文件系统和分布式数据库
特点：数据库采用分布式数据库，文件系统采用分布式文件系统
随着业务的发展，最终数据库读写分离也将无法满足需求，需要采用分布式数据库和分布式文件系统来支撑
分布式数据库是数据库拆分后的最后方法，只有在单表规模非常庞大的时候才使用，更常用的数据库拆分手段是业务分库，将不同业务的数据库部署在不同的机器上
二、 分布式技术详解 1. 并发性
2. 分布性
大任务拆分成多个任务部署到多台机器上对外提供服务
3. 缺乏全局时钟
时间要统一
4. 对等性
一个服务部署在多台机器上是一样的，无任何差别
5. 故障肯定会发生
硬盘坏了 CPU烧了....
三、分布式事务 1. ACID
原子性（Atomicity）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
比如A有500元，B有300元，A向B转账100，无论怎么样，A和B的总和总是800元
隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
2. 2P/3P
2P= Two Phase commit 二段提交（RDBMS（关系型数据库管理系统）经常就是这种机制，保证强一致性）
3P= Three Phase commit 三段提交
说明：2P/3P是为了保证事务的ACID（原子性、一致性、隔离性、持久性）
2.1 2P的两个阶段
阶段1：提交事务请求（投票阶段）询问是否可以提交事务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e720c18a69ebfd62dbd17f426936851b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa7f813b81f8490fc9ae07c1d82fc75/" rel="bookmark">
			「UR#5」怎样更有力气
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「UR#5」怎样更有力气 解题思路
考虑没有限制的情况，一定是把操作离线下来，按照边权从小到达做。可以发现，如果没有限制，完全图是多余的，直接拿树边进行合并就可以了。我们要做这么一件事情，把每个点属于的图上联通块看做颜色，每次合并链上相邻两块颜色不一样的，那么我们再额外使用一个并查集，把树上相邻的颜色相同的点合并在一个集合里，每次跳到集合中最浅的点做图上的合并操作即可，复杂度 \(\mathcal O(n\alpha(n))\) 。考虑一个操作的限制数量 \(cnt\) ，如果 \(cnt \geq\) 链上的点数，那么这些点仍然是联通的，所以可以直接当做没有限制的情况来做。于是发现，有限制的情况的链的点数不超过 \(p_i\) ，考虑暴力把这条链上的点拿出来。问题转化为有一个点集 \(S\) ，并且给出这个点集的补图，要合并联通块信息。涉及到补图可以试图用一个小技巧解决，拿出补图中度数最小的点 \(x\) ，有 \(\deg[x]\leq \min(|S|,\sqrt{p_i})\) 。划分成与 \(x\) 相连的点集和与 \(x\) 不相邻的点集两个问题考虑。所有不与 \(x\) 相连的点可以直接与 \(x\) 合并，所有与 \(x\) 相邻的点不超过 \(\sqrt{p_i}\) 个，可以直接枚举两个点合并。对于两个集合直接的连边，考虑与 \(x\) 相邻的集合的每一条对 \(x\) 不相邻集合的出边，如果出边数量 \(=\) 集合大小则无法连边，否则一定可以和 \(x\) 不相邻集合连边，直接连向 \(x\) 即可。总复杂度 \(\mathcal O(n \alpha(n))\) 。 code /*program by mangoyang*/ #include&lt;bits/stdc++.h&gt; #define inf (0x7f7f7f7f) #define Max(a, b) ((a) &gt; (b) ? (a) : (b)) #define Min(a, b) ((a) &lt; (b) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa7f813b81f8490fc9ae07c1d82fc75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fac50ebcde28234d7c764ee453d85db/" rel="bookmark">
			oppo面经-java开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oppo一面
（1）自我简介
（2）介绍一个自己做过的最得意的项目，项目的细节，难点，怎么解决的，还存在的问题，有什么优化的想法吗（这个我说了很长时间，面试官说非计算机专业的，有这种实习经验确实能加分）
（3）操作系统有了解过吗，linux基本操作命令
（4）给了一个排序算法的排序过程动态图，问能看出这个排序算法吗？排序的逻辑和时间复杂度？
后来我没看出来，面试官提示是冒泡的改进算法，顺序是把最大值交换过去，逆序则是把最小值交换过去
（5）sql语句，写一个group分组统计的语句，很简单
（6）有什么想问的。我问了面试官对我有什么建议，需要学习的地方。面试官人很好，说整体还不错，需要补一补算法和操作系统的知识，虽然在实际开发中数据结构算法用的较少，但是基础还是要多看看。
一面结束等结果
二面面经
（1）简介
（2）jvm模型
（3）场景题：一个10g的文件，包含许多qq号，且符合两个条件，无序，重复。现在给1核cpu,2g内存。用什么方法找到一个qq号
（4）用了哪些后端框架
（5）线程池的类型，有哪些可以调节的参数
（6）concurrent包有了解吗，有哪些常使用的类
（7）相比其他同学有哪些优势
（8）数据库索引类型
转载于:https://www.cnblogs.com/zz22--/p/11634071.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a10ddc3e45e21a3ca692b243253b2d0/" rel="bookmark">
			洛谷 P2765 魔术球问题 （dinic求最大流，最小边覆盖）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P2765 魔术球问题 题目描述 «问题描述：
假设有n根柱子，现要按下述规则在这n根柱子中依次放入编号为1，2，3，...的球。
（1）每次只能在某根柱子的最上面放球。
（2）在同一根柱子中，任何2个相邻球的编号之和为完全平方数。
试设计一个算法，计算出在n根柱子上最多能放多少个球。例如，在4 根柱子上最多可放11 个球。
«编程任务：
对于给定的n，计算在n根柱子上最多能放多少个球。
输入格式 第1 行有1个正整数n，表示柱子数。
输出格式 程序运行结束时，将n 根柱子上最多能放的球数以及相应的放置方案输出。文件的第一行是球数。接下来的n行，每行是一根柱子上的球的编号。
输入输出样例 输入 #1复制
4 输出 #1复制
11 1 8 2 7 9 3 6 10 4 5 11 说明/提示 4&lt;=n&lt;=55
思路： 首先知道放球的个数和柱子的个数是成正相关的，
一直增加球，对于每一个球i，将比其小的，能和其相加为平方数的，统一连中间边。
之所以叫中间边，是因为这题要拆点，设源点和汇点分别为S和T。
将每一个点i，拆为 Xi，Yi，
每一个点将其S与Xi连接，Yi与T连接，
中间点就是如果i节点和j节点相连接，
就Xi 与Yj，相连，。以上讲到的边，流量全为1.
当num个数建立的容量网络的最小边覆盖x&gt;n时，即n个柱子无法覆盖掉num个数时，
结束加边操作，此时num-1，就是N个柱子能覆盖到的最大数字。
在dinic算法中增光路的过程中，记录每一个v，增广的下一个节节点u。
一路链状输出就是方法。
代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;iomanip&gt; #define ALL(x) (x).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a10ddc3e45e21a3ca692b243253b2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bcbbd7835445a52f436104cde40076e/" rel="bookmark">
			proxmox的U盘制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要是讲解怎么制作优盘(U盘)启动盘。
一、安装前准备
1、下载U盘写盘软件
官方网站下载地址：https://rufus.ie/
备用下载地址：http://one.piaoyun.cc/ 在目录软路由&amp;NAS-工具相关下面
2、下载PVE ISO文件
官方网站下载地址：https://www.proxmox.com/en/downloads
备用下载地址：http://one.piaoyun.cc/ 在目录虚拟机-Proxmox VE下面
二、写入镜像文件
1、U盘插入电脑并打开写盘软件（请确保U盘里没有总要数据，因写盘会擦拭掉U盘原有数据）
2、选择刚刚下载好的PVE镜像文件并点击开始
3、点击开始后会提示 检测到 ISOHybrid 镜像，此时务必选择【以 DD 镜像 模式写入】，否则U盘无法安装PVE。
后续还会有警告提示，直接确定即可。
接下来，等待镜像写入
4、镜像写入完毕，点击关闭。至此，Proxmox VE(Proxmox Virtual Environment)的安装U盘已制作完成。
最后说一点：因为想着用最新版：proxmox-ve_5.4-1.iso 这个镜像，怎么制作都无法从优盘启动，无法安装，后面退其次，降级版本，使用：proxmox-ve_5.3-2.iso 制作成功，优盘引导安装成功！
如果使用UltraISO软件制作，引导写入方式请使用：RAW 格式
关于安装教程请访问下面的地址查看：
Proxmox VE(Proxmox Virtual Environment) V5.4 安装图文教程说明 - 飘云 - http://piaoyun.cc/1162.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7605e2fe2f0fc9ced007aff6938bcb9d/" rel="bookmark">
			FPGA逻辑面试笔试准备材料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 背景专业问题问题1 状态机的编码面试2 串口线最长有多少米问题3 负数补码的计算问题4 化简逻辑表达式问题5 什么是组合逻辑？什么是时序逻辑？问题6 谈一谈竞争冒险的产生、解决方案。问题7 谈一谈锁存器和触发器的区别问题8 谈一谈阻塞逻辑和非阻塞逻辑的区别。问题9 用异或门怎么构建非门？问题10 使用二选1选择器和一个非门实现异或问题11 使用二选一选择器mux构建或门问题12 用状态机进行序列检测问题13 什么是同步逻辑和异步逻辑问题14 如何理解触发器要满足建立/保持时间？问题15 什么是亚稳态？为什么两级触发可以防止亚稳态？问题16 时序约束的计算题问题17 解释FPAG和ASIC的概念及区别问题18 解释相关名词问题 19 数制转换问题 20 跨时钟域的几种方法问题 21 用与非门等设计一个全加法器问题 22 理解MOS门电路，根据门电路，写出表达式问题 23 关于FIFO的深度计算，你是如何理解？场景1、fa&gt;fb with no idle cycles in both write and read场景2 fa&gt;fb with two clock cycle delay between two successive read and write场景3 fa&gt;fb with idle cycles in both write and read场景4 fa 背景 由于平时也没太注重基础，这次针对我本人，自己准备了一些面试官可能问到的，以及网上别人被面试到的问题，问题的难度都不大，但你不复习也许就不行。
我的文章禁止转载！！！你可以收藏！
QQ：1183699227
资料推荐：
https://blog.csdn.net/ciscomonkey/article/details/102941101
专业问题 问题1 状态机的编码 在使用Verilog描述状态机时，通常用参数定义语句 parameter指定状态编码。常用的状态编码有三种分别是：递增二进制编码，格雷码和one-hot编码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7605e2fe2f0fc9ced007aff6938bcb9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e162f6071ea43f87f2e45cfb175d1b71/" rel="bookmark">
			Qt--多线程间的互斥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.多线程间的互斥
临界资源--每次只允许一个线程进行访问的资源
线程间的互斥--多个线程在同一个时刻需要访问临界资源
QMute类是一把线程锁，保证线程间的互斥--利用线程锁能够保证临界资源的安全性
QMutex中的关键成员函数
void lock()--当锁空闲时，获取锁并继续执行;当锁被获取时，阻塞并等待释放
void unlock()--释放锁(同一把锁的获取和释放必须在同一线程中成对出现 )
A.生产消费者问题
1.有n个生成者同时制造产品，并把产品放入仓库中
2.有m个消费者同时需要从仓库中取出产品
所定的规则是--当仓库未满，任意生产者可以存入产品，当仓库未空，任意消费者可以取出产品
代码示例
#include
#include
#include
#include
static QMutex g_mutex;//线程锁
static QString g_store;
class Producer : public QThread
{
protected:
void run()
{
int count = 0;
while(true)
{
g_mutex.lock();
g_store.append(QString::number((count++) % 10));
qDebug() &lt;&lt; objectName() &lt;&lt; " : " + g_store;
g_mutex.unlock();
msleep(1);
}
}
};
class Customer : public QThread
{
protected:
void run()
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e162f6071ea43f87f2e45cfb175d1b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48503528b21ccfdf159e309a43fa34d7/" rel="bookmark">
			const关键字总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中
const是C语言中总结
1.修饰的变量，使其具有常属性，使变量的值不能直接被改变。但是可以通过指针来间接的修改变量的值。
2.便于进行类型检查(在编译时进行类型检查)，使编译对处理内容有更多的了解，保护被修饰的东西，防止被意外修改，增强程序的健壮性。
3.方便的进行参数的调整和修改(类似于宏定义)
作用1说明：
修饰的变量，使其具有常属性，使变量的值不能直接被改变。但是可以通过指针来间接的修改变量的值
例如：
const int t=10;
//在以后的代码中，程序不可直接对i进行修改
//但是可通过指针来间接的修改i变量中存的值
t=2; //会报错
int *p=(int *)&amp;t;
*p=2; //在此处就将i中的值存成2了
const修饰指针变量：
int main()
{
int a = 10;
const int *p = &amp;a; //const修饰int *，即p的指向，因而p指向的内容即通过pa解引用后不能被修改，但是p中存的内容可以改变，即p的指向可以改变
int * const q=&amp;a; //const修饰*，即q变量，因而q里存的内容不能变，即q的指向不能改变，但是q指向的内容即a中的内容可以修改。
p++;//正确
(*p)++;//错误
q++;//错误
(*q)++;//正确
return 0;
}
所以看const修饰谁，要看const右面有什么
比如：
int **const* p; 则通过*p来修改对应的内容则报错
int **const** p; 则通过**p来修改内容则会报错
通过const的特性，const可以在很多地方派上用场
比如在传参时，不想通过函数来改变实参值，在传实参地址时，形参接收在前可加const修饰，这样就不会在函数里通过解引用来修改实参值了
在C语言中，const不用来修饰函数，原因看C++的用法
在C++中
在c++中：
1.const修饰变量的用法和作用与c语言一样，但是有一点不同
#include
using namespace std;
int main()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48503528b21ccfdf159e309a43fa34d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674ff275af4475bdcd11507150ac2cca/" rel="bookmark">
			腾讯股票API获取上证指数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用腾讯股票API，获取上证指数的日k数据：
http://web.ifzq.gtimg.cn/appstock/app/fqkline/get?param=sh000001,day,2017-12-01,,640,qfq 参数简述：
sh000001--上证指数；
param=代码,日k，开始日期，结束日期，获取多少个交易日，前复权
返回：
["2019-09-30","2927.920","2905.190","2936.480","2905.190","116646811.000"]], 交易日，开盘价，收盘价，最高价，最低价,总手 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07492fcbeda0088f284c5d0554837310/" rel="bookmark">
			P4016 负载平衡问题(最小费用最大流)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P4016 负载平衡问题 题目描述 GG 公司有 nn 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 nn 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。
输入格式 文件的第 11 行中有 11 个正整数 nn，表示有 nn 个仓库。
第 22 行中有 nn 个正整数，表示 nn 个仓库的库存量。
输出格式 输出最少搬运量。
输入输出样例 输入 #1复制
5 17 9 14 16 4 输出 #1复制
11 说明/提示 \(1&lt;=n&lt;=100\)
思路： 「问题分析」
转化为供求平衡问题，用最小费用最大流解决。
「建模方法」
首先求出所有仓库存货量平均值，设第i个仓库的盈余量为A[i]，A[i] = 第i个仓库原有存货量 – 平均存货量。建立二分图，把每个仓库抽象为两个节点Xi和Yi。增设附加源S汇T。
1、如果A[i]&gt;0，从S向Xi连一条容量为A[i]，费用为0的有向边。
2、如果A[i]&lt;0，从Yi向T连一条容量为-A[i]，费用为0的有向边。
3、每个Xi向两个相邻顶点j，从Xi到Xj连接一条容量为无穷大，费用为1的有向边，从Xi到Yj连接一条容量为无穷大，费用为1的有向边。
求最小费用最大流，最小费用流值就是最少搬运量。
「建模分析」
计算出每个仓库的盈余后，可以把问题转化为供求问题。建立供求网络，把二分图X集合中所有节点看做供应节点，Y集合所有节点看做需求节点，在能一次搬运满足供需的Xi和Yj之间连接一条费用为1的有向边，表示搬运一个单位货物费用为1。另外还要在Xi与相邻的Xj之间连接边，表示货物可以暂时搬运过去，不立即满足需求，费用也为1。最大流满足了所有的盈余和亏损供求平衡，最小费用就是最少搬运量。
以上拷贝自：http://hzwer.com/1955.html 这位聚聚博主。
我的代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;iomanip&gt; #define ALL(x) (x).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07492fcbeda0088f284c5d0554837310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5774525b10a92c727328c9eacfb90c/" rel="bookmark">
			Mac  激活win10-报错：所请求的操作需要提升特权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装win10后需要激活码
按照教程的三句代码安装
slmgr.vbs /upk
slmgr /ipk+激活码
slmgr /ato
（之前是直接搜索cmd打开的命令提示符）报错如下：
解决办法： 找到C盘Windows路径下System的cmd，右键“管理员身份运行”
再输入那三行就可以了
转载一个博主的win10激活码文章：（避免到期后我又找不到了）
文章链接https://blog.csdn.net/RootCode/article/details/86589928
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33cbbc04d86f8850b462ecb096e1a5d/" rel="bookmark">
			bootstrap&#43;spring boot实现面包屑导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面包屑导航介绍
一般的内容型网站，例如CMS都会有这种面包屑导航。总结起来它有以下优势：
让用户了解目前所在的位置，以及当前页面在整个网站中所在的位置；
体现了网站的架构层级；提高了用户体验；
减少返回到上一级页面的操作；
实现效果
那我们应该如何实现？我看网上多数都是只提供静态实现，
这里我结合bootstrap 和 spring boot以及mysql来做一个完整的例子。
表结构设计
图里面的菜单其实是分级维护上下级关系的。我这里用到了2级，表里有level字段标记。
点击第1级加载第2级分类，点击第2级分类名称则展示面包屑导航。
CREATE TABLE `tb_category` (
`id` bigint(20) NOT NULL AUTO_INCREMENT,
`category_name` varchar(100) NOT NULL,
`parent_id` bigint(20) DEFAULT NULL,
`level` tinyint(1) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
insert into tb_category values(1,'Java文档',0,1);
insert into tb_category values(2,'Java多线程',1,2);
insert into tb_category values(3,'Spring Boot',1,2);
insert into tb_category values(4,'微服务实战',1,2);
insert into tb_category values(5,'Java视频',0,1);
insert into tb_category values(6,'Java基础',5,2);
insert into tb_category values(7,'Java基础',1,2);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c33cbbc04d86f8850b462ecb096e1a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171995b38ed704ed46aae6f6bbd2a580/" rel="bookmark">
			Numpy和Pandas的使用入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Numpy
Numpy基本数据结构
np.array()函数接受一个多维list,返回对应纬度的矩阵
vector = np.array([1, 2, 3, 4])
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
特殊矩阵:
np.zeros((第一维size, 第二维size, ...)) 初始化全零矩阵,要求传入的是一个元组,存储各个维度上的尺寸.
np.ones((第一维size, 第二维size, ...)) 初始化全一矩阵,要求传入的是一个元组,存储各个维度上的尺寸.
np.arange(起点, 终点, 步长) 创建一个序列
np.eye(size) 创建一个size*size的单位矩阵
np.linspace(起点, 终点, 数列长度) 返回一个从起点到终点线性插值的长度为数列长度序列
np.logspace(起点指数, 终点指数, 数列长度, base=底数) 返回从 底数起点指数 到底数终点指数的长度为数列长度的等比序列
Numpy基本操作和属性
一个矩阵中存储的数据类型应该相同,其dtype属性返回矩阵中元素的数据类型
使用astype(类型)方法安全地改变元素的数据类型.
vector = numpy.array(["1", "2", "3", "4"]) # ['1' '2' '3' '4']
vector = vector.astype(float) # [1. 2. 3. 4.]
矩阵对象的shape属性返回其各维度上的尺寸.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/171995b38ed704ed46aae6f6bbd2a580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8ad6fd26cc5512fdf4fc550eaf2579/" rel="bookmark">
			互联网公司去年到今年的大批裁员，这是怎么了？程序员该何去何从
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近这几个月，网络上接连报道美图、拉勾网、锤子手机等知名互联网公司在裁员，互联网公司巨头BAT也迎来新一轮的“缩招”，业内人士纷纷表示担忧，互联网行业随着人口和流量红利的的逐渐消退，互联网公司的寒冬真的来了吗？
互联网发展迅速，所以有些工作不需要太多的人工操作，而且随着能力要求的不断提高，一些岗位没有存在的必要或者一个人可以身兼两种职位。再加上如今互联网公司太多，竞争也很激烈，如果面临经营不当等其他问题，很快便会从中被收购或者淘汰。所以，一些公司不得不通过一些其他途径来缓解某方面的压力，规划自己的行程，为以后的发展着想，自然有很多不符合条件的人会被刷下去。
程序员是技术类型，现在中小企业都是有自己的互联网产品，产品需要技术开发就要需要程序员，不管再怎么裁员都不会影响互联网发展方向，所以科技公司或互联网裁程序员并不在名单中。互联网技术是推动互联网发展最根本的问题，比如互联网安全，互联网技术研发等都是需要苦逼的程序员每天加班才有今天互联网。
这家公司裁员，那么同行肯定还会有招聘需求啊，你以前的知识积累不会随着裁员白白丢掉的。假如行业不行，就去需要你工种的临近行业，比如当初很多零售外企或者通信行业的程序员就会转行到互联网金融或者互联网行业。你要区分的是公司不行还是行业下滑，选择一个有前进的行业可靠的公司。更高的职位可以是技术方面的也可以是管理方面的。可以去招聘网站找下相关的招聘启事，对比自己的能力，看差距在哪里，需要补充哪些领域的知识。
技术+创业：这是一条很少有人走的路，而且就算选择了这条路也不意味着你能成功，选择创业你不仅仅需要过硬的技术能力，更要有敏锐的商业头脑和较高的情商，一般很少有同学会选择这条路，如果你选择了这条路请好好走下去，即便失败也会是你人生中不可多得一笔宝贵的记忆！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fd0dd84118394644eb7a356338ab4f/" rel="bookmark">
			四元环计数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想看就看吧
f o r ( u ) for(u) for(u)
f o r ( v : o u t u ) for(v : out _u) for(v:outu​)
f o r ( w : a d j v ) for(w : adj_v) for(w:adjv​)
a n s + = c n t [ w ] + + ans += cnt[w] ++ ans+=cnt[w]++
我们把无向图按度数从小往大连边，那么每个点的度数 o u t u &lt; = O ( m ) out_u&lt;=O(\sqrt m) outu​&lt;=O(m ​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29fd0dd84118394644eb7a356338ab4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f38dd09cdcac30313bc0de44db04d4b/" rel="bookmark">
			springboot中移除tomcat插件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 从依赖信息里移除 Tomcat配置 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a96d2a975789aa13e5b960c24cb85ee/" rel="bookmark">
			APP自动化时，关闭小米手机的USB安装提示弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大多数手机关闭USB安装提示弹窗很简单，但是小米手机很麻烦，很多人不知道怎么关闭。
以最新的MIUI10 系统为例
关闭USB安装弹窗，其实执行以下几步即可
需要点 设置 -&gt; 授权管理 -&gt; 右上角设置按钮 -&gt; USB安装管理 -&gt;关闭
但是很多人会发现，授权管理页面的右上角根本没有设置按钮啊
其实很简单，在开发者选项中 -&gt; 启动MIUI优化 -&gt;关闭
再返回到授权页面，就可以看到 右上角的设置按钮了，关闭USB安装管理后
通过USB安装就不会有确认弹窗了
Python自动化测试研究院： 560151970 （q群） B站主页：https://space.bilibili.com/403609135 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ff16eb244214d86083d697b104eda7/" rel="bookmark">
			VS2015关掉文本编辑器的注释自动补全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VS2015的文本编辑器里，要对代码块进行注释，当打出“/*”时，会自动补全为“/**/”，然而这不是我想要的，如何关掉它？
以C/C++为例，从菜单栏 - 工具 - 选项中打开下面的对话框，取消选择“自动大括号完成”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abeafab4d6d213e3c3b8b6b11544114d/" rel="bookmark">
			用Dockerfile定制镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dockerfile定制镜像 从刚才的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。
Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
以定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。
在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：
mkdir mynginx cd mynginx touch Dockerfile Dockerfire的内容：
FROM nginx RUN echo '&lt;h1&gt;Hello,Docker!&lt;/h1&gt;' /usr/share/nginx/html/index.html FROM 指定基础镜像 所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。
在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。
如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。
除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。
RUN 执行命令 RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：
shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。
RUN echo '&lt;h1&gt;Hello,Docker!&lt;/h1&gt;' /usr/share/nginx/html/index.html exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abeafab4d6d213e3c3b8b6b11544114d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc736ea67d6ccdb90e82805b8a5cd6fa/" rel="bookmark">
			粒子群算法笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实质：在定义域随机放置多个变量，不断跳跃，同步寻找最优解。寻找方向受单个粒子与全部粒子的最优位置共同影响。单个粒子按照公式不断迭代寻找当新位置。多个变量聚集在某一点时，该点即是最优解。
控制其搜索速度（步长）的因素有两个，使其兼备全局搜索能力和局部搜索能力，减少错过最优解几率
距离自身最优距离距离群体最优距离 状态转移方程： ：代表优化问题在D维空间上的一个解，对应于粒子群中第i个粒子的位置
：代表第i个粒子所经历的所有路程上最优的位置，即其在飞翔过程中离目标函数最优解最近的位置
：代表所有粒子经历过的路程上的最优位置（可以认为是所有个体最优位置当中的最优位置）
：代表粒子i的飞翔速度
参数说明： 粒子数m：一般为20-40。根据实际定义。惯性因子：一般在0.6-0.75.影响步长（即影响 全局/局部 搜索能力）。加速常数 c1 ，c2 : 控制速度的影响因素的权重。一般取2左右的值。常数r1 , r2 :在[0,1]之间随机数。v,x:步长和位移值。 基本粒子群算法 权重 w 为1.
算法改进 https://blog.csdn.net/xuehuafeiwu123/article/details/52299628
线性递减：前期有较高的全局搜索能力以找到合适的种子，后期有较高的开发能力，以加快收敛速度，故惯性权重递减。
学习因子、惯性权重是改进粒子群算法的关键
更新函数决定了粒子群算法的本质能力。
matlab实现 初始化种群（位置和速度权重随迭代次数的增加而降低（线性递减计算粒子适应度，将各个粒子的位置和适应度储存在Pbest中，将Pbest中适应度最优个体的位置和速度储存在Gbest中根据公式更新粒子的速度和位移将各个粒子与前一个最优位置比较，如果较好，则将其设置为当前最优位置比较当前的Pbest与上一周期的Gbest，更新Gbest达到迭代次数或者达到精度，停止。否则返回第二步 说明：
为防止粒子位置超过最大区间，设定界限，在粒子位置与步长进行迭代时，超过边界最值的则设定为最值r1,r2为随机数 matlab代码实现(后期改多维也很方便)
%	fitness	目标函数 %	N	粒子数目 %	c1,c2	学习因子	一般取2 %	w	权重 %	M	最大迭代次数	具体看精度要求 %	D	自变量个数/空间维度	由目标函数决定 %	a	上界 %	b	下界 %	Pbest	个体最优位置 %	PVbest	个体最优适应度 %	Gbest	种群最优位置 %	GVbest	种群最优适应度 %	目标函数	a = -10; b = 10; wmax = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc736ea67d6ccdb90e82805b8a5cd6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfef093f777c02876473ffc39c1159c8/" rel="bookmark">
			pycharm使用过程遇到的问题以及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		anaconda的使用相关问题 用python -m pip install --upgrade pip升级pip时出现报错twisted 18.7.0 requires PyHamcrest&gt;=1.9.0, which is not installed.
解决：PIP install PyHamcrest
若不成功，请参考https://blog.csdn.net/qq_36048987/article/details/89452858
通过anaconda添加第三方库时出现报错Non-zero exit code
很奇怪，添加库报错，但是anaconda的库都可以用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a002a6695b2367b6c53abc784b570170/" rel="bookmark">
			MFC多线程互斥锁的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MFC多线程互斥锁的使用 本例演示在MFC中使用多线程。第一部分实现多线程的开启、暂停、继续、注销（见上一篇文章MFC多线程的开启、暂停、继续和注销）。第二部分实现两个线程互斥锁的使用。
演示系统为Win10，平台为VS2017（MFC），主要使用类为CWinThread。
第二部分： 1.在原有基础上（见上一篇文章MFC多线程的开启、暂停、继续和注销）添加一个EDIT控件和一个线程MyThread2。
2.在ThreadTestDlg.h头文件中添加函数及变量声明：
static UINT MyThread2(LPVOID* pParam);//线程函数 CWinThread *Thread2;//线程2 3.在ThreadTestDlg.cpp实现文件上部中添加变量：
CMutex Mutex;//用于互斥锁 修改文件末尾线程1函数定义：
//线程1函数 UINT CThreadTestDlg::MyThread1(LPVOID* pParam) { CThreadTestDlg *ap1 = (CThreadTestDlg *)pParam;//获取主类指针，在多线程类中使用主类变量需要使用指针ap1-&gt; CSingleLock singleLock(&amp;Mutex); while(1) { if (ThreadKill) { DWORD dwExitCode;//指定线程的退出代码 GetExitCodeThread(ap1-&gt;Thread1, &amp;dwExitCode);//获取线程1的退出代码 AfxEndThread(dwExitCode, TRUE);//退出线程 } else { //singleLock.Lock();//没被调用就上锁自己用，已被调用就等着 //if (singleLock.IsLocked()) { n=1; strn.Format(_T("%d"), n); ap1-&gt;SetDlgItemText(IDC_EDIT1, strn); Sleep(30); } //singleLock.Unlock();//解锁 } } return 0; } 4.添加线程2函数定义：
UINT CThreadTestDlg::MyThread2(LPVOID* pParam) { CThreadTestDlg *ap2 = (CThreadTestDlg *)pParam;//获取主类指针，在多线程类中使用主类变量需要使用指针ap1-&gt; CSingleLock singleLock(&amp;Mutex); while (1) { if (ThreadKill) { DWORD dwExitCode;//指定线程的退出代码 GetExitCodeThread(ap2-&gt;Thread2, &amp;dwExitCode);//获取线程2的退出代码 AfxEndThread(dwExitCode, TRUE);//退出线程 } else { //singleLock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a002a6695b2367b6c53abc784b570170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a5243812513e1532eddaf2dc0316065/" rel="bookmark">
			从域环境搭建到域渗透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转发：
从域环境搭建到域渗透（上）
从域环境搭建到域渗透（下）
转载于:https://www.cnblogs.com/little-kwy/p/11622550.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc1e6e768eb339a8d21175052e57614/" rel="bookmark">
			Linux中root用户找不到JAVA_HOME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中root用户找不到JAVA_HOME 在Ubuntu环境中安装好Java环境后设置环境变量：在/etc/profile中设置好了JAVA_HOME变量并引入到PATH中，用于Ubuntu默认是不以root用户登录的，这时echo $PATH可以看到JAVA_HOME已经被设置好了，java命令也可以执行。接下来su root，再输入java命令提示找不到java命令，$PATH中也找不到JAVA_HOME这个路径了。查了很久的资料也没有找到原因，后来偶然切换用户的时候用了su - root命令，这时又可以找到JAVA_HOME这个变量了。
对比了一下su和su - 这两个命令的差别才明白：su是切换用户存取权限，但是没有获得环境变量，所以PATH没有被带入；su -是完全的切换用户，可以获得环境变量，所以可以找到JAVA_HOME。
转载于:https://www.cnblogs.com/micro-chen/p/11621966.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c30f0e9a7b8ef89709c48e631bb9204e/" rel="bookmark">
			Python multiprocessing Pool map()实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：并行处理某个目录下文件中的字符个数和行数，存入res.txt文件中
# coding=utf-8 import os import time import logging from multiprocessing import Pool x1, x2 = 3, 7 logging.basicConfig( level=logging.INFO, format="%(asctime)s [*] %(message)s" ) def getFile (path): # 获取目录下的文件list fileList = [] for root, dirs, files in list(os.walk(path)): for i in files: if i.endswith('.txt') or i.endswith('.py'): file = str(root + "\\" + i).replace("\\", "/") fileList.append(file) logging.info(file) return fileList def operFile (filePath_): # 统计每个文件中行数和字符数，并返回 filePath = filePath_.replace("/", "\\") with open(filePath, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c30f0e9a7b8ef89709c48e631bb9204e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c704f9d6a3a14d70d35ca173226110/" rel="bookmark">
			Address already in use:端口被占用的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在执行程序的过程中，我们经常会遇到“端口已被占用”“port xxxx is already in use”的情况：
我们首先要知道是哪个程序占用了端口，才能有目的的关闭该程序，使该端口空闲下来。
解决方案如下： 方法一： 1、执行Win+R，输入cmd，进入“命令提示符”界面
2、输入以下命令：
netstat -aon|findstr xxxx （xxxx：表示被占用的端口号） （netstat -aon：可以查看所有端口的占用情况）
例如：netstat -ano|findstr 7000
注：第一列(TCP、UDP)表示：协议
第二列(0.0.0.0:7000)：本地地址:端口
第三列(0.0.0.0:0)：外部地址：端口
第四列(LISTENING)：状态
第五列（4472）：PID（pid不是固定的）
3、输入
taskkill -f -pid PID PID：是上一条命令查出来第五列的对应结果 例如：taskkill -f -pid 4472
这样就能够终止占用对应端口号的程序了。
方法二: 第二种方法比较麻烦，需要先查看占用当前端口的进程名称，再使用结束进程的方法终止
1、执行 方法一 的前两条命令，查出进程的pid之后，
执行：
tasklist|findstr PID 查看该进程的名称 例如：tasklist|findstr 7000
注：第一列(KGService.exe)：映像名称
第二列(7236 Console)：PID会话名
第三列(1)：会话#
第四列(19,936 K)：内存使用
2、结束进程：
taskkill -f -t -im 映像名称 例如：taskkill -f -t -im KGService.exe
把"-" 改成 “/” 也行，如：taskkill /f /t /im KGService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c704f9d6a3a14d70d35ca173226110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84bf7b70429a4946c8a5636488cab6fa/" rel="bookmark">
			「清华集训2014」矩阵变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「清华集训2014」矩阵变换 解题思路
问题转化为找一个行与选的数字的完美匹配，记 \(pos[i][j]\) 为数字 \(i\) 在第 \(j\) 行的出现位置，要求不存在匹配边 \((a,b),(c,d)\) 使得 \(pos[b][a] &lt; pos[b][c]\ \&amp; \ pos[d][c] &gt; pos[b][c]\) 。
观察发现，这个式子相当于让一条边的权值看做 \(pos[x][y]\) ，当存在一个行与一个数没有匹配但是强行让它们匹配后数的权值会变大，行的权值会变小，这个时候就出现了不合法情况。那么就是一个稳定婚姻匹配的模型，GS算法解决之。
话说我可能还有十几天就退役了才会这个算法，实在是没救了。
最近写代码好丑，就不贴了。
转载于:https://www.cnblogs.com/mangoyang/p/11620429.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430bd4dc1adf8985c17944a5eb5a6cff/" rel="bookmark">
			Idea2019的安装及其相关配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先安装Jdk和Jre
https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
以上是JDK的下载地址，根据自己电脑版本的不同选择64位或32位
下载完成之后进行安装，基本上是默认进行，不过建议在安装路径上选择除C盘之外的硬盘进行存储，例如G:\Java\jdk1.8.0_221 这样的形式。
一般安装完成之后会显示是否还要继续安装jre，因为我们安装的JavaSE中默认含有jre，所以是否进行安装都是可以的，同时，jre和jdk安装的路径应该一直，例如G:\Java\jre1.8.0_221
2.配置Java环境
“我的电脑”右键属性–高级系统设置–高级–环境变量–系统变量选择“新建”
One.新建 JAVA_HOME 变量
Two.查看是否存在CLASSPATH变量，没有的话新建
Three.找到Path变量进行编辑，将“%JAVA_HOME%\bin”和“%JAVA_HOME%\jre\bin”加入Path的变量值中，如图所示
Four.配置完毕，控制台测试是否安装成功!
测试命令 java javac java -version
3.安装Idea 2019
安装好之后要配置自己的JDK的位置 即电脑中的JDK位置
Idea相关配置学习借鉴该链接 谢谢该链接提供者
https://blog.csdn.net/qq_42303709/article/details/81983208
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d23948eed7ce28d3f788a56069e381a4/" rel="bookmark">
			数据结构——线性表（顺序实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好好学习基础知识，出人头地就靠它了，内外兼修。(好吧，我现在内外都不行)写这篇文章的目的就是为了，巩固刚学完的线性表，个人能力有限，若有不当之处，望指出。
线性表 好了，扯完了，说正事：
1、定义
线性表是一种及其常用的并且最简单的一种数据结构。简单来说，线性表就是集合里的元素的有限排列。(在这里我把集合定义为具有相同属性的元素，会有些狭义)
在线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的(注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表(存储层次上属于链式存储)，但是把最后一个数据元素的尾指针指向了首位结点)[百度百科]
怎么说呢，毕竟数据结构毕竟是逻辑结构，逻辑上符合线性结构的特征即可，存储结构能实现就行。线性表的很重要！很重要！很重要！后面的栈，队列，串等都是基于线性表的基础上实现的，所以说一定要学好线性表
2、线性表的特点：
对于任意的的非空线性表或者线性结构有：
1、存在唯一一个被称为 ”第一个“的元素
2、存在唯一一个被称为 ”最后一个“的元素
3、出第一个元素之外，每一个元素都存在一个后继
4、除最后一个元素之外，每一个元素都存在一个前驱
3、基本操作
1、Create(*L)创建空表
2、InitEmpty(*L)初始化
3、getLength(*L)获取长度
4、Insert(*L)插入元素
5、Remove(*L)移除元素
6、IsEmpty(*L)空表检测
7、IsFulled(*L)表满检测(顺序表常用，链式表基本不用)
8、Delete(*L)删除表
9、getElemt(*L)获取元素
10、Traverse(*L)遍历输出所有元素
11、Clear(*L)清除所有元素
4 、实现 好了最麻烦的事情开始了，数据结构在计算机上的的映射。众所周知，线性表有两种实现方法，一种是顺序表，另一种是链式表，这两种结构实现最大的不同在于前者逻辑关系无需存储空间，而后者则需要用额外的空间(顺便记录一下，指针大小只由环境有关(严格意义上说和CPU的位数有关)本篇只实现顺序结构)。
1、顺序表：
先说一下概念：用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。
很明显对于顺序表来说：逻辑上相邻的数据元素，物理次序也是相邻的。 特点：
对表中任意元素访问时间复杂度都为常数级。
尾部插入元素时间复杂度也为常量级。
下面是重点！！！
说明一下，讲解的时候实现语言为C，后续会贴上C++和Python
实现：
敲~~~键盘，敲~~键盘！敲~~~键盘，敲~~键盘！
结构定义：　1 #define YWZLIST_INIT_SIZE 8 2 #define INC_SIZE 3 //空间增量的大小 3 4 typedef int ElemType; 5 typedef struct listnode 6 { 7 ElemType *base; 8 int capacity; //顺序表容量 9 int size; //表的大小 10 } YWZlist; 函数声明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d23948eed7ce28d3f788a56069e381a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd0a3221408b725078c58f45afdf461/" rel="bookmark">
			[C]编译器对char数组声明的一个行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 如果使用char[]来声明char数组，那么编译器会自动计算后面的字面量字符数，再加上一个空字符，作为它的长度。实际上这个数组最后一位被编译器强行加上了\0：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #define BUFFSIZE 4096 int main(void) { int fd_1 = open("./test_1.txt", O_RDWR); //为了改变fd_1的偏移值，输出一下fd_1的内容 char str[BUFFSIZE]; ssize_t n; //往test_1.txt写入一些信息 char str_2[] = "|append"; n = write(fd_1, str_2, sizeof(str_2)); //最终的输出结果是"|append\0"，在文本中，\0被当成了空格去显示 lseek(fd_2, 0, SEEK_SET); while((n = read(fd_1, str, BUFFSIZE)) &gt; 0){ printf("%s\n", str); } } 给数组加上长度，就可以解决上述"问题"：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #define BUFFSIZE 4096 int main(void) { int fd_1 = open("./test_1.txt", O_RDWR); //为了改变fd_1的偏移值，输出一下fd_1的内容 char str[BUFFSIZE]; ssize_t n; //往test_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afd0a3221408b725078c58f45afdf461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e135bbaaa4c01f321ab3a4c4ca382825/" rel="bookmark">
			Django 静态文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态文件 1.什么是静态文件 对于前端已经写好了的文件 我们只是拿过来使用 那么这些文件都可以称之为叫"静态文件"
静态文件可以是:bootstrap一类的前段框架, 已经写好了的图片,css,js 静态文件默认全都放在static文件夹下,static文件夹中默认会创建的子文件夹(手动创建):
css文件夹 当前网站所有的样式文件
js文件 当前网站所有的js文件
img文件 当前网站所有的图片文件
其他(前端框架代码 第三方插件代码...) 2.静态文件配置 (1):将static文件夹路径配置到settings.py中 # settings.py文件中: STATICFILES_DIRS = [ os.path.join(BASE_DIR,'static') ] # 你只要输入static文件夹内具体文件的路径就能够访问到 (2):利用解析器"动态解析"静态文件接口前缀 &lt;!--HTML文件中--&gt; {% load static %} &lt;link rel="stylesheet" href="{% static 'bootstrap-3.3.7-dist/css/bootstrap.min.css' %}"&gt; &lt;script src="{% static 'bootstrap-3.3.7-dist/js/bootstrap.min.js' %}"&gt;&lt;/script&gt; 注意 # 在settings.py文件中: STATIC_URL = '/static/' # 这个static不是文件夹的名字 而是接口前缀 """只要你想访问静态文件中的资源 文件路径就必须用static开头""" # 手动将static文件夹中所有的资源暴露给用户 STATICFILES_DIRS = [ os.path.join(BASE_DIR,'static'), # 真正的文件夹路径 os.path.join(BASE_DIR,'static1'), # 真正的文件夹路径 os.path.join(BASE_DIR,'static2'), # 真正的文件夹路径 os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e135bbaaa4c01f321ab3a4c4ca382825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4228f0fadc35ee4a1682257ed65af7c/" rel="bookmark">
			Python有用的内置函数divmod,id,sorted,enumerate,input,oct,eval,exec,isinstance,ord,chr,filter,vars,zip...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		divmod(a, b) 函数接收两个数字类型（非复数）参数，返回一个包含商和余数的元组(a // b, a % b) id() 函数用于获取对象的内存地址。 sorted(iterable, key=None, reverse=False) iterable -- 可迭代对象。key -- 用来进行比较的元素，具体的参数取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 enumerate(sequence, [start=0]) sequence -- 一个序列、迭代器或其他支持迭代对象。start -- 下标起始位置。
返回值:返回 enumerate(枚举) 对象。 input() 接受一个标准输入数据，返回为 string 类型。 oct() 数将一个整数转换成8进制字符串。 eval() 函数用来执行一个字符串表达式，并返回表达式的值。 exec() 执行储存在字符串或文件中的 Python 语句，相比于 eval，exec可以执行更复杂的 Python 代码。 isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。
isinstance() 与 type() 区别：
type() 不会认为子类是一种父类类型，不考虑继承关系。
isinstance() 会认为子类是一种父类类型，考虑继承关系。 ord() 将字符转换成对应的ASCII/Unicode数值 chr() 将一个数值转换成对应的字符 filter(function, iterable) 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4228f0fadc35ee4a1682257ed65af7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be578a92885f3cd826e72f6c37fb9bd/" rel="bookmark">
			快速搭建redis5.0集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis主从集群搭建 redis简单主从结构如上图所示，主从结构的redis由主节点负责读写操作，从节点负责读操作，这里做搭建介绍，具体工作原理不分析。
下载安装redis压缩包
解压压缩包，进入redis-5.0文件夹，运行命令./make install安装redis
安装完成进入redis-5.0/src文件夹，执行./redis-server 指定配置文件 即可启动redis
redis-cli 默认连接本机6379redis服务器
主从集群的搭建非常简单，要做的有一下的步骤：
注释掉redis-conf配置文件的以下配置，并且在redis-5.0/目录下创建一个文件夹6379-6380
# bind 127.0.0.1 #如果想要redis后台运行泽东配置为yes daemonize yes 根据redis.conf配置文件，复制两份配置文件到文件夹文件夹6379-6380，模拟在同一台机器上启动两个redis实例。复制文件名为master.conf和slave.conf
修改slave.conf配置文件端口为6380,增加配置slaveof 127.0.0.1 6379
port 6380 #主节点的主机地址和端口号，这里是本机 slaveof 127.0.0.1 6379 在src下执行redis-server命令，分别指定配置文件为刚才配置master和slave配置文件。连接6379的redis服务器，执行info replication,显示如下所示。 # Replication role:master connected_slaves:1 slave0:ip=127.0.0.1,port=6380,state=online,offset=224,lag=0 master_replid:201640b5a63c036087b7a459245a6f6a699b8a36 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:224 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:224 ​ 如果执行redis-cli -h 127.0.0.1 -p 6380则是指定连接从节点，执行info replication显示如下
# Replication role:slave master_host:127.0.0.1 master_port:6379 master_link_status:up master_last_io_seconds_ago:6 master_sync_in_progress:0 slave_repl_offset:462 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:201640b5a63c036087b7a459245a6f6a699b8a36 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:462 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:462 以上搭建起一个简单的主从集群
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be578a92885f3cd826e72f6c37fb9bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c85c6bd8c10cc7999467b91f4d64595/" rel="bookmark">
			谈我对于ajax的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ajax的全称是Asynchronous JavaScript and XML 中文名称定义为异步的JavaScript和XML。Ajax是Web2.0技术的核心由多种技术集合而成，使用Ajax技术不必刷新整个页面，只需对页面的局部进行更新，可以节省网络带宽，提高页面的加载速度，从而缩短用户等待时间，改善用户体验。
直白地说，就是没用AJAX的网页，你点一个按钮就要刷新一下页面，尽管新页面上只有一行字和当前页面不一样，但你还是要无聊地等待页面刷新。用了AJAX之后，你点击，然后页面上的一行字就变化了，页面本身不用刷。 AJAX只是一种技术，不是某种具体的东西。不同的浏览器有自己实现AJAX的组件。我们传统的web应用，当我们提交一个表单请求给服务器，服务器接收到请求之后，返回一个新的页面给浏览器，这种做法浪费了很多带宽，因为我们发送请求之前和获得的新页面两者中很多的html代码是相同的，由于每次用户的交互都需要向服务器发送请求，应用的访问时间取决于服务器的返回时间。而我们使用Ajax就不同了，Ajax只取回一些必须的数据，它使用SOAP、XML或者支持json 的Web Service接口，我们在客户端利用JavaScript处理来自服务器的响应，这样客户端和服务器之间的数据交互就减少了，然后用户请求就得到了加速。Ajax是多种技术的组合，包括我们JavaScript异步数据获取技术，就是XMLHttpRequest以及xml以及Dom还有表现技术XHTML 和CSSAjax的核心是XMLHttpRequest 是支持异步请求的技术，可以发送请求给服务器，并且不阻塞用户在IE浏览器中首次引用，使我们的网络应用更加强大。其实XMLHttpRequest是JavaScript的一种语法子集，是它的一套API，支持发送GET和POST请求。该API是Ajax开发的核心，也是现在web技术的核心之一。通过这些技术，我们无序重新加载网页就可以发送和取回数据，完成交互。 转载于:https://www.cnblogs.com/bichen-01/p/11612932.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8e4a55b54e549feec4b621047bfae8/" rel="bookmark">
			偷学笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计数知识/套路总结 一些比较基础的多项式 具体数学 网络流/模拟费用流 比较有趣的数据结构 字符串 做题杂记 图论（施工中） 转载于:https://www.cnblogs.com/mangoyang/p/11612842.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e98ff40f01f76ff98d25e6b568466f8/" rel="bookmark">
			返回顶部代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;dic id='scrollTop'&gt;返回顶部&lt;/div&gt;
&lt;script&gt;
$(function(){
$(function(){
$(window).scroll(function(){
if($(window.sctollTop()&gt;150){
$("#scrollTop").fadeIn(1000);
}else{
$("#scrollTop").fadeOut(1000);
}
});　});
//返回顶部动作
$("#scrollTop").click(function(){
$(body,html).animate({scrollTop:0},1000);
});
});
&lt;/script&gt;
转载于:https://www.cnblogs.com/sjzgk/p/11611499.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dfb16f32eebeebf2cc324f725f61ee0/" rel="bookmark">
			jquery 中this和$(this),.find() 与 .children() 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jquery 中this和$(this),.find() 与 .children() 的区别 this与$(this) $("#desktop a img").each(function(index){ alert($(this)); alert(this); } alert($(this)); 弹出的结果是[object Object ] alert(this); 弹出来的是[object HTMLImageElement] 也就是说，后者返回的是一个html对象(本例中是遍历HTML的img对象，所以为HTMLImageElement)。 Object - 是jquery对象 HTMLImageElement - 是一个html对象 var $backgroundImage = $(this).find(".news-thumb").css("background-image"); var $title = $(this).find("h2").text(); var $date = $(this).find("h6").text(); var $summary = $(this).find("p").html(); find() 和children() .find() 方法允许我们在 DOM 树中搜索这些元素的后代，并用匹配元素来构造一个新的 jQuery 对象(无论多少层子元素都可获取)。 .find() 与 .children() 方法类似，不同的是后者仅沿着 DOM 树向下遍历单一层级(仅获取下一层子元素)。 .find() 方法第一个明显特征是，其接受的选择器表达式与我们向 $() 函数传递的表达式的类型相同。 将通过测试这些元素是否匹配该表达式来对元素进行过滤。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f51bb48c0773d7b8a2d02fecdcda9e/" rel="bookmark">
			解决absolute fixed元素在安卓唤起虚拟键盘时，元素被挤上来。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//由于安卓虚拟键盘也会占位置，致使页面高度变小，所以absolute fixed元素跟着移动 //防止唤起键盘，导致absolute元素被挤上来 var isAndroid = navigator.userAgent.indexOf('Android') &gt; -1 || navigator.userAgent.indexOf('Adr') &gt; -1; if (isAndroid){//如果是安卓手机的浏览器 var win_h = $(window).height();//关键代码 $("body").height(win_h);//关键代码 window.addEventListener('resize', function () { // Document 对象的activeElement 属性返回文档中当前获得焦点的元素。 if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') { if($('.footerText').is(':visible')){ $('.footerText').hide(); }else{ $('.footerText').show(); } } }); } 转载于:https://www.cnblogs.com/wugai/p/11610907.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e15ee320361efaedd0bc527c63c389/" rel="bookmark">
			js递归实现多层级数组内获取兄弟节点id
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js递归实现多层级数组内获取兄弟节点id 最近做了一个需求
列表内有多个层级
要求可以实现每一级的列表项的上下移动
需要在点击下移一层时
将当前列表项平级向下移动一个位置
移动这部操作是后端实现的
前端需要在点击下移时获取当前项id和后面第一个兄弟节点的id
以下操作实现获取兄弟节点的id
直接上代码Demo:
&lt;button&gt;点击&lt;/button&gt; &lt;script&gt; let _btn = document.querySelector('button') const _list = [ {id:'1',parentId: null,level:1,name: '1a'}, {id:'2',parentId: null,level:1,name: '1b'}, {id:'3',parentId: null,level:1,name: '1c',children: [ {id:'01',parentId: '3',level:2,name: '2a'}, {id:'02',parentId: '3',level:2,name: '2b',children:[ {id:'001',parentId: '02',level:3,name: '3a'}, {id:'002',parentId: '02',level:3,name: '3b'}, {id:'003',parentId: '02',level:3,name: '3c'}, {id:'004',parentId: '02',level:3,name: '3d'}, {id:'005',parentId: '02',level:3,name: '3e'}, ]}, {id:'03',parentId: '3',level:2,name: '2c'}, {id:'04',parentId: '3',level:2,name: '2d'}, ]}, ] var _id = '003' var nextId = null _btn.onclick = function () { var ParentId = getParentId(_list) } // 获取当前行信息 function getParentId(list) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03e15ee320361efaedd0bc527c63c389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633de4b0c14ca52ea2432a3c8a5c4c31/" rel="bookmark">
			ff
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssr://MTcyLjEwNC4xMDIuMjk6NTQ0NDA6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOlkwUkRVekZsTWpGNE1VbGsvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNVFF4TGpreTVwZWw1cHlzJmdyb3VwPTVwZWw1cHlz
ssr://NTIuMTk0LjI1NS40NDoyNTI2MjpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46Um5GUGVXUnphWEU0TldwUC8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU9URXVORERtbDZYbW5Ldz0mZ3JvdXA9NXBlbDVweXM=
ssr://NTIuMTk5LjExNi4yNDoxNzYwMjpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46WTA5TWIybFNabWxUVm5wWC8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU9UY3VNVGptbDZYbW5Ldz0mZ3JvdXA9NXBlbDVweXM=
ssr://NTIuMTk5LjM3LjE4NToyNzk3ODpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46Y2xKemEwcFJXRU00VjB4bi8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU9UZ3VOemZtbDZYbW5Ldz0mZ3JvdXA9NXBlbDVweXM=
ssr://NTQuMTk5LjIyNC4xMzA6MzQ4MzM6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOk1qRmFkVkp4VWtwbE1HNHkvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FPVGt1TnpqbWw2WG1uS3c9Jmdyb3VwPTVwZWw1cHlz
ssr://NTQuMjM4LjE3OC4xMzg6MTMwMDA6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmNuRnFZMk0zUkVKR1ZXZEQvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FPVFV1T1RqbWw2WG1uS3c9Jmdyb3VwPTVwZWw1cHlz
ssr://NTQuOTUuNDcuMjY6NTM2MTY6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmNsQmxiM001ZG0wNVZrMUQvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FPVFl1T0RUbWw2WG1uS3c9Jmdyb3VwPTVwZWw1cHlz
以上为日本地区节点
ssr://MTM0LjIwOS41NS4xMTg6MTIwNjU6YXV0aF9zaGExX3Y0X2NvbXBhdGlibGU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoX2NvbXBhdGlibGU6YzNONExuSmxMVEkzTVRFeE5UZzIvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNell5TGpReDU3Nk81WnU5Jmdyb3VwPTU3Nk81WnU5
ssr://MTM0LjIwOS41NS4xMTg6MTIwNjU6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmMzTjRMbkpsTFRJM01URXhOVGcyLz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTXpZeUxqUXg1NzZPNVp1OSZncm91cD01NzZPNVp1OQ==
ssr://MTM4LjY4LjIxMS4xMTM6MTIxMzg6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmFYTjRMbmwwTFRBMk56Y3lOell5Lz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTVRrNUxqSTA1NzZPNVp1OSZncm91cD01NzZPNVp1OQ==
ssr://MTM4LjY4LjIxMi4xMzM6MTc0NTE6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmFYTjRMbmwwTFRjNE1qRTBOamd6Lz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTWpReExqUTU1NzZPNVp1OSZncm91cD01NzZPNVp1OQ==
ssr://MTM4LjY4LjIxNi4xMjY6MTM3NjE6YXV0aF9zaGExX3Y0X2NvbXBhdGlibGU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoX2NvbXBhdGlibGU6YzNONExuSmxMVEl6TlRVek5EQXovP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNakF3TGpjejU3Nk81WnU5Jmdyb3VwPTU3Nk81WnU5
ssr://MTM4LjY4LjIxNi4xMjY6MTM3NjE6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmMzTjRMbkpsTFRJek5UVXpOREF6Lz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTWpBd0xqY3o1NzZPNVp1OSZncm91cD01NzZPNVp1OQ==
ssr://MTMuMTE0LjQ0LjEyMDozODQ3NzpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46YTNKMU56QlRNVzl0WlRWWi8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU1UQTFMamc0NTc2TzVadTkmZ3JvdXA9NTc2TzVadTk=
ssr://MTMuMTEyLjQ4LjMzOjQxNjM0Om9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjpSbUk0TVdGU1lVbHFPVk5CLz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTVRFd0xqSTE1NzZPNVp1OSZncm91cD01NzZPNVp1OQ==
ssr://MTMuMTEzLjE0LjIxMjo1MzcwMTpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46TUZCaVoxWmFUMmRtWmxWdi8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU1UQXlMall4NTc2TzVadTkmZ3JvdXA9NTc2TzVadTk=
ssr://MTU3LjI0NS41OC4xODE6MTA3ODk6YXV0aF9zaGExX3Y0X2NvbXBhdGlibGU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoX2NvbXBhdGlibGU6YzNONExuSmxMVGd3TnpFME9EazIvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNalUwTGpBMTU3Nk81WnU5Jmdyb3VwPTU3Nk81WnU5
ssr://MTU3LjI0NS4yMDYuMjM1OjE3NzE3Om9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjphWE40TG5sMExUa3pNVGc1TURjMy8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU1qSTRMakl6NTc2TzVadTkmZ3JvdXA9NTc2TzVadTk=
ssr://MTU3LjI0NS4yMDcuNjk6MTc3MjI6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmFYTjRMbmwwTFRVM05qZ3dOVFl6Lz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTWpZMkxqZzA1NzZPNVp1OSZncm91cD01NzZPNVp1OQ==
ssr://MTU5LjIwMy4xOTUuMjIzOjExNjQyOm9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjphWE40TG5sMExUY3pOREUyT1RBdy8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU1qQXpMamd4NTc2TzVadTkmZ3JvdXA9NTc2TzVadTk=
ssr://MTcyLjEwNC4zMC4xODc6MzAwMDc6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOk1YWnphM2s0UlRnM1MwZzIvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNekk0TGpZdzU3Nk81WnU5Jmdyb3VwPTU3Nk81WnU5
ssr://MTguMTc5LjMxLjE2NDozODQzOTpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46TkhSdlFsbHNZVFkzWm1GSy8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU1UQXhMalk0NTc2TzVadTkmZ3JvdXA9NTc2TzVadTk=
ssr://MjMuMjM5LjEyLjIzNDo0Nzc3NzpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46ZGpKNFptRnhhMVUyTlhNNS8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU16RTRMamN4NTc2TzVadTkmZ3JvdXA9NTc2TzVadTk=
ssr://My4xMTIuMTIzLjE0Mjo0MTc1MjpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46VEZBNVdFUlFjMXBLVFdOTS8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU1UQXhMak14NTc2TzVadTkmZ3JvdXA9NTc2TzVadTk=
ssr://My4xMTIuMjAxLjE2OTo0MjgzODpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46UkV4TlRIbzFZV1ZOYm5jNS8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU9UWXVORGZudm83bG03MD0mZ3JvdXA9NTc2TzVadTk=
ssr://My4xMTIuMjQwLjc4OjMzODI5Om9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjpWRnBrWWxSallXdFRObXN5Lz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhT1RjdU9UVG52bzdsbTcwPSZncm91cD01NzZPNVp1OQ==
ssr://My4xMTIuMzAuOTE6NTk5NTI6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOldYZFdkMDlJTjBGSVdrSjQvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNVEF4TGpZeDU3Nk81WnU5Jmdyb3VwPTU3Nk81WnU5
ssr://NDUuMzMuNjUuMzk6MjI4NTk6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOk9GUlRSMUZVTkVkRVQwdGsvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNamcwTGpRMDU3Nk81WnU5Jmdyb3VwPTU3Nk81WnU5
ssr://NDUuNzkuNDIuMjUzOjE1ODQ0Om9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjpZalpDZWtKc2JqSXlXV2xCLz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTWpjeExqRTE1NzZPNVp1OSZncm91cD01NzZPNVp1OQ==
ssr://NDUuNzkuNTAuMTE3OjE3NTMzOm9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjpjMnBrVlhBNWFGUXhhRkJVLz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTWpjd0xqa3k1NzZPNVp1OSZncm91cD01NzZPNVp1OQ==
ssr://NDUuNzkuNTAuMjY6NDUxMzI6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmJXVnhSMm8zTkhCV1F6SXovP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNalk0TGpFNDU3Nk81WnU5Jmdyb3VwPTU3Nk81WnU5
ssr://NDUuNzkuNTIuOTozNjg5NjpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46Tkd3NGVXdDZOalphU0VwVS8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU1qZ3lMakE1NTc2TzVadTkmZ3JvdXA9NTc2TzVadTk=
ssr://NjkuMTY0LjIyMC4xOTI6MTU5MDk6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOlJqUkdNRTQyY0d4SU1HUkgvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNekV6TGpJMjU3Nk81WnU5Jmdyb3VwPTU3Nk81WnU5
以上为美国地区节点
ssr://MTA5LjIzNy4yNC44NDoxMTY5NTpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46ZUV4NGFYUlBWRTVJUlRVNC8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU16SXpMakl6Nkl1eDVadTkmZ3JvdXA9Nkl1eDVadTk=
ssr://MTA5Ljc0LjIwNC4xMzE6MTE1MDU6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOlZYSm1NMnh6TlRCQlZIbHIvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNekl3TGpjMjZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
ssr://MTM5LjE2Mi4xOTUuMjUyOjQwMzM3Om9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjpOR0pzTmtoMVNGY3hWa1pxLz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTkRBd0xqZzM2SXV4NVp1OSZncm91cD02SXV4NVp1OQ==
ssr://MTM5LjE2Mi4yMDAuNzE6NDQ0OTY6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOlpXazVZV1EzUm1GSFRUbDUvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNelV5TGpjeTZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
ssr://MTM5LjE2Mi4yMDIuMjQzOjIzMjUwOm9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjpiVEJPUldsTGFraFRhWFpqLz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTXpjM0xqVTM2SXV4NVp1OSZncm91cD02SXV4NVp1OQ==
ssr://MTM5LjE2Mi4yMTYuMTA6NDAzMjQ6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOlVIRnBhV1p3WXpjM1YzVm8vP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNekV6TGpFejZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
ssr://MTM5LjE2Mi4yNDUuMjI4OjIxODgxOm9yaWdpbjphZXMtMjU2LWNmYjpwbGFpbjpTMVExYTNkc2ExYzJTRmxuLz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTXpFNUxqRXo2SXV4NVp1OSZncm91cD02SXV4NVp1OQ==
ssr://MTc2LjU4LjEwMi4xNDA6MzUyOTI6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmNreGhkRmhzYWpoR1QwWjAvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNek16TGpVMDZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
ssr://MTc4Ljc5LjE2Mi4xOTY6NDU3MjE6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmIxRXdNME50TW1aVFVtcEwvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNell3TGpnMzZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
ssr://MTc4Ljc5LjEyOC4xNDk6MTg2MDI6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOlJXUllURE5NZWpGb2VrTmwvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNek0xTGpVeTZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
ssr://MjEyLjcxLjI1NS4yMzg6MTExOTc6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOlRGWk5ibWhHWTFCUVZHTncvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNekE0TGpFMTZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
ssr://MjEyLjcxLjIzNC4xMTc6MjI1MTc6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmQyOTVUMUExVWtzNVpESTQvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNekE1TGpreDZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
ssr://ODUuMTU5LjIwOC4xNjE6NTA3OTQ6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOlFWVjNiREEyWmprNWRscGsvP29iZnNwYXJhbT0mcHJvdG9wYXJhbT0mcmVtYXJrcz01Ny03NWFLWjVZV2FNekU1TGpjMTZJdXg1WnU5Jmdyb3VwPTZJdXg1WnU5
以上为英国地区节点
ssr://aGt0ajMuc2VydmVwMnAuY29tOjU0MzpvcmlnaW46YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOlRVaHhXR050Vm1wUS8_b2Jmc3BhcmFtPSZwcm90b3BhcmFtPSZyZW1hcmtzPTU3LTc1YUtaNVlXYU9URXVOamJrdUszbG03MD0mZ3JvdXA9NUxpdDVadTk=
ssr://MTU3LjIzMC4yNDEuOTg6MTgxMjI6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmFYTjRMbmwwTFRFMU56Y3pNVEl3Lz9vYmZzcGFyYW09JnByb3RvcGFyYW09JnJlbWFya3M9NTctNzVhS1o1WVdhTWpZM0xqZ3o1cGF3NVlxZzVaMmgmZ3JvdXA9NXBhdzVZcWc1WjJo
以上为其他地区节点
转载于:https://www.cnblogs.com/xxxxxxxxx/p/11609517.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1063641519f01867a862400d4f965ace/" rel="bookmark">
			安装anaconda和tensorflow(windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda安装时勾选All User和启用环境变量
可切换为清华镜像
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
conda config --set show_channel_urls yes
anaconda-navigator无法打开的解决办法
conda update anaconda-navigator
anaconda-navigator --reset
conda update anaconda-client
conda update -f anaconda-client
打开Anaconda-Navigator-&gt;Environments-&gt;base(root)修改python版本到3.6.8
python3.7目前对tensorflow2.0支持不好
在Anaconda里创建名为tensorflow的环境
conda create -n tensorflow python=3.6.8
进入tensorflow环境
activate tensorflow
查看Anaconda里的环境
conda info --envs
在cmd里先执行以下两行
easy_install pip
pip install--upgrade pip
回到Anaconda Prompt
pip install tensorflow或
pip install --upgrade --ignore-installed tensorflow
如果报错超时，延长超时时间
pip install --upgrade --ignore-installed tensorflow --default-timeout=100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1063641519f01867a862400d4f965ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269ec8427c688564beb8261e22c4b3d9/" rel="bookmark">
			Linux 系统基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		温故而知新，可以为师矣。好久没有再次系统学习 Linux 相关的知识了，总结回顾一下，为了更好的前进。
一、环境搭建 环境的配置，是我们学习的基础。环境配置会用到的工具及环境：
(1) Inteelij IDEA 2019 + BashSupport插件 (2) Ubuntu 18.04（用的腾讯云服务器） (3) Git Bash 1.全局配置bash解释器 2.配置bash shell 脚本运行解释器 二、Linux 文件 【GitHub示例】
1. Linux 内核的四种功能 （1）内存管理 默认情况下，运行在Linux系统上的每个进程都有各自的内存页面；进程不能访问其他进程正在使用的内存页面。 内核维护着自己的内存区域 用户进程不能访问内核进程的内存 可以创建一些共享内存页面，多个进程可在同一块共用内存区域进行读取和写入操作；内核负责维护和管理这块共用内存区域并控制每个进程访问这块共享区域。 内核的系统内存管理主要是对1.物理内存和虚拟内存（交换空间）2.共享内存的管理 （2）软件程序管理 内核创建第一个进程（init进程）来启动系统上所有其他进程 内核启动时，将init加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码 系统开机自动启动的进程通常位于专门的文件 /etc/inittab 或 /etc/init.d目录中 运行级决定init进程运行/etc/inittab文件 或者 /etc/rcX.d目录中定义好的某些特定类型的进程。 （3）硬件管理 Linux系统将硬件设备（需要在内核代码中加入其驱动程序代码）当成特殊的文件，称为设备文件，分三种： 字符型 块 网络 （4）文件系统管理 Linux内核支持多种不同类型的文件系统来从硬盘中读取或写入数据。 内核必须在编译时就加入对所有可能用到的文件系统的支持。 Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的标准接口。 Linux的文件管理系统为： ext4文件管理系统 文件管理系统：Fat文件管理系统 Windows的文件管理系统：NTFS文件管理系统 【GitHub示例】
#!/usr/bin/env bash # @File : ${NAME} # @Time : 2019/9/9 7:55 # @Author : Crisimple # @Github : https://crisimple.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269ec8427c688564beb8261e22c4b3d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbccee6d0992db3208dd4716083373ca/" rel="bookmark">
			Python 测试相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件开发固然重要，软件测试也必不可少。
一. Python 文档测试 【GitHub代码commits id：c5bdcc5】
1. pydoc生成文档 python 的 pydoc 模块可以非常方便地查看、生成 HTML 帮助文档。只要在函数、类、方法定义后面加
#!/usr/bin/env python # -*- encoding: utf-8 -*- """ @File : 01_create_pydoc.py @Time : 2019/8/16 11:36 @Author : Crisimple @Github : https://crisimple.github.io/ @Contact : Crisimple@foxmail.com @License : (C)Copyright 2017-2019, Micro-Circle @Desc : None """ NMAE = 'PyDOC' class CreatePyDOC(object): name = 'pydoc' """ 定义一个CreatePyDOC，该类包括两个变量：name、language """ def __int__(self, name, language): """ name --- 初始化文档的名称 language --- 初始化文档的编写语言 :param name: :param language: :return: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbccee6d0992db3208dd4716083373ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b79f4343356551fd4077653a9b11e0/" rel="bookmark">
			Python 基础学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、学习路线 根据下图的Python路线进入Python学习之旅。
二、数据类型 学习一门编程语言，首先得学习它的数据类型和语法。基于现在的趋势，所有的都是基于Python3的学习。 Python 的基本数据类型有以下几类：
1. 数字（int）类型：int、float、complex 2. 布尔型（bloo） 3. 字符串（str） 4. 列表（list） 5. 元组（tuple） 6. 字典（dict） 7. 集合（set） 1. 数字类型（int） Python3中，无论整数的大小长度为多少，统称为整型int。
【GitHub代码commits id：b0f0c81】
power_int = 2 ** 40 print("power_int：", power_int) print("power_int_type：", type(power_int)) str_int = int('123') print("str_int_type：", type(str_int)) bit_length_int = 123 print(bit_length_int.bit_length()) 2. 布尔类型（bool） 对于 bool 类型来说，只存在两种值 True 和 False，对应的二进制值分别是 1 和 0。True的值太多，但 False 的值可以穷举：None, 空（[], (), {}, “”）, 0。【GitHub代码commits id：e420fc2】
none_value = bool(None) print("none_value: ", none_value) blank_1 = bool([]) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28b79f4343356551fd4077653a9b11e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd2bb0b18e3814b17f317e629e7654a/" rel="bookmark">
			Vim 从放弃到入门 (插入、移动、替换、批量删除等技巧)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vim从放弃到入门 目录
Vim从放弃到入门
Vim基本操作:
你可能不知道得事:
撤销回退操作:
插入:
编辑小技巧
移动:
替换 substitute:
视图模式(visual):
批量删除
复制
方块块选择
Vim基本操作: 在进入vim后默认为 normal(普通)模式,这个模式下不可以进行文本的编辑
想要进入insert(插入)模式按 i 可在光标所在之前进行插入,编辑后想退出insert模式按Esc
想完全退出vim,首先要在normal模式下,进入后如果没有进行改动(:q),改动后想保存后退出(:wq),改动后不保存退出(:q!)
学会这几个就可以正常操作vim了
你可能不知道得事: 设置vim行号:
:set nu
跳转到最后一次编辑的地方:
normal模式下 按gi 会移动到你最后一次编辑的地方 并且进入插入模式
语法高亮:
打开语法高亮:
:syntax enable
:syntax on
撤销回退操作: u撤销上一步操作
Ctrl+r 取消上一次撤销
插入: a/i/o (append)在光标后插入,i(insert在光标前插入),(open a line below)在当前行下插入
A/I/O 在行尾插入、在行首插入、在当前行上插入
编辑小技巧 在进入插入模式后:
按:Ctrl+h 删除上一个字符
按:Ctrl+w 删除上一个单词
按:Ctrl+u 删除光标所在位置到当前行首
移动: vim移动记住这些常用命令方便编辑
h(左)j(下)k(上)l(右)
w/W 可以移动到下一个单词
b/B可以移动到上一个单词
0移动到行首,$移动到行尾
可以使用0w移动到行首非空白的地方,或者^
可以使用g_移动到行尾非空白的地方
gg/G移动到文件开头、结尾
H/M/L跳转到屏幕的开头(Head)、中间(Middle)、结尾(Lower)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dd2bb0b18e3814b17f317e629e7654a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a466136d74cdc0c904467dabc0a7ad72/" rel="bookmark">
			C# Lambda Left Join AND Group by Then Sum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var list = List1.Join( List2, l1 =&gt; new { l1.Cityid }, l2 =&gt; new { l2.Cityid }, (item1, item2) =&gt; new { Report_date = item1.Rdate, Cityname = item2.Cityname, Th = item1.Th, Yh=item1.Yh, Eh= item1.Eh, }) //2列表left jion .GroupBy(p =&gt; new { p.Report_date, p.Cityname }) .Select(g =&gt; new { Cityname = g.Key.Cityname, Report_date = g.Key.Rdate, DH = g.Sum(t =&gt; t.Th) + g.Sum(t =&gt; t.Yh) + g.Sum(t=&gt;t.Eh) }).ToList();//分组计算 转载于:https://www.cnblogs.com/TTonly/p/11608456.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/105b1bacb8225746ee27889da382fee5/" rel="bookmark">
			django查询表记录的十三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		django查询表记录的十三种方法 all() 结果为queryset类型
&gt;&gt;&gt; models.Book.objects.all() &lt;QuerySet [&lt;Book: Book object&gt;, &lt;Book: Book object&gt;, &lt;Book: Book object&gt;]&gt; filter() 条件查询(它下面也有很多种方法，见最下面)
&gt;&gt;&gt; ret = models.Book.objects.filter(id=5) &gt;&gt;&gt; ret &lt;QuerySet [&lt;Book: Book object&gt;]&gt; get() 得到的是一个model对象，有且只能有一个
会出现两种报错
1 查不到数据会报错 ：Book matching query does not exist.2 返回值超过一个就报错 ：returned more than one Book -- it returned 13！ &gt;&gt;&gt; ret = models.Book.objects.get(id=5) &gt;&gt;&gt; ret &lt;Book: Book object&gt; exclude() 排除
object能够调用，models.Book.objects.exclude(book_name__startswith='活')queryset类型数据能够调用。 &gt;&gt;&gt; ret = models.Book.objects.all() &gt;&gt;&gt; ret.exclude(id=5) &lt;QuerySet [&lt;Book: Book object&gt;, &lt;Book: Book object&gt;]&gt; order_by() 排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/105b1bacb8225746ee27889da382fee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c2e383af72c52b6846edc7c2856aa0b/" rel="bookmark">
			vue 中 获取数据以后，操作DOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		methods:{ getDeliveryProductInfo() { axios.get('/purchase/thirdCash/deliveryMethod/getProduct', { params : { //请求参数 orderId: document.getElementById('orderid').value } }).then(response =&gt; { this.tableData = response.data.list; SCF.colSpan.totalColumn(this); }); }, } main.js
SCF.colSpan = { totalColumn : function(_this){ _this.$nextTick(()=&gt;{ let totalTable = document.getElementsByClassName("el-table__footer-wrapper"); for(let i=0;i&lt;totalTable.length;i++){ let clospan = 1; console.log(document.getElementsByClassName("el-table__footer-wrapper")); let table = document.getElementsByClassName("el-table__footer-wrapper")[i].querySelector("table").querySelectorAll("tr")[0]; let pagis = document.getElementsByClassName("el-table__footer-wrapper")[i].getElementsByTagName("td"); if(pagis[1].querySelector(".cell").innerHTML == ''){ for(let j=1;j&lt;pagis.length;j++){ if(pagis[j].querySelector(".cell").innerHTML == ''){ clospan += 1; }else{ for(let k=clospan-1;k&gt;=1;k--){ table.removeChild(pagis[k]); } pagis[0].setAttribute("colspan", clospan); return ; } } } } }); } } // 声明该公共方法 Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c2e383af72c52b6846edc7c2856aa0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c428c3c2ecb4e630749177029e951609/" rel="bookmark">
			线上CPU飙升100%问题排查，一篇足矣
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java架构学习交流 2019-09-27 17:16:56
一、引子 对于互联网公司，线上CPU飙升的问题很常见（例如某个活动开始，流量突然飙升时），按照本文的步骤排查，基本1分钟即可搞定！特此整理排查方法一篇，供大家参考讨论提高。
二、问题复现 线上系统突然运行缓慢，CPU飙升，甚至到100%，以及Full GC次数过多，接着就是各种报警：例如接口超时报警等。此时急需快速线上排查问题。
三、问题排查 不管什么问题，既然是CPU飙升，肯定是查一下耗CPU的线程，然后看看GC。
3.1 核心排查步骤
1.执行“top”命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。
2.执行“top -Hp 进程号”命令：查看java进程下的所有线程占CPU的情况。
3.执行“printf "%x\n 10"命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如, printf "%x\n 10" -》打印：a，那么在jstack中线程号就是0xa.
4.执行 “jstack 进程号 | grep 线程ID” 查找某进程下 -》线程ID（jstack堆栈信息中的nid）=0xa的线程堆栈信息。如果“"VM Thread" os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了
5.执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大-》确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。
6.执行“jmap -dump:format=b,file=filename 进程ID”，导出某进程下内存heap输出到文件中。可以通过eclipse的mat工具查看内存中有哪些对象比较多。
3.2 原因分析
1.内存消耗过大，导致Full GC次数过多
执行步骤1-5：
多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程-》上一节步骤2通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。--》上一节步骤5 确定是Full GC,接下来找到具体原因：
生成大量的对象，导致内存溢出-》执行步骤6，查看具体内存对象占用情况。内存占用不高，但是Full GC次数还是比较多，此时可能是代码中手动调用 System.gc()导致GC次数过多， 这可以通过添加 -XX:+DisableExplicitGC来禁用JVM对显示GC的响应。 2.代码中有大量消耗CPU的操作，导致CPU过高，系统运行缓慢；
执行步骤1-4：在步骤4 jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。
3.由于锁使用不当，导致死锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c428c3c2ecb4e630749177029e951609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3792e96ed012aea3b0fe50c79e3716b4/" rel="bookmark">
			React &#43; TypeScript 实现泛型组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛型类型 TypeScript 中，类型（interface, type）是可以声明成泛型的，这很常见。
interface Props&lt;T&gt; { content: T; } 这表明 Props 接口定义了这么一种类型：
它是包含一个 content 字段的对象该 content 字段的类型由使用时的泛型 T 决定 type StringProps = Props&lt;string&gt;; let props: StringProps; props = { // ? Type 'number' is not assignable to type 'string'.ts(2322) content: 42 }; props = { // ✅ content: "hello" }; 或者，TypeScript 能够跟使用时候提供的值自动推断出类型 T，无需显式指定：
interface Props&lt;T&gt; { content: T; } function Foo&lt;T&gt;(props: Props&lt;T&gt;) { console.log(props); } /** 此时 Foo 的完整签名为： function Foo&lt;number&gt;(props: Props&lt;number&gt;): void */ Foo({ content: 42 }); /** 此时 Foo 的完整签名为： function Foo&lt;string&gt;(props: Props&lt;string&gt;): void */ Foo({ content: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3792e96ed012aea3b0fe50c79e3716b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc53d8b8895f514cd0e16a738517e46d/" rel="bookmark">
			对meta标签的再次认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		META标签用来描述一个HTML网页文档的属性，例如作者、日期和时间、网页描述、关键词、页面刷新等。
指定字符集
&lt;meta charset="utf-8"&gt; 向搜索引擎说明网页的关键词
&lt;meta name="keywords" content="关键词"&gt; 告诉搜索引擎你的站点的主要内容
&lt;meta name="description" content="主要内容"&gt; 告诉搜索引擎你的站点的制作的作者
&lt;meta name="author" content="Tiboo"&gt; 响应式页面
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 定时让网页在3秒内跳转到指定url
&lt;meta http-equiv="refresh" content="3" url="https://huaban.com/"&gt; X-UA-Compatible是自从IE8新加的一个设置，对于IE8以下的浏览器是不识别的。 通过在meta中设置X-UA-Compatible的值，可以指定网页的兼容性模式设置。
如果安装了谷歌浏览器内嵌框架 (Google Chrome Frame)简称GCF，则使用GCF来渲染页面 ("chrome=1"), 如果没有安装GCF，则使用最高版本的IE内核进行渲染 ("IE=edge")。X-UA-Compatible(浏览器采取何种版本渲染当前页面)
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; 浏览器的内核控制
&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt; 国内的主流浏览器都是双核浏览器：基于Webkit的内核用于常用网站的高速浏览，基于IE的内核主要用于部分网银、政府、办公系统等网站的正常使用。
以360为例：只要在网站里增加一个meta标签，告诉360浏览器这个网站应该用哪个内核渲染，那么360浏览器就会在读取到这个标签后，立即切换对应的内核，并将这个行为应用于这个二级域名下所有网址。
若页面需默认用极速核，增加标签：&lt;meta name="renderer" content="webkit"&gt; 若页面需默认用ie兼容内核，增加标签：&lt;meta name="renderer" content="ie-comp"&gt; 若页面需默认用ie标准内核，增加标签：&lt;meta name="renderer" content="ie-stand"&gt; 转载于:https://www.cnblogs.com/Tiboo/p/11605304.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d565f045ae9d273910e7716bffd4c68/" rel="bookmark">
			微信小程序regeneratorRuntime is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序regeneratorRuntime is not defined 新版本的小程序支持async / await。不勾选下面2个选项后重新编译程序即可，不需要ES6转ES5了，增强编译也要去掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2caa837b3fb3600978a7c30fd3c61ee8/" rel="bookmark">
			【记录一个问题】android opencl c&#43;&#43;: 使用event.SetCallBack()方法后，在回调函数中要再使用event.wait()才能得到profile信息...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题：希望执行完成后得到各个阶段的执行时间，但是通过回调发现start, end, submit, queued等时间都是0
因此要在回调函数中再使用一次event.wait()，然后才能获得profile数据。
转载于:https://www.cnblogs.com/ahfuzhang/p/11605074.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/659ed1f7e028d8010979f4fd4f35ef3c/" rel="bookmark">
			【记录一个问题】android opencl c&#43;&#43;: 不要Context, CommandQueue类的赋值函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始代码中这样写了：
cl::Context ctx = cl::Context(CL_DEVICE_TYPE_GPU, NULL);
cl::CommandQueue queue= cl::CommandQueue(ctx, devices[device_index],
CL_QUEUE_PROFILING_ENABLE, &amp;err);
运行时发现运行正常，但是始终无法得到正确的结果。 找了另一个正常的例子逐个替换对象，最终发现这两个对象上面的赋值函数导致了问题。
因此，除非看了源码确认可以这么用，否则还是应该避免对象的值拷贝或者使用赋值函数。
很可能新对象虽然得到了所有内容，但是老对象析构后又导致新对象指向的内容出错。
修改为以下代码后正常：
cl::Context* ctx = new cl::Context(CL_DEVICE_TYPE_GPU, NULL);
cl::CommandQueue* queue = new cl::CommandQueue(ctx, devices[device_index],
CL_QUEUE_PROFILING_ENABLE, &amp;err);
转载于:https://www.cnblogs.com/ahfuzhang/p/11605057.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e8bebdc6c24abc63827df4677421e2/" rel="bookmark">
			ISO14229之概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ISO14229之概述 0、概述1、术语介绍2、诊断服务报文格式3、NRC定义描述 0、概述 ISO-14229也称为UDS（统一诊断服务），是一个用于汽车行业诊断通信的需求规范，应用于OSI七层模型的应用层（第7层）。他只规定了与诊断相关的服务需求，并未涉及通信机制；所以，对于ISO-14229的使用是可以架设在各种网络上的，除了我们比较熟悉的CAN外，还可以基于LAN、FlexRay、串口等。在前面的一些文章里，我们也介绍了UDS中常用到的一些诊断服务（如19服务、34/36/37服务、31服务等）的使用；本文则主要介绍下UDS诊断服务的格式及NRC（错误响应码）的定义描述，作为基础补充。
1、术语介绍 为便于后面对UDS诊断服务格式的介绍，我们先来介绍下涉及到的术语。
（1）、Addressing Type （寻址方式）
寻址方式指的是诊断消息的传递方式，有以下两种寻址方式：
物理寻址（Physical），即1对1通信，用于知道确切的被诊断ECU的地址；
功能寻址（Functional），即1对n通信，或者说广播发送，用于不知道确切的被诊断的ECU的地址，向一组或者全体ECU发送请求。
例如，在我们ECU的升级过程中，预编程阶段的相关诊断报文（如通过85服务关闭DTC的更新、28服务关闭其他ECU的报文发送功能），一般会通过功能寻址的方式进行发送，广播式地通知车上其他ECU。在正式升级阶段则通过物理寻址方式，进行数据传输刷写。
（2）、SID（Service Identifier）
用以指代某个诊断服务的1字节无符号整数。例如会话模式控制的10服务、请求复位的11服务等。
（3）、DID（Data Identifier）
用以标识ECU中贮存的某个诊断数据单元的2字节无符号整数。例如请求数据读取的22服务：22 F1 87中的"F1 87"。对于使用者来说DID屏蔽了具体实现细节，而将重点放在了数据本身。例如当我们要读取某个单元的诊断数据时，只要操作（读）对应的DID就可以，而不必通过数据的具体地址去操作。
（4）、NRC（Negative Response Code）
即1字节的无符号整数表示的错误响应码。它是诊断协议为每一种执行失败的诊断服务分配的失败原因代号，便于我们对服务请求失败原因的定位分析。
（5）、Sub-Function（子服务）
1字节的无符号整数表示的子服务。有些诊断服务可以支持不同的诊断子服务，Sub-Function就是用来定义这种子服务的，通过他将某一个服务细分为更为具体的服务。如10服务中的01、02、03，分别表示请求进入不同的会话模式；19服务中的04、06，分别表示请求的是快照还是扩展信息等。
其格式如下，注意其最高位(bit7)是肯定响应应答禁止位；即当该位为1时，则该请求的肯定响应不需进行回复。剩余的7个位用于表示子功能的值，具体值对应的含义在各自服务中都有进行介绍的。这里只需注意该字节最高位这个"肯定响应应答禁止位"的作用即可。如10 83是请求进入扩展会话；且如果是肯定响应（50 03）则不需进行回复。
2、诊断服务报文格式 前面介绍完了涉及到的术语，接下来我们正式来说说UDS诊断服务报文的格式，将分为请求格式、响应格式（肯定响应/否定响应）来进行介绍。
2.1、请求格式（Request）
诊断服务请求格式可以分为以下2种：
[SID] + [Sub-Function] + [Parameter]
[SID] + [Parameter]
即有无Sub-Function的区别；这里我们是把DID也归为Parameter了。Parameter可以是DID，可以是输入参数，可以是自定义的值，字节数目也是视具体要求而定。
2.2、肯定响应（Positive Response）
在请求服务成功执行后，被请求的ECU会返回一个肯定响应；根据通过请求的服务格式是否带有[Sub-Function]，其格式一样可以分为以下的两种：
[SID + 0x40] + [Sub-Function] + [Parameter]
[SID + 0x40] + [Parameter]
这里一样把DID也归为Parameter里。要注意前面ECU收到的服务请求格式是否有带[Sub-Function]，有的话则需注意[Sub-Function]中的Bit 7肯定响应应答禁止位的值。若为1，注意此时是不需发送肯定响应的。我们来看看如下的例子
A、带&lt;Sub-function&gt;的格式： Request: 10 03 ------------ 请求进入扩展会话（10是SID，03是Sub-function） Response: 50 03 ------------ 请求成功，回复积极响应（50是SID+0x40，03是Sub-function） Request: 10 83 ------------ 请求进入扩展会话（10是SID，83是Sub-function，其中肯定响应应答禁止位有效） Response: 无应答，因为肯定响应应答禁止位（Sub-function的Bit7）有效 B、不带&lt;Sub-function&gt;的格式： Request: 22 F1 84 --------- 请求进入扩展会话（22是SID，F1 84 是DID，即Parameter） Response: 62 F1 84 01 ------ 请求成功，回复积极响应（62是SID+0x40，F1 84 是DID，即Parameter，01是ECU返回的数据，也是归于Parameter） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30e8bebdc6c24abc63827df4677421e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce69a98787979fb720a3563d61c0c33d/" rel="bookmark">
			shell索引数组和字符串转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我看到了一个视频，说的是所谓的数组传递（具体内容就不写了），然后自己测试一下从函数中传递出来的是什么，这里直接使用一个数组和一个字符串：
$ num=(1 2 3) $ num1="2 3 4" $ set | grep num num=([0]="1" [1]="2" [2]="3") num1='2 3 4' $ echo ${num1[@]} 2 3 4 $ echo ${num[@]} 1 2 3 $ echo ${num1[0]} 2 3 4 $ echo ${num1[1]} $ echo ${num1[*]} 2 3 4 $ echo "${num1[*]}" 2 3 4 $ echo "${num1[@]}" 2 3 4 $ echo "${num1[0]}" 2 3 4 $ echo "${num1[1]}" $ echo ${#num1[@]} 1 echo ${#num[@]} 3 从上面测试可以看出，字符串其实可以转化为数组的第一个元素的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62ecc8d40b15d145ca9fd9b30d98cd3/" rel="bookmark">
			visual studio 2019使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建项目：
文件–&gt;新建项目–&gt;空项目–&gt;下一步–&gt;创建。
项目名称和解决方案名称可以不同。
2.创建源代码文件：
右击源文件–&gt;添加新建项–&gt;c++文件(.cpp)
3.写完代码后–&gt;生成–&gt;生成解决方案。
4.点击本地Windows调试器就可以运行代码了。
5.断点处的设置按钮可以设置条件，设置完条件再点继续就可以直接跳到想去的位置。
6.vs的完文件编译技术，当有多个源文件（每个里边都有main）时，运行报错，运行哪个就把其他的移除（右键–&gt;从项目中排除），需要的时候再右击源文件添加已有项就可以了。
7.vs多文件编译：需要一个媒介——头文件(.h结尾)，在两个需要连接的源代码文件中都加上一句#include"…h"，这个.h文件里要声明需要用到的函数，结构体等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a5bd4cae1cf07118922b8431ee0edf/" rel="bookmark">
			C语言实现去除字符串首尾空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* C语言去除字符串首尾空格，trim()函数实现 https://blog.csdn.net/u013022032/article/details/50521465 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; //去除尾部空白字符 包括\t \n \r /* 标准的空白字符包括： ' ' (0x20) space (SPC) 空格符 '\t' (0x09) horizontal tab (TAB) 水平制表符 '\n' (0x0a) newline (LF) 换行符 '\v' (0x0b) vertical tab (VT) 垂直制表符 '\f' (0x0c) feed (FF) 换页符 '\r' (0x0d) carriage return (CR) 回车符 //windows \r\n linux \n mac \r */ char *rtrim(char *str) { if (str == NULL || *str == '\0') { return str; } int len = strlen(str); char *p = str + len - 1; while (p &gt;= str &amp;&amp; isspace(*p)) { *p = '\0'; --p; } return str; } //去除首部空格 char *ltrim(char *str) { if (str == NULL || *str == '\0') { return str; } int len = 0; char *p = str; while (*p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4a5bd4cae1cf07118922b8431ee0edf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52bf6cd8798449ba51db4a3fa5bb62c/" rel="bookmark">
			Java算法：1!&#43;2!&#43;3!&#43;···&#43;n!求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1（累加）： 1!+2!+3!+···+n!
其中 n！ = 1 * 2 * 3 * ··· * n
两层for循环，内层for循环输出 An = n!（n遍历1~n），外层for循环执行 A1+A2+A3+···+An = num
public void play2() { //命令行输入操作 @SuppressWarnings("resource") int n = new Scanner(System.in).nextInt(); //算法开始的时间 Date date1 = new Date(); System.out.println("开始时间: " + date1); //开始执行算法 long num = 0; for(int i=1;i&lt;=n;i++) { long a = 1; for(int j=1;j&lt;=i;j++) { a = a*j; } num = num + a; System.out.println(" + " + i + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d52bf6cd8798449ba51db4a3fa5bb62c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08ac8596b96f48766d3bd01180403b8/" rel="bookmark">
			Socket error Event: 32 Error: 10053. Connection closing...Socket close
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在用xshell连接vmware中的centos时，经常报socket error Event，一般隔几分钟就断开了，需要重新连接，报错信息如下
Connecting to 192.168.0.100:22... Connection established. To escape to local shell, press 'Ctrl+Alt+]'. Socket error Event: 32 Error: 10053. Connection closing...Socket close. Connection closed by foreign host. Disconnected from remote host(kubernetes1_100) at 00:35:35. 解决问题 1.修改/etc/ssh/sshd_config配置
#vi /etc/ssh/sshd_config #UseDNS yes 改为 UseDNS no 2.修改ifcfg文件，加上“NM_CONTROLLED=no”
[root@kubernetes1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=6d50f27e-7d3c-4c95-8e7f-7f3574682134 DEVICE=ens33 ONBOOT=yes IPADDR=192.168.0.100 NETMASK=255.255.255.0 GATEWAY=192.168.0.1 NM_CONTROLLED=no 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08ac8596b96f48766d3bd01180403b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dcc05e4acac6d3bf2f2a011b29a1a1b/" rel="bookmark">
			符号配对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请编写程序检查C语言源程序中下列符号是否配对：/与/、(与)、[与]、{与}。
输入格式:
输入为一个C语言源程序。当读到某一行中只有一个句点.和一个回车的时候，标志着输入结束。程序中需要检查配对的符号不超过100个。
输出格式:
首先，如果所有符号配对正确，则在第一行中输出YES，否则输出NO。然后在第二行中指出第一个不配对的符号：如果缺少左符号，则输出?-右符号；如果缺少右符号，则输出左符号-?。
我的思绪 一开始看到这个题，就知道使用栈——因为之前了解过编译器的一些括号对齐原理。
只不过，这道题目出的太含糊了，好多东西都没有交代清楚，容易使人走弯路，你必须像出题人期待的那个水平和想法去敲代码，否则不会通过的。就像……八股？我这么认为这道题目，太死板而且含糊了。
1 没有明确“第一个”是什么意思。第一个不匹配的括号，啥意思？ 我的同学有敲了好几个小时的实在是过不了点，就知道想法肯定和出题人不一样，于是找了一段ac代码，运行一下发现了以下几个案例：
{（】，按照常理来说，应该输出{（人类视角）或者】（计算机视角），但是运行结果是（。
实际上这道题目输出的错误处，不同人会有不同的理解，所以就算有大佬来敲，可能也会摸索很长一段时间。
那么，出题人什么意思呢？
出题人：只要栈不为空，就给我输出弹出的那个括号不匹配。如果栈空了，在按照你碰到的应该弹出一个的括号去输出。
对此，我只想说一句呵呵→_→ 要不是同学来找我讨论，我真的会用计算机视角做这道题目，那今天天亮之前绝对做不出来，更写不出这篇博客。
2 没有说明一些复杂的样例不用考虑。 第一次看到这个题目，我构思出来的测试样例中有这么一组：
printf("((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((");
输出什么？应该输出YES吧，没有不配对的。
可如果这样，这道题目就复杂了，应该出现在竞赛题目上面，而不是日常的PTA里。
我靠，这我特么到底是做还是不做？
郁闷了几分钟，才猜着它不考虑这种情况来敲代码。
3 我的代码 //这次本九熬夜给你们写注释！！！
//这次本九熬夜给你们写注释！！！
//这次本九熬夜给你们写注释！！！
我的思路和大部分人一样，用栈实现。
感谢打开了C++，可以直接使用stl了。
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;stack&gt; using namespace std; int main() { string s; char b[7]; b[1] = '('; b[2] = ')'; b[3] = '['; b[4] = ']'; b[5] = '{'; b[6] = '}';//用来存储括号，省掉三分之二的代码量。如果你代码超过100行了，那很有可能是因为用了6个if而不是2个。 int find = 0; bool isasimple = false; stack&lt;char&gt; bracket;//特地百度了一下括号的英文单词，就用他做栈名字吧。 while (1) { getline(cin, s); if (s=="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dcc05e4acac6d3bf2f2a011b29a1a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af55e8d451e2052072de491659d5a220/" rel="bookmark">
			mbim ndis ecm ncm之我的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几个问题困扰了我很长时间，经过我不懈的努力 加上 我的悟性， 我自认为 理解了那么一点。
ndis （Network Driver Interface Specification） 网络驱动接口规范，这是一个规范，我也可以理解为标准，这个规范规定的比较宽，从物理层到应用层都有涉及，（也就是介绍中说的：横跨传输层、网络层和数据链路层）
下面是网卡查到的相关介绍：
NDIS(Network Driver Interface Specification)是网络驱动程序接口规范的简称。它横跨传输层、网络层和数据链路层，定义了网卡或网卡驱动程序与上层协议驱动程序之间的通信接口规范,屏蔽了底层物理硬件的不同,使上层的协议驱动程序可以和底层任何型号的网卡通信。 NDIS为网络驱动程序创建了一个完整的开发环境，只需调用NDIS函数,而不用考虑操作系统的内核以及与其他驱动程序的接口问题，从而使得网络驱动程序可以从与操作系统的复杂通讯中分离，极大地方便了网络驱动程序的编写。另外，利用NDIS的封装特性，可以专注于一层驱动的设计，减少了设计的复杂性，同时易于扩展驱动程序栈。
NDIS支持三种类型的网络驱动程序： NDIS网卡驱动程序(NICdrivers) 网卡驱动程序是网卡与上层驱动程序通信的接口,它负责接收来自上层的数据包,或将数据包发送到上层相应的驱动程序,同时它还完成处理中断等工作。 NDIS中间驱动程序 (InterMediateProtocolDrivers)：中间驱动程序位于网卡驱动程序和协议驱动程序之间,它向上提供小端口(Minport)函数集,向下提供协议(protocol)函数集,因此对于上层驱动程序而言,它是小端口驱动程序。对于底层的驱动程序,它是协议驱动程序。 NDIS协议驱动程序 (Upper Level Protocol Drivers)：协议驱动程序执行具体的网络协议,如IPX/SPX、TCP/IP等。协议驱动程序为应用层客户程序提供服务,接收来自网卡或中间驱动程序的信息
ndis既然是标准，那么win、linux都可以使用，广义的来讲，在windows上是ndis，只要符合ndis标准的无线网卡、有线网卡，不需要驱动，直接就可以在win7以上的系统上使用。
但是在linux上它却是以另一个名字为大家知晓"ECM（Ethernet Control Model） ""NCM"，其实ECM NCM只是在linux上规定 了ndis规范的“物理层”实现形式，是通过USB CDC通信类来实现了，所以双叫CDC-ECM，在华为的这个文档里写的很清楚：
linux下其它ndis层怎么实现了我就不知道了，但是我知道ndis物理层除了使用标准ECM来实现之外，还有一个非标准的QMI WWAN ，这是高通自己定义的ndis物理层标准，由于高通的行业地位，这个非标甚至比标准运用的还要广泛，ECM QMI由于使用协议不同，拨号连网的命令也不同， 华为ME909是echo "AT^NDISDUP=1,1"&gt;/dev/ttyUSB0 而STIM7100是 echo "AT\$QCRMCALL=1,1" &gt; /dev/ttyUSB2 命令形式不一样，但实质是一样的，都是建立连接，获得运营商IP地址。
如果是支持ECM标准的4G模块，3.X的内核支持，直接在内核中配置就可以了。比如华为ME909
如果是支持高通QMI的模块，好像有文档说3.4以上的内核直接支持，那是不是也是内核menuconfig时，添加 上就行也呢？这个我还没有验证。使用高通方案的模块多的很sim7100 ec20几乎都是。
最后说MBIM,(Mobile Broadband Interface Model),这是正宗的移动宽带接口模型，专门用于3G/4G/5G模块的，上面说的ndis这个并不是专门用在移动宽带上的，比如USB接口的百兆网卡RTL8152也是基于ndis的，所以它能做到免驱。但是MBIM只在win8以上的windows上使用，不知道为什么 linux没有使用，好象这种新技术都是windows先用，然后才慢慢推广到linux上。(最近调试imx6ull板子时，在4.x.xx的内核中发现了 CDC MBIM support选项，说明新内核已经支持了)
QMI: Qualcom Message Interface
Network Driver Interface Specification网络驱动接口规范
ECM:Ethernet Control Model 以太网控制模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af55e8d451e2052072de491659d5a220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a051593aa5b2b3d2e92c9866f823de6a/" rel="bookmark">
			随机数生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、随机数生成器：
编写一个方法，使用以上算法生成指定数目（比如1000个）的随机整数。
源代码
package org.yuan.Day3; import java.util.Scanner; public class RandomNumber { static Scanner sc=new Scanner(System.in); static public void Random(long seed) { long n,x1; System.out.println("请输入想要产生的随机数的个数："); n=sc.nextLong(); for(long i=1;i&lt;=n;i++) { x1=(16807*seed)%(Integer.MAX_VALUE); System.out.println(x1); seed=x1; } } public static void main(String []args) { long a; a=(long)(Math.random()*100); Random(a); } } 二、方法重载
public class MethodOverload { public static void main(String[] args) { System.out.println("The square of integer 7 is " + square(7)); System.out.println("\nThe square of double 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a051593aa5b2b3d2e92c9866f823de6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586c0e4927d0a99dc68c37e6481deb7a/" rel="bookmark">
			数据库的框架及优化之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/adeng/p/9012301.html
转载于:https://www.cnblogs.com/ceshizhilu/p/11598914.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931baf4dc10e46d89851c66a6be0362f/" rel="bookmark">
			CentOS下 .Net Core 1.0 升级到 3.0 遇到的一个小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前.net core 1.0的安装方式，不是用yum方式安装的，所以，在用yum安装3.0之后，用dotnet --version还是1.0的版本，想起了之前
做过链接映射dotnet目录，删除之前的链接重新创建就好了。
sudo ln -s /opt/dotnet/dotnet /usr/local/bin #（创建链接）
如果在创建链接时报错，说明之前映射过另外一个目录，这个时候需要删除上一次的链接
rm /usr/local/bin/dotnet #（删除链接）
附上安装.net core的两种方式：
1. 下载压缩包安装方式（1.0版本的时候）
sudo yum install libunwind libicu #（安装libicu依赖） curl -sSL -o dotnet.tar.gz https://go.microsoft.com/fwlink/?linkid=848821 #（下载sdk压缩包） 根据网速，可能快可能慢 sudo mkdir -p /opt/dotnet &amp;&amp; sudo tar zxf dotnet.tar.gz -C /opt/dotnet #（解压缩） sudo ln -s /opt/dotnet/dotnet /usr/local/bin #（创建链接） dotnet new console -o hwapp # 我们初始化一个示例Hello World应用程序 （这里稍微耗时点） cd hwapp dotnet restore dotnet run #运行应用程序 2. 使用yum安装方式
参考：晓晨Master https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/931baf4dc10e46d89851c66a6be0362f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe26623dec09bbe6fa6ab3777861313d/" rel="bookmark">
			12 机器学习 - KNN实现手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 利用一个手写数字“先验数据”集，使用knn算法来实现对手写数字的自动识别；
先验数据（训练数据）集：
数据维度比较大，样本数比较多。数据集包括数字0-9的手写体。每个数字大约有200个样本。每个样本保持在一个txt文件中。手写体图像本身的大小是32x32的二值图，转换到txt文件保存后，内容也是32x32个数字，0或者1，如下：
数据集压缩包解压后有两个目录：
目录trainingDigits存放的是大约2000个训练数据目录testDigits存放大约900个测试数据。 模型分析 本案例看起来跟前一个案例几乎风马牛不相及，但是一样可以用KNN算法来实现。没错，这就是机器学习的魅力，不过，也是机器学习的难点：模型抽象能力！
思考：
1. 手写体因为每个人，甚至每次写的字都不会完全精确一致，所以，识别手写体的关键是“相似度” 2. 既然是要求样本之间的相似度，那么，首先需要将样本进行抽象，将每个样本变成一系列特征数据（即特征向量） 3. 手写体在直观上就是一个个的图片，而图片是由上述图示中的像素点来描述的，样本的相似度其实就是像素的位置和颜色之间的组合的相似度 4. 因此，将图片的像素按照固定顺序读取到一个个的向量中，即可很好地表示手写体样本 5. 抽象出了样本向量，及相似度计算模型，即可应用KNN来实现 python实现 新建一个kNN.py脚本文件，文件里面包含四个函数：
一个用来生成将每个样本的txt文件转换为对应的一个向量，一个用来加载整个数据集，一个实现kNN分类算法。最后就是实现加载、测试的函数。 ######################################### # kNN: k Nearest Neighbors # 参数: inX: vector to compare to existing dataset (1xN) # dataSet: size m data set of known vectors (NxM) # labels: data set labels (1xM vector) # k: number of neighbors to use for comparison # 输出: 多数类 ######################################### from numpy import * import operator import os # KNN分类核心方法 def kNNClassify(newInput, dataSet, labels, k): numSamples = dataSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe26623dec09bbe6fa6ab3777861313d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c1d4a91eafd675f5813a0c7618ed8e/" rel="bookmark">
			layer实现鼠标悬浮效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var tip_index = 0; $(document).on('mouseenter', '.layer_hover', function(){ var words = $(this).data('words'); tip_index = layer.tips(words, '.layer_hover', {time: 0}); }).on('mouseleave', '.layer_hover', function(){ layer.close(tip_index); }); 转载于:https://www.cnblogs.com/pansidong/p/11598399.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e91461a03fe796e75d0a6d17eb240738/" rel="bookmark">
			elementUI el-autocomplete 在ie9无法正常使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同标题，发现有时可以搜索，有时无法触发搜索，后来发现是如果不失焦，是不会触发后台接口去请求数据的；
因此用watch监听了数据的变化，然后用js失焦
watch: { "formData.name": { handler(newVal, oldVal) { if (this.isIE9) { // ie9的操作 if (oldVal) { if (newVal != oldVal) { this.clearTimer(); this.timer = setTimeout(function() { $("#autocompleteInput").blur(); $("#autocompleteInput").focus(); }, 5000); } } } }, deep: true // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法 // immediate: true } } autocompleteInput为远程搜索的DOM元素
这样可以让其触发搜索，但是仍有搜索时不连贯，输入被失焦打断的问题需解决 转载于:https://www.cnblogs.com/suiyide/p/11598285.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45550f5831702e78e259582af74e7f65/" rel="bookmark">
			Ant Design of Vue 中的Card 卡片的headStyle和bodyStyle设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从官网上可以看到Card的相关使用和API https://vue.ant.design/components/card-cn/
这里可以看到headStyle 和 bodyStyle 的类型都是object，但是为它赋值的需要注意一些问题。
如果只设置一个样式，可以直接在行内写
&lt;a-card title="title" :bordered=false :headStyle="{color:'#0785fd'}" :bodyStyle="{padding:'0'}"&gt;&lt;/a-card&gt; 但是如果要设置多个CSS样式这样的书写方式就会报错出问题了
解决办法：（以headStyle为例）
在js中定义一个变量，再将变量值赋予headStyle即可
html：
&lt;a-card title="title" class="bg" :bordered=false :headStyle='tstyle'&gt;&lt;/a-card&gt; js：
&lt;script&gt; export default { data() { return { tstyle:{"color": "#0785fd","font-weight": "bold"} } }, methods: { } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b0a4df4ac27ed645438295155e390c4/" rel="bookmark">
			Docker 01 - CentOS 7 中安装 Docker 的详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 初识 Docker 1.1 Docker 原理简介1.2 Docker 核心概念2 安装 Docker 2.1 查看系统内核版本2.2 更新 yum 包2.3 安装软件包2.4 向 yum 中添加 Docker 仓库2.5 安装指定版本的 Docker2.6 启动 Docker2.7 验证安装是否成功3 扩展内容 3.1 卸载旧版本 Docker3.2 常用的 Docker 命令 容器大行其道, 不来试一手怎能感知其强大? 本文主要是写给0基础的小白 (对, 就是博主本人?) 作为入门参考, 步骤详细, 对安装过程中遇到的坑都有一一记录, 如有疑问, 可直接评论区留言?
1 初识 Docker 1.1 Docker 原理简介 关于 Docker, 引用百度百科上的介绍:
Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。
Docker 的架构：Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器（Container）通过 Docker 镜像（Image）来创建，二者之间的关系类似于面向对象编程中的对象与类。
Docker 服务端（daemon）一般在宿主机后台运行，等待接收来自客户端的请求，并处理这些请求（创建、运行、分发容器）。 Docker 客户端可以和服务端既可以运行在一个机器上，为用户提供一系列命令，用户通过这些命令（也可以是 Socket 或者RESTful API ）与 Docker daemon 进行交互。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b0a4df4ac27ed645438295155e390c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9c27679d83d15459b4c19a0711675e/" rel="bookmark">
			ubuntu安装gnome以及gnome-tweak-tool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo apt-get install gnome-shell #安装gnome桌面窗口管理程序 sudo apt install gnome-tweak-tool #安装管理工具 sudo apt install gnome-shell-extensions #扩展管理 gnome扩展下载地址：https://extensions.gnome.org/
下载方法："一起来找茬"
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
使用的扩展说明：
1：Battery Status电源按百分比显示
2：Dash to Dock
3：Coverflow Alt-Tab
4：Drop Down Terminal
按照默认，按下“~”会在屏幕上方弹出终端，很方便
End--------------------------------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f52a2aca078068452f1248fb78f3e8b/" rel="bookmark">
			LitJson ---json的创建和解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建Plugins文件夹，把LitJson.dll放进去。
链接：https://pan.baidu.com/s/1dWqx2TlHdD3pQVysEXX0nA 提取码：30dj using System.Collections; using System.Collections.Generic; using UnityEngine; using LitJson; using System; public class Hero { public string name; public int age; } public class Heros { public Hero[] heros; } public class LitJsonDemo : MonoBehaviour { // Use this for initialization void Start () { //func1(); // func2(); func3(); } //第一种创建和解析方法 需要创建类 private void func1() { Hero hero1 = new Hero(); hero1.name = "超人"; hero1.age = 40; Hero hero2 = new Hero(); hero2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f52a2aca078068452f1248fb78f3e8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6218a0aea81cb8cbfc2a024cfd018684/" rel="bookmark">
			ctcss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTCSS解码器基于非常窄的带通滤波器，其通过所需的CTCSS音调。
滤波器的输出经过放大和整流，只要存在所需的音调，就会产生直流电压。直流电压用于打开，启用或取消静音接收器的扬声器音频级。
当音调存在时，接收器被取消静音，当它不存在时接收器静音。、
转载于:https://www.cnblogs.com/yssrf-possible/p/11595928.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0775f8ad5a7c4876ace05736f82427d/" rel="bookmark">
			计算机图形系统简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机图形系统简介 1 图形系统浅析1 图形系统的功能2 计算机图形系统的组成 2 从穿孔纸到数据衣1 输入设备的四个阶段2 VR中的动态感知设备 3 CRT的前世今生1 阴极射线管2 彩色阴极射线管3 扫描方式1 随机扫描2 光栅扫描 4相关概念： 4 3D显示1 较早的三维立体显示2 三维立体显示原理3 三维观察设备4 裸眼立体显示器1 基于液晶显示器的视差屏障技术2 气体投影技术 5 平板1 平板显示器2 液晶显示器3 等离子体显示器4 LED显示器 6 CPU到GPU1 图形显示子系统结构1 早期的光栅扫描图形显示子系统2 典型的光栅扫描图形显示子系统3 图形显示处理器 2 相关概念1 像素2 分辨率3 颜色位面法4 帧缓冲容量5 颜色查找表 1 图形系统浅析 1 图形系统的功能 看电影玩游戏做设计 2 计算机图形系统的组成 计算机系统由图形硬件和图形软件两部分组成；
图形硬件包括输入设备，显示设备，输出设备，计算机；
图形软件系统包括应用软件，支撑软件和操作系统；
2 从穿孔纸到数据衣 1 输入设备的四个阶段 穿孔纸光笔鼠标数据衣 2 VR中的动态感知设备 三维鼠标数据手套数据衣力反馈器 3 CRT的前世今生 1 阴极射线管 Cathode Ray Tube
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0775f8ad5a7c4876ace05736f82427d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cefff396a439eb4e3f542ae2a4266519/" rel="bookmark">
			【线代】线性方程组求解概念：齐次/非齐次方程的解？非零解、无穷多解、求解、求通解、方程有解时求全部解，是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、起因
二、概念理解
1. Ax=0 的解
2. Ax=b 的解
三、齐次、非齐次方程解的关系
四、求解、求全部解
五、小结
一、起因 被线代的大量解的称呼唬住了，收集了主要的问法，如下。
有非零解、有无穷多解、求解、求通解、方程有解时求全部解，具体都是什么意思呢？
群友的一句回答，给了我一些方向，看要求的是谁的解。文章也按照“谁的什么解”的思路来分类，也就是上述问题的反问题——齐次方程、非齐次方程解的情况。
二、概念理解 这个问题一开始提的不好，是因为没有搞清楚方程与解的情况是对应的。分类是逐层的，应该先有齐次、非齐次，再分别研究。这样做的原因如下，一个是方程不同，解的结构不同；二是解的数量/判定，及求解方法不同。在此分别分析两种方程的解的结构、数量，穿插一些记忆方法。
1. Ax=0 的解 （1）结构：对于齐次方程组 Ax=0，它的解就是满足方程的 xi 值组成的列向量 x。
（2）解的情况 / 数量：
Amxn 长方形矩阵（==表示前后条件等价，为充要条件可互推。） r(A) = n == 只有0解，有唯一解r(A) &lt; n == 有无穷多解（包括0解、非零解），此时（齐次方程时）也可说“有非零解”、“不只有零解”、“求通解”注：零解是零向量，即xi 全为0的解。齐次方程至少有0解，因为代入恒成立。但是齐次方程也许有除了零解以外的解，也就是非零解，而且要有，就不是一个两个，而是无穷多个！这里的措辞是“有非零解”，不是“只有非零解”，注意下。而这无穷多个的表达式就是通解，它含有有限个任意常数！Anxn 方形矩阵 |A| ≠ 0 == 只有0解|A| = 0 == 有无穷多解，有非零解，不只有零解记忆：|A|≠0，x 只好恒为0。|A|=0，那么 x 就可以非0。（如若证明，也好理解，|A|≠0时，A可逆，所以Ax=0左乘A-1，得x=0） 2. Ax=b 的解 （1）结构：非齐次方程的解，等于齐次方程通解 + 非齐次方程的一个特解（很像微分方程的解的结构）。
（2）解的情况/数量
Amxn 长方形矩阵 r(A) ≠ r(A|b) == 无解r(A) = r(A|b) =n == 有唯一解（因为方程数等于列秩，也就等于未知数个数，即一个方程可确定一个未知数。）r(A) = r(A|b) &lt;n == 有无穷多解，有非唯一的解，不只一个解，求通解（方程数少，能确定的未知数少，有不受约束可自由取值的自由变量。）注：非齐次方程的无穷多解不包括唯一解，它对应于秩相等但不满的情况；而唯一解是秩相等且列满秩，多了一些方程（约束条件），所以这分明是两个方程组！Anxn 方形矩阵（克莱姆法则） |A| ≠ 0 == 唯一解，xi = |Ai| / |A|，再把 xi 拼起来得到 x|A| = 0 == 唯一解的对立事件（无解，或是无穷多解，此判断法失效！分别在原始矩阵中，代入使 |A|=0 的参数数值，化为阶梯型，用 r(A|b) 判断。此方法的好处是，代入数值后，化简更容易；弊端是如果有不同参数值，可能需要分别化简两个矩阵，而 Amxn 只需一次复杂的化简。）记忆：|A|≠0，才能放分母上，才可克莱姆法则。 三、齐次、非齐次方程解的关系 （1）前提是“当 Ax=b 有解时”：（没有此前提，则不可正推，只可反推）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cefff396a439eb4e3f542ae2a4266519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349c75dd0b58b44e4c7e64bce8465c59/" rel="bookmark">
			go struct{} 空结构体的特点和作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空结构体的特点和作用 参考代码 package main import ( "fmt" "unsafe" ) func main() { empStruct() } //空结构体的实例和作用 func empStruct(){ //空结构体的特点:1、不占用内存；2、地址不变 var s struct{} var s1 struct{} fmt.Println("空结构体占用内存的情况：",unsafe.Sizeof(s)) fmt.Printf("空结构体指针指向情况:s = %p, s1 = %p,两个指针的比较结果：%v",&amp;s,&amp;s1,&amp;s==&amp;s1) strChan := make(chan string,3) signChan := make(chan struct{},1) //接收数据信号 signChan1 := make(chan struct{},2) //操作完成信号 go func(){ // 用来接收信息 &lt;- signChan //阻塞协程，直到signChan接收到值 for value := range strChan{ fmt.Println("接收到值为：",value) } signChan1 &lt;- struct{}{} }() go func(){ // 模拟发送数据 for index,value := range []string{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349c75dd0b58b44e4c7e64bce8465c59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b79fda34f3dfaea2bfd98fe6c470e8b/" rel="bookmark">
			python实现100以内数求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		s1=0
for i in range(1,101):
s1+=i
print(s1)
输出截图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4d14407b19fdb268d8a7a92afe4657/" rel="bookmark">
			线性代数02 线性方程组的解的情况（矩阵的秩）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在01中，我们提到出了一个问题：关于线性方程组的解是否可以根据消元过程中的结构来探究?
博主给出了答案是可以的，那么具体的情况是如何呢？我们先来明确几个概念：
1 主元与矩阵的秩 上一节01，我们提到了关于主元的概念，就是在阶梯矩阵中的非零行中，第一个不为零的数。那么很简单能够知道，主元的个数=非零行的数量。 如此一来。我们可以从主元出发，得到一个新的概念：矩阵的秩（Rank）=主元的数量=非零行的数量。
2 矩阵的秩与线性方程组的解的情况 对于线性方程组的解，我们已经明确只有三种情况，因此不妨分情况讨论：
（1） 唯一解
唯一解的情况非常好理解，就是每个变量均有唯一值，在高斯-诺尔当消元法中，对应的情况就是，增广矩阵中的系数矩阵A可以化简为单位矩阵：
实例如下：
可以看到，若矩阵的秩R==原线性方程组变量的个数（也是增广矩阵的列数）n，那么此时线性方程组有唯一解。
（2） 无解
根据上一节中，无解的实例ex1，我们可以看到，若存在任意行有0=d（常数项）。那么线性方程组无解。因此这种情况，就无需看矩阵的秩与n的关系，可以直接通过是否存在“0=d”方程来判断。
（3） 无穷多解
根据上一节中，无穷多解的实例ex2，可以很容易的发现。若矩阵的秩R&lt;n，就一定有自由变量F的存在。
这里解释一下自由变量F：不是主元的变量就称作自由变量。
思考：为什么R&lt;n,就一定存在自由变量？
因为有一行全为0，那么就一定存在主元的数量&lt;变量的数量。
因此，结论是：若存在矩阵的秩R&lt;n，那么线性方程组一定有无穷多解。
3 总结 （1） 矩阵的秩R&lt;n，那么线性方程组一定有无穷多解
（2） 若存在任意行有0=d（常数项）。那么线性方程组无解。
（3） 矩阵的秩R==原线性方程组变量的个数（也是增广矩阵的列数）n，那么此时线性方程组有唯一解。
在这篇博文中，主要介绍了矩阵的秩的概念，并且将矩阵的秩与线性方程组的解的情况联系了起来。在下一章节，我想从n阶矩阵的行列式来关联到含有n个线性方程，n个变量的线性方程组的解的情况的说明，并且根据齐次线性方程组与非齐次线性方程组的不同来撰写。
概念 单位矩阵
矩阵的秩
主元
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746d922f2d2bae538ee93ba145571436/" rel="bookmark">
			浅谈Scheduler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：https://www.cnblogs.com/qlqwjy/p/8721982.html
1.Scheduler工厂模式 所有的Scheduler实例应该由SchedulerFactory来创建 2.SchedulerFactory类图 最常用的是StdSchedulerFactory工程类，其出那个键Scheduler的两种方式:
//3. 创建scheduler Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // 3. 创建scheduler SchedulerFactory sfact = new StdSchedulerFactory(); Scheduler scheduler = sfact.getScheduler(); 3.　回顾Quartz三个核心概念 调度器 任务 触发器 1个job对应多个Trigger
4.Scheduler的创建方式 StdSchedulerFactory: 使用一组参数（Java.util.Properties）来创建和初始化Quartz调度器 配置参数一般存储在quartz.properties中 调用getScheduler方法就能创建和初始化调度器对象 5..Scheduler的主要函数 // 绑定 jobDetail 和 trigger，将它注册进 Scheduler 当中 ,返回值是最近一次任务执行的开始时间 Date scheduleJob(JobDetail jobDetail, Trigger trigger) // 启动 Scheduler void start() // 暂停 Scheduler void standby() // 关闭 Scheduler void shutdown() 例一:测试:scheduleJob函数返回最近一次开始执行的时间
package cn.qlq.quartz; import static org.quartz.JobBuilder.newJob; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/746d922f2d2bae538ee93ba145571436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496e3bf6959476737c367892aedb33e7/" rel="bookmark">
			Centos7安装hive3.1.2遇到报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找hive启动日志 默认名是hive.log
[root@Master bin]# find / -name hive.log /tmp/root/hive.log Q1 Illegal character entity: expansion character (code 0x8 hive-site.xml有未识别的字符,需要删除,比如报错
xception in thread "main" java.lang.RuntimeException: com.ctc.wstx.exc.WstxParsingException: Illegal character entity: expansion character (code 0x8 at [row,col,system-id]: [3215,96,"file:/opt/apache-hive-3.1.2/conf/hive-site.xml"] 查看文件 hive-site.xml
在3215行,96列出附近找到
查找:for&amp;#8;transactional 删除&amp;#8;即可 Q2 Caused by: java.net.URISyntaxException: Relative path in absolute URI: KaTeX parse error: Expected '}', got 'EOF' at end of input: …a.io.tmpdir%7D/%7Bsystem:user.name%7D 修改hive-site.xml ,修改所有${…}之类的value值,写上绝对路径.
部分修改如下(可以搜索name标签内名字查找)
&lt;property&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;!-- 修改这里的value --&gt; &lt;value&gt;/opt/apache-hive-3.1.2/resources&lt;/value&gt; &lt;description&gt;Temporary local directory for added resources in the remote file system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496e3bf6959476737c367892aedb33e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58389d9885585fce024457719b0159f0/" rel="bookmark">
			JMP基本绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Graph Builder(
Size( 1224, 921 ),
Variables(
X( :SPLIT_1 ),
Y( :WAT_M0_BV_ND_PW_VALUE ),
Color( :SPLIT_1 )
),
Elements(
Box Plot( X( 1 ), Y, Legend( 5 ) ),
Points( X( 1 ), Y, Legend( 6 ) ),
Line Of Fit(
X( 1 ),
Y,
Legend( 7 ),
Confidence of Fit( 0 ),
F Test( 1 ),
Means and Std Devs( 1 )
)
),
SendToReport(
Dispatch(
{},
"SPLIT_1",
ScaleBox,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58389d9885585fce024457719b0159f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ea78b6262808df8d625ab4791737e5/" rel="bookmark">
			this request has no response data ....问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查是否有跨域。一般情如果有跨域会报跨域错误。报无响应的比较少。
2. 邀请服务端一起跟踪，两看，一看接口请求是不是一个不带参数的post请求。如果是，把原来不传参的body .改为传 {}
又或者使用content-type:application/x-www-form-urlencoded .两者二选一。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/258/">«</a>
	<span class="pagination__item pagination__item--current">259/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/260/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>