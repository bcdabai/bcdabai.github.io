<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfdcc52adba661e3110a3b98fd9d185/" rel="bookmark">
			ip地址管理工具_【干货】三款IP地址管理工具，你一定用的到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。现在就跟着小编共同来学习一下：简单介绍基于GPL许可的三款IP地址管理工具。
就算是在一些最小型的网络上面，一个集成的网络发现/IP地址跟踪/DNS以及DHCP管理应用程序都能够直接极大地节省网络管理人员的时间，对于一些大型的网络来说的话，它更是不可缺少的工具。
大家都应该知道商业化的IP地址管理产品个头都不小，它们能够直接提供广泛而丰富的特性，不过打多数都是基于Windows的，而且它的价格可以说的上是不菲，要求的许可成本都以所管理的地址数目作为基础的。
对于一些没有丰富预算的Unix以及Linux的网络管理人员来说，他们过去经常都需要编写其自己的IP地址管理工具，他们所使用的标准应用程序有MySQL、php（PHP是一种HTML内嵌式的语言，PHP与微软的ASP颇有几分相似，都是一种在服务器端执行的嵌入HTML文档的脚本语言，语言的风格有类似于C语言）、Nmap、Kismet、sed、Netcat、fping、awk、snmp等等。他们能够非常轻易地就构建出一个不错的网络发现和报告系统，不过构建一个能够管理名字服务的统一控制器，这就需要花费一点点工夫了。但是幸运的是，有几个设计得非常不错的开源IP地址管理的应用程序可以值得去试一试。
一、Ipplan
首先小编要为大家介绍的是Ipplan，相对来说还是比较成熟的，它是另外一个基于PHP的应用程序，支持用户希望用于后端的非常多的数据库。它的文档资料非常的丰富，拥有一个赏心悦目并且组织十分得当的web界面，除此之外，它还可以使用于DNS管理。它能够直接从路由表里面导入网络定义，也能够直接由XML文件等等里面导入数据，查找空闲的地址空间，支持VLAN。另外一个方面，它还拥有一个审核日志，并且可以处理网络地址转换(也就是NAT)。但是它也有一个缺陷，也就是它使用的是PHP4，这就会显得有一点儿过时并且不怎么安全了。
二、IPReg
Ipplan小编就已经介绍完毕了，接下来小编就为大家介绍一下IPReg。它也是基于MySQL/PHP的程序。它可以说的上是一个新出道的地址管理程序，它也拥有一些类似于其它程序的特性集，另外一个方面它还能够直接使用不一样的颜色为不一样的网络段显示所用的IP地址。除此之外，它支持A/B/C类子网，并可用图形方式查看子网(就比如说：VLAN、位置以及在用的IP地址等等)，它可以为每一个用户配置MAC地址等等。
三、RackTables
最后RackTables称自己为一个“机架空间、交换机、IP地址、服务器、路由器等等的管理框架”。它拥有一个web界面，执行报告以及配置，并管理名字服务。另外一个方面，RackTables主要是以Apache、PHP5、MySQL这三者作为基础的。它能够直接实现精确的网络连接管理，除此之外还拥有统一的搜索功能以及一个多用户的访问模块。不过在这里小编想说的是，它的文档资料少得非常可怜，所以这样子的话我们就需要花一点时间来搞清楚它的运作机理了。不过呢，在非常大的程度上面，就小编个人认为RackTables使用起来相对来说还是蛮容易的。
在这里的话，大家还可以有另外一个选择对这一些工具进行定制。上面小编所介绍的三个工具都是基于GPL（是一份GNU通用公共授权非正式的中文翻译）的许可，因此大家能够直接重新分发我们的修改版本或者是为有的项目作出一点点的贡献(当然拉，这是一件不错的事情，毕竟大家都应该知道Unix/Linux世界需要更加多高质量的IPAM应用程序，从而就可以和名字服务非常好地集成在一起了)。
注：本文转载自微信公众平台；文内观点仅供参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408a6d080527b164a07d326f498374fb/" rel="bookmark">
			Parallel Scavenge和Parallel Old垃圾回收器组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.5.2. Parallel Scavenge和Parallel Old垃圾回收器组合 1）工作地点
Parallel Scavenge垃圾回收器工作在年轻代，而Parallel Old工作在老年代。
2）工作原理
当使用Parallel Scavenge垃圾回收器时：首先在用户线程处于安全的时候执行STW（stop-the-world），这个时刻称为安全点，执行STW时用户线程会暂停执行，同时会有多个线程来并行清理垃圾，垃圾清理的算法是Copying拷贝算法。
当使用Parallel Old垃圾回收器时：首先在用户线程处于安全的时候执行STW（stop-the-world），这个时刻称为安全点，执行STW时用户线程会暂停执行，同时会有用户线程来并行清理垃圾，垃圾清理的算法是Compacting压缩算法。
3）Parallel Old采用标记压缩的原因
Parallel Old垃圾回收器更注重于吞吐量，标记压缩算法是一种在垃圾回收时移动对象的算法，相较于标记清除等非移动式垃圾回收算法，虽然会由于STW耗时长而降低用户线程的执行效率，但是因节省了在内存分配和访问上时间（内存分配和访问的频率远高于垃圾回收的频率），所以总吞吐量就提高了。
4）适用场景
Parallel Scavenge和Parrallel Old垃圾回收器更适用于注重于吞吐量或处理器资源较为稀缺的场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67459e2f968d88f124153f2b3fe05752/" rel="bookmark">
			Serial和Serial Old垃圾回收器组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.5.1. Serial和Serial Old垃圾回收器组合 1）工作地点
Serial垃圾回收器工作在年轻代，而Serial Old工作在老年代。
2）工作原理
当使用Serial垃圾回收器时：首先在用户线程处于安全的时候执行STW（stop-the-world），这个时刻称为安全点，执行STW时用户线程会暂停执行，同时会有一个单独的线程来清理垃圾，垃圾清理的算法是Copying拷贝算法。
当使用Serial Old垃圾回收器时：首先在用户线程处于安全的时候执行STW（stop-the-world），这个时刻称为安全点，执行STW时用户线程会暂停执行，同时会有一个单独的线程来清理垃圾，垃圾清理的算法是Mark Sweep标记清除算法或Mark Compact标记压缩算法。
3）使用场景
Serial和Serial Old垃圾回收器由于没有线程交互的开销，所以可以获得很高的单线程收集效率，适用于单机场景。同时也适合内存资源受限的环境，因为Serial和Serial Old垃圾回收器是所有垃圾回收器中额外内存消耗最少的。
4）缺陷
因为只有一个单独线程来清理垃圾所以停顿时间就会比较长，对于现代处理器来说，已经不适用。
5）Serial和Serial Old的对比
工作地点 垃圾清理算法
Serial 年轻代 Copying拷贝算法
Serial Old 老年代 Mark Sweep标记清除算法
或Mark Compact标记压缩算法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93031ef66f5ed4e5c84d338fa8c0a3f8/" rel="bookmark">
			【hive】java.lang.ClassNotFoundException: org.apache.tez.dag.api.TezConfiguration的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动HiveServer2中或者外部客户端连接HiveServer2时候有可能出现此异常，具体是
java.lang.ClassNotFoundException: org.apache.tez.dag.api.TezConfiguration
解决方案是：配置文件hive-site.xml中的hive.execution.engine属性值由tez修改为mr，然后重启HiveServer2即可。因为没有集成tez，重启后依然会报错，但是60000ms后会自动重试启动（一般重试后会启动成功）
这算是一个遗留问题，但是不影响客户端正常连接，只是启动时间会多了60秒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c295df63fb7836cce7f143dad5fc5657/" rel="bookmark">
			银河麒麟系统QtCreator不能切换中文输入法问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
在Linux系统中QtCreator不能切换成中文输入法。
背景知识：
Fcitx是 (Free Chinese Input Toy for X) 的英文缩写，中文名为小企鹅输入法，是一个以 GPL 方式发布的输入法框架， 编写它的目是为桌面环境提供一个灵活的输入方案，彻底解决在GNU/Linux下没有一个好的中文输入法的问题。
解决方法：
在GitHub上个下载fcitx插件源码，地址如下：https://github.com/fcitx/fcitx-qt5
下载fcitx输入法框架的源码到本地，且本地必须安装了cmake才能进行后续的编译输出。
修改根目录文件 CMakeLists.txt, 在"set(CMAKE_MODULE_PATH ${ECM_MODULE_PATH} ${ECM_KDE_MODULE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/cmake)"行之后加入:
set(Qt5Core_DIR /XXX/Qt5.5.1/5.5/gcc_64/lib/cmake/Qt5Core/) set(Qt5Gui_DIR /XXX/Qt5.5.1/5.5/gcc_64/lib/cmake/Qt5Gui/) set(Qt5Widgets_DIR /XXX/Qt5.5.1/5.5/gcc_64/lib/cmake/Qt5Widgets/) set(Qt5DBus_DIR /XXX/Qt5.5.1/5.5/gcc_64/lib/cmake/Qt5DBus/) 编译源码: cmake . make sudo make install 同为麒麟系统，QT版本一样时，不用再进行编译，直接将libfcitxplatforminputcontextplugin.so库拷贝到对应的目录中即可。
库下载路径https://download.csdn.net/download/duck251/13212276
把编译得到 libfcitxplatforminputcontextplugin.so 拷贝到 Qt5.5安装目录的
/opt/Qt5.14.1/5.14.1/gcc_64/plugins/platforminputcontexts/ sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.14.1/5.14.1/gcc_64/plugins/platforminputcontexts/ 和
/opt/Qt5.14.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/
sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.14.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/ 下(拷贝之后记得加 755 权限) 。
sudo chmod 755 libfcitxplatforminputcontextplugin.so 目录位置注解
（1） /XXX/Qt5.14.1/5.14.1/gcc_64/plugins/platforminputcontexts/ 这个目录是用qt
creator编译出的程序运行时调用插件的目录，在编译出的程序下新建 plugins/platforminputcontexts/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c295df63fb7836cce7f143dad5fc5657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72f7ffebe1aa2a6c680911276e546cc/" rel="bookmark">
			人脸聚类框架(Face Cluster Framework)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Face Cluster Framework (人脸聚类框架) English Version | 中文版
Intorduction 一个人脸图片聚类框架github
对于给定的大量待聚类人脸图片，利用人脸特征抽取组件(face_feature_extract)进行人脸特征抽取，并对用抽取的人脸特征进行人脸聚类并进行图片归档。
采用的人脸聚类算法较当前主流人脸聚类算法效果更优，具体测评效果详见人脸聚类
Cluster Result 输入数据：
部分聚类效果：
Requirements Python &gt;= 3.6sklearninfomapnumpyfaiss-gpu(or faiss-cpu)torch &gt;= 1.2torchvision Datasets and Pretrain_models 可用测试人脸图片数据10000张(data_sample), 下载地址 BaiduYun(passwd: trka)人脸特征抽取的预训练模型(pretrain_model), 下载地址 BaiduYun(passwd: trka)归档标注后的人脸图片数据10000张(labeled_data_sample), 下载地址 BaiduYun(passwd: trka) Run 将待聚档图片放入到 ‘data/input_pictures’ 目录下下载人脸特征抽取的预训练模型，将2个tar文件放到 ‘pretrain_models’ 目录下运行： python main.py 人脸图片聚类结果目录 ‘data/output_pictures’，每个数字子目录下为同一个人的人脸图片，格式如下： Evaluate 如果想测评聚类效果，可以利用归档标注后的人脸图片数据(如上述下载数据的labeled_data_sample)，放到’data/input_pictures’目录下，
并在main.py中设置is_evaluate=True即可测评聚类效果。不同人脸数据集可以通过调整main.py中的min_sim与k值获得最优参数
labeled_data_sample数据的聚类指标(调整参数还能提高)：
此外，可以通过利用自己的数据(如戴口罩的人脸数据)进行人脸特征解析模型训练，训练可以参考hfsoftmax
References face-clusterface_feature_extract 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6caa4b093e9147c8c2c0c4596129292/" rel="bookmark">
			charles下载web证书，抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击help，选中ssl Proxying ,点击Install Charles Root Certificate 2.点击”安装证书”按钮 点击”下一步”按钮
选中”将所有的证书都放入下列存储”，点击”游览”按钮
选中”受新任的根证书颁发机构”，点击”确定”按钮
点击”下一步”按钮
点击”完成”按钮
界面弹出”导入成功”弹框
点击”proxy”按钮，选中Proxy Settings…
勾选允许传输http代理，接着点击”OK”按钮
点击’proxy”按钮，选中SSL Proxyig settings…
点击勾选运行代理，点击“add”按钮
填写Host和Port都为*，正则表达式为匹配所有，再点击”OK”按钮
点击”OK”按钮
重启Charles,即可
16：验证是否可以获取web端的https接口
（1）打开Charles
（2）打开游览器输入数据
（3）查看Charles，查看获取https的包的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f80ca9a5f01f20d1c757e668a77f8c5/" rel="bookmark">
			银河麒麟 安装 jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：系统环境 ：
卸载open-jdk
1.首先查看系统是否自带Java
#Java -version 2.卸载open-jdk
#sudo apt-get remove openjdk* 安装JDK
下载地址:
https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
1.下载jdk1.8安装包
jdk-8u271-linux-x64.tar.gz
2.切换到安装目录
cd /home/XXXXXXXXXX/java/jdk 3.解压 jdk-8u271-linux-x64.tar.gz
tar -zxvf '/home/XXXXXX/java/jdk/jdk-8u271-linux-x64.tar.gz' 4.设置JDK环境变量
#vim /etc/profile 编辑文件
直接点击i
在profile最后面追加java_home和path：
export JAVA_HOME=/home/XXXXXXXXX/java/jdk/jdk1.8.0_271 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 按Esc退出编辑状态，shift+: 然后输入:wq保存并退出文件
如果出现下面的错误， 切换root 用户。然后设置 /etc/profile 的权限是 777 读写权限
#切换root用户 sudo su # /etc/profile 设置 777 权限 chmod 777 /etc/profile 5.刷新配置文件，使配置文件产生作用
#source /etc/profile 6.测试java是否安装成功
#java -version 如果出现下面的错误，说明下载的 jdk 版本的位置 与操作系统的位数不一致造成的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95fd76000de3ccf697768b2993969281/" rel="bookmark">
			OJ8-3  C. Slack Time 松弛时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C. Slack Time
运行时间限制: 1000 运行内存限制: 65536
作者: scsxuke 是否specialjudge: False
题目描述
Given an Acyclic Graph as the figure (shared by QQ), delete one edge of activity, then calculate the slack time of the left nodes.
Output the slack time of a specified node
input
1 line of numbers seperated by commar, the first two are the nodes numbers of the edge to be deleted, the third gives the node number to be output the slack time
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95fd76000de3ccf697768b2993969281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e7014ccd0a77f8ad450e814ddb14ee/" rel="bookmark">
			liunx安装nginx全步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装依赖
yum install gcc
yum install pcre-devel
yum install zlib zlib-devel
yum install openssl openssl-devel
//一键安装上面四个依赖
yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel
下载nginx的tar包
进入opt 文件夹内 wget http://nginx.org/download/nginx-1.13.7.tar.gz 解压 tar
-xzvf nginx-1.13.7.tar.gz
安装nginx
//进入nginx目录
cd /opt/nginx-1.13.7
//执行命令
./configure
//执行make命令
make
//执行make install命令
make install
由于我是把nginx安装在opt的目录下所以后续操作按照安装的目录来
进入 /usr/local/nginx/conf 目录下配置
启动nginx
/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
重启nginx
1.进入/usr/local/nginx/sbin 目录下
检查配置是否成功
./nginx -t
重启 ./nginx -s reload
经过以上步骤 我成功搞定。
注意：要注意自己的防火墙，及端口的开放，防火墙的配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/139be1d92e58c489e9a782cb926a8a95/" rel="bookmark">
			多目标学习(Multi-task Learning)-网络设计和损失函数优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前多目标学习主要从两个方向展开，一个是网络结构设计，一个是损失函数优化；
一、MTL网络设计 MTL网络通常可分为两种，一种是hard-parameter sharing不同任务间共用底部的隐层，另一种是soft-parameter sharing，形式较为多样，如两个任务参数不共享，但对不同任务的参数增加L2范数的限制；也有一些对每个任务分别生成各自的隐层，学习所有隐层的组合；这两种方式各有优劣，hard类的网络较soft不容易陷入过拟合，但如果任务差异较大，模型结果较差，但soft类网络通常参数较多，结构比较复杂，线上部署困难；
1、hard-parameter sharing models hard-parameter sharing models为不同任务底层共享模型结构和参数，顶层分为几个不同的目标进行网络训练
这种结构本质上可以减少过拟合的风险，但是效果上可能受到任务差异和数据分布带来的影响
基本上，只要是能预测单模型的模型，都可以很简单的转化为hard-parameter sharing models的结构，只需要将共享层的最后一层与多个输出层拼接即可。
2 soft-parameter sharing models soft-parameter sharing models不同于hard-parameter sharing model，每个任务有自己的参数，最后通过对不同任务的参数之间的差异加约束，表达相似性。比如可以使用L2, trace norm（迹范数）等。
网络结构如下：
3、相关技术 3.1 MMoE 谷歌2018 其中(a)是传统的硬共享参数模型，(b)是MoE模型，使用单个gate控制多个任务的参数，（c）是MMoE模型，在MoE的基础上，每个任务使用一个gate控制其权重。
名词解释：
a、expert：指对模型输入进行不同方式的变换处理的网络层，每个Expert表示一种网络（Expert也可以都一样）
b、gate：控制每个Expert权重的变量，对于每一个任务，不同Expert的权重可能是不一样的，因此使用gate来控制权重，类似于attention
MoE模型对于不同的任务的gate权重是一样的，其函数表达式如下：
y k = h k ∑ i = 1 n g i f i ( x ) y^k=h^k\sum_{i=1}^{n}g_if_i(x) yk=hki=1∑n​gi​fi​(x)
其中k表示第k个任务，n表示n个expert网络
MMoE是在MoE的基础上提出的方法，作者认为对于不同的任务，模型的权重选择是不同的，所以为每个任务分配一个gate模型。对于不同的任务，gate k的输出表示不同Expert被选择的概率，将多个Expert加权求和，得到f_k(x)，并输出给特点的Tower模型，用于最终的输出。
MMoE模型的表达式如下：
f k ( x ) = ∑ i = 1 n g i k ( x ) f i ( x ) f^k(x)=\sum_{i=1}^{n} g_i^k(x)f_i(x) fk(x)=i=1∑n​gik​(x)fi​(x)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/139be1d92e58c489e9a782cb926a8a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597e8fec11fbafbe7a5ebdb8dbebbb4d/" rel="bookmark">
			java中byte为何范围是-128~127
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/u012959008/article/details/72812658?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c145026b6c7a13dddd0117695e0dd1d7/" rel="bookmark">
			分布式事务解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式事务解决方案 1.分布式事务解决方案-面试 ​ 刚才编写的扣减库存与保存订单是在两个服务中存在的，如果扣减库存后订单保存失败了是不会回滚的，这样就会造成数据不一致的情况，这其实就是我们所说的分布式事务的问题，接下来我们来学习分布式事务的解决方案。
1.1 本地事务与分布式事务 1.1.1 事务 数据库事务(简称：事务，Transaction)是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。
事务拥有以下四个特性，习惯上被称为ACID特性：
原子性(Atomicity)：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
一致性(Consistency)：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到(这层语义也有说应该属于原子性)。
隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。
持久性(Durability)：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。
1.1.2 本地事务 起初，事务仅限于对单一数据库资源的访问控制,架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源,这类基于单个服务单一数据库资源访问的事务，被称为本地事务(Local Transaction)。
1.1.3 分布式事务 ​ 分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上,且属于不同的应用，分布式事务需要保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。
​ 最早的分布式事务应用架构很简单，不涉及服务间的访问调用，仅仅是服务内操作涉及到对多个数据库资源的访问。
​ 当一个服务操作访问不同的数据库资源，又希望对它们的访问具有事务特性时，就需要采用分布式事务来协调所有的事务参与者。
​ 对于上面介绍的分布式事务应用架构，尽管一个服务操作会访问多个数据库资源，但是毕竟整个事务还是控制在单一服务的内部。如果一个服务操作需要调用另外一个服务，这时的事务就需要跨越多个服务了。在这种情况下，起始于某个服务的事务在调用另外一个服务的时候，需要以某种机制流转到另外一个服务，从而使被调用的服务访问的资源也自动加入到该事务当中来。下图反映了这样一个跨越多个服务的分布式事务：
​ 如果将上面这两种场景(一个服务可以调用多个数据库资源，也可以调用其他服务)结合在一起，对此进行延伸，整个分布式事务的参与者将会组成如下图所示的树形拓扑结构。在一个跨服务的分布式事务中，事务的发起者和提交均系同一个，它可以是整个调用的客户端，也可以是客户端最先调用的那个服务。
​ 较之基于单一数据库资源访问的本地事务，分布式事务的应用架构更为复杂。在不同的分布式应用架构下，实现一个分布式事务要考虑的问题并不完全一样，比如对多资源的协调、事务的跨服务传播等，实现机制也是复杂多变。
只要是涉及到多个微服务之间远程调用的话，那就回涉及到分布式事务。
分布式事务的作用：
保证每个事务的数据一致性。 1.2 分布式事务相关理论 1.2.1 CAP定理-重点 CAP定理是在 1998年加州大学的计算机科学家 Eric Brewer （埃里克.布鲁尔）提出，分布式系统有三个指标
Consistency 强一致性Availability 可用性Partition tolerance 分区容错 它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。
真实情况：
1 ac 只用一个数据库：黑马旅游网 图书馆管理系统
2 cp 钱 银行app
3 ap 互联网
分区容错 Partition tolerance ​ 理解: 分布式系统集群中, 一个机器坏掉不应该影响其他机器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c145026b6c7a13dddd0117695e0dd1d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa682a76d5d70e562643ee05dd86005/" rel="bookmark">
			Hadoop大数据简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Hadoop概述 1.1 Hadoop简要概述 我们生活在这个数据大爆炸的时代 ，很难估算全球电子设备中存储的数据总共有多少 。当前一个中小型公司的数据量也达到数十TB，甚至更多。
有句话说得好 ：“ 大数据胜于好算法 。” 意思是说对于某些应用 （譬如根据以往的偏好来推荐电影和音乐），不论算法有多牛 ，基于小数据的推荐效果往往都不如基于大量可用数据的 一般算法的推荐效果 。
我们遇到的问题很简单：在硬盘存储容量多年来不断提升的同时，访问速 度（硬盘数据读取速度）却没有与时俱进 。
第二个问题是大多数分析任务需要以某种方式结合大部分数据来共同完成分析 ，即从一个硬盘读取的数据可能需要与从另外 99 个硬盘中读取的数据结合使用 。各种分布式系统允许结合不同来源的数据进行分析，但保证其正确性是一个非常大的挑战 。
MapReduce 提出一个编程模型 ，该模型抽象出这些硬盘读写问题井将其转换为对一个数据集（由键值对组成）的计算 。后文将详细讨论这个模型 ，这样的计算由 map 和 reduce 两部分组成 ，而且只有这两部分提供对外的接口 。与HDFS 类似，MapReduce自身也有很高的可靠性 。
MapReduce 看似采用了一种蛮力方法 。每个查询需要处理整个数据集或至少一个数据集的绝大部分 。但反过来想，这也正是它的能力 。MapReduce 是一个批量查询处理器 ，能够在合理的时间范围内处理针对整个数据集的动态查询 。它改变了我们对数据的传统看法 ，解放了以前只是保存在磁带和硬盘上的数据 。它让我们有机会对数据进行创新 。以前需要很长时间处理才能获得结果的问题 ，到现在变得顷刻之间就迎刃而解 ，同时还可以引发新的问题和新的见解 。
1.2 Hadoop发展历史 Hadoop 是 Apache Lucene 创始人Doug Cutting 创建的 ，Lucene 是一个应用 广 泛 的文本搜索系统库Hadoop起源于开 源的网络搜索引擎Apache Nutch，它本身也是 Lucene 项目的一部分 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afa682a76d5d70e562643ee05dd86005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4583254a2457830bbb7c4cbc6ad963/" rel="bookmark">
			阿里运维笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一．单项选择题
&lt;阿里云&gt;一个大型网站准备上线，时间非常紧急，需要在2天内完成2000台ECS的开通的环境部署，以下哪个功能可以帮客户解决困难？©
A、SSD
B、快照+OpenAPI
C、自定义镜像+OpenAPI
D、共享快照
&lt;阿里云&gt;阿里云的产品中负责负载均衡的产品是？(A)
A． SLB
B． ECS
C． OSS
D． RDS
&lt;阿里云&gt;弹性伸缩是否一定要搭配ECS使用？(A)
A. 否
B. 是
&lt;阿里云&gt;Aliyun Linux和以下哪个系统兼容？(D)
A. UBUNTU
B. OpenSUSE
C. windows server2008
D. Red Hat
&lt;阿里云&gt;小明是一个社交网站的架构师，创业初期用户量较少，每个注册客户上传的图片文件直接保存在了一台阿里云的云服务器 ECS 实例上。最近用户量爆增，图片存储的空间达到了 3.5T，WEB 服务器由原来的 1 台 ECS 实例扩展到了 5 台 ECS 实例，性能问题得到了解决，可是保存在 ECS 实例的图片无法在多台 ECS 之间共享读写。 阿里云的____A____产品非常适合解决这个问题。
A. 对象存储 OSS；
B. 负载均衡 SLB；
C. 归档存储（Archive Storage）；
D. 内容分发网络 CDN；
&lt;阿里云&gt;您基于阿里云的云服务器ECS实例部署了Mysql数据库，随着业务量的不断上涨，您需要通过读写分离的方式来改善数据库的性能，可以采用阿里云的©产品来快速解决该问题。
A. 对象存储OSS
B. 本读SSD盘
C. 云数据库RDS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb4583254a2457830bbb7c4cbc6ad963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4abcad6eb64b2f04fb882994365559a5/" rel="bookmark">
			TCP 协议相关知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
TCP 的特性 **
TCP 提供一种面向连接的、可靠的字节流服务
TCP 使用校验和，确认和重传机制来保证可靠传输
TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制
注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。
**
TCP 帧格式 **
TCP的源端口、目的端口、以及IP层的源IP地址、目的IP地址四元组唯一的标识了一个TCP连接
TCP各字段释义：
TCP源端口(Source Port)：16位的源端口其中包含发送方应用程序对应的端口。源端口和源IP地址标示报文发送端的地址。
TCP目的端口(Destination port)：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。
TCP序列号（SequenceNumber）：该数据报第一个数据字节的序列号，用作标识该报文段序列号
TCP应答号(Acknowledgment Number简称ACK Number)：存放的是发送方期望收到的数据段序号，算作是对收到报文的一个确认。ACK标志为 0 时，应答号部分无效(例如首个连接的[SYN]数据包)，ACK标志为1时应答号才有效
TCP首部长度：标明TCP协议报头长度，单位是32bit即4个字节，其最小值为5（5 x 4 = 20 byte，这个长度是除去可选项的长度），从上图中看出，其规定头部长为 4 bit，所以最大值为 15， 15 x 4 = 60 byte可以算出可选项长度大为40个字节(60 byte - 20 byte = 40 byte)
保留位：保留字段长度为3位，必须全置为0
标记：
标志位简写 全写 含义
NSNonce有效排除潜在的ECN滥用CWRCongestion Window Reduced拥塞窗口减少标志ECEECN-EchoECN标志URGUrgent紧急指针有效性标志ACKAcknowledgment确认序号有效性标志，一旦一个连接建立起来，该标志总被置为1PSHPushush标志（接收方应尽快将报文段提交至应用层）RSTReset重置连接标志SYNSynchronization同步序号标志(建立连接时候使用)FINFin传输数据结束标志(断开连接时使用) 窗口大小(Window Size)：16位，该值指示了从Ack Number开始还愿意接收多少byte的数据量，也即用来表示当前接收端的接收窗还有多少剩余空间，用于TCP的流量控制。
校验位(Checksum)：16位TCP头。发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端checksum校验失败的时候会直接丢掉这个数据包。CheckSum是根据伪头+TCP头+TCP数据三部分进行计算的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4abcad6eb64b2f04fb882994365559a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a9f0a492ac5f3ded556435f0436924/" rel="bookmark">
			error:could not open jvm.cfg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次写博客，记录我java之旅
一、为什么产生这个问题
我是看的尚硅谷的视频进行java安装的，在安装jbk的过程一定要注意记住安装路径，不要随意更改目录名。
因为在注册表中，已经登记好了你的注册数据。若更改路径，cmd运行都会报错，会显示出你在安装程序的默认路径。例如:error:could not open"F:\JAVA\soft.jdk.1.8.0/bin… jvm.cfg"
二、解决问题
首先，Windows＋R输入regedit找到注册编辑器中HKEY_LOCAL_MACHINE/software/javasoft/Java Development Kit/1.8.0_131/MSI，查看INSTALLDIR找到原始注册路径。把之前更改的文件路径改成原始注册路径。
之后，设置环境变量，jdk就可以运行了。
三、其他问题的解决方法
1.设置环境变量时，把path路径下的jdk放到最上边，可以优先调用
2.之前安装过JAVA，需要把之前的注册表删掉，把HKEY_LOCAL_MACHINE/software/javasoft，把这个javasoft删除即可。
重新安装jdk
重新配置环境变量
成功解决问题！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f1dff7e8d5c1d21409446a77701a11/" rel="bookmark">
			batch normalization学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习存在两个问题 1，由于更新权重导致输入取值范围的变化导致收敛慢。
2，由于输入数量的增多，一般都是累加x*w。而若假设他们都是正太0，1分布，那么加的越多会导致方差越大，因此使用sigmoid会导致饱和，而使用relu 等线性的会导致数有可能很大，几百上千的值。
解决方案 将每个核的输出给一个归一化，让其都保持期望是0，方差为1。
归一化的话无非就是求均值方差，而根据求得方法分为很多种，因此出现各种normalization 方法。
batch 方法就是在batch范围内对每个单个得输出求均值。
layer 方法是在每个layer求均值。
而最新的Cross Iteration Batch Normalization，由于batch normalization是batch 求均值，因此batch小了的话反而造成不好的效果，因此尝试累计这个均值和方差。
但是不同次batch 训练时参数都变了，因此直接利用前几次batch 的均值和方差有偏差，因此需要做一个简单的线性拟合。
具体计算见原论文，或https://zhuanlan.zhihu.com/p/159762029
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7669738acd1ddd3af03c278ea8225d/" rel="bookmark">
			实现tinyc语言的扫描程序_C语言实现的一个交互小程序(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于C语言如何有效正确的学习，我写了一个专栏：你可以这样学习C语言，有兴趣的小伙伴可以来看看哦，希望能对你有收获！需要本文源代码的可以关注我后私信我！
阅读本文之前，请先阅读：
C语言实现的一个交互小程序(一)C语言实现的一个交互小程序(二) 三、功能扩展示例 你可以很方便的在这个程序上扩展你自己的功能模块。
现在这个结构已经有两个功能模块，一个是function1，它包含一个.h头文件”function1.h“，还包含一个.c实现文件”function1.c“；另一个是function2，它包含一个.h头文件”function2.h“，还包含一个.c实现文件”function2.c“。
下面我用一个”学生管理系统“的例子来说明如何扩展这个结构。”学生管理系统“的源码网上有很多，也是很经典的C语言上手实例项目。我们假设学生管理系统有三个功能需要实现，如下：
1. ”学生“类型的定义；
2. 添加一个学生；
3. 删除一个学生；
现在针对这三个功能，我们在这个程序上来扩展。
1. 扩展”学生“类型的定义
我们可以增加一个.h头文件：student.h，文件内容如下：
2. 扩展”添加学生“的功能模块
扩展这个功能模块时，需要添加.h头文件AddStu.h，以及一个.c文件AddStu.c。
在AddStu.h文件中，声明如下函数：
extern void AddStu();//添加一个学生的函数 在AddStu.c文件中，实现如下函数：
void AddStu(){ puts("成功添加一个学生!");} 在菜单选择界面，添加一个”学生添加“选项"puts(" 3. add_stu");"：
在switch语句中，添加case语句3：调用”AddStu“的模块
3. 扩展”删除学生“的功能模块
扩展这个功能模块时，需要添加.h头文件DelStu.h，以及一个.c文件DelStu.c。
在DelStu.h文件中，声明如下函数：
extern void DelStu();//删除一个学生 在DelStu.c文件中，实现如下函数：
void DelStu(){ puts("删除一个学生成功");} 在菜单选择界面，添加一个”学生删除“选项"puts(" 4. del_stu");"：
在switch语句中，添加一个case语句4：调用”DelStu“的模块
基本上扩展的套路就是这样。
如果你觉得欢迎界面或者菜单选择界面不够丰富，不够美观，你也可以自行完善里面的信息。如果你美学功底深厚，又有点技术底子，可以考虑使用graphics图形库画个漂亮的界面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4191274fab2d6c4be9d3ac0a458ae731/" rel="bookmark">
			数据库MVCC看这个肯定有收获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、回顾 本文主要内容围绕MVCC多版本并发控制展开，通过本文你可以收获事务隔离级别的原理。知道幻读，不可重复读，可重复读等原理。以及数据库的一些底层知识。
1.1 数据库常见的一些问题 mysql数据库的innodb引擎中存在一些名词像幻读、脏读、不可重复读、隔离级别。我们现在先依次解释下这些名词。
脏读：事务A中读到了事务B尚未提交的数据（事务B可能会回滚）
不可重复读：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）
幻读：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）
很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。
1.2 事务隔离级别 MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。
MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性
隔离级别比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交
隔离级别对性能的影响比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交
由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。
1.3 二者关系总结 2 隔离级别实现原理 我们知道有锁这种东西，其实在数据库也是有锁的。数据库中的隔离级别读提交、可重复读都是通过基于乐观锁的MVCC方案实现的，而不是悲观锁。
在RC（读提交）级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。
其实隔离级别主要是为了解决读问题，写问题我们后面再讨论。同时innodb中的默认隔离级别是可重复读，那么这里也就主要分析可重复读的原理。
2.1 MVCC在MySQL的InnoDB中的实现 在可重复读情况下，事务一旦开启就会对整个库生成一个快照，这个快照并不是把整个库复制一遍，这个快照需要保存的信息极少。它保存当前活跃的所有事务id（事务id是每启动一个事务都从数据库申请的一个自增的id）。然后从这个事务id中选出最大和最小的。并把这个最大+1和最小值分别定义为上界和下界。当前事务内，同一条sql在不同时刻执行时，会用当前事务的id和数据行上标记的事务id进行比较。
①凡是数据行上事务id小于下界，则认为改事务结束时，当前事务尚未开始。
②数据行上记录的事务id刚好在上下界之间，则需要判断这个事务id是否在活跃事务数组内，如果在，则认为当前事务启动时，这个数据被一个当时的活跃事务修改了。需要找回这个记录的历史记录。（怎么找回历史记录呢？mysql行上除了会保存数据内容，事务id，还会保存一个undo_log(回滚日志)。可以通过执行回滚日志拿到上一个版本的内容，并判断上一个版本的事务id是否小于下界，满足则取改版本数据返回，否则继续往回找）
③跟随上面②如果数据行上的事务id不在活跃数组内，说明操作这个数据事务id是在当前事务启动之前就已经提交的。数据可以直接使用。
④如果数据行上的事务id刚好大于上界，则这个数据肯定在当前事务之后启动的某个事物修改了。这种情况的话需要和2一样往前
总结上面的三种情况，一个事务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c463a0fde25e390c6884f8a1b2ad89/" rel="bookmark">
			算法之【动态规划】详解（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法之动态规划详解 定义 动态规划其实是一种运筹学方法，是在多轮决策过程中寻找最优解的方法。
应用场景 动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。
核心思想 求解动态规划的核心求解思路是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。但是我们在求解过程中， 需要避免重复计算从而更快速的找到答案 。
动态规划三要素 最优子结构：原问题的最优解所包含的子问题的解也是最优的，通过子问题的最值得到原问题的最值。存在重叠子问题：子问题间不独立（这是动态规划区别于分治的最大不同）；如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。无后效性：即后续的计算结果不会影响当前结果。 动态规划通用解题过程 动态规划没有标准的解题方法，即没有一个完全通用的解题方法。但在宏观上有通用的方法论：
下面的 k 表示多轮决策的第 k 轮：
问题分解，将原问题划分成几个子问题。一个子问题就是多轮决策的一个阶段。
找状态，选择合适的状态变量 S(k)。它需要具备描述多轮决策过程的演变，更像是决策可能的结果。
做决策，确定决策变量 u(k)。每一轮的决策就是每一轮可能的决策动作，即当前可以有哪些决策可以选择。
状态转移方程。这个步骤是动态规划最重要的核心，即 S(k+1)= uk(sk) 。
定目标。写出代表多轮决策目标的指标函数 V(k,n)，即最终需要达到的目标。
寻找目标的终止条件。
动态规划的解题核心就是找到状态转移方程，其实所谓的状态转移方程说白了就是数学上的递推方程，没有什么高大上的。就是通过最基础的问题，一步步递推出所需要的最终目标结果。只是在定义状态转移方程的含义时，有不同的定义方式，不同的定义方式会有不同的递推方程式，但是只要定义正确，都可以得到最终正确的结果。
通常状态转移方程定义过程
明确当前可改变的状态有什么；定义dp数组或者递归函数的具体含义；明确每一步可以进行的选择有哪些；编写递推方程，也就是状态转移方程；明确baseline，也就是递推开始时的基础值是什么。 动态规划解题方式 动态规划的解题方式通常分为两种：
通过定义递归方程解决，这是一种自顶向下的求解方式，通常这种方式会有很多重复计算过程，因此可以通过建立备忘录记录中间过程来进行优化；通过定义DP(Dynamic Programming)数组来求解，这是一种自底向上的求解方式。 至于选择哪一种解题方式，可以根据自己的习惯来。自己比较习惯那种方式思考就用哪种方式即可。
简单举例 下面以常见的斐波拉契数列为例来说明一下上述两种求解方式。
斐波那契数列（Fibonacci sequence）是指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……。即后一个数为前两个数之和。在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）
通过暴力递归求解
定义fib(n)函数返回的是斐波拉契数列第n项的值：
def fib(n): if n &lt;= 2: return 1 return fib(n-1) + fib(n-2) 此时的时间复杂度O(2^n)指数级，计算很慢。
我们来看一下递归的状态树：
从状态树我们可以看到有很多重复计算的节点，为了避免重复，我们可以通过建立一个备忘录memo记录,来记录中间节点的计算结果，避免重复计算，可以将时间复杂度直接降为O(n)线性复杂度，优化代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67c463a0fde25e390c6884f8a1b2ad89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3f158e761cf45524961cff52d119bd/" rel="bookmark">
			分页式存储（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分页式存储（C语言实现） 分段允许进程的物理地址空间是非连续的。分页是提供这种优势的另一种内存管理方案。然而，分页避免了外部碎片和紧缩，而分段不可以。
不仅如此，分页还避免了将不同大小的内存块匹配到交换空间的问题，在分页引入之前采用的内存管理方案都有这个问题。由于比早期方法更加优越，各种形式的分页为大多数操作系统采用，包括大型机的和智能手机的操作系统。实现分页需要操作系统和计算机硬件的协作。
基本方法 分页存储管理是将一个进程逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始，如第0页、第1页等。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。将每个进程的页面号和相应的内存块号的对应关系存储在页面变换表中，这样就可以通过地址变换机构寻找到某个逻辑地址在内存中的实际物理地址。
代码实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define BLOCKSIZE 200//定义块的大小 #define COUNT 100 // 定义内存块总数 enum STATUS {OCCUPIED,FREE//内存块的状态 } block[COUNT]; //建立内存块数组 记录内存信息 //进程链表 typedef struct ProcessInfo { int PId; //记录进程ID int pages; //记录页数 int * addr; //定义一个整形指针指向由动态数组构成的页面变换表 struct ProcessInfo * next;//链表指针指向下一个结点 }P; struct ProcessInfo *head;//定义链表头指针 void run();//程序菜单 void Allocate(int id,int size);//为进程分配内存：参数（进程ID 和所需内存大小size） void Releace(int id);//释放一个进程所占的内存：参数（进程ID） void Locate(int id,int log);//查看进程的逻辑地址对应的物理地址：参数（进程ID，逻辑地址） void dispaly();//显示 进程单链表 void mem(); //显示内存未被分配的块 //看进程的逻辑地址对应的物理地址 void Locate(int id,int log){ struct ProcessInfo *p_move;//定义一个结构体指针 用于遍历链表 int page,j;//page记录所在页数，j记录页内地址 p_move=head; j=log%BLOCKSIZE; while(p_move-&gt;PId!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b3f158e761cf45524961cff52d119bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6a652afd5a66b862fbd49c95bb43c9/" rel="bookmark">
			OAuth2.0四种授权方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OAuth OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。比如，现在很多APP都支持使用微信账号登录，用户授权后，这些APP后台可以获取到用户在微信绑定的手机号码和昵称信息，从而完成在APP的注册和登录，期间不需要用户提供微信的密码。
OAuth1.0 规范看这里
OAuth2.0 2.0版本比1.0版本更简单也更安全。OAuth2.0规范看这里或者rfc6749文件。
首先要先理解几个概念：
Access Token
访问令牌是用来访问受保护的资源的凭据。一个访问令牌是一个字符串，它代表发给客户端的授权。令牌代表资源所有者授予的对特定范围和访问的时间（令牌是有范围和有效期的）。
Refresh Token
Refresh Token是用于获取Access Token的凭据。刷新令牌是授权服务器发给客户端的，用于在当前访问令牌已经失效或者过期的时候获取新的访问令牌。
Scope
scope用于限制限制第三方应用可以获取哪些用户账户信息，由授权服务器自己定义。 应用程序可以请求一个或多个scope，然后在在授权页面把申请的权限范围呈现给用户，并且颁发给该应用程序的访问令牌将限于所授予的scope。
OAuth2.0授权方式 OAuth2.0定义了四种授权方式
授权码（authorization-code）隐式（implicit）密码式（password）：客户端凭证（client credentials） 注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到授权服务器备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。相当于账号密码，这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。比如：微信登录第三方应用，需要先在微信开放平台注册开发者帐号，并拥有一个已审核通过的移动应用，并获得相应的 AppID 和 AppSecret。
下面举例说明这四种方式授权步骤，假设有A和B两个网站，用户使用B网站的账号信息，登录A网站。
1. 授权码方式
适用于有前端（APP或网页）的应用。第三方网站或APP先向授权服务器申请一个授权码（用户确认授权后，授权服务器将授权码返回给第三方网站），然后第三方网站或APP后台用授权码去申请访问令牌。
1.1 用户在A网站点击“使用B登录”，浏览器跳转到B网站的授权页面。
https://b.com/auth2/code? response_type=code &amp;client_id=${client_id} &amp;redirect_uri=${callback_uri} &amp;scope=user_info 在上面的网址中，response_type=code,表示第三方应用要申请授权码，client_id是第三方应用在授权服务器系统备案的id，redirect_uri是第三方网站提供的回调地址，这一步scope可选。
1.2 在授权页面，用户确认授权后，B回调A网站的链接，返回授权码。
https://a.com/authorize?code=${code} 1.3 A后台接收到授权码后，用授权码向B申请access_token
https://b.com/auth2/access_token? grant_type=authorization_code &amp;client_id=${client_id} &amp;client_secret=${client_secret} &amp;code=${code} &amp;redirect_uri=${redirect_uri} 在上面的网址中，grant_type=authorization_code,表示授权码方式，client_id和client_secret是第三方应用在授权服务器系统备案的id和密码，redirect_uri是第三方网站提供的回调地址，可选，B可以回调A，也可以直接返回访问令牌。
1.4 B回调A，或直接返回数据。
{ "access_token":"2YotnFZFEjr1zCsicMWpAA", "expires_in":3600, "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA", "openId":"openId" } access_token是访问令牌，expires_in是访问令牌的超时时间，refresh_token用于访问令牌过期时重新向B获取访问令牌，这样可以减少用户操作授权的次数。openId是B提供的，这个用户的id，用于后续获取该用户账号信息。
1.5 A调用B的接口，用access_token和openId来获取用户账号信息等。
2. 隐式
隐式授权是为了兼顾到在浏览器中用诸如JavaScript的脚本语言实现的客户端而优化的简化授权代码流程。在隐式授权流程中，不是发给客户端一个授权码，而是直接发给客户端一个访问令牌，而且不会对客户端进行认证。隐式授权提高了一些客户端（比如基于浏览器实现的客户端）的响应能力和效率，因为它减少了获得访问令牌所需的往返次数。
2.1 用户在A网站点击“使用B登录”，浏览器跳转到B网站的授权页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f6a652afd5a66b862fbd49c95bb43c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff69de98ec2aa2df20e441692b7dde4a/" rel="bookmark">
			PS-twelveday-历史记录画笔工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、历史记录
1.作用：记录对图片的所作操作，可以对操作进行撤销和还原（整体的恢复）
2.特点：所撤销或还原的操作是针对一整个图片的。（一荣俱荣，一损俱损）
3.相机
可以将修改后的图片设置为最原始的状态
操作：将需要设置为最原始状态的图片的页面：点击历史记录面板-&gt;点击照相机
二、历史记录画笔工具
作用：可以针对性的对图片中的某一个部分进行撤销和还原操作（局部的恢复）
特点：所撤销或还原的操作是对图片中的某个部分的。（）
用历史记录画笔回复的是最原始的状态
三、历史记录艺术画笔工具
1.作用：打造艺术效果（与混合器画笔工具看上去有点像）
2.区别（个人感觉）：
历史记录艺术画笔工具：像是墨水混合，比较有流动性
混合器画笔工具：混合效果比较干燥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de055d27cd8e2b1fcb83141dd1f5e23/" rel="bookmark">
			ISO 14229系列（一）简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先感谢autogeek的分享，原文链接：http://www.cnblogs.com/autogeek/p/4458591.html
由于工作中经常用到ISO-14229，因此决定对该协议做个总体介绍和总结，既是对自己学习的总结，也能够给初次涉及该协议的朋友一个参考。
首先简要介绍什么是ISO-14229，至于可以在网上找到的大篇理论介绍我就略过不讲了，有兴趣可以自行搜索。简单的说，它就是一个用于汽车行业诊断通信的需求规范，它只规定了与诊断相关的服务需求，并没有涉及通信机制，因此要实现一个完整的诊断通信还需要定义网络层协议（比如ISO-15765），还有底层硬件实现方式（比如CAN控制器）。由于不涉及网络通信机制，可以架设在各种网络之上，因此ISO-14229也称为UDS（Unified Diagnostic Services）统一诊断服务。
1. 用途 ISO-14229的用途就是规定了诊断需求，因此想要了解ISO-14229的用途首先要知道诊断的用途。诊断最先用于汽车尾气排放的监测，后来发展为包括对汽车行驶故障的监测，想知道诊断的发展史，可以维基百科。至少现代的诊断可以粗略的分为排放相关和非排放相关，ISO-14229只定义非排放相关的诊断需求。非排放相关诊断可以做什么呢？其实用途很大，基本贯穿整个汽车ECU生命周期。首先，ECU开发时要用到它来构建bootloader，上传和下载数据；测试时要用它来读写RAM、ROM，控制外设；在产线上，要用它来校准机械件，刷新软件；在行驶过程中，要用它来监测各种故障，并记下故障码；在4S店，技师需要用它来读出故障码，判断故障发生点，还可以用来升级ECU程序。现在很火热的车联网概念，其中一些就是通过OBD口联网，读取车内故障码，车辆信息，或者油量、速度等等车相关的参数。
2. 诊断通信分层结构 虽然借鉴OSI的七层结构，但是诊断通信分层还是做了一些改变。可以参考如下列表：
OSI Layer
Enhanced Diagnostic Services
Application （layer 7）
ISO 14229
Presentation （layer 6）
-
Session （layer 5）
ISO 15765-3
Transport （layer 4）
ISO 15765-2
Network （layer 3）
ISO 15765-2
Data link （layer 2）
ISO 11898
Physical （layer 1）
ISO 11898
显然，从上表可以看出诊断通信分层模型和OSI的区别，同时也可以看到ISO-14229在该模型中的位置。其实，可以将该模型简化为：
- 统一诊断服务层 （layer 7）
- 网络服务层 （layers 1 to 6）
因此，在使用ISO-14229时，下面的通信机制可以改变，比如基于CAN，基于蓝牙，基于LAN，基于FlexRay等等。
3. 相关术语 3.1 协议相关术语 要了解协议，首先要知晓协议内定义的术语。我挑了一些使用频率比较高的在此解释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de055d27cd8e2b1fcb83141dd1f5e23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a4a4e5edb3f9d11a04479b708dd560/" rel="bookmark">
			向量范数和矩阵范数的相容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自 张绍飞, 赵迪. 矩阵论教程[M]. 机械工业出版社, 2012. 4.1 节
程云鹏. 矩阵论(第二版)[M]// 矩阵论（第二版）. 西北工业大学出版社, 2000. 2.2节
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2e4696af3e8ab6516be6518331105be/" rel="bookmark">
			折半查找（递归做法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;bits/stdc++.h&gt; using namespace std; int BinFind(vector&lt;int&gt;v,int x,int low,int high) { if(high&lt;low) // 尾下标小于头下标，说明没找到，返回-1 return -1; int mid=(low+high)/2; // 取中点 if(v[mid]==x) // 如果找到，返回所在下标 return mid; else if(x&lt;v[mid]) // 如果要查找的元素小于中点元素，继续查找数组前半部分 { return BinFind(v,x,low,mid-1); } else // 如果要查找的元素大于中点元素，继续查找数组后半部分 { return BinFind(v,x,mid+1,high);	} } int main() {	vector&lt;int&gt;v; int n,m; cin&gt;&gt;n; // 输入数组元素个数， for(int i=0;i&lt;n;i++) { cin&gt;&gt;m; // 输入元素，要按照从小到大的顺序输入 v.push_back(m);	} int x; cin&gt;&gt;x; // 输入要查找的元素 int idx=BinFind(v,x,0,v.size()-1); cout&lt;&lt;idx&lt;&lt;endl; // 输出要查找的元素在数组中的下标 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2161131af26be7611622349884c0545e/" rel="bookmark">
			多摄像头实时目标跟踪和计数，使用YOLOv4，Deep SORT和Flask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自github，很实用的一个应用。
git仓库地址：https://github.com/LeonLok/Multi-Camera-Live-Object-Tracking
这个存储库包含了我的目标检测和跟踪项目。所有这些都可以托管在云服务器上。
由于有ImageZMQ，你还可以使用自己的异步处理IP相机。
Deep SORT 和 YOLO v4
Check out我的Deep SORT repository：https://github.com/LeonLok/Deep-SORT-YOLOv4，查看我使用的跟踪算法，其中包括Tensorflow 2.0、异步视频处理和低置信度跟踪过滤。
交通流量计数
这个项目是目标计数应用的一个扩展。
功能
使用DETRAC数据集生成的244,617幅图像进行训练。可以在这里找到我创建的转换代码。 我把这篇论文：https://ieeexplore.ieee.org/document/8909903作为数据准备和训练的指南。每个跟踪id只计数一次。通过查看被跟踪目标的路径与计数线的交叉点对目标进行计数。 因此，那些跟丢了但用相同的ID重新跟踪的仍然会被计数。使用低置信度滤波进行跟踪，来自上面同样的论文。 提供更低的假阳性率。跟踪目标显示平均检测置信度。跟踪的类别由最常见的检测类别确定。显示检测结果是可选的(但是隐藏了平均检测置信度)。可以使用多个IP摄像头。方向计数可以配置为基于角度。每一小时的间隔记录计数。 总的计数基于类别的计数记录每个计数目标的交叉详细信息。 交叉时间交叉点坐标交叉角度可以托管在云服务器上。 注意，由于DETRAC不包含任何摩托车，它们是唯一被忽略的车辆。此外，DETRAC数据集只包含中国的交通图像，因此由于缺乏训练数据，它很难正确地检测出其他国家的某些车辆。例如，它经常会将掀背车误归为suv，或者由于不同的颜色方案而无法识别出租车。
目标计数
这个项目最初打算成为一个应用程序，用于使用我自己的智能手机计算当前在多个房间的人数，服务器被远程托管。下面展示了对人和汽车的检测、跟踪和计数。
功能
对当前视场中的物体进行计数跟踪可选支持多个IP相机每间隔一个小时记录一次当前的计数 当前的总数当前每个类别的计数可以托管在云服务器上 使用我自己的智能手机作为IP相机
训练你自己的机动车跟踪模型
我使用DETRAC训练带有v3标注的数据集训练了YOLOv4和Deep SORT模型。我提供了将DETRAC训练图像和v3标注转换为正确格式的脚本，用于训练YOLOv4模型和Deep SORT跟踪模型。
Deep SORT 转换参数
DETRAC图像转换为Market 1501训练格式。
遮挡阈值 - 忽略遮挡比率过高的车辆序列。截断阈值 - 忽略截断率过高的车辆序列。出现的次数 - 车辆序列太短(即没有足够的图像)被丢弃后，考虑遮挡和截断比率。 YOLO 转换参数
DETRAC图像被转换成Darknet YOLO训练格式。
遮挡阈值 - 忽略遮挡比率过高的车辆序列。截断阈值 - 忽略截断率过高的车辆序列。 两种模型都在DETRAC训练集上进行了训练和评估，但由于缺少v3标注，测试集还没有评估，我也没有MATLAB用于Deep SORT的评估软件。到目前为止，对于我的用例来说，它已经足够好了。
使用的硬件
Nvidia GTX 1070 GPUi7-8700K CPU 为了让大家了解我们的期望，我可以运行两个流量计数流，每个流大约10fps(正如你在流量计数gif中看到的)。当然，这在很大程度上取决于流分辨率以及用于检测和跟踪的帧数。
YOLO v3 vs. YOLO v4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2161131af26be7611622349884c0545e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a30c82533b2da72221e2fcb4dcdd919/" rel="bookmark">
			安装mysql依赖的时候  报warning:mysql-community-server-5.7.26-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature,
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装mysql依赖的时候 报warning:mysql-community-server-5.7.26-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY
安装rpm安装MySQL时爆出警告： 警告：MySQL-server-5.5.46-1.linux2.6.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY 原因：这是由于yum安装了旧版本的GPG keys造成的 解决办法：后面加上 --force --nodeps 如： rpm -ivh MySQL-server-5.5.46-1.linux2.6.x86_64.rpm --force --nodeps 从 RPM 版本 4.1 开始，在安装或升级软件包时会检查软件包的签名。
原因：这是由于yum安装了旧版本的GPG keys造成的
解决办法：后面加上
1
--force --nodeps
如：rpm -ivh mysql-community-server-5.7.19-1.el6.x86_64.rpm --force --nodeps
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf888d12c6fa693a8ded6f4e8273284/" rel="bookmark">
			python 长时间运行卡死_Python 程序运行时卡住，既不报错，也不停止，也不动，是什么原因？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光看这程序似乎也没有什么问题，而且卡住也有多种原因，题主的情况也不一定是卡住——我猜题主是根据一直没有输出来判断的吧。
还是先讲我的处理方案——调试。看来题主用的是类似于PyCharm的IDE，可以用IDE自带的调试器。我还是习惯于传统的print+logging+pysnooper：logging是自带的日志模块，可以选择输出高于某一级别（info、debug、error、critical等）的输出内容，可以调节为比较低的等级以输出更多的信息；另一个pysnooper是第三方的，输出的内容更详细，操作也更简单，就是耗费时间更长。有关的教程请题主自己查阅。找到明显的错误之后，就是百度+谷歌+stackoverflow大法即可。
另外，如果题主的程序是真的卡住了——比如说无法执行语句之类的“假死”状态（自己定义的，不能保证规范性），这种情况下一般应用程序会显示“无响应”，但也不敢保证微软bug导致没有显示出来。我的一种判断方法是进入任务管理器，看“python.exe”的进程的CPU和内存占用量。如果短时间内迅速上升，超出预期，就要考虑是不是“假死”。另外一种判断就是在异常处理中专门捕获KeyboardInterrupt异常，在程序持续无输出的时候按Ctrl+C尝试中断。具体操作如下：
try:
# ... your code here
except Exception as e: # catch all kinds of exceptions
if e.__class__ == KeyboardInterrupt: # if keyboard interruption is caught
raise KeyboardInterrupt # halt the program
# ... your remaining code here
由此可以用Ctrl+C中断，此时Python应当会抛出异常，同时会给出程序回溯的路线，这个时候可以依此找出卡住的语句。如果发现如此设置还是中止不了................
（PS：如果做了上述的异常处理，并加入了logging或pysnooper等，可能在控制台上看不到回溯，这个时候就要查看日志文件里的内容。）
非常抱歉，我也没办法.........毕竟这种情况也很罕见，没有太多的经验............
以上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a153dd2a90e2b78e20a2cb76fa98915/" rel="bookmark">
			URP——后期处理特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用渲染管道(URP)包括一个后处理效果的集成实现。如果使用URP，则不需要为后期处理效果安装额外的包。URP与Post Processing Stack v2包不兼容。
URP使用体积框架进行后期处理效果。
下面的图片显示了一个URP场景有没有后期处理的区别。
没有后期处理特效：
有后期处理特效：
注意:URP在OpenGL ES 2.0上不支持后期处理特效。
How to configure post-processing effects in URP 本节描述如何在URP中配置后期处理特效。
Using post-processing in the URP Template Scene 后期处理特效是在URP模板的样本场景中预先配置的。
要查看预配置的效果，在场景中选择后期处理体积。
若要添加额外效果，请向体积添加体积覆盖。
若要配置基于位置的后处理效果，请参阅如何使用本地体积。
Configuring post-processing in a new URP Scene 在新场景中配置后期处理特效:
选择一个相机，然后选择后期处理复选框。 在场景中添加一个带有Volume组件的GameObject。此指令添加一个全局Volume。选择GameObject &gt; Volume &gt; Global Volume。选择全局Volume游戏对象。在Volume组件中，单击Profile属性右侧的new按钮来创建一个新的Profile。 通过向Volume组件添加Volume Overrides向相机添加后处理效果。 现在，您可以在Volume组件的覆盖中调整后期处理效果设置。
若要配置局部的后期处理效果，请参阅如何使用本地体积。
Post-processing in URP for mobile devices 后处理效果会占用很多帧时间。如果你使用URP的移动设备，这些效果是最“移动友好”的默认:
Bloom (with High Quality Filtering disabled) Bloom(禁用高质量过滤)Chromatic Aberration 色差Color Grading 颜色分级Lens Distortion 透镜变形Vignette 晕映 注意:对于场的深度，Unity建议你对低端设备使用高斯场的深度。对于控制台和桌面平台，使用散景景深。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a153dd2a90e2b78e20a2cb76fa98915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14699c315980aaa94994fdc8a5cab834/" rel="bookmark">
			IP地址，子网掩码，网关三者的关系和作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IP地址（Internet Protocol Address）：IP地址是32位，分为网络号和主机号 一般ip地址常见的有三类 A类：前8位是网络号，后24位是主机号 **网络地址的最高位必须是“0”** B类：前16位是网络号，后16位是主机号	**网络地址的最高位必须是“10”** C类：前24位是网络号，后8位是主机号	**网络地址的最高位必须是“110”** 子网掩码： 什么是子网掩码 子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。
例如：“192.168.1.1”和子网掩码为“255.255.255.0”的二进制对照。其中，“1”有24个，代表与此相对应的IP地址左边24位是网络号；“0”有8个，代表与此相对应的IP地址右边8位是主机号。
子网掩码的表示方法
①、点分十进制表示法
二进制转换十进制，每8位用点号隔开
例如：子网掩码二进制11111111.11111111.11111111.00000000，表示为255.255.255.0
②、CIDR斜线记法
IP地址/n
例1：192.168.1.100/24，其子网掩码表示为255.255.255.0，二进制表示为11111111.11111111.11111111.00000000
例2：172.16.198.12/20，其子网掩码表示为255.255.240.0，二进制表示为11111111.11111111.11110000.00000000
不难发现，例1中共有24个１，例2中共有20个１，所以n是这么来的。
如何根据IP地址和子网掩码，计算网络地址：
①、将IP地址与子网掩码转换成二进制数。
②、将二进制形式的 IP 地址与子网掩码做“与&amp;”运算。
或 | ：有一个是1，就为1
与&amp;：两个都是1，才为1;两个都为0或者为0和1则都为0
非！：对一个二进制数按位取反，即将0变1，1变0。
异或^：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。
③、将得出的结果转化为十进制，便得到网络地址。
网关：用于不同网络间的通信（类似于路由器的功能） 从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。计算机的网关（Gateway）就是到其他网段的出口，也就是路由器接口IP地址。路由器接口使用的IP地址可以是本网段中任何一个地址，不过通常使用该网段的第一个可用的地址或最后一个可用的地址，这是为了尽可能避免和本网段中的主机地址冲突。 默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ade065eff39677162fddd1748ee631/" rel="bookmark">
			驱动api_一个硬件工程师说：RF 数据转换器软件驱动真的很简单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Keith Lumsden
在我的职业生涯中，我一直从事模拟和混合信号系统、FPGA 架构、I/O 和信号完整性方面的工作。 所以我真的是一个搞硬件的人，让我有时有一点负罪感的是我曾认为嵌入式软件适合其他人来做。
随着射频 (RF) 数据转换器的问世，情况发生了变化。我们现在已经将世界一流的 RF ADC 和 DAC 集成到 Zynq UltraScale +架构中了。因此，传统的射频和模拟工程师不可避免地以前所未有的方式接触到了嵌入式系统。
射频数据转换器解决方案 如果您对数据转换器解决方案很熟悉，那您就会知道它是以 IP 核的形式被封装到 Vivado Design Suite 中的。这让您可以通过赛灵思提供的软件驱动来管理射频模数转换器 (RF-ADC) 和射频数模转换器 (RF-DAC) 块的状态和控制。
《Zynq UltraScale + RFSoC RF 数据转换器 IP 产品指南》(PG269) 提供了有关此 IP 的所有详情，并且还提供了有关该驱动的详细附录。
开始在 RF-ADC 和 RF-DAC 上进行调试
RF 分析仪工具是一个不错的起点。
RF 分析仪是基于 MicroBlaze™ 的设计，具有通信层，可以部署到任何电路板上的任何器件上。它还带有一个 GUI，让您可以将 RF-ADC 接收的内容可视化，并可通过 RF-DAC 来实现激励生成和发射函数。至关重要的是，该应用是通过软件驱动构建的。
如果您试图追踪 RF 系统中的问题，RF 分析仪非常强大，而且由于它独立工作，不依赖于设计或电路板，因此可以用来验证系统的 RF 部分。
一个常见的用例是您希望在系统中调试 RF-ADC 和 RF-DAC，并需要编写一个小应用以在运行时进行测试。鉴于 RF 分析仪和定制设计都需要使用软件驱动，我决定编写一个博客帮助您了解驱动，并展示一下如何开始用它来进行调试。在下一个博客中，我会展示一次拆箱，带您一起来看看 RF 分析仪工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33ade065eff39677162fddd1748ee631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5fbc387f20ed67247a57322f83ac5f0/" rel="bookmark">
			python 添加图片_python怎么导入图片？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python导入图片的方法：
一、直接从源图片中导入（图片位于images文件夹内）self.label1=QLabel(self)
self.label1.setPixmap(QPixmap(r"images/head.jpg"))
layout.addWidget(self.label1)
#或者 layout.addWidget(QLabel(self, pixmap=QPixmap("images/head.jpg")))
二、利用qrc资源导入
1、先写qrc文件
images/head.jpg
images/body.jpg
2、将qrc文件转化成py文件
转化命令为：pyrcc5 res.qrc -o res_rc.py
3、导入res_rc.py：import res_rc
4、layout.addWidget(QLabel(self,pixmap=QPixmap(":/images/head.jpg")))
注意需要添加:/符号作为前缀。
更多Python知识请关注Python自学网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40a246842e08da6229d999739082060/" rel="bookmark">
			asp.net 安装element ui_vue项目中引入element组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、全局安装element-ui
npm install element-ui --save
有淘宝镜像的情况下cnpm install element-ui --save 或者cnpm install element-ui -S
二、在main.js文件中加入以下内容，这样就可以全局使用；
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
Vue.use(ElementUI)
三、直接在.vue文件中引入element中的组件
例如弹框：
&lt;template&gt;
&lt;el-button type="text" @click="open" style="color:red;fontSize:30px;"&gt;点击where&lt;/el-button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
methods: {
open() {
this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {
confirmButtonText: '确定',
cancelButtonText: '取消',
type: 'warning'
}).then(() =&gt; {
this.$message({
type: 'success',
message: '删除成功!'
});
}).catch(() =&gt; {
this.$message({
type: 'info',
message: '已取消删除'
}); });
}
}
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40a246842e08da6229d999739082060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c3c0f3e8b96e8fec4052f745ba404e/" rel="bookmark">
			word排版插件_8款堪称神器的Office插件，让你工作效率直线飙升！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，各位叨友们好呀！我是叨叨君~
上班了，上班了，打开电脑又要和PPT/Word/Excel软件打交道了，是不是感觉工作效率有点低呢？今天给大家推荐8款超实用的Office插件，让你工作效率直线飙升！
一、Word插件
1.小恐龙公文排版助手
这是一款免费实用的Word文档排版插件，下载安装后这款插件就会内嵌在 Word 软件中，不用打开额外的软件，使用起来非常方便。
可以对文章排版进行自动优化，包括中文缩进、断行重排、删除空格/空行、中英文间添加空格、中英文标点符号转换等。而且要是有需要的话，插件还能帮我们按照国家公文排版标准进行排版。
2.文驰 Word 自动排版大师
文驰Word自动排版大师也是一个能帮我们对Word文档进行排版的Word插件，虽然它的外表给人感觉很弱，但其实它的功能可是非常强大的，不仅能帮我们一键完成排版，而且还能帮我们调整段落、字体大小等等。
二、Excel插件
1.方方格子
这是一款功能强大Excel插件工具，操作简单，支持撤销，还支持DIY工具箱，极大的加强了Excel功能，可以大大提高办公效率。它有上百个小功能可以使用，包括文本处理、批量录入、删除工具、合并转换等等。DIY工具箱也有很多实用的功能，包括快查快录、身份证工具等等。
我们可能经常会碰到一些汉字、字母、数字混合的情况，需要提取出其中的某一类型的字符时，比如英文字母和数字，就可以这么简单！关于文本处理，里边还有很多高级的黑科技呢，几乎能满足所有的日常需求。
2.EasyCharts
office自带的excel图表功能非常有限，做出的图表也都很死板。这款插件能很好的解决这个痛点。如图所示，多种模板，图示可以通过easycharts在excel中实现。助力做出直观清晰的图表！
3.Excel易用宝
尽管Excel的功能无比强大，但是在很多常见的数据处理和分析工作中，需要灵活的组合使用包含函数、VBA等高级功能才能完成任务，这对于很多人而言是个艰难的学习和使用过程。
针对Excel用户在数据处理与分析过程中的多项常用需求，Excel易用宝集成了数十个功能模块，从而让繁琐或难以实现的操作变得简单可行，甚至能够一键完成。
比如，在浏览超出屏幕范围的大数据表时，只要单击一下Excel易用宝“聚光灯”按钮，就可以用自己喜欢的颜色高亮显示选中单元格/区域所在的行和列，效果如下图所示。
三、PPT插件
1.islide
听我的，经常做PPT的朋友，一定要下载这个插件！islide功能太多太多，这是一款学习成本低，制作效果好的ppt神器！
它支持的功能包括：PPT模板、一键优化、设计排版、主题库色彩库、图示库、智能图表、图片库、图标库、PPT拼图、PPT瘦身等等多种功能。
2.PA口袋动画
PA口袋动画是一款基于PowerPoint的PPT动画编辑插件。插件涵盖片头片尾、图表等多种场景的动画。一键下载，修改替换即可完成一版酷炫的PPT。除此之外，插件还包含庞大的素材模板库，支持批量下载、批量替换，帮你实现小白一秒变大神。
3.PPT美化大师
PPT美化大师有海量的免费在线模板、图标、图表素材，大家可以和iSlide补充使用，另外也有一些其他插件具有的一些功能，比如矩阵、圆形复制，批量删除动画，切换以及批注，还可以替换字体和设置行距，以及内容规划。
4.办公资源网
这不是一个PPT插件，这是一个拥有海量PPT模板素材的网站，如果做PPT对你来说真的不是件容易的事情，那就实行拿来主义吧！找个好看的PPT模板，一键下载，直接套用，省时省力，只要结果是好的，过程有时候也没那么重要啦~
好了，以上就是我为大家推荐的8个Office插件。最后，插件不建议下载太多，容易有冲突且打开软件速度慢，挑适合自己的下载使用即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5122f9f4f841399326fbed284305b369/" rel="bookmark">
			matlab牛顿法_数值优化（Numerical Optimization）(3)-牛顿法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3基本牛顿法
牛顿法的基本思想是用迭代点的梯度信息和二阶导数对目标函数进行二次函数逼近，然后把二次函数的极小值作为新的迭代点，并不断重复这一过程，直到求出极小点。
假设函数 的二阶导数 连续，函数 在 处的二阶泰勒展开为 其中 ，求函数的 驻点那就是求导并令 导数为零，即 如果二阶导数非奇异，可以得到下一个迭代点为（上式求出来的 就是 ） 如果二阶导数奇异，那么可以求解下面线性方程确定搜索方向 后计算下一个迭代点 。 基本牛顿法可以归结为以下四步
初值设置：初始点以及终止准则检验是否满足终止准则 计算二阶导数，确定搜索方向 : 计算下一个迭代点 ，回到步骤2 注意：牛顿法的好处在于收敛速度快，缺点在于计算二阶导数的计算量大以及求解线性方程组确定搜索方向可能是病态的。
修正牛顿法 最基础的改进是在基本牛顿法中加入线搜索方法求得步长 且令 ，这种方法称为 阻尼牛顿法。 牛顿法面临的一个主要困难是二阶导数不正定，在这一情况下，下降方向就很难获得。Goldfeld 修正法在二阶导数不正定时对其进行修正
其中 为修正阵。 带有线搜索的修正牛顿法可以表述为
输入：初始点，终止阈值
循环：
找到修正阵 使得 正定 求解线性方程组 得到下降方向 线搜法计算步长 更新迭代点 可以看到修正阵 的选择对算法起关键作用，针对这个有不少修正的方案，这里简要介绍一下 基于 Cholesky 分解法的思想，这种算法在对二阶导数矩阵分解过程中调整对角元使得修正后的二阶导数充分正定，也就是说在矩阵的 分解中， 的对角元不小于某一个给定常数；并且如果原矩阵正定，那么修正后的二阶导数矩阵也是就原矩阵。 Ps: 信赖域牛顿法在上一篇博文仿真案例用的就是了，感兴趣的可以去看一下。
养生的控制人：数值优化（Numerical Optimization）(2)-信赖域法​zhuanlan.zhihu.com 拟牛顿法 拟牛顿法的思想是模拟牛顿方向的生成路径，利用相邻两个点的位移和一阶导数信息构造与二阶导数阵相似的正定矩阵。所需的计算量比牛顿法少，收敛速度达到超线性。
假设函数 二次连续可微，在 的二次近似为 对上式两边求导可得
如果令 可得 等价于
假设二阶导数矩阵的逆矩阵 近似为 满足 上式也称为拟牛顿方程，可以看到 和迭代点的 位移 和 梯度差 决定。 DFP 下面介绍一下第一个拟牛顿法，DFP算法，算法中假设 由 修正得到，且修正矩阵为秩二矩阵 根据假设 以及拟牛顿方程可以得到 其中 为位移， 为梯度差。这里 的选择并不是唯一的，可以取 ，则 因此有
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5122f9f4f841399326fbed284305b369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e901d14dfd23fcb4adedbb2b779ad0c/" rel="bookmark">
			脑机接口全球Top20实验室信息与概括（有空更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脑机接口前沿Top20实验室信息与概括（更1，有空再更新） 个人看过一遍并且整理的信息，帮助大家更好地了解脑机接口相关的前沿方向以及各实验室大概在干什么，个人稍微精简概括了一下各项目。
剩下的有空会更
有想补充的实验室请评论，我会补上
信息截止2020/11 university/institutelabweb整体type+评价具体项目/相关领域项目概要havard Cortical Plysiology Laboratory/
lab of dr. sydney cash
https://ca
shlab.mgh
.harvar
d.edu/
非侵入式，基本上是结合医疗方向，
试图了解大脑在正常和病理状态下是如何工作的
Mechanisms of normal cognition at the level of individual neurons and small groups of neurons in the context of widespread brain activity 在大脑活动广泛的背景下，
单个神经元和小群神经元水平的正常认知机制
其一子课题为直接解码代表语言语义基础的神经活动 The physiology and importance of sleep and dreaming 睡眠生理学睡眠和做梦的生理学和重要性
人类大脑皮层中睡眠的一些特征性节奏和元素是如何产生的 The basic physiology of cortical and subcortical oscillations 皮质和皮质下振荡的基本生理学
大脑的振荡和有节奏的活动，在睡眠和做梦过程中以及在正常
的认知活动中都明显表现出来，构成主动认知的一部分，会涉及癫痫
The physiological mechanisms of seizures and how they can be better treated.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e901d14dfd23fcb4adedbb2b779ad0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e01a23cf7729afbe1f6b7f10bf60483/" rel="bookmark">
			git设置代理_开源社区驱动的轻量级Git代码托管解决方案——Gitea
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Gitea 是一个开源社区驱动的跨平台轻量级代码托管解决方案，后端采用 Go 编写，采用 MIT 许可证，这个项目自2016年以来一直 从Gogs 分支出来， 但改变了很多，关于这个我不予置评，但是开源社区是充满活力与生机的，百花齐放，动力更足。
功能特性 支持活动时间线支持 SSH 以及 HTTP/HTTPS 协议支持 SMTP、LDAP 和反向代理的用户认证支持反向代理子路径支持用户、组织和仓库管理系统支持添加和删除仓库协作者支持仓库和组织级别 Web 钩子(包括 Slack 集成)支持仓库 Git 钩子和部署密钥支持仓库工单(Issue)、合并请求(Pull Request)以及 Wiki支持迁移和镜像仓库以及它的 Wiki支持在线编辑仓库文件和 Wiki支持自定义源的 Gravatar 和 Federated Avatar支持邮件服务支持后台管理面板支持 MySQL、PostgreSQL、SQLite3, MSSQL 和 TiDB(实验性支持) 数据库支持多语言本地化(21 种语言) 搭建步骤 本地测试环境(其他环境请参考官网文档)： 操作系统：Windows10 1903版本
Go语言版本：V1.12.5(如果你只是搭建的话，并不需要，Go语言环境只是为了你能够自己构建)
安装步骤： 1、从官网下载二进制文件下来
https://dl.gitea.io/
我这里下载的是1.8.2版本
2、直接双击下载好的二进制文件即可启动
这个时候我们就可以打开浏览器了http://127.0.0.1:3000/，然后你就能看到初步搭建成功的启动页面
但是我们发现了一个问题，由于是控制台的，当服务器重启的时候就会需要人为的去打开，因此我们这里准备将它注册成windows服务，注册成windows服务我这里提供两种方式
(1)查看我之前文章中的介绍如何将可执行文件注册成windows服务的工具，而且是可视化的
https://www.toutiao.com/i6685117283867558408/
(2)官方文档中提供了使用windows自带的windows服务注册方式
首先我们将文件重命名成gitea，以便于我们后续操作
第一步：管理员身份运行cmd,然后执行下面的命令(注意自己的文件位置)
sc create giteaService start= auto binPath= ""F:giteagitea.exe" web --config "F:giteacustomconfapp.ini"" 第二步：创建成功后会提示创建成功，然后到windows 的服务中启动服务
如果你想删除服务，执行下面的命令即可
sc delete giteaService PS：如果重启电脑后打开失败，请查看是否是数据库启动失败导致的！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e01a23cf7729afbe1f6b7f10bf60483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9b75e933df2a7e7ae04e30e4255fc7/" rel="bookmark">
			VUE:v-for的使用及源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 v-for可以说是vue中使用最多的指令之一，不过，你真的了解它吗？v-for不仅仅能用于遍历数组，也不仅仅能用于遍历对象。
二、使用 先说结论：v-for可以遍历数组、对象、数字以及字符串，以及，在vue3版本新增的对于部署了iterator接口的对象的支持。下面是各种场景的分析，以(item,index) in obj的使用方式为例：
&lt;div v-for="(item,index) in obj"&gt;&lt;/div&gt; 1.遍历数组
遍历数组时，item是数组的当前项，index是对应的下标
//(item,index) in [1,2,3] // item : 1 2 3 // index: 0 1 2 2.遍历对象
遍历对象时，item是对象键值对的value，index是对应的key
遍历顺序，和Object.keys(obj)、Object.values(obj)的遍历顺序是一样的，即先是数值键，按升序遍历；然后是字符串键，按加入时间遍历；然后是Symbol键，按加入时间遍历
// obj = { // 1: 1, // v: 2, // c: 3, // }; //(item,index) in obj // item : 1 2 3 // index: 1 v c 3.遍历字符串
item是字符串的每个字符，index是对应的下标
// (item,index) in 'abc' // item: a b c // index: 0 1 2 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9b75e933df2a7e7ae04e30e4255fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be453e9b72ba2e68869efbf85e19816/" rel="bookmark">
			g的python实现_使用Gedit打造python集成开发环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直使用sublime来进行python程序的编写，但是在linux系统里，sublime无法输入中文。网上虽然有很多解决方案，但都不完美。近日随意用起debian自带的gedit编辑器，发现其出乎意料的强大，使用自带系统插件就可实现python IDE的功能。下面就说说我如何将这款开源编辑器打造成python的继承开发环境。
IDE无非如下几个功能：1、代码高亮等文本处理；2、代码自动补全；3、自动运行；4、调试功能；5、文件浏览功能
本文操作系统Debian8.8, gedit版本：3.14
实现方式：
1、代码高亮代码高亮等文本处理
首选项中：
2、插件配置
勾选“单词补全”、“文件浏览器面板”、“python控制台”、“嵌入终端”、“外部工具”插件，
效果：
激活“python控制台”、“嵌入终端”、“外部工具”这三个插件之后，可以在“查看——底部面板”打开底部面板，这里可以现实“Tool Output”、“Python Console”、“终端”。
其中“python Console”可以进行python语句的交互式编程。
“终端”可以执行各种命令。
“Tool Output”现实的是“外部工具”插件的执行结果。“外部工具”插件可以执行预设的linux命令和shell脚本，并且可以以快捷键的方式来执行。
选择“manage external tools”，如图，可以新建快捷运行python程序的shell脚本：
#!/bin/sh
EHOME=`echo $HOME | sed "s/#/\#/"`
DIR=$GEDIT_CURRENT_DOCUMENT_DIR
fullname=$GEDIT_CURRENT_DOCUMENT_NAME
name=`echo $fullname`
dir=$GEDIT_CURRENT_DOCUMENT_DIR
gnome-terminal --hide-menubar --working-directory=$dir -t "Terminal-$name" -x bash -c "python $name echo;echo 'press ENTER to continue';read"
快捷键可以自行设置。按快捷键便可自动运行python程序，方便。“manage external tools”这个插件实在强大，有了它几乎可以自定义任何功能了。例如，也可以自行编写PDB模式的shell脚本，方便调试，大家自己试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2e386c349952eb3f6bccd862f77b1c1/" rel="bookmark">
			docker启动_rocketmq 部署启动指南-Docker 版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习使用 rocketmq，需要搭建 rocketmq 服务端，本文主要记录 rocketmq 搭建过程以及这个过程踩到的一些坑。
准备工作 在搭建之前，我们需要做一些准备工作，这里我们需要使用 docker 搭建服务，所以需要提前安装 docker。此外，由于 rocketmq 需要部署 broker 与 nameserver ，考虑到分开部署比较麻烦，这里将会使用 docker-compose。
rocketmq 架构图如下:
另外，还需要搭建一个 web 可视化控制台，可以监控 mq 服务状态，以及消息消费情况，这里使用 rocketmq-console，同样该程序也将使用 docker 安装。
部署过程 首先我们需要 rocketmq docker 镜像，这里我们可以选择自己制作，直接拉取 git@github.com:apache/rocketmq-docker.git ，然后再制作镜像。 另外还可以直接使用 docker hub 上官方制作的镜像，镜像名： rocketmqinc/rocketmq。
接着创建 mq 配置文件 broker.conf，文件放置到 /opt/rocketmq/conf ，配置如下:
brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH # 如果是本地程序调用云主机 mq，这个需要设置成 云主机 IPbrokerIP1=10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2e386c349952eb3f6bccd862f77b1c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b328658131a2c6f8820f780eb4396994/" rel="bookmark">
			套接字（socket）编程简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		套接字（socket）编程简介 现在的网络编程几乎都是用的socket。
我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？
这些都得靠socket！那什么是socket？下面介绍一下socket的相关概念和一些基本函数。
套接字概念 Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。
既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。
在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。
套接字通信原理如下图所示：
在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。
TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。本文的主要内容是socket API，主要介绍TCP协议的函数接口，最后介绍UDP协议和UNIX Domain Socket的函数接口。
应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为**套接字(Socket )**的接口，区分不同应用程序进程间的网络通信和连接。
socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用以下模式来操作
“打开open –&gt; 读写write/read –&gt; 关闭close”
Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。
生成套接字，主要有3个参数：通信的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。
Socket 原意是“插座”。通过将这3个参数结合起来，与一个“插座”Socket 绑定，应用层就可以和传输层通过套接字接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
TCP/IP协议族包括运输层、网络层、链路层，而socket所在位置如图，Socket是应用层与TCP/IP协议族通信的中间软件抽象层
sockaddr数据结构 strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。
sockaddr数据结构：
struct sockaddr { sa_family_t sa_family; //地址结构类型 char sa_data[14]; //地址数据, 14 字节的协议地址，sa_data则包含该socket的IP地址和端口号 }; /*说明： 在实际编程中，一般定义struct sockaddr_in addr， 然后给各个成员赋值，传参数强制转换为struct sockaddr, 例如 (struct sockaddr *) &amp;addr*/ IPv4: struct sockaddr_in (internet), 16个字节
struct sockaddr_in { __kernel_sa_family_t sin_family; //地址结构类型,AF_INET __be16 sin_port; //端口号 struct in_addr sin_addr; //IP地址 /* Pad to size of `struct sockaddr'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b328658131a2c6f8820f780eb4396994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263146c5cc4a84413f02365f51220062/" rel="bookmark">
			lvds屏线接口图解_液晶lvds接口，改屏线，点屏~~液晶电视维修必备知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		液晶lvds接口，改屏线，点屏
点屏配板最难搞的就是屏接口电路了，像背光电路一般都很简单，一般的背光板只要3根线就行了，亮度调节可以不用管它，即电源，地，背光开启信号就行了，大部分都是高电平开启。
LVDS接口是在TTL发展来的
以单六位的TTL接口为例，最少要20多根线，除了电源线外，还有三基色信号线，R0~R5、G0~G5、B0~B5和行场同步HS、VS以及数据使能DE时钟CLK等，屏线数量多，容易受到干扰，所以现在也不是很多了，现在的液晶屏大部分都是LVDS接口。
LVDS是低压差信号，信号电平1v左右，一般是单排的，常见20针和30针，它的数据是成对的。
常见位数有单6位，字母D6L,SI6L表示。单8位，字母D8L,SI8L表示。双6位，字母S6L,D06L表示。双8位，字母S8L,D08L表示。
单6位屏线
双8位屏线
屏供电电压一般有3.3V,5V和12V，一般15寸及以下屏供电为3.3V，17寸~24寸一般为5V，26寸有5V也有12V，26寸以上一般是12V，不过也有例外，这只是大部分，点屏配板时，一般不要轻易不要轻易尝试跳12V屏供电，要不然的话，有可能叫你终生难忘。
那么怎样来区分这个屏接口是单6，单8，还是双6，双8呢，就数它的双绞线来确定，单6位由4对双绞线，单8位有5对双绞线，双6位有8双绞线，双8位有10对双绞线，单6位的4对双绞线有3对数据线和1对时钟线，单8位的5对双绞线有4对数据线和1对时钟线，双6位的8对双绞线有6对数据线和2对时钟线，双8位的10对双绞线有8对数据线和2对时钟线。
一般备货就备单八位的，因为单八位的屏线可以轻松改成单六位的，减掉最后一对数据线就行了，如果用单六位改单八位，就比较难了，如果手头实在没有合适的屏线，就要通过改屏线来解决，改屏线的顺序是双8改双6，双6改单8，单8改单6，一定要注意引脚位置不要搞错，一般的线路板上都有标识。 要是原机屏线是扁排线的那种，也可以通过逻辑板屏接口电路来识别，电源+不用说了，大部分都连着一个保险电阻，地线也不说了，大家都懂得，连接大面积铜箔就是，数据和时钟也好识别的，它们基本都是相邻的，而且都经过一对小电阻进入到芯片内部，而且每对数据线或时钟线的阻值都在100欧附近，所以通过数一下与屏接口相连小电阻的对数，也可以知道这个屏是几位的。
点屏配板不仅要弄清楚屏接口定义，要准确无误的连接，数据线，地线，供电线要一一对应，还要弄清楚屏的分辨率，和屏的尺寸，其中刷程序时最重要的分辨率要对上，有些尺寸不是很重要。
一般只要屏线连接无误，主板程序的屏幕分辨率，位数，合适，大部分都能点亮，但是点亮了，也不一定程序就合适，还要多方面考虑，比如字符，按键功能等，不行的话就再换一个程序。
近期精彩：
1、飞线读写EMMC引导与擦除方法(内含400多款主板点位图)
2、XTW100 编程器 USB 主板路由液晶 BIOS FLASH 24 25 烧录器
3、液晶电视网络主板海思工厂菜单选项详解
点一下在看再走吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f205ed3b62294f5f5227182570a1231b/" rel="bookmark">
			如何用matlab画bode图——自动控制原理基础补充（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画bode图有两种方法，我采用的方法是通过模型生成，也就是通过simulink模型搭建传递函数，在通过matlab自带的工具箱生成bode图。
步骤一：搭建模型。根据所需要的系统搭建传函模型，我认为这种方法是最为直接和方便的，每个环节的传递函数一目了然。 步骤二：打开bode图工具箱。运行一下模型，然后打开如下选项卡。并将信号源选为 Root Level Inputs and Output。也就是调用的数据按照输入输出来。 步骤三：选择bode图。可以看到这里不仅可以选阶跃反应、伯德图、奈奎斯特图等。可以看到我的生成结果为一阶惯性环节 1/0.1s+1的伯德图，截止频率为10rad/s，滞后90°。 整理不易，希望大家帮忙点个赞呀~谢谢啦~^_^ 参数整定以及自动控制原理系列文章： 永磁同步电机矢量控制到无速度传感器控制学习教程（PMSM）（一）
如何用matlab画bode图——自动控制原理基础补充（一）
一阶惯性环节的性能分析——自动控制原理基础补充（二）
二阶系统的性能分析（开环相幅和阶跃响应）——自动控制原理基础补充（三）
转速环PI参数整定详解（一）——电机传递函数的来源
转速环PI参数整定详解（二）——转速环各个环节传递函数的来源
转速环PI参数整定详解（三）——转速环开环传函特性及其整定策略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b0254703c44639c3367cfae53b83da/" rel="bookmark">
			ARP攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单介绍 作为安全攻防的菜鸟，今天简单的介绍ARP攻击，经过几次的实验和理解，也算顺利完成了这个简单的攻防实验。
实验过程： 在这里，我用的是：
攻击者：kali
靶机：window xp
这两个软件都是在VMware虚拟机里实现的
结果1：造成靶机window xp无法上网。
结果2：对靶机的IP地址和MAC地址进行绑定，使ARP攻击失效。
首先先对攻击者kali IP地址的查询： 运行：ifconfig 命令
如下图所示：
eth0 的第二行inet：
得知kali的IP地址为：192.168.88.131
#在对靶机window xp进行IP地址和MAC表查询: 运行：ipconfig 命令
如下图：
这里查到window xp的IP地址是：192.168.88.130
default gateway 即默认网关地址：192.168.88.2
继续在window xp中查询默认网关地址对应的MAC地址： 运行： arp -a 命令
如下图所示：
可以得知默认网关地址：192.168.88.2
所对应的MAC地址是：00-50-56-ea-91-30（这是正确的MAC地址，接下来会与受到攻击过后IP地址所对应的MAC地址进行对比）
接下来，关闭window xp的防火墙，在kali中进行ping命令，来检查2个主机是否在同一网段 形式：ping +window xp的IP地址
kali中的代码：ping 192.168.88.130
如下图所示：
这就意味着ping命令操作成功，2个主机在同一网段。
输入：ctrl+c来终止，否则一直ping下去。
在window xp浏览器中输入：http://www.baidu.com发现可以上网
实行ARP攻击： 在kali中输入以下代码形式：
arpspoof -i eth0 -t window xp IP地址 -r IP地址对应的MAC地址
如下图所示：
显示如此，说明正在进行ARP攻击，请不要终止，让它一直攻击着。
在打开window xp 查看MAC表，发现IP地址所对应的MAC已经变化且网站已打不开 如下图所示：
此时发现原IP地址所对应的MAC地址已经变成：00-0c-29-26-1b-ef
则说明ARP攻击成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b0254703c44639c3367cfae53b83da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94dcd3acbc946a897da678dd83eab693/" rel="bookmark">
			weblogic反序列化_从Weblogic原理上探究CVE20154852、CVE20160638、CVE20163510究竟怎么一回事...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多全球网络安全资讯尽在邑安全
目前。网上关于CVE-2015-4852漏洞的资料很多，但是针对CVE-2015-4852漏洞如何修复，修复补丁又是如何生效的却少之又少；而CVE-2016-0638、CVE-2016-3510这两个漏洞又是如何绕过CVE-2015-4852补丁的，则只是在介绍Weblogic系列漏洞时被一句话带过。
CVE-2015-4852、CVE-2016-0638以及CVE-2016-3510，这三个漏洞有着极其相似的地方，其本质就是利用了Weblogic反序列化机制，而官方在修复CVE-2015-4852时，也并未对这个机制进行调整，而仅仅是在此基础上增加了一个关卡：黑名单。
因此，在彻底搞清楚Weblogic反序列化漏洞的原理以及如何修复这个问题之前，很有必要弄清楚Weblogic处理流量中的java反序列化数据的流程。只有清楚了这一点，才能很好的理解如下几个问题：
CVE-2015-4852是如何产生的以及后续是如何修复的？
修复CVE-2015-4852，为何要在resolveClass:108,InboundMsgAbbrev\$ServerChannelInputStream (weblogic.rjvm)处添加黑名单？
CVE-2016-0638、CVE-2016-3510是如何绕过修复？二者的绕过方式有何相同与不同？
Weblogic 反序列化攻击时序 为了搞清楚CVE-2015-4852、CVE-2016-0638、CVE-2016-3510中的种种疑团，我们需要首先来弄明白一些原理性的东西，我们先从Weblogic
反序列化攻击时序入手，看看Weblogic是如何从流量中将序列化字节码进行反序列化。
首先贴出一张Weblogic 反序列化攻击时序图
这张图是从我的好朋友廖新喜大佬博客扒下来的，也欢迎大家去读一读他的关于java漏洞的分析文章：
http://xxlegend.com/2018/06/20/%E5%85%88%E7%9F%A5%E8%AE%AE%E9%A2%98%20Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E6%88%98%20%E8%A7%A3%E8%AF%BB/
上图为一张完整的Weblogic反序列化攻击时序图，庞大而且繁杂，不如我们将其拆分开，首先说说Weblogic如何从流量数据取出序列化数据并获取其类对象的过程。
从流量数据到Class对象 首先我们来看一张图：
Weblogic通过7001端口，获取到流量中T3协议的java反序列化数据。从上图中readObject开始，经过流程中的一步步的加工，并最终于上图流程终点处的resolveProxyClass或resolveClass处将流量中的代理类/类类型的字节流转变为了对应的Class对象。
首先我们可以发现：在ObjectInputStream (java.io)中的readClassDesc方法处，存在着分叉点，导致了序列化流量流向了两个不同的分支：其中一些流量流向了readProxyDesc并最终采用resolveProxyClass获取类对象，而另一些则流向了readNonProxyDesc并最终使用resolveClass获取类对象。
readClassDesc是什么？ 从上文来看，流量数据经过readClassDesc并驶入了不同的处理分支。
首先来看一下readClassDesc方法的官方注释：“readClassDesc方法读入并返回(可能为null)类描述符。将passHandle设置为类描述符的已分配句柄。”
如果想理解官方注释的含义，需要扩充一些java序列化的知识：
java序列化数据在流量传输，并不是随随便便杂乱无章的，序列化数据的格式是要遵循序列化流协议。
序列化流协议定义了字节流中传输的对象的基本结构。该协议定义了对象的每个属性：其类，其字段以及写入的数据，以及以后由类特定的方法读取的数据。
字节流中对象的表示可以用一定的语法格式来描述。对于空对象，新对象，类，数组，字符串和对流中已有对象的反向引用，都有特殊的表示形式。比如说在字节流中传递的序列化数据中，字符串有字符串类型的特定格式、对象有对象类型的特定格式、类结构有着类结构。而TC_STRING、TC_OBJECT、TC_CLASSDESC则是他们的描述符，他们标识了接下来这段字节流中的数据是什么类型格式的
以TC_CLASSDESC为例，TC_CLASSDESC在流量中的值是(byte)0x72，在序列化流协议中，当这个值出现后，代表接下来的数据将开始一段Class的描述(DESC=description)，即TC_CLASSDESC描述符(byte)0x72后面的字节流数据为Class类型。通过这些描述符，程序可以正确的解析流量中的序列化数据。
如果对这部分感兴趣，可以参照oracle文档：
https://www.oracle.com/security-alerts/cpuoct2020traditional.html
readClassDesc的功能很简单：读入字节流，通过读取字节流中的描述符来确定字节流中传递数据的类型，并交给对应的方法进行处理。
接下来我们看看readClassDesc的实现
private ObjectStreamClass readClassDesc(boolean unshared) throws IOException {byte tc = bin.peekByte();switch (tc) {case TC_NULL:return (ObjectStreamClass) readNull();case TC_REFERENCE:return (ObjectStreamClass) readHandle(unshared);case TC_PROXYCLASSDESC:return readProxyDesc(unshared);case TC_CLASSDESC:return readNonProxyDesc(unshared); default:throw new StreamCorruptedException(String.format("invalid type code: %02X", tc));}} 从readClassDesc方法的实现可见，readClassDesc中switch语句有5个分支(TC_NULL、TC_REFERENCE、TC_PROXYCLASSDESC、TC_CLASSDESC、default)。
TC_NULL描述符表示空对象引用
TC_REFERENCE描述符表示引用已写入流的对象
TC_PROXYCLASSDESC是新的代理类描述符
TC_CLASSDESC是新的类描述符 那么我们为什么在上文流程图里只画出了其中两处分支(TC_PROXYCLASSDESC、TC_CLASSDESC)呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94dcd3acbc946a897da678dd83eab693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd79891739cdfb9f4e95f3f8fff21761/" rel="bookmark">
			matlab中 repmat 函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、repmat 函数定义 B = repmat(A,n)
B = repmat(A,r1,…,rN)
B = repmat(A,r)
这是一个处理矩阵内容有重复时使用，其功能是以A的内容堆叠在（r1xr2）的矩阵B中，B矩阵的大小由r1r2r3*…及A矩阵的内容决定
B = repmat(A,n) 返回一个数组，该数组在其行维度和列维度包含 A 的 n 个副本。A 为矩阵时，B 大小为 size(A)*n。 B = repmat(A,r1,...,rN) 指定一个标量列表 r1,..,rN，这些标量用于描述 A 的副本在每个维度中如何排列。当 A 具有 N 维时，B 的大小为 size(A).*[r1...rN]。例如：repmat([1 2; 3 4],2,3) 返回一个 4×6 的矩阵。 B = repmat(A,r) 使用行向量 r 指定重复方案。例如，repmat(A,[2 3]) 与 repmat(A,2,3) 返回相同的结果。 二、repmat 函数举例： 举例1：B = repmat(A,n) A=[1, 2; 3, 4]; B = repmat(A,2) 结果：
B = 1 2 1 2 3 4 3 4 1 2 1 2 3 4 3 4 举例2：B = repmat(A,r1,…,rN) A=[1, 2; 3, 4]; B = repmat(A,2,3) 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd79891739cdfb9f4e95f3f8fff21761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b203b29028e21fc78131b41b1d3bdcc/" rel="bookmark">
			python将一列数据转换成向量,在Numpy中将行向量转换为列向量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Let's say I have a row vector of the shape (1, 256). I want to transform it into a column vector of the shape (256, 1) instead. How would you do it in Numpy?
解决方案
you can use the
Example:
In [2]: a = np.array([[1,2], [3,4], [5,6]])
In [5]: np.shape(a)
Out[5]: (3, 2)
In [6]: a_trans = a.transpose()
In [8]: np.shape(a_trans)
Out[8]: (2, 3)
In [7]: a_trans
Out[7]:
array([[1, 3, 5],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b203b29028e21fc78131b41b1d3bdcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3128fbfe53946576299ff1d65807e8/" rel="bookmark">
			c语言贪吃蛇(简易版本含完整代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前引头文件注释部分头文件部分主函数部分实现效果 前引 这个贪吃蛇是在我学完C语言的基本部分 在跟着哈工大的c语言程序设计Mooc课程完了之后做的 因为学完C语言很迷茫 不晓得应该学什么 学校里面的题库感觉刷起来又没有实际我能看到的东西 我认为在阶段性的学习过程中应该找到自己能够看得到的成果 才能刺激自己继续往前进 继续学习 不然很枯燥的学习谁都坚持不下去
这也是在看了视频教程后 自己一步步敲出来的 其实还是建议大家在看懂 了代码后自己实现 因为不要怕自己忘不忘 这又不是理论知识 敲出来的代码就是自己的 一步步的提升 加油qwq
另外 此代码保证可以运行
在这篇博客发布后一年 我需要用这个交大作业时用的还是这个博客的代码
编译无错 依然能够流畅无阻的运行
主要问题部分集中于头文件部分
详情多看一下头文件注释部分
头文件注释部分 这里是head.h头文件 因为可以使主文件看起来更整洁更清晰
因为我用的是code:blocks 头文件的创建是在File-&gt;New-&gt;Class中 然后点击创建就ok了 记得如果想看一下这个代码的实现效果 自己也创建头文件名字是head哦 不然头文件名字匹配不了hhhh 或者大家自己把代码一起copy到主程序里面也可以qwq 还有记得要把cpp给取消掉qwq
头文件创建截图
头文件部分 #ifndef HEAD_H #define HEAD_H #define SnakeMaxLength 20 typedef int bool; #define true 1 #define false -1 //背景布置 //这里解释一下 一个特殊字符实线格子在横列是占两格 //所以空白格子在圈中要以两倍的间隔空格隔开 char MyBackGround[22][80]={ "■■■■■■■■■■■■■■■■■■■■\n", "■ ■\n", "■ ■\n", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca3128fbfe53946576299ff1d65807e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ae482b04c2d9484bb11b053b15b4397/" rel="bookmark">
			看完谷歌大佬的刷题笔记, 我直接手撕了101道 Leetcode 算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，有小伙伴私信我说，“二哥，刷 LeetCode 觉得很吃力，怎么办？”
作为一个贴心接地气的优质博主，这事咱必须得想办法解决啊，于是我就问了很多身边的大牛，他们一致推荐了这份谷歌师兄的 Leetcode 刷题笔记。
这位谷歌师兄当年在美国卡内基梅隆大学攻读硕士学位时，为了准备实习秋招，他从夏天开始整理 Leetcode 上的题目，几个月的时间，刷了几百道题目。
凭借着扎实的基础和长期的勤奋，他很快找到了如愿的工作。
后来，他想啊，自己刷了那么多题，而且对很多题目的解法都有着自己的理解，为什么不把这些题目归纳总结一下，做成一个便于后来者阅读学习的电子书呢？
于是他就把这份 PDF 开源了出来，我仔细看了一下，每一道题的题解都写得非常清楚。
引用他的话来说：
本书分为算法和数据结构两大部分，又细分了十五个章节，详细讲解了刷 LeetCode 时常用的技巧。我把题目精简到了 101 道，一是呼应了本书的标题，二是不想让读者阅读和练习时间过长。
这么做不太好的一点是，如果只练习这 101 道题，读者可能对算法和数据结构的掌握不够扎实。因此在每一章节的末尾，我都加上了一些推荐的练习题，并给出了一些解法提示，希望读者在理解每一章节后把练习题也完成。
从我的直观感受来说，这是一本用心的数据结构算法类书籍，全书总共 143 页篇幅，详细讲解算法的内容有十五个章节。每个章节都是一些重要的知识点，伴有基础讲解和例题介绍，当然，也有一些推荐的练习题。
话不多说，让我们来看一下书的目录：
光看书的目录就觉得非常的震撼，相信你和我一样，都有这种强烈的感受。整本书，我仔细看了一遍，并对书中的一些解题思路和代码进行了校验，确实良心了。
第 7 章是讲动态规划的，这里摘取了一点内容，大家可以看到谷歌师兄对于知识点的讲解是非常透彻且细致的。
从排版上也可以看得出，整本书制作得非常精美。
我把这份 PDF 发给小伙伴后，两个月后，他直呼，“二哥，你太牛逼了，这书贼好，我现在刷 LeetCode 再也不头皮发麻了。”
考虑到更多小伙伴也可能会有这样的需求，我就把这份 PDF 上传到了网盘：
链接:https://pan.baidu.com/s/1ojBerkBfgMFpYcj-JfDKlw 密码:5ttz
GitHub 地址也整理了一份：
https://github.com/itwanger/CSDN-Books
还有 CodeChina：https://codechina.csdn.net/qing_gee/CSDN-Books
顺带把作者的开源地址地址贴一下：
https://github.com/changhub/leetcode_101
觉得不错的小伙伴可以去点个 star，支持一下作者，这样，他付出的劳动成果也得到了最好的回报。
最后，晒一下我最近在读的一些书，你喜欢的话，也可以买起来读一读。
不用先点赞，如果觉得确实不错的话，再来一键三连也是可以的，记得关注我哟，好资源，不错过。静悄悄地蓄能，然后惊艳所有人！
噢哟 ~ 来个赞呗~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cae352e4373ef97487d3ba0aa14be35/" rel="bookmark">
			delphi7无法编译已经使用的单元怎么解决_NVDLA 深度学习推理编译器现已开源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为深度学习设计新的定制化硬件加速器，是件备受广大开发者欢迎的事情，但是如想要这种新的设计能够同时实现最先进的性能和效率，却是一项复杂且具有挑战性的难题。
两年前，NVIDIA为NVIDIA深度学习加速器（NVIDIA Deep Learning Accelerator，简称：NVDLA）的硬件设计开源代码，以帮助推动在定制化硬件设计中采用高效的AI推理。同样的NVDLA也被移植在NVIDIA Jetson AGX Xavier开发工具包中，为AI提供了最佳峰值为7.9 TOPS/W的效率。随着NVDLA在GitHub上的优化编译器的开源发布，系统架构师和软件团队现在已经拥有了世界上第一个完全开放的软硬件推理平台的完整源代码。
本文将解释网络图形编译器在实现专用硬件加速器的电源效率这一关键目标中所扮演的角色，并展示如何通过在云端构建和运行用户自己的自定义NVDLA软件和硬件设计开始。
NVDLA Block Diagram 使用NVDLA进行目标检测 NVDLA编译器的性能及效率 该编译器是NVDLA软件栈的关键组件。它生成优化的执行图，将预先训练的神经网络模型层中定义的任务映射到NVDLA中的各个执行单元。它在最大限度地利用计算硬件的同时，尽可能地减少数据移动。
NVDLA核心硬件有六个专门的硬件单元，它们可以同时调度，也可以在流水线配置中调度。它还具有小型和大型硬件配置文件。大的配置文件包括先进的功能，如芯片上的SRAM接口和附加一个微控制器的能力。硬件架构是模块化的，它的设计具有可拓展性，从小型嵌入式物联网设计到使用NVDLA单元阵列的大型数据中心类芯片。编译器可以根据各种选择的因素进行调优：NVDLA硬件配置、系统的CPU和内存控制器配置，以及应用程序的自定义神经网络用例(如果需要的话)。
NVDLA Small Profile Model 编译器优化，如层融合和管道调度工作良好的大型NVDLA设计，提供了高达3倍的性能效益，跨广泛的神经网络架构。这种优化灵活性是实现跨大型网络模型(如ResNet-50)和小型网络模型(如MobileNet)的能效的关键。
对于较小的NVDLA设计，编译器优化(如内存平铺)对于提高能效至关重要。内存平铺使设计能够在权重和激活数据之间平衡片上缓冲区的使用，从而最小化片外内存流量和功耗。
此外，用户可以自由地创建完全定制的层，根据他们自己的特殊用例进行调优，或者使用研究中发表的最新前沿算法进行实验。
用户可以根据下面的性能数字来评估默认NVDLA大概要模型的预期性能。该数据结果是使用Jetson AGX Xavier开发工具包上的两个NVDLA核心之一获取的。
在AWS上使用RISC-V和FireSim在云端进行设计 通过这个编译器版本，NVDLA用户可以完全访问集成、增长和探索NVDLA平台所需的软件和硬件源代码。开始的最佳方法之一是直接使用NVDLA上的YOLOv3和云中的RISC-V和FireSim进行对象检测。
要使用FireSim- nvdla，请按照FireSim的说明操作，直到能够运行单节点模拟为止。按照步骤操作，在“设置FireSim Repo”一节中，验证您正在使用firesim-nvdla 存储库，如下所示：
git clone https://github.com/CSL-KU/firesim-nvdla cd firesim-nvdla ./build-setup.sh fast 使用NVDLA运行单节点模拟之后，按照NVDLA教程中的步骤运行YOLOv3，你应该很快就可以运行YOLOv3了。
NVIDIA很高兴能与SiFive这样的初创公司合作，提供开源的深度学习解决方案。
SiFive使用NVDLA运行深度学习推理 SiFive CTO、联合创始人，及 RISC-V联合发明者Yunsup Lee表示：“我们非常高兴看到NVIDIA在开发开放源代码机器学习生态系统方面的所做出的贡献。一年前，SiFive首次展示了在SiFive Freedom平台上运行的NVDLA，新的性能优化开源NVDLA编译器进一步使SiFive能够创建特定领域的优化SoC设计，以满足物联网边缘AI的现代计算需求。”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c6c0c5879bc4c2961cd014b9ea21e9/" rel="bookmark">
			C# 使用 WebBrowser 编写一个简易的网页客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、创建项目二、窗体设计三、代码编写四、总结五、参考资料 用C#完成一个简易图形界面的基于 HTTP 协议的浏览器客户端软件。
编译环境：Windows 10
编写工具：Visual Studio 2019
编写语言：C#
一、创建项目 打开 VS2019，点击 “ 创建新项目 ”。 选择 C# 的 “ Windows 窗体应用 ”，然后点击 “ 下一步 ”。 输入项目名称，选择保存路径，然后点击 “ 创建 ”。 创建完毕如下图： 二、窗体设计 添加 MenuStrip 控件到窗口中，作为菜单栏，并添加如下的下拉选项。 有一点需要注意，记得更改控件 ID ，不能含中文。 添加 ToolStrip 控件到窗口中，作为工具栏，如图所示： 然后添加一些工具项。 添加 StatusStrip 控件到窗口中，作为状态栏。 添加一个 StatusLabel（文本内容：当前状态）。 添加 WebBrowser 控件到窗口中，作为网页的显示界面。 大致的界面就设计完成，如果还需要细微调整的，可以自行调整。 三、代码编写 说明：
一、按钮类的控件，可以双击后转到代码编辑区；
二、如果出现部分红色波浪线的部分，可以点击 “ 显示修补程序 ” ，这是由于没有定义。
using System; using System.Collections.Generic; using System.Collections.Specialized; using System.ComponentModel; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c6c0c5879bc4c2961cd014b9ea21e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c421a543c2a9972acbc836e95d7de335/" rel="bookmark">
			centos 忘记root密码_CentOS7忘记root密码该怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很多时候在使用CentOS7的时候会因为使用多个用户名而导致忘记root密码，那么应该如何找回或者修改密码呢？
方 法/ 步骤 1
首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面。如图：
2
接着，进入编辑界面，使用键盘上的上下键把光标往下移动，找到以““Linux16”开头内容所在的行数”，在行的最后面输入：init=/bin/sh。如图：
3
接着，输入完成后，直接按快捷键：Ctrl+x 进入单用户模式。如图：
4
接着，在进入新的编辑界面中，在最后面输入“ls”，完成后按键盘的回车键(Enter)。如图：
5
接着，在光标闪烁的位置中(最后一行的位置)输入：mount -o remount,rw /(注意：mount与－o之间有空格以及rw与/之间也有空格，不能省略)，完成后按键盘的回车键(Enter)。如图：
6
接着，在新的一行最后面输入：passwd， 完成后按键盘的回车键(Enter)。如如图;
7
接着，在弹出的内容中就是修改密码的操作了，在光标闪烁的位置输入新的密码(密码在输入的时候是不显示的，就像没反应一样，只需要记住自己输入的密码是正确的就可以了，密码必须是不少于8位，否则会修改失败)， 完成后按键盘的回车键(Enter)。如图：
接着，再一次输入刚输入设置的密码。如图：
接着，密码修改成功后，会显示passwd.....的样式，说明密码修改成功。如图：
接着，在鼠标闪烁的位置中(最后一行中)输入：touch /.autorelabel(注意：touch与 /后面有一个空格)，完成后按键盘的回车键(Enter)。如图：
接着，继续在光标闪烁的位置中，输入：exec /sbin/init(注意：exec与 /后面有一个空格)，完成后按键盘的回车键(Enter)。如图：
接着，等待系统自动修改密码，完成后，系统会自动重启。如图：
接着，系统自动重启成功后，点击登陆界面中的“未列出”。如图：
接着，在弹出的用户名中输入：root账户。点击“下一步”。如图：
接着，在弹出的输入密码界面中，输入刚设置好的新密码，完成后点击“登录”。如图：
接着，登录成功后，界面会提示上一次登录的详细信息，成功登录后，进入系统打开终端，能够正常使用了，说明密码修改成功说明密码修改成功了。如图：
以上就是CentOS7忘记root密码教程。
蜂巢超算
为HPC提供澎湃动力！
400-993-0036
长按关注 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/635de5bb535988dbc40a8415b3ad7472/" rel="bookmark">
			centos7 访问php页面显示源码_7、Linux云计算系列CentOS7网络服务—LNMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux第十七章实验报告
一、准备工作
1. 环境要求：
操作系统：CentOS 7.X 64 位
关闭 SELinux 和 iptables 防火墙
此次试验环境使用网络 yum 源，保证系统能正常连接互联网
2. 网络 yum 源：
先将系统自带的 yum 配置文件移除或者删除，然后下载以下两个配置文件
官方基础：
http://mirrors.163.com/.help/CentOS6-Base-163.repo
http://mirrors.aliyun.com/repo/Centos-6.repo
epel 拓展：http://mirrors.aliyun.com/repo/epel-6.repo
下载完成后，需要使用命令清除掉原有的 yum 缓存，使用新的配置文件建立缓存
# yum clean all #清除掉原有缓存列表
# yum makecache #建立新的缓存列表
# yum update #将所有能更新的软件更新(非必选)
3. 安装编译工具和依赖软件包：
yum -y install gcc* pcre-devel openssl openssl-devel zlib-devel ncurses-devel cmake bison libxml2-devel libpng-devel
4. Nginx、MySQL、PHP 三大软件的源码包下载地址：
Nginx：http://nginx.org/en/download.html
MySQL：https://dev.mysql.com/downloads/mysql/
PHP：http://www.php.net/
版本选用：
Nginx：1.12.* #选用软件的稳定版即可
Mysql：5.5.* #5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/635de5bb535988dbc40a8415b3ad7472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b35119f0d0309ddf2535238e56d403/" rel="bookmark">
			canny算子_紫光同创PGL22G开发平台试用连载（3）——驱动OV5640 摄像头实现sobel算子边缘检测算法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过近一个月的学习，紫光同创PGL22Gfpga已经和spartan6和kintex7不相上下了，紫光EDA生态也趋于完善。EDA是FPGA皇冠上的明珠。FPGA更大的逻辑规模和更高的性能，意味着指数级增长的软件算法复杂度。Pango Design Suite是紫光同创基于多年FPGA开发软件技术攻关与工程实践经验而研发的一款拥有国产自主知识产权的大规模FPGA开发软件，已经可以支持数千万门级FPGA器件的设计，并可实现从RTL综合到配置数据流生成下载的全套操作，形成了完全自主知识产权的FPGA开发工具套件，更适合国内研发需要，某些方面比Altera 和Xilinx公司Quartus II Vivado和ISE更加人性化。
边缘检测算法是图像处理中最为基本的问题。其目的是标志图像出亮度变化明显的点，从而反映出图像中重要变化。边缘是图像最基本的特征，其在计算机视觉、图像分析等应用中起着重要的作用，这是因为图像的边缘包含了用于识别的有用信息，是图像分析和模式识别的主要特征提取手段。在图像中，“边缘”指的是临界的意思。一幅图像的“临界”表示为图像上亮度显著变化的地方，边缘指的是一个区域的结束，也是另一个区域的开始。“边缘点”指的是图像中具有坐标[x,y]，且处在强度显著变化的位置上的点。常用的边缘检测算法大多是以原始图像灰度值为基础,通过考察图像的每个像素的某个邻域内灰度的变化,利用边缘一阶或二阶导数的规律来检测边缘。
实现边缘检测有很多不同的方法，也一直是图像处理中的研究热点，人们期望找到一种抗噪强、定位准、不漏检、不误检的检测算法。边缘检测算子，一阶：Roberts Cross算子，Prewitt算子，Sobel算子， Kirsch算子，罗盘算子；二阶：Marr-Hildreth，在梯度方向的二阶导数过零点，Canny算子，Laplacian算子。其中 Sobel 算子效果较好，边缘检测算法比较简单，实际应用中效率比 canny 边缘检测效率要高，但是边缘不如 Canny 检测的准确，但是很多实际应用的场合， sobel 边缘却是首选，尤其是对效率要求较高，而对细纹理不太关心的时候。采用 Sobel 的算法来实现视频图像的边缘检测。Sobel 算子是像素图像边缘检测中最重要的算子之一，该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。如下图，Gx和Gy分别是在横向及纵向的灰度偏导的近似值。 为了在一副图像f的(x,y)位置处寻找边缘的强度和方向，所选择的工具就是梯度，向量定义为：
公式
Sobel算法：
1、把图像每三行三列的数据分别乘上算子中对应位置的值再相加。然后进行如下运算，得到相应方向(x和y)的Dx和Dy。
Dx=(a3-a1)+(b3-b1)*2+c3-c1;
Dy=(a1-c1)+(a2-c2)*2+a3-c3;
2、对上面求得的Dx和Dy做平方和的平方根，再取近似值Dx和Dy的绝对值的和得到Dxy：
Dxy=Dx2+Dy2=(∣Dx∣+∣Dy∣)Dxy = \sqrt{Dx^2+Dy^2} =(\left|Dx\right|+\left|Dy\right|)Dxy=Dx2+Dy2=(∣Dx∣+∣Dy∣)
3、如果Dxy的值大于一个阈值，表示该点为边界点，就让VGA显示一个白点，否则显示黑点。
4、把计算的结果通过vga显示，显示器会把是边界点的以白色像素显示，不是边界点的以黑色像素点显示，于是得到了一幅图像的轮廓。
sobel 算法的实现，首先需要一个 3x3 的像素窗口，本实验利用 xilinx 提供的VHDL 程序，做了一个 3 行的图像缓存，这样就可以轻松实现 3x3 的窗口。
然后按照简化公式，采用绝对值的方式计算 sobel。
架构
module sobel (
input rst,
input pclk,
input[7:0] threshold,
input de,
input[7:0] data_in,
output reg[7:0] data_out
);
reg[7:0] p11,p12,p13;
reg[7:0] p21,p22,p23;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b35119f0d0309ddf2535238e56d403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a32a8e73675af89efdb650bd12e0db7/" rel="bookmark">
			香港攻略 之 首次初次第一次去香港需要注意什么准备什么（仅供参考）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		香港攻略 之 首次初次第一次去香港需要注意什么准备什么（仅供参考） 目录
香港攻略 之 首次初次第一次去香港需要注意什么准备什么（仅供参考）
一、简单介绍
二、可提前准备或者注意事项
1、根据去香港的目的，旅游、工作或者学习等，可提前办理好对应的港澳通行证
2、办理好往来港澳通行证，如果是工作等，就还可以提前预约办理香港身份证，有了香港身份证，就可以更方便的在香港放浪的嗨了
3、通讯，提前开通手机的香港漫游（旅游的话，通话或者流量叠加包什么的），工作的话，必要可以办张香港的电话卡
4、交通，可以提前购买八达通，地铁巴士都会有优惠，而且便捷
5、港币，去香港为了方便，手上建议准备些港币，购物交通以防不时之需（虽然香港的很多商家都欢迎使用人民币付款）
6、转换接头，如果带电子设备去香港，或者长久呆在香港，电子设备是国内的话，由于香港的插头插座和国内的不同，建议可以提前准备转换接头，以防不时之需
7、在拿到香港临时身份证后（没有的话就港澳通行证），一定养成出门随身携带的习惯，警察有可能查证身份，虽然很少碰上，但带身份证会免去很多麻烦
8、香港的高校是全部开放的，任何人在任何时间都可以自由出入校门，方便的话可以去各大高校参观一下
9、在香港留学生活，居民普遍有良好的排队习惯，来香港后千万不要加塞，遇到可能排队的地方先看看是否有人站在旁边排队，以免出现洋相
10、香港电脑，手机等电子产品的价格都比内地便宜，随着人民币的不断升值，此优势越加明显，可以考虑赴港购买
11、目前香港很多地方支持支付宝和微信付款，如果没有兑换港币和没有境外信用卡或者银行卡，可以使用支付宝和微信先
12、Google Map。建议在香港使用谷歌地图作为导航软件，一般能很快的找到目的地哈
13、找便宜的房子或者二手家具
附录：
1、香港可以点外卖（例如特殊时期：疫情期间）
2、天猫超市可以送货到香港。香港的日常用品还是消费较高的，可以考虑到天猫超市买国内的价格实惠的商品，天猫超市送货香港，可以省不少哦
一、简单介绍 香港（Hong Kong），简称“港”（HK），全称中华人民共和国香港特别行政区，位于中国南部、珠江口以东，西与中国澳门隔海相望，北与深圳市相邻，南临珠海市万山群岛，区域范围包括香港岛、九龙、新界和周围262个岛屿，陆地总面积1106.66平方公里，海域面积1648.69平方公里。截至2019年末，总人口约752万人，是世界上人口密度最高的地区之一，人均寿命全球第一。
香港是一座高度繁荣的自由港和国际大都市，与纽约、伦敦并称为“纽伦港”，是全球第三大金融中心，重要的国际金融、贸易、航运中心和国际创新科技中心，也是全球最自由经济体和最具竞争力城市之一，在世界享有极高声誉，被GaWC评为世界一线城市第三位。 香港是中西方文化交融之地，把华人智慧与西方社会制度的优势合二为一，以廉洁的政府、良好的治安、自由的经济体系及完善的法治闻名于世，有“东方之珠”、“美食天堂”和“购物天堂”等美誉。
物品们去香，无非旅游、工作和学习等，那么去香港前需要准备写些什么，或者注意些什么呢，这里以个人的经历简单介绍一下，如有不对，欢迎指出，谢谢指教哈。
二、可提前准备或者注意事项 1、根据去香港的目的，旅游、工作或者学习等，可提前办理好对应的港澳通行证 （例如：旅游 的 7天旅游签，工作一般2年的 多次逗留工作签等）
2、办理好往来港澳通行证，如果是工作等，就还可以提前预约办理香港身份证，有了香港身份证，就可以更方便的在香港放浪的嗨了 （预约网址：https://www.gov.hk/tc/residents/immigration/idcard/hkic/bookregidcard.htm）
3、通讯，提前开通手机的香港漫游（旅游的话，通话或者流量叠加包什么的），工作的话，必要可以办张香港的电话卡 （
1）流量叠加包什么的可以去营业厅（可以提前电话咨询下），也可某付宝帮忙开通；
2）可以到某宝上购买，不急的话也可以先开通几天的漫游，再到香港本地办理电话卡，根据自己需要选择即可）
4、交通，可以提前购买八达通，地铁巴士都会有优惠，而且便捷 （某宝上可以购买，或者某些口岸也有卖，可以过关的时候的购买也行，看个人需要
其实：在香港，你只要拥有一张八达通卡就可以乘坐任何一种交通工具，还可以在很多连锁餐厅(肯德基、麦当劳、 大家乐等)、商店(百佳、惠康、7-11、OK便利店等)进行小额消费。
注意：在香港坐出租车很贵（仅供参考）：起步两公里16HK$，之后每两百米$ 1.5，行李另收费）
5、港币，去香港为了方便，手上建议准备些港币，购物交通以防不时之需（虽然香港的很多商家都欢迎使用人民币付款） （目前国内各大行基本上都可以兑换，或者某些口岸也可以兑换，可以过关的时候兑换也行，根据自己的需要）
6、转换接头，如果带电子设备去香港，或者长久呆在香港，电子设备是国内的话，由于香港的插头插座和国内的不同，建议可以提前准备转换接头，以防不时之需 (当然，本地有些地方也有卖，某些酒店会提供，看个人需要)
7、在拿到香港临时身份证后（没有的话就港澳通行证），一定养成出门随身携带的习惯，警察有可能查证身份，虽然很少碰上，但带身份证会免去很多麻烦 8、香港的高校是全部开放的，任何人在任何时间都可以自由出入校门，方便的话可以去各大高校参观一下 9、在香港留学生活，居民普遍有良好的排队习惯，来香港后千万不要加塞，遇到可能排队的地方先看看是否有人站在旁边排队，以免出现洋相 10、香港电脑，手机等电子产品的价格都比内地便宜，随着人民币的不断升值，此优势越加明显，可以考虑赴港购买 11、目前香港很多地方支持支付宝和微信付款，如果没有兑换港币和没有境外信用卡或者银行卡，可以使用支付宝和微信先 （注意：结账价格会根据实时汇率转为人民币价格的，还是挺好的（以下是KFC 网上的结账方式））
12、Google Map。建议在香港使用谷歌地图作为导航软件，一般能很快的找到目的地哈 （注意：国内的百度和高德在香港好似GPS导航j就不是很准了哈）
13、找便宜的房子或者二手家具 可以微信关注港漂租租，里面有蛮多便宜点的租房，或者离港人士在上面便宜卖二手家具等用品，不过需要上门提取，大家可以上面参考哈，就近最好，因为大型家具香港送货还是蛮贵的
附录： 1、香港可以点外卖（例如特殊时期：疫情期间） （（仅供参考）Foodpanda，E 肚仔，Uber Eats，Eatigo，利園區，Deliveroo 戶戶送等，肯德基，麦当劳也可以
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a32a8e73675af89efdb650bd12e0db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365a0ff6ca724c102f223d6dedd30b9a/" rel="bookmark">
			python怎么一直循环_python 基础之while无限循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户登录程序
username = "chenxi"
passwed = "testki"
counter = 0
while counter &lt; 3: # 测试3次
user = input("输入用户名：")
passw = input("输入密码：")
if user == username and passw == passwed :
print("登录成功")
break #退出
else:
print("重新输入")
counter += 1
测试-1
D:\python\python.exe D:/untitled/dir/for.py
输入用户名：bhghjb
输入密码：njbmnbm
重新输入
输入用户名：bhbjb
输入密码：nnbnbm
重新输入
输入用户名：nnbmnb
输入密码：jhjh
重新输入
Process finished with exit code 0
测试-2
D:\python\python.exe D:/untitled/dir/for.py
输入用户名：chenxi
输入密码：testki
登录成功
打印0-9，小于5不打印
for i in range(10):
if i &lt; 5 :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/365a0ff6ca724c102f223d6dedd30b9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81682836c5708ed6d22950b4880c886/" rel="bookmark">
			使用systemctl restart network 或 service network restart 命令重启网卡失败。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于我使用的是centos8版本的虚拟机，所以这个命令是没有的需要使用：
nmcli c reload 命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2e8c0e73709405264cb74bceec312ab/" rel="bookmark">
			CSS布局：sticky定位  position:sticky
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS布局：sticky定位 position:sticky 转载 https://www.cnblogs.com/byeyear/p/11999334.html
stick定位一如其名：它随“正常”文档流而动，直到规定位置，尔后“粘”在那里；或者，当它发现自己可以跟随“正常”文档流而脱离sticky位置时，就果断离开从而加入文档流。
示例
&lt;div style="height: 200px; overflow:scroll;"&gt; &lt;p style="background-color:lightgrey; position:sticky; top: 0px;"&gt;This is header A&lt;/p&gt; &lt;p&gt;This is content A&lt;/p&gt; &lt;p&gt;This is content A&lt;/p&gt; &lt;p&gt;This is content A&lt;/p&gt; &lt;p&gt;This is content A&lt;/p&gt; &lt;p style="background-color:lightgrey; position:sticky; top: 0px;"&gt;This is header B&lt;/p&gt; &lt;p&gt;This is content B&lt;/p&gt; &lt;p&gt;This is content B&lt;/p&gt; &lt;p&gt;This is content B&lt;/p&gt; &lt;p&gt;This is content B&lt;/p&gt; &lt;p style="background-color:lightgrey; position:sticky; top: 0px;"&gt;This is header C&lt;/p&gt; &lt;p&gt;This is content C&lt;/p&gt; &lt;p&gt;This is content C&lt;/p&gt; &lt;p&gt;This is content C&lt;/p&gt; &lt;p&gt;This is content C&lt;/p&gt; &lt;p style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2e8c0e73709405264cb74bceec312ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f49e6d7cac8c02abbd3bec8547249572/" rel="bookmark">
			(c语言)圣诞树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、前引2、二次编辑3、代码实现（c语言）4、代码实现（python）5、运行效果1、c语言实现效果（codeblocks）1、3层圣诞树（c语言）2、5层圣诞树（c语言）3、6层圣诞树（c语言） 2、python实现效果（pycharm）1、3层圣诞树（python）2、5层圣诞树（python）3、6层圣诞树（python） 1、前引 这是我初学c开始有意识的记录自己做的每一道题开始写下的代码水平 一个一个代码发出来 直到我现在学的数据结构 那个时候还不会注释 格式什么的也是按照自己怎么喜欢怎么来 如果真不会看会代码理解一下 qwq 如代码有错请见谅 毕竟都好久以前敲得了hhh ~~
如果对各位的思路引导有帮助那更好
2、二次编辑 笔者于 2021/12/27 凌晨1：19 刚玩完《赛博朋克2077》 二次编辑 -留
最近可能是由于圣诞节快来临的期间 我的c语言圣诞树 作为可能大一时的自己 在刚学c语言 学了两个星期的我 自己突发奇想想写一个圣诞树 现在我都能记得到 当时熬夜花了半个小时写的 哈哈哈
因为发现浏览量突然的增长 然后也就发现大家留言 说树只出现了一半 因为现在笔者在二次编辑的时候 是大概大二上的最后几个星期了 也就是快要到了考试周 因为对于应付考试的那些学科并不是很感兴趣 并且这段时间也是杂事繁多 没有心思继续学编程 所以就购买了 赛博朋克2077 大概花了4天左右 从早到晚就给通关了 哈哈哈 笔者作为一个编程和游戏迷 对于好游戏 或者对于新技术 还是非常的痴迷的
不是这个原因 就是看到留言说 圣诞树只出现了一半 我上午还在做支线任务的时候 就看到有读者留言了 于是心生疑惑 自己把代码复制了下来 并且运行 结果发现并没有只出现了一半 如下图 层数为6 不太清楚大家是什么原因为什么只有一半
为了核实是否是编译器的问题 笔者用的是codeblocks 但是鉴于笔者电脑没有多的c语言 编译器了 所以笔者又改用python代码 用c语言的代码流 跑了一遍 发现结果是一样正确的 尽管太久太久没用python 代码写的有些许不好看 但是同样也验证了 肯定是可以运行 且结果是正确的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f49e6d7cac8c02abbd3bec8547249572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02034e42663997562bdcc93c0a0d943/" rel="bookmark">
			lambdaquerywrapper查询指定字段_5.MySQL连接查询join，联合查询union
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自己的MySQL阅读笔记，持续更新，直到看书结束。
数据库技术可以有效帮助一个组织或者企业科学、有效的管理数据，也是现在很多企业招聘数据分析师的必备要求之一。
大家如果看过MySQL的书，也可以看我的知识导图做一个复习，因为是自己的读书笔记，所以有的地方也不是很详尽，但是十分欢迎私下交流共同进步。
SQL整理的目录
目录 连接查询 交叉连接自连接外连接联合查询子查询 1.连接查询（join） MySQL连接查询语句join图解
《图解 SQL 里的各种 JOIN》https://mazhuang.org/2017/09/11/joins-in-sql/ 《图解 SQL 里的各种 JOIN》https://mazhuang.org/2017/09/11/joins-in-sql/ 1.1 交叉连接 笛卡尔积，返回两张表每一行相互连接后所有可能的搭配结果
基本语法格式
SELECT 1.2 内连接 1.2.1 等值与非等值连接
基本语法格式
[&lt;表名1&gt;].&lt;字段名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;].&lt;字段名2&gt; 示例
查询会计学院全体同学的学号、姓名、籍贯、班级编号和所在班级名称
SELECT 1.2.2 自连接
表自己和自己连接，使用时要为表指定不同的别名
1.2.3 自然连接
只有当连接字段为两张表中的字段名都相同时才可以使用，否则返回的是笛卡尔积。
实例
NATURAL JOIN 进行连接的时候并不需要指定连接字段
SELECT 1.3 外连接 1.3.1 左外连接
将左表作为基表的连接
SELECT 1.3.2 右外连接
将右表作为基表的连接
SELECT 2.联合查询(union) 使用UNION关键字可以把来自多个SELECT语句的结果组合到一个结果集中。合并时，多个SELECT字句中对应的字段数和数据类型必须相同。
基本语法格式
SELECT 实例
查询选修了“管理学”或“计算机基础”的学生学号
SELECT 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7fb74d49fd1ff949f0322ec796a6e7/" rel="bookmark">
			mysql存储过程返回结果集_面试再问MySQL存储过程和触发器就把这篇文章给他
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql存储过程及触发器trigger 存储过程 一、一个简单的存储过程
1,一个简单的存储过程
delimiter $$create procedure testa()begin Select * from emp; Select * from dept; End;$$;delimiter ;-- 调用存储过程call testa(); 存储过程的结构组成：
1，创建格式:create procedure 存储过程名
2，包含一个以上代码块，代码块使用begin和end之间
3，在命令行中创建需要定义分隔符 delimiter $$
2,存储过程的特点
1，能完成复杂的判断和运算
2，可编程性强，灵活
3，SQL编程的代码可重复使用
4，执行速度相对快
5，减少网络之间数据传输，节省开销
二、存储过程变量
1，存储过程中的变量
需求：编写存储过程，使用变量取empno=7369的用户名
Delimiter $$;Create procedure testa();BEGIN DECLARE my_uname varchar(32) default ""; -- 定义变量my_uname SET my_uname='smith'; -- 为变量my_uname赋值 -- 查询empno=7369的用户名，并将值赋给my_uname select ename into my_uname from emp where empno=7369; -- 为变量赋值 select my_uname;-- 返回my_uname的值END;$$;Delimiter ; 特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c7fb74d49fd1ff949f0322ec796a6e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346ac64833292a3434cfa0b9867852e7/" rel="bookmark">
			bigdecimal不保留小数_Excel用Round函数保留小数与取整及与Average组合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Excel 中，Round函数是一个比较好用的保留小数函数，它会把小数按指定位数保留小数位数、整数自动取整，而不像设置单元格格式保留小数位数，无论是小数还是整数都保留指定小数位数。Round函数保留小数位数分为三种情况，分别为保留指定小数位数、取整和从小数点处向左移位。以下是 Excel Round函数的使用方法，共有五个实例，包含批量给已有公式添加Round保留小数实例，实例操作所用版本均为 Excel 2016。
一、Round函数语法
1、表达式：ROUND(Number, Num_Digits)
中文表达式：ROUND(数字, 保留小数位数)
2、说明：
Num_Digits 为要四舍五入保留的小数位数；如果 Num_Digits 大于 0，把数字四舍五入到指定小数位数；如果 Num_Digits 等于 0，把数字四舍五入到最接近的整数；如果 Num_Digits 小于 0，把数字四舍五入到小数点左边的相应位数。
二、Round函数的使用方法及实例
(一）保留两位小数的实例
1、选中 B1 单元格，输入公式 =round(a1,2)，按回车，返回 5.68；把鼠标移到 A1 右下角的单元格填充柄上，按住左键并往下拖到 B3，则 A2 和 A3 中的数值也实现保留两位小数；操作过程步骤，如图1所示：
图1
2、从 A1 到 A3 三个数字的保留小数位数可知，每个数都按四舍五入的方式保留两位小数。
(二）保留最接近的整数实例
1、双击 B1 单元格，把上例的公式 =round(a1,2) 的 2 去掉，按回车，返回 6；再次双击 B1 单元格，把公式改为 =round(a1,0)，按回车，同样返回 6；用往下拖的方法，把 A2 和 A3 的数字也保留整数；操作过程步骤，如图2所示：
图2
2、从操作可知，当保留整数时，Round函数可以省略 Num_Digits；另外，保留整数也都进行了四舍五入。
（三）四舍五入到小数点左边的相应位数的实例
1、向左移一位
A、双击 B1 单元格，把 B1 中的公式改为 =ROUND(A1,-1)，按回车，返回 570；用往下拖的方法，把 A2 和 A3 都从小数点处往左移一位；操作过程步骤，如图3所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/346ac64833292a3434cfa0b9867852e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76023b2c3f69d8248253b475a1555bcc/" rel="bookmark">
			axure元件_Axure 9——元件库基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天天使用的工具，有些小技巧还是很懵懂...
Axure 中，我们经常使用的就是各种各样的元件，比如：
矩形元件
图片元件
按钮元件
文本框元件
表格元件
图标元件
单选按钮元件等
以上所以元件，都可以通过 Axure的“元件面板”进行集中管理，如下图所示：
多个元件就可以组成一个元件库。
Axure 9 安装时，内置了4个元件库，分别如下：
Default(默认元件库)
Flow(流程元件库)
lcons (图标元件库)
Sample UI Patterns( 示范UI元件库)
但在日常工作中，也需要你定制元件库。这一点，明天详细说明。
今天先说明，元件库基础
添加元件库
市面上已有很多优秀的元件库，你可以直接引用。
此时，可以直接添加第三方元件库。
操作路径为：元件面板—&gt;添加元件库，如下图所示。
然后在文件资源管理器中，找到所要添加的第三方元件库即可。
注意：只有添加第三方元件库之后，才可以进行如下操作：
编辑元件库
打开源目录
移除元件库
如下图所示：
以上操作的路径为：元件面板—&gt;更多选择，如图所示：
获取元件库
在添加已经下载好的，第三方元件库的同时，也可以获取官方的元件库
网址如下：https://www.axure.com/support/download-widget-libraries
不过，官方元件库大部分收费，部分免费，你可根据自己需求来下载。
添加图片文件夹
最后，也是最想强调的就是，你之前所收集的各类图片(如ICON、背景图、截图等)文件夹，也可以导入到 Axure 中，方便直接拖拽使用。
操作路径：元件面板—&gt;添加图片文件夹，如下图所示：
下图，就是我添加图片文件夹之后效果。
同理，当添加图片文件夹之后，也可以进行如下操作：
编辑元件库
打开源目录
移除元件库
最后福利
目前市面上，优秀的第三方元件库如下：
AntD Library http://library.ant.design/
Element https://element.faas.ele.me/#/zh-CN/resource
Axure元件库 - Axure中文网 https://www.axure.com.cn/download/rplib/
等等
如有补充，欢迎留言互动。
今天，只是基础。
明天，将给你分享， 元件库进阶！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31f75ebebdec95e5f7bf4503ac71931/" rel="bookmark">
			pygame.error: video system not initialized的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一些python小白（比如me）经常会遇到一些莫名其妙的错误，很多都是由于不细心造成的。
如果出现错误 – pygame.error: video system not initialized
原因有两个：
没有初始化 pygame.init()
pygame.init()会自动初始化需要初始化的东西，比如font模块等等缩进错误
大家写代码一定要细心哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db81770026235e70bde1345c47565e65/" rel="bookmark">
			python中for怎么无限循环_Python中无限循环有什么条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无限循环
如果条件判断语句永远为 true，循环将会无限的执行下去。
如下实例#!/usr/bin/python
# -*- coding: UTF-8 -*-
var = 1
while var == 1 : # 该条件永远为true，循环将无限执行下去
num = raw_input("Enter a number :")
print "You entered: ", num
print "Good bye!"
以上实例输出结果：Enter a number :20
You entered: 20
Enter a number :29
You entered: 29
Enter a number :3
You entered: 3
Enter a number between :Traceback (most recent call last):
File "test.py", line 5, in num = raw_input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db81770026235e70bde1345c47565e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3363fdee6b649ceff8e7a4a338c36955/" rel="bookmark">
			python 可视化界面_基于Python的量化交易工具清单(下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		—— Python量化工具清单 ——　以下内容来源于Wilson Freitas的Github项目"Awesome Quant"。原文中包含了丰富的语言类别，但是后续介绍主要针对Python语言。原网址：https://github.com/ wilsonfreitas/awesome-quant
本篇主要介绍风险分析,因子分析,时间序列,日历,数据源,Excel集成,可视化相关的Python包。
06
风险分析
Risk Analysis
pyfolio-Python中的投资组合和风险分析。
empyrical-常见的财务风险和绩效指标。
fecon235-金融经济学的计算工具包括：leptokurtotic风险的高斯混合模型，自适应Boltzmann投资组合。
finance-财务风险计算。通过类构造和操作员重载进行了优化，易于使用。
qfrm-定量金融风险管理：很棒的OOP工具，用于测量，管理和可视化金融工具和投资组合的风险。
visualize-wealth-投资组合构建和定量分析。
VisualPortfolio-此工具用于可视化投资组合的绩效。
07
因子分析
Factor Analysis
alphalens-预测性alpha因子的性能分析。
08
时间序列 Time Series
ARCH-Python中的ARCH模型。
statsmodels-Python模块，允许用户浏览数据，估计统计模型和执行统计测试。
dynts-用于时间序列分析和处理的Python软件包。
PyFlux-Python库，用于对模型进行时间序列建模和推理(频率和贝叶斯)。
tsfresh-从时间序列中自动提取相关特征。
hasura / quandl-metabase-Hasura快速入门，可通过Metabase可视化Quandl的时间序列数据集。
09
日历
Calendars
trading_calendars-联交所交易日历。
bizdays-工作日计算和实用程序。
pandas_market_calendars-与Pandas一起使用的交换日历，用于交易应用程序。
10
数据源
Data Sources
chinesestockapi-获取中国股票价格的Python API。
tushare-抓取中国股票历史和实时行情数据的实用程序。
cn_stock_src-用于从不同来源检索中国基本库存数据的实用程序。
pytdx-用于从TongDaXin节点检索中国股票实时报价数据的Python接口。
findatapy-Python库，用于通过Bloomberg，Quantl，Yahoo等下载市场数据。
googlefinance-Python模块，可从Google Finance API获取实时库存数据。
yahoo-finance-从Yahoo!获取股票数据的Python模块金融。
pandas-datareader-Python模块，用于将来自各种来源(Google财经，Yahoo Finance，FRED，OECD，Fama / French，世界银行，Eurostat ...)的数据转换为Pandas数据结构，例如DataFrame，具有缓存机制的Panel。
pandas-finance-用于访问和分析财务数据的高级API。
pyhoofinance-快速查询Yahoo Finance的多个代码，并返回键入的数据进行分析。
yfinanceapi-适用于Python的Finance API。
yql-finance-yql-finance简单快速。API返回当前时间段的股票收盘价和当前股票行情记录(即APPL，GOOGL)。
ystockquote-从Yahoo Finance检索股票报价数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3363fdee6b649ceff8e7a4a338c36955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cfe39a964a71fbbbcd9ec3e36822bef/" rel="bookmark">
			echarts实现GIS可视化——热力图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		热力图介绍 echarts的热力图有两种，一种时按照点元素的权重，还有一种是按照点元素的密度（官网api害死人，一直搞不清为什么要用.concat([1]))
点元素密度案例 看一下热力图实现的案例：
效果图： 示例代码&amp;注释： $.get(ROOT_PATH + '/data/asset/data/hangzhou-tracks.json', function (data) { var points = [].concat.apply([], data.map(function (track) { return track.map(function (seg) { return seg.coord.concat([1]); }); })); myChart.setOption(option = { //是否使用动画 animation: false, //背景地图中心点等基础值 bmap: { center: [120.13066322374, 30.240018034923], zoom: 14, roam: true }, //视觉映射组件 visualMap: { show: false, top: 'top', min: 0, max: 5, seriesIndex: 0, calculable: true, //定义在选中范围中的视觉元素 inRange: { color: ['blue', 'blue', 'green', 'yellow', 'red'] } }, series: [{ type: 'heatmap', //该系列使用的坐标系，可选'cartesian2d'和'geo' coordinateSystem: 'bmap', data: points, //每个点的大小 pointSize: 5, //每个点模糊的大小 blurSize: 6 }] }); // 添加百度地图插件 var bmap = myChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cfe39a964a71fbbbcd9ec3e36822bef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6c564f779b22da4bc42243862fca2b/" rel="bookmark">
			python地图散点图_python – Cartopy：使用散点图数据渲染图层的顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我试图使用Cartopy在地图上绘制几个点(散点图)的位置(参见下面的代码).当我尝试渲染绘图时,数据点将在LAND层后面呈现.但我想在LAND-layer上绘制我的分散数据……我做错了什么？
Cartopy：ver. 0.12.x,Matplotlib：ver.1.4.2
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent([125, 150, 35, 63])
ax.stock_img()
ax.add_feature(cfeature.LAND) #If I comment this =&gt; all ok, but I need
ax.add_feature(cfeature.LAKES)
ax.add_feature(cfeature.RIVERS)
ax.coastlines()
ax.scatter(yc,xc,transform=ccrs.PlateCarree()) #yc, xc -- lists or numpy arrays
plt.show()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3b3b4d08d9591e7f8b72afc7ec136f/" rel="bookmark">
			[已解决] xshell连接不上linux虚拟机，找了无数方法，终于成功了，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题困扰了我很久，一直都没有很好的解决它，导致用虚拟机很不方便，在网上也找了无数的方法。均没有解决我的问题（都要哭了|-_-|~~~），
最终功夫不负有心人，还是让我摸索出来的方法，其实很简单，
解决方法 1 还原虚拟网络的默认设置，完美解决，
步骤如下： 1、关闭所有虚拟机；
2、编辑 &gt; 虚拟网络编辑器
3、还原默认设置。
更改设置 &gt; 还原默认设置
然后问题就得到了完美地解决，不知道是否能解决你的问题。
解决方法 2 如果是NAT模式连接虚拟机，虚拟机可以ping通外网，但是xshell连接不上，
可以在网络适配器中先禁用VMnet8，然后在启用VMnet8，在尝试使用xshell连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca24a1dbc9b0f33989104fe1eb64b54e/" rel="bookmark">
			目标检测新范式！港大同济伯克利提出Sparse R-CNN，代码刚刚开源！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​Sparse R-CNN: End-to-End Object Detection with Learnable Proposals
沿着目标检测领域中Dense和Dense-to-Sparse的框架，Sparse R-CNN建立了一种彻底的Sparse框架， 脱离anchor box，reference point，Region Proposal Network(RPN)等概念，无需Non-Maximum Suppression(NMS)后处理， 在标准的COCO benchmark上使用ResNet-50 FPN单模型在标准3x training schedule达到了44.5 AP和 22 FPS。
代码: https://github.com/PeizeSun/SparseR-CNN
论文链接: https://msc.berkeley.edu/research/autonomous-vehicle/sparse_rcnn.pdf
1. Motivation
我们先简单回顾一下目标检测领域中主流的两大类方法。
第一大类是从非Deep时代就被广泛应用的dense detector，例如DPM，YOLO，RetinaNet，FCOS。在dense detector中， 大量的object candidates例如sliding-windows，anchor-boxes， reference-points等被提前预设在图像网格或者特征图网格上，然后直接预测这些candidates到gt的scaling/offest和物体类别。第二大类是dense-to-sparse detector，例如，R-CNN家族。这类方法的特点是对一组sparse的candidates预测回归和分类，而这组sparse的candidates来自于dense detector。 这两类框架推动了整个领域的学术研究和工业应用。目标检测领域看似已经饱和，然而dense属性的一些固有局限总让人难以满意：
NMS 后处理many-to-one 正负样本分配prior candidates的设计 所以，一个很自然的思考方向就是：能不能设计一种彻底的sparse框架？最近，DETR给出了一种sparse的设计方案。candidates是一组sparse的learnable object queries，正负样本分配是one-to-one的optimal bipartite matching，无需nms直接输出最终的检测结果。然而，DETR中每个object query都和全局的特征图做attention交互，这本质上也是dense。而我们认为，sparse的检测框架应该体现在两个方面：sparse candidates和sparse feature interaction。基于此，我们提出了Sparse R-CNN。
Sparse R-CNN抛弃了anchor boxes或者reference point等dense概念，直接从a sparse set of learnable proposals出发，没有NMS后处理，整个网络异常干净和简洁，可以看做是一个全新的检测范式。
2.Sparse R-CNN
Sparse R-CNN的object candidates是一组可学习的参数，N*4，N代表object candidates的个数，一般为100～300，4代表物体框的四个边界。这组参数和整个网络中的其他参数一起被训练优化。That's it，完全没有dense detector中成千上万的枚举。这组sparse的object candidates作为proposal boxes用以提取Region of Interest(RoI)，预测回归和分类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca24a1dbc9b0f33989104fe1eb64b54e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0bc002a387444746b0928ef57c759a4/" rel="bookmark">
			pom文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于收费的依赖，会 无法直接注入到pom.xml文件中下载，所以只能手动在cmd中操作命令键注入 操作命令如下：
依赖
&lt;dependency&gt; &lt;groupId&gt;com.aspose.words&lt;/groupId&gt; &lt;artifactId&gt;aspose-words-jdk16&lt;/artifactId&gt; &lt;version&gt;15.8.0&lt;/version&gt; &lt;classifier&gt;jdk16&lt;/classifier&gt; &lt;/dependency&gt; 命令
mvn install:install-file -Dfile=D:\wordToPdf\aspose-words-15.8.0-jdk16.jar - DgroupId=com.aspose.words -DartifactId=aspose-words-jdk16 -Dversion= 15.8.0 -Dpackaging=jar -Dclassifier=jdk16 在maven仓库存放目录键入cmd
在黑窗口输入以上命令
即可在本地仓库中下载上述依赖
这辈子坚持与不坚持都不可怕,怕的是独自走在坚持的道路上！！！
吃水不忘跳水人 参考链接
参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6154737f5f7376a1650bada9e04f7c4/" rel="bookmark">
			sql server sql 取各自前几条数据_最强官配：世界上人们最喜欢的数据库&#43;最喜欢的语言...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文共2157字，预计学习时长13分钟 图源：unsplash 几乎每个人都在使用SQL和Python，Python是用于数据分析、机器学习和网页开发的全明星顶级语言，而SQL是数据库的实际标准。如果将两者结合会发生什么呢？
实际上，两者要结合在一起并不难。我们可以快速利用Python的动态特性，控制和构建SQL查询。设置完成后，我们无需执行任何操作。
这两种工具结合之后可谓是最强搭档，自动化和效率都达到了新高度。
pyodbc
连接两种技术的桥梁是pyodbc，该库可以轻松访问ODBC数据库。
ODBC（开放数据库连接的简称）是一种用于访问数据库的标准化应用程序编程接口（API），由90年代初的SQLAccess组开发。兼容的数据库管理系统（DBMS）包括：
· IBM Db2
· MySQL
· Oracle
· MS Access
· MS SQL服务器
本文将使用MS SQL服务器。在多数情况下，该服务器可以直接转移，与任何符合ODBC的数据库都可一起使用。唯一需要更改的是连接设置。
连接
首先，要创建与SQL 服务器的连接，可以通过pyodbc.connect实现。在此函数中，还须传递连接字符串。此连接字符串必须指定DBMS驱动程序、服务器、要连接的特定数据库以及连接设置。
因此，假设要连接到服务器UKXXX00123,45600和数据库DB01，需要使用SQL Server Native Client 11.0。从内部连接使得连接被信任，无需输入用户名和密码。
cnxn_str = ("Driver={SQLServer Native Client 11.0};" "Server=UKXXX00123,45600;" "Database=DB01;" "Trusted_Connection=yes;") 现在，连接已初始化为： cnxn = pyodbc.connect（cnxn_str） 如果不通过受信任的连接访问数据库，则需要输入通常用于通过SQLServer Management Studio（SSMS）访问服务器的用户名和密码。例如，如果用户名是JoeBloggs，而密码是Password123，则应立即更改密码。更改密码之前，可以按照如下进行连接：
cnxn_str = ("Driver={SQLServer Native Client 11.0};" "Server=UKXXX00123,45600;" "Database=DB01;" "UID=JoeBloggs;" "PWD=Password123;")cnxn = pyodbc.connect(cnxn_str) 现在我们已连接到数据库，可以开始通过Python执行SQL查询。
图源：pexels 执行查询
SQL 服务器上运行的每个查询都包含游标初始化和查询执行。如果要在服务器内部进行任何更改，还需要将这些更改提交到服务器。
先来初始化游标：
cursor = cnxn.cursor() 现在，每当要执行查询时，都要使用此游标对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6154737f5f7376a1650bada9e04f7c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68a93399a6678d4e22a53ca34f637fb/" rel="bookmark">
			cicd持续集成全程_GitLabCI/CD自动集成和部署到远程服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的是通过一个示例应用程序对GitLab CI/CD进行友好的了解，该应用程序有助于入门，而无需阅读所有GitLab文档。
持续集成的工作原理是：将小的代码块-commits-推送到Git存储库中托管的应用程序的代码库中，并且每次推送时，都要运行脚本管道来构建，测试和验证代码更改，然后再将其合并到主分支中。
持续交付和部署包括进一步的CI，可在每次推送到存储库默认分支时将应用程序部署到生产环境。这些方法使您可以在开发周期的早期发现错误和错误，从而确保部署到生产环境的所有代码均符合为应用程序建立的代码标准。
使用Gitlab CI/CD的主要好处之一是，您无需使用许多第三方插件和工具来创建工作流的繁琐过程。GitLab CI/CD由位于存储库根目录的一个名为.gitlab-ci.yml的文件配置。该文件中设置的脚本由GitLab Runner执行。
要将脚本添加到该文件，需要按照您的应用程序适合的顺序组织它们，并通过执行的测试。为了可视化该过程，请想象添加到配置文件中的所有脚本与在计算机的终端上运行的命令相同。
这些脚本被分组为job，它们共同组成了一个管道。
流水线 我们可以根据需要构造管道，因为YAML是一种序列化的人类可读语言
建立3条管道的假设：
Project Pipeline 将安装依赖项，运行linters，以及处理该代码的所有脚本。持续集成管道运行自动化测试并构建代码的分布式版本。部署管道将代码部署到指定的云提供商和环境。 管道执行的步骤称为作业。当您通过这些特征将一系列作业分组时，这称为阶段。作业是管道的基本构建块。可以将它们分为多个阶段，也可以将各个阶段分为多个管道。
根据上图，我们来配置一个基本的管道实例。以下是.gitlab-ci文件
stages: - build - test - deployimage: alpinebuild_a: stage: build script: - echo "This job builds something."build_b: stage: build script: - echo "This job builds something else."test_a: stage: test script: - echo "This job tests something. It will only run when all jobs in the" - echo "build stage are complete."test_b: stage: test script: - echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a68a93399a6678d4e22a53ca34f637fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffa33ea8b92b3cb37c590bd6be69acf/" rel="bookmark">
			EL1008E: Property or field ‘lastMessage‘ cannot be found on object of type ‘java.util.HashMap‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'lastMessage' cannot be found on object of type 'java.util.HashMap' - maybe not public or not valid? at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) at org.springframework.expression.spel.ast.OpNE.getValueInternal(OpNE.java:43) at org.springframework.expression.spel.ast.OpNE.getValueInternal(OpNE.java:33) at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:330) at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ... 102 common frames omitted .TemplateProcessingException: Exception evaluating SpringEL expression: "commentMessage.lastMessage != null" (template: "site/notice" - line 80, col 71) 出现错误的地方：
@RequestMapping(path = "/notice/list",method = RequestMethod.GET) public String getSystemMessage(Model model){ // 获取当前登录用户 User localUser = sessionReplace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ffa33ea8b92b3cb37c590bd6be69acf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607fdd70b5e67612dde93ba80fadc91e/" rel="bookmark">
			k8s-(五）最全的安装教程（使用kubeadm在Centos7上部署kubernetes1.18）以及安装异常问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s使用kubeadm进行安装步骤，使用kubeadm安装k8s会简单很多，一直想总结写一篇简单明了的安装教程，希望能有用。k8s在2020年初发布的第一个版本是1.18.0，目前最新版本是1.19.4，并且1.20的版本应该会在年底发布，但是我们这里安装的版本是1.18。
k8s-基础概念
1.系统准备 搭建虚拟机centos7环境，虚拟机固定IP地址
安装三台虚拟机，一台作master节点，两台作node节点关闭防护墙 [root@master01 ~]# systemctl stop firewalld [root@master01 ~]# systemctl disable firewalld 注：可以不关闭防火墙，但是要设置各个需要的端口的开放规则，比较麻烦，我们自己的开发环境就直接关了防火墙
关闭swap [root@master01 ~]# vi /etc/fstab 注释里面的"/dev/mapper/centos-swap swap"
注：
1.swap相当于“虚拟内存”。当物理内存不足时，拿出部分硬盘空间当SWAP分区（虚拟成内存）使用，从而解决内存容量不足的情况。
2.kubelet 在 1.8 版本以后强制要求 swap 必须关闭
3.free -m 命令可以查看交换区的空间大小，我们注释完再使用这个命令发现交换区swap还没关闭，因为需要重启才生效
关闭selinux [root@master01 ~]# vi /etc/selinux/config 注释掉SELINUX=disabled,然后重启，reboot
注：
1.selinux这个是用来加强安全性的一个组件，挺复杂的，一般直接禁用
2.关闭selinux以允许容器访问宿主机的文件系统
添加阿里源 [root@master01 ~]# rm -rfv /etc/yum.repos.d/* [root@master01 ~]# curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 注：如果是centos8,则链接最后面的Centos-7.repo修改成Centos-8.repo，否则使用yum安装的时候会提示没有可用的软件包
配置主机名 [root@master01 ~]# hostnamectl set-hostname master01 [root@master01 ~]# more /etc/hostname 注：这一步如果少了的话，后面执行kubeadm join的时候会报错，提示有相同名称的节点，所有其他机器的hostname不能一样，工作节点可以写node01、node02这样子
2.配置内核参数，将桥接的IPv4流量传递到iptables的链 [root@master01 ~]# cat &gt; /etc/sysctl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/607fdd70b5e67612dde93ba80fadc91e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff38ea35873926ea4f1a22a47c4db293/" rel="bookmark">
			MATLAB：repmat() 函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		repmat函数 repmat函数主要是用于快速的产生一个大的矩阵，它的用法一般有下面几种：
B = repmat(A,M,N) 矩阵B是矩阵A的复制品，其中B的维度为[size(A,1)*M, size(A,2)*N]。如果你写成repmat(A,[M,N])也是可以的；如果你写成repmat(A,N)，那么它等价于repmat(A,N,N)或者repmat(A,[N,N])。
其实就是把A当做一个元素，让后生成一个M*N的矩阵，该矩阵的每个元素位置放置一个A
首先有A 了
得到的B就是个2行3列的A
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7cec99d9e0e518af33969510d7d4acc/" rel="bookmark">
			基于 Spring 实现管道模式的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇为设计模式第二篇，第一篇可见设计模式最佳套路 —— 愉快地使用策略模式
管道模式（Pipeline Pattern） 是责任链模式（Chain of Responsibility Pattern）的常用变体之一。在管道模式中，管道扮演着流水线的角色，将数据传递到一个加工处理序列中，数据在每个步骤中被加工处理后，传递到下一个步骤进行加工处理，直到全部步骤处理完毕。
PS：纯的责任链模式在链上只会有一个处理器用于处理数据，而管道模式上多个处理器都会处理数据。
何时使用管道模式 任务代码较为复杂，需要拆分为多个子步骤时，尤其是后续可能在任意位置添加新的子步骤、删除旧的子步骤、交换子步骤顺序，可以考虑使用管道模式。
愉快地使用管道模式
▐ 背景回放 最开始做模型平台的时候，创建模型实例的功能，包括：“输入数据校验 -&gt; 根据输入创建模型实例 -&gt; 保存模型实例到相关 DB 表”总共三个步骤，也不算复杂，所以当时的代码大概是这样的：
public class ModelServiceImpl implements ModelService { /** * 提交模型（构建模型实例） */ public CommonReponse&lt;Long&gt; buildModelInstance(InstanceBuildRequest request) { // 输入数据校验 validateInput(request); // 根据输入创建模型实例 ModelInstance instance = createModelInstance(request); // 保存实例到相关 DB 表 saveInstance(instance); } } 然而没有过多久，我们发现表单输入数据的格式并不完全符合模型的输入要求，于是我们要加入 “表单数据的预处理”。这功能还没动手呢，又有业务方提出自己也存在需要对数据进行处理的情况（比如根据商家的表单输入，生成一些其他业务数据作为模型输入）。
所以在 “输入数据校验” 之后，还需要加入 “表单输入输出预处理” 和 “业务方自定义数据处理（可选）”。这个时候我就面临一个选择：是否继续通过在 buildModelInstance 中加入新的方法来实现这些新的处理步骤？好处就是可以当下偷懒，但是坏处呢：
ModelService 应该只用来接收 HSF 请求，而不应该承载业务逻辑，如果将 提交模型 的逻辑都写在这个类当中，违反了 单一职责，而且后面会导致 类代码爆炸
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7cec99d9e0e518af33969510d7d4acc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43fe9ada247aff436175600ccb8be764/" rel="bookmark">
			Python 炫技操作：五种 Python 转义表示法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 为什么要有转义？ ASCII 表中一共有 128 个字符。这里面有我们非常熟悉的字母、数字、标点符号，这些都可以从我们的键盘中输出。除此之外，还有一些非常特殊的字符，这些字符，我通常很难用键盘上的找到，比如制表符、响铃这种。
为了能将那些特殊字符都能写入到字符串变量中，就规定了一个用于转义的字符 \ ，有了这个字符，你在字符串中看的字符，print 出来后就不一定你原来看到的了。
举个例子
&gt;&gt;&gt; msg = "hello\013world\013hello\013python" &gt;&gt;&gt; print(msg) hello world hello python &gt;&gt;&gt; 是不是有点神奇？变成阶梯状的输出了。
那个 \013 又是什么意思呢？
\ 是转义符号，上面已经说过
013 是 ASCII 编码的八进制表示，注意前面是 0 且不可省略，而不是字母 o
把八进制的 13 转成 10 进制后是 11
对照查看 ASCII 码表，11 对应的是一个垂直定位符号，这就能解释，为什么是阶梯状的输出字符串。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-izM0SikI-1606375376406)(http://image.iswbm.com/image-20201125122651086.png)]
2. 转义的 5 种表示法 ASCII 有 128 个字符，如果用 八进制表示，至少得有三位数，才能将其全部表示。这就是为什么说上面的首位 0 不能省略的原因，即使现在用不上，我也得把它空出来。
而如果使用十六进制，只要两位数就其 ASCII 的字符全部表示出来。同时为了避免和八进制的混淆起来，所以在 \ 后面要加上英文字母 x 表示十六进制，后面再接两位十六进制的数值。
\ 开头并接三位 0-7 的数值，表示 8 进制\x 开头并接两位 0-f 的数值，表示 16进制 因此，当我定义一个字符串的值为 hello + 回车 + world 时，就有了多种方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43fe9ada247aff436175600ccb8be764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa703a3af1892bf30ca1dce1a2e2488/" rel="bookmark">
			bigdecimal除法保留4位小数_小猿圈分享-MySQL保留几位小数的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天小猿圈给大家分享的是MySQL使用中4种保留小数的方法，希望可以帮助到大家，让大家的工作更加方便。
1 round(x,d) 用于数据x的四舍五入, round(x) ,其实就是round(x,0),也就是默认d为0；
这里有个值得注意的地方是，d可以是负数，这时是指定小数点左边的d位整数位为0,同时小数位均为0；
1 SELECT ROUND(100.3465,2),ROUND(100,2),ROUND(0.6,2),ROUND(114.6,-1);
结果分别：100.35,100，0.6,110
2 TRUNCATE(x,d)
函数返回被舍去至小数点后d位的数字x。若d的值为0，则结果不带有小数点或不带有小数部分。若d设为负数，则截去（归零）x小数点左起第d位开始后面所有低位的值。
1
SELECT TRUNCATE(100.3465,2),TRUNCATE(100,2),TRUNCATE(0.6,2),TRUNCATE(114.6,-1);
结果分别：100.34,100，0.6,110
3 FORMAT（x,d）
强制把数字x保留D位小数，整数部分超过三位的时候以逗号分割，并且返回的结果是string类型的
1
SELECT FORMAT(100.3465,2),FORMAT(100,2),FORMAT(,100.6,2);
结果分别：100.35,100.00，100.60
4 convert（num，type）
类型转换，相当于截取
type:
二进制，同带binary前缀的效果 : BINARY 字符型，可带参数 : CHAR() 日期 : DATE 时间: TIME 日期时间型 : DATETIME 浮点数 : DECIMAL 整数 : SIGNED 无符号整数 : UNSIGNED 1
SELECT CONVERT(100.3465,DECIMAL(10,2)),CONVERT(100,DECIMAL(10,2)),CONVERT(100.4,DECIMAL(10,2));
结果分别：100.35,100，100.4
好了，小猿圈python学习之在MySQL种4种保留小数的方式已经给大家分享完了，希望大家要认真去记忆哦，最后觉得不错的话记得分享给身边的朋友哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c43a3f26fe7e87d1505760fc43725d/" rel="bookmark">
			11.后台管理系统之动态tabs制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11.后台管理系统之动态tabs制作 1. 第一步，先在侧边栏组件中绑定跳转事件 &lt;template&gt; &lt;el-menu background-color="#1d6a96" text-color="#fff" active-text-color="#66b1ff" :default-active="String(activeNav)"&gt; &lt;!-- 没有儿子的导航栏 --&gt; &lt;el-menu-item :index="item.path" v-for="item in noChildren" :key="item.path" @click="clickMenu(item)"&gt; &lt;i :class="'el-icon-' + item.icon"&gt;&lt;/i&gt; &lt;span slot="title"&gt;{{ item.label }}&lt;/span&gt; &lt;/el-menu-item&gt; &lt;!-- 有儿子的导航栏 --&gt; &lt;el-submenu index="index" v-for="(item, index) in hasChildren" :key="index"&gt; &lt;template slot="title"&gt; &lt;i :class="'el-icon-' + item.icon"&gt;&lt;/i&gt; &lt;span&gt;{{ item.label }}&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item :index="subItem.path" v-for="(subItem, subIndex) in item.children" :key="subIndex" @click="clickMenu(subItem)"&gt; &lt;i :class="'el-icon-' + subItem.icon"&gt;&lt;/i&gt; &lt;span slot="title"&gt;{{ subItem.label }}&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { asideMenu: [ { path: '/', name: 'home', label: '首页', icon: 'info' }, { path: '/video', name: 'video', label: '视频管理页', icon: 'video-play' }, { path: '/user', name: 'user', label: '用户管理页', icon: 'user' }, { path: '/other', name: 'other', label: '其他', icon: 'phone', children: [ { path: '/pageone', name: 'pageone', label: '其他1', icon: 'phone' }, { path: '/pagetwo', name: 'pagetwo', label: '其他2', icon: 'phone' } ] } ] } }, computed: { // 设置当前激活的导航 activeNav() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0c43a3f26fe7e87d1505760fc43725d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a7acaa889b5455254db1d4857d5712/" rel="bookmark">
			怎么用sql按条件把表分离_SQL的汇总分析及练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天的SQL相关汇总分析内容包含了：函数，分组，排序和指定行等
一、函数有：
count(列名)：求某列的行数，不包含空值(null); count(*) 求全部的行数，包含空值(null)
sum(列名)：对某列数据求和，只能对数值类型的列计算
avg(列名)：求某列数据的平均值，只能对数值类型的列计算
max(列名)：求某列数据的最大值
min(列名)：求某列数据的最小值
二、分组和特殊条件查询：group by 和having
group by是分组，having是对分组结果指定条件。这里的having作用类似where，区别是当后面的条件是函数时，只能使用having。
三、排序order by asc/desc
asc是升序：从小到大排 （默认的排序）
desc是降序：从大到小排
注：我们也可以同时指定多个排序列名 order by &lt;列名1&gt; asc,&lt;列名2&gt; desc;
对于含有空值（null）的列排序时，空值会在查询结果开头显示，方便查询表格中空值的情况
四、指定行limit
在mysql中如果返回的数据行很多，可以用limit来限制返回的行数。在SQL中使用的是top,作用相同。
几个常用函数及其作用 SQL 的运行顺序图 上图是SQL的运行顺序，可以帮助理清思路。
练习：
查询课程编号为“0002”的总成绩 /* 分析思路 select 查询结果 [总成绩:汇总函数sum] from 从哪张表中查找数据[成绩表score] where 查询条件 [课程号是0002] */ select sum(成绩) from score where 课程号 = '0002'; 2. 查询选了课程的学生人数
/* 这个题目就是：查询有多少人选了课程 select 学号，成绩表里学号可能有重复值需要去掉 from 从课程表查找score; */ select count(distinct 学号) as 学生人数 from score; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a7acaa889b5455254db1d4857d5712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9875f0c5030e94cd90ef2ef29b5605f1/" rel="bookmark">
			习题8-4 报数 (20分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		习题8-4 报数 (20分)
报数游戏是这样的：有n个人围成一圈，按顺序从1到n编好号。从第一个人开始报数，报到m（&lt;n）的人退出圈子；下一个人从1开始报数，报到m的人退出圈子。如此下去，直到留下最后一个人。
本题要求编写函数，给出每个人的退出顺序编号。
函数接口定义：
void CountOff( int n, int m, int out[] );
其中n是初始人数；m是游戏规定的退出位次（保证为小于n的正整数）。函数CountOff将每个人的退出顺序编号存在数组out[]中。因为C语言数组下标是从0开始的，所以第i个位置上的人是第out[i-1]个退出的。
裁判测试程序样例：
#include &lt;stdio.h&gt; #define MAXN 20 void CountOff( int n, int m, int out[] ); int main() { int out[MAXN], n, m; int i; scanf("%d %d", &amp;n, &amp;m); CountOff( n, m, out ); for ( i = 0; i &lt; n; i++ ) printf("%d ", out[i]); printf("\n"); return 0; } /* 你的代码将被嵌在这里 */ 输入样例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9875f0c5030e94cd90ef2ef29b5605f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6e2daaba236233aec64ccad8221d4c/" rel="bookmark">
			ensp 查看命令（display）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ensp 查看命令（display） 1. display this #查看当前配置过的命令 2. display current-configuration #查看所有配置 （简写 *dis cu* ） 3. display ip interface brief #查看接口的ip 4. display interface brief #查看接口配置信息 5. display ip routing-table #查看路由表 6. display mac-address #查看MAC表 7. display arp #查看ARP表 8. display ospf peer brief #查看ospf邻居关系 9. display interface Eth-Trunk #查看链路聚合状态 10. display clock #查看系统当前时间 11. display saved-configuration #显示保存的配置文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9639dc3f6cde445dd11a518d17b16b1/" rel="bookmark">
			sql删除表_你好！SQL，好久不见！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在下笔写SQL系列文章时，我突然有点懵，因为从某种意义上来说SQL是我熟悉的陌生人。熟悉是因为我和SQL很早就已相遇，回首整个过程，我们经历过浅浅的相知，长长的相忘于江湖，紧接着又是短暂的重逢，然后再是分离，到如今我又一次拜倒在她的石榴裙下。陌生则是因为，恰如前面所述的历程，很多属于我和SQL的回忆因为分隔而变得云淡风轻。这种感觉很是奇妙，但我欣喜的是我终于明白了SQL在我心中的地位。
你可能要问我，是如何确定了SQL在我心中的地位？我的答案是，黄金圈思维原则。无论是工作还是日常生活，相较于问自己为什么，我们更愿意在大脑惯性指挥下，先行动起来。而往往很多事情到了最后，会发现从一开始就是错的。以前在学校里，SQL只是课程表上的一门课而已，踏入社会，SQL就是工作上一个必须要用的工具而已，我却从未深度思考过，我为什么要选择SQL？SQL究竟于我而言代表着什么。
SQL是数据分析的好战友，没有SQL，或许我们面对数据库，只能望洋兴叹；SQL是高级的非过程化编程语言，掌握它，我们可以拥有多一重的思维模式；SQL也是我们求职加薪的敲门砖和筹码，它也许可以有助于你再往上一个台阶； 既然知晓了SQL对我的重要性，那么为了不再产生陌生的感觉，接下来的这段时间，我会重新认识一下SQL，并且把这些感悟以文字形式记录下来，来吧！开启重温之旅~
一. 什么是数据库？什么是SQL？
数据库，顾名思义是存放数据的仓库，就像一个包罗万象的收纳盒，只不过它的对象只是数据。在数据库中，我们更多接触的是关系数据库，它包括多张表以及各表之间的关系。在数据库中，关系是两张表之间数据的匹配，比如外键。
SQL是操作数据库的一个工具，数据库里有原始天然的信息，而把这些信息提炼加工出来靠的是SQL。
二. 如何安装数据库？
在数据库的选择上，通常优先选择Mysql，它具有运行速度快和使用成本低的优点。具体安装，可参考线上分享的安装课程。
Mysql还有它的好盆友Navicat，它们是被管理和管理的关系，前者作为数据库系统，后者则是数据库管理工具。我们日常对数据库的基本操作都在Navicat中进行，它功能强大且易于学习。
三. 表的创建、删除和更新
在已创建的数据库下，可以右击选择【新建表】： 创建表后，会对表格的字段进行设置：
类型的选择见下：
“不是null”勾选表明不允许为空值，不勾选则是允许为空值。
一张表可以选择&gt;=1列作为主键/复合主键，确保该表的每一行具有身份的唯一性。
Null和空字符串（“”）的区别在于空字符是有值的且可以进行运算。
字段设置完成后，点击【保存】，表格的骨架已搭建好，需要对应数据的填充：
以上数据是类似于Excel中表格录入数据一样，需要手动一条条输入。
2. 表可以删除：右击选中需要删除的表格：
在实际工作中，【删除表】一定要慎重，删除不可恢复，千万不能手欠呀！
3. 和Excel一样，表格中的数据有了改动，就需要更新，可以右击该表，直接在表格中进行更新保存。
四. 数据的插入、删除和更新
除了采用类似Excel方式录入数据外，还可以使用查询语句来进行插入、删除和更新：
Insert into &lt;表名&gt;（&lt;列名1&gt;,&lt;列名2&gt;,…） Values（&lt;值1&gt;,&lt;值2&gt;,…）
输入符号的时候只能使用英文状态下，切记一旦有报错首先查看一下是否符号是中文状态下的。一个语句结束，以英文分号（;）结尾，不能忘记。 2. DELETE 语句用于删除表中的行：DELETE FROM 表名称 WHERE 列名称 = 值
3. Update 语句修改表中的数据：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
好了，今天先简单入个门，下一期就是简单查询啦，期待~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3936a39b2537d0c87a015b71302c5205/" rel="bookmark">
			未找到框架“.NETFramework,Version=v4.6.1”的引用程序集 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从Unity可以打开c#文件，但高亮没有，生成也报错…真的离谱…各种重装百度都没用，断断续续搞了快一天，终于能用了，妙啊
错误信息： 未找到框架“.NETFramework,Version=v4.6.1”的引用程序集。若要解决此问题，请安装此框架版本的 SDK 或 Targeting Pack，或将应用程序的目标重新指向已装有 SDK 或 Targeting Pack 的框架版本。请注意，将从全局程序集缓存(GAC)解析程序集，并将使用这些程序集替换引用程序集。因此，程序集的目标可能未正确指向您所预期的框架。
打开项目出现的提示： 类似这样：
因为没截图就找了网上老版本的一张图，大致意思一样
解决： 右键 报错的这个解决方案 —— 属性
目标框架 —— 选择刚报错中显示连接不到的那个framework
1）如果没有显示那个framework，查看C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework 中有没有这个版本，如果有，说明其实已经安装了此版本。
2）则将.NETFramework文件夹整个复制到C:\Program Files\Reference Assemblies\Microsoft\Framework 文件夹中。
3）重新打开属性，出现了需要的framework版本，选择即可。没出现可以等一会儿或者都关了重新打开vs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd1aa1be8ac2e8be1caf56d5deb93260/" rel="bookmark">
			win10下安装Flink
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flink 可以运行在 Linux, Mac OS X, and Windows 操作系统上面。要运行Flink得先安装JDK 8.X。
JDK安装参看：http://www.itclj.com/blog/5920236681c06e672f942ad4
注意：到写这篇文章为止，目前支持windows最稳定版本是1.9.3，1.10和1.11就不支持了（不知道原因），用1.10或1.11版本安装总报一些参数找不到的问题，并且另外一个启动窗口总是一闪而过。所以这里用支持windows的最高版本1.9.3。有条件的用MAC或者其它Linux系统，不建议用Windows。
1.10和1.11安装报错如下：
1.下载 官网下载地址：https://flink.apache.org/zh/downloads.html
GIThub源码下载地址：https://github.com/apache/flink
当前最新稳定版本是1.9.3
下载的文件：flink-1.9.3-bin-scala_2.12.tgz
2.启动 把下载的文件解压到一个目录，例如我本地解压到了：C:\ProgramFiles\ASF
解压后的目录结构如下
window命令行下进入目录D:\bigdata\flink\flink-1.9.3运行
./bin/start-cluster.bat 启动flink
Flink启动后，会有一个WEB的管理页面，默认地址为：http://localhost:8081
这样，flink就算已经启动好了。
3.运行demo flink 提供两种任务运行入口
1、flink.bat脚本启动任务程序
2、页面上传任务程序包运行
3.1通过脚本启动任务 运行字统计任务demo程序
flink.bat run ../examples/batch/WordCount.jar 可以看到统计结果直接打印到了控制台上。
3.2通过页面上传任务程序包运行 上传任务程序包
运行任务程序包
任务管理监控
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d6a7836be200eec62fb0d2bbb44a6a/" rel="bookmark">
			idea2020 导入svn项目失败总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在Setting的SVN配置中找到Use custom configuration directory选项；--不管用；
2、重装的svn----不管用；
3、最后自己瞎试的，settings--》version control-》subversion---》将两个复选框勾选都选上；点ok再试就可以了；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0fedc7bd0d64118697a3ce4fa8190c/" rel="bookmark">
			Flink SQL中的窗口函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Flink窗口函数是flink的重要特性，而Flink SQL API是Flink批流一体的封装，学习明白本节课，是对Flink学习的很大收益！
窗口函数 窗口函数Flink SQL支持基于无限大窗口的聚合（无需在SQL Query中，显式定义任何窗口）以及对一个特定的窗口的聚合。例如，需要统计在过去的1分钟内有多少用户点击了某个的网页，可以通过定义一个窗口来收集最近1分钟内的数据，并对这个窗口内的数据进行计算。
Flink SQL支持的窗口聚合主要是两种：Window聚合和Over聚合。本文档主要为您介绍Window聚合。Window聚合支持Event Time和Processing Time两种时间属性定义窗口。每种时间属性类型支持三种窗口类型：滚动窗口（TUMBLE）、滑动窗口（HOP）和会话窗口（SESSION）。
时间属性 Flink SQL支持以下两种时间属性。实时计算可以基于这两种时间属性对数据进行窗口聚合。
Event Time：您提供的事件时间（通常是数据的最原始的创建时间），Event Time一定是您提供在Schema里的数据。Processing Time：对事件进行处理的本地系统时间。 概念性的东西不说了，参考：https://help.aliyun.com/document_detail/62510.html?spm=a2c4g.11186623.6.761.5778319bX6nU52
https://blog.csdn.net/huahuaxiaoshao/article/details/107520208
2 分组窗口 2.1 分组窗口的类型
SQL查询的分组窗口是通过GROUP BY子句定义的。类似于使用常规GROUP BY语句的查询，窗口分组语句的GROUP BY子句中带有一个窗口函数为每个分组计算出一个结果。以下是批处理和流出理表支持的分组窗口函数：
（1）TUMBLE(time_attr, interval)
定义一个滚动窗口。滚动窗口把行分配到有固定持续时间（interval）的不重叠的连续窗口。比如，5分钟的滚动窗口以5分钟为间隔对行进行分组。滚动窗口可以定义在事件时间（批处理、流处理）或处理时间（流处理）上。
（2）HOP(time_attr, interval, interval)
定义一个跳跃窗口（在Table API中成为滑动窗口）。滑动窗口有一个固定的持续时间（第二个interval参数）以及一个滑动的间隔（第一个interval参数）。若滑动间隔小于窗口的持续时间，滑动窗口则会出现重叠；因此，行将会被分配到多个窗口中。比如，一个大小为15分钟的滑动窗口，其滑动间隔为5分钟，将会把每一行数据分配到3个15分钟的窗口中。滑动窗口可以定义咋事件时间（批处理、流处理）或处理时间（流处理）上。
（3）SESSION(time_attr, interval)
定义一个会话时间窗口。会话时间窗口没有一个固定的持续时间，但是它们的边界会根据interval所定义的不活跃时间所确定；即一个会话时间窗口在定义的间隔时间内没有新纪录出现，该窗口会被关闭。例如时间窗口的间隔时间是30分钟，当其不活跃的时间达到30分钟后，若观测到新的记录，则会启动一个新的会话时间窗口（否则该行数据会被添加到当前的窗口），且若在30分钟内没有观测到新纪录，这个窗口将会被关闭。会话时间窗口可以使用事件时间（批处理、流处理）或处理时间（流处理）。
2.2 时间属性
在流处理表中的SQL查询中，分组窗口函数的time_attr参数必须引用一个合法的时间属性，且该属性需要指定行的处理时间或事件时间。
对于批处理的SQL查询，分组窗口函数的time_attr参数必须是一个TIMESTAMP类型的属性。
2.3 选择分组窗口的开始和结束时间戳（辅助函数）
（1）返回相对应的滚动、滑动和会话窗口的开始时间（包含边界）
TUMBLE_START(time_attr, interval) HOP_START(time_attr, interval, interval) SESSION_START(time_attr, interval) （2）返回相对应的滚动、滑动和会话窗口的结束时间（包含边界）
TUMBLE_END(time_attr, interval) HOP_END(time_attr, interval, interval) SESSION_END(time_attr, interval) 注意：返回的间戳不可以在随后基于事件的操作中，作为行时间属性使用，比如基于事件窗口的join以及分组窗口或分组窗口上的聚合。
（3）返回相对应的滚动、滑动和会话窗口的结束时间（不包含边界）
TUMBLE_ROWTIME(time_attr, interval) HOP_ROWTIME(time_attr, interval, interval) SESSION_ROWTIME(time_attr, interval) 返回的是一个可用于后续需要基于时间的操作的时间属性（rowtime attribute），比如基于时间窗口的join以及分组窗口或分组窗口上的聚合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f0fedc7bd0d64118697a3ce4fa8190c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd01c801b5626b969c125ad3249f2fb/" rel="bookmark">
			Vue报错Duplicate keys detected: ‘900‘. 问题处理记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发Vue项目中遇到报错“Duplicate keys detected: '900'. This may cause an update error”，一开始有点懵，于是网上找了一圈，还是找到了一些比较有帮助意义的资料，为了防止自己第二次踏入同一条河，决定拿小本本记下来……
一、报错原因
v-for里的key存在重复值。
二、解决办法
参考https://blog.csdn.net/weixin_44626952/article/details/101026672，做了以下总结。
可以采用以下其中一种方法解决：
1、删除数据来源中重复的key值。（本人采用的是此方法）
2、更改key值的定义，比如原来由1个字段作为key值，改为由2个字段组合作为key值。（较多网友采用该方式，不过个人的想法是既然是数据源的问题，那就把有问题的数据处理掉，所以未采用该方法）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6059ec1ba0a9998fa0a8d8b7d2d30ddc/" rel="bookmark">
			Android使用kotlin开发入门 （学习一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android使用kotlin开发入门 （学习一） 关于效果图新建一个Android项目修改Activity_main.xml文件修改MainActivity.kt文件 关于 南京又是持续下雨的季节，下午在学习郭霖老师和鸿洋老师的博客文章的时候，看到了郭老师讲解的Jetpack新成员，App Startup一篇就懂，内容博大精深，发现是我还没学习使用的kotlin语言写的博客demo。。。回顾这一年来的Android工作，基本都是用的java语言写的代码，之前也看到有朋友在朋友圈分享他的kotlin写的天气类型app。现在想来是时候学习并记录一下。好在kotlin有一个特别好的优点就是可以和java混合开发，特别适合我这种kotlin新手在项目中混合编写学习。
下面的demo简单记录下如何使用kotlin编程，别的不说，代码量少了一大截。
效果图 简单演示了kotlin如何使用控件实例的点击监听。
新建一个Android项目 新建项目如下，如图所示，选择kotlin，然后点击继续即可：
等待自动生成即可。
我们看到MainActivity.kt(已经由.java变成了.kt)，里面的基本代码也已经发生了变化：
其中变化之一呢，是由原来的：
public class Mainctivity extends AppCompatActivity() 变成了现在的这样：
class MainActivity : AppCompatActivity() 这就是继承，由原来的extends变成了:。
二就是override 字段，用来字类继承父类方法。
第三就是每局代码结尾不需要用；来做结尾。
第四就是定义变量类似C，用的val ，内容要赋值，不然会有空提示。
修改Activity_main.xml文件 新增对应的textview与button控件：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:id="@+id/tvTestKotlin" android:layout_height="wrap_content" android:text="Hello World!" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/buttonKotlin" android:text="click" tools:ignore="MissingConstraints" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 修改MainActivity.kt文件 tvTestKotlin.text="hello Kotlin World!" 添加代码，设置主界面textview实例的内容为hello Kotlin World!，其中tvTestKotlin为xml文件中的TextView的实例id。
以前java写法是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6059ec1ba0a9998fa0a8d8b7d2d30ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d08930222013dae2c730893381a51a/" rel="bookmark">
			Linux运行SQL文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux系统运行SQL文件 1、现在/opt目录下有一个uc_menu.sql文件，需要将其数据备份到数据库中，应进行如下操作
2、步骤如下：
（1）首写进入进入mysql:
（2）输入mysql密码：
（3）输入命令：show databases;显示所有数据库； show databases; （4）输入命令：use databasename;选中你要执行sql文件的数据库（其中databasename是数据库名称）
use kayou; （5）输入命令：source /opt/uc_menu.sql;（运行SQL文件）
注：/opt是目录，sql文件前的/不可以省略。
source /opt/uc_menu.sql; （6）执行完毕。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff9ab629cc3a6e7da49a2bf94efdf12/" rel="bookmark">
			centos7 批量创建samba用户_(转)在ubuntu16(samba/iscsi/nfs）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ubuntu 16.04系统中搭建NAS环境
一、基本配置1：设置静态IPvi /etc/network/interfaces#iface ens32 inet dhcpiface ens32 inet staticaddress 10.86.2.5netmask 255.255.255.0gateway 10.86.2.1dns-nameservers 114.114.114.114 2：进行系统更新apt updateapt upgrade 3：对新加进来的硬盘进行格式化并挂载进来mkfs.ext4 /dev/sdbmkdir /mnt/sdbmount /dev/sdb /mnt/sdb 二、部署samba(Windows系统文件共享)
1：安装服务
apt install samba
2：配置共享vi /etc/samba/smb.conf在末尾添加以下内容[public]path=/home/publicbrowseable=yesread only=noguest ok=yes 3：创建文件夹配置写入权限mkdir /home/publicchmod 777 /home/public 至此匿名的文件读写权限已经设置好了
4：添加系统用户到SAMBA账号smbpasswd -a asheng注：asheng是我要添加的账户名，如果系统没有此用户需要创建。 5：启用samba账户smbpasswd -e asheng 6：重启服务，致使配置生效systemctl restart smbd.service nmbd.service 三、部署iSCSI(可挂载到Windows系统的本地磁盘)1：安装服务apt install iscsitargetsystemctl enable iscsitarget 2：配置ietvi /etc/iet/ietd.conf添加以下内容Target iqn.1991-05.com.microsoft:cld-pcLun 0 Path=/dev/sdb,Type=fileioAlias lun0 注1：iqn.1991-05.com.microsoft:cld-pc是我从Windows7系统的“iSCSI 发起程序”复制过来的iqn
注2：/dev/sdb是要挂载给Windows系统的磁盘
3：配置为启用vi /etc/default/iscsitarget将第一行的ISCSITARGET_ENABLE=false改为ISCSITARGET_ENABLE=true 4：重启服务使之生效service iscsitarget restart 四、部署NFS(可挂到linux系统、给ESXI提供存储)1：安装服务apt install nfs-kernel-serversystemctl enable nfs-kernel-server 2：配置NFSmkdir -p /mnt/sdb/nfs/datavi /etc/exports添加内容/mnt/sdb/nfs/data 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff9ab629cc3a6e7da49a2bf94efdf12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7e1075f3e23b70e57201961946c6ae/" rel="bookmark">
			Ubuntu 20.04 修改IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用NetPlan工具修改IP地址 进入/etc/netplan目录
cd /etc/netplan 查看目录下的配置文件
ls 选择本机正在使用的配置文件
（如果您和我一样，当前目录下只有一个配置文件，那么，不需要犹豫，就是它了，打开，大胆的修改它！）
sudo vi 01-network-manager-all.yaml 修改前
修改后
其中 ens32为网卡，请通过net-tools工具查询
ifconfig addresses为IP地址和子网掩码，参数为数组类型，可填写多组。
dhcp4 是否自动分配IP
gateway4 网关
nameserver DNS服务IP
令配置生效 sudo netplan apply 再次使用net-tools检查配置是否生效
注意！如果使用的是ssh服务进行远程连接，出现没有反应的情况是正常的。
因为你的IP地址可能已经发生改变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6979c7a047686402b85b0fe26675bd/" rel="bookmark">
			每日一课 | 将 Python string 转换为 float 的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Python中，我们可以使用float()将String转换为float。
num = "3.1415" print(num) print(type(num)) # str pi = float(num) # convert str to float print(pi) print(type(pi)) # float 输出量
3.1415 &lt;class 'str'&gt; 3.1415 &lt;class 'float'&gt; 参考文献 Python文档– float（）
翻译自: https://mkyong.com/python/python-how-to-convert-string-to-float/
推荐阅读--
每日一课 | java字符串加入空格 每日一课 | AES加密和解密（CBC模式） 每日一课 | python去除图片水印 每日一课 | 示例 Java 8 Stream 的 iterate 处理 每日一课 | java now_Java即时类 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/821e8a554342ee371774f01695a06bba/" rel="bookmark">
			win10下安裝pig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10下安裝pig非常简单
1.下载 2.配置环境变量 分别配置PIG_HOME和PATH，这个比较简单，不在详细说明。
3.替换pig.cmd文件 这里贴上完整的pig.cmd文件
# Licensed to the Apache Software Foundation (ASF) under one # or more contributor license agreements. See the NOTICE file # distributed with this work for additional information # regarding copyright ownership. The ASF licenses this file # to you under the Apache License, Version 2.0 (the # "License"); you may not use this file except in compliance # with the License. You may obtain a copy of the License at # # http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/821e8a554342ee371774f01695a06bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6169b4a03be747a90476a42aff0893b5/" rel="bookmark">
			解决legacy、uefi系统盘boot页面无法识别问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		boot页面有时候识别不到legacy盘
此时，先进bios页面的plantform configuration页面-&gt;PCH Configuration-&gt;PCH sata configuration看到port2 口的系统盘已被识别
排除硬件没识别问题后
进入bios的advance选项卡-&gt;CSM configuration
先把CSM support改为enable，再把boot option filter改为uefi and legacy或legacy only，再进入boot页面即可识别（不同bios版本有所差异）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25fc9241b534ec6ecfa729b35d800642/" rel="bookmark">
			Docker工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初识 Docker jdk的版本问题，环境造成的问题很常见，称为代码的水土不服
把环境和代码一起传过去
软件跨环境迁移的问题就解决了
Docker 是一个开源的应用容器引擎诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc）Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。容器是完全使用沙箱机制，相互隔离容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版） 解决环境兼容问题
https://blog.csdn.net/b9567/article/details/105027440/
• 镜像（ Image ）： Docker 镜像（ Image ），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 • • 容器（ Container ） ：镜像（ Image ）和容器（ Container ）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 • • 仓库（ Repository ） ：仓库可看成一个代码控制中心，用来保存镜像。 Docker 命令 Docker 进程相关命令 • 启动 docker 服务 • 停止 docker 服务 • 重启 docker 服务 • 查看 docker 服务状态 • 开机启动 docker 服务 Docker 镜像相关命令 • 查看镜像 • 搜索镜像 • 拉取镜像 • 删除镜像 查看镜像: 查看本地所有的镜像 tag就是版本号 镜像文件就是各种软件，可以创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25fc9241b534ec6ecfa729b35d800642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2ce2ca165f058321386eaa45dc3dba/" rel="bookmark">
			Matlab filter2、conv2报错：不支持N维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 filter2、conv2报错：不支持N维数组 错误原因👇
对于彩色图像，imread函数返回一个3维数组，其中第三维度有3个元素分别为R、G和B。
解决办法
读取图像后，紧接着需要用rgb2gray函数将图像转换为二维的灰度值
A = imread('E:\MATLAB学习\qie.jpg');B = rgb2gray(A);MATLAB 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/225/">«</a>
	<span class="pagination__item pagination__item--current">226/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/227/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>