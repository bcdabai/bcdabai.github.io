<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e53ac47bd751d8d156e906a029144d/" rel="bookmark">
			了解OpenCart中的地理区域和税收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/cunjie3951/article/details/106922860/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab576cb9d276ba3f9ef4fc13d80ae54/" rel="bookmark">
			5-9 找两个数中最大者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对两个整数a和b，输出其中较大的数。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬
函数接口定义： int max( int a, int b ); 其中a和b是用户传入的参数，函数返回的是两者中较大的数。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬
‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭ #include &lt;stdio.h&gt; int max( int a, int b ); int main() { int a, b; scanf("%d %d", &amp;a, &amp;b); printf("max = %d\n", max(a, b)); return 0; } /* 你的代码需要被嵌在这里，与上述测试代码一起提交 */ 输入样例： -5 8 输出样例： max = 8 参考代码
#include&lt;stdio.h&gt; int max(int a,int b); int main(){ int a,b; scanf("%d%d",&amp;a,&amp;b); printf("max = %d\n",max(a,b)); return 0; } int max(int a,int b){ if(a&gt;b) return a; else return b; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6c6a630172f7fdbad20cc4e072714b/" rel="bookmark">
			【机械臂算法】机械臂运动学参数辨识/DH参数校准/DH参数辨识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要进行的是以提高位置精度为目的，基于误差模型和最小二乘法的DH参数辨识。需要注意的是，由于DH参数使得机械臂的位置和姿态存在强耦合，因此在提高位置精度的同时，姿态精度也会获得提升。
DH参数辨识的主要步骤：
建立误差模型；不能辨识的冗余参数剔除；雅可比矩阵求伪逆；迭代求解。 在建立误差模型的过程中，如果机械臂存在相邻两个轴平行时，需要建立含有beta模型的DH参数。
还有需要注意的是，基于误差模型的DH参数校准方法是建立在DH误差相对较小的情况，只有当此时才能进行线性近似，保证辨识的效果。
这里的DH参数标定是包括，1、零点标定，和 2、杆长标定。
本文随机给出一种6轴的机械臂，同时存在相邻两个轴平行，进行参数辨识。
首先假设，DH模型存在误差如下:
可以看出无论是距离还是角度都为1e-2数量级。
然后我们进行数据采样，比较基于NDI采样的机器人末端位姿和基于机器人运动学读出的位姿的差异：
进行迭代补偿：
（待补充）
辨识结果：
可以看出，除去冗余参数，其他DH参数都能辨识出来。
对比补偿前后的绝对精度：
可以看出，补偿后的位置精度大大提升。
同时我们再关心一下姿态精度：
可以看出，虽然我们是建立在辨识位置精度误差模型的基础上，机器人位姿关系的强耦合，我们同时也提高了姿态精度。
因此通过此算法，机器人的位置精度和姿态精度都大大提升了。
为了更直观的展示，我们讲机器人末端轨迹展示出来。
其中绿线是补偿前的轨迹，蓝线是补偿后的轨迹，可以看出通过DH参数辨识，我们将机器人的模型和真实的机器人更加接近了，因此也就提高了控制的精度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/754b523187ea6d406aa6621fee5f1dba/" rel="bookmark">
			Linux Centos7环境下vim编译器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.vim是什么？
2.vim的基本模式
2.1插入模式
2.2命令模式
2.3底行模式
3.vim下批量化注释/去注释
3.1首先进入VISUAL BLOCK模式
3.2用hjkl进行你要注释的区域选择
3.3进入插入模式
3.4注释
3.5去注释
4.vim配置问题
1.vim是什么？ vim是一种多模式的编辑器，里面还有很多子命令，用来对代码进行编辑操作
2.vim的基本模式 大家可以先看看下面这张照片 能更好的理解 后面会细讲各个模式
2.1插入模式 在命令模式下按一下 i 键即可进入到插入模式
在左下角出现INSERT即成功进入到插入模式了，在此模式下，任何的输入（Esc除外）都会被当做数据插入到文本上，我们可以在此模式下写一些c语言代码
2.2命令模式 命令模式就是你用vim命令进去文件时默认所处的模式，在此模式下，你可以通过一些快捷键（子命令），来实现对代码的复制，粘贴，查看等等操作。
shift+^：光标移动到当前行最左侧结尾处
shift+$：光标移动到当前行最右侧结尾处
gg：光标定位到文本最开始处
shift+g：光标移动到文本最后一行
n+shift+g：光标移动到文本第n行
8+shift+g
h：向左移动一位
j：向下移动一位
k：向上移动一位
l：向右移动一位
yy：复制当前行
n+yy：复制n行
p：在下一行进行粘贴
n+p：在下一行进行n次粘贴
在第四行点一次yy，再点一次即可复制第四行（可以加n选择复制和粘贴的次数）
u：撤销操作
ctrl+r：对撤销进行撤销
点一下u即可返回上一步
ctrl+r，对撤销进行撤销
dd：删除当前行/剪切当前行
n+dd：删除n行/剪切n行
按一下dd即可将当前行剪切/删除
shift+~：大小写快速切换
r：替换当前所在字符
n+r：替换n个字符
x：删除光标所在字符
n+x：删除n个字符
按一下x进行删除
shift+x：向光标的左侧进行局部删除
shift+3：高亮要查找的函数名
n：切换到下一个查找到的函数名
w：按照单词在行内进行移动 （前）
b：按照单词在行内进行移动 （后）
2.3底行模式 在命令模式下 shift + : 即可进入
w：写入，即将你当前所写的代码保存起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/754b523187ea6d406aa6621fee5f1dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4f425c07c5f9bd92ee19c1338671f5/" rel="bookmark">
			Ubuntu(WSL2) 安装最新版本的 GCC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 Ubuntu 上安装最新版本的 GCC，可以通过以下步骤进行操作：
1. 打开终端（Terminal）
2. 更新软件包列表，确保系统使用最新的软件包信息，运行以下命令：
sudo apt update 3. 安装 GCC 软件包，运行以下命令：
sudo apt install gcc 这将安装 Ubuntu 软件仓库中可用的默认版本的 GCC。
4. 如果您需要安装特定版本的 GCC，可以使用 `apt` 命令加上软件包的版本号进行安装。例如，要安装 GCC 11 版本，可以运行以下命令：
sudo apt install gcc-11 5. 安装完成后，您可以通过运行以下命令来验证 GCC 的版本：
gcc --version 这将显示已安装的 GCC 版本信息。
说明：如果使用上述命令查看 gcc 版本时没有出现 gcc 的相关版本信息，可以使用下述命令查看（或者关闭当前 Ubuntu 会话，重启会话就可以正常查看 gcc 版本信息了）：
gcc-11 --version 请注意，Ubuntu 软件仓库中的 GCC 版本可能不是最新的稳定版本。如果您需要使用最新的 GCC 版本，可以考虑从官方 GCC 网站（https://gcc.gnu.org/）下载并手动编译安装最新版本的 GCC。这需要更多的步骤和依赖项，请确保在进行此操作之前阅读官方文档并了解所需的步骤和要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2ec97bfc5421cf0f5c17896354f64e/" rel="bookmark">
			Unity&amp;&amp;C#学习笔记-抽象方法虚方法抽象类:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象方法和虚方法 什么叫虚方法: 关键字 virtual 允许在子类中重写的方法
如果子类重写了虚方法,则在运行时将运行重写的逻辑;如果子类没有重写虚方法,则在运行时将运行父类的逻辑。
抽象方法(纯虚函数)： 关键字 abstarct
只在抽象类中定义，关键字abstract方法修饰符不能使用private,virtual,static.
没有方法主体
总结：抽象方法是只有方法名称，没有方法体（也就是没有方法具体实现），子类必须重写父类抽象方法；虚函数是该方法有方法体，但是子类可以覆盖，也可不覆盖。
（1）虚方法有方法体，抽象方法没有方法体。抽象方法是一种强制派生类覆盖的方法，否则派生类将不能被实例化；
（2）抽象方法只能在抽象类中声明，虚方法不是；
（3）派生类必须重写抽象类中的抽象方法，虚方法则不必要。
抽象类: 1、抽象方法只能出现在抽象类中，但是抽象类中可以包含普通方法。
2、如果抽象类的子类不是抽象类，那么子类中必须重写父类抽象类的所有抽象方法。
3、如果类包含抽象方法，那么该类也是抽象的，也必须声明为抽象的
4、抽象方法必须加public关键字
如果子类是抽象类可以不实现父类抽象方法
抽象类里面可以有虚方法
接口 二、抽象类和接口的相同点和区别 1、相同点 1、不能实例化；
2、包含未实现的方法声明
3、派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员（不仅是方法包括其他成员）
2、不同点 1、接口可以多继承，抽象类不能实现多继承。
2、接口只能定义抽象规则，抽象类既能定义抽象规则也能提供已实现的成员。
3、接口是一组行为规范，抽象类是一个不完全的类，着重于族的概念。
4、接口支持回调，抽象类不能实现回调，因为继承不支持。
5、接口只包含方法、属性、索引器、事件的签名，但不能定义字段和包含实现的方法，抽象类可以定义属性、字段、包含有实现的方法。
6、接口可以作用于值类型和引用类型，抽象类只能作用于引用类型（例如：Struct只能继承接口）。
7、抽象类应主要用于关系密切的对象，而接口则是适合为不相关的类提供通用功能。
8、接口着重于Can—Do关系类型，抽象类则偏重于IS—A式关系。
9、接口多定义对象的行为，抽象类多定义对象的属性。
10、如果要设计小而简练的功能块，则使用接口，如果要设计大的功能单元，则使用抽象类。
11、接口对应是面向对象编程思想的重要原则：面向接口编程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194d6b02d3d43b91dbb9b5232d66f140/" rel="bookmark">
			打包的文件可以在C盘写入&#43;C# WInForm项目打包为exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分：使得打包的文件可以在C盘写入 内容来源：添加/删除/读写c盘文件——c# - vv彭 - 博客园 (cnblogs.com)
一、前言： 有时候我们为自己的程序添加配置文件，如tet、ini、xml等文件，又或者保存软件运行时的日志
当我们把软件打包后，默认安装在c盘，而配置文件也会跟随生成在安装目录下
此时你会发现，配置文件无法生成/修改
这是因为操作c盘文件需要管理员身份
二、写入C盘方法： 有两种方法可以达到目的，一种是修改安装后的软件属性，另一种是修改打包前的程序属性
（一）方法一：修改安装后的软件属性 步骤：1.右键需要运行的exe文件选择属性
2.选择兼容性目录栏
3.勾选以管理员身份运行此软件
4.点击“应用”，“确定”
注：此方法操作简单，不用重新打包，对只有一次安装该软件比较友好，但如果需要多次安装，就显得很繁琐，每安装一次都要去修改一次，发行给别人不推荐 ；
（二）方法二：在项目中配置管理员权限（相关步骤进行完后，记得生成一下解决方案哦） （1）来到相关的解决方案，右键选中需要提升权级的项目——&gt;属性——&gt;安全性——&gt;勾选启动ClickOnce安全设置选项。
相关项目的“Properties”会出现app.manifest配置。
（2）双击打开Properties下的app.manifest文件，按照按照注释把requestedExecutionLevel 节点的 level="asInvoker"替换成level="requireAdministrator" 即可。
其中权限解析如下：
asInvoker 当前权限，可以理解为只有一般用户的权限；requireAdministrator 管理员权限，如果运行此程序的账户没有管理员权限则直接不运行；highestAvailable 用户所能拿到的最高权限，如果用户不是管理员也会运行。 下图是修改后的截图：
（3）将之前勾选的ClickOnce取消掉：右键项目——&gt;属性——&gt;安全性——&gt;取消勾选启动ClickOnce安全设置选项。如果不取消，会报错误：“ClickOnce 不支持请求执行级别“requireAdministrator”“
（4）注意，生成一下解决方案和项目。
第二部分：如何将C# WInform打包为exe让User在本地运行 第一步：下载扩展Microsoft Visual Studio Installer Projects 1.工具=&gt;扩展和更新=&gt;扩展 =&gt; 管理扩展 2.搜索框输入：Microsoft Visual Studio Installer Projects 3.点击下载，然后按着指示安装（此图是已经下载安装完成） 第二步：右击选中项目的解决方案 =&gt; 添加 =&gt; 新建项目
选中“Setup Project”，点击“确定”
第三步：项目创建成功之后，添加文件 1.右击Application Folder（应用程序文件夹） =&gt; Add =&gt; 文件 把你需要打包的项目下 =&gt; bin =&gt; Debug文件夹下的所有文件一个一个添加到Application Folder（应用程序文件夹）中（注：项目不同文件多少不一致，全部添加）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/194d6b02d3d43b91dbb9b5232d66f140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a7bf2ab10ec8dc44b3457b166ccfb1/" rel="bookmark">
			【CASS精品教程】cass3d基于DOM和DEM生成倾斜三维模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和EPS一样，cass3d也可以生成三维模型。本文讲解 cass3d基于pix4d生成的正射影像DOM和DSM生成倾斜三维模型，并进行三维测图。
一、三维倾斜模型打开 打开cass11.0软件，打开三维窗口，点击打开模型，选择基于dom和dsm生成的osgb模型。
三维模型预览：
完整的模型数据：
二、三维模型生成 点击cass3d工具栏上的【构建3d模型】按钮。
选择pix4d生成的dom、dsm，确定生成路径，点击确【开始生成】。
三、三维测图 选择对应的工具 ，即可在三维环境进行DLG的采集。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4895fbd5b3ac2e629e423a2ba5c59c35/" rel="bookmark">
			矩阵转置（二维数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 KiKi有一个矩阵，他想知道转置后的矩阵（将矩阵的行列互换得到的新矩阵称为转置矩阵），请编程帮他解答。
输入描述: 第一行包含两个整数n和m，表示一个矩阵包含n行m列，用空格分隔。 (1≤n≤10,1≤m≤10)
从2到n+1行，每行输入m个整数（范围-231~231-1），用空格分隔，共输入n*m个数，表示第一个矩阵中的元素。
输出描述: 输出m行n列，为矩阵转置后的结果。每个数后面有一个空格。 示例1
输入 复制2 3 1 2 3 4 5 6
2 3 1 2 3 4 5 6 输出 复制1 4 2 5 3 6
1 4 2 5 3 6 代码： #include&lt;stdio.h&gt; int main() { int a, b; scanf("%d%d", &amp;a, &amp;b); int arr[15][15]; for (int i = 0; i &lt; a; i++) { for (int j = 0; j &lt; b; j++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4895fbd5b3ac2e629e423a2ba5c59c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53bbbf356f9dfdcd666fd169a9c5718d/" rel="bookmark">
			Linux学习-破解Root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 破解root密码思路 1）重启系统,进入 救援模式 开启虚拟机A，在此界面按e键 在linux开头的该行，将此行的ro修改为rw 然后空格输入 rd.break 按 ctrl x 启动，会看到switch_root:/# 2）切换到硬盘操作系统环境 # chroot /sysroot #切换环境，切换到硬盘操作系统的环境 3）重新设置root的密码 sh-4.2# echo 1 | passwd --stdin root 4）如果SELinux是强制模式，才需要SELinux失忆，其他模式不需要让SELinux进行失忆 sh-4.2# touch /.autorelabel #让SELinux失忆 或者可以修改SELinux运行模式，修改成宽松模式即可 sh-4.2# vim /etc/selinux/config #查看SELinux开机的运行模式 5）强制重启系统完成修复 sh-4.2# reboot -f #-f强制重启系统 才能 可以对救援模式设定密码防护，这样就不能随便去重置root密码了... 1.设置救援模式密码 [root@A ~]# grub2-setpassword Enter password: #输入密码，密码不显示 Confirm password: #重新输入密码，密码不显示 [root@A ~]# cat /boot/grub2/user.cfg #存放grub密码的文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7763f6757c7325559bed71baf755388/" rel="bookmark">
			Linux Ubuntu 修改 /etc/apt/sources.list (镜像源)文件(非常实用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改 /etc/apt/sources.list 文件，也即修改镜像源，能够加快在 Ubuntu 中下载和更新相关软件数据；否则默认情况下使用的是外网，下载起来比较慢！！！
基本步骤：
1、复制一份 /etc/apt/sources.list 文件，以作备用,其中 sources-bak.list 是备份文件名； sudo cp /etc/apt/sources.list /etc/apt/sources-bak.list 2、打开 /etc/apt/sources.list 文件；
sudo vi /etc/apt/sources.list 3、点击 D 删除里面的所有内容； 4、打开镜像源 阿里云镜像源链接 ； 5、找到 Ubuntu 对应版本的镜像； deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7763f6757c7325559bed71baf755388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf0b52670aad75b800237abb6a37b36/" rel="bookmark">
			【软件测试】Jmeter性能测试入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成脚本：
使用Jmeter手动编写脚本 使用Fiddler进行抓包
HTTP Cookie Manager: Cookie Policy-&gt;rfc2019?
(User Defined Variables)
HTTP Header Manager:
名称值User-AgentMozilla/5.0 (Windows NT 6.2; WOW64; Trident/7.0; rv:11.0) like GeckoAcceptimage/gif, image/jpeg, image/pjpeg, application/x-ms-application, application/xaml+xml, application/x-ms-xbap, /Accept-Languagezh-Hans-CN,zh-Hans;q=0.5 参照Fiddler中Headers内容
事务控制器下
http请求
名称+路径=网址
端口号：80端口、443端口、1080端口。例如http请求一般为80端口、https为443端口
Implementation=Java
协议：http or https
方法: Get or Post
自动重定向 勾选
http请求(参数化)
参照Fiddler中WebForms内容
(编码 勾选)
脚本写好后跳至步骤7
使用badboy录制脚本(即下面的1-4) 打开Badboy
输入网址
执行操作
另存为JMeter并放到一个文件夹中
打开JMeter （运行bin目录下jmeter.bat）
把存好的JMeter文件导进去
Thread Group 改名
线程数先设置为20个
Thread Group-&gt;添加-&gt;逻辑控制器-&gt;事务控制器
把请求（操作）放到事务控制器中，删除Step1
Thread Group 勾选调度器，持续时间按照要求（60秒)
Ramp-Up Period 设为1（Ramp-Up Period 设为10）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf0b52670aad75b800237abb6a37b36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1bcacedffd0b2774aae92431ae59ca/" rel="bookmark">
			Uncaught runtime errors:×ERRORRequest failed with status code 404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Request failed with status code 404 at createError (webpack-internal:///./node_modules/axios/lib/core/createError.js:16:15) at settle (webpack-internal:///./node_modules/axios/lib/core/settle.js:18:12) at XMLHttpRequest.handleLoad (webpack-internal:///./node_modules/axios/lib/adapters/xhr.js:56:7)
项目运行时，如果请求的接口不存在，是404的情况下，页面会整个弹出一个错误。具体情况如下：
这是我们不想让它遮挡页面，想让它在控制台提示即可。我们需要做如下的操作：
在 vue.config.js 中增加如下代码：
devServer: { client: { //当出现编译错误或警告时，在浏览器中是否显示全屏覆盖。 示例为只显示错误信息 overlay: { runtimeErrors: false, }, }, }, 注意：修改之后需要关闭服务，重新运行项目。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb5fe0c0fe7f5d10df5b1cefd366c7b/" rel="bookmark">
			【Rust】十分钟睡前开发 —— URL Shortener by Shuttle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: 十分钟睡前开发 —— URL Shortener by Shuttle
categories:
计算机
tags:翻译Rust
link: https://framist.github.io/post/ae049c5.html
date: 2023-10-30 本文翻译自 URL Shortener - Shuttle ，有少许修改。当个小软文看吧
现在，星期三晚上，我试图在入睡 —— 我看了下手机，现在是凌晨 2 点 54 分。当我意识到我将无法再次获得超过 5 小时的睡眠时，一种恐惧感笼罩着我。
我做软件开发人员已经将近 10 年了，我是怎么走来的？
我的部署在晚上十点崩溃了（因为我从不学习），我不得不在接下来的 3 小时内应对我们的基础设施和巨大的压力。当我坐在那里反思人生选择时，我有了一个想法。我们能做得更好吗？
我不想在午夜处理 Terraform 和 Kubernetes。我在部署的同时编写可扩展的代码。我希望为我的依赖会帮我自动生成和管理。我希望晚上能够入睡。
现在是 2022 年。当然，我们可以做得更好。当我茫然地盯着我的白色天花板时，我决定看看这是否可能。
我突然在床上坐了起来。我是否可以创建一个有用的应用程序，具有某种数据库状态，一个自定义子域，只关注我的应用程序代码，而不需要担心基础设施，并在 10 分钟或更短的时间内完成它？我会写一个 URL 缩短器什么的。我会用 Rust 写。我今晚会写它。
设计 我下了床，打开了办公室的灯。我坐在符合人体工程学的椅子上，打开了一个滑稽的大曲面显示器。Arch 启动！我赶紧在 Signal 上给我的一个朋友发消息，提醒他们我用的是 Arch。现在我已经准备好编码了。让我们来构建这个东西。
API 将很简单。没有理由使用 GUI 或类似的东西 - 我是工程师，因此我说服自己 UI 在 1970 年代的电传打字机中达到了顶峰。
生命是短暂的，所以我要构建一个 HTTP API。我能想到的最简单的事情。
您可以像这样缩短 URL：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fb5fe0c0fe7f5d10df5b1cefd366c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06544afa52ce919f860f7926777974bc/" rel="bookmark">
			Mysql 高阶自定义排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）FIELD函数实现 FIELD()函数返回值列表中值的索引位置，语法：FIELD(value, val1, val2, val3, ...)，简单的说：改函数就是返回value在集合(val1,val2,val3，...)中对应的索引位置，结合上面的需求,是不是可以这样来使用，学生表stage值就映射函数的value,(初中、高总、大学)就映射函数的值列表集合，如果学生.stage=初中，返回值不是就是1；学生.stage=高中，返回值不是就是2；学生.stage=大学，返回值不是就是3，在对结果值排一个序，不就满足要求了嘛，话不多说上代码：
SELECT id,name,stage FROM `user` ORDER BY FIELD(stage,"初中","高中","大学") asc; （二）LOCATE函数实现 FIELD(substr,str,pos)函数返回字符串substr在str中第一次出现的位置，pos可空，表示开始坐标，例如：
SELECT LOCATE("初中","初中,高中,大学");--返回1 SELECT LOCATE("高中","初中,高中,大学");--返回2 SELECT LOCATE("大学","初中,高中,大学");--返回3 这不就正好满足上述需求嘛，话不多说上代码：
SELECT id,name,stage FROM `user` ORDER BY LOCATE(stage,"初中,高中,大学") asc; （三）INSTR函数实现 INSTR(str,substr)函数返回字符串str中substr第一次出现的位置，例如：
SELECT INSTR("初中,高中,大学","初中");-- 返回1 SELECT INSTR("初中,高中,大学","高中");-- 返回2 SELECT INSTR("初中,高中,大学","大学");-- 返回3 这不就正好满足上述需求嘛，话不多说上代码：
SELECT id,name,stage FROM `user` ORDER BY INSTR("初中,高中,大学",stage) asc; （四）CASE WHEN语句实现 CASE WHEN简单的说就是根据不同的条件将其转换为指定的值，比如：根据stage 的不同值转换为对应的数字，在对结果排序满足要求了，话不多说上代码：
SELECT id,name,stage FROM `user` ORDER BY CASE stage WHEN "初中" THEN 1 WHEN "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06544afa52ce919f860f7926777974bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1312f5a3674e7ab8f341d76dd71f2fec/" rel="bookmark">
			通过usb接口串口发送接收数据的android程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USB通信使用系统api，USB转串口通信使用第三方库usb-serial-for-android，
串口通信使用Google官方库android-serialport-api。x
引入包后在本地下载的位置：C:\Users\Administrator\.gradle\caches\modules-2\files-2.1
在 Android 中，可以通过 USB 转串口适配器连接串口设备，并通过串口发送和接收数据。以下是一种常见的实现方式：
确认设备权限和支持：
1.在 AndroidManifest.xml 文件中添加 &lt;uses-feature android:name="android.hardware.usb.host" /&gt; 权限，以获取 USB 主机支持。
添加 &lt;uses-permission android:name="android.permission.USB_PERMISSION" /&gt; 权限，以获取 USB 设备权限。
2.获取 USB 设备列表：
使用 UsbManager 类的 getDeviceList() 方法获取已连接的 USB 设备列表。选择你需要连接的 USB 转串口适配器。
3.请求 USB 权限：
使用 UsbManager 类的 requestPermission() 方法向用户请求 USB 设备权限，并注册 BroadcastReceiver 监听权限授权结果。在广播接收器中处理权限授权结果。
4.打开和配置串口连接：
使用 UsbDeviceConnection 类的 open() 方法打开 USB 设备连接。
使用 UsbDeviceConnection 接口中的 setBaudRate()、setDataBits()、setStopBits()、setParity() 等方法配置串口参数。
5.发送数据：
创建 UsbDeviceConnection 对象后，通过 UsbDeviceConnection 的 bulkTransfer() 方法向串口发送数据。将要发送的数据作为字节数组传递给 bulkTransfer() 方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1312f5a3674e7ab8f341d76dd71f2fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e20dd9996cc75085a5cbd5eec94565/" rel="bookmark">
			软考网络工程师（第五版）个人学习笔记---思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分内容来源于网络，如有侵权，请及时联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1acbd58b7adcc2296896c2d88393bdf3/" rel="bookmark">
			spring整合的redis分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring整合了redis以后可以直接使用redis分布式锁，过程是：
引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt; &lt;artifactId&gt;spring-integration-redis&lt;/artifactId&gt; &lt;/dependency&gt; 注入RedisConnectionFactory到RedisLockRegistry，这是用来连接redis执行redis执行的 @Bean public RedisLockRegistry redisLockRegistry(RedisConnectionFactory connectionFactory){ return new RedisLockRegistry(connectionFactory,LOCK_KEY,5000L); } 注入RedisLockRegistry到要用redis锁的地方，然后使用即可 @Resource private RedisLockRegistry redisLockRegistry; //1.生成锁对象 Lock lock = redisLockRegistry.obtain(lockKey); //2.获取锁 if(lock.tryLock()){ try{ ......//3.业务代码 }finally{ //4.释放锁 lock.unlock(); } } 接下来看看这个redis分布式锁的实现原理，看下spring对细节的顶级处理。
首先obtain()方法就是从locks(Map&lt;String, RedisLockRegistry.RedisLock&gt;)中根据key获取RedisLockRegistry.RedisLock对象，这里用来map进行缓存，对相同的key取得的就是相同的对象，避免重复new降低效率。
public Lock obtain(Object lockKey) { Assert.isInstanceOf(String.class, lockKey); String path = (String)lockKey; return (Lock)this.locks.computeIfAbsent(path, (x$0) -&gt; { return new RedisLockRegistry.RedisLock(x$0); }); } tryLock()方法就是获取redis分布式锁的。首先尝试获取本地ReentrantLock可重入公平锁，当应用的线程第一次获取redis锁时，就会在redis中生成key表示自己获取到锁了，如果接下来时应用本地的线程来获取锁，就会直接通过ReentrantLock先拿锁，没拿到说明有线程拿到锁了，就不用去redis获取，可以提高效率。然后再到redis去获取分布式锁。
public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { long now = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1acbd58b7adcc2296896c2d88393bdf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa16ed6e2b1a28e8da74758a428eb23b/" rel="bookmark">
			mac使用VMware Fusion安装Centos 7系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac主机芯片：Apple M2 Pro
VMware-Fusion：13.5
centos：7
第一次操作：
按步骤选择操作系统
在选择虚拟启动虚拟机没有安装centos的界面 而是下图
改动：把UEFI换成BIOS ——&gt;无果
第二次操作：
直接将镜像拖到虚拟机 然后报错
找到大致原因 参考文档 重新换了镜像 成功
参考 https://blog.csdn.net/baidu_40468340/article/details/129066070
http://www.bryh.cn/a/415868.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2869c40063c145d36659022865fa2de4/" rel="bookmark">
			【分布式id生成系统——leaf源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式id生成系统——leaf源码 号段模式双buffer优化id获取 Leaf ，分布式 ID 生成系统，有两种生成 ID 的方式： 号段模式Snowflake模式 号段模式 由于号段模式依赖于数据库表，我们先看一下相关的数据库表：
biz_tag：针对不同业务需求，用biz_tag字段来隔离，如果以后需要扩容时，只需对biz_tag分库分表即可
max_id：当前业务号段的最大值，用于计算下一个号段
step：步长，也就是每次获取ID的数量
random_step: 每次getid时随机增加的长度
对应的实体类如下
import java.util.concurrent.atomic.AtomicLong; /** * @author left */ public class Segment { private AtomicLong value = new AtomicLong(0); //对 long 类型的变量进行原子操作，这里就是产生的id值 private volatile long max; //当前号段起始id private volatile int step; //每次缓存数量 private volatile int randomStep; //随机增长 private final SegmentBuffer buffer; //双buffer } 这样一看，就是在把数据库的自增方式放到了内存中，相当于加了一层缓存，减少了数据库的访问次数。但其实做的比这更好，程序通过一种双 Buffer 优化方式，提前缓存下一个 Segement，降低网络请求的耗时。
双buffer优化 思路如下
数据库表对应的实体类如下：
/** * @author leaf */ public class LeafAlloc { private String key; private long maxId; private int step; private String updateTime; private int randomStep; } 这个类是用于缓存的类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2869c40063c145d36659022865fa2de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5620305e0571c19f72a86327cfe85fd5/" rel="bookmark">
			mysql的sql_mode参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		msql修改了这个参数，首先mysql需要重新才能生效，还有就是java连接的springboot项目也需要重新启动。之前是遇到了下面的这个报错。只需要把sql_mode设置为空，重启mysql和服务就行
报错
In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column ‘haha.student001.name’; this is incompatible with sql_mode=only_full_group_by
数据库报错
原因：这个错误是由于MySQL的"ONLY_FULL_GROUP_BY" SQL模式导致的。在这种模式下，当使用聚合函数（如SUM、COUNT、MAX等）时，SELECT列表中的列必须要么是聚合函数的参数，要么包含在GROUP BY子句中。
解决方法：
SET sql_mode=(SELECT REPLACE(@@sql_mode,‘ONLY_FULL_GROUP_BY’,‘’));
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462c373f7efa74ea34b26b90fe8f010d/" rel="bookmark">
			Linux 之八 完整嵌入式 Linux 环境、构建工具、编译工具链、CPU 架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，工作重心要从裸机开发转移到嵌入式 Linux 系统开发，由于之前对嵌入式 Linux 环境并不是很了解，因此，第一步就是需要了解如何搭建一个完整的嵌入式 Linux 环境。现在将学习心得记录为此文。
嵌入式 Linux 环境 嵌入式 Linux 环境与我们熟悉的 PC 环境还是有很大区别的，要搭建出一套完整的嵌入式 Linux 环境需要做的工作相当多。下图是我根据学习整理的一个嵌入式 Linux 环境示意图，其中标号 1 ~ 4 就是需要我们构建的部分：
BootLoader：通常使用的是 U-Boot，就是一个复杂点的裸机程序。与我们通常编写的裸机程序（例如 ARM 架构）没有本质区别。BootLoader 需帮助内核实现重定位，BootLoader 还要给内核提供启动参数。
BootLoader 是无条件启动的，从零开始启动的。
Linux Kernel： 本身也是一个复杂的裸机程序。与裸机程序相比，内核运行起来后，在软件上分为内核层和应用层，分层后两层的权限不同，内存访问和设备操作的管理上更加精细（内核可以随便访问各种硬件，而应用程序只能被限制地访问硬件和内存地址）。
内核是不能开机自动完全从零开始启动的，需要 BootLoader 帮忙。
文件系统： 其中主要就是根文件系统（RootFS），包括 Linux 启动时所必须的目录和关键性的文件，例如，Linux 启动时都需要有 init 目录下的相关文件。Linux 启动时，必须首先挂载根文件系统，若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。
根文件系统是第一个需要使用我们自己的编译套件来编译的程序。
linux 程序编译工具链： 这个编译工具链用于编译出在我们的嵌入式 Linux 环境中运行的用户程序。通常这个编译工具链需要我们根据自己的嵌入式 Linux 环境自己编译。如果是直接买的 SoC 或者开发套件，SoC 或者开发套件厂家会自己编译好然后提供给客户。
通常采用交叉编译。自己编译出来的 linux 程序编译工具链通常会被称为 SDK。嵌入式 linux 编译套件往往不是通用的！linux 程序编译工具链也可以编译裸机程序，例如编译裸机 U-Boot、Linux Kernel。 但是通常不会使用 linux 程序编译工具链来进行纯裸机开发。 裸机程序编译工具链： 这个编译工具链编译出特定于架构的纯裸机程序以在指定架构上运行。一般由内核厂家提供，我们最为熟知的就是 ARM 提供的 GNU Arm Embedded Toolchain 中的 AArch32 bare-metal target (arm-none-eabi)、Keil 中的 armcc、IAR。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/462c373f7efa74ea34b26b90fe8f010d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4f0e4ca7f0d5efa6620bc53ad9c163/" rel="bookmark">
			总结避免死锁的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中用到一些多线程的知识，涉及到一个线程需要锁住多个资源的情况，这就会涉及到多线程的死锁问题。特此总结一下
死锁产生的方式有好几种，并不是只有一个线程涉及多个锁才会出现死锁的情况，单个锁也有可能出现死锁。
1、第一种常见的情况是加锁之后没有解锁。有可能是lock之后真的忘了unlock,这种比较少见也容易发现。但是有时候程序并不是跟我们预想的一样一帆风顺的走完流程，可能是在lock和unlock之间的代码出现了异常退出，这样就造成了加锁之后没有解锁，后续程序对该锁的请求无法实现，导致死锁等待。
解决方法：在c++语言中，就是利用所谓的Autolock局部对象，在该对象的构造函数中lock，在析构函数中unlock，因为是在栈中创建的对象，系统会自动执行析构函数，即使程序异常退出也会执行析构函数从而释放资源。
2、第二种是同一个线程中对同一个资源多次调用lock函数。有的互斥锁对象没有线程所有权属性，比如windows下的信号量Semaphores ，即一个线程获得某个信号量后，在他释放该信号量之前，他不能再次进入信号量保护的区域。如果信号量的计数只有1，同一个线程调用WaitForSingleObject两次，程序就会阻塞在第二次调用处造成死锁。
3、第三种情况就是我们通常所说的情况。有两个线程，线程1和线程2，有两个锁A和B，线程1持有A然后等待B，与此同时线程1持有B然后等待A。两个线程都不释放拥有的锁，也都获取不到等待的锁。
避免死锁一般针对的是第三种情况。
1、尽量不在同一个线程中同时锁住两个临界资源，不过如果业务要求必须这样，那就没办法。
2、有一种可行的办法是，多个线程对多个锁的加锁顺序一样，这样就不会发生死锁，比如线程1先对A资源加锁，再对B资源加锁，线程2也使用相同的顺序，就不会产生死锁。
3、还有一种可行的方案是一次性获取所有需要获取的锁，如果不能一次性获取则等待。我想了一下linux下可以用pthread_mutex_trylock函数来实现，伪代码如下(针对两个锁而言)：
while (true) { pthread_mutex_lock(&amp;mutexA); if (0 == pthread_mutex_trylock(&amp;mutexB)) { //成功获取所有锁 break; } else { //释放持有的锁，继续等待 pthread_mutex_unlock(&amp;mutexA); //延时一段时间再继续请求 usleep(10*1000); } } //业务代码 ... pthread_mutex_unlock(&amp;mutexA); pthread_mutex_unlock(&amp;mutexB); 4、还有一种方法是使用等待超时机制，如果等待一个锁太久没得到，就释放自己拥有的所有锁，避免死锁。这个方法感觉指标不治本，是处理死锁发生后的情况而不是有效的预防死锁。
5、听说还有一种是死锁检测机制。mysql数据库就具备死锁检测机制，死锁检测的算法目前没有研究过，感兴趣的同学可以自行研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72671ebef43cec03553d0fe40618de8/" rel="bookmark">
			【flink-sql实战】flink 主键声明与upsert功能实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. flink 主键声明语法二. 物理表创建联合主键表三. flink sql使用 一. flink 主键声明语法 主键用作 Flink 优化的一种提示信息。主键限制表明一张表或视图的某个（些）列是唯一的并且不包含 Null 值。 主键声明的列都是非 nullable 的。因此主键可以被用作表行级别的唯一标识。
主键可以和列的定义一起声明，也可以独立声明为表的限制属性，不管是哪种方式，主键都不可以重复定义，否则 Flink 会报错。
有效性检查
SQL 标准主键限制可以有两种模式：ENFORCED 或者 NOT ENFORCED。 它申明了是否输入/出数据会做合法性检查（是否唯一）。
Flink 不存储数据因此只支持 NOT ENFORCED 模式，即不做检查，用户需要自己保证唯一性。
注意: 在 CREATE TABLE 语句中，创建主键会修改列的 nullable 属性，主键声明的列默认都是非 Nullable 的。
sql声明语法：
CREATE TABLE [IF NOT EXISTS] [catalog_name.][db_name.]table_name ( { &lt;physical_column_definition&gt; | &lt;metadata_column_definition&gt; | &lt;computed_column_definition&gt; }[ , ...n] [ &lt;watermark_definition&gt; ] [ &lt;table_constraint&gt; ][ , ...n] ) ... &lt;column_constraint&gt;: [CONSTRAINT constraint_name] PRIMARY KEY NOT ENFORCED &lt;table_constraint&gt;: [CONSTRAINT constraint_name] PRIMARY KEY (column_name, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f72671ebef43cec03553d0fe40618de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80375650e77b2720ef26352b9d443dd/" rel="bookmark">
			springboot/java/php/node/python临沂大学实验室预约管理系统【计算机毕设】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本系统（程序+源码）带文档lw万字以上 文末可领取本课题的JAVA源码参考
系统程序文件列表 系统的选题背景和意义 选题背景： 随着科技的不断发展和应用，实验室在各个领域中扮演着重要的角色。实验室是科学研究、教学和创新的核心场所，为学生和教师提供了进行实验、探索和创新的平台。然而，传统的实验室管理方式存在一些问题，如预约流程繁琐、信息不透明、资源浪费等。因此，建立一个高效、智能的实验室预约管理系统具有重要的意义。
选题意义： 实验室预约管理系统可以提高实验室资源的利用率。通过系统化的管理和调度，可以合理安排实验室的使用时间和设备资源，避免资源的闲置和浪费。同时，系统可以根据实验室的特点和需求，优化资源分配，提高实验室的工作效率和产出质量。
实验室预约管理系统可以提升用户体验和服务质量。传统的实验室预约方式往往需要人工操作和沟通，容易出现信息不准确、预约冲突等问题。而通过引入智能化的管理系统，用户可以方便地查询实验室的可用时间、设备情况等信息，并进行在线预约，大大提升了用户的使用便利性和满意度。
实验室预约管理系统还可以加强实验室安全管理。通过系统的权限控制和记录功能，可以确保只有合法的用户才能进行实验室的预约和使用。同时，系统可以对实验室的设备状态进行监测和维护，及时发现和解决潜在的安全隐患，保障实验室的安全运行。
实验室预约管理系统还具有推动科研创新的作用。通过系统的数据统计和分析功能，可以为实验室的科研工作提供参考和支持。系统可以记录实验室的使用情况、设备故障情况等信息，为实验室的管理者提供数据支持，帮助他们更好地了解实验室的运行状况，并进行科学决策和优化调整。
综上所述，建立一个高效、智能的实验室预约管理系统对于提升实验室资源利用率、改善用户体验、加强安全管理以及推动科研创新具有重要的意义。
运行环境 开发工具：idea/eclipse/myeclipse
数据库：mysql5.7或8.0
操作系统：win7以上，最好是win10
数据库管理工具：Navicat10以上版本
环境配置软件： JDK1.8+Maven3.3.9
服务器：Tomcat7.0
技术栈 前端技术: 使用Vue.js框架构建用户界面，它是一个灵活且高效的JavaScript框架，适合构建现代化的单页面应用（SPA）。后端技术: 采用Spring Boot框架进行后端开发，Spring Boot是一个Java平台，它提供了快速搭建、开发、运行Spring应用程序的能力，极大地简化了配置和部署流程。数据库: 使用MySQL作为关系型数据库管理系统，存储应用数据，它是一个流行的开源数据库，适用于各种规模的应用程序。数据库可视化工具: Navicat用于数据库的可视化管理和操作，它支持多种数据库系统，提供了一个直观的用户界面来管理MySQL数据库。开发环境: 使用JDK 1.8进行Java应用的开发，这是Java开发的核心环境，包含了运行Java程序所需的库和工具。服务器: 使用Tomcat 7.0作为Web应用服务器，它是一个开源的Servlet容器，用于部署和运行Java Web应用程序。项目管理工具: Maven 3.3.9用于项目的构建和依赖管理，它通过pom.xml文件定义项目结构和依赖关系，简化了项目构建过程和库管理。 后端由Spring Boot提供支持，前端由Vue.js构建，数据存储和管理通过MySQL和Navicat实现，整个开发流程由Maven进行管理，并在Tomcat服务器上运行。
程序界面： 源码文末获取↓↓↓↓： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a002830cf2f51e81a997b7da2b0effea/" rel="bookmark">
			conda添加清华镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、conda下载 https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/
显示所有channel
conda config --show channels 二、添加清华镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --set show_channel_urls yes的意思是从channel中安装包时显示channel的url，这样就可以知道包的安装来源了。
输入conda config --show channels查看一下是否添加成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20452c28c1617fe47c692eb36d706411/" rel="bookmark">
			Gated Context Aggregation Network for Image Dehazing and Deraining（GCANet）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 总体概述 GCANet是端到端去雾的一篇代表性的文章，它摒弃以往使用手工设计的先验以及大气散射模型的使用，直接通过原始有雾图像估计出无雾图像J与有雾图像I之间的残差，图像恢复阶段直接使用网络输出的残差与输入有雾图像I之间的加和完成去雾过程。
文章本身最大的贡献：
1、借鉴并使用了平滑空洞卷积消除以往空洞卷积存在的网格伪影以及特征相关性不强的问题，提出了一个门限子网络，用于依据不同level的特征的权重进行特征加权融合
2、GCANet达到当前的SOTA,并且使用消融试验对不同模块重要性进行了分析
3、GCANet应用到去雨任务中依然获得了SOTA
2 灵感来源 之前的研究者利用扩张卷积来聚合上下文信息，可以获得更加细腻和准确的结果，主要原因是扩张卷积不损失分辨率，但是他也存在一些问题，比如网格伪影，远距离信息没有相关性。因此也有很多人去尝试改进上述问题，比如使用平滑空洞卷积来消除网格伪影；也有人使用不同level的特征图进行融合获得更好的去雾效果；也有使用使用gated fusion module ,但是它是直接使用原始图的拷贝而非中间所获取的特征图；GCANet借鉴了上述思想，使用了扩张卷积，借鉴了smooth 扩张卷积消除伪影，借鉴了融合特征图的思路，提出了一个门限子网络用于辨析不同level特征图的重要性
3 现有工作分析 去雾分为两种，其一是基于传统先验知识的去雾，其二是基于学习的方式， 区别就是第一种方案通过手工获取的先验知识在第二钟方案是通过学习获取
传统方案去雾
1、基于暗通道先验以及其对应的优化方案
2、最大对比度
3、颜色衰减先验等
深度学习去雾
1、使用端到端的深度学习方式，利用多尺度网络预测透射率图，但是透射率图估计的不准确导致去雾结果较差
2、将全局大气光值A以及透射率参数融合为一个参数，使用轻量级的网络进行预测
3、也有使用两个子网络分别预测全局大气光值A以及透射率参数，并依据大气散射模型进行图像去雾的
4 本文GCANet方法 整体架构是：首先使用编码模块将输入的有雾图像编码为特征；接着通过聚合上下文信息以及融合不同level的特征强化编码特征（主要使用平滑空洞卷积以及特殊设计的门限子网络）；最后使用一个解码网络将特征映射回原图空间，并加上原始图就可以获取最终的去雾图像
4.1 Smoothed Dilated Convolution 什么是网格伪影？
由上图可知，最右边的这一幅特征图中的红蓝绿黄色四种小点来自于之前特征层对应颜色的独立特征，特征之间没有交互，没有融合，导致最终获取的当前层的特征的之间没有相关性可言，造成局部信息丢失，这对于pixel_level的预测来说是极其致命的。
消除网格伪影有两种方式，第一种是在使用空洞卷积之前，使用共享可分离卷积先进行特征之间的融合；另一种方式是在卷积后特征整合之前，使用类似于shuffleNet一样的方式进行特征交互，具体可以参考如下链接：总结-空洞卷积(Dilated/Atrous Convolution)
本文采用第一种方式完成空洞卷积的网格效应消除
class ResidualBlock(nn.Module): def __init__(self, channel_num, dilation=1, group=1): super(ResidualBlock, self).__init__() self.conv1 = nn.Conv2d(channel_num, channel_num, 3, 1, padding=dilation, dilation=dilation, groups=group, bias=False) self.norm1 = nn.InstanceNorm2d(channel_num, affine=True) self.conv2 = nn.Conv2d(channel_num, channel_num, 3, 1, padding=dilation, dilation=dilation, groups=group, bias=False) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20452c28c1617fe47c692eb36d706411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d0a3e0cc26b9f5e78ce0210c0de400/" rel="bookmark">
			浅谈kotlin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常量和变量 常量与变量都可以没有初始化值,但是在引用前必须初始化编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。如果不在声明的时候初始化则必须提供变量的类型
var和val var是variable的缩写val是value的缩写,val是赋值一次只读属性
var sum1: Int = 3 val sum2: Int = 3 常量 const val url = "www.nuo.com" lateinit 关键字代表了 "晚期初始化"只有在程序的后期初始化时，才会为lateinit 变量分配内存，而不是在它们被声明时
lateinit var view：View 类型推断 var a = "haha"//推断类型Int 检查NUll //类型后面加?表示可为空 var age: String? = "28" //字段后面加"!!"抛出空指针异常 val ages = age!!.toInt() //字段后面加”？“不做处理返回 null val ages1 = age?.toInt() //使用”?:“ 表示age为空返回-1 val ages2 = age?.toInt() ?: -1 构造方法 class User { var name: String constructor(name: String) {//构造方法 this.name = name } } class User(var name: String) { } 静态方法 当你给一个类使用了object关键字这个类是单例所有属性和方法都是静态属性和方法 object User { fun test(){} } 在非单例类中添加静态属性和方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77d0a3e0cc26b9f5e78ce0210c0de400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957a5ea164d2c946c715db4bee807c53/" rel="bookmark">
			【软件测试】WebDriver入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
元素定位
Xpath定位
xpath定位优点
xpath定位缺点
xpath调试方法
xpath节点
xpath语法
CSS定位
1、css属性定位
2、css属性值模糊匹配定位
3、css标签定位
4、css层级关系定位
5、css索引定位
6、css逻辑运算定位
7、css元素状态定位
常用基本对象操作方法
单元素及多元素定位管理
一些对象及体系
Web功能测试示例
注：要先把Selenium以及对应浏览器版本的驱动配置好
Hello,world!
import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; ​ public class Test01 { public static void main(String[] args) { WebDriver wd=new ChromeDriver();//创建对象 wd.get("http://baidu.com");//打开网页 wd.manage().window().maximize();//窗口最大化 wd.close();//关闭网页 } } 元素定位 定位方法Java语言实现实例id 定位driver.findElement(By.id(“id的值”))；name定位driver.findElement(By.name(“name的值”))；链接的全部文字定位driver.findElement(By.linkText(“链接的全部文字”))；链接的部分文字定位driver.findElement(By.partialLinkText(“链接的部分文字”))；css 方式定位driver.findElement(By.cssSelector(“css表达式”))；xpath 方式定位driver.findElement(By.xpath(“xpath表达式”))；Class 名称定位driver.findElement(By.className(“class属性”))；TagName 标签名称定位driver.findElement(By.tagName(“标签名称”))；Jquery方式Js.executeScript(“return jQuery.find(“jquery表达式”)”) F12打开开发者控制台
Ctrl+F打开搜索框，在搜索框里可以搜索文本，css selector 和 xpath
Xpath定位 xpath即为XML路径语言（XML Path Language），是由国际标准化组织W3C指定的，一种用来确定XML文档节点位置的语言
xpath定位优点 相较于其他定位方式，可支持更多定位方法，如：布尔逻辑判断、模糊定位等
可支持web定位、Android app原生页面定位
xpath定位缺点 需要从头到尾解析整个页面，速度较慢
xpath调试方法 方法1：在浏览器开发者模式的elements中，Ctrl+F搜索栏输入xpath表达式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/957a5ea164d2c946c715db4bee807c53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6df380a7c794bcb5910413fefd3431/" rel="bookmark">
			Assimp编译与配置（VisualStudio 2019）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Assimp编译与配置 环境源码下载编译配置环境配置 Include 文件配置 .lib 文件配置 .dll 文件 测试 参考文章Assimp 编译（Visual Studio 2019）
使用vs2022编译assimp，并基于OpenGL加载模型
环境 win11
Assimp 5.2.5
VisualStudio2019
cmake 3.26
源码下载 Assimp releases
5.3版本我尝试用visualstudio2019编译失败，不知道什么原因，5.2是可以的
编译 下载源码之后解压文件
进入解压后的assimp-5.2.5路径，新建build文件夹作为输出目录
打开cmake的gui选择源码路径和输出目录
点击configure，弹窗中选择生成项目使用的VS版本，我这里用的是VS2019，点击Finish
可能会报错的提示找不到DirectX SDK
需要安装DirectX:官网下载
安装之前需要先卸载Microsoft Visual C++ 2010 x64 Redistributable和Microsoft Visual C++ 2010 x86 Redistributable这两个东西
安装好DirectX之后，再讲之前卸载的内容下载回来即可
下载地址
选择这两个内容下载
安装好DirectX之后再回到cmake点击configure
出现以下警告忽略即可，不影响
configure结束
点击genarate
点击open project，在VS中打开项目选中ALL_BUILD
在release模式下生成解决方案即可
运行结果
配置环境 配置 Include 文件 将build文件夹下的include复制到assimp源码中的include中，也就是将两个include合并到一起。然后在VisualStudio的项目中配置项目属性，在项目的包含目录中添加这个include路径即可。
配置 .lib 文件 编译好后\build\lib\Release路径下会生成assimp-vc142-mt.lib
将这个绝对路径添加到项目属性中的库目录中
然后在链接器-输入中添加lib文件名称
配置 .dll 文件 拷贝 build\bin\Release目录下的assimp-vc142-mt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e6df380a7c794bcb5910413fefd3431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a6435e0ac9eb6206c3f11c306991d43/" rel="bookmark">
			Dhtmlx KanBan 付费版使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div v-if="isShowToolbar" ref="toolbarRef" class="kanban-toolbar"&gt;&lt;/div&gt; &lt;div ref="kanbanRef" class="kanban"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { computed, onMounted, ref } from "vue"; import { kanban } from "./lib/kanban.dev.js"; import "./lib/kanban.css"; import { kanbanProps } from "./kanban"; import zhCN from "./locale/zh-CN"; defineOptions({ name: "Kanban" }); const { columns, columnsConfig, cards, cardConfig, cardHeight, editor, editorConfig, history, readonly, locale, isToolbar, } = defineProps(kanbanProps); const kanbanRef = ref(); const kanbanInstance = ref(); const toolbarRef = ref(); const toolbarInstance = ref(); const isShowToolbar = computed&lt;boolean&gt;(() =&gt; isToolbar); const { Kanban, Toolbar, defaultEditorShape } = kanban; onMounted(() =&gt; { kanbanInstance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a6435e0ac9eb6206c3f11c306991d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a178a065566effa7bbfa6152f0282db/" rel="bookmark">
			Dhtmlx Event Calendar 付费版使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div ref="eventCalendarRef" class="event-calendar"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { onMounted, ref } from "vue"; // @ts-ignore import { eventCalendar } from "./lib/event-calendar.dev.js"; import "./lib/event-calendar.css"; import { eventCalendarProps } from "./event-calendar"; defineOptions({ name: "EventCalendar" }); const { events, date, config, locale, mode, calendars, colors, editorConfig, editorValidation, } = defineProps(eventCalendarProps); const eventCalendarRef = ref(); const eventCalendarInstance = ref(); const { EventCalendar } = eventCalendar; onMounted(() =&gt; { eventCalendarInstance.value = new EventCalendar(eventCalendarRef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a178a065566effa7bbfa6152f0282db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c56ed8d25b7021e3e31305310173742c/" rel="bookmark">
			Java实现WebSocket客户端和服务端（简单版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天行健，君子以自强不息；地势坤，君子以厚德载物。
每个人都有惰性，但不断学习是好好生活的根本，共勉！
文章均为学习整理笔记，分享记录为主，如有错误请指正，共同学习进步。
文章目录 WebSocket简介1. 介绍2. 定义 开发环境功能实现1. 项目包结构2.项目创建3. WebSocket服务端创建1. 依赖引入2. 配置文件3. 项目启动类4. 配置类5. 服务端服务类6. 请求类7. 测试服务 4. WebSocket客户端创建1. 依赖引入2. 配置文件3. 项目启动类4. 配置类5. 请求类 5. 服务端和客户端交互测试1. 启动服务2. 客户端向服务端发送消息3. 服务端向客户端推送消息 写在前面：
网上看了很多关于WebSocket的文章，大多都是服务端的实现，然后用在线工具测试。 现在遇到的需求是客户端和服务端都要用Java实现，所以就有了这篇文章。 大多数文章的服务端实现都相当的精细，各种细节的处理，但很多都是代码不全。 对于刚接触WebSocket然后只想简单实现的人来说，着实有些吃力。 所以想把最简单的实现写出来分享，希望对大家有些帮助。 WebSocket简介 1. 介绍 WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 2. 定义 WebSocket 是独立的、创建在 TCP 上的协议。WebSocket 通过HTTP/1.1 协议的101状态码进行握手。为了创建WebSocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。 开发环境 JDK版本：1.8
maven版本：3.9.4
开发工具：IDEA 2023.2.1
项目框架：spring boot 版本为 2.7.3 springboot搭建传送门
功能实现 1. 项目包结构 2.项目创建 为了更方便操作，将两个服务放在一个项目里
首先创建父类项目websocket_client_server
项目创建可参考springboot搭建传送门
然后可以把src包删了
父类项目所需依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c56ed8d25b7021e3e31305310173742c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404cfaf7bac70dd1400e209669f880fa/" rel="bookmark">
			vitepress：编写vite插件实现vitepress自动sidebar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有用过vitepress的老表都知道，配置sidebar、nav这些是相当繁琐的一件事。nav还算好的，毕竟你的网页不可能有太多的nav。但是sidebar就头疼了，随着文档的增多，我们有必要将其自动化。
下面是我写的一个自动生成sidebar的nodejs脚本0.0.1，本来是想做成插件的，类似于vite-plugin-pages这种，奈何实力不允许。等我研究完vite和rollup再进行改造吧。
博客源码：GitHub - jyj1202/docs: 项目文档
2023.11.10更新
之前看了一下vite-plugin-page源码，并且发现vitepress已经有人写过自动生成sidebar的插件了，于是仿照着一下，写了一个自己版本的vite-plugin-vitepress-auto-sidebar插件，支持dev和build环境。由于已经有现成插件了，且我的插件配置代码就是抄的现成的，所以就没打算发布成插件。
主要改动是在运用vite的configureServer钩子这块，开发时使用watcher监听文件变化，监听到变换，立即重启开发服务器，重新修改sidebar配置项。
下面贴出核心代码：
vite-plugin-vitepress-autoSidebar插件代码：
/** * 只有目录可以作为sidebar; * 作为sidebar的目录必须以"-sidebar"结尾，并且只有最外层以-sidebar结尾的目录才会作为sidebar，子目录忽略 * 如果文件或目录以"-hide"结尾，则不会出现在sidebar中 * 如果目录名为"xxx-hide-sidebar"，则仍然会作为sidebar，对应sidebar名称为"xxx-hide" * 如果目录名为"xxx-sidebar-hide"，则不作为sidebar */ // const fs = require('fs').promises; // const path = require('path'); import * as fs from 'node:fs/promises'; import { fileURLToPath } from 'node:url'; import path from 'path'; import type { Plugin, ViteDevServer } from 'vite'; import type { UserConfig, FolderInfo, AutoSidebarOption } from "./type"; import type { DefaultTheme} from 'vitepress/types/default-theme.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404cfaf7bac70dd1400e209669f880fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c3fbae5fe5fa4d1049ece9f656cb41/" rel="bookmark">
			程序员的护城河是什么？是技术？还是沟通？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员的护城河主要是他们的技术能力和专业知识。这些技能和知识包括但不限于编程语言、算法和数据结构、系统设计和架构、网络安全和隐私保护等。
编程语言：程序员精通各种编程语言，如Java、Python、C++等，能够根据项目的需求选择最适合的编程语言进行开发。算法和数据结构：程序员理解和运用各种算法和数据结构来优化程序性能，解决复杂的问题，如排序、搜索、图像处理等。系统设计和架构：程序员具备设计和构建复杂系统的能力，包括后端服务、前端应用、数据库系统等，并能根据需求进行合理的架构选型和设计。网络安全和隐私保护：程序员了解并应用网络安全最佳实践，如加密、防火墙、安全协议等，以保护系统和用户数据的安全。同时，程序员也关注用户隐私保护，遵循相关的隐私政策和法规。 除了技术技能，程序员的护城河还包括他们的团队协作能力、解决问题的能力、持续学习的态度等。这些软技能使得程序员能够在不断变化的技术环境中保持竞争力，为组织和社会创造更大的价值
技术能力的深度、对创新的追求以及沟通协作等软实力也是程序员的护城河。
技术能力的深度：程序员的技术能力是他们的核心竞争力之一。他们需要具备扎实的技术基础，包括编程语言、算法和数据结构、系统设计和架构等方面的知识。同时，他们还需要具备深入的技术洞察力，能够预见并解决未来可能出现的技术问题。对创新的追求：程序员通常具备较强的创新意识和能力。他们不断探索新的技术趋势和最佳实践，并将这些应用到实际工作中。程序员还需要具备批判性思维和解决问题的能力，能够独立思考并找到创新的解决方案。沟通协作等软实力：程序员虽然主要与代码打交道，但良好的沟通协作能力也是必不可少的。他们需要与团队成员、产品经理、设计师等不同角色进行有效的沟通和协作，确保项目的顺利进行。此外，程序员还需要具备耐心、细心、责任心等品质，以确保代码质量和系统稳定性。 综上所述，技术能力的深度、对创新的追求以及沟通协作等软实力都是程序员的护城河，三者相辅相成，共同构成了程序员的核心竞争力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70280765e933ba16b8845e7e1d84bfeb/" rel="bookmark">
			HBuilderX使用代码托管功能，安装git插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBuilderX是前端开发人员可能经常会用的开发工具，有很好的语法提示和检查，今天就介绍一下HBuilderX中怎么才能提交代码到git仓库上。
下载并安装HBuilderX 首先，如果你还没有安装HBuilderX，需要下载并安装HBuilderX，HBuilderX的官网地址如下：
https://www.dcloud.io/https://www.dcloud.io/访问上方网址，点击红框内的导航菜单。
然后点击页面的下载按钮
下载完成后，把压缩包解压到D盘，比如D:/program。
至此，HBuilderX的下载和安装就完成了。
使用HBuilderX 打开HBuilderX的安装目录，双击HBuilderX.exe可执行文件打开HBuilderX。
HBuilderX的界面长这样
点击左上角的工具栏文件(F) &gt;&gt; 新建(N) &gt;&gt; 项目可以创建多种不同类型的项目，也可以从代码托管平台导入项目。
开启代码托管 HBuilderX支持git功能需要安装git的插件，点击上方工具栏的工具(T) &gt;&gt; 插件安装(P)，打开插件界面
如图，在已安装插件中可以看到博主之前安装的git插件
默认是没有安装这个插件的，点击右边的选项
然后在插件页面搜索git，第一条搜索结果就是，鼠标点击进去
接着，点击下载插件并导入HBuilderX，下载要求先登录，按要求登录即可。
完成git插件安装之后，还需要安装另外一个工具，下面的是汉化包。
在使用git功能的时候就会提示安装， 这里就不过多介绍了。
使用代码托管功能 第一次提交 当一切都准备就绪之后，可以右键单击我们的项目，点击右键菜单的托管项目到Git平台。
然后来到创建git仓库阶段，输入项目描述，点击【托管】按钮。
紧接着，勾选需要提交的文件，点击红框内【提交并推送】按钮
推送最新代码 在右键菜单中依次点击Git(G) &gt;&gt; 添加(A)把当前代码添加到git中，然后再点击提交按钮即可提交。
好了，关于HBuilderX使用代码托管功能的介绍就到这里了，看完不要忘了点赞+收藏哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ddf2226ebc379c1c62e0de166c3982/" rel="bookmark">
			使用 pubsub-js 进行消息发布订阅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm 包地址
github 包地址
pubsub-js 是一个轻量级的 JavaScript 基于主题的消息订阅发布库 ，压缩后小于1b。它具有使用简单、性能高效、支持多平台等优点，可以很好地满足各种需求。
功能特点： 无依赖同步解耦ES3 兼容。pubsub-js 能够在任何可以执行 JavaScript 的地方运行。AMD / CommonJS 模块支持不修改订阅者（jQuery 自定义事件修改订阅者）易于理解和使用（得益于同步解耦）小（ish），压缩后小于 1kb 获取 pubsub-js 你可以通过以下几种方式获取 pubsub-js。
使用 NPM 包 首先，你需要在项目根目录下使用以下命令安装 pubsub-js：
# 使用 pnpm 安装 pnpm add pubsub-js # 使用 npm 安装 npm install --save pubsub-js # 使用 yarn 安装 yarn add pubsub-js 使用 CDN 你还可以通过 CDN 获取构建好的 pubsub-js 文件。将以下代码添加到 HTML 文件的 &lt;script&gt; 标签中：
&lt;script src="https://unpkg.com/pubsub-js"&gt;&lt;/script&gt; &lt;!-- or --&gt; &lt;script src="http://www.jsdelivr.com/#!pubsubjs"&gt;&lt;/script&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ddf2226ebc379c1c62e0de166c3982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ac0e69845e7f95368ddf502d9e8801/" rel="bookmark">
			Yolov8模型训练报错：torch.cuda.OutOfMemoryError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用自己的数据训练Yolov8模型的时候遇到了很多错误，下面将逐一解答。
问题报错 在训练过程中红字报错：torch.cuda.OutOfMemoryError: CUDA out of memory.
后面还会跟着一大段报错：
Tried to allocate XXX MiB (GPU 0; XXX GiB total capacity; XXX GiB already allocated; 0 bytes free; XXX GiB reserved in total by PyTorch) If reserved memory is &gt;&gt; allocated memory try setting max_split_size_mb to avoid fragmentation. See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
报错信息如下图：
原因分析 其实这是因为训练时读取的图像数据太大，超出了GPU的显存。
可以看到我这台电脑是GTX2060，显存6G，读取的图像信息已经到了5.17G，无法再进行模型训练。
解决方案 在遇到此类问题时，我们可以调整两个部分的代码。
首先，yolov8的模型训练代码如下：
from core.ultralytics import YOLO model = YOLO("runs/detect/train_2048_91_200/weights/last.pt") # 读取断点模型训练 # # Train the model results = model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ac0e69845e7f95368ddf502d9e8801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbe0088440eb6d333709272ceb60cecb/" rel="bookmark">
			pnpm-workspace实现monorepo 组件库开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件库开发 环境搭建 menorepo
pnpmpnpm-workspacelerna 7.4.2 （已全局安装lerna） 1、初始化 1.1 新建项目目录root
1.2 在目录root中使用pnpm初始化packages.json文件，新建 pnpm-workspace.yaml文件， packages/文件夹
pnpm-workspace.yaml有这个文件表示开启工作区。
文件内容如下：
// root/pnpm-workspace.yaml packages: - "packages/*" // root/lerna.json { "version": "0.0.0", "npmClient": "pnpm" } 1.3 在root/packages/文件夹中新增子项目，使用lerna create &lt;button&gt;创建button子项目。
​ 或直接新建对应文件夹以及其中的文件…
使用lerna create &lt;button&gt;创建的button子项目内容如下
root/ | |packages/ | |button/ |__test__/ 测试文件存放 |src/ 项目代码 |index.vue |index.js 入口文件 |packages.json |READEME.md root/ packages/ button/ src/ index.vue 文件写入内容
&lt;template&gt; &lt;h1&gt;this button component 123&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'ls-button', setup() { } } &lt;/script&gt; root/ packages/ button/ index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbe0088440eb6d333709272ceb60cecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83fb861ac663682553bfdc3a2d09ccf9/" rel="bookmark">
			[最新]Claude或将不再支持个人免费用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就在今天晚上，打开slack app询问问题时，claude不再回复我答案，转为提示：
"We now require billing permission so we can check your Slack subscription status (only Enterprise Grid accounts are supported). Uninstall and then reinstall the app to continue."
"我们现在需要计费权限，以便检查您的Slack订阅状态（仅支持企业网格帐户）。卸载然后重新安装应用程序以继续。"
一开始没看清，以为又是墙的问题，开梯子把app卸了重装后仍然这么提示。于是把工作区注销了，用谷歌浏览器清空cookie、改电脑和浏览器时区重新注册了一个工作区账号，终于发现问题不是出在账号地区上
而这个所谓的Enterprise企业账号呢，是需要在网站上提交申请表注册的
早在今年四月网上就有反映过出同样问题的了。注册得比较早的账号，可能正在一批批取消claude的使用，新注册的工作区怕是直接不能用。我算是注册得比较早的一批了，今天上午在用claude查资料，晚上就没法使用。
那就告别吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c64c66dc2c1f0a7a77b16a63df5f154b/" rel="bookmark">
			Java面试题-Redis-第四天（线程模型一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Redis为何选择单线程？
二、Redis真的是单线程吗？
三、Redis6.0为何引入多线程
四、Redis6.0引入多线程之后，性能的提升效果如何？
一、Redis为何选择单线程？ 通常对于一个数据库来说，CPU通常不是瓶颈，因为大多数请求都不是CPU密集型的，而是IO密集型的，具体到Redis的话，如果不考虑RDB/AOF持久化方案，Redis是完全的内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis真正的性能瓶颈在于网络IO，也就是就是客户端和服务端之间的网络延迟，而为了减少延迟，Redis选择了单线程的IO多路复用实现它的核心网络模型
具体来说：
1. 避免过多的上下文切换，如果是单线程则规避了进程内频繁的线程切换开销。因为程序始终运行在进程的单个线程内，没有多线程切换场景
2. 避免同步锁的开销 如果说Redis选择多线程模型，因为Redis是一个数据库，势必涉及到底层数据同步的问题，必然会引入某些同步机制。比如锁，而且我们知道 Redis不仅提供了key - value数据结构，而且还有list、set、hash等结构。不同的数据结构对同步访问的加锁粒度是不同的。可能会导致在操作数据的过程中会带来很多加锁解锁上面的开销。增加程序复杂度的同时还会降低性能
3. 简单可维护：如果说Redis使用多线程模式，那么底层所有的数据结构都必须设计为线程安全的，这无疑会使得Redis的实现变得更为复杂
二、Redis真的是单线程吗？ 主体核心来说是单线程的 就是执行命令仍然是单线程的
但是有两个节点需要注意是多线程的：
redis4.0：引入多线程处理异步任务
主要就是针对那些非常耗时的命令，将这些命令异步话，防止阻塞
redis6.0：在核心网络模型中引入了多线程IO
但是这个主要是为了处理网络数据的读写和协议的解析，执行命令仍然是单线程
三、Redis6.0为何引入多线程 随着互联网的高速发展，互联网业务系统要处理的线上流量越来越大，这样的话Redis的IO瓶颈会越来越大，Redis的单线程模型会导致系统消耗很多的CPU时间在网络IO上面，从而降低了吞吐量
要提升Redis的性能有两个方向：
1. 优化网络模型
2. 提高机器内存读写速度
后者依赖于硬件，暂时无解。只能从前者入手：网络IO的优化可以分为两个方向：
1. 零拷贝或者DPDK技术
2. 利用多核优势
零拷贝技术有其局限性，无法适配Redis这一复杂的网络IO场景。
而DPDK技术通过旁路网卡IO绕过内核协议栈太过于复杂可能还需要内核甚至是硬件的支持
总结来说，Redis支持多线程就两个原因：
1、充分利用CPU资源
2. 分摊Redis 同步IO读写负担
四、Redis6.0引入多线程之后，性能的提升效果如何？ Redis作者说这个性能至少提升一倍
国内也有大牛测试过性能几乎翻倍了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9302eb283beccda8b8f2cae895ab970b/" rel="bookmark">
			DehazeNet: An End-to-End System for Single Image Haze Removal（端到端的去雾模型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、论文去雾总体思路 DehazeNet是2016年华南理工大学的研究者提出的一个端到端的深度学习模型，该模型主要通过输入的原始有雾图像拟合出该图所对应的medium transmission map（透射率t值图），并使用引导滤波对t值进行refine，接着通过medium transmission map中前0.1%的值所对应的原始图像的RGB值的均值求取全局大气光值，利用现有的大气散射模型完成图像去雾操作。
文章的主要贡献:
1、通过特殊的网络设计构建了一个端到端的网络，利用原始雾天图像直接拟合对应的透射率图像t，进而达到去雾的目的
2、提出了一个非线性的双边整流线性激活函数模块（BReLu）,并验证了它的有效性（减少搜索空间，加速模型收敛）
3、建立了DehazeNet与现有的假设先验之间的联系，并解释了通过自动学习来优化和改善之前的先验假设
2、既有模型简介 2.1 大气散射模型 由上图可知，阳光在物体表面形成反射光 J(x)，反射光在穿过雾霾的过程中发生散射，只有部分能量 J(x)t(x) 能到达摄像头。与此同时，阳光也在悬浮颗粒表面散射形成大气光 α 被摄像头接收。因此，摄像头中的成像 I(x) 可由两部分组成，透射的物体亮度 J(x)t(x) 和散射的大气光照 α(1－t(x))。
大气散射模型是图像去雾的核心公式，由上述描述可知，最终到达镜头呈现出来的图像包含两部分：透射的物体亮度 J(x)t(x)以及散射的大气光照 α(1－t(x))，具体公式如下所示：
2.2 既有先验模型 （1）暗通道先验
参考之前的文章：Single Image Haze Removal Using Dark Channel Prior(暗通道先验)
（2）最大对比度方法
雾霾会降低物体成像的对比度：Σx‖ΔI(x)‖=tΣx‖ΔJ(x)‖≤Σx‖ΔJ(x)‖。因此，基于这个推论可利用局部对比度来近似估计雾霾的浓度。同时，也可以通过最大化局部对比度来还原图像的颜色和能见度
（3）颜色衰减先验
颜色衰减先验（CAP）是一种与暗通道先验（DCP）相似的先验特征。观察发现雾霾会同时导致图像饱和度的降低和亮度的增加，整体上表现为颜色的衰减。根据颜色衰减先验，亮度和饱和度的差值被应用于估计雾霾的浓度
（4）色调视差
3、DehazeNet总体概况 模型的整体架构包含四个大块，分别是特征提取，主要是通过卷积+maxout激活函数；多尺度特征映射，主要借鉴xception网络，使用3、5、7三种不同大小的卷积获取不同感受野的特征并进行通道拼接；局部极值，利用maxpooling完成极值的求解；非线性回归，使用一个6*6的卷积+BReLU完成非线性映射。
3.1 特征提取 传统图像提取特征都会需要一定的假设和先验，但是这些手工设计的或者假设的特征并不是在所有情况下都适用。在观察了暗通道先验、最大对比度先验、颜色衰减先验的实现原理后，作者提出可以使用相对应的卷积核去卷积原始图像并加上非线性激活后的特征等效代替上述先验特征。此处使用maxout激活函数主要是将通道分段，提取不同的通道的最大值，结合不同的卷积核，可以得到类似暗通道先验、最大对比度先验、颜色衰减先验等的效果，并且可以带来更强的拟合性能。
此处的卷积使用的是5*5的卷积核，输入是3通道输出是原始输入图片的宽（输入数据大小16*16），激活函数是maxout，该激活函数和普通的激活函数不太一样，如下为对比
对于普通的激活函数，z=w*x+b而言，out=f(z)，其中f就是我们常用的激活函数，比如ReLU,Sigmod等
针对maxout不一样的点在于，如果我们设置maxout的组数K为5，则会在每个神经元的前面多出一层，这一层有5个神经元，如下图所示。
那么maxout的计算公式就变成了：
z1=w1x+b1
z2=w2x+b2
z3=w3x+b3
z4=w4x+b4
z5=w5*x+b5
最终的输出为out = max(z1,z2,z3,z4,z5)
差别就在于：常规的激活函数主要针对单个神经元，比如ReLU，输出的max(0,x)；而针对maxout这样的激活函数，是将多个神经元分为一组，整体求最大值。maxout相对其它激活拥有更好的拟合效果
3.2 多尺度映射 多尺度特征在图像去雾中应用广泛，原因是它可以获取尺度不变性，使得获取的特征更加鲁棒，受inception模块的启发，作者使用3*3,5*5以及7*7的卷积核去获取不同的特征，并进行聚合，增强特征对多尺度物体的泛化能力。
3.3 局部极值 使用局部极值的原因类似于其它先验算法里面的假定局部透射率不变作用一样，文中使用maxpool去代替之前的局部透射率不变先验操作，这里使用的是7*7的局部区域。
3.4 非线性回归 图像恢复领域，最后一层的输出值一般是上限和下限处于一个小范围的，sigmoid以及relu都不太适合作为激活函数，前者由于梯度爆炸问题，后者由于无上限都不适合，本文提出使用BReLU激活函数，限制激活后的值处于tmin以及tmax之间，实际有点类似Hardtanh函数，作者在实现的时候也是继承这个函数去实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9302eb283beccda8b8f2cae895ab970b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933812a3cf87f8e722b978e8541bc87a/" rel="bookmark">
			【Leetcode】383. 赎金信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true ；否则返回 false 。
magazine 中的每个字符只能在 ransomNote 中使用一次。
示例 1：
输入：ransomNote = "a", magazine = "b" 输出：false 示例 2：
输入：ransomNote = "aa", magazine = "ab" 输出：false 示例 3：
输入：ransomNote = "aa", magazine = "aab" 输出：true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c5f047f4192239d3ff90220df52e63/" rel="bookmark">
			linux常见命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aeed866052ab32c1d839eae08097807/" rel="bookmark">
			4K壁纸下载器，多种风格壁纸，一键批量下载到本地，桌面壁纸，高清壁纸，壁纸下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个桌面壁纸爬虫工具，该工具可以从内置的多个壁纸网站爬取高清壁纸，并支持将壁纸一键下载到本地，真正实现了所见即所得，不必再费心费力的翻看多个网站。
文末附工具下载链接~
一、软件简介 本次带来的工具由吾爱的一位大佬开发，经过近一年的迭代更新，目前最新版是1.6版本，该版本中内置了5个壁纸站点，壁纸资源非常丰富，而且壁纸风格也比较全面，之前非常火爆的AI绘画类型壁纸也可以找到。在一些站点中还支持下载手机壁纸。
先上一波小编认为还比较好看的壁纸~
二、使用方法 该软件不需要安装，双击即可进入主界面，主界面非常简洁，如下图所示。
主界面左侧为软件爬取到的壁纸资源列表；右侧最上方为功能区，可以切换壁纸站点；右侧中部为壁纸预览区，点击左侧的列表中的链接，即可预览对应的壁纸；右侧最下方为待下载资源列表，可以将喜欢的壁纸链接保存在这里，然后统一下载。
目前软件内置了5个壁纸资源站点，选中某个站点后，点击【开始爬虫】按钮即可从左侧资源列表看到壁纸资源。
在爬取壁纸完成后，可以使用【鼠标左键】点击左侧列表中的壁纸链接来查看壁纸预览图，使用键盘的【↑】【↓】可以上下切换壁纸。
使用【鼠标右键】点击左侧列表中的壁纸链接或先用鼠标左键选中壁纸，然后按键盘的【End】键可以将对应的壁纸添加到右侧待下载列表中，如下图所示。
下载壁纸有两种方式，一个是点击【下载全部】按钮，这可以将爬取到的所有壁纸通通下载到本地；另一种方式是通过上面讲的方式将喜欢的壁纸添加到右下方的待下载列表中，然后点击【下载选中】按钮，这将只下载待下载列表中的壁纸文件。
下载完成后将弹出一个提示框，在提示框中点击【是】即可打开壁纸所保存的文件夹，默认情况下，保存壁纸的文件夹和软件主体在同一文件夹下。
注意 经过实测，多次下载可能出现壁纸被覆盖的情况，尤其是使用【下载选中】进行下载，该下载模式下壁纸命名的方式为从0开始的纯数字，如果上一次下载的壁纸没有及时转存到其他文件夹，下一次再次使用【下载选中】下载壁纸就会覆盖掉之前下载的壁纸。
为了避免之前下载的壁纸被覆盖掉，建议每次下载完成后，将下载的壁纸手动保存到其他文件夹。
三、下载链接 链接1
https://pan.baidu.com/s/1TjgmtQ7IhHgcHK77nA_Vug?pwd=7gzg
链接2
https://donot996.lanzoub.com/b048vcp3e
密码：8bb8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7948a0d25e8ea722064c80c1e1c3426/" rel="bookmark">
			配置VTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设置域名 Switch&gt;en
Switch#conf t //进入全局配置模式
Switch(config)#vtp mode server //进入vtp服务模式
Device mode already VTP SERVER.
Switch(config)#vtp domain hhh //设置域名为hhh （区分大小写）
Changing VTP domain name from NULL to hhh
2.设置密码及查询 Switch(config)#vtp password class //设置密码为class
Setting device VLAN database password to class
Switch(config)#do show vtp pass //查询密码
VTP Password: class
3.查看vtp状态 Switch(config)#do show vtp status //查询vtp状态
图3-1 4.将S2和交换机Core加入VTP域中 下面以Core为例，两者相同 Core(config)#vtp mode client //客户端模式（该模式下不能创建、删除、修改vlan）
Setting device to VTP CLIENT mode.
Core(config)#vtp domain hhh //设置域名为hhh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7948a0d25e8ea722064c80c1e1c3426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77a20de174ef65ba455c772371d0a743/" rel="bookmark">
			顺丰接口对接-订单创建与取消（java单元测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		api文档 下单接口 ：https://qiao.sf-express.com/Api/ApiDetails?level3=393&amp;interName=%E4%B8%8B%E8%AE%A2%E5%8D%95%E6%8E%A5%E5%8F%A3-EXP_RECE_CREATE_ORDER
取消订单接口： https://qiao.sf-express.com/Api/ApiDetails?level3=339&amp;interName=%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4%2F%E5%8F%96%E6%B6%88%E6%8E%A5%E5%8F%A3-EXP_RECE_UPDATE_ORDER
每个接口需要测试成功三次才可上线下单接口上线需要上传电子面单，下线订单量不大时可以走免面单申请，不需要提交电子面单也可以上线接口 单元测试类 package com.cqdh.group.applet; import cn.hutool.core.lang.UUID; import cn.hutool.http.HttpRequest; import cn.hutool.http.HttpResponse; import org.apache.commons.codec.binary.Base64; import org.junit.Test; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.security.MessageDigest; /** * @Description 顺丰API测试 * @Date 2023/10/17 16:21 * @Author 余乐 **/ public class SFApiTest { /** * 客户编码 */ private static final String partnerID = "ZYHNYK*****"; /** * 测试环境url */ private static final String url = "https://sfapi-sbox.sf-express.com/std/service"; /** * 校验码 */ private static final String checkWord = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77a20de174ef65ba455c772371d0a743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfe8426c742ab6105779d6fc336541a/" rel="bookmark">
			linux ZYNQ 中使用 GPIO子系统leds-gpio驱动控制EMIO的LED灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在使用zynq是最初使用的是axi-gpio,但是想在linux应用层控制，当时网上也有相关的驱动，但是感觉不是自己想要的，自己就将axi-gpio在系统的gpio子系统中使用，发现驱动中失败，在传创建class/leds下的设备文件是出错，就想到了axi-gpio是不是不支持，将其改为gpio后成功，具体原因后续在补充。
1.使用axi-gpio 1.1vivado工程 引脚约束
1.2设备树配置 具体原因可能是axi-gpio不能这么使用，后续在补充，以下将记录从axi-gpio改为EMIO。
2.使用EMIO 2.1使用linux gpio指令测试 2.1.1修改vivado工程 2.1.2使用GPIO指令直接测试 2.1.2.1产看gpio的基础编号 进入目录：cd /sys/class/gpio/
查看：ls
其中903（gpiochip903）为gpio的基础编号；
2.1.2.1计算gpio编号 gpio的计算公式为base+mio+EMIO；
我的设备基础gpio编号为903，以LED_RED为例进行计算：
gpio编号为：903+54（mio：0-53，共54个）+ 5(EMIO（从零开始 4对应的是第5个）) = 962；
2.1.2.1导出gpio 导出：echo 962 &gt; /sys/class/gpio/export;
2.1.2.1设置gpio的方向 设置方向：echo out &gt; /sys/class/gpio/gpio962/direction;
2.1.2.1测试 echo 1 &gt; /sys/class/gpio/gpio962/value;
2.2使用leds-gpio驱动测试 2.2.1修改设备树 设备树中的gpio编号需要注意，一般会写成即gpio_0中的编号，如下：
设备树中不能写上面的编号，需要加上54个MIO的编号，我就在这里出过问题，即：从54开始，54对应的是0，那么设备树如下配置：
2.2.2擦看驱动结果 进入目录：cd /sys/class/leds/
查看：ls
2.2.3测试 查看当前值：cat PS_RUN/brightness
设置0：
灯已熄灭
设置1：echo 1 &gt; PS_RUN/brightness 灯亮，
注意上面设置1或者255均可以，
3.leds-gpio设备树 3.1leds-gpio 设备树字段的说明： 3.2设置方式和电平的关系 3.3触发方式 触发方式linux,default-trigger = "default-off";
触发方式类型可以参考使用内核里面的支持项，源码在drivers\leds\trigger下面
drivers/leds/trigger/ledtrig-activity.c
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfe8426c742ab6105779d6fc336541a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbbeaa748e5c4d515586a88e1085c2f1/" rel="bookmark">
			蛤蟆先生去看心理医生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		儿童自我状态指行为和感受都像一个孩子，这不同于幼稚，而是像孩子一样。
儿童自我状态是由我们童年残留的遗迹搭建而成，包含我们小时候体验过的所有情感。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9ba9d4d14713bc21cd523e5a2c2877/" rel="bookmark">
			【数据结构】平衡树之AVL树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然二叉搜索树可以大大提升查找的效率，但如果数据本身有序或接近有序，二叉搜索树将退化为单支树，此时借助它查找元素就相当于在顺序表中搜索元素，效率反而大大降低（详情可见【数据结构】二叉搜索树）。 为了解决二叉搜索树退化为单支树影响效率的问题，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年发明了一种方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1，即可降低树的高度，从而减少平均的搜索长度，提高效率。
基于这种方法改进而来的二叉搜索树，被命名为AVL树（由两位数学家的名字而来）。
AVL树是二叉平衡搜索树的一种，因其结构本质为“通过子树的高度差来控制平衡”，也被称为高度二叉平衡搜索树。
本篇博客将通过对AVL树主要性质的梳理和主要功能的模拟实现，帮助读者更加全面地理解AVL树。
目录
一、AVL的性质
二、AVL树的模拟实现
1 - 树的构建
2 - 插入及旋转
2.1.左单旋 2.2.右单旋 2.3.右左双旋
2.4.左右双旋
3 - 完整代码
补、一些迷思
1. AVL树的平衡为什么不是高度相等？
2. 增删查改的时间复杂度：高度次 - O(logN)
3. AVL树的性能问题 4.数据的查找方案一般有哪些？ 一、AVL的性质 控制一个节点的左右子树高度之差，是使AVL树平衡的一种重要手段。为了方便描述左右子树高度之差，我们将其称为平衡因子。在一棵平衡的AVL树中，任意节点的平衡因子值应为-1、0和1。
平衡因子是判断一棵树高度平衡的重要条件。如果一棵二叉搜索树满足了高度平衡的条件，那么它就是AVL树。
对于任意一棵AVL树，它都具有如下性质：
任意树节点的左右子树都是AVL树；任意树节点的平衡因子取值范围为[-1,1]。 如果它有n个结点，其高度可保持在O(logN)，搜索查找的时间复杂度为O(lognN)。
二、AVL树的模拟实现 1 - 树的构建 //此处树节点被定义为三叉链结构，每个节点中都有平衡因子 template&lt;class K,class V&gt; struct AVLTreeNode { pair&lt;K, V&gt; _kv; AVLTreeNode&lt;K, V&gt;* _left; //左孩子 AVLTreeNode&lt;K, V&gt;* _right; //右孩子 AVLTreeNode&lt;K, V&gt;* _parent; //双亲 int _bf; //平衡因子 balance factor // AVLTreeNode的构造，对树节点做初始化 AVLTreeNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) ,_left(nullptr) ,_right(nullptr) ,_parent(nullptr) ,_bf(0) {} }; //AVL树 template&lt;class K, class V&gt; class AVLTree { typedef AVLTreeNode&lt;K, V&gt; Node; public: //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe9ba9d4d14713bc21cd523e5a2c2877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67aa24f48bb0736015d2cde03e084db4/" rel="bookmark">
			Spring Boot2中配置HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：微点阅读 https://www.weidianyuedu.com
1.生成证书
使用jdk，jre中的keytool.exe生成自签名的证书，需要配置JAVA_HOME和path环境变量，即jdk的环境变量。命令如下：
keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650
然后可以找到C:/用户/用户名/keystore.p12，复制到springboot项目根目录
2.加入页面和映射
添加一个index.html页面在resources/stastic下面
并添加一个配置类MVCConfig
@Configurationpublic class MVCConfig implements WebMvcConfigurer { public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController("/").setViewName("/index"); registry.addViewController("/index").setViewName("/index"); } }
3.springboot 配置SSL
在application.properties中配置
server.port=8080#SSL https证书配置server.ssl.key-store=keystore.p12server.ssl.key-store-password=123456#行业标准PKCS12server.ssl.key-store-type=PKCS12server.ssl.key-alias=tomcat
现在就可以访问https://localhost:8080/index了
4.http转向https
在MVCConfig加入如下代码
/*配置http自动转为https*/ @Bean public ServletWebServerFactory servletWebServerFactory(){ TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(){ @Override protected void postProcessContext(Context context) { SecurityConstraint securityConstraint = new SecurityConstraint(); securityConstraint.setUserConstraint("CONFIDENTIAL");//机密的 SecurityCollection securityCollection = new SecurityCollection(); securityCollection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67aa24f48bb0736015d2cde03e084db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882e3b0d00b2ba36f7d091b98c9ffe32/" rel="bookmark">
			安装nginx时./configure报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、第一个错误： ./configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre=&lt;path&gt; option 解决方法： yum -y install pcre 或者 sudo yum -y install pcre 安装完成之后输入：
./configure --user=nginx --prefix=/usr/local/nginx --with-http_ssl_module --with-http_realip_module --with-http_image_filter_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_stub_status_module --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --without-http_rewrite_module 2、第二个错误： .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/882e3b0d00b2ba36f7d091b98c9ffe32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52ee6671cda472ea9d06a10b661e280/" rel="bookmark">
			微信小程序tab切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;view catchtouchmove='true'&gt; &lt;view class='navBox'&gt; &lt;view class='titleBox1' id="allaid" bindtap='titleClick' data-idx='0'&gt; &lt;text class="{{0 == currentIndex ? 'fontColorBox' : 'fontColorBox1'}}"&gt;tab1&lt;/text&gt; &lt;view class="line" wx:if="{{currentIndex ==0}}"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class='titleBox2' bindtap='titleClick' data-idx='1'&gt; &lt;text class="{{1 == currentIndex ? 'fontColorBox' : 'fontColorBox1'}}"&gt;tab2&lt;/text&gt; &lt;view class="line" wx:if="{{currentIndex ==0}}"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 内容布局 --&gt; &lt;swiper class='swiperTtemBox' bindchange='pagechange' current='{{currentIndex}}'&gt; &lt;swiper-item catchtouchmove='onTouchMove'&gt; &lt;/swiper-item&gt; &lt;swiper-item catchtouchmove='onTouchMove'&gt; &lt;view&gt; tab2 &lt;/view&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/view&gt; data: { currentIndex: 0, }, //点击tab时触发 titleClick: function (e) { this.setData({ //拿到当前索引并动态改变 currentIndex: e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52ee6671cda472ea9d06a10b661e280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5801df3d3a678f5da2fb0ff3848daab/" rel="bookmark">
			Win10专业版安装wsl-ubuntu子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、查看是否满足安装要求二、管理员权限启动 Windows PowerShell三、启用Windows10子系统功能四、启用虚拟机平台功能五、重启电脑六、下载 Linux 内核更新包（适用于 x64 计算机的 WSL2 Linux 内核更新包）七、将 WSL 2 设置为默认版本八、打开应用商店安装子系统 (在应用商店搜索 ubuntu)九、安装ubuntu应用十、搜索栏ubuntu，设置登陆账号和密码 win10 专业版如何在应用商店商店被禁止的情况下，来安装wsl-ubuntu子系统 以下纪录笔者的方案
前面步骤和一下博客一样
Windows 10专业版安装 WSL2 (Ubuntu 20.04)
一、查看是否满足安装要求 版本：win10专业版对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。低于 18362 的版本不支持 WSL 2。 使用 Windows Update 助手更新 Windows 版本。 二、管理员权限启动 Windows PowerShell 三、启用Windows10子系统功能 powershell窗口中输入如下命令：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 四、启用虚拟机平台功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 五、重启电脑 六、下载 Linux 内核更新包（适用于 x64 计算机的 WSL2 Linux 内核更新包） https://wslstorestorage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5801df3d3a678f5da2fb0ff3848daab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae3124854da6ba9fafbf13ebe1bb1b4/" rel="bookmark">
			开源知识库软件xwiki在Windows下的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 开源知识库软件-xwiki在windows上的部署0、参考文档1、前置环境准备1.1、Windows版本及系统配置1.2、JDK11安装1.3、Tomcat9安装1.4、MySQL5.7数据库的安装 2、xwiki安装3、配置3.1、修改配置支持对文档内容进行搜索 4、问题解决4.1、附件无法上传问题4.1、附件无法下载和删除问题 开源知识库软件-xwiki在windows上的部署 xwiki是java语言开发的开源知识库
0、参考文档 开源知识库软件-xwiki在windows下的安装：基本参考这个安装即可。
XWiKi 部分汉化
1、前置环境准备 1.1、Windows版本及系统配置 Windows10专业版，32GB内存
1.2、JDK11安装 1、xwiki15版本要求至少JDK11。
2、到oracle官网系在JDK11安装。
3、Java11安装以后在Windows的环境变量里配置JAVA_HOME，值就是JDK11的安装地址。如果不配置JAVA_HOME，接下来的Tomcat运行会报错。
1.3、Tomcat9安装 1、xwiki15版本要求至少Tomcat9及以上。
2、到Tomcat官网下载Tomcat9，解压缩即可。
1.4、MySQL5.7数据库的安装 1、xwiki15需要MySQL5.7版本（注意5.1.7不可以，会报错）。
2、安装了MySQL5.7后，创建一个数据库xwiki，并创建一个用户xwiki，将数据xwiki的所有权限（除了Grant外）均授权给xwiki用户。
2、xwiki安装 到xwiki官网下载war包，将war包解压缩，重命名为xwiki，放到Tomcat9的webapps目录下。修改配置文件：xwiki\WEB-INF\hibernate.cfg.xml，注释掉默认的hsqldb数据库配置，使用MySQL的数据库配置，如下所示： &lt;!-- &lt;property name="hibernate.connection.url"&gt;jdbc:hsqldb:file:${environment.permanentDirectory}/database/xwiki_db;shutdown=true&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;sa&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;&lt;/property&gt; &lt;property name="hibernate.connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;--&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://IP地址:端口号/xwiki?useUnicode=true&amp;amp;characterEncoding=utf-8&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;xwiki&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;xwiki用户的密码&lt;/property&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; 将MySQL的jdbc驱动 mysql-connector-java-5.1.49.jar，复制到xwiki\WEB-INF\lib目录下。
修改XWiki的默认工作路径，修改配置文xwiki/WEB-INF/xwiki.properties的environment.permanentDirectory=D:\apache-tomcat-9.0.73\webapps\wiki\data，也可以改为其他目录。
运行startup.bat启动Tomcat
访问http://localhost:8080/xwiki/，根据指引逐步初始化xwiki
3、配置 3.1、修改配置支持对文档内容进行搜索 默认的配置只支持对文档标题进行搜索，因此需要做如下配置实现对内容的搜索：
点击右上角如下图标
点击“管理wiki”
点击“查询”
点击“查询”
将“缺省的搜索引擎”由Solr改为Database即可。
4、问题解决 4.1、附件无法上传问题 一般这种问题是由于配置了nginx作为负载均衡，需要在nginx的http那里增加一句话：client_max_body size 1024m;如下所示：
4.1、附件无法下载和删除问题 1、查了下，官方FAQ宣称无法下载现象基本上都是环境问题。网络带宽、负载均衡配置、网络安全限制都可能造成附件无法下载,其中负载均衡节点可能会限制响应体大小。详见：https://kkxwiki.seeyoncloud.com/bin/viewrev/maintenance/%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7BUG_FAQ/WebHome?rev=2.1
2、然后我试了下不经过nginx，果然可以下载和删除。所以应该是nginx的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4836eb3e79fe87adeb013ff8eb60df31/" rel="bookmark">
			Python - 利用 OCR 技术提取视频台词、字幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.引言
二.视频处理
1.视频样式
2.视频截取
◆ 裁切降帧
◆ 处理效果
3.视频分段
三.OCR 处理
1.视频帧处理
2.文本识别结果
3.后续工作与优化
◆ 识别去重
◆ 多线程提效
◆ 片头片尾优化
四.总结
一.引言 视频经常会配套对应的台词或者字幕，通过文本与字幕可以更好地理解视频内容。本文介绍如何使用 moviepy 库处理视频并使用 paddleocr 库实现视频文本识别，从而获取视频中出现的文字信息。
二.视频处理 1.视频样式 样例中我们以老电视剧 &lt;三国演义&gt; 为例，处理其剧集信息并获取对话文本。
视频中字幕展示位置位于视频正下发居中位置，为了减少 OCR 的识别工作量，提高 OCR 识别成功率，我们会优先对视频截取，只保留下方台词部分的关键帧信息。
2.视频截取 ◆ 裁切降帧 from moviepy.editor import * # 对视频进行裁剪与缩放 clip = VideoFileClip('/Users/Desktop/1.mkv') print("Ori FPS:{} Duration:{} Height:{} Width:{}".format(clip.fps, clip.duration, clip.w, clip.h)) cut_clip = clip.crop(y2=clip.h - 11, height=70) cut_clip = cut_clip.set_fps(3) print("Cut FPS:{} Duration:{} Height:{} Width:{}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4836eb3e79fe87adeb013ff8eb60df31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d8947e24c05d5ee02705671bb94af4/" rel="bookmark">
			【Linux】shell执行文件清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/usr/bin/env bash ################################################################################# # 程序名称: AutoClearFiles.sh # 创建日期: 2022-11-16 # 作者: evens # 使用说明: /evens/share/shell/AutoClearFiles.sh # 功能说明： 自动执行文件清理 ################################################################################# #归档路径 archiveDir=/evens/share/archive/ #接收上游文件路径 receiveDir=/evens/share/receive/ #localworkdir localworkdir=/evens/share/localworkdir/ #日志写入路径 today=`date -d "now" +%Y%m%d` logpath=/evens/share/log/ logname=AutoClearFiles.log.${today} #清理receiveDir修改时间超14日文件和路径 cd ${receiveDir} find ./ -mtime +14 | xargs -i rm -rf {} #清理localworkdir修改时间超过14日文件和路径 cd ${localworkdir} find ./ -mtime +14 | xargs -i rm -rf {} #清理${archiveDir}receive/raw/中修改时间超过7日文件和路径 cd ${archiveDir}receive/raw/ find ./ -mtime +14 | xargs -i rm -rf {} #清理7天前的数据库备份文件 cd /evens/share/db_bak/dmp/ find .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82d8947e24c05d5ee02705671bb94af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623c2c8ee5e686d5d546b4df3231e382/" rel="bookmark">
			java构建树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看看模拟的数据库的值（数据库名：company（公司）） 可以根据parentId为0的数据为父节点，但是有些数据库根据不同的情况，设置了不同属性
level（等级1为顶点）idparentId（父公司Id）name（公司名）110顶级节点A120顶级节点B231父节点是A242父节点是B252父节点是B363父节点的ID是3 构建一棵树的步骤 1、首先获取所有的根节点（顶级节点），跟数据库的配置有关
2、根据每一个根节点，与所有节点集合（数据）进行判断，当前节点是否为其下的子节点。
3、若是，则递归调用构建树形；若不是，则表明该节点不属于其下子节点。
4、应继续循环判断节点父子关系，直到所有节点与根节点判断完毕。
/** * 构造树(需要根据不同的情况变动) * @return */ private List&lt;TreeNode&gt; constructionTree(List&lt;Company&gt; list) { // 全部数据（由查找的数据遍历得到） List&lt;TreeNode&gt; allList = new ArrayList&lt;&gt;(); // 根节点的数据 List&lt;TreeNode&gt; rootNodeList = new ArrayList&lt;&gt;(); // 最终的树结构 List&lt;TreeNode&gt; treeList = new ArrayList&lt;&gt;(); // 获取根节点 list.forEach(x -&gt; { // 这里就是说根节点是级别为1的值 if ("1".equals(x.getLevel())) { TreeNode treeNode = new TreeNode() .setKey(x.getId()) .setId(x.getId()) .setTitle(x.getName()) .setParentId(x.getParentId()); rootNodeList.add(treeNode); } }); // 构造树结构，这里可以执行过滤操作，把list（List&lt;Data&gt;）过滤成我们需要的参数（allList） list.forEach(x-&gt;{ TreeNode treeNode = new TreeNode() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/623c2c8ee5e686d5d546b4df3231e382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579acde027faa45dac81f93913ffb82d/" rel="bookmark">
			达梦--存储过程创建定时任务插入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		达梦存储过程（PL/SQL）是达梦数据库管理系统中的一种编程语言，可以用于创建复杂的数据处理逻辑，实现业务逻辑的封装和复用，并提高数据库的性能和安全性。
在达梦数据库中，存储过程可以使用PL/SQL语言编写，包括变量声明、条件语句、循环语句、游标、子程序等语法结构，同时还支持事务控制、异常处理、存储过程参数传递等功能。使用存储过程可以减少数据库数据传输量，提高数据库操作效率，同时保证了数据的一致性和安全性。
以下是一个简单的达梦存储过程示例：
CREATE OR REPLACE PROCEDURE add_salary(employee_id IN NUMBER, salary IN NUMBER) IS BEGIN UPDATE employees SET salary = salary + salary WHERE employee_id = employee_id; COMMIT; DBMS_OUTPUT.PUT_LINE('Salary added successfully'); EXCEPTION WHEN OTHERS THEN ROLLBACK; DBMS_OUTPUT.PUT_LINE('Error occurred: ' || SQLCODE || ' - ' || SQLERRM); END; 这个存储过程名为add_salary，接受两个输入参数：employee_id和salary。当存储过程被调用时，会将指定员工的薪水加上输入的salary值，并输出执行结果。如果执行过程中出现异常，就会回滚之前的操作，并输出错误信息。
可以通过创建存储过程和定时任务，实现在固定时间段内将一个表中的数据插入到另一个表中的功能。
首先，创建存储过程，例如：
CREATE PROCEDURE insert_data AS BEGIN INSERT INTO target_table (field1, field2, field3) SELECT field1, field2, field3 FROM source_table; COMMIT; END; 该存储过程将从source_table中选择数据，并插入到目标表target_table中，其中field1、field2和field3分别表示需要插入的字段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/579acde027faa45dac81f93913ffb82d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72518ad17e2159c31d554d5b243eb1d6/" rel="bookmark">
			浅谈vue3中computed和watch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.computed是什么？ 在vue世界中，computed是一个叫计算机属性的玩意，他是响应式的，这意味着当计算属性所依赖的数据发生变化时，计算属性会自动重新计算，并更新相关的 DOM，下面是一个简单的案例
&lt;template&gt; &lt;input type="text" v-model="one"&gt; &lt;br/&gt; &lt;input type="text" v-model="two"&gt; &lt;div&gt;{{str}}&lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import {computed, ref} from "vue"; const one=ref(0) const two=ref(0) let str=computed(()=&gt;{ return parseInt(one.value)+parseInt(two.value) }) &lt;/script&gt; 这样做的好处在于：每当 one 或 two 发生变化时，&lt;div&gt;中的 {{str}} 将会自动更新为 one 和 two 的和。这是因为 computed 是一个响应式计算的属性，这意味着当其依赖的数据（即 one 或 two）发生变化时，它将重新计算并更新自身的结果。由于 computed 是惰性的，它只会在其依赖项发生变化后才进行计算，因此它可以避免不必要的计算和性能开销，总的来说，&lt;div&gt;中的 {{str}} 始终保持最新，而无需手动更新，这就是使用 computed 进行响应式计算的好处。
2.Vue 中计算属性的好处主要体现在以下几个方面 2.1.简化模板逻辑 计算属性可以使模板更加清晰和简洁。它允许你将复杂的逻辑抽离到计算属性中，使模板更专注于 UI 的呈现，降低了模板的复杂度，提高了代码的可读性。
2.2.依赖追踪 Vue 会追踪所有计算属性的依赖关系，在依赖的数据发生变化时自动更新计算属性，而无需手动管理更新逻辑。这带来了更高的开发效率和代码可维护性。
2.3.缓存性 计算属性是基于它们的响应式依赖进行缓存的。只有当依赖发生改变时，才会重新计算。这意味着在多次访问计算属性时，Vue 可以避免不必要的计算，提高了性能和效率。
2.4.更容易维护代码 将复杂的计算逻辑抽象成计算属性，使得代码更易维护。计算属性可以被多个模板中复用，而不需要重复编写逻辑，降低了代码重复率。
如果不使用计算属性，相同的逻辑可能会散布在模板、方法和生命周期钩子中，导致代码难以维护、理解和调试。而使用计算属性，则可以将这些逻辑集中到一个地方，更好地组织代码。总的来说，使用计算属性能够使代码更加清晰、高效和易维护，降低了重复代码的编写，提高了开发效率。它有助于将 UI 的渲染逻辑和数据处理逻辑分离，使得代码结构更加清晰，提高了开发体验和代码质量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72518ad17e2159c31d554d5b243eb1d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022ffb9c52be6c25c60df78160f42ec4/" rel="bookmark">
			分享66个Python管理系统源代码总有一个是你想要的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享66个Python管理系统源代码总有一个是你想要的
源码下载链接：https://pan.baidu.com/s/1FGmE9Q_NE1-cjjoxU540BQ?pwd=8888 提取码：8888
项目名称
automobile-sales-management-system汽车销售管理系统 Python Vue
BNUZ教务系统认证爬虫Python语言实现，你可以用这个爬虫去模拟登录教务系统以检验学生账号是否合法
Book Managementsystem based on python QT.(基于Python QT的图书管理系统)
CRM管理系统 -- python
elasticsearch_python+flask检索系统
FZQOJ自动签到系统，基于python+selenium+javascript
JLU打卡系统（Python）
JXNU操作系统实验课程代码 -- Python版
mac系统下的appium环境搭建（python）
Mesoor 推荐系统 Python SDK
import os import shutil def void_folder(path): # 访问path路径下的文件或文件夹 lst = os.listdir(path) # 打印每一层的文件或文件夹 for name in lst: # 拼接名称，得到绝对路径，判断该文件是否符合是文件夹 real_path = os.path.join(path, name) # 如果是文件夹，则打空格表示，并且递归访问下一层 if os.path.isdir(real_path): # print(name) files = os.listdir(real_path) if len(files) == 0: print("void_folder()："+name) shutil.rmtree(real_path) endindex = len(real_path) - len(name) real_path = real_path[0:endindex] void_folder(real_path) else: void_folder(real_path) # 如果不是文件夹，直接打印，不再递归访问下一层 else: #print(name) pass def void_file(dirPath): dirs = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/022ffb9c52be6c25c60df78160f42ec4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b559a53d2f0dc68fc253204fb1d3146/" rel="bookmark">
			elementUI可拖拉宽度抽屉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，需求： 在elementUI的抽屉基础上，添加可拖动侧边栏宽度的功能，实现效果如下：
2，在原组件上添加自定义命令 &lt;el-drawer v-drawerDrag="'left'" :visible.sync="drawerVisible" direction="ltr"&gt; &lt;div id="showId" style="padding: 1rem;font-size: 12px;overflow-x: hidden;" v-html="form.introduce"&gt;&lt;/div&gt; &lt;/el-drawer&gt; v-drawerDrag 属性是我们在原组件新加的命令，传入left或者right，需要与 direction 的let和rtl对应，
3，drawer-drag.js export default { bind(el, binding, vnode, oldVnode) { // 默认抽屉宽度，当宽度小于此值不在压缩 const minWidth = 400 const dragDom = el.querySelector('.el-drawer') dragDom.style.overflow = 'auto' const resizeElL = document.createElement('div') const img = new Image(24, 38) img.src = require('@/assets/images/stretch.png') dragDom.appendChild(img) dragDom.appendChild(resizeElL) resizeElL.style.cursor = 'w-resize' resizeElL.style.position = 'absolute' resizeElL.style.height = '100%' resizeElL.style.width = '10px' resizeElL.style.top = '0px' img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b559a53d2f0dc68fc253204fb1d3146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb42c345be9ffaf59c04ce08d5153e4/" rel="bookmark">
			仅需一步，完美解决无法安装.Net framework3.5的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.自己遇到的问题，并尝试解决 当我换新笔记本的时候安装一些xxx软件或者是一些运行库的时候总是提示出现“.Net framework3.5”安装错误或者是“.Net framework4.0”等等出现问题的时候。
我的版本是win10-21H2
之后就是点击安装的时候总是会出现以下问题一直卡在进度条始终不动
本着缺啥补啥的原则，开始了第一次尝试。首先，在“控制面板”里找到“程序”选项，在从里面找到“启用或关闭windows功能”选项，在里面勾选".NET Framework3.5（包括.NET2.0和3.0）"选项，点击确定，安装不成功，一直试错，搞到都没心态了。
之后又尝试了广大网友的方法下载了离线安装包，还是失败
检查了【Windows Update】服务，将服务启用，再次安装依然失败
找一个win10镜像，找到里面的\sources\sxs\microsoft-windows-netfx3-ondemand-pachage.cab文件，把它复制出来
后来还是失败，最终无奈之下发现一个非常简单的方法。
2.自己找了自动安装.Net framework3.5-4.5的软件，直接下载并运行就直接安装好了 后来就显示安装成功了
软件链接---免费下载【免费】解决win7win8win10装4.8-3.5的.Netframework3.5安装失败问题附带安装文档资源-CSDN文库
总结：诸如此类问题，要想一步解决。直接下载并运行该软件就可以自动安装.Net framework3.5之类应用程序了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0cf81c4e4ce9c3be69effca8c6b36a/" rel="bookmark">
			【C语言基础】第02章_变量与进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲师：康师傅
视频：https://www.bilibili.com/video/BV1Bh4y1q7Nt?p=1&amp;vd_source=3eaa9d17f2454e1ae80abc50d16e66b5
文章目录 本章专题脉络1关键字(keyword)2标识符(Identifier)3变量(variable)3.1 为什么需要变量3.2 初识变量3.3 变量的声明与赋值步骤1：变量的声明步骤2：变量的赋值 3.4 变量的作用域(scope)3.5 变量按类型的分类 4基本数据类型4.1 整数类型4.1.1 类型说明4.1.2 举例4.1.3 关于后缀4.1.4 精确宽度类型(了解)4.1.5 整型的极限值(了解) 4.2 浮点类型4.2.1 类型说明4.2.2 举例4.2.3 存储规则(了解) 4.3 字符类型4.4 布尔类型 5变量间的运算规则5.1 隐式类型转换5.2 强制类型转换5.3 运算的溢出问题 6常量6.1 常量分类6.2 多种方式定义常量6.2.1 使用#define6.2.2 使用const限定符6.3.3 定义枚举常量 7输入/输出函数7.1 scanf()的使用7.2 getchar()与putchar()的使用7.3 gets()与puts()的使用 8变量按声明位置的分类9常见的进制9.1 二进制概述9.2 进制的分类9.3 进制的换算举例9.4 输出格式9.5 进制间的转换9.5.1 二进制如何表示整数？9.5.2 二进制与十进制间的转换9.5.3 二进制与八进制、十六进制间的转换 本章专题脉络 1关键字(keyword) 定义：被C语言赋予了特殊含义，用做专门用途的字符串（或单词）。
特点：全部关键字都是 小写字母 。
举例：HelloWorld案例中，出现的关键字有 int 、 return 等，些单词已经被C语言定义好了。
传统的C语言（ANSI C）有32个关键字。如下：
后续，1999年，C99标准增加了5个关键字： inline 、restrict 、 _Bool 、 _Complex 和 _Imaginary 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f0cf81c4e4ce9c3be69effca8c6b36a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450192e2fc6cf492cc859c7334ec2ff4/" rel="bookmark">
			【完美解决·离线安装】Pip安装时遇到Microsoft Visual C&#43;&#43; 14.0 is required错误，下载离线安装包安装即可（2023年11月8日更新资源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： Windows环境下，在使用pip安装第三方Python库时，部分库会下载压缩包进行本地编译，才能运行，此时若缺少相关环境会提示Microsoft Visual C++ 14.0 is required。
解决方案： （1）下载编译好的.whl文件 ① 打开链接：点击跳转
② 选择相应Python环境与库版本，下载。
③ 使用pip install安装本地.whl即可。
（2）下载Microsoft Visual C++ Build Tools安装相应环境（推荐） 但是，从网络上正常下载相应Bulid Tools，打开后会提示安装包丢失或毁坏。
所以，这里提供了一个完整的离线安装包。
链接：https://pan.baidu.com/s/11zUpLaQg2fAJJi8wq4ilzA（已过期）
提取码：2015 2023年11月8日更新：
链接: https://pan.baidu.com/s/12TwgKVviTVFdCqKoy3EJOA?pwd=2023
提取码: 2023
右键下载好的.iso文件，解压到文件夹（或装载），
打开VisualCppBulidTools_FULL.exe，开始安装，便可安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f425958c5537b52444ca5251506e2f/" rel="bookmark">
			MongoDB 之滴滴、摩拜都在用的索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、第1关：了解并创建一个简单索引二、第2关：常见索引的创建三、第3关：有趣的地理位置索引 提示：以下是本篇文章正文内容，下面案例可供参考
一、第1关：了解并创建一个简单索引 编程要求
根据提示，在右侧命令行进行操作，在 test 数据库创建集合 student ，内容如下：
然后在集合中创建成绩的降序索引。
测试说明
平台会对你的操作进行测试：
展示当前数据库 test 中 student 集合的所有索引，符合编程要求便可通过。
代码如下（示例）：
mongo use test db.student.insert([{_id:1,name:"王小明",age:15,score:90},{_id:2,name:"周晓晓",age:18,score:86},{_id:3,name:"王敏",age:20,score:96},{_id:4,name:"李晓亮",age:15,score:74},{_id:5,name:"张青青",age:21,score:88}]) db.student.createIndex({score:-1}) 二、第2关：常见索引的创建 编程要求
根据提示，在右侧命令行进行操作，在 test2 数据库中创建集合 article，内容如下：
集合创建完成后，按要求创建以下索引：
用字段 follwers 和 title 创建复合升序索引；
用字段 tags 创建多 key 降序索引；
用_id创建哈希索引；
用字段 title 和 tags 创建文本索引。
测试说明
平台会对你的操作进行测试：
展示当前数据库 test2 中 article 集合的所有索引，符合编程要求便可通过。
代码如下（示例）：
mongo use test2 db.article.insert([ ... {_id:1,title:"提升程序员工作效率的6个工具利器",tags:["Alfred","幕布"],follwers:543}, ... {_id:2,title:"我是如何从零开始学习前端的",tags:["HTML","Html5","CSS"],follwers:1570}, ... {_id:3,title:"20个非常有用的JAVA程序片段",tags:["Java","编程"],follwers:1920}]) db.article.createIndex({follwers:1,title:1}) db.article.createIndex({tags:-1}) db.article.createIndex({_id:'hashed'}) db.article.createIndex({title:'text',tags:'text'}) 三、第3关：有趣的地理位置索引 编程要求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f425958c5537b52444ca5251506e2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd2736f77ecfeb9194362f74aa20eb9c/" rel="bookmark">
			css设置浏览器表单自动填充时的背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器自动填充表单内容，会自动设置背景色。对于一般的用户，也许不会觉得有什么，但对于要求比较严格的用户，就会“指手画脚”。这里，我们通过css属性来设置浏览器填充背景的过渡时间，使用户看不到过渡后的背景，达到“清新”的感觉。
通常，浏览器自动填充表单的表现形式如下：
而我们想要的效果如下：
通过css设置即可实现上述效果：
:deep(.el-input) { input { height: 38px; &amp;:-webkit-autofill, &amp;:-internal-autofill-selected { transition-delay: 5000s; transition: color 5000s ease-out, background-color 5000s ease-out; -webkit-transition-delay: 5000s; -webkit-transition: color 5000s ease-out, background-color 5000s ease-out; } } } 通过设置input框的过渡，使input框自动填充的过渡效果在5000s后发生，这样表面上，用户就看不到浏览器设置的背景了。
当然上面也只是实现的一种方法，记得还有一种方法是用div去模拟input输入框，但是实现起来需要花点心思。而上面这种方式简单粗暴，果断采取了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3487cd710d3894e6f0e250dbbe27482d/" rel="bookmark">
			vue3使用axios语法和搭建Node.js服务器，连接本地数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.先下载axios 打开axios官网：axios中文网|axios API 中文文档 | axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。http://www.axios-js.com/
在终端下载：
npm install axios 二.在src下新建axios.js 在axios中写入如下代码：
import axios from 'axios' const server = axios.create({ baseURL:"http://127.0.0.1"//本地域名//接口前缀 }) export default server; 这个代码的意思是：从axios导入axios方法，创建一个访问地址。我这里使用的是本地地址，要连接本地的服务器。
三.搭建Node.js服务器，连接本地数据库 需要两个环境：
1.本地下载mysql。 （如果没下载，请去b站找教程）
2.Node.js环境
随便新建一个文件夹在你想要的地方，我命名未server。
在server内新建一个.js文件，我命名未01.js。
加载如下三个库，这里的库还没安装全。后面还要补。
cnpm install mysql cnpm install express cnpm install cors 在js中写如下代码：
const mysql = require('mysql'); const express = require('express'); const cors = require('cors'); // // const bodyParser = require('body-parser'); const app = express(); // app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3487cd710d3894e6f0e250dbbe27482d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9255471dd9c7ac3f655401b719a27e2/" rel="bookmark">
			登录模块设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、登录模块的主要功能和设计考虑。 基于Spring Boot的博客系统登录模块的主要功能是允许用户进行注册、登录及找回密码等操作，同时要保证用户信息安全以及系统的安全性。在设计时，需要考虑以下几点：
用户注册：提供一个注册页面，收集用户基本信息如用户名、密码、邮箱等，并将其存入数据库。用户登录：提供一个登录页面，用户输入用户名/邮箱及密码进行登录，验证信息正确性，验证通过则进入博客系统主页，否则返回错误提示信息。密码找回：用户通过注册邮箱找回密码，系统发送验证码到用户邮箱，用户输入验证码后重置密码。接口设计：使用Spring Security进行接口安全性的验证和管理，例如使用@Security注解来限制某接口只有登录状态的用户才能访问。密码加密：使用哈希算法对用户密码进行加密存储，保证用户信息的安全性。日志记录：记录用户登录、退出等操作的日志，方便后续查看和审计。异常处理：对用户输入的信息进行有效性校验，对异常情况进行处理，如用户名不存在、密码错误等。验证码功能：为了防止暴力破解，在用户注册或找回密码时，加入验证码功能。记住登录状态：使用Token机制或者其他方式，让用户在下次访问时无需再次输入用户名和密码。前后端分离设计：前端提供登录页面和交互接口，后端处理业务逻辑和数据存储等操作，前后端通过API进行数据交互。 在设计登录模块时，需要根据系统的特点和业务需求来制定具体的方案，同时要考虑系统的可维护性和可扩展性。
2、在登录模块中，如何处理用户的认证和授权? 在基于Spring Boot的博客系统中，处理用户的认证和授权是非常重要的。这可以通过使用Spring Security这样的安全框架来实现。下面是一些处理用户认证和授权的步骤：
配置Spring Security：在项目的配置文件中（如application.properties或application.yml），添加Spring Security的相关配置。例如，启用Web安全性，配置允许的HTTP方法和内容类型等。创建用户实体类：创建一个User实体类，用于存储用户信息，如用户名、密码、角色等。创建UserRepository：创建一个UserRepository接口，用于访问和操作用户数据。使用Spring Data JPA来实现这个接口。实现认证功能：创建一个UserService类，用于处理用户的认证请求。这个类应该包含一个方法，接收用户名和密码作为参数，并验证这些信息是否与数据库中的记录匹配。如果匹配，则创建一个包含用户信息的身份令牌（如JWT），并将其返回给客户端。实现授权功能：创建一个RoleService类，用于处理用户的授权请求。这个类应该包含一个方法，接收用户的身份令牌和请求的资源作为参数，并检查用户是否具有访问该资源的权限。如果有权限，则允许访问资源；否则，返回一个错误消息。配置资源安全性：在Spring Boot应用程序中，为不同的资源路径配置不同的安全约束。例如，对于博客文章的GET请求，你可能需要检查用户是否已登录并具有适当的角色或权限。创建安全过滤器：创建一个安全过滤器，用于处理未认证的用户请求。如果用户未通过认证，则重定向到登录页面。日志记录和异常处理：在处理用户认证和授权的过程中，记录必要的日志以方便后续审计。同时，对可能出现的异常情况进行处理，如用户名不存在、密码错误等。 通过以上步骤，可以在基于Spring Boot的博客系统中实现用户的认证和授权处理。请注意，这只是一个基本的框架，你可能需要根据具体需求进行适当的调整和扩展。
3、你将如何设计数据库表结构来支持登录模块? 在设计基于Spring Boot的博客系统的登录模块时，需要考虑以下数据库表结构：
用户表（User）：
id：用户ID（主键，自增）username：用户名password：密码（加密后存储）email：电子邮箱role：用户角色（例如，管理员、作者、读者等） 角色表（Role）：
id：角色ID（主键，自增）role_name：角色名称permission：角色权限（例如，发布文章、评论文章等） 登录日志表（LoginLog）：
id：登录日志ID（主键，自增）user_id：用户ID（外键，关联用户表的id）login_time：登录时间logout_time：登出时间（如果用户未登出，则为空）ip_address：登录IP地址user_agent：用户代理信息 通过以上三个表的设计，可以支持用户注册、登录、找回密码以及记录登录日志等功能。在具体实现时，可以根据需求对表结构进行调整和优化。
如果需要设计关联表，可以考虑用户与角色之间的关联关系。在这种情况下，可以创建一个关联表来存储用户与角色之间的对应关系。
关联表的设计可以根据具体需求来确定，以下是一个简单的示例：
关联表（UserRole）：
id：关联ID（主键，自增）user_id：用户ID（外键，关联用户表的id）role_id：角色ID（外键，关联角色表的id） 通过这个关联表的设计，可以实现用户与角色的多对多关联关系，从而支持用户拥有多个角色和权限的功能。根据实际需求，还可以根据需要添加其他关联表来支持更复杂的业务逻辑。
4、可以描述一下登录流程吗? 包括前端和后端的交互步骤 基于Spring Boot的博客系统登录流程可以大致分为前端和后端两个部分。下面是一个简单的登录流程描述：
前端部分：
用户在浏览器中输入博客系统的URL，并访问登录页面。登录页面向用户展示登录表单，要求输入用户名、密码等信息。用户在登录表单中输入正确的用户名和密码，并提交表单。前端使用HTTP协议将用户提交的登录信息发送到后端进行验证。 后端部分：
后端接收到前端发送的登录请求和用户提交的信息。后端使用Spring Security等安全框架对用户提交的信息进行验证。验证包括检查用户名和密码是否匹配，以及用户角色和权限是否符合要求等。如果验证通过，后端将生成一个身份令牌（例如JWT），并将其返回给前端。同时，后端还将该用户的角色和权限等信息存储在会话中或数据库中。前端接收到身份令牌后，将其存储在本地（例如LocalStorage）或传递给后台其他页面使用。前端使用身份令牌访问受保护的资源时，后端会验证令牌的有效性，并根据令牌中的用户信息和角色权限来判断是否允许访问相应的资源。如果验证通过，后端将返回请求的资源或继续处理请求。如果验证失败或令牌无效，则返回相应的错误消息或重定向到登录页面。 需要注意的是，这只是一个简单的登录流程示例，实际实现中可能涉及更多的细节和安全措施。此外，还可以根据具体需求进行自定义和优化。 重定向是指当用户访问一个页面或发出一个请求时，由于某种原因（如身份验证失败、权限不足等），服务器返回一个不同的页面或URL地址，而不是响应原始请求的内容。
在基于Spring Boot的博客系统中，重定向通常发生在以下情况：
登录失败：当用户输入错误的用户名或密码尝试登录时，后端验证失败，会将用户重定向到登录页面，并显示相应的错误消息。权限不足：当用户尝试访问一个需要特定权限的资源时，如果用户没有足够的权限，后端会将用户重定向到无权限访问的错误页面，并提示用户没有权限访问该资源。身份验证：在某些情况下，系统需要进行更复杂的身份验证，例如多因素认证或社交登录等。后端会将用户重定向到另一个页面或服务，完成额外的身份验证步骤。 重定向可以通过HTTP状态码和Location头部来实现。当服务器返回一个状态码（如302）和Location头部时，浏览器会自动重定向到指定的URL地址。在Spring Boot中，可以使用@RedirectToView注解或return "redirect:url"语句来实现重定向。
5、如果用户名和密码都正确但在验证过程中出现异常或延迟，你会如何处理? 在处理用户名和密码验证的过程中，如果出现异常或延迟，可以考虑以下几种处理方式：
错误提示和重试机制：如果验证过程中出现异常或延迟，可以立即向用户显示一个错误提示，告知用户验证失败，并提供重试的选项。这样可以避免用户长时间等待，并提高用户体验。异步验证机制：可以将验证过程设计为异步的，即用户提交验证请求后，系统立即返回一个响应，告知用户验证正在进行中，并给出预计完成时间。在此期间，用户可以继续使用系统，而不需要等待验证结果。当验证完成时，系统可以通过回调函数或通知机制告知用户验证结果。限流和限时机制：为了防止恶意攻击或异常情况导致的系统过载，可以在系统中设置限流和限时机制。例如，限制每个用户在一定时间内的验证请求次数，或者限制每个请求的执行时间。如果超过限制，可以返回错误提示或暂时禁止该用户继续进行验证。日志记录和监控：对于异常或延迟情况，应该进行详细的日志记录，以便后续分析和监控。通过监控系统的运行状态和日志信息，可以及时发现并处理潜在的问题。 综上所述，处理用户名和密码验证过程中的异常或延迟需要综合考虑用户体验、系统安全和性能等多个方面，并采取相应的措施来提高系统的可靠性和稳定性。
6、如何防止暴力破解登录? 暴力破解是一种攻击手段，它通过尝试猜测用户名和密码来获取访问权限。为了防止暴力破解登录，可以采取以下几种措施：
增加密码复杂度：要求用户设置长密码，至少8位以上，最好包含大小写字母、数字和特殊字符的组合。避免使用容易猜测的密码，如生日、名字等。启用多因素身份验证：多因素身份验证是一种更加安全的身份验证方式，它要求用户提供除了密码之外的其他验证方式，如手机验证码、指纹识别等。启用多因素身份验证可以增加暴力破解的难度。限制登录尝试次数：可以设置一个限制登录尝试次数的机制，当用户在一定时间内尝试登录次数超过限制时，账户将被暂时锁定或立即禁止登录。这样可以防止暴力破解攻击。添加IP限制：可以设置一个IP限制规则，允许每个IP地址在一定时间内只能进行一定次数的登录尝试。如果一个IP地址的登录尝试次数超过限制，该IP地址将被暂时禁止访问系统。异常行为检测：通过监控用户的登录行为和访问记录，可以检测到异常情况，如短时间内多次登录失败、异地登录等。对于这些异常情况，系统可以采取相应的措施，如发送警告邮件、暂时冻结账户等。定期更换密码：为了降低被暴力破解的风险，可以定期要求用户更换密码。在更换密码时，可以增加一些额外的验证步骤，如手机验证码验证等。使用安全库或加密算法：使用安全库或加密算法对密码进行存储和加密，可以增加暴力破解的难度。不要明文存储密码，应使用哈希函数或加盐加密等技术对密码进行处理。定期更新软件和补丁：保持系统、应用程序和浏览器的最新版本，及时更新安全补丁，可以防止漏洞被利用来进行暴力破解攻击。 综上所述，防止暴力破解登录需要综合考虑多种措施，包括增加密码复杂度、启用多因素身份验证、限制登录尝试次数、添加IP限制、异常行为检测、定期更换密码、使用安全库或加密算法以及定期更新软件和补丁等。这些措施可以有效地提高系统的安全性，降低被暴力破解攻击的风险。
7、你将如何保护用户的密码安全? 保护用户的密码安全是非常重要的，以下是一些措施来保护用户的密码安全：
加密存储：用户的密码应该被加密存储，而不是以明文形式存储。可以使用哈希函数、加盐加密等技术对密码进行加密处理，确保即使数据库被泄露，攻击者也无法轻易获取用户的密码。密码复杂度要求：要求用户设置长密码，并包含大小写字母、数字和特殊字符的组合，避免使用容易猜测的密码，如生日、名字等。这样可以增加密码的强度，降低被破解的风险。避免重复使用密码：用户应该在不同的网站和应用程序上使用不同的密码，避免重复使用相同的密码。如果一个密码被泄露，其他账户的安全性也可以得到保障。登录失败处理：当用户尝试登录失败时，系统应该采取相应的措施，如限制登录尝试次数、启用验证码等，以防止暴力破解攻击。这样可以减少被攻击者恶意攻击的风险。传输加密：在网络传输过程中，密码应该被加密传输，避免被中间人攻击。可以使用HTTPS等加密协议来确保密码的安全传输。防止SQL注入：在处理用户输入时，应该对输入进行正确的过滤和转义处理，防止SQL注入攻击。攻击者可以通过注入恶意SQL语句来获取用户的敏感信息，包括密码。更新和修补漏洞：及时更新系统和应用程序的补丁，修复已知漏洞。这样可以防止攻击者利用漏洞来获取用户的密码和其他敏感信息。用户教育：向用户宣传密码安全知识，提醒他们不要轻易透露密码，并定期更换密码。用户的安全意识对于保护密码安全非常重要。 综上所述，保护用户的密码安全需要综合采取多种措施，包括加密存储、要求密码复杂度、避免重复使用密码、登录失败处理、传输加密、防止SQL注入、更新和修补漏洞以及用户教育等。这些措施可以有效地提高用户密码的安全性，降低被攻击的风险。
8、在登录过程中，如何处理潜在的安全漏洞，例如跨站请求伪造(CSRF) 和跨站脚本攻击 (XSS)? 处理登录过程中的潜在安全漏洞，例如跨站请求伪造（CSRF）和跨站脚本攻击（XSS），可以采取以下措施：
针对CSRF攻击：
使用随机数生成器生成并存储一个唯一的挑战令牌（CSRF token），并在登录表单中添加一个隐藏的输入字段来存储该令牌。在处理登录请求时，验证该令牌是否与数据库中存储的令牌匹配。如果匹配，表示请求是由合法用户提交的。在每个需要用户认证的页面上，都使用相同的令牌来验证后续请求。 针对XSS攻击：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9255471dd9c7ac3f655401b719a27e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc5140becd32c1412af8fc533c22059/" rel="bookmark">
			企业微信开发——企业内部自建应用开发（第二篇）---JS_SDK配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业微信如果想要使用企业微信的JS_SDK来实现拍照、定位等等功能，就需要预先在使用到的页面进行配置，当然你可以做全局配置。对于JS_SDK的配置设计前端和后端的统一配置。下面我来说明下具体的步骤。
特别说明：1、企业微信有的接口需要配置wx.config，有的接口需要配置wx.agentConfig，下面我将分别举例说明。
2、只要按照我的步骤进行配置，有一定代码基础的同学，就能完成。
一、wx.config配置
此配置配置完成后，一些基础功能就可以调用了，如：拍照、定位等等，还有其它的功能，需要参考企业微信开发文档。那么如何配置，直接通过代码来讲解：前端使用的时vue脚手架，后端使用的
.net web api。
首先在vue脚手架项目的index.html全局引用引入js文件：
&lt;script src="" target="_blank"&gt;//res.wx.qq.com/open/js/jweixin-1.2.0.js"&gt;&lt;/script&gt;
js 代码：
//首先，在created中初始化配 created() { this.initQyWxConfig(); } methods: { initQyWxConfig() { let that = this; var postData = { url: window.location.href, }; xapi.ajax({ url: "/api/***/****/AccessQyWxConfigBaseMessage", type: "POST", contentType: "application/json", data: postData, success: function (data, status, xhr) { that.configQyWx(data.Data, function () {}); }, error: function (XMLHttpRequest, textStatus, errorThrown) { alert( "错误:" + textStatus + ":" + errorThrown + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc5140becd32c1412af8fc533c22059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cea013c170f609bfe7b8c847c9c0d860/" rel="bookmark">
			企业微信开发——企业内部自建应用开发（第四篇）---自定义工具栏开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题说明：企业微信中私聊微信客户，在聊天输入框上面有一行快捷工具，这边怎么自定义开发？如下图，我们可以点击快捷发送，然后弹出一个页面，页面中有我们需要发送给当前会话的各种资源，点击发送，就可以像图中这样把资源发送出来。
二、下面介绍下具体步骤
2.1 配置应用
在企业微信管理后台添加一个应用，如下图，输入相关名字、地址链接即可添加完成。
2.2 应用创建完成，点击应用，进入应用配置页，将应用配置到快捷聊天栏，如下图。配置到聊天工具栏后，在企业微信已微信客户聊天的窗口中，就会多出来一个快捷方式，点击这个快捷方式，可以进入到我们配置的页面。
2.3 页面发送资源给当前微信客户联系人的自定义开发，有以下几个步骤，代码都在下面：
2.3.1 首先获取页面进入的环境，调用wx.invoke("getContext"），就是判断下是否是从“与客户聊天的界面”中进入的当前页面，如果时，则页面上附带发送按钮。因为这个页面也是应用的一个页面，从其他入口进入时不需要发送按钮，相当于给你做个判断。
2.3.2 完成上述操作后，可以调用wx.invoke("getCurExternalContact"）接口获得外部联系人的userid，这边主要是为了记录给那些客户发送了什么资源消息，如果项目中无这种要求就不需要。
2.3.3然后配置wx.agentConfig ，具体的配置方法在上篇文章中已经说明了，不清楚的可以参考上面的文字，或者私信问我，微信：1057359832。这边给出前端代码：
2.3.4 最后就可以把项目发布到测试环境，点击聊天的快捷栏目，就可以实现打开页面，发送相关资源。
用的是vue脚手架:
created() { //初始化时先进行配置 this.initQyConfig(); }, methods: { initQyConfig() { let that = this; var postData = { url: window.location.href, }; xapi.ajax({ url: "/api/WxComHandle/Common/AccessAgentConfigBaseMessage", type: "POST", contentType: "application/json", data: postData, success: function (data, status, xhr) { that.configQy(data.Data); }, error: function (XMLHttpRequest, textStatus, errorThrown) { xapi.alert( "错误:" + textStatus + ":" + errorThrown + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cea013c170f609bfe7b8c847c9c0d860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd138607f7b05ba6e082023a1a1f8391/" rel="bookmark">
			【AI编程】ai编程插件汇总iFlyCode、codegeex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、iFlyCode 开发公司：讯飞
支持IDE: VS Code、IntelliJ IDEA、CLion、PyCharm、WebStorm
支持语言: Python、JavaScript、C++、Java
下载地址：https://iflycode.xfyun.cn/
iFlyCode 快捷键列表：
 Tab 采纳建议
 Esc 拒绝建议
 Alt+\ 主动触发建议
使用手册：https://iflycode.xfyun.cn/iFlyCode%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C-IDEA.pdf
2、codegeex 下载地址：https://codegeex.cn/
主要功能：写代码注释非常溜
支持编辑器：
支持编程语言：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c13a9048708088000e14e712b1089f/" rel="bookmark">
			oracle flashback（闪回）恢复误删的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就在今天
几小时前
误删了数据库里面的数据，直接all in，点击删除，头也不回的commit，像极了女朋友和你分手时候的样子，不对，是我主动提分手的！（真的是我提的）然后删除了微信之类的所有联系方式。
那一瞬间，白了，什么都没有了，所有的回忆（数据）都没了。
我慌了，识图回到从前，还有美好回忆的那个时刻，可是一切都晚了。
我寻遍千山（疯狂问度娘），我该怎么办
她给我了一串神秘代码：
select scn, to_char(time_dp, 'yyyy-mm-dd hh24:mi:ss') from sys.smon_scn_time order by TIME_DP desc ;
alter table 表名 enable row movement;
flashback table 表名 to timestamp to_timestamp(恢复的时间点, 'yyyy-mm-dd hh24:mi:ss');
执行完的那一刻，我又神清气爽。
可是，再也曾经的那种感觉了。
那一刻之前，我很爱你，那一刻之后，不再爱了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e15badc586c8b25dd4a42065a06a63/" rel="bookmark">
			springboot 接口防刷（根据IP与路径限制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口防刷 一、全局接口防刷（通过拦截器方式）1、原理 + 代码示例 二、个别接口防刷（接口注解方式)1、代码示例 一、全局接口防刷（通过拦截器方式） 1、原理 + 代码示例 通过ip地址+uri拼接用以作为访问者访问接口区分通过在Interceptor中拦截请求，从Redis中统计用户访问接口次数从而达到接口防刷目的 拦截器：
package org.jeecg.config.InterceptorLimint; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.web.servlet.HandlerInterceptor; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Objects; import java.util.concurrent.TimeUnit; @Slf4j public class AccessLimintInterceptor implements HandlerInterceptor { @Resource private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 多长时间内 */ @Value("${interfaceAccess.second}") private Long second = 10L; /** * 访问次数 */ @Value("${interfaceAccess.requestCount}") private Long requestCount = 3L; /** * 禁用时长--单位/秒 */ @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e15badc586c8b25dd4a42065a06a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69744a788273956ae2a3bcd8a159d2a0/" rel="bookmark">
			血流动力学与血压(二)--脉压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脉压 往期文章 往期文章 血流动力学与血压(一)–平均动脉压
目前针对心血管血流动力学的准确分析，有两个不同但相互依赖的组成部分不能被忽略：
血压中的稳定分量，即平均动脉压脉动分量，定义为脉压（PP, Pulse Pressure），代表动脉压平均值周围的压力值波动。 以上两点在脉搏波中的体现可以看下图，平均动脉压（Mean Arterial Pressure）表述的是血液在血管中波动的平均量，而脉压（收缩压-舒张压）则是表示血液在血管中的波动程度。下图中的上方表示随着脉搏波的振动，动脉血管的横截面，可以发现，当血管内压力达到最大时（此时血管内压力为收缩压），对应动脉血管的横截面积最大，当血管压力达到最小时（此时血管内压力为舒张压），动脉血管的横街面积最小。
从第一期文章，我们知道血压中的稳定部分，即平均动脉压取决于三个因素：
心率每博输出量全身血管阻力 而血管中的脉动分量（即脉压）取决于两个因素：
左心室射血活动和大动脉机械特性之间的相互作用（即前向波）反射波 血压的决定因素可以通过下面这个框架来解释。绿色部分表示平均动脉压的决定因素，首先左心室充盈和收缩决定了每博输出量，其和心率结合决定了心输出量，心输出量和全身血管阻力决定了平均动脉压的大小。紫色部分表示脉压的决定因素，首先大动脉的扩张和收缩会形成前向波和反向波，二者决定了脉压的大小。脉压和平均动脉压共同决定了一个人的血压水平。
然而，血压的稳定成分和脉动成分不应被视为独立的区域。事实上，定义平均动脉压的元素和定义脉压的元素之间存在许多相互作用。这些相互作用会在后续的文章中说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d5555225b04279cc6d872b9535b0ff/" rel="bookmark">
			基于MySQL和OpenCV的二维码实时识别系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.研究背景与意义 项目参考AAAI Association for the Advancement of Artificial Intelligence
研究背景与意义
随着二维码技术的广泛应用，二维码的识别成为一个重要的研究领域。二维码是一种能够储存大量信息的图像编码方式，通过扫描二维码，用户可以快速获取相关信息，例如产品信息、网址链接等。然而，传统的二维码识别方法往往需要离线处理，无法实现实时识别，限制了二维码技术的应用范围。
为了解决这一问题，本研究提出了基于MySQL和OpenCV的二维码实时识别系统。MySQL是一种常用的关系型数据库管理系统，具有高效、稳定的特点，适用于存储和管理大量的数据。OpenCV是一个开源的计算机视觉库，提供了丰富的图像处理和计算机视觉算法，可以用于二维码的识别和解码。
本研究的主要目标是设计和实现一个高效、准确的二维码实时识别系统，以满足现实生活中对于快速获取信息的需求。具体来说，本研究的主要内容包括以下几个方面：
首先，本研究将研究和开发一种基于OpenCV的二维码识别算法。该算法将利用OpenCV提供的图像处理和计算机视觉算法，对输入的图像进行预处理、二值化、定位和解码等操作，以实现对二维码的准确识别。
其次，本研究将设计和实现一个基于MySQL的二维码信息管理系统。该系统将利用MySQL的数据库管理功能，存储和管理大量的二维码信息，包括二维码的内容、生成时间、使用次数等。同时，该系统还将提供查询和统计功能，方便用户对二维码信息进行管理和分析。
最后，本研究将实现一个基于MySQL和OpenCV的二维码实时识别系统。该系统将集成前述的二维码识别算法和信息管理系统，实现对实时视频流中的二维码进行识别和解码，并将识别结果与数据库中的信息进行匹配和查询，以实现对二维码信息的快速获取和管理。
本研究的意义主要体现在以下几个方面：
首先，基于MySQL和OpenCV的二维码实时识别系统将大大提高二维码的识别效率和准确性。传统的二维码识别方法往往需要离线处理，无法满足实时识别的需求。而本研究提出的系统将利用OpenCV提供的图像处理和计算机视觉算法，实现对实时视频流中的二维码进行快速、准确的识别，大大提高了二维码的识别效率和准确性。
其次，基于MySQL的二维码信息管理系统将方便用户对二维码信息进行管理和分析。传统的二维码信息管理方法往往需要手动记录和整理，效率低下且容易出错。而本研究提出的系统将利用MySQL的数据库管理功能，实现对二维码信息的存储、管理和查询，方便用户对二维码信息进行管理和分析。
最后，基于MySQL和OpenCV的二维码实时识别系统将有助于推动二维码技术的应用和发展。二维码技术具有广泛的应用前景，可以应用于商品追溯、物流管理、移动支付等领域。而本研究提出的系统将为二维码技术的应用提供了一种高效、准确的识别方法，有助于推动二维码技术的应用和发展。
综上所述，基于MySQL和OpenCV的二维码实时识别系统具有重要的研究意义和应用价值，将为二维码的识别和管理提供一种高效、准确的解决方案，有助于推动二维码技术的应用和发展。
2.图片演示 3.视频演示 基于MySQL和OpenCV的二维码实时识别系统_哔哩哔哩_bilibili
4.算法流程图 本算法功能主要为二维码识别以及信息内容读取。算法结构如图所示，首先二维码图片转化为二进制像素矩阵,然后利用鼠标监听事件选择感兴趣区域(Region of Interest, ROI),进一步聚焦待识别区域;最后采用线性变换方法突显图片细节,利用神经网络和OpenCV 实现二维码识别功能。信息内容读取通过对所获得的二维码信息取模后输出在液晶屏。
算法整体流程为:首先,设计摄像头调用函数获取原始图片，鼠标监听事件选取ROI和图片降噪,提升识别效率;其次,利用二维码识别器构建训练集和测试集，采用CNN 算法进行训练和学习;最后,采用OpenCV设计二维码识别算法。算法整体流程如图所示。为避免二维码内容为空，以识别内容长度作为判定值,当识别后没有信息时,显示二维码错误。
5.核心代码讲解 5.1 login.py class Database: def __init__(self, host, user, passwd, db): self.conn = MySQLdb.connect(host=host, user=user, passwd=passwd, db=db) self.cur = self.conn.cursor() def create_database(self, name): self.cur.execute(f"CREATE DATABASE IF NOT EXISTS {name}") self.conn.select_db(name) def create_table6(self): self.cur.execute('''CREATE TABLE IF NOT EXISTS table6 (name VARCHAR(255), password VARCHAR(255))''') def create_table7(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d5555225b04279cc6d872b9535b0ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb74e8d15759ad12d5ce4268c88459c0/" rel="bookmark">
			C语言实现简易扫雷游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求： 1.棋盘大小为9*9，雷的个数为10
2.棋盘刚开始全为 ‘*’ ,当用户输入自己选择坐标位置后，返回该位置附近雷的个数 第一次选择前的显示效果 选择第五行第五列后显示的效果 思考点： 1.棋盘怎么实现？
同时我们需要两个棋盘来实现扫雷游戏，一个负责储存雷所在位置的信息（假设0表示没有雷，1表示所在位置是雷）该二维数组命名为mine，类型为char（和下面的show数组保持类型一致，方便计算雷的个数）
另外一个负责显示给用户当前位置附近雷的个数，该二维数组命名为show，因为展现给用户的初始界面全部为 ‘*’ ，应该使用 char 类型的二维数组
2.雷的个数怎么计算？
如上图所示，假如我们计算第三行第六列周围八个位置的雷（有1即是雷），显示给用户的个数为1
但计算第9行第7列位置的雷时，因为棋盘为9*9大小，该位置的下面三个位置会超出范围，因此我们需要判断用户输入的位置是否是边界，但边界位置太多不好判断并且费时费力，我们直接将棋盘转化为10*10，这样用户输入的位置是边界时就不会超出范围，所有判断雷的个数都只需要同一种代码即可。
mine数组中保存的是雷所在的位置，show是显示给用户该位置雷的个数，因为两数组都是char类型，在内存中，char类型存储都是以对应字符的ASCII码进行存储，比如 '0' 对应数字48 ，即在内存中保存的并非 '0' ，而是48
因此：
'0' - '0' = 0
'1' - '0' = 1
利用上述方法可以直接将 字符形式的数字 转化为 整数类型的数字 （反过来也可以将 整数类型的数字 转化为 字符形式的数字）
完整代码如下： test.c #include &lt;stdio.h&gt; #include "game.h" void menu(void) { printf("***********************\n"); printf("***** 1. play *****\n"); printf("***** 0. exit *****\n"); printf("***********************\n"); } void game(void) { //初始化棋盘 char mine[ROWS][COLS]; char show[ROWS][COLS]; InitBroad(mine, ROWS, COLS, '0'); InitBroad(show, ROWS, COLS, '*'); //显示棋盘 //	DisplayBroad(mine, ROW, COL); //	DisplayBroad(show, ROW, COL); //设置雷 SetMine(mine, ROW, COL, Mine); //	DisplayBroad(mine, ROW, COL); //排查雷 FineMine(mine, show, ROW, COL, Mine); } int main() { int input = 0; do { menu(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb74e8d15759ad12d5ce4268c88459c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e8c9416bb39b4f6c67f6e211614af5d/" rel="bookmark">
			C语言——二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前置】多个字符从两端移动，向中间汇聚 利用代码实现如下效果：
############ H##########! He########d! Hel######ld! Hell####rld! Hello##orld! Hello world! 要求： 刚开始全部是 ############ ，每循环一次，左右两边各一个#被代替成 Hello world! 这句话
的对应字符
思路： 1.需要创建两个数组来存储原始字符串 ############ 和用来替代的字符串 Hello world! 2.需要计算数组的长度从而计算原始字符串哪个位置对应替代字符串的位置
隐藏条件：两个数组的长度相同
因此只需要计算一个数组的长度即可，同时数组存储的是字符串，可以使用 strlen()函数计算长度，strlen()函数计算字符串长度时不会计算最后的终止符 \0
也可以使用 sizeof(arr)/sizeof(arr[0]) 来计算数组的长度，但字符串在存储的过程中会添加终止符 \0，而 sizeof(arr)/sizeof(arr[0]) 在计算时会把终止符计算进去，所以数组的真实长度为 sizeof(arr)/sizeof(arr[0])-1
3.需要两个变量 left 和 right 来代表左右两边移动的位置（即移动到哪里了）
int left = 0; int right = strlen(arr)-1; //数组的下标是从0开始，最后一个元素的下标是数组的长度-1 //如果是用sizeof(arr)/sizeof(arr[0])来计算长度的话，最后一个元素的下标是sizeof(arr)/sizeof(arr[0])-2 //在DEV——C++中使用strlen()函数时需要包含头文件#include &lt;cstring&gt; 完整实现代码如下： #include &lt;stdio.h&gt; #include &lt;cstring&gt; int main() { char arr1[] = "Hello world!"; char arr2[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e8c9416bb39b4f6c67f6e211614af5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77526da44b8f8000d35e1028c69b1cf6/" rel="bookmark">
			docker数据目录迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载docker源码
wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.09.0.tgz --no-check-certificate
2.将解压出来的docker目录下的指令复制到 /usr/bin/ 目录下
tar xf docker-18.09.0.tgz
cp docker/* /usr/bin/　3.将docker注册为service服务
新建该文件
vi /etc/systemd/system/docker.service
加入以下内容：
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target
[Service]
Type=notify
ExecStart=/usr/bin/dockerd -g /opt/docker ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TimeoutStartSec=0
Delegate=yes
KillMode=process
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s
[Install]
WantedBy=multi-user.target
ExecStart=/usr/bin/dockerd -g /opt/docker #启动docker操作并指定数据目录
4.添加执行权限并重新加载配置文件
chmod a+x /etc/systemd/system/docker.service
systemctl daemon-reload
systemctl restart docker
验证
docker --version
停止docker服务
systemctl stop docker
迁移数据目录
mkdir -p /data/docker
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77526da44b8f8000d35e1028c69b1cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23c88de8fb36898babccf8407ed61d4/" rel="bookmark">
			出现Could not autowire. No beans of ‘xxxx‘ type found的错误提示。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个报错运行和编译都不会出现问题
在编辑情况下，无法找不到对应的bean，于是提示找不到对应bean的错误。
解决方式是降低Autowired检测的级别
在setting-&gt;inspections-&gt;autowining for bean class-&gt;Severity 中的error改成warning或者其他级别
这样就解决了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaec2ba3614eed0603abc8213b8cb2cf/" rel="bookmark">
			html2canvas和dom-to-image的优缺点对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间因为需求需要用到截图功能，一番调研后了解到html2canvas和dom-to-image可以实现截图功能。原理都是获取到dom元素，将dom绘制成canvas,然后转成图片。刚开始用的是html2canvas插件，后面因为html2vancas没法更改生成图片的样式，果断放弃了选择了dom-to-image插件。所以说对这两款插件还是有一定的了解，现在来说下个人对这两款插件的优缺点！
html2canvas的优点： 1.生成的图片非常清晰，即使放大数倍也很清晰。
html2canvas的缺点： 1.无法对图片进行样式设置，就是说布局是什么样子的，生成的图片就是什么样的
dom-to-image的优点： 1.可以对图片进行样式设置，比如添加背景色，padding
dom-to-image的缺点： 1.图片相比html2canvas,放大数倍后模糊
2.经测试，dom中含有伪类元素的话，生成的图片伪类元素的样式将会丢失。
3.只能生成可见元素的dom（可以用dom-to-image的升级版本dom-to-image-more解决）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/449fda514b9fd322f47531b5db737d66/" rel="bookmark">
			vue3&#43;element-plus表单验证方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们最后要得到的是：
先定义一个什么也没有的表单。我定义了一个表单，这个表单有用户名、密码、登录、注册。
&lt;el-form class="w-[250px]"&gt; &lt;!-- 和表单验证属性相对应 --&gt; &lt;el-form-item&gt; &lt;!-- 给input添加图标 --&gt; &lt;el-input placeholder="请输入用户名"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-input type="password" show-password placeholder="请输入密码"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item class=""&gt; &lt;el-button round color="#626aef" type="primary" class="w-[250px]"&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 然后我们给表单的每个item加上它的响应式数据:
响应式数据是用:model=""来定义的，将其分配给item使用的是prop。
&lt;script setup&gt; import { ref, reactive } from 'vue'; const form = reactive( { username: '', password: '' } ) &lt;/script&gt; &lt;template&gt; &lt;el-form class="w-[250px]" :model="form"&gt; &lt;!-- 和表单验证属性相对应 --&gt; &lt;el-form-item prop="username"&gt; &lt;!-- 给input添加图标 --&gt; &lt;el-input placeholder="请输入用户名"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item prop="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/449fda514b9fd322f47531b5db737d66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a3ff41ca7ee717c819c76f4f51e4367/" rel="bookmark">
			Python学习笔记DAY9（函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
函数的定义及调用
函数的参数传递
函数的返回值
变量的作用域
匿名函数lambda的使用
函数的递归操作
常用的内置函数
本章总结
函数的定义及调用 函数的参数传递 函数的参数传递-位置传参和关键字传参
函数的参数传递-默认值参数
函数的参数传递-可变参数
函数的返回值 变量的作用域 全局变量、局部变量
匿名函数lambda的使用 函数的递归操作 斐波那切契数列
常用的内置函数 常用的内置函数-数据类型转换函数 常见的内置函数-数学函数
常用的内置函数-迭代器操作函数
常用的内置函数-其它函数
本章总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7eda983bb5ed36a689a3baa78a79622/" rel="bookmark">
			大津法OSTU算法 -活动轮廓方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OTSU算法是一种常用的图像分割算法，用于自动确定图像中的阈值。下面是使用OTSU算法进行图像分割的基本步骤： 将彩色图像转换为灰度图像，以便简化处理过程。
计算灰度图像的直方图，即统计每个灰度级别的像素数量。
计算图像的总像素数，并初始化类间方差最大值为0，最佳阈值为0。
对于每个可能的阈值t（从0到255），按照以下步骤进行计算：
将图像分割为两个区域：前景（小于等于阈值t）和背景（大于阈值t）。
计算前景和背景的像素数、像素总和和像素平均值。
计算前景和背景的类内方差（方差是像素值与平均值之差的平方和除以像素数）。
计算类间方差，即前景和背景之间的方差乘以前景和背景像素数的乘积。
如果类间方差大于当前最大值，则更新最大值和最佳阈值。
找到类间方差最大值时对应的最佳阈值。
使用最佳阈值将图像分割为前景和背景。
下面是一个使用Python和OpenCV库实现OTSU算法的示例代码：
import cv2 # 读取图像并转换为灰度图像 image = cv2.imread('image.jpg') gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 计算直方图 histogram = cv2.calcHist([gray], [0], None, [256], [0, 256]) # 图像总像素数 total_pixels = gray.shape[0] * gray.shape[1] # 初始化类间方差最大值和最佳阈值 max_variance = 0 best_threshold = 0 # 遍历所有可能的阈值 for threshold in range(256): # 将图像分割为前景和背景 foreground = gray &lt;= threshold background = gray &gt; threshold # 计算前景和背景的像素数、像素总和和像素平均值 foreground_pixels = foreground.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7eda983bb5ed36a689a3baa78a79622/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c753c37d3dc1ef379d53ad373276e3d2/" rel="bookmark">
			开源不止，创新澎湃 | 2023开源产业生态大会六大专题抢“鲜”看！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023开源产业生态大会
作为上海市经济和信息化委员会、上海市科学技术协会指导的年度重点活动，2023开源产业生态大会即将于12月19日在上海开幕。大会将展示最前沿的开源创新项目，从金融科技、人工智能到智能汽车、智能制造、工业软件等一系列颠覆性应用，无疑是年内一场不容错过的科技盛宴。
大会与中国信通院云计算与大数据研究所、北京国家金融科技认证中心、OpenHarmony生态委员会、中国汽车工业协会软件分会、OpenSDV汽车软件开源联盟、Linux AI &amp; DATA基金会、开放原子开源基金会等联袂举办一系列专题论坛，深入探讨开源与金融科技、智能汽车、企业数字化，工业软件及开源大模型应用、开源合规与风险管理等热点议题。
1 引领金融业开源应用创新，促进业务生态繁荣发展
大会携手北京国家金融科技认证中心联合举办金融科技与开源创新分论坛，邀请金融机构管理层、开源技术大咖、行业专家共聚一堂，聚焦金融行业开源体系建设和应用最佳实践，针对金融业开源治理、开源应用与金融科技创新融合的过程中行业面临的挑战，共同构建安全有序的金融开源生态。
联合出品人：李博文
北京国家金融科技认证中心实验中心负责人，先后参与多项金融国家标准、行业标准、团体标准的研究制定工作，支撑金融行业金融科技发展规划、金融标准化发展规划的落地实施，研究领域包括金融开源、供应链管理、网络安全、数据安全等相关领域。
此次分论坛重点议题包括开源治理体系及内源建设、大模型技术在金融行业创新应用、隐私计算金融行业应用实践等，同时还将围绕开源技术促进金融业务创新发展举办圆桌论坛，邀请银行、证券、保险等金融机构、金融科技公司、业内专家共同交流探讨。
2 共建鸿蒙生态，构筑数字底座
大会携手OpenHarmony生态委员会共同推出鸿蒙生态分论坛，将邀请鸿蒙生态核心共建企业的管理者、技术专家项目负责人等，分享基于鸿蒙带来的千行百业技术创新及解决方案。
随着万物互联时代的到来，鸿蒙操作系统正在构建面向消费市场、行业市场终端设备生态，为包括个人消费、医疗、金融、能源、工业、交通等行业提供统一融合的数字化创新基础平台。
OpenHarmony是由开放原子开源基金会孵化及运营的开源项目，目标是面向全场景、全连接、全智能时代、基于开源的方式，搭建一个智能终端设备操作系统的框架和平台，促进万物互联产业的繁荣发展。
联合出品人：张伟
OpenHarmony工作委员会开发者与活动运营工作组负责人，华为HarmonyOS开发者运营高级经理
鸿蒙生态分论坛重点议题包括OpenHarmony生态进展，分享重点行业实现商业落地的成功案例，软硬件产品商业化最新进展等。
3 加强开源治理和合规管理，助力开源产业健康发展
大会与中国信通院云计算与大数据研究所联袂举办开源治理与合规分论坛，聚焦如何构建可信的企业开源治理体系，并分享企业开源合规治理的最佳实践。
联合出品人：郭雪
中国信通院云大所开源和软件安全部主任，主要从事开源、安全相关工作，目前担任中国通信标准化协会TC608开源治理、云安全工作组组长。牵头编写ITU标准《云计算风险管理框架》，建立可信开源标准体系，牵头编写《开源生态白皮书》等十余本开源及安全领域白皮书。
此次分论坛将展示中国信通院云大所在可信开源领域取得的系列成果，并分享在标准建设、产业研究、生态构建等方面最新进展。分论坛议题主要包括开源管理的最佳实践分享、企业如何建立开源管理架构和制度、以及开源全生命周期管理等，帮助企业提升开源软件治理能力。
4 加快智能汽车开源应用，提升产业核心竞争力
加快汽车领域的开源开放及生态建设，已成为推动中国汽车产业发展的重要手段和必然趋势。大会与OpenSDV汽车软件开源联盟、中国汽车工业协会软件分会联袂呈现开源开放赋能汽车软件创新分论坛，邀请车企管理层、开源技术大咖、行业专家、技术专家和项目负责人等，聚焦智能汽车前沿技术与解决方案，展示分享开源开放赋能汽车软件创新发展的理论与实践。
联合出品人：滕召智
OpenSDV汽车软件开源联盟技术生态总监，中国科协开源技术传播委员会委员，CCF开源发展委员会执委，国家Linux标准工作组成员，苏州自由软件用户组、Trystack社区、息壤开源发起人，苏州高新技术专家库云计算大数据领域顾问。
联合出品人：尤强
中国汽车工业协会技术部副主任兼软件分会执行副秘书长，拥有二十余年汽车信息化及软件行业从业经验，先后就职于中国电子信息产业集团、上海汽车工业集团、中国电子科技集团等大型中央及国有企业，主导并参与多项重点任务。现负责中国汽车工业车用软件领域的重点工作与生态建设。
此次分论坛将深度探讨汽车软件及开源技术的发展，分享开源车控系统和车路协同开源应用案例，助力产业把握开源最新发展动向。
5 构筑AI大模型商业生态，加速开源技术产业应用
大会联合Linux AI &amp; DATA基金会以及中国大模型语料数据联盟共同举办AI大模型商业生态分论坛， 将邀请基础大模型公司、AIGC类社区、开源的行业垂直应用开发方、大模型的基础提供方、及各类企业用户，聚焦开源基础大模型的发展趋势和产业生态内的应用潜力，探讨开源大模型的效能与各行业创新融合，加速开源大模型技术应用推广。
联合出品人：谭中意
Linux基金会AI &amp; Data TAC成员、LF AI &amp; Data Generative AI Commons联席主席，在 SUN、百度、腾讯等有超过20年开源工作经验，现在第四范式负责 AI 开源，是企业智能化转型开源社区—星策的发起人。
联合出品人：王宇
上海人工智能实验室产业生态合作中心负责人。曾参与国家“工业互联网平台，工业互联网赋能产业链供应链，智能化生产”等白皮书、标准的编写与制定，对平台生态、智能制造及工业数字化转型发展趋势、业务及商业模式创新有深入的理解和实践经验。2020年入选“福布斯中国科技女性榜”。
分论坛重点议题包括AI大模型技术在垂直行业的创新应用、开源基础大模型的发展趋势等，还将邀请来自百川、智谱、腾讯、华为盘古、阿里通义等业内专家，共话开源与大模型应用的未来前景。
6 开源赋能企业数字化，提升智能生产力
大会与开放原子开源基金会联袂出品源聚一堂--开源项目应用实践分论坛，邀请政府领导、基金会负责人、行业专家深度分享，聚焦国产开源项目应用与发展，洞见开源技术发展趋势，解读开源应用成功案例，为开发者和管理者提供借鉴。
联合出品人：李博
开放原子开源基金会运营部负责人，全国信标委人工智能分委会开源工作组组长，参与OpenHarmony、openEuler、XuperCore等知名开源项目的孵化运营。致力于推动云原生、大数据、人工智能、区块链各技术领域开源建设，共同推动开源生态繁荣发展。
此次分论坛将全面展现国内优秀开源项目的技术发展趋势与行业应用最新实践，提升本地企业的开源竞争力，基于开源提升科技创新能力，并为成员企业及优质项目提供推广机会。重点议题将包括操作系统、数据库、云原生、区块链等众多技术方向的产业端开源应用赋能企业数字化转型的实践案例，精彩内容不容错过。
2023开源产业生态大会
我们诚挚邀请您拨冗出席、注册参会，分享开源技术应用和创新的实践成果，共议开源产业新未来。11月19日前完成早鸟注册，将能免费参加大会所有议程。11月20日起注册报名需购票参会。
上海开源信息技术协会
协会由致力于开源信息技术创新和产业发展的企业、高校、科研院所、社会组织及专业人员等自愿组成。基于开源、开放、共享理念，有效整合高校、科研院所、企业创新资源，开展开源信息技术创新和应用研究，立足上海，服务全国，推动中国开源信息技术事业发展。 协会主要业务：开源理论及方法论构建、中国开源创新社会工程、上海开源产业开源服务业、数字“一带一路”， 推动我国开源产业及开源服务业快速发展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c753c37d3dc1ef379d53ad373276e3d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798785ac7a20be104f37be763525d9dd/" rel="bookmark">
			【VSCode】VSCode自定义代码编辑区背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // A code block { "editor.fontSize": 16, "editor.mouseWheelZoom": true, "editor.tabSize": 2, "workbench.colorCustomizations": { // 写在 Atom One Light 里面则只对该主题有效 "[Atom One Light]": { "editor.background": "#c5f3cb", "sideBar.background": "#d9f1d1", "activityBar.background": "#ddeedd", // 终端前景背景色 "terminal.foreground" : "#141416", "terminal.background" : "#a0ecd9" }, "editorLineNumber.foreground": "#f19012", }, "workbench.statusBar.feedback.visible": false, "workbench.colorTheme": "Atom One Light", } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ea9256af3e5184da6385a5cf5180ff/" rel="bookmark">
			银河麒麟系统还原后的激活方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银河麒麟系统还原后的激活方法
1.还原前，在日系统查看备份自己的服务序列号: 我的电脑右击查看或者桌面打开终端输入 cat /etc/.kyinfo [servicekey]，key=就是你的服务序列号)。
或者直接打开计算机属性 激活 微信扫码查看
2.输入命令 cat /etc/.kyactivation 记录20位激活码
3.官网下载安装最新银河麒麟系统
4.新系统打开终端输入 sudo kylin-system-verify 等会按提示回车，请输入服务序列号 出来二维码 不用管 回车输入之前的激活码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9507624519f09a19052d43b6b7ecf0ba/" rel="bookmark">
			真实感渲染的非正式调研与近期热门研究分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		真实感渲染的非正式调研与近期热门研究分享 1 期刊1 Top2 Venues 2 Rendering Reserach1 Material2 BRDF3 Appearance Modeling4 Capture5 Light Transport光线传播6 Differetiable Rendring-可微渲染7 Ray Tracing8 Denoising降噪9 NeRF 3 VR/AR4 Non-Photorealistic Rendering5 AIGC6 总结7 问题 1 期刊 1 Top SIGRAPH
SIGRAPH Asia
TOG
2 Venues 2 Rendering Reserach NeRF-叫神经渲染，
今年的研究工作那些工作可以看：
1 Material 表示与压缩
2 BRDF 3 Appearance Modeling 4 Capture 5 Light Transport光线传播 目前新的方法都是神经网络来做。
6 Differetiable Rendring-可微渲染 两个老师在做
7 Ray Tracing 8 Denoising降噪 自己多设计点东西，神经网络少跑点，只要不是表面都特别糊，比如毛发边缘就特别糊。
9 NeRF 只是描述特殊光照下是什么样子2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9507624519f09a19052d43b6b7ecf0ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f746d2180f9d36fef9baa0cf78cb3e49/" rel="bookmark">
			UE4编辑器下用C&#43;&#43;修改蓝图对象的属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 if (auto Property = FindFProperty&lt;FStrProperty&gt;(Class, "A")) { Object-&gt;Modify(); Property-&gt;SetPropertyValue_InContainer(Object.GetClass(), "OK"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e4f2328e819107f400235fcda028ed/" rel="bookmark">
			Docker使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载安装 在linux下安装docker一共有三步：
更新软件包列表 sudo apt-get update
安装docker sudo apt-get install docker-ce
检查docker是否安装成功 docker --version
更详细的docker安装可以参考ubuntu18.04安装docker
安装完成后，为了避免每次命令都输入sudo，可以设置用户权限 sudo usermod -a -G docker $USER
2.docker使用 2.1 docker相关命令 查看docker的镜像 docker images
查看所有docker容器 docker ps -a
进入镜像 sudo docker restart e4a777571d87
sudo docker attach e4a777571d87
常用进入镜像命令为：
docker exec -it e4a777571d87 /bin/bash
停止容器 sudo docker stop tndl-con
重启容器 docker restart tndl-con
删除容器，删除前应先暂停容器 docker rm -f tndl-con
删除镜像，删除镜像前应先停掉相关容器的运行 docker rmi tndl-img:v1
2.2 将相关程序封装成docker容器 创建一个dockerfile，大致的模版如下： # 使用一个适合的基础镜像，这里以Ubuntu为例 FROM ubuntu:latest # 安装所需的依赖库，例如libssl1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83e4f2328e819107f400235fcda028ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a667dc688bdda9a5445f186779b169/" rel="bookmark">
			adb 工具下载及其环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 adb 工具下载 官方下载地址：https://developer.android.com/studio/releases/platform-tools
二、 adb 环境配置 下载后解压放置到C盘，复制文件夹地址：C:\platform-tools 右击此电脑，点击属性
点击高级系统设置–&gt;点击环境变量
windows 11 点击属性后： 点击系统，右侧向下滑动找到高级系统设置后并点击点击环境变量
新建系统变量 变量名：输入ANDROID；粘贴变量值：输入C:\platform-tools；点击确定
把变量写入本地路径 双击打开系统变量中的Path 变量cccd点击新建地址 ：输入 %ANDROID%点击下方确定
三、确认环境配置 同时按住Windows键+R键电脑左下角框内输出CMD，点击确认打开cmd窗口
在cmd 窗口中输入adb ； 安装成功显示如下：安装地址为C:\platform-tools\adb.exe
安装失败显示如下：可以在环境变量里更改一下ANDROID的名字，重新点击确认
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5304c4007cfdaf5a846a2f27089a473/" rel="bookmark">
			PTA Python作业五
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 判断题
选择题
编程题
7-1 计算水费
7-2 今天过后，明天是几号啊
7-3 s=1+2+3+...+n直到s&gt;=m
7-4 水仙花数
判断题 1-1 在if-elif-else结构中，else子句是可选的。（T）
1-2 Python可以比较字符串，但不区分大小写。（F）
1-3 布尔表达式，表示对和错的单词既可以大写，也可以使用小写，如：ture，TRUE。（F）
1-4 Python中if语句冒号后的语句块中的所有语句的缩进必须相同。（T）
1-5 if语句可以同时进行多个条件判断，使用”or“作为连接。只要其中一个条件成立，该项结果为TRUE。（T）
1-6 循环结构中的continue语句是使整个循环终止执行。（F）
1-7 break语句只能用于循环语句中。（T）
1-8 如果仅仅是用于控制循环次数，那么使用for i in range(20)和for i in range(20, 40)的作用是等价的。（T）
1-9 在循环中continue语句的作用是退出循环的当前迭代。（T）
1-10 下面程序输入36，输出是10。（F）
a=[3,5,7,11,13,16,21,24,28,32,36,40,46] x = int(input()) found = -1 left = 0 #第一个元素下标 right = len(a)-1 #最后一个元素下标 while left&lt;right: mid = (left + right) // 2 if a[mid] &gt; x: right = mid - 1 elif a[mid] &lt; x: left = mid + 1 else: # a[mid]==x found = mid break print(found) 选择题 2-1 下面（D）语句的写法是正确的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5304c4007cfdaf5a846a2f27089a473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041e3c685408de9ad44fdf4222a517a8/" rel="bookmark">
			【H3C HCL Cloud Lab平台搭建防火墙做路由实现多网段内网PC访问外网】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A.搭建环境：
1.HCL Cloud Lab 5.10.0
2.Oracle VM VirtualBox 6.0.14
3.Windows 11操作系统
4.本地以太网卡：Killer E2600 Gigabit Ethernet Controller
（IP：192.168.8.126）
5.TP-LINK无线路由器（路由器IP：192.168.8.1）
B.网络拓扑图：
C.设备配置：
1.Host-Internet：（本地连接）
NIC:Realtek PCIe GbE Family Controller → FW-A：GE_0/2
2.SW-A：（交换机）
SW-A：GE_0/1 → GE_0/1
&lt;H3C&gt;sys //进入系统视图 [H3C]sysname SW-A //修改设备名称 [SW-A]vlan 10 //创建vlan10 [SW-A-vlan10]port GigabitEthernet 1/0/5 to GigabitEthernet 1/0/15 //将5-15端口划入vlan10 [SW-A-vlan10]vlan 11 //创建vlan11 [SW-A-vlan11]port GigabitEthernet 1/0/16 to GigabitEthernet 1/0/25 //将16-25端口划入vlan11 [SW-A-vlan11]vlan 100 //创建vlan100（业务数据通道） [SW-A-vlan100]port GigabitEthernet 1/0/1 to GigabitEthernet 1/0/4 //将1-4端口划入vlan100 [SW-A-vlan100]interface vlan 100 //进入vlan100管理视图 [SW-A-Vlan-interface100]ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041e3c685408de9ad44fdf4222a517a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e292eff11e24b4846d59ac359d423491/" rel="bookmark">
			【无标题】【教3妹学编程-算法题】2918. 数组的最小相等和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3妹：呜呜，烦死了， 脸上长了一个痘
2哥 : 不要在意这些细节嘛，不用管它，过两天自然不就好了。
3妹：切，你不懂，影响这两天的心情哇。
2哥 : 我看你是不急着找工作了啊， 工作那么辛苦，哪还有时间想这些啊。
3妹：说到找工作，我又要去刷题了。
2哥：我给你出一道关于美丽的题吧，让你的心情美丽美丽~
3妹：2哥真能忽悠，心情好了让刷题，心情不好也让刷题，那请问啥时候不用刷题勒？
2哥：是进亦忧，退亦忧。然则何时而乐耶？其必曰：刷完之后就不用刷了。哈哈
3妹：切，刷完了2哥要请吃饭！
题目： 给你两个由正整数和 0 组成的数组 nums1 和 nums2 。
你必须将两个数组中的 所有 0 替换为 严格 正整数，并且满足两个数组中所有元素的和 相等 。
返回 最小 相等和 ，如果无法使两数组相等，则返回 -1 。
示例 1：
输入：nums1 = [3,2,0,1,0], nums2 = [6,5,0]
输出：12
解释：可以按下述方式替换数组中的 0 ：
用 2 和 4 替换 nums1 中的两个 0 。得到 nums1 = [3,2,2,1,4] 。用 1 替换 nums2 中的一个 0 。得到 nums2 = [6,5,1] 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e292eff11e24b4846d59ac359d423491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20bbeb2a09515e388c425715343af811/" rel="bookmark">
			选择题环节，引流江苏银行，南京银行，中国银行，中国农业银行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字节跳动 秋季招聘 看看还有无你的合适岗位
字节跳动秋招上车！看看还有无你的合适岗位～内推码:XKYMWNJ投递链接:https://job.toutiao.com/s/idKwUuoD
题解 | #找出字符串中第一个只出现一次的字符#
#include &lt;stdio.h&gt;int main() { char str[1001] ,b; int i=0,j=0,o=0,a=
请教一道素数相关算法题
题目：定义"好数"：当且仅当该数可以写成两素数的乘积，求大于x的最小"好数"。（ 1&lt;=x &lt;= 1^10）
美团排序
hr面两个多星期了，啥时候能泡出来啊。许愿一下，团子收了我把[牛泪]
题解 | #迭代器遍历容器#
#include &lt;iostream&gt;#include &lt;vector&gt;// write your code here......usi
12306项目有一起合购的吗？
有没有朋友一起的？好兄弟们
三星电子研究院C++开发一面
1、英文自我介绍2、C++ vector 和 list 区别，查找性能有区别吗，如何改进方式3、智能指针相关4、Dash 协议具体原理，如何切换码率的5、遇到吞
货拉拉深圳怎么样
有没有uu 讲下货拉拉日常工作体验，base深圳。在考虑要不要去实习
Offer
211文科硕 会日语B端销售多少底薪合适呀？有个offer给了底薪5500（深圳联建光电），有友友了解这个公司吗，做LED屏的，朋友们不太建议去，HR对提成的
家人们帮忙看看
#大华##新华三#大华薪资地点都挺满意的，就是考虑全网风评太差，不然直接签了新华三薪资应该比较低，听说这个月中旬开奖，大华那边可能要撑不住了
等不到华为了收到了荣耀的offer
等不到华为了收到了荣耀的offer不是自己喜欢的岗工资待遇和自己的预期差不多签了
小红书运营（兼职）
小红书运营（兼职） "岗位要求：1、在校大学生，能够长期持续工作3个月以上者优先考虑；2、不需要线下办公，随时随地都可以，每天可兼职时长≥2小时；3、重度
xdm二选一，推荐一下呗海尔 medp
xdm二选一，推荐一下呗海尔 medp智能制造岗芯恩 研发工程师工资根据hr给的信息基本一样，海尔公积金高些，但据说单休，岗位也待定，怕是去流水线芯恩半导体前景
等不等银行
bg双非本211硕，已有一个中电的offer，事业编+户口，组里偏预研方向不加班，总包20w出头。北京银行，农行北分这周才通知一面，是否还需要等银行，银行的薪资
浅问一下邮储面试一般要多久呀？下午四点开
浅问一下邮储面试一般要多久呀？下午四点开始面，大概多久能面完？
想问下牛友实习工资
下学期开学就要去实习啦，offer上说实习工资按天结算。那我去实习四个月，是按照一周五天来结算还是一周七天来结算啊？
航天三院三部面试
地点是丰台云岗，真滴偏，主要是偏嵌入式开发，但是不太会...1、自我介绍之后问了几个常规八股2、进程和线程区别3、数据索引底层原理、查询优化4、实验室项目具体说
中国邮政笔试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20bbeb2a09515e388c425715343af811/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ce348d077602eb4377eaf515c083fb/" rel="bookmark">
			HTML5&#43;CSS3实现小米商城（完整）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对面小米商城这个首页，我想肯定是很多在校学生在学习前端课程的时候，老师经常布置的一个作业。
这个页面整体结构不算复杂，下面是我的分析，我想一定会对你产生一些帮助。
话不多说，先展示一下网页实现效果，看是否符合你的要求，如果不符合，也可以私信我！（有些图片可能已经产生了一些变动，莫慌！联系我，帮你解决）
一、网页效果展示 二、部分代码展示 &lt;div class="head2"&gt; &lt;img class="head2_img" src="../imgs/logo.png" alt=""&gt; &lt;div class="head2_div1"&gt; &lt;div class="head2_div1_1"&gt; &lt;span class="tou2_s"&gt;Xiaomi手机&lt;/span&gt; &lt;div class="head2_x1"&gt; &lt;div class="x1"&gt; &lt;div class="x1_1"&gt; &lt;a href="#"&gt; &lt;img src="../imgs/shouji1.webp"&gt; &lt;p class="x1_p1"&gt;Xiaomi 12S Ultra&lt;/p&gt; &lt;p class="x1_p2"&gt;5999元起&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="x1_2"&gt; &lt;a href="#"&gt; &lt;img src="../imgs/shouji2.webp"&gt; &lt;p class="x1_p1"&gt;Xiaomi 12S Pro&lt;/p&gt; &lt;p class="x1_p2"&gt;5999元起&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="x1_3"&gt; &lt;a href="#"&gt; &lt;img src="../imgs/shouji3.webp"&gt; &lt;p class="x1_p1"&gt;Xiaomi 12S&lt;/p&gt; &lt;p class="x1_p2"&gt;3999元起&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="x1_4"&gt; &lt;a href="#"&gt; &lt;img src="../imgs/shouji4.webp"&gt; &lt;p class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76ce348d077602eb4377eaf515c083fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad7315009b4f4910f57fbaa9d01b6fc/" rel="bookmark">
			WSL2 &#43; Docker &#43; xfce4安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL2 + Docker + xfce4安装及使用 WSL官方指南：适用于 Linux 的 Windows 子系统安装指南 (Windows 10)
文档比较详细，而且会持续更新，欢迎大家指错。
文章目录 WSL2 + Docker + xfce4安装及使用一、前言1.1 什么是WSL?1.2 比较 WSL 1 和 WSL 21.3 WSL可以做什么？ 二、便捷自动安装（本人未测试）三、手动安装 WSL 23.1 启用适用于 Linux 的 Windows 子系统*3.2 更新到 WSL 23.2.1 检查运行 WSL 2 的要求3.2.2 启用“虚拟机平台”可选组件*3.2.3 将 WSL 2 设置为默认版本3.2.4 下载 Linux 内核更新包 3.3 安装所选的 Linux 分发版3.3.1 下载 Linux 分发版3.3.2 设置新分发版3.3.3 修改ubuntu的apt安装源3.3.4 重置 Linux 密码(可选)3.3.5 忘记密码(可选)3.3.6 修改root用户密码(可选)3.3.7 修改默认用户root(可选) 3.4 自定义分发版安装目录(可选，推荐)3.4.1 如果未安装分发版3.4.2 如果已经安装分发版(未测试) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ad7315009b4f4910f57fbaa9d01b6fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f5bb98196811c8e9af8584831a7e05/" rel="bookmark">
			工具类xxxUtil从application.properties中读取参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.原因
编写一个服务类的工具类，想做成一个灵活的配置，各种唯一code想从配置文件中读取，便有了这个坑。
二.使用@value获取值为null,
这是因为这个工具类没有交给spring boot 来管理，导致每次都是new 一个新的，所以每次取出来的值都是nu l l
三.解决方案
方法1:
@Component public class MyUtil { private static String str; @Value("${zjg.name}") public void setStr(String str){ MyUtil.str = str; } //使用 public static void dd(){ System.out.println(str); } } 方法2:
public class MyUtil { private final static ResourceBundle resourceBundle = ResourceBundle.getBundle("application"); private final static String str = resourceBundle.getString("zjg.name"); //使用 public static void dd(){ System.out.println(str); } } 注： private final static ResourceBundle resourceBundle = ResourceBundle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f5bb98196811c8e9af8584831a7e05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e844c6c76450a755ca5252b781c7fb/" rel="bookmark">
			Kibana Dashboard饼图展示keyword子字符串去重统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日志内容 log.info("请求开始 uri: {} header RequestId:{}", request.getRequestURI(), reqId, request.getHeader("request_id")); 操作步骤 进入Dashboard菜单
点击Create Dashboard按钮
点击Create Panel按钮
选择Aggregation based
然后选择Pie饼图
配置 添加整体过滤的关键词(图: 请求开始 url), 确保代码里唯一, 全局过滤
选择UniqueCount及字段, 表示按照message字段进行分组统计
以message为关键词分组, 提取TOP50, 并展示Other统计结果
从message中取关键词, _value为目标字符串
{ "script": "(_value.indexOf('header') &gt; 0 ? _value.substring(9, _value.indexOf('header')) : _value)" } 注意: 每次更改之后需要点击右下角 update按钮, 然后再Refresh查看效果
![在这里插入图片描述](https://img-blog.csdnimg.cn/5bdba2422ebd4b33ab7fd8dd5bdf4e92.png
效果图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10766b084ef3eb3fb6d96e0a6c486d8/" rel="bookmark">
			ArcGIS Pro设置谷歌影像（无水印）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 打开软件，命名工程文件，底图（Basemap）选择【天地图】。 2 点击【视图（View）】——&gt;【目录面板（Catalog pane）】，在【门户（Portal）】中搜索【新版谷歌】，即可找到 【新版谷歌底图】,这个是没有水印的，非常好使。 3 加载后，就可以画图了。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/47/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>