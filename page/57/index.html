<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea0b1493dd9a5312c426e820bf8f4ce/" rel="bookmark">
			摄像头打不开怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【求助】摄像头打不开，各种方法都试了，还是无法解决！怎么办？别急，我将会分享一些可能帮助你解决问题的实用技巧！
联想知识库https://iknow.lenovo.com.cn/detail/205568
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f745dd3c4bc9e94f7d33c5c1ec1ac7e2/" rel="bookmark">
			python期末题库和答案,python 期末卷及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编来为大家解答以下问题，python期末题库和答案，python 期末卷及答案，今天让我们一起来看看吧！
下面是eval()函数作用的是：‬‬
A去掉参数中元素两侧所有引号，含单引号或双引号，当作Python语句执行
B直接将参数中元素当作Python语句执行
C去掉参数中做外侧一对引号，含单引号或双引号，当作Python语句执行
D在参数两侧增加一对单引号，当作Python语句执行
正确答案 C ：eval(x)函数用于去掉参数x最外侧一对引号。
下面属于import保留字作用的是： ‬
A改变当前程序的命名空间
B每个程序都必须有这个保留字
C引入程序之外的功能库
D当调用函数时需要使用该保留字
正确答案 C ：import保留字仅用于引用外部库
下列选项中不符合Python语言变量命名规则的是‬‬
A I
B TempStr
C 3_1
D _AI
正确答案 C
给出如下代码
TempStr =“Hello World” 可以输出“World”子串的是‬‬
A print(TempStr[–5:])
B print(TempStr[–5: –1])
C print(TempStr[–4: –1])
D . print(TempStr[–5:0])
正确答案 A
5关于Python程序中与“缩进”有关的说法中，以下选项中正确的是‬
A缩进在程序中长度统一且强制使用
B缩进是非强制性的，仅为了提高代码可读性
C缩进统一为4个空格
D缩进可以用在任何语句之后，表示语句间的包含关系
正确答案 A
Python 语言中，以下表达式输出结果为11的选项是
A print(eval(“1” + “1”))
B print(eval(“1+1”))
C print(1+1)
D print(eval(“1” + 1))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f745dd3c4bc9e94f7d33c5c1ec1ac7e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bdf67f7738611a4513f3c47682826c7/" rel="bookmark">
			联想电脑虚拟化开启方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【干货】联想电脑虚拟化开启指南！简单易学，轻松上手！
在当今这个数字化时代，虚拟化技术已经成为了许多电脑用户的必备技能。而虚拟化技术也成为了联想电脑用户所追求的一项重要功能。本文将为大家介绍如何开启联想电脑的虚拟化功能，让您轻松上手，实现电脑的优化与升级！
本文将详细介绍联想电脑虚拟化的开启方法，包括BIOS设置、操作系统的支持以及常见问题和解决方案等方面。无论您是刚开始接触虚拟化还是有一定经验的用户，相信本文都能为您的联想电脑虚拟化开启提供有益的参考和指导。让我们一起来看看如何轻松开启联想电脑虚拟化，享受更加便捷的数字生活！
联想知识库https://iknow.lenovo.com.cn/detail/125894
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071a03089bc2c14b651f1aff018848b4/" rel="bookmark">
			我的电脑突然黑屏了，怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【紧急求助】电脑突然黑屏了，没有任何反应，怎么办？别担心，我将会分享一些解决这个问题的实用技巧！
不加电 如何判断机器不加电？ 可观察笔记本侧面指示灯/开关键（部分机器支持）是否有白色常亮/闪烁、琥珀色慢闪/快闪等状态，也可查看机器内置键盘大小写指示灯状态，若此类指示灯都是熄灭状态，重新开机依旧无反应，则说明机器不加电；
台式机一体机也可参考相关指示灯是否闪烁/常亮，也可观察或听下风扇，若风扇不转，相关灯也是熄灭状态，说明机器可能处于不加电状态；
不加电情况如何处理？ 内容较长请点击我查看更多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2dbbc1c1eeeae5a4440f0a42e0a724/" rel="bookmark">
			电脑或服务器IP地址配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开控制面板，点击网络和Internet，点击网络和共享中心，点击所连接的网络
点击属性，找到TCP/IPv4，双击进入。
选择使用下面的IP地址，输入要配置的网络ip，点击高级，点击添加，可配置多个ip。
如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033aa7f66f7d7815ca42147f409196eb/" rel="bookmark">
			C# 代码实现打印以及各种设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.有弹出窗口打印 private void btnPrint_Click(object sender, EventArgs e) { PrintDocument printDocument1 = new PrintDocument(); //printDocument1.DefaultPageSettings.PrinterSettings.PrinterName = "ZDesigner GX430t";//打印机名称设置 //printDocument1.DefaultPageSettings.PaperSize = new PaperSize("Custum", label_biaoda1.Width, label_biaoda1.Height);//设置纸张大小 printDocument1.PrintPage += new PrintPageEventHandler(this.PrintDocument_PrintPage); PrintPreviewDialog printPreviewDialog1 = new PrintPreviewDialog(); printPreviewDialog1.Document = printDocument1; DialogResult result = printPreviewDialog1.ShowDialog(); if (result == DialogResult.OK) printDocument1.Print(); } //以下代码获取到一张用作打印内容的图片 private void PrintDocument_PrintPage(object sender, System.Drawing.Printing.PrintPageEventArgs e) { //Image image = Image.FromFile(@"D:\0000-临时文件\4.png"); Bitmap _NewBitmap = (Bitmap)img; /* e.Graphics.DrawImage(_NewBitmap, 0, 0, _NewBitmap.Width, _NewBitmap.Height);//调整图片的大小 e.Graphics.DrawImage(_NewBitmap, 0, 0, 570, 380);*/ //各种调整，消除锯齿 /*e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/033aa7f66f7d7815ca42147f409196eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/742a126ffbed9a783408e1fc130de422/" rel="bookmark">
			STM32 USB CDC 虚拟串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 用虚拟串口(USB CDC VCP)感觉有些不稳定，尤其是下位机掉电后再上电，上位机虚拟的那个串口根本不能用，还有就是 // 必须等虚拟串口出来后且知道串口号上位机才可以执行打开操作 // 上面是实际情况，但并不是STM32的USB不行，而是PC端的驱动程序有问题。或者说是PC机的驱动程序机制造成的。 // 如果是PC机正常的RS-232串口，断掉连接线，但串口硬件还是在的，所以重新接上连接线后，就能通信继续通信。 // 但CDC类的USB转串口，当USB线断掉时，实际上PC机上已经没有该串口设备了，程序中的串口句柄已经无效了。但当USB线再次连接时，PC机给新的USB转串口分配的是新的内存，所以原来的句柄显然不能访问新的串口。 // 换句话，USB转串口设备，可以当串口设备使用，但毕竟不是串口设备。 // 所以说，PC端软件也是需要进行一些修改的。比如，接收USB设备的插入、拔出的消息，以便进行适当的处理。 //不管虚拟串口的事，跟USB底层驱动有关。只要你开着虚拟串口，USB底层驱动就一直加载着，不会因为你断开设备而卸载。这样的话，第二次插入USB设备的时候，就有问题了。 下载好程序后，识别不到串口，同过zadig 找到当前 usb描述，切换为USB cdc，然后拔掉电脑端的USB,重新插上就能识别到 USB虚拟串口了。
上面这样操作，有可能导致串口，数据丢包等其他异常 。
最终通过下面的操作 自己选择驱动解决。
不要选择win32， 选择下面的libwdi
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ffe2064c8bd7487638bc59102cc201/" rel="bookmark">
			车载娱乐系统之Android系统CarFramework流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，背景介绍
1.1 Android Automotive与整个Android生态系统的关系
1.2 Android Automotive架构
二，CarService启动流程
三，CarService源码分析
四. Car API 使用方式
4.1 编译 Car API
4.2 使用 Car API
一，背景介绍 Android Automotive OS 定义了标准的硬件抽象层HAL(Hardware Abstraction Layer)来规范各个子系统与Framework的调用接口, 并且通过CarService以及相关的Car API对上层应用提供标准编程接口。
1.1 Android Automotive与整个Android生态系统的关系 Android Automotive是Android的一部分。 Android Automotive不是Android的分支或并行开发，它与手机，平板电脑等安卓设备上的Android具有相同的代码库，并且位于相同的存储库中。它基于经过10多年开发的强大平台和功能集，可利用现有的安全模型，兼容性程序，开发人员工具和基础架构，同时继续具有高度可定制性和可移植性，完全免费和开源的特点。
Android Automotive扩展了Android 。在将Android打造为功能齐全的信息娱乐平台的过程中，我们添加了对汽车特定要求，功能和技术的支持。就像今天用于移动设备的Android一样，Android Automotive将是一个完整的汽车信息娱乐平台。
1.2 Android Automotive架构 Android Automative是在原先Android的系统架构上增加了一些与车相关的（图中虚线框中绿色背景的）模块。
Car App ：包括OEM和第三方开发的AppCar API ：提供给汽车App特有的接口Car Service ：系统中与车相关的服务，主要是基于CarProperty实现Vechile相关的一些策略Vehicle Network Service ：汽车的网络服务Vehicle HAL ：汽车的硬件抽象层描述，定义 OEM 可以实现的车辆属性的接口 二，CarService启动流程 细节代码如下:
路径：/frameworks/base/services/java/com/android/server/SystemServer.java
if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) { t.traceBegin("StartCarServiceHelperService"); mSystemServiceManager.startService(CAR_SERVICE_HELPER_SERVICE_CLASS); t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ffe2064c8bd7487638bc59102cc201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221d6dbf7b4481a5067714d2c0b0feb9/" rel="bookmark">
			linux系统anaconda常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除虚拟环境及该环境下的所有包
conda remove -n env_name --all 只删除环境保留包
conda env remove -n env_name
查看已存在虚拟环境
conda env list
创建虚拟环境
conda create --name xxx python=3.xxx
conda activate base
conda deactivate
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d547f20d7e3316a7794db5fd88da97/" rel="bookmark">
			2023中秋活动征文获奖名单已公布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023中秋活动征文获奖名单已公布，快看看你上榜没！
获奖名单 用户ID活动期间高质量原创博文数qq_22593423105weixin_47225948101m0_6514457088deepviewinsight82m0_7373170870m0_62617719692201_7596016965qq_5094209361leva34556qq_4477110255qq_4571427254weixin_5200320545m0_6383498842weixin_4792401629qq_3113651325qq_2148446123m0_4947624122jiong941220m0_6377421117yangshangwei16 恭喜以上上榜博主，还请上榜博主9月24日之前到此填写地址，以便运营人员尽快为您邮寄奖品，若用户对此名单存疑，也可联系官博微信（CSDN blog）进行咨询沟通哦～
评选标准 1、在活动期间发布高质量原创博文即可
2、通过其他渠道已经获得中秋礼品的博主本次活动不可再获得
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d98eee47f43ccb1a8166afd487fdf27/" rel="bookmark">
			解决GitHub.com无法访问，连接超时的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、ping github网站（Ping github.com），ping不通，说明dns无法解析导致的
2.打开C:\Windows\System32\drivers\etc\hosts，在文件末尾添加如下内容，并保存：
192.30.255.112 github.com git 185.31.16.184 github.global.ssl.fastly.net 3.重启cmd窗口，继续ping一下github.com，本机已经能够正常解析github.com这个域名。
4.打开浏览器重新输入https://github.com/可以访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a2ff5ac10b34973bb6fb2690ccec5e/" rel="bookmark">
			Nodejs错误处理详细指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nodejs错误处理详细指南 学习 Node.js 中的高级错误处理技术，以增强应用程序的可靠性和稳定性。
在 Node.js 中，我们可以使用各种技术和方法来处理错误，可以查看这篇文章。错误处理是任何 Node.js 应用程序的一个重要方面。正确管理错误可以显着提高代码库的稳定性、可靠性和可维护性。在这篇文章中，我们将探索 Node.js 中错误处理的各种最佳实践和技术，使我们能够像经验丰富的 Node.js 开发人员一样处理错误。
我们可以在 Node.js 中采用多种高级错误处理技术。这些技术允许对错误处理进行更精细的控制，增强错误报告并提高代码可维护性。以下是 Node.js 中的一些高级错误处理技术：
错误中间件错误处理框架错误冒泡优雅关机错误监控和报告断路器模式背压处理自动重试日志记录和分析 1. 错误中间件 Express 等框架中的错误中间件功能允许我们处理请求处理期间发生的错误。当错误传递到 next方法时，将执行这些错误处理函数。以下是逐步细分的步骤：
步骤1：定义错误中间件函数，有四个参数：err、req、res 和next。
app.use((err, req, res, next) =&gt; { // Handle the error }); 步骤2：在错误中间件函数内处理错误。我们可以访问错误消息、状态代码和其他相关详细信息，以制定适当的错误响应。
app.use((err , req, res, next ) =&gt; { // 处理错误 res.status (err.status || 500 ).json({ error : err.message }); }); 示例1 app.get('/users/:id', (req, res, next) =&gt; { const userId = req.params.id; if (userId === 'admin') { const error = new Error('Access denied'); error.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31a2ff5ac10b34973bb6fb2690ccec5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab266839fd44c03a0f348b652a844f4d/" rel="bookmark">
			kafka 3.5 日志定时清理(源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、定时任务入口二、LopManager(这个是日志抽象层，实际逻辑不在这里)1 把日志清理加入定时任务中 三、清理符合条件的日志1、deletableSegments(把需要删除的segment加入待删除的集合)(1)如果主题分区的logStartOffset大于segment的baseOffset(2)如果主题分区文件总大小大于配置中retention.bytes(最大留存大小)(3)如果主题分区各个segment的修改时间和当前时间差大于配置的retention.ms(最大留存时间) 2、把上面待删除segment执行删除操作1、把segment文件后缀改成.deleted2、异步执行删除文件后缀是.delete的文件(加入只执行一次定时任务中) 四，segment相关文件有哪些整理五、问题:1、如果segment最大留存时间和分区最大留存文件大小都不配置会出现什么情况？2、如果只配置segment最大留存时间，并且数据量非常小，能消费最大留存时间之前的数据吗？3、如果只是配置分区最大留存文件大小，并且数据量非常小，能消费到很久以前的吗？ 一、定时任务入口 这里选择kraft的模式启动的定时任务，所以入口是在BrokerServer.scala文件中，如果选择ZooKeeper模式的入口在KafkaServer.scala
def startup(): Unit = { if (!maybeChangeStatus(SHUTDOWN, STARTING)) return try { info("Starting broker") /* start scheduler 开始定时任务*/， kafkaScheduler = new KafkaScheduler(config.backgroundThreads) kafkaScheduler.startup() //省略。。。 //创建日志管理器，但不要启动它，因为我们需要延迟任何潜在的不干净关闭日志恢复 // 直到我们赶上元数据日志并拥有最新的主题和代理配置。 logManager = LogManager(config, initialOfflineDirs, metadataCache, kafkaScheduler, time, brokerTopicStats, logDirFailureChannel, keepPartitionMetadataFile = true) //省略。。。 } catch { case e: Throwable =&gt; maybeChangeStatus(STARTING, STARTED) fatal("Fatal error during broker startup. Prepare to shutdown", e) shutdown() throw e } } 二、LopManager(这个是日志抽象层，实际逻辑不在这里) object LogManager { val RecoveryPointCheckpointFile = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab266839fd44c03a0f348b652a844f4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6919ce2d5057e70eb847ae01619af636/" rel="bookmark">
			uniapp、vue实现滑动拼图验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp、vue实现滑动拼图验证码 实际开发工作中，在登陆的时候需要短信验证码，但容易引起爬虫行为，需要用到反爬虫验证码，今天介绍一下拼图验证码，解决验证码反爬虫中的滑动验证码反爬虫。滑动拼图验证码是在滑块验证码的基础上增加了一个随机滑动距离，用户需要将滑块滑到拼图的缺口处，使拼图完整，才能通过校验。平台兼容性，H5、微信小程序、字节、百度、qq等。
实际开发工作中，在登陆的时候需要短信验证码，但容易引起爬虫行为，需要用到反爬虫验证码，今天介绍一下拼图验证码，解决验证码反爬虫中的滑动验证码反爬虫。
原理
滑动拼图验证码是在滑块验证码的基础上增加了一个随机滑动距离，用户需要将滑块滑到拼图的缺口处，使拼图完整，才能通过校验。
一、不对接口版本 平台兼容性，H5、微信小程序、字节、百度
XXX.vue文件引入
template标签中引入
&lt;slider-verify :isShow="sliderVerifyFLag" @touchSliderResult="verifyResult" ref="verifyElement"&gt;&lt;/slider-verify&gt; script标签中引入组件
import sliderVerify from '@/components/slider-verify/slider-verify.vue';//组件存放的路径 export default { components: { 'slider-verify': sliderVerify }, data() { return { sliderVerifyFLag: false //滑块验证 }; }, onLoad() {}, methods: { // 滑块验证结果回调函数 verifyResult(res) { this.sliderVerifyFLag = false; if (res) { //校验通过 }else{ // 校验失败,点击关闭按钮 } } } }; slider-verify.vue文件代码
&lt;template&gt; &lt;view class="slider-verify-box" v-if="isShow"&gt; &lt;view class="verifyBox"&gt; &lt;view class="slider-title"&gt;图形验证&lt;/view&gt; &lt;view class="slide-content"&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6919ce2d5057e70eb847ae01619af636/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/793573403fdda1d8989cbcdda7af54db/" rel="bookmark">
			SpringBoot整合邮件发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot整合邮件发送 1、导入maven坐标
&lt;!--邮件发送--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 2、编写yaml配置
spring: mail: default-encoding: UTF-8 host: smtp.qq.com password: dpfbdheg #SMTP的密码，并不是自己的登录密码，具体获取下面给出（这里以QQ邮箱为例） port: 587 properties: mail: debug: true protocol: smtp smtp: socketFactory: javax.net.ssl.SSLSocketFactory username: 2059468666@qq.com #自己的电子邮箱 具体实现
@RestController @RequestMapping("/send") @Slf4j public class TestEmailController { @Value("${spring.mail.username}") private String from; @Resource private JavaMailSender javaMailSender; @RequestMapping("/email") public void sendEmailCode(String email,String code, Integer type){ try { Date date = new Date(); SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); //发送人 message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/793573403fdda1d8989cbcdda7af54db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ee21bd59b9514e86272bbb7b61e2ec/" rel="bookmark">
			深入了解卷积神经网络（CNN）中的全连接层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络（CNN）是深度学习领域中应用广泛的神经网络架构，特别适用于图像识别和计算机视觉任务。在CNN的核心中，有一个重要组件称为全连接层，它在网络的顶部扮演着关键的角色。
一、CNN的基本结构 在介绍全连接层之前，让我们简要回顾一下CNN的基本结构。CNN通常由多个层组成，包括卷积层、池化层和全连接层。这些层一起构成了一个层次化的特征提取和分类网络。
卷积层（Convolutional Layers）：卷积层是CNN的核心。它使用卷积核（也称为过滤器）来提取输入数据中的特征，例如图像中的边缘、纹理等。卷积操作有助于减少参数数量，从而提高网络的计算效率和泛化能力。
池化层（Pooling Layers）：池化层用于降低卷积层输出的空间分辨率，同时保留关键信息。常见的池化操作包括最大池化和平均池化。
全连接层（Fully Connected Layers）：全连接层位于CNN的顶部，通常用于分类任务。这是我们将要深入探讨的层级。
二、全连接层的原理 全连接层的原理非常简单，它与前一层的每个神经元都有连接，以及与后一层的每个神经元都有连接，创建了一个密集的连接结构。这意味着每个神经元都与整个相邻层的神经元相连接。这些连接由权重（weights）和偏置（bias）参数控制。
权重（weights）：每个连接都有一个相关联的权重，用于表示连接的强度。权重决定了前一层神经元的输出如何影响后一层神经元的输入。权重是在训练过程中学习的，以最小化网络的损失函数。
偏置（bias）：每个后一层神经元都有一个偏置项，用于调整神经元的激活。偏置的作用是使神经元对某些输入更容易激活。类似于权重，偏置也是在训练过程中学习的。
三、全连接层的作用 全连接层的主要作用是将卷积和池化层的输出转换为最终的分类或回归结果。它通过在网络的最后一层引入全连接操作，将之前层级提取的特征映射转化为类别概率或数值预测。
具体来说，全连接层执行以下功能：
特征整合：卷积神经网络（CNN）的前面层级，包括卷积层和池化层，负责提取输入数据的各种特征。全连接层将这些特征整合在一起，将它们结合成更高级别的表示，以便网络能够进行更复杂的决策和分类。
分类决策：全连接层通常位于神经网络的顶部，它将整合后的特征传递给激活函数，然后生成每个类别的得分或概率。对于分类任务，通常使用softmax函数来将这些得分转化为类别概率，从而决定输入数据属于哪个类别。
参数学习：全连接层包含大量的可学习参数，这些参数在训练过程中通过反向传播和梯度下降来调整。这使得网络能够适应训练数据并进行准确的预测。通过学习适当的权重和偏置，网络能够进行特定任务的学习和泛化。
非线性建模：全连接层中通常包含激活函数，如ReLU（Rectified Linear Unit），用于引入非线性性质。这是神经网络具有强大表示能力的一个重要因素，允许它们学习复杂的数据关系。
四、防止过拟合 全连接层的参数数量通常很大，这可能导致过拟合问题，特别是在数据集相对较小的情况下。为了应对这个问题，研究人员常常采用以下策略：
正则化：通过添加L1或L2正则化项来惩罚权重的大小，以减小模型的复杂性。
丢弃（Dropout）：丢弃是一种正则化技术，随机关闭一部分神经元，以防止它们过于依赖特定的输入。
批标准化（Batch Normalization）：批标准化有助于加速训练过程并提高网络的稳定性，通常应用于全连接层之前的层级。
五、总结 全连接层是卷积神经网络中的关键组件，它将前面层级提取的特征映射整合成最终的分类或回归结果。通过合适的正则化和优化技巧，我们可以更好地应对全连接层的参数量大和过拟合的挑战，从而构建更强大的CNN模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2caa975eee49963818958eb6570dea69/" rel="bookmark">
			Dataset和DataLoader用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dataset和DataLoader用法 在d2l中有简洁的加载固定数据的方式，如下
d2l.load_data_fashion_mnist() # 源码 Signature: d2l.load_data_fashion_mnist(batch_size, resize=None) Source: def load_data_fashion_mnist(batch_size, resize=None): """Download the Fashion-MNIST dataset and then load it into memory. Defined in :numref:`sec_fashion_mnist`""" trans = [transforms.ToTensor()] if resize: trans.insert(0, transforms.Resize(resize)) trans = transforms.Compose(trans) mnist_train = torchvision.datasets.FashionMNIST( root="../data", train=True, transform=trans, download=True) mnist_test = torchvision.datasets.FashionMNIST( root="../data", train=False, transform=trans, download=True) return (data.DataLoader(mnist_train, batch_size, shuffle=True, num_workers=get_dataloader_workers()), data.DataLoader(mnist_test, batch_size, shuffle=False, num_workers=get_dataloader_workers())) File: ~/anaconda3/envs/d2l/lib/python3.9/site-packages/d2l/torch.py Type: function 如果我们要自定义需要加载的数据集
数据集：一个图片文件夹，用csv文件来表示训练数据和标签
# 定义Dataset import pandas as pd import os from PIL import Image from torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2caa975eee49963818958eb6570dea69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12af1e45054ea843b1555f77424bf5c3/" rel="bookmark">
			ARM Cortex-M内核中系统堆栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 有无OS的栈结构区别：裸机的任务栈结构带FreeRTOS操作系统的任务栈 ARM的寄存器有哪些特殊寄存器有哪些 关于FreeRTOS中的SP寄存器栈操作【压栈与弹栈的操作】一般函数嵌套调用时sp指针的变化Cortex-M内核的MSP与PSP作用 有无OS的栈结构区别： 裸机的任务栈结构 无OS的堆栈结构：此时每个任务的堆栈都在一起
带FreeRTOS操作系统的任务栈 在FreeRTOS中对线程、进程没有明显区分，统一称为任务。
有OS的堆栈结构：每个任务都有独立栈空间，用于保存上下文信息和全局变量
ARM的寄存器有哪些 ARM 架构的寄存器可以分为以下几类：
通用寄存器：ARM 架构有 17 个 32 位的通用寄存器，它们命名为 R0-R15，其中 R13-R15 被用作栈指针、链接寄存器（LR）和程序计数器（PC）。
状态寄存器：也称为程序状态寄存器（PSR），用于存储当前处理器的状态信息，例如条件码、中断使能位等。
特殊寄存器：包括控制寄存器、处理器 ID 寄存器、系统控制寄存器等，它们用于控制处理器的一些重要行为和特性。
浮点寄存器：ARMv7 架构引入了 VFP 协处理器，增加了 32 个浮点寄存器（S0-S31），可用于高精度浮点运算。
特殊寄存器有哪些 特殊寄存器是指在 ARM 架构中具有特殊用途的寄存器，包括以下几个：
控制寄存器（Control Register）：用于控制处理器的一些重要行为和特性，如异常处理、缓存设置等。
处理器 ID 寄存器（Processor ID Register）：用于标识处理器的类型和版本信息。
系统控制寄存器（System Control Register）：用于控制系统级的功能和特性，如内存管理单元（MMU）的设置、缓存控制等。
中断控制寄存器（Interrupt Control Register）：用于控制中断的使能和屏蔽，包括中断优先级、中断屏蔽位等。
定时器控制寄存器（Timer Control Register）：用于控制定时器的计数和触发方式，包括定时器的频率、计数模式等。
异常控制寄存器（Exception Control Register）：用于控制异常处理和异常向量表的地址。
这些特殊寄存器在 ARM 架构中扮演着关键的角色，可以控制和配置处理器的各种功能和特性，用于实现更高级的操作和控制。
关于FreeRTOS中的SP寄存器 一般来说Cortex-M系列有两种工作模式：
Thread Mode （线程模式）：程序按照编译好的代码顺序执行
​Handler Mode（中断模式）：收到中断信号并执行中断处理函数
所以，Cortex-M系列内核使用了双堆栈，即MSP和PSP
MSP ： Main_Stack_Pointer 主栈PSP ： Process_Stack_Pointer 任务栈SP ： 堆栈指针，指向最后一个被压入元素的地址 R13在任何时刻只能是其中一个，默认情况为MSP，可以通过控制寄存器：CONTROL寄存器的bit1来改变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12af1e45054ea843b1555f77424bf5c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb6ac28f68d2fa423ace83c5d3109b8/" rel="bookmark">
			Windows，macOS，Linux换行标识的前世今生，如何处理文本文件行尾的^M
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: Windows，macOS，Linux换行标识的前世今生，如何处理文本文件行尾的^M / The Past and Present of Line Break Symbols in Windows, macOS, Linux: How to Deal with ^M at the End of Text Files
categories:
极客实用技巧 / Geek Practical Skills 我们在Windows创建文本文件，默认使用的换行标识为CRLF
🌈When we create a text file in Windows, the default line break symbol is CRLF.
这种CRLF文件在Linux系统中打开，则会在换行的位置显示^M
🌈When this CRLF file is opened in the Linux system, ^M will be displayed at the line break.
为什么会出现^M / Why Does ^M Appear?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb6ac28f68d2fa423ace83c5d3109b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d793ce54484f8230ac33ac02309b690/" rel="bookmark">
			ant-design-vue搞一个等待回调的确认弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上搜了一下没搜到，所以自己搞了一个，分享给跟我一样有需要的小白。
HandleComfirm.vue组件代码：
//HandleComfirm.vue组件代码： &lt;script setup lang="ts"&gt; import { Modal } from 'ant-design-vue'; function checkComfirm(method) { return new Promise((resolve) =&gt; { const modal = Modal.confirm();//这里提示需要输入参数，我没搞明白，希望有大神指点 modal.update({ title: '请确认', content: method.content,//自己的提示语 maskClosable: false,//不允许通过点击蒙版关闭弹窗 onOk: () =&gt; { resolve(true); //console.log('确定了'); }, onCancel: () =&gt; { resolve(false); // console.log('取消了') }, }); }); } defineExpose({ checkComfirm }); &lt;/script&gt; 我这里是vue3 + ts，如果不是用ts的话，那就把lang="ts"去掉就行了，自己灵活了
引用HandleComfirm组件的页面：
&lt;script setup lang="ts"&gt; import HandleComfirm from '/你的组件路径/HandleComfirm.vue'; //通过某个函数触发弹窗，如：handleSubmit async function handleSubmit() { try { //打开并等待用户点击获取回调 const isSubmit = await $handleComfirm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d793ce54484f8230ac33ac02309b690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f30e5c0753b4f8ed4d70a043704d6f/" rel="bookmark">
			SQLMap使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：一、SQLMap安装二、SQLMap介绍1、Sqlmap简介：2、Sqlmap支持的注入方式：3、Sqlmap输出级别： 三、SQLMap使用：1、判断是否存在注入：2、判断文本中的请求是否存在注入：3、查询当前用户下的所有数据库：4、获取数据库中的表名：5、获取表中的字段名：6、获取字段内容：7、获取数据库的所有用户：8、获取数据库用户的密码：9、获取当前网站数据库的名称：10、获取当前网站数据库的用户名称： 四、SQLMap进阶：参数讲解1、`--level 5`：探测等级2、`--is-dba`：当前用户是否为管理权限3、`--roles`：列出数据库管理员角色4、`--referer`：HTTP referer头5、`--sql-shell`：运行自定义SQL语句6、`--os-cmd`，`--os-shell`：运行任意操作系统命令7、`--file-read`：从数据库服务器中读取文件8、`--file-write --file-dest`：上传文件到数据库服务器中 前言： 今天来总结一下sqlmap注入神器的详细使用方法。
一、SQLMap安装 Sqlmap官网：http://sqlmap.org/，Sqlmap的安装需要Python环境，最新版可以运行在 Python 2.6, 2.7 和 3.x 版本的任何平台上。
下载完成后可以添加进环境变量，方便使用（不添加也可以用）
当出现这个画面时工具即可正常运行了。
二、SQLMap介绍 1、Sqlmap简介： Sqlmap是一个开源的渗透测试工具，可以用来自动化的检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。
目前支持的数据库有MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access等大多数据库。
2、Sqlmap支持的注入方式： Sqlmap全面支持六种SQL注入技术：
基于布尔类型的盲注：即可以根据返回页面判断条件真假的注入。
基于时间的盲注：即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行(即页面返回时间是否增加)来判断。
基于报错注入：即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。
联合查询注入：在可以使用Union的情况下的注入。
堆查询注入：可以同时执行多条语句时的注入。
带外注入：构造SQL语句，这些语句在呈现给数据库时会触发数据库系统创建与攻击者控制的外部服务器的连接。以这种方式，攻击者可以收集数据或可能控制数据库的行为。
3、Sqlmap输出级别： 使用 Sqlmap 对一个注入点进行测试时，可以使用 -v x 参数指定回显信息的复杂度，x范围为[0~6]，共有 7 个等级，默认为 1。
0：只显示python错误以及严重的信息。1：同时显示基本信息和警告信息。（默认）2：同时显示debug信息。3：同时显示注入的payload。4：同时显示HTTP请求。5：同时显示HTTP响应头。6：同时显示HTTP响应页面。 如果想看到 Sqlmap 发送的测试 payload 最好的等级就是3，例：
sqlmap.py -v 3 -u "http://www.xxx.com/a.php?id=x" 三、SQLMap使用： 1、判断是否存在注入： 假设目标注入点是 http://127.0.0.1/sqli-labs/Less-1/?id=1，判断其是否存在注入的命令如下：
sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 结果显示存在注入：
当注入点后面的参数大于等于两个时，需要加双引号，如下所示。
sqlmap.py -u "http://127.0.0.1/sqli-labs/Less-1/?id=1&amp;uid=2" 运行完判断是否存在注入的语句后，爆出一大段代码，这里有三处需要选择的地方：
第一处的意思为检测到数据库可能是MySQL，是否需要跳过检测其他数据库；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f30e5c0753b4f8ed4d70a043704d6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e83e5eb518a8c71a3a16fc7ffb845d7/" rel="bookmark">
			基于Autoencoder自编码器的数据特征提取和分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Autoencoder原理
二、Autoencoder的应用
降维
特征学习
异常检测
图像降噪
三、MATLAB程序
四、仿真结果
自编码器（Autoencoder）是一种深度学习算法，其主要目标是通过学习将输入数据编码为低维的表示，然后使用这个表示重新构造原始数据。这种算法中的关键思想是，好的编码应该能够通过这个编码和解码的过程保留尽可能多的原始数据信息。其基本结构如下：
基于自编码器的数据特征提取和分类主要利用了自编码器的学习能力和特征提取能力，下面将介绍其原理和数学公式。
一、Autoencoder原理 自编码器由两部分组成：编码器和解码器。编码器将输入数据压缩到一个低维的表示，解码器则从这个低维的表示中恢复出原始数据。自编码器的学习过程是通过最大化重构误差的最小值来实现的，即尽可能减小原始数据与重构数据之间的差异。
基于自编码器的特征提取主要是通过编码器将输入数据映射到低维空间，这个低维空间可以更好地表示数据的特征。然后，解码器利用这个特征表示进行数据重构，以保留更多的原始数据信息。分类任务则需要对编码器的输出进行分类，这可以通过训练一个额外的分类器来完成，例如softmax分类器。在这个情况下，自编码器可以视为特征提取器，用于从原始数据中提取有意义的特征，然后这些特征被用于训练分类器。
假设我们的输入数据为X，编码器函数为f，解码器函数为g，重构误差为重建_error，则自编码器的损失函数可以定义为：
error = E[||X - g(f(X))||_2^2]
其中E[||X - g(f(X))||_2^2]表示对所有输入数据进行上述计算的期望值。
为了优化上述损失函数，我们可以使用梯度下降法或者变分推断进行优化。其中，基于梯度下降法的自编码器可以被表示为：
f, g = argmin_f, g E[||X - g(f(X))||_2^2]
使用变分推断进行优化的自编码器可以被表示为：
f, g = argmin_f, g E[logP(X|f(X))]
其中P(X|f(X))表示给定编码后的表示f(X)重构出原始数据的概率。
在基于自编码器的分类任务中，我们通常会训练一个额外的分类器，例如softmax分类器，来对编码器的输出进行分类。这种情况下，我们的损失函数可以被定义为：
classification_error = E[C(f(X), Y)] + E[||X - g(f(X))||_2^2]
其中C(f(X), Y)表示基于编码表示f(X)和真实标签Y的分类错误率。这样我们就将自编码器的重构误差和分类错误率结合在了一起，可以通过梯度下降或者变分推断进行优化。
基于自编码器的数据特征提取和分类是一种非常有效的深度学习方法，它可以被广泛应用于各种任务中，例如数据降维、异常检测、数据可视化、语音识别等。同时，自编码器还可以和其他算法结合使用，例如卷积神经网络、循环神经网络等，以实现更复杂的功能。
二、Autoencoder的应用 自动编码器在各个领域都有广泛的应用，包括：
降维 自动编码器可以通过学习潜在空间中的紧凑而有效的表示来降低输入数据的维数。这对于可视化、数据压缩和加速其他机器学习算法很有帮助。
特征学习 自动编码器可以从输入数据中学习有意义的特征，这些特征可用于下游机器学习任务，如分类、聚类或回归。
异常检测 通过在普通数据实例上训练自动编码器，它可以学习以低错误重建这些实例。当呈现异常数据点时，自动编码器可能会有更高的重建误差，可用于识别异常值或异常值。
图像降噪 可以训练自动编码器从嘈杂的版本重建干净的输入数据。降噪自动编码器学习消除噪声并生成输入数据的干净版本。
三、MATLAB程序 ..................................................................... %在此处定义时期的数量 for epoch= 1:1:1500 epoch J_epoch=[];Total_Activation = zeros(HN,1);Activated_Outputs_Outputlayer = cell(4000,1); der_Activated_Outputs_Outputlayer = cell(4000,1); Activated_Outputs_Hiddenlayer = cell(4000,1); der_Activated_Outputs_Hiddenlayer = cell(4000,1); delta_Outputlayer = cell(4000,1); delta_Hiddenlayer = cell(4000,1); %4000个输入进入隐藏层 %所有输入的平均激活和误差的计算 for inp=1:1:4000 Hjk = train_set(inp,1:784)'; for i=1:1:HL+1 s=Weight_Matrices{i}*[1;Hjk];%此处[1列车组]表示输入数量，外部1表示偏差 Hjk = arrayfun(Yj,s); Activated_Outputs{i}=Hjk; der_Activated_Outputs{i} = (1-Hjk).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e83e5eb518a8c71a3a16fc7ffb845d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e0e543c88cd5da6fdcb6b37df7bc1c/" rel="bookmark">
			华为Mate60RS真机曝光：陶瓷外观？“Ultimate Design”字样现身
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为 Mate 60 RS 玄黑色真机已经曝光，博主 @路人路 通过网友的投稿今天下午发文称：“看着还是陶瓷的”，引起了广泛关注。
据悉，该机与 Mate 60 系列机型一样采用了两段式设计，但在外观上与现有机型有明显不同。华为 Mate 60 RS 的后壳使用直线条，棱角分明，形成了与其他Mate 60系列机型的区隔。此外，该机具备八边形的后置三摄模组，这也成为了备受关注的亮点之一。
尽管外观发生了变化，华为 Mate 60 RS的其他方面与前代产品 “华为 Mate 50 RS 保时捷设计”几乎保持一致，其主要的改变为后壳字样从“Porsche Design”更改为“Ultimate Design”。
另一方面，据博主 @看山的叔叔 透露，华为 Mate 60 RS的包装盒信息也已经公开，与华为 Mate 60 Pro + 区别不大。配置信息显示，该机型将提供16GB内存和1TB存储空间，支持卫星通话，并且采用与华为 Mate 60 Pro + 相同的型号 ALN-AL10，通过了3C认证，并在今年9月生产。
这些信息短期内引起了广泛的猜测和讨论。相信这样的配置不仅会满足用户对存储和通话质量的需求，同时也将使他们在使用过程中享受到更快和更流畅的体验。此外，在Mate系列中搭载这些性能强大的功能，意味着华为一直在追求更高的创新和顶尖的技术水平。
总之，华为 Mate 60 RS 的曝光引起了广泛关注。不久的将来，这款机型将进一步呈现给我们大家的是它出色的性能和华为一贯的创新和领先技术。我们期待着了解更多关于这款手机的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4f0a27e97020a98f51b2b256a32d57/" rel="bookmark">
			Spring Cloud版本选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud版本号由来 SpringCloud的版本号是根据英国伦敦地铁站的名字进行命名的，由地铁站名称字母A-Z依次类推表示发布迭代版本。 SpringCloud和SpringBoot版本对应关系 注意事项：
其实SpringBoot与SpringCloud需要版本对应，否则可能会造成很多意料之外的错误，比如eureka注册了结果找不到服务类啊，比如某些jar导入不进来啊，等等这些错误。
版本说明 名字描述SNAPSHOT快照版，可以稳定使用，且仍在继续改进版本。PRE预览版,内部测试版. 主要是给开发人员和测试人员测试和找BUG用的，不建议使用；RC发行候选版本，基本不再加入新的功能，主要修复bug。SR修正版或更新版GA正式发布的版本 从 Spring Cloud 2020.0.0-M1 开始，Spring Cloud 废除了这种英国伦敦地铁站的命名方式，而使用了全新的 "日历化" 版本命名方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320b0767c3b438627f2b57ed21b01351/" rel="bookmark">
			spring系列漏洞复现CVE-2022-22947、CVE-2022-22963、CVE-2022-22965、CVE-2022-22978
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Spring Cloud Gateway RCE (CVE-2022-22947)漏洞复现
漏洞原理
漏洞复现
修复建议
Spring Cloud Function SpEL表达式命令注入（CVE-2022-22963）漏洞复现
漏洞原理
漏洞复现
修复建议
Spring Framework远程代码执行（CVE-2022-22965）漏洞复现
漏洞原理
漏洞复现
修复建议
Spring-security 认证绕过（ CVE-2022-22978 ）漏洞复现
漏洞原理
漏洞复现
修复建议
Spring Cloud Gateway RCE (CVE-2022-22947)漏洞复现 漏洞原理 Spring Cloud Gateway是基于Spring Framework和Spring Boot构建的API网关，它旨在为微服务架构提供一种简单、有效、统一的API路由管理方式。Spring Cloud Gateway应用程序的Actuator端点，其在启用、公开和不安全的情况下容易受到代码注入的攻击。攻击者可通过该漏洞恶意创建允许在远程主机上执行任意远程执行的请求。
漏洞复现 启动环境
浏览器访问
使用burp抓包发送到repeater模块修改请求包
构造spel
POST /actuator/gateway/routes/test HTTP/1.1 Host: 192.168.0.154:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0 Connection: close Content-Type: application/json Content-Length: 331 { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320b0767c3b438627f2b57ed21b01351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085b4ae9daa63934d71ae1b6c4a17aff/" rel="bookmark">
			自己实现SpringBoot三方Starer依赖封装(自动装配自定义实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.对Spring Boot自动装配理解
自动装配其实是一种按照SpringBoot的约定配置规则实现三方依赖注入项目,通过配置文件+注解实现配置文件识别以及对应的Bean等IOC注入,供SpringBoot 使用.
具体自动装配原理可以参考下边博文学习
https://www.cnblogs.com/monkey-xuan/p/15911610.html
二.自己封装自定义Starter
被封装项目创建Springboot项目或者maven项目
创建自定义配置类
package com.example.springstarerredisautoconfig.redisson; import org.redisson.Redisson; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @ConditionalOnClass(Redisson.class) @EnableConfigurationProperties(RedissonProperties2.class) @Configuration public class RedissonAutoConfiguration { @Bean public RedissonClient redissonClient(RedissonProperties2 redissonProperties) { final Config config = new Config(); String prefix = "redis://"; if (redissonProperties.isSsl()) { prefix="rediss://"; } String address = prefix+redissonProperties.getHost()+":"+redissonProperties.getPort(); config.useSingleServer().setAddress(address); return Redisson.create(config); } } RedissonProperties2
package com.example.springstarerredisautoconfig.redisson; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/085b4ae9daa63934d71ae1b6c4a17aff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de4d2b8fd13362f82ee128e56d2b58e7/" rel="bookmark">
			(23)认识Linq:序列与集合,延迟与缓存,链式与查询式,性能提升技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考https://www.bilibili.com/video/BV1rx41157DS/?p=6&amp;spm_id_from=333.880.my_history.page.click&amp;vd_source=2a0404a7c8f40ef37a32eed32030aa18
难度：中级
一、Enumerables与IEnumerable 1、什么是Enumerables?
(1)Enumerables是一个用于处理集合数据的接口或者类型。
它是System.Collections命名空间下提供的一组功能强大的接口和类的集合。通过使用Enumerables，你可以遍历、过滤、转换和操作各种集合，比如列表（List）、数组（Array）以及其他实现了"IEnumerable"接口的类型。
Enumerables提供了一种方便的方法来处理集合数据，它包含了许多扩展方法（Extension Methods），使得对集合的操作变得更加简单和高效。你可以使用Linq查询表达式或者方法链（Method Chaining）来使用Enumerables，以实现各种常用的操作，如过滤、映射、排序等。总之，Enumerables在C#中是一个非常有用的工具，它简化了集合数据的处理和操作。
(2)Enumerables与Enumerable表达的意思是一样的。
它们都是用来表示可枚举序列的概念。
说Enumerable时，通常指的是Enumerable类及其提供的扩展方法。
而说Enumerables时，通常指的是一组可枚举序列的集合。
2、Enumerables与IEnumerable区别？
可以将 Enumerable 视为包含了丰富集合操作的工具箱，提供了许多可用于操作和处理集合的扩展方法。这些方法提供了丰富的功能，包括筛选、映射、排序、分组等等，使得对集合进行操作变得更加方便和灵活。
而IEnumerable 接口只是 Enumerable 工具箱中的一项功能，它定义了一个最基本的功能：允许对集合进行迭代。IEnumerable 接口提供了 GetEnumerator() 方法，该方法返回一个 IEnumerator 对象，用于遍历集合中的元素。在 C# 中，foreach 循环就是利用这个接口来迭代集合的。 所以，Enumerable 提供了 Enumerable.Range()、Enumerable.Where()、Enumerable.OrderBy() 等丰富的扩展方法，而 IEnumerable 接口只提供了最基本的迭代功能。
总结：IEnumerable 是用于表示一个可循环迭代的集合的基本接口;
而 Enumerables 则是提供了一整套功能丰富的工具方法，用于操作和处理实现了 IEnumerable 接口的集合。
private static void Main(string[] args) { List&lt;int&gt; list = new List&lt;int&gt;() { 1, 2, 3, 4, 5 }; IEnumerable&lt;int&gt; filter = Enumerable.Where&lt;int&gt;(list, x =&gt; x % 2 == 0);//a IEnumerable&lt;int&gt; map = Enumerable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de4d2b8fd13362f82ee128e56d2b58e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5339bd407b7ce5926f9ce0afdbe6fbb9/" rel="bookmark">
			zst_2001(B站软考)-计算机系统笔记简
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机基本硬件系统 组成:(运算器，控制器)-&gt;中央处理单元;存储器;输入设备;输出设备;
CPU的功能 控制器-(程序控制; 操作控制; 时间控制;)
运算器-数据处理;
运算器组成成分: 算术逻辑单元(ALU); 处理数据，算术运算，逻辑运算
累加寄存器(AC); 为ALU提供一个工作区;将进行运算的结果放在累加器中;
数据缓冲寄存器(DR); 作为CPU和内存，外部设备之间数据的中转站;
状态条件寄存器(PSW); 保存算术指令和逻辑指令运行和测试的结果建立的各种条件码内容，主要分为状态标志和控制标志;
控制器组成: 指令存储器(DR) 在CPU执行一条指令时,先把它从内存存储器取到缓冲寄存器,再送入IR暂存，指令译码器根据IR的内容产生操作;
程序计数器(PC) 又称为指令计数器，用于跟踪指令地址的寄存器
寄存信息和计数
地址寄存器(AR) AR保存当前CPU所访问的内存单元地址
指令译码器(ID) 指令包含操作码和地址码两部分,对操作码进行分析，识别指令规定的操作，向操作控制器发出具体控制信号，完成所需功能;
通用寄存器(透明) 计算机基本单位 示例单位内存换算: ​ 进制转换 进制运算最基本的各个进制数的表示: BODH-进制对应的单位 B-二进制;
O-八进制;
D-十进制;
H-16进制;
注:十进制小数-&gt;转换为2进制
乘2取整直到小数位为0;
示例:
0.25-&gt;二进制;
0.25X2=0.5-&gt;取整0;
0.5X2=1.0-&gt;取整1;
最后得二进制数0.01;
规则：
二进制-&gt;八进制-&gt;三位一体 注:三位二进制数表示一位8进制数
二进制-&gt;16进制-&gt;四位一体 注:四位二进制数表示一位16进制数
示例二进制转换八进制和16进制图: 示例八进制和16进制转二进制图: 数据表示 原码，反码，补码 机器字长为n时各种码制表示的带符号数的范围 浮点数: 寻址: 奇偶校验码 海明码 循环冗余校验码 RISC(精简指令集计算机)和CISC(复杂指令集计算机) 流水线执行公式: 流水线的作用 提升各设备的利用率
加速比；操作周期;吞吐率 存储器 存储器的类型
示例:
空间局部性和时间局部性 空间局部性:访问一个储存单元的相邻存储单元;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5339bd407b7ce5926f9ce0afdbe6fbb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971664d10745a50183a61172cbe9170f/" rel="bookmark">
			vue使用高德地图服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先使用npm方式引入高德
// npm引入高德 npm i @amap/amap-jsapi-loader 页面中引入高德地图插件
// 页面引入高德插件 import AMapLoader from '@amap/amap-jsapi-loader'; window._AMapSecurityConfig = { securityJsCode: '',//高德地图密钥 } 页面中使用高德地图
AMapLoader.load({ key: "高德地图申请的key", //此处填入我们注册账号后获取的Key version: "2.0", //指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: ['AMap.MarkerCluster'], //需要使用的的插件服务列表，如比例尺'AMap.Scale'等 }).then((AMap) =&gt; { // 创建卫星图层 var satellite = new AMap.TileLayer.Satellite(); this.satelliteMap = new AMap.Map("需要绑定的节点ID", { center: [114.223939, 22.699103], zoom: 13, layers: [ satellite ] }); }) 全局main.js文件中引入高德地图插件
// main.js全局引入高德插件 import AMapLoader from '@amap/amap-jsapi-loader'; Vue.prototype.AMapLoader = AMapLoader //页面调用 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971664d10745a50183a61172cbe9170f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11c609906f6def7401ce9c52396ac64/" rel="bookmark">
			Dubbo学习（四）——Dubbo的常用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 启动时检查概念代码示例 集群容错概念代码示例 负载均衡概念代码示例 直连提供者概念代码示例 只订阅概念代码示例 只注册概念代码示例 多协议机制概念代码示例 多注册中心概念代码示例 多版本概念代码示例 日志管理概念代码示例 总结 启动时检查 概念 启动时检查是Dubbo的一个常用场景，它可以在服务提供者启动时检查依赖的服务是否可用。如果依赖的服务不可用，服务提供者将会延迟启动，直到依赖的服务可用或者超时。这可以保证服务的稳定性和可靠性。
代码示例 配置示例：
&lt;dubbo:reference id="userService" interface="com.example.UserService" check="true"/&gt; 集群容错 概念 在分布式系统中，服务的可靠性和容错是非常重要的。Dubbo提供了多种集群容错策略，可以在服务调用失败时进行自动的容错处理。常用的集群容错策略包括：
Failover：失败自动切换，当调用失败时，自动切换到其他可用的服务提供者。Failfast：快速失败，只进行一次调用，失败则立即报错。Failsafe：失败安全，出现异常时，直接忽略。Failback：失败自动恢复，记录失败请求，定时重发。 代码示例 配置示例：
&lt;dubbo:reference id="userService" interface="com.example.UserService" cluster="failover"/&gt; 负载均衡 概念 负载均衡是分布式系统中常见的问题，Dubbo提供了多种负载均衡策略，可以根据不同的需求选择合适的负载均衡策略。常用的负载均衡策略包括：
Random：随机选择一个可用的服务提供者。RoundRobin：轮询选择一个可用的服务提供者。LeastActive：最少活跃数，选择活跃数最少的服务提供者。ConsistentHash：一致性Hash算法，根据请求的key选择服务提供者。 代码示例 配置示例：
&lt;dubbo:reference id="userService" interface="com.example.UserService" loadbalance="random"/&gt; 直连提供者 概念 Dubbo默认会通过注册中心来发现服务提供者，但有时候我们可能需要直接指定某个服务提供者来进行调用。Dubbo提供了直连提供者的功能，可以直接通过指定的地址来调用服务提供者。
代码示例 配置示例：
&lt;dubbo:reference id="userService" interface="com.example.UserService" url="dubbo://localhost:20880"/&gt; 只订阅 概念 Dubbo默认会订阅所有的服务提供者，但有时候我们可能只需要订阅某个特定的服务提供者。Dubbo提供了只订阅的功能，可以只订阅指定的服务提供者。
代码示例 配置示例：
&lt;dubbo:reference id="userService" interface="com.example.UserService" subscribe="false"/&gt; 只注册 概念 Dubbo提供了只注册的功能，可以选择只将服务提供者注册到注册中心，而不订阅其他服务。这在某些场景下非常有用，例如当我们只需要提供服务而不需要消费其他服务时，可以通过配置只注册来减少不必要的网络开销和资源消耗。
代码示例 配置示例：
&lt;dubbo:service interface="com.example.UserService" register="true" subscribe="false"/&gt; 多协议机制 概念 Dubbo支持多种协议，可以根据不同的需求选择合适的协议。常用的协议包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11c609906f6def7401ce9c52396ac64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd69258a937f7d7b3d52325bdab8147/" rel="bookmark">
			Exploit-DB 使用小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Exploit-DB （网址：https://www.exploit-db.com） 是一个漏洞库网站 ，存储了大量的漏洞利用程序，可以帮助安全研究者和渗透测试工程师更好的进行安全测试工作，目前是世界上公开收集漏洞最全的数据库，该仓库每天都会更新。
searchsploit 是一个用于搜索 Exploit-DB 漏洞数据的命令行工具（Kali默认已安装），可以离线搜索 Exploit 数据库，这对于有时候不能联网的渗透工作非常的有用。
更新数据库 searchsploit -u 查看帮助信息 searchsploit -h Usage: searchsploit [options] term1 [term2] ... [termN] ========== Examples ========== searchsploit afd windows local searchsploit -t oracle windows searchsploit -p 39446 searchsploit linux kernel 3.2 --exclude="(PoC)|/dos/" searchsploit linux reverse password ========= Options ========= -c, --case [Term] 执行区分大小写的搜索 (默认是不敏感)。 -e, --exact [Term] 对漏洞标题执行精确匹配(默认是和)[Implies "-t"]. -h, --help 显示这个帮助屏幕。 -j, --json [Term] 以JSON格式显示结果 -m, --mirror [EDB-ID] 将漏洞镜像复制到当前工作目录。 -o, --overflow [Term] 允许利用标题溢出它们的列。 -p, --path [EDB-ID] 显示攻击的完整路径(如果可能，还将路径复制到剪贴板)。 -t, --title [Term] 只搜索攻击标题(默认是标题和文件的路径)。 -u, --update 检查并安装任何的开发包更新(deb或git)。 -w, --www [Term] 显示url到Exploit-DB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd69258a937f7d7b3d52325bdab8147/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cfe5db3a9a7899be77336f460fff24e/" rel="bookmark">
			Vue3安装配置、开发环境搭建(组件安装卸载)（图文详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3安装配置、开发环境搭建(组件安装卸载)（图文详细） 本文目录：
一、vue的主要安装使用方式
二、node.js安装和配置
1、支持运行 Node.js的平台
2、Node.js 版本开发发布时间表（日期可能会有变化）
3、下载安装node.js
4、node.js环境配置
（1）、检查node 和npm版本信息
（2）、配置npm下载时的默认安装目录和缓存日志目录
（3）、npm配置镜像站
（4）、配置环境变量
三、npm 安装vue 和脚手架、webpack模板
(1)、下载安装vue.js
(2)、验证vue安装
(3)、安装 webpack 模块
(4)、安装vue-cli 3.x脚手架
(5)、安装vue-router V4
(6)、查看一下npm的全局情况
四、打开Vue 项目管理器
五、创建运行 vue 3 项目
六、使用TypeScript进行开发 Vue3 的代码
七、vue及组件的卸载
八、vue项目结构
九、vue学习资源
十、Vue 安装过程中遇到的问题记录
十一、常见的npm命令
一、vue的主要安装使用方式 Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。
Vue.js是一个MVVM(Model - View - ViewModel)的SPA框架。
Model：数据。View：视图。ViewModel：连接View与Model的纽带。 Vue.js的安装使用方式有几种，简单的只需要引入一个第三方的JS包即可。在&lt;head&gt;中引入Vue.js包。
本地搭建 Vue 单页应用，可使用npm安装方式，即本文主要内容。
使用全局构建版本# 使用了全局构建版本的 Vue，该版本的所有顶层 API 都以属性的形式暴露在了全局的 Vue 对象上。这里有一个使用全局构建版本的例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cfe5db3a9a7899be77336f460fff24e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/896343c4b8f78da37a507da16ee15685/" rel="bookmark">
			分布式定时任务调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程目标 1、了解任务调度的应用场景和 Quartz 的基本特性
2、掌握 Quartz Java 编程和 Spring 集成的使用
3、掌握 Quartz 动态调度和集群部署的实现
4、理解 Quartz 原理与线程模型
内容定位 适合没有用过 Quartz 或者只会 Quartz 基本配置的同学
说明：基于最新稳定版本 2.3.0
1 漫谈任务调度 1.1 什么时候需要任务调度？ 1.1.1 任务调度的背景 在业务系统中有很多这样的场景：
1、账单日或者还款日上午 10 点，给每个信用卡客户发送账单通知，还款通知。如何判断客户的账单日、还款日，完成通知的发送？
2、银行业务系统，夜间要完成跑批的一系列流程，清理数据，下载文件，解析文件， 对账清算、切换结算日期等等。如何触发一系列流程的执行？
3、金融机构跟人民银行二代支付系统对接，人民银行要求低于 5W 的金额（小额支付）半个小时打一次包发送，以缓解并发压力。所以，银行的跨行转账分成了多个流程： 录入、复核、发送。如何把半个小时以内的所有数据一次性发送？
类似于这种 1、基于准确的时刻或者固定的时间间隔触发的任务，或者 2、有批量数据需要处理，或者 3、要实现两个动作解耦的场景，我们都可以用任务调度来实现。
1.2 任务调度需求分析 任务调度的实现方式有很多，如果要实现我们的调度需求，我们对这个工具有什么样的基本要求呢？
1.2.1 基本需求 1）可以定义触发的规则，比如基于时刻、时间间隔、表达式。
2）可以定义需要执行的任务。比如执行一个脚本或者一段代码。任务和规则是分开的。
3）集中管理配置，持久配置。不用把规则写在代码里面，可以看到所有的任务配置，方便维护。重启之后任务可以再次调度——配置文件或者配置中心。
4）支持任务的串行执行，例如执行 A 任务后再执行 B 任务再执行 C 任务。
5）支持多个任务并发执行，互不干扰（例如 ScheduledThreadPoolExecutor）。
6）有自己的调度器，可以启动、中断、停止任务。
7）容易集成到 Spring。
1.3 任务调度工具对比 层次举例特点操作系统Linux crontab &lt;br&gt;Windows 计划任务只能执行简单脚本或者命令数据库MySQL、Oracle可以操作数据。不能执行 Java 代码工具Kettle可以操作数据，执行脚本。没有集中配置开发语言JDK Timer、ScheduledThreadPoolTimer：单线程&lt;br&gt;JDK1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/896343c4b8f78da37a507da16ee15685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525673da9c5ce1c0266b21f19c52ca53/" rel="bookmark">
			03Nginx的静态资源部署,反向代理,负载均衡,动静分离的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx具体应用 部署静态资源 Nginx相对于Tomcat处理静态资源的能力更加高效,所以在生产环境下一般都会将Nginx可以作为静态web服务器来部署静态资源
静态资源: 在服务端真实存在并且能够直接展示的一些html页面、css文件、js文件、图片、视频等资源文件将静态资源部署到Nginx非常简单,只需要将静态资源文件放到到Nginx安装目录下的html目录中就可以正常访问 http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { # 监听80端口 listen 80; # 服务器的IP地址(域名) server_name localhost; # 处理80端口的location块,用来匹配客户端请求的url,匹配到后去根目录找对应的文件 location / { # 指定静态资源的根目录,默认当前目录是配置文件所在的conf目录,html目录和conf目录同级 root html; # 指定默认访问的首页(可以指定多个,中间用空格隔开,以";"结尾),默认当前目录是我们指定的根目录 index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 正向/反向代理 正向代理: 为了从目标服务器取得内容, 客户端向代理服务器发送一个请求并指定目标服务器的地址,然后代理将请求转发给目标服务器并将获得的内容返回给客户端
正向代理是给客户端设置代理服务器,客户端知道代理服务器的存在, 通过代理服务器转发请求最终访问到目标服务器正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径即通过代理访问无法访问的资源 反向代理: 用户直接访问反向代理服务器就可以获得目标服务器的资源(用户不需要指定目标服务器的地址), 反向代理服务器负责将请求转发给目标服务器
反向代理服务器也是位于用户与目标服务器之间,但却是给服务端设置代理服务器(用户不知道它的存在),用户以为自己访问的就是目标服务器 正向代理和反向代理的区别
正向代理隐藏的是用户: 原始服务器接收的是代理服务器的请求,用户知道可以通过代理服务器访问无法访问的资源(帮助客户端访问目标服务器)反向代理隐藏的是服务器: 用户以为自己访问的是目标服务器,其实自己访问的资源是通过反向代理服务器转发的(帮助目标服务器统一处理请求) 负载均衡 随着业务流量越来越大并且业务逻辑也越来越复杂, 单台服务器的性能及单点故障问题就凸显出来了, 因此需要多台服务器组成应用集群进行性能的水平扩展
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/525673da9c5ce1c0266b21f19c52ca53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b227bb738ea8455a606bd5956d35a2c/" rel="bookmark">
			【java打包下载zip树形结构】打包的时候在zip里创建文件夹自定义路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、测试类 import lombok.Data; @Data public class ZipVo { //文件路径：开始和结束都要/斜杠，生成属性文件夹 private String pathName; //文件数据 private String data; private String type; //后缀suffix private String suffix; } 2、控制器 import com.ekkcole.utils.Func; import org.apache.logging.log4j.util.Base64Util; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import javax.servlet.http.HttpServletResponse; import java.io.*; import java.net.HttpURLConnection; import java.net.URL; import java.util.*; import java.util.stream.Collectors; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream; /** * 树形层级下载打包下载zip */ @RestController public class TestZip { /** * 树形层级下载打包下载zip * 参数自定义 */ @GetMapping("/generateFileGroupDownZip") public void generateFileGroupDownZip(HttpServletResponse response) { //TODO 设置测试数据 List&lt;ZipVo&gt; zipVoList = new ArrayList&lt;&gt;(); ZipVo bean = new ZipVo(); bean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b227bb738ea8455a606bd5956d35a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2563eced18782cab9b907e952c8573f/" rel="bookmark">
			题解 | #统计有未完成状态的试卷的未完成数和未完成率#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同程旅行一面
说项目。异步下单时会不会出现库存没了，但是下单信息放到了消息队列中。导致下单失败？说说分布式锁的思路？Redis实现分布式锁有哪些缺陷？说说Redission原
【24届】中国物流2024全球校招正式启动！
更多23/24届校园招聘信息请关注【校招日程】每日更新！关注小助手，更新不迷路！实习信息汇总：https://www.nowcoder.com/share/ju
3i第二次训练题解
第一题链接：https://ac.nowcoder.com/acm/problem/21993 来源：牛客网题目描述:输入三个数，反序输出这三个数。输入描述:输
今日更新提醒
看过了招聘信息，快来用牛客直投官网吧[打call]一键直投，给自己多一次面试机会[赞]移动端：https://mnowpick.nowcoder.com/m/m
【滴滴】招聘视觉算法日常实习生
【岗位职责 工作内容】： 1.负责道路场景的视觉感知相关工作，在指导下实现视觉感知(目标检测、图像分割、半监督等)等相关算法复现，着重调研BEV场景的感知算法并
宁德时代极其糟糕的简历流程
8月中旬投递了宁德时代机械设计工程师，和我一起投递的同学(非武汉地区)在8月底9月初都完成了面试邀请。而我只做了两份测评没收到面试通知，前段时间来学校宣讲，hr
题解 | #调整牛群的位置#
import java.util.*;public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，
家人们有没有明白的 人在青岛投的深圳的为
家人们有没有明白的 人在青岛投的深圳的为啥去北京面试啊 也没笔试 会不会就是走个流程啊就给我挂了 去不去啊 主要酒店挺贵呢
飞书一面，狠狠的拷打基础
周末笔试做完补面经
长安线下面
长安二面线下面是人事面吗 #长安汽车#
株洲608有收到offer的嘛
有收到邮件的同学交流一下
华为
华为发offer主要看哪一方面啊，有没有人知道啊，面试官说机考考了80多分（满分100），三场面试感觉面的还可以，问面试评价，回答的都比较官方（挺好，问的基本都
入池，开泡！
入池，开泡！
阶段总结
目前已经面了24场了，下周还有4场也都到了或者接近终面环节。从最早的一面结束就被挂，到现在全能进二面，开始关注面试官介绍自己部门的工作，面试官能不能找到我经历中
大疆嵌入式二面
这算不算从池子里被捞起来kpi面啊刷牛客看好多已经终面结束的
地狱笑话
小米给我发了明年的笔试太牛了
就业意向邮件具有法律效力吗？
如题，就业意向邮件点击接受之后，如果后面确定不去该公司的话，需要按照意向邮件写的那样赔偿吗？
#牛客在线求职答疑中心(35799)#完
#牛客在线求职答疑中心#完美世界笔试可以顺延吗
922下午
922下午美的二面问实习，问项目，没问八股，20分钟919美的一面类似于hr面问题记不太清了，没有技术问题
【滴滴】招聘视觉算法日常实习生
【岗位职责 工作内容】： 1.负责道路场景的视觉感知相关工作，在指导下实现视觉感知(目标检测、图像分割、半监督等)等相关算法复现，着重调研BEV场景的感知算法并
网安30所的笔试大概是什么内容啊
有牛友知道吗
海康二面面筋
2023.9.22，全程22min二面(疯狂拷打) #海康威视# 1.自我介绍2.介绍课题3.介绍一个发明专利4.为什么选择海康5.为什么来杭州6.为什么之前离
美团约面
之前面过一面，等一周后回到人才库，前几天重新一面，现在至今没有任何后续，也不挂，也不约面，眼看着就要快到5天的工作日了，没有任何hr的联系方式，发公众号和招聘邮
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2563eced18782cab9b907e952c8573f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e87d457b6858eb6a1323e7cdd68a4a1f/" rel="bookmark">
			关于结构体初始化使用memset初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数原型：_CODE_ACCESS void *memset(void *_mem, int _ch, size_t _n);
该值返回一个指向存储区 _mem 的指针。
头文件：#include &lt;string.h&gt;
复制字符 _ch（一个无符号字符）到参数_mem所指向的字符串的前 size_t _n个字符。
大白话来说就是，使用_ch来填充_mem这片空间 填充长度为：size_t_n
使用如下所示：
memset(ethernet_port_cfg, 0, sizeof(ethernet_port_cfg));
将ethernet_port_cfg空间填充0 长度为结构体长度。
其他的结构体初始化后期优化~~~~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1aa93597e8fd91d4aec00fb3de8bbf/" rel="bookmark">
			如何使用 Pyinstaller 编译打包 Python 项目生成 exe 可执行文件（2023 年最新详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyinstaller 概述 PyInstaller 是一个将 Python 程序转换为独立可执行文件的工具。它能够在 Windows、Linux、Mac OS X、AIX 和 Solaris 等系统上运行。相较于其他类似的工具 PyInstaller 主要优点
1. PyInstaller 与任何 Python 版本兼容，从 2.3 版本开始支持。 2. PyInstaller 通过透明压缩功能，使生成的可执行文件更小。 3. PyInstaller 是完全跨平台的，可以在各种操作系统上运行。 4. PyInstaller 利用操作系统的支持来加载动态库，从而确保了完全的兼容性。 通过使用 PyInstaller，你可以将 Python 程序转换为单个可执行文件，从而方便地在没有 Python 解释器的机器上运行。这样做可以简化程序的分发，避免用户安装 Python 解释器的麻烦。
PyInstaller 官网：https://www.pyinstaller.org
在这里，你可以找到最新版本的 PyInstaller 下载包，以及详细的文档和用例供开发者学习和使用。
下载安装 pyinstaller 方案一：通过 pip 快速安装（PyPI 清华源镜像仓库）
通过 pip 包管理工具进行快速安装
pip install pyinstaller -i https://pypi.tuna.tsinghua.edu.cn/simple/ 若本地已经安装了旧版的 pyinstaller 进行更新 pyinstaller 工具
pip install -U pyinstaller 方案二：通过 git clone 安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c1aa93597e8fd91d4aec00fb3de8bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee49a85560e6aede53c71adb737536aa/" rel="bookmark">
			Android 按键流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、驱动层流程 主要流程涉及以下文件
kernel/msm-4.19/drivers/input/keyboard/gpio_keys.c
kernel/msm-4.19/drivers/input/input.c
kernel/msm-4.19/drivers/input/evdev.c
kernel/msm-4.19/drivers/input/input-compat.c
有按键动作时，根据 dtsi 中配置 code 上报事件。在 gpio_keys.c 中进行处理，最终在 gpio_keys_gpio_report_event 函数中调用 input.c 上报事件。大概流程分为两步。
第一步：获取event事件保存到队列中
input.c：input_event -&gt; input_handle_event -&gt; input_pass_values -&gt; input_to_handler(此函数中调用 handler-&gt;events ,handler 定义在 evdev.c 中，events 对应函数 evdev_events)
evdev.c：evdev_events -&gt; evdev_pass_values -&gt; __pass_event （将event事件添加到缓存队列 client-&gt;buffer）
第二步：通过循环读取队列中event事件保存到用户内存
evdev.c：evdev_read -&gt; input_event_to_user
input-compat.c：input_event_to_user -&gt; copy_to_user
二、上层流程 主要流程涉及以下文件
frameworks/native/services/inputflinger/reader/EventHub.cpp
frameworks/native/services/inputflinger/reader/InputReader.cpp
frameworks/native/services/inputflinger/reader/InputDevice.cpp
frameworks/native/services/inputflinger/reader/mapper/KeyboardInputMapper.cpp
frameworks/native/services/inputflinger/dispatcher/InputDispatcher.cpp
frameworks/native/libs/input/KeyLayoutMap.cpp
frameworks/native/libs/input/Keyboard.cpp
上层获取按键事件流程大致如下：
InputReader.cpp：loopOnce -&gt; processEventsLocked -&gt; processEventsForDeviceLocked (调用 device-&gt;process)
InputDevice.cpp：process (调用 mapper.process)
KeyboardInputMapper.cpp：process -&gt; processKey（调用 getListener()-&gt;notifyKey）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee49a85560e6aede53c71adb737536aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66e99572d9713a723e98ed7d650cfd6/" rel="bookmark">
			Dubbo学习（三）——dubbo实现负载均衡、智能容错功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Dubbo实现负载均衡功能1. 介绍2. Dubbo负载均衡原理3. Dubbo负载均衡的配置和使用3.1 配置负载均衡策略3.2 编程方式使用负载均衡 4. 总结 Dubbo实现智能容错功能1. 背景介绍2. Dubbo智能容错原理3. Dubbo智能容错的配置和使用3.1 配置容错策略3.2 编程方式使用智能容错 4. 总结 Dubbo实现负载均衡功能 1. 介绍 Dubbo是一种高性能的分布式服务框架，它提供了一套完整的服务治理解决方案。其中，负载均衡是Dubbo框架的重要特性之一，它可以帮助我们实现服务调用的负载均衡，提高系统的性能和可靠性。
在本文中，我们将介绍Dubbo框架中负载均衡的概念和原理，并展示如何使用Dubbo实现负载均衡功能。
2. Dubbo负载均衡原理 Dubbo框架中的负载均衡是指在多个服务提供者之间进行请求分发，以实现请求的负载均衡。Dubbo提供了多种负载均衡策略，包括随机、轮询、最少活跃调用等。
Dubbo的负载均衡原理如下：
当服务消费者发起调用时，Dubbo框架会根据负载均衡策略从多个服务提供者中选择一个进行调用。Dubbo框架会维护每个服务提供者的调用次数和响应时间等信息，根据这些信息计算出每个服务提供者的权重。根据负载均衡策略和服务提供者的权重，Dubbo框架选择一个服务提供者进行调用。如果调用失败或超时，Dubbo框架会根据配置的重试策略进行重试。 3. Dubbo负载均衡的配置和使用 下面我们将介绍如何在Dubbo框架中配置和使用负载均衡功能。
3.1 配置负载均衡策略 在Dubbo的服务提供者和服务消费者的配置文件中，可以配置负载均衡策略。示例如下：
&lt;!-- 服务提供者配置 --&gt; &lt;dubbo:service interface="com.example.UserService" ref="userService"&gt; &lt;dubbo:method name="getUser" loadbalance="roundrobin" /&gt; &lt;/dubbo:service&gt; &lt;!-- 服务消费者配置 --&gt; &lt;dubbo:reference id="userService" interface="com.example.UserService"&gt; &lt;dubbo:method name="getUser" loadbalance="random" /&gt; &lt;/dubbo:reference&gt; 上述示例中，服务提供者配置了getUser方法的负载均衡策略为roundrobin，而服务消费者配置了getUser方法的负载均衡策略为random。
Dubbo支持的负载均衡策略包括：
random：随机选择一个服务提供者。roundrobin：轮询选择一个服务提供者。leastactive：最少活跃调用数选择一个服务提供者。consistenthash：一致性哈希选择一个服务提供者。 3.2 编程方式使用负载均衡 除了在配置文件中配置负载均衡策略，我们还可以通过编程方式使用Dubbo的负载均衡功能。
// 服务消费者代码示例 public class UserServiceConsumer { public static void main(String[] args) { ReferenceConfig&lt;UserService&gt; referenceConfig = new ReferenceConfig&lt;&gt;(); referenceConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e66e99572d9713a723e98ed7d650cfd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/549e729b4784e42787b6fe0f0c9d526e/" rel="bookmark">
			谷歌验证码(Recaptcha)(hcaptcha)(funcaptcha)对接教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 reCAPTCHA V2也被称为我不是机器人 reCAPTCHA是一种非常流行的验证码类型，看起来像这样：
点击复选框后它会让你选择标题上对应的目标：
谷歌验证码一般需要点击2次大图或者更多，当然也有一次性通过的，手动通过也是相当麻烦的，那么如何绕过谷歌验证码呢？
平台地址：国内 https://fastcaptcha.cn:2000/ 国外https://fastcaptcha.net/ 首先我们打开网站
点击免费试用填写GoogleSitekey 和网址地址点击解决
将平台返回的token提交到你的网站 如果token可用再自行注册账号使用平台解决你的Google Recaptcha
FastCaptcha 目前支持Hcaptcha RecaptchaV3(包括企业版且高分) 还有Recaptcha 价格也是相对便宜 通过速度也非常快 有需要的小伙伴赶快去试试吧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a021f4fbe398500061dfafde84178dbf/" rel="bookmark">
			大数据是什么？可以做什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字化时代，大数据已渗透到我们生活的方方面面。提到大数据，大家首先想到的就是前景好，薪资高，但是对于到底什么是大数据却还是一头雾水，今天就来给大家详细说说。
什么是大数据？ 如果从字面意思来看，大数据指的是巨量数据。那么可能有人会问，多大量级的数据才叫大数据？不同的机构或学者有不同的理解，难以有一个非常定量的定义，只能说，大数据的计量单位已经越过TB级别发展到PB、EB、ZB、YB甚至BB级别。
最早提出“大数据”这一概念的是全球知名咨询公司麦青锡，它是这样定义大数据的：一种规模大到在获取、存储、管理、分析方面大大超出了传统数据库软件工具能力范围的数据集合，具有海量的数据规模、快速的数据流转、多样的数据类型以及价值密度低四大特征。
研究机构Gartner是这样定义大数据的：“大数据”是需要新处理模式才能具有更强的决策力、洞察发现力和流转优化能力来适应海量、高增长率和多样化的信息资产。
若从技术角度来看，大数据的战略意义不在于掌握庞大的数据，而在于对这些含有意义的数据进行专业化处理，换言之，如果把大数据比作一种产业，那么这种产业盈利的关键在于提高对数据的“加工能力”，通过“加工”实现数据的“增值”。
大数据发展前景及特点 从近些年的校招情况来看，大数据开发的岗位数量是增量比较明显的，目前企业不仅需要研发型人才，同时也需要应用型人才，随着大数据开始全面落地应用，当前这一行业正在从平台开发过渡到应用开发，这是趋势的必然。
大数据行业在过去几年中快速发展，成为了信息技术行业中最重要的领域之一。大数据行业的发展前景趋势，概括起来将会呈现如下特点：
#1 持续快速增长
大数据行业将继续保持快速增长。根据市场研究公司IDC的报告，全球大数据和商业智能市场在2020年达到了1890亿美元，预计将以5年复合年增长率(CAGR)达到13.2%，到2025年市场规模将达到 2980 亿美元。
#2 云计算、AI和物联网的普及
云计算本身与大数据的关系十分紧密，云计算、人工智能(AI)和物联网(IoT)等技术的发展将为大数据行业带来更多的机会。这些技术可以提供更多的数据，更快的计算速度以及更高的精度，从而改善大数据分析工作的效率和质量，自身的技术边界也得到了拓展。
#3 数据隐私和安全的重要性增加
随着数据泄露和信息安全事件的频繁发生，数据隐私和安全变得越来越重要。大数据行业将在保护数据隐私和安全方面扮演更加重要的角色。这将推动行业在数据隐私和安全方面的投资和技术创新。
#4 数据分析的普及
数据分析已成为各行各业的必备技能，大量企业和组织需要专业的数据分析师来帮助他们处理和分析数据。大数据行业将为这些数据分析师提供更多的就业机会。
#5 产业融合加速大数据行业将与其他行业进行更多的融合
例如，医疗、金融、零售等各行业都将利用大数据技术来提高业务效率和用户体验。这将为大数据行业带来更多的发展机会。
综上所述，大数据行业具有持续快速增长的趋势，未来将会有更多的技术创新和产业融合，同时也需要关注数据隐私和安全的问题。
大数据好学吗？
大数据行业经历10年的发展，现在技术已经非常的成熟，涉及的行业也是越来越多，转化成学习也比较简单。
Python+大数据学习路线图详细介绍（均为免费视频教程哈）
第一阶段 大数据开发入门 学前导读：从传统关系型数据库入手，掌握数据迁移工具、BI数据可视化工具、SQL，对后续学习打下坚实基础。
1.大数据数据开发基础MySQL8.0从入门到精通
MySQL是整个IT基础课程，SQL贯穿整个IT人生，俗话说，SQL写的好，工作随便找。本课程从零到高阶全面讲解MySQL8.0，学习本课程之后可以具备基本开发所需的SQL水平。
2022最新MySQL知识精讲+mysql实战案例_零基础mysql数据库入门到高级全套教程
第二阶段 大数据核心基础 学前导读：学习Linux、Hadoop、Hive，掌握大数据基础技术。
2022版大数据Hadoop入门教程
Hadoop离线是大数据生态圈的核心与基石，是整个大数据开发的入门，是为后期的Spark、Flink打下坚实基础的课程。掌握课程三部分内容：Linux、Hadoop、Hive，就可以独立的基于数据仓库实现离线数据分析的可视化报表开发。
2022最新大数据Hadoop入门视频教程，最适合零基础自学的大数据Hadoop教程
第三阶段 千亿级数仓技术 学前导读：本阶段课程以真实项目为驱动，学习离线数仓技术。
数据离线数据仓库，企业级在线教育项目实战（Hive数仓项目完整流程）
本课程会、建立集团数据仓库，统一集团数据中心，把分散的业务数据集中存储和处理 ；目从需求调研、设计、版本控制、研发、测试到落地上线，涵盖了项目的完整工序 ；掘分析海量用户行为数据，定制多维数据集合，形成数据集市，供各个场景主题使用。
大数据项目实战教程_大数据企业级离线数据仓库，在线教育项目实战（Hive数仓项目完整流程）
第四阶段 PB内存计算 学前导读：Spark官方已经在自己首页中将Python作为第一语言，在3.2版本的更新中，高亮提示内置捆绑Pandas；课程完全顺应技术社区和招聘岗位需求的趋势，全网首家加入Python on Spark的内容。
1.python入门到精通（19天全）
python基础学习课程，从搭建环境。判断语句，再到基础的数据类型，之后对函数进行学习掌握，熟悉文件操作，初步构建面向对象的编程思想，最后以一个案例带领同学进入python的编程殿堂。
全套Python教程_Python基础入门视频教程，零基础小白自学Python必备教程
2.python编程进阶从零到搭建网站
学完本课程会掌握Python高级语法、多任务编程以及网络编程。
Python高级语法进阶教程_python多任务及网络编程，从零搭建网站全套教程
3.spark3.2从基础到精通
Spark是大数据体系的明星产品，是一款高性能的分布式内存迭代计算框架，可以处理海量规模的数据。本课程基于Python语言学习Spark3.2开发，课程的讲解注重理论联系实际，高效快捷，深入浅出，让初学者也能快速掌握。让有经验的工程师也能有所收获。
Spark全套视频教程，大数据spark3.2从基础到精通，全网首套基于Python语言的spark教程
4.大数据Hive+Spark离线数仓工业项目实战
通过大数据技术架构，解决工业物联网制造行业的数据存储和分析、可视化、个性化推荐问题。一站制造项目主要基于Hive数仓分层来存储各个业务指标数据，基于sparkSQL做数据分析。核心业务涉及运营商、呼叫中心、工单、油站、仓储物料。
全网首次披露大数据Spark离线数仓工业项目实战，Hive+Spark构建企业级大数据平台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcac135c557446803a6529487b6fd80/" rel="bookmark">
			2023上半年薪资报告出炉！人均月入过万？！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，大家都有听到经济回暖的消息吧？经过三年口罩大考之后，2023年上半年各行各业都迎来复苏，关于职场的话题讨论也不绝于耳。
现在就业环境如何？哪些行业更有前途？大家在求职时是选择一线城市还是回二、三线城市？……对于这一系列职场话题，近期猎聘发布的《2023上半年人才流动与薪酬趋势报告》中，列举了很多关于当前人才市场的趋势和薪酬情况的数据，或许对求职者和企业都有一定的参考价值。我们一起来看看报告内容。
热门城市、热门行业依旧为就业首选 选择一座喜欢或者发展好的城市，然后找一份体面的工作，是大多数职场人的愿望。选择去哪座城市发展，很大程度上又跟自己对工作的期望有关，比如想要薪资高一些，一线、新一线城市便成为大家的首选。
在猎聘发布的报告中，2023年上半年招聘平均月薪最高的城市为北京（18976元），其次是上海（18132元）、深圳（17784元），这三个城市也是上半年人才投递前三名。整体上看，招聘薪资较高的依旧是一线城市，但是像杭州、南京等新一线城市的招聘薪资也非常可观。
△ 来源猎聘，如侵删
报告中的数据显示，各大城市的就业薪资上涨非常明显：对比2023上半年与2018上半年六年间一线、新一线城市人才薪资涨幅，上海薪资涨幅最高，达29.6%，北京以27.48%的薪资涨幅位居第二。且从不同学历人才薪资情况来看，无论大专、本科、硕士、博士均是北京、上海、深圳的平均薪资最高。
报告数据还显示，虽然因为生活成本等原因，近三年来有曾“逃离”北上广深的职场人，但其中39.2%会选择重新投递一线城市。他们重新投递一线城市的平均间隔时间在20个月左右，而最能影响职场人就业/定居的因素是城市工资水平。
这些数据无疑都在证明一线、新一线城市的就业更具竞争力，也是职场人更青睐的热门城市。
△ 来源猎聘，如侵删
说完城市，我们再来看行业热度。当被调研职场人被问到求职时最希望进入哪些行业? 报告显示，IT、互联网、游戏以34.3%的占比位居第一；电子、通信、半导体以25.7%位居第二。
△ 来源猎聘，如侵删
毫无悬念，薪资高、发展前景好IT、互联网、游戏行业依旧是职场人的心头爱。但在职场中，高薪一般都意味着要付出更多精力、时间。对于大家比较关注的加班情况，报告中也有所体现：被调研职场人中，月薪在1-2万的人最经常加班，占比60.5%；其次是月薪8千-1万的，经常加班的占比为40.2%。月薪5千-8千与月薪5千以下的职场人经常加班的比例趋同，均在40%左右。月薪2W以上的人经常加班的比例最少，仅占19.0%。
从这组数据中，薪资越高，不代表加班更多，而月薪2w是一个分水岭。另外，为了搞钱，数据还显示近三成的职场人有摆摊、开店的想法，并且年龄越小，打算摆摊、开店的人越多，其中00后有这些打算的占比最高，到达62.5%，其次是95后占比40.7%，70后只占20.8%，占比最少。
看完猎聘《2023上半年人才流动与薪酬趋势报告》，你有什么想说的？欢迎评论区讨论。
经济回暖，为何大家还说就业难？ 经济复苏，薪资上涨，就业市场开始回暖，但是为何仍有很多人抱怨工作难找？可能正如智联招聘集团执行副总裁李强所说： 就业最大的问题不是市场没有工作机会，而是对工作要求不太一样，求职者都要找到一份好工作，而不是找工作。
就像猎聘调查结果所说，找工作时，城市、薪资、是否加班等都是大家找工作考虑的重点问题，随着进入社会的职场人越来越多，好的工作机会总显得凤毛麟角，并且好的工作往往意味着高要求。
拿热门岗位Java开发工程师来说，第三方平台统计结果全国招聘量在10万+，但是点进岗位要求，会发现企业一般都需要2-3年工作经验的中高级开发工程师。
△ 来源职友集，如侵删
据已毕业的黑马学长学姐介绍，现在好的工作机会往往意味着你得拥有：突出的专业技能、丰富的从业经验、漂亮的简历、出色的面试表现、超强的工作能力、解决实际问题能力……
而要集齐上述这些技能，不是一件易事。这也就造成了当下就业市场提供的岗位数量虽多，但能达到企业要求的人才数量却不够的情况，让很多人觉得工作难找。
知道问题所在，找到解决方法便可迎刃而解
好工作难找，不代表没有机会，机会总是留给有准备的人。
扎实的技术基本功+真实项目实战经验，就是好就业的关键！
技术的提升永无止步，碎片时间学习进行各种技术强化：
一、Java学习路线详细介绍 第一阶段： Java基础 学前导读：Java基础是入行Java、应对Java程序员面试必备的知识，好的开始等于成功的一半。打好Java基础才能真正成为Java开发的高手，学习Java企业级技术和项目也才能游刃有余。
本部分推荐两套精品Java基础入门课，可自由选择一套优秀视频学习：
1.Java入门经典教程【课程播放量300w+】
通过本视频的学习，让您从零开始，掌握 Java 开发的各种技术，再结合后续知识，最终达到企业对 Java 开发工程师的要求！
全套Java教程_Java基础入门视频教程，零基础小白自学Java必备教程
2.最新、最全、在最短时间教会最实用技术的Java基础视频【2021年新版】
讲解由浅到深、采用一线大厂真实需求驱动知识的学习，更清楚，更高效，更实用，没有废话！课程内置大量的案例实战，初学者可以学练合一，对Java语言形成完整体系，并能得到自己的心得，足以轻松应对薪酬30万+的Java基础面试。
Java入门基础视频教程（含Java项目和Java真题）
第二阶段： Java Web 学前导读：本阶段深入讲解JavaWeb核心技术，学完本阶段课程可以制作中小型网站和企业管理系统等。
1.JavaWeb
最全的JavaWeb阶段核心知识，包括MySQL数据库、JDBC、JavaWeb核心、前端技术、Tomcat、Linux、Ngnix。在系统学习核心技术点后，还能制作出旅游项目综合案例是入门Javaweb最合理、最省时的学习流程。
JavaWeb全套基础教程，java web从入门到项目实战（IDEA版javaweb）
第三阶段：Java开发框架 学前导读：本阶段为企业级服务端开发必备技能，可以优化之前web阶段学习内容，使开发网站和企业管理系统更加快捷，更加方便维护。
1.项目构建Maven
课程涵盖Maven技术从初级到高级各个层面的知识，各种开发技巧，帮你完成从开发界新人到成熟开发人员的华丽转职。
Maven全套教程，maven项目管理从基础到高级，Java项目开发必会管理工具maven
2.版本控制Git
从最基本的环境配置与安装到Git的基本操作，轻松应对Git在使用时遇到的常见问题。
Git全套教程，完整的git项目管理工具教程，一套精通git
3.SSM（Spring框架+SpringMVC+持久层框架Mybatis）
SSM是当今企业开发中必备基础框架，学习完该套课程，可以进行几乎所有功能性项目开发，例如购物网站、社交网站、办公系统等。
最全SSM框架教程|Spring+SpringMVC+MyBatis全套教程(spring+springmvc+mybatis)
4.Spring高级之注解驱动开发详解
通过简洁的注解配置，替代了早期Spring框架中大量的XML配置。本套课程就是由浅入深的通过Spring的注解驱动开发，来揭开SpringBoot封装的细节。并且，深入的分析了Spring的IoC、AOP以及事务管理的源码，同时加入了对Spring-mvc的源码分析，组成了Spring完整的全家桶源码讲解。
Spring注解开发教程，包含框架Spring+SpringMVC+SrpingTest+SpringData(事物）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dcac135c557446803a6529487b6fd80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b957cc7172470d0d81bec87e36fa9a8d/" rel="bookmark">
			VsCode配置C/C&#43;&#43;环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MinGW编译器的下载和配置
下载
配置环境变量
检查是否配置成功
VsCode配置C/C++
下载编写C/C++所需插件
编写配置文件
编写C++代码
MinGW编译器的下载和配置 下载 官方网站： MinGW-w64 - for 32 and 64 bit Windows - Browse /mingw-w64/mingw-w64-release at SourceForge.net
我们往下拉页面，找到这一栏
这里推荐下载最上面的x86_64-posix-sjlj,这边粗略的解释一下这几个的后缀分别是什么意思
x86_64是64位系统用的版本
i686是32位的版本
seh结尾的是纯64位编译
sjlj是32，64两种编译
posix通常用于跨平台，比win32兼容性要好一点
配置环境变量 下载目录建议放到自己IDE所在的盘符中，然后我们复制MinGW里面的bin目录
随后打开我的电脑，然后右键点击属性进入系统页面，然后点击高级系统设置
点击环境变量
在系统变量中找到Path一行，选中后点击编辑
我们点击新建，然后将我们刚才复制的bin目录粘贴进去即可
检查是否配置成功 我们打开cmd，在cmd中输入gcc -v 或g++ -v，出现以下图片中内容即为配置成功
VsCode配置C/C++ 下载编写C/C++所需插件 我们点进我们的VsCode，点击扩展，在扩展中先后找到下图中的插件，然后点击安装
编写配置文件 下载完成后重启VsCode
我们需要新建一个文件夹用来存放在VsCode中编写的代码（或项目），然后我们在项目文件夹内需要创建一个.vscode文件夹，并在.vscode文件夹内创建以下三个配置文件c_cpp_properties.json 和 launch.json 和 tasks.json
分别在这三个文件中写入以下内容
c_cpp_properties.json
{ "configurations": [ { "name": "Win32", "includePath": ["${workspaceFolder}/**"], "defines": ["_DEBUG", "UNICODE", "_UNICODE"], "windowsSdkVersion": "10.0.17763.0", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b957cc7172470d0d81bec87e36fa9a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3bd9a28da93e86f87afe7e47eeaecd4/" rel="bookmark">
			为什么在token在http请求头中的Authorization要加Bearer前缀？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么在token在http请求头中的Authorization要加Bearer前缀？ token认证方式一般是放在http的请求头中Authorization字段，那么有两种形式：
Authorization : Bearer eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJCRkwiLCJhdWQiOiJDaGluYU1vYmlsZSIsImV4cCI6MTY5NTM0MTUwNiwibmJmIjoxNjk1Mjk4MzA2fQ.PxgojHlpUEaNJMy8I5DXkTSOrhn3oawzWIs0YL7yNP4 Authorization : eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJCRkwiLCJhdWQiOiJDaGluYU1vYmlsZSIsImV4cCI6MTY5NTM0MTUwNiwibmJmIjoxNjk1Mjk4MzA2fQ.PxgojHlpUEaNJMy8I5DXkTSOrhn3oawzWIs0YL7yNP4 两种方式有什么区别呢？为什么外面使用的时候都会加前缀Bearer?
两种方式使用上没有太大区别，只是：
The Authorization: &lt;type&gt; &lt;credentials&gt; pattern was introduced by the W3C in HTTP 1.0, and has been reused in many places since. Many web servers support multiple methods of authorization. In those cases sending just the token isn’t sufficient.
可以认为Bearer是一种schema。
后端服务filter中获取token进行验证可以兼容两种方式：
private String getToken(String authorizationString) { if (authorizationString.startsWith("Bearer ")) { return requestString.substring(7); } return authorizationString; } 另外，使用token认证有一个隐患：
http协议是明文传输的，token完全暴露在网络环境中，其他人获得token就能冒充身份，所以使用时必须注意网络环境，或者请使用https/TLS。
认证方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3bd9a28da93e86f87afe7e47eeaecd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c2a7e27506a29a0eec0251b3a67bf3f/" rel="bookmark">
			vue-cli-service build 不同环境的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🤜 背景
🤜 vue-cli-service介绍
🤜 环境变量和模式
🤜 配置不同模式
🤜index.html使用环境变量
🤜 验证
🤜 参考资料
🤜 背景 在项目部署时，我们需要在测试环境和生产环境使用不同的变量。vue-cli提供了vue-cli-service build打包命令，然而vue-cli-service build默认的环境变量值则为production。那我们通过npm run build打包构建，想要实现不同环境使用不同变量，暂时不能实现。
🤜 vue-cli-service介绍 官方介绍：vue-cli-service
vue-cli生成项目时，在package.json中会设置：
"scripts": { "serve": "vue-cli-service serve", "build": "vue-cli-service build" } vue-cli-service serve 命令会启动一个开发服务器，默认指定的环境模式为development。
vue-cli-service build 会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的vendor chunk splitting。
🤜 环境变量和模式 在项目的根目录下我们可以创建不同模式的文件：
.env # 在所有的环境中被载入 .env.local # 在所有的环境中被载入，但会被 git 忽略 .env.[mode] # 只在指定的模式中被载入 .env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 一般来说，我们会存在本地环境、测试环境、线上环境，那我们就需要创建三个模式文件。
.env.development开发环境模式 // 环境变量 NODE_ENV=development // 以 VUE_APP_ 开头的变量会被 webpack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c2a7e27506a29a0eec0251b3a67bf3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd4e66efefe2893be022753a71bb0089/" rel="bookmark">
			Vuex —— 状态管理 | Module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面讲到了关于Vuex数据状态管理的内容，讲了Vuex的五大核心属性，在这五大核心属性中就 state、mutation 和 actions 在前面介绍 Vuex 状态管理和讲 Vuex 中的同步和异步操作已经比较熟悉了，getter 是基于state 的计算属性，vue 中 computed从data中派生出的计算属性， vuex中 getter是从state中派生出的属性，对于getter的使用还是比较简单的，那么本篇主要来讲关于这最后一个核心属性 —— Module .
创建项目之后在 /store/index.js 文件后，将之前编写获取swiperList的操作放进入之后：
import Vue from 'vue' import Vuex from 'vuex' import { reqSwiperList } from '@/api' Vue.use(Vuex) export default new Vuex.Store({ state: { swiperList: [] // swiperList-轮播列表 }, getters: { }, actions: { async getSwiperList (store) { const result = await reqSwiperList() console.log(result) if (result.meta.status === 200) { const data = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd4e66efefe2893be022753a71bb0089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b98f9f75d4070fbbad9494d266a5c94/" rel="bookmark">
			【ubuntu20.04配置PX4仿真】ros&#43;PX4固件&#43;gazebo&#43;mavros
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装PX4 下载源码
git clone https://github.com/PX4/PX4-Autopilot.git --recursive 进入PX4-Autopilot文件夹，继续下载未下载的组件
cd PX4-Autopilot/ git submodule update --init --recursive 执行Ubuntun.sh脚本
bash ./PX4-Autopilot/Tools/setup/ubuntu.sh 出现python部分包的版本问题
python3 -m pip install --upgrade pip python3 -m pip install --upgrade Pillow 再执行
bash ./PX4-Autopilot/Tools/setup/ubuntu.sh --fix-missing reboot系统
测试进入PX4-Autopilot文件夹内
make px4_sitl_default gazebo 添加到环境变量
source ~/PX4-Autopilot/Tools/simulation/gazebo-classic/setup_gazebo.bash ~/PX4-Autopilot ~/PX4-Autopilot/build/px4_sitl_default export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/PX4-Autopilot export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/PX4-Autopilot/Tools/simulation/gazebo-classic/sitl_gazebo-classic 安装MAVROS sudo apt-get install ros-noetic-mavros ros-noetic-mavros-extras mavlink
wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh chmod +x install_geographiclib_datasets.sh ./install_geographiclib_datasets.sh 启动PX4和MAVROS之间的连接 roslaunch mavros px4.launch fcu_url:="udp://:14540@127.0.0.1:14557"#gazebo方针的端口号 出现下面，表示成功启动
ROS程序测试 创建工程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b98f9f75d4070fbbad9494d266a5c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d4510c014a08d29004aaf5285e0a76/" rel="bookmark">
			进度条(el-progress)控制快慢(带遮罩的进度条)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!--通过触发进度条的按钮或者其他方式来控制isProgress--&gt; &lt;div v-if="isProgress" class="bacc"&gt; &lt;el-progress v-if="isProgress" :text-inside="true" :stroke-width="15" :percentage="percentage" :color="colors" &gt;&lt;/el-progress&gt; &lt;!--这个div是进度条下面蹦跶的三个圆,不想要就删掉--&gt; &lt;div class="wrapper"&gt; &lt;div class="circle"&gt;&lt;/div&gt; &lt;div class="circle"&gt;&lt;/div&gt; &lt;div class="circle"&gt;&lt;/div&gt; &lt;div class="shadow"&gt;&lt;/div&gt; &lt;div class="shadow"&gt;&lt;/div&gt; &lt;div class="shadow"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; // 以下样式是定义的进度条占满全屏,而且会有种带遮罩的效果,如果需求不同请自己摸索一下 .bacc { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 999; background: rgba(0, 0, 0, 0.6); } .bacc .el-progress { position: absolute; width: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center; } // 以下是蹦跶的三个小球的样式 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91d4510c014a08d29004aaf5285e0a76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d665488d9a327a1a74229dd09f71ed5/" rel="bookmark">
			nvm下载安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 nvm 官网地址：https://nvm.uihtm.com
一、nvm 下载 进入 nvm github 地址，下载最新版本：https://github.com/coreybutler/nvm-windows/releases
点击选择当前最新版本。 滑动到底部，点击 nvm-setup.exe 下载安装文件。 接受，下一步。
选择 nvm 安装目录，下一步。
选择 nodejs 安装目录，下一步。
点击安装。
进入 cmd，输入 nvm 指令查看版本。安装成功则如下显示。
nvm arch：显示 node 是运行在32位还是64位。
nvm install 18.17.0：安装 node 18.17.0， version是特定版本也可以是最新稳定版本 latest。可选参数 arch 指定安装32位还是64位版本，默认是系统位数。可以添加 --insecure 绕过远程服务器的 SSL。install 可简化为 i。
nvm list [available] ：显示已安装的列表。可选参数 available，显示可安装的所有版本。list 可简化为 ls。
nvm on ：开启 node.js 版本管理。
nvm off ：关闭 node.js 版本管理。
nvm proxy [url] ：设置下载代理。不加可选参数url，显示当前代理。将 url 设置为 none 则移除代理。
nvm node_mirror [url] ：设置 node 镜像。默认是 https://nodejs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d665488d9a327a1a74229dd09f71ed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647040c50fb025adb7d640098d9861b9/" rel="bookmark">
			企业微信-通用开发参数回调设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司业务需要开发企业微信，注册三方服务商审核通过后，
开始配置开发信息。本篇中记录在调试url验证中遇到错误及解决方式。
目录
准备工作
下载php加解密库
下载文件说明
设置白名单
设置路径
参数说明
设置ip
回调处理
回调类型：
1、Get 类型
2、Post 类型
Get 回调实现
设置路由
控制器
业务层处理
配置开发信息
遇到问题
发现问题
解决方案
准备工作 下载php加解密库 在回调的实现逻辑中需要进行加解密计算，企业微信已经提供了 C++ Python PHP Java Go C# Node.js 等语言版本的加解密库，并且均提供了解密、加密、验证URL三个接口，开发者可以根据开发需要 下载加解密库。
下载文件
下载文件说明 WXBizMsgCrypt.php文件提供了WXBizMsgCrypt类的实现，是用户接入企业微信的接口类。Sample.php提供了示例以供开发者参考。errorCode.php, pkcs7Encoder.php, sha1.php, xmlparse.php文件是实现这个类的辅助类，开发者无须关心其具体实现。
WXBizMsgCrypt类封装了VerifyURL, DecryptMsg, EncryptMsg三个接口，分别用于开发者验证接收消息。的url、接收消息的解密以及开发者回复消息的加密过程。使用方法可以参考Sample.php文件。
设置白名单 设置路径 在开发者中心-&gt;工具-&gt;开发配置-&gt;IP白名单-&gt;点击编辑按钮，
添加白名单IP列表
参数说明 参数内容
说明
白名单IP列表
服务商调用企业微信API时的合法IP列表，只有白名单内的IP才能正常调用企业微信API，修改后立即生效。支持“222.209.201.*” 这样用通配符表示IP段；多个IP以英文分号;分隔
设置ip 我设置的是自己本机ip,并把最后一位设置为*，防止ip变动。
回调处理 加解密库加到项目中，最好外网可以访问到，否则估计要实现内网穿透。
回调类型： 第三方应用的回调配置有数据回调和指令回调两种。
数据回调，用于接收托管企业微信应用的用户消息、进入应用事件、通讯录变更事件。
指令回调，用于接收应用授权变更事件（应用添加、删除、修改）以及ticket参数，ticket说明详API接口说明。
对于数据回调和指令回调的两个 URL ，在服务端的实现时，都必须同时支持 HttpGet 以及 HttpPost两种能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/647040c50fb025adb7d640098d9861b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd82a62919e21b48f743b612684e830c/" rel="bookmark">
			8月最新修正版风车IM即时聊天通讯源码&#43;搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8月最新修正版风车IM即时聊天通讯源码+搭建教程。风车 IM没啥好说的很多人在找,IM的天花板了,知道的在找的都知道它的价值,开版好像就要29999,后端加密已解,可自己再加密,可反编译出后端项目源码,已增加启动后端需要google auth双重验证,pc端 web端 wap端 android端 ios端 都有
风车IM 是一款独立服务器部署的即时通讯解决方案，可以帮助你快速拥有一套自己的移动社交、企业办公、多功能业务产品。独立部署！加密通道！牢牢掌握通讯信息！
1234F云盘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3198cf161dd3601fd6cb0f65adfe249/" rel="bookmark">
			IIS部署OCIEnvCreate failed with return code -1 but error message text was not available.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境Windows Server2008 R2 SP1 IIS7.5 看网上的解决方案要把iis的应用程序池，启用32位应用程序改为true
我正好相反，要改为false，大家可以两种都试试看有没有效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e0009e15bae53bd7b6fe6262900f01/" rel="bookmark">
			Jetpack Compose基础组件之 — Text
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Text的源码参数预览 @Composable fun Text( text: String, modifier: Modifier = Modifier, color: Color = Color.Unspecified, fontSize: TextUnit = TextUnit.Unspecified, fontStyle: FontStyle? = null, fontWeight: FontWeight? = null, fontFamily: FontFamily? = null, letterSpacing: TextUnit = TextUnit.Unspecified, textDecoration: TextDecoration? = null, textAlign: TextAlign? = null, lineHeight: TextUnit = TextUnit.Unspecified, overflow: TextOverflow = TextOverflow.Clip, softWrap: Boolean = true, maxLines: Int = Int.MAX_VALUE, onTextLayout: (TextLayoutResult) -&gt; Unit = {}, style: TextStyle = LocalTextStyle.current ) Text 是 Compose 中最基本的布局组件，它可以显示文字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e0009e15bae53bd7b6fe6262900f01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1569498a3899f141cc43e9293fe3da24/" rel="bookmark">
			教你用Python写一个京东自动下单抢购脚本（Python实现京东自动抢购）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多朋友都有网购抢购限量商品的经历,有时候蹲点抢怎么也抢不到,今天小编带你们学习怎么用Python写一个京东自动下单抢购脚本,以后再也不用拼手速拼网速啦,快来一起看看吧
1 问题背景 经过无数次抢购失败后，发现商家会不定时的放出少量货源，目测每次会有几台。如果我们编写一个脚本程序24小时不间断监听商品库存，一旦查询到货源便开始尝试自动下单，这样就可以极大提高我们的成功概率。
2 设计思路 京东对于商品的抢购主要分为两种：
预约抢购：到点开放购买，和普通商品下单流程一致；秒杀商品：单独的抢购接口和下单流程。
当然本次针对的预约抢购类或无货订购类，即整体下单流程和购买普通商品时一样：
登录账号 → 进入购物车 → 选择抢购商品 → 点击去结算 → 点击提交订单 → 选择付款方式并付款。
3 具体实现 由于笔者本人没有一个可以抓包的客户端，决定采用京东 WEB 端接口实现我们的脚本程序。
于是经过对京东网页下单流程的分析，将我们的脚本程序分为四个模块：账号登录模块、库存监听模块、购物车管理模块、订单管理模块。
3.1 账号登录 由于使用账号密码时有验证码限制，此处采用扫码登录方式绕过。
如对扫码登录不熟悉或感兴趣的同学可以查看周周之前的博文 扫码登录原理和实现。
本次只要针对京东登录页进行抓包分析，找到几个有用接口：
获取登录二维码
def getQRcode(self): url = 'https://qr.m.jd.com/show' payload = { 'appid': 133, 'size': 147, 't': str(int(time.time() * 1000)), } headers = { 'User-Agent': self.userAgent, 'Referer': 'https://passport.jd.com/new/login.aspx', } resp = self.sess.get(url=url, headers=headers, params=payload) if not self.respStatus(resp): return None return resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1569498a3899f141cc43e9293fe3da24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8ceb64810bc9c195a36777687536c3/" rel="bookmark">
			Python 爬虫实战之爬淘宝商品并做数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 是这样的，之前接了一个金主的单子，他想在淘宝开个小鱼零食的网店，想对目前这个市场上的商品做一些分析，本来手动去做统计和分析也是可以的，这些信息都是对外展示的，只是手动比较麻烦，所以想托我去帮个忙。
一、 项目要求： 具体的要求如下：
1.在淘宝搜索“小鱼零食”，想知道前10页搜索结果的所有商品的销量和金额，按照他划定好的价格区间来统计数量，给我划分了如下的一张价格区间表：
2.这10页搜索结果中，商家都是分布在全国的哪些位置？
3.这10页的商品下面，用户评论最多的是什么？
4.从这些搜索结果中，找出销量最多的10家店铺名字和店铺链接。
从这些要求来看，其实这些需求也不难实现，我们先来看一下项目的效果。
二、效果预览 获取到数据之后做了下分析，最终做成了柱状图，鼠标移动可以看出具体的商品数量。
在10~30元之间的商品最多，越往后越少，看来大多数的产品都是定位为低端市场。
然后我们再来看一下全国商家的分布情况：
可以看出，商家分布大多都是在沿海和长江中下游附近，其中以沿海地区最为密集。
然后再来看一下用户都在商品下面评论了一些什么：
字最大的就表示出现次数最多，口感味道、包装品质、商品分量和保质期是用户评价最多的几个方面，那么在产品包装的时候可以从这几个方面去做针对性阐述，解决大多数人比较关心的问题。
最后就是销量前10的店铺和链接了。
在拿到数据并做了分析之后，我也在想，如果这个东西是我来做的话，我能不能看出来什么东西？或许可以从价格上找到切入点，或许可以从产品地理位置打个差异化，又或许可以以用户为中心，由外而内地做营销。
越往深想，越觉得有门道，算了，对于小鱼零食这一块我是外行，不多想了。
三、爬虫源码 由于源码分了几个源文件，还是比较长的，所以这里就不跟大家一一讲解了，懂爬虫的人看几遍就看懂了，不懂爬虫的说再多也是云里雾里，等以后学会了爬虫再来看就懂了。
测试淘宝爬虫数据 apikey secret
import csvimport osimport timeimport wordcloudfrom selenium import webdriverfrom selenium.webdriver.common.by import By def tongji(): prices = [] with open('前十页销量和金额.csv', 'r', encoding='utf-8', newline='') as f: fieldnames = ['价格', '销量', '店铺位置'] reader = csv.DictReader(f, fieldnames=fieldnames) for index, i in enumerate(reader): if index != 0: price = float(i['价格'].replace('¥', '')) prices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e8ceb64810bc9c195a36777687536c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d76923d6c26e8e1a2933d383c98d1c0e/" rel="bookmark">
			使用锐捷RG-EG210G-E路由器实现两个IP地址冲突的局域网互通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景：
之前写过一篇博文使用路由器实现三个不同网段局域网内的计算机相互访问，链接如下
https://blog.csdn.net/agang1986/article/details/131862160
当前的需求又发生了变更，有两个独立的局域网，内部的计算机个数和配置的IP地址完全相同，现在需要两个局域网内的计算机可以通信。我们知道软件交互需要指定对端的IP地址+端口号，如果两个互联的局域网里的计算机IP地址冲突，咋知道发送给谁的呢？方案之一是端口映射。
大体思路：
由于两个局域网中的计算机IP地址冲突，假设A局域网中地址为10.10.1.1的计算机发送报文给B局域网中地址为10.10.1.1的计算机，此时程序不能直接发送给10.10.1.1，报文会被它自己接收到。好在当前大多少路由器都支持端口映射功能。我们只要把报文发送到B局域网所在的路由器WAN口，然后通过对此WAN口做端口映射再把报文转发到B局域网下的10.10.1.1 IP的计算机即可。
三点共识：
1、路由器的WAN口主要用于连接外部网络，一般路由器上有1到2个；LAN口主要用于内部局域网，一般路由器有4到5个。
2、一台路由器的LAN口和WAN口的IP地址不能同网段，否则路由器会报冲突。
3、一台路由器的LAN口数据可以直接传输到WAN口，类似于我们在局域网内上网；但WAN口数据不能直接传输到LAN口，需要使用端口映射做转换，也就是常听到的内网穿透。
设置方法：
1、首先准备一根网线连接A路由器的LAN5口和B路由器的WAN0口
2、设置A路由器的LAN5口的IP地址为10.10.200.254
3、设置B路由器的WAN0口IP地址为10.10.200.2 如下图所示：
4、再设置B路由器的端口映射，从WAN口+2001端口，映射到内网的10.10.1.1+2001端口
5、A路由器所在局域网的10.10.1.1计算机通过网线连接到A路由器的LAN3口，并设置IP地址为10.10.1.254
6、设置A路由器所在局域网的10.10.1.1计算机的IP地址为10.10.1.1，默认路由为10.10.1.254
测试方法：
在A路由器所在局域网的10.10.1.1计算机执行：
telnet 10.10.200.2 2001 然后在B路由器所在局域网的10.10.1.1计算机上抓包，确认是否收到telnet报文。
扩展：
同理，如果需要从B路由器所在的局域网反向发送报文到A路由器所在局域网，也需要反向做下配置即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2172876ae2be21e8f6175a1368193db/" rel="bookmark">
			c&#43;&#43; nlohmann::json 中文支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++ nlohmann::json 是当前排名第一人库，但是在解析中文时会有问题
std::string to_utf8(std::wstring&amp; wide_string) { static std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; utf8_conv; return utf8_conv.to_bytes(wide_string); } void test_nlohmann() { using namespace nlohmann; nlohmann::json j; // 测试中文和英文提前解析 std::string js1 = R"({"key": "中文"})"; std::string js2 = R"(Not a json string)"; std::wstring js3 = LR"({"name":"中文"})"; std::wstring js4 = LR"("中文"})"; bool jsonStringIsValid = json::accept(js1); bool notJsonStringIsValid = json::accept(js2); jsonStringIsValid = json::accept(js3); notJsonStringIsValid = json::accept(js4); nlohmann::json jt; jt["age"] = 1; jt["name"] = "张三"; auto jt_out = jt.dump(); auto dd = utf8_to_ascii(jt["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2172876ae2be21e8f6175a1368193db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952573168cf27bd5a993a92e0460a167/" rel="bookmark">
			巨人网络游戏策划校经一面面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享下 巨人网络 的面经，在 SSP面试笔记 网站看了很多面经，感谢前辈的分享：
1.简单做一下自我介绍
2.平时比较喜欢玩什么游戏？比较偏向哪个类型的游戏？
3.如果让你自己做一款游戏，你会想要做什么类型的
4.以明日方舟为例，如果你来设计一个明日方舟里面的角色/人物，你会怎样去设计？
5.刚才你说喜欢玩黑暗之魂3，对于他的地图你有什么看法？
6.你对中国游戏市场有了解吗？说一下你的想法。
7.反问
作者：努力学习的小菜鸡
内容来源：SSP面试笔记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b3279948dcca8fa34c976bffff9ff9/" rel="bookmark">
			idea 创建springboot报错：request failed with status code 404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 idea 创建springboot报错：request failed with status code 404 报错提示如图 解决方案 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31876d4729176783f203527d7fdeff07/" rel="bookmark">
			python经典百题之最大公约数与最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：输入两个正整数m和n，求其最大公约数和最小公倍数。 方法1: 辗转相除法（欧几里德算法）求最大公约数 def gcd_euclidean(m, n): while n: m, n = n, m % n return m m = 36 n = 48 gcd_result = gcd_euclidean(m, n) print("GCD:", gcd_result) # 计算最小公倍数公式: LCM = m * n / GCD lcm_result = (m * n) // gcd_result print("LCM:", lcm_result) 思路：
使用辗转相除法（欧几里德算法），不断地用较小数去除较大数，直到余数为0。最终的除数就是最大公约数。 优点：
算法简单、高效，适用于大整数。 缺点：
除法运算可能会引入浮点数运算误差，需要注意。 方法2: 更相减损术求最大公约数 def gcd_subtraction(m, n): if m == n: return m elif m &gt; n: return gcd_subtraction(m - n, n) else: return gcd_subtraction(m, n - m) m = 36 n = 48 gcd_result = gcd_subtraction(m, n) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31876d4729176783f203527d7fdeff07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5fbcbb048d9b45b931068ec419a008/" rel="bookmark">
			Unity游戏开发客户端面经，六万字面经知识点，一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前这是记录一些被常问的面经，面向初级，总结了大约六万字的常问知识点，有各种大佬的链接可以深入的了解。希望可以帮助正在准备八股的同学们。
C#：Unity游戏开发客户端面经——C#（初级）_正在奋斗中的小志的博客-CSDN博客_c# unity
数据结构：Unity游戏开发客户端面经——数据结构（初级）_正在奋斗中的小志的博客-CSDN博客
lua：Unity游戏开发客户端面经——lua（初级）_正在奋斗中的小志的博客-CSDN博客 算法：Unity游戏开发客户端面经——算法（初级）_正在奋斗中的小志的博客-CSDN博客_拉绳算法
设计模式：Unity游戏开发客户端面经——设计模式（初级）_正在奋斗中的小志的博客-CSDN博客
Unity：Unity游戏开发客户端面经——Unity（初级）_正在奋斗中的小志的博客-CSDN博客 性能优化：Unity游戏开发客户端面经——性能优化（初级）_正在奋斗中的小志的博客-CSDN博客
热更新：Unity游戏开发客户端面经——热更新（初级）_正在奋斗中的小志的博客-CSDN博客
网络 ：Unity游戏开发客户端面经——网络（初级）_正在奋斗中的小志的博客-CSDN博客
数学：Unity游戏开发客户端面经——数学（初级）_正在奋斗中的小志的博客-CSDN博客
操作系统：Unity游戏开发客户端面经——操作系统（初级）_正在奋斗中的小志的博客-CSDN博客
希望此篇文章可以帮助到更多的同学，此外对现在面临校招的大三大四的同学，以及热爱游戏或者即将面临找工作的朋友，可以点击下方链接，来解决游戏职业道路的种种困惑，并且还可以学习理论知识的同时，拓宽游戏制作的实践技能~
游戏行业大揭秘https://scrm.vipskill.com/CMS/prod/5726/53/home.html?mantisSiteId=460&amp;track_id=__TRACKID__
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dfdd51ba3ecace65758a036f24ec1a2/" rel="bookmark">
			安卓系列机型 框架LSP 安装步骤 支持多机型 LSP框架通用安装步骤【二】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​安卓玩机教程---全机型安卓4----安卓12 框架xp edx lsp安装方法【一】
低版本可以参考上个博文了解相关安装方法。
LSP框架优点 简单来说装lsp框架的优点在于可以安装各种模块。包括 但不限于系统优化 加速 游戏开挂等等的模块。大致相当于电脑的扩展油猴
Lsposed框架是在Edposed框架的基础上进行改良的新框架。并且接管了Xposed的API，可以很好的兼容Xposed的API
LSPosed框架一直在更新中，有版本更新时。官方都会提供了2个运行环境供我们选择，分 别为riru版本和zygisk版本。两者环境的LSPosed使用起来没什么区别，只有是对运行 环境存在要求。对于新手来说。zygisk版本的框架安装是最简单的.
安装LSP框架基本常识 01--建议最新的LSPosed框架要求面具最低V23.0版本，低于23.0刷入可能出现不能支持新版本了.或者安装时报错版本低.这种情况需要找低版本的lsp框架文件安装
02--如果要刷zygisk的lsp请刷入支持zygisk的面具版本
03---Riru版本：基本支持目前所有版本面具，但新版面具带Zygisk开关，开启Zygisk开关后
riru环境会失效，导致Riru版本LSPosed可能激活失败，所以需关闭Zygisk
04---Zygisk版本：仅仅支持最新稳定24/Alpha/金丝雀等带Zygisk版本面具，面具无Zygisk按钮
的，均不支持使用，会激活失败.zygisk版本发Lsposed是基于Magisk的插件zigisk完成的，它也是在Android启动链上入手，实现Hook。zygisk相当于zygote的magisk，它会在zygote进程中运行magisk的一部分，这也使得Magisk模块更加强大。我们对于Magisk的使用需求一般是获取手机的root权限。使用zygisk可以实现动态替换app_process。
05---Riru版本安装框架需要使用面具模块功能直接刷riru模块，然后再刷入LSP模块激活
06---截止发文。最新的LSPosed v1.91版本支持安卓14系统的适配，并且修复了三星手机此前刷入LSPosed框架出现的兼容问题.
LSP框架安装步骤 1-----手机必须要解锁bl先。至于怎么解锁bl。请查看各自机型解锁bl教程
2-----手机需要有面具root版本。然后按图示进行安装。需要先在面具设置里打开zygisk选项。然后在面具模块里找到下载的lsp框架zip刷入即可
import android.util.Log; import de. robv . android . xposed . IXposedHookLoadPackage; import de. robv . android . xposed. callbacks .XC_ LoadPackage; public class HookTest implements IXposedHookLoadPackage { @Override t@ public void handleLoadPackage(XC_ LoadPackage. LoadPackageParam lpparam) throws Throwable { Log.e( tag: "LSP- TAG", msg: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dfdd51ba3ecace65758a036f24ec1a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a805e86f1a4a883efb7b6092ed03c4fe/" rel="bookmark">
			云计算（Docker）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Docker简介Docker理念Docker 容器与虚拟机的区别 Docker去哪下Docker安装前提说明安装步骤yum安装gcc相关安装需要的软件包设置stable镜像仓库更新yum软件包索引安装DOCKER CE启动docker测试 卸载阿里云镜像加速 Docker常用命令帮助启动类命令镜像命令查找镜像下载镜像删除镜像容器命令 发布阿里云Docker镜像commit操作案例本地镜像发布到阿里云将本地镜像推送到阿里云将阿里云上的镜像下载到本地 Docker简介 Docker 是一个开源的应用容器引擎，基于 Go 语言，并遵从 Apache2.0 协议开源。它可以让开发者打包应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。Docker 可用于开发应用、交付应用、运行应用等场景。
容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低。Docker 允许用户将基础设施中的应用单独分割出来，形成更小的部分容器，从而提高软件交付速度。
Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版）和 EE（Enterprise Edition: 企业版），通常使用社区版就可以满足大多数业务场景。
Docker理念 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。
Linux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。
Docker 容器与虚拟机的区别 Docker 容器与虚拟机很相似，但它们之间又有着很大的区别。
虚拟机是通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。创建虚拟机时，会将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存，每个虚拟机都有独立的硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。
虚拟机会消耗大量系统资源和开销，尤其是当多个虚拟机在同一物理服务器上运行时，每个虚拟机都有自己的子操作系统，大量精力以及资源被用于虚拟化的部署和运行上。
容器类似于虚拟机，只是容器不是完整的操作系统，容器通常只包含必要的操作系统包和应用程序，这就是它们轻量级的原因。
Docker去哪下 • 官网
• docker官网：http://www.docker.com
• 仓库
• Docker Hub官网: https://hub.docker.com
Docker安装 前提说明 CentOS Docker 安装
前提条件
目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在CentOS 7 (64-bit)上，要求系统为64位、Linux系统内核版本为 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a805e86f1a4a883efb7b6092ed03c4fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f987e4fb949dfcd3f2dfaf8aea2597/" rel="bookmark">
			LINUX 安装mysql5.6.50 RPM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天要做一个MySql数据库的主从备份，由于现有的数据库，是使用宝塔安装的5.6.50版本，因此需要在新购买的服务器上安装MySql5.6.50版本，记录一下安装过程的碰见的各种问题
1.下载安装包
抖店云上的系统是CentOS 7.9 64位，因此下载Redhat 7系统下面的安装包
下载地址：https://downloads.mysql.com/archives/community/
只需要下载这两个安装包即可。
2.安装mysql
2.1将下载好的包上传到服务器上
2.2使用命令安装
安装依赖包
yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 libncurses.so.5 --setopt=protected_multilib=false
yum update libstdc+±4.4.7-4.el6.x86_64
安装 mysql-client
rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm
安装 mysql-server
rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm
2.3碰到问题
1.安装mysql-server的时候碰见问题，输入命令rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm的时候返回，error: Failed dependencies，意思是 失败的依赖 解决方法：
在安装包后面加两个参数，如
rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm --nodeps --force
安装时不再分析包之间的依赖关系而直接安装。
2.安装完成之后，启动mysql服务，service mysql start的时候返回：/usr/sbin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory
网上是说这是Linux-centos版本的问题，有的版本缺少libaio.so.1文件。因此需要安装libaio。
安装之前检查一下libaio位置：wheris libaio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f987e4fb949dfcd3f2dfaf8aea2597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b92e9bc55e02483ef2af5267c37adcd/" rel="bookmark">
			小程序开发一个多少钱啊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在今天的数字化时代，小程序已经成为一种非常流行的应用程序形式。由于它们的便捷性、易用性和多功能性，小程序吸引了越来越多的用户和企业。但是，很多人在考虑开发一个小程序时，都会遇到同一个问题：开发一个小程序需要多少钱？
小程序的开发费用因人而异，取决于多种因素。下面，我们将为您详细列出影响小程序开发费用的主要因素。
1、功能需求
小程序的功能复杂程度是影响开发成本的重要因素。功能越复杂，开发难度越大，需要投入的时间和人力成本也就越高。例如，如果小程序需要包含商品展示、支付、同城社区等多项功能，那么开发费用相对较高。
2、技术实现
小程序的开发需要一定的技术基础。如果采用代码开发方式，费用相对较高，耗时也较长。而如果选择自助搭建【45。fkw。com】解决方案，则可以降低开发成本，也能提高开发效率。
3、设计要求
小程序的设计要求也会影响开发成本。如定制设计，需要投入的设计资源也就越多，成本也就越高；如果是已经设计好的小程序模板，则可以降低设计方面的开发成本。
那么，开发一个小程序到底需要多少钱呢？实际上，小程序开发费用并没有一个固定的标准。根据不同的功能需求和技术实现方式，开发费用也会有所不同。一般来说，小程序开发的费用便宜的一千元至三千元左右，贵的则一万元以上至数万元不等。
在您决定开发小程序之前，建议您先明确自己的需求和预算范围。这样，您可以选择合适的技术实现方式，确保您的资金得到合理利用。
总之，在考虑开发一个小程序时，我们需要全面考虑功能需求、技术实现、设计要求等多方面因素，才能确定最终的开发费用。希望以上内容能够帮助您更好地了解小程序开发一个多少钱的费用情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde9791f56d08490e8b0898742c9995d/" rel="bookmark">
			Guacamole远程连接与屏幕录制Docker版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉取镜像 docker pull guacamole/guacamole docker pull guacamole/guacd docker pull mysql/mysql-server 初始化数据库 docker run --rm guacamole/guacamole /opt/guacamole/bin/initdb.sh --mysql &gt; initdb.sql docker run --name mysql --restart=always -e MYSQL_ROOT_PASSWORD=123456 -d mysql/mysql-server:5.7 docker cp initdb.sql mysql:/usr/local docker exec -it mysql bash mysql -u root -p123456 CREATE DATABASE guacamole; CREATE USER 'guacamole'@'%' IDENTIFIED BY 'guacamole'; GRANT SELECT,INSERT,UPDATE,DELETE ON guacamole.* TO 'guacamole'@'%'; use guacamole; source /usr/local/initdb.sql; FLUSH PRIVILEGES; quit; exit; 前期准备工作 # 创建程序主目录 mkdir -p /extdatas/guacamole # 创建插件目录 mkdir -p /extdatas/guacamole/extensions # 创建录像目录 mkdir -p /extdatas/guacamole/recordings # 下载快速链接插件 curl -O https://archive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fde9791f56d08490e8b0898742c9995d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50320f6c4a3f71aeb2f1e727954566e1/" rel="bookmark">
			4.SpringBoot配置及Nacos配置中心加载顺序及覆盖生效优先关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、测试环境版本
二、测试结果
1、标准的SpringBoot应用
2、含有Nacos配置中心的SpringBoot应用
一、测试环境版本 spring-boot-starter-parent 2.7.10
spring-cloud-starter-bootstrap 3.1.6
spring-cloud-starter-alibaba-nacos-config 2021.0.4.0
nacos-client 2.1.1
nacos服务端 2.2.1
二、测试结果 1、标准的SpringBoot应用 在标准的SpringBoot应用中，本地配置加载顺序如下：
bootstrap配置 加载先于 application配置不带profile的配置 加载先于 带profile的配置(不含后缀的)同文件名配置 *.yaml 加载先于 *.properties 综上，本地加载顺序为：
bootstrap.yamlbootstrap.propertiesbootstrap-{profile}.yamlbootstrap-{profile}.propertiesapplication.yamlapplication.propertiesapplication-{profile}.yamlapplication-{profile}.properties 因此，配置生效覆盖关系：
对于key名相同，后加载会覆盖掉前加载，故而最终为后加载的配置项生效！
对于key名不同，则直接生效（会加载，但不会被覆盖）；
注意：不能理解为文件级整体覆盖，而仅是同名key会被后加载的键值覆盖。
2、含有Nacos配置中心的SpringBoot应用 带Nacos配置中心的SpringBoot应用中，配置加载顺序如下：
本地bootstrap配置 加载先于 本地application配置本地配置 加载先于 nacos配置中心 nacos配置中心上共享配置(见下说明) 加载先于 nacos配置中心该服务配置（见下说明）不带profile的配置 加载先于 带profile的配置本地(不含后缀的)同文件名配置 *.yaml 加载先于 *.propertiesnacos配置中心因需要通过data ID指定（或者通过spring.cloud.nacos.config.file-extension指定后缀），所以对于Nacos配置中心上的某个Data ID而言，不会存在既加载其*.yaml又加载其*.properties的情形。 综上，本地及Nacos配置中心共同加载顺序为：
bootstrap.yamlbootstrap.propertiesbootstrap-{profile}.yamlbootstrap-{profile}.propertiesapplication.yamlapplication.propertiesapplication-{profile}.yamlapplication-{profile}.propertiesnacos配置中心共享配置（通过spring.cloud.nacos.config.shared-configs指定）Nacos配置中心该服务配置（通过spring.cloud.nacos.config.prefix和spring.cloud.nacos.config.file-extension指定）Nacos配置中心该服务-{profile}配置（通过spring.cloud.nacos.config.prefix和spring.cloud.nacos.config.file-extension、以及spring.profiles.active指定） 因此，配置生效覆盖关系：
对于key名相同，后加载会覆盖掉前加载，故而最终为后加载的配置项生效！
对于key名不同，则直接生效（会加载，但不会被覆盖）；
注意：不能理解为文件级整体覆盖，而仅是同名key会被后加载的键值覆盖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fff9185fa7a900a2cd7057b493a714/" rel="bookmark">
			如何把eclipse从计算机A移植到计算机B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在计算机A将eclipse文件压缩，迁移到另一计算机B 二、在另一计算机B解压eclipse压缩包 三、eclipse所需插件及jar包需要从计算机A迁移到计算机B 将计算机A的.p2文件夹迁移到计算机B的对应文件夹中。
如把计算机A(C:\Users\Administrator.p2)文件夹迁移到计算机B（C:\Users\Administrator）下
四、需要修改eclipse配置文件 eclipse配置文件包括eclipse目录下的eclipse.ini和config.ini、bundles.info
eclipse.ini 2行：确保eclipse.ini所在目录中，plugins目录下是否存在该jar包
4行：确保对应路径下是否存在该目录，13640相当于Administrator目录
8行：确保对应路径下是否存在该目录，13640相当于Administrator目录
13行：确保在计算机B中eclipse的安装目录是否对应
15行：确保jdk版本
config.ini 3行：确保在计算机B中eclipse的安装目录是否对应
5行：确保对应路径下是否存在该jar包，13640相当于Administrator目录
7行：确保对应路径下是否存在该jar包，13640相当于Administrator目录
8行：确保bundle.info存在于指定目录中。注意：bundles.info可能会存在于如下位置（F:\安装目录\eclipse\configuration\org.eclipse.equinox.simpleconfigurator、C:\Users\13640.p2\pool\plugins\org.eclipse.equinox.simpleconfigurator）
10行：确保对应路径下是否存在该目录，13640相当于Administrator目录
11行：确保对应路径下是否存在该目录&amp;jar包，13640相当于Administrator目录
13行：确保.p2路径没错
bundles.info 注意：bundles.info可能会存在于如下位置，都需要修改（F:\安装目录\eclipse\configuration\org.eclipse.equinox.simpleconfigurator、C:\Users\13640.p2\pool\plugins\org.eclipse.equinox.simpleconfigurator）
bundles.info文件中的文件路径都得改成计算机B中对应的文件路径
五、遭遇问题总结 Eclipse The Eclipse executable launcher was unable to locate itscompanion shared library.
5.1.1 参考文档 https://blog.csdn.net/Oraclesand/article/details/54341466
5.1.2 解决方案 修改eclipse.ini配置文件，确保配置文件中eclipse的安装目录、jar包、插件的目录跟计算机B的环境无误。
java.lang.ClassNotFoundException: org.eclipse.core.runtime.adaptor.EclipseStarter java.lang.ClassNotFoundException: org.eclipse.core.runtime.adaptor.EclipseStarter
at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
5.2.1 参考文档 https://blog.csdn.net/qq_40037872/article/details/94224262
5.2.2 解决方案 修改config.ini配置文件，确保配置文件中eclipse的安装目录、jar包、插件的目录跟计算机B的环境无误。
Ensure that the org.eclipse.core.runtime bundle is resolved and started java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07fff9185fa7a900a2cd7057b493a714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b16070ad59af2109f6b54abebed9c1/" rel="bookmark">
			保证成功！Ubuntu20.04 环境搭建 XTdrone &#43;px4 (v1.13)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提说明：本教程的所有应用前提是需要一个科学上网环境！！！ 1.px4 1.13源码下载与编译 sudo apt get-install git git clone -b v1.13.0-beta1 https://github.com/PX4/PX4-Autopilot.git --recursive cd PX4-Autopilot/ #克隆子模块路径 git submodule update --init --recursive cd.. //执行.sh文件 bash ./PX4-Autopilot/Tools/setup/ubuntu.sh 报错与警告1：配置环境不兼容的原因
解决办法:
sudo pip install --upgrade python-dateutil 报错与警告2：配置环境不兼容的原因
解决办法:
#新建终端打开环境变量 gedit ~/.bashrc #添加环境变量 export PATH=/root/.local/bin:$PATH #刷新环境变量 source ~/.bashrc 成功界面:
压缩 PX4-Autopilot以防后续编译出现问题重新克隆代码:
PX4固件编译:
cd PX4-Autopilot/ make px4_sitl make px4_sitl_default gazebo 成功界面: 弹出的gezebo界面在终端使用ctrl+c进行关闭（防止意外关闭导致后续报错） 2.ROS noetic安装 鱼香ROS一键安装（安装过程中不需要换源，选择桌面版）
wget http://fishros.com/install -O fishros &amp;&amp; . fishros 成功界面（输入roscore）: 3.Mavros安装 sudo apt install ros-noetic-mavros ros-noetic-mavros-extras wget https://raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b16070ad59af2109f6b54abebed9c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588fe6e45fdc1b65d88f23fef50d7d4d/" rel="bookmark">
			Python基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、概述
（一）、python的优缺点
（二）、Python应用场景
（三）、pycharm安装
二、python基础操作
（一）、print打印
（二）、变量
（三）、Python基本数据类型分类
（四）、运算
（五）、循环语句
（六）、检测字符串
（七）、列表
（八）、字典
（九）、模块
总结
前言 python 的创始人为 Guido von Rossum （吉多 · 范 · 罗苏姆），俗称 ” 龟叔 “ ，荷兰人。 1989 年圣诞节期间，在阿姆斯特丹， Guido 为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，做为 ABC 语言的一种继承。之所以选中 Python （大蟒蛇的意思）作为该编程语言的名字，是因为他是一个叫 Monty Python 的喜剧团体的爱好者。 ABC 是由 Guido 参加设计的一种教学语言。是专门为非专业程序员设计的。但是 ABC 语言并没有成功，究其原因，Guido 认为是其非开放 ( 封闭,不开源 ) 造成的。 Guido 决心在 Python 中避免这一错误。同时他还想实现在 ABC 中闪现 过但未曾实现的东西。就这样， Python 在 Guido 手中诞生了。 一、概述 Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588fe6e45fdc1b65d88f23fef50d7d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ca53d891fec7073dcc2cb11188d978/" rel="bookmark">
			Java面向对象之类与对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、面向对象基本概念 面向对象：面向对象程序设计是是一种基于对象概念的软件开发方法。面向对象三大特征：封装、继承和多态。对象：在面向对象的世界中认为万事万物皆对象。认识对象过程中从两个方面，一是对象有什么状态，二是对象有什么行为。对象的状态是指对象有什么属性，对象的行为是指对象有什么行为。对象的简单理解就是真实存在的具体的个体。类：类是具有相同的状态和相同行为的一组对象的集合。类是对象的模板，对象是类的具体实例。类和对象的关系：类是多个对象综合抽象的结果，对象是类的实例化。 1、定义类 类是由字段和方法构成的，字段就是对象的属性，方法就是对象的行为。
面向对象设计的过程就是抽象的过程，也就是设计类的过程，一般分为三步：
发现类，类定义了对象将会拥有的特性（字段）和行为（方法）。发现类的字段，对象所拥有的特性在类中表示为类的字段。发现类的方法，对象执行的操作称为类的方法。 1.1 定义类 定义类的语法格式如下：
public class Person { //类中的属性和方法 } 访问修饰符public、private是可选的。class 是声明类的关键字。按照命名规范，类名应使用帕斯卡命名法，首字母大写。 1.2 类的字段 定义字段的语法格式如下：
-[访问修饰符] 数据类型 字段名;
1）访问修饰符是可选的。
2）除访问修饰符外，其他部分与定义变量相同。
1.3 类的方法 在”人“类中定义”工作“的方法，用于描述人的行为。
public class Person{ //定义人类 public String name; // 定义人的名字 public String gender; // 定义人的性别 public int age; // 定义人的年龄 //定义工作方法 public void work() { System.out.println(this.name + "的工作理念是：让老板挣大钱") } } 2、创建和使用对象 2.1 创建对象 一个对象称为类的一个实例，是类一次实例化的结果。
类的对象可以可以调用类中的成员。
Person person = new Person(); 使用new 运算符实例化了一个person对象。实例化的结果是产生了一个Person类的实例，这个实例的名称是 person。创建对象就是定义了一个新的变量，变量名就是对象名，变量的类型就是被实例化的类。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5ca53d891fec7073dcc2cb11188d978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe2727940d83cd6077f0cbfa8a0cf40/" rel="bookmark">
			Spring Cloud Gateway快速入门（二）——断言工厂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 什么是Gateway断言工厂2. 为什么要使用断言2.1. 调试和开发：2.2. 防御性编程：2.3. 文档和可读性：2.4. 测试： 3. 常用的Gateway断言工厂3.1 Path断言工厂3.2 Method断言工厂3.3 Header断言工厂3.4 时间断言工厂 4. 自定义Gateway断言工厂5. 使用Gateway断言工厂6. gateway断言的功能种类7. 总结 前言 Spring Cloud Gateway包含许多内置的Route Predicate工厂。所有这些断言都匹配HTTP请求的不同属性。多路由断言工厂通过and组合。
官方提供的路由工厂：
这些断言工厂的配置方式，参照官方文档：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html
1. 什么是Gateway断言工厂 Gateway断言工厂是Spring Cloud Gateway提供的一种机制，用于定义路由请求的匹配条件。通过使用不同的断言工厂，我们可以根据请求的不同属性（如请求路径、请求方法、请求头等）来匹配和过滤请求。
2. 为什么要使用断言 断言在软件开发中起到了非常重要的作用。下面是一些使用断言的主要原因：
2.1. 调试和开发： 断言可以用于验证程序的正确性，并在出现错误时提供有用的错误信息。通过在关键代码段中插入断言，开发人员可以检查假设是否成立，以及在遇到不符合预期的情况时立即发现问题。
2.2. 防御性编程： 断言可以帮助开发人员在代码中插入一些额外的检查，以确保程序在运行时的各种情况下都能正确执行。这有助于防止潜在的错误和异常情况，并提高代码的健壮性和可靠性。
2.3. 文档和可读性： 断言可以作为代码的自文档，提供了一种清晰明了的方式来描述代码的预期行为和假设。这使得其他开发人员能够更容易地理解和维护代码。
2.4. 测试： 断言是单元测试的重要组成部分。通过在测试中使用断言，可以验证代码的正确性，并确保它按照预期的方式工作。断言还可以帮助捕获和报告测试中的错误和异常情况。
总之，断言是一种强大的工具，可以帮助开发人员提高代码的质量和可靠性。它们可以帮助我们在开发和测试过程中发现和解决问题，以及提供更好的代码文档和可读性。
3. 常用的Gateway断言工厂 以下是一些常用的Gateway断言工厂及其用法：
3.1 Path断言工厂 Path断言工厂用于根据请求路径进行匹配。
spring: cloud: gateway: routes: - id: path_route uri: http://example.org predicates: - Path=/foo/** 在上述示例中，我们定义了一个名为 path_route 的路由规则，将以 /foo 开头的请求转发到 http://example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe2727940d83cd6077f0cbfa8a0cf40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7177594039b7bdbcaf68d8f2c1445773/" rel="bookmark">
			硬件I2C通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简介
二、物理层
三、协议层
四、I2C在单片机的初始化
初始化过程：
I2C写一个字节数据：
一、简介 I2C全称为Integer Integrated Circuit，由于它的引脚少，硬件连接简单，所以很多时候都使用I2C来进行不同模块之间的通信，虽然速度没有SPI块。
I2C只使用了一根数据总线SDA和一根时钟总线SCL，属于串行通信，采用半双工通信。
二、物理层 I2C的连接方式如下图所示：
I2C支持多设备通信，同一时间只能有一个主机和从机进行通信，每个设备都会由一个独立的地址，可以是7位或10位总线通过上拉电阻接到电源，当设备空闲时会输出高阻态，当所有设备都空闲时，由上拉电阻把总线拉成高电平，I2C就是利用这种特性，所以使用时把引脚设为复用开漏输出模式，输出信号源于I2C外设。设备空闲时输出高阻态是为了不干扰其他设备的通信，如果空闲时输出低电平，当其他数据发送数据1时，就会发生短路，烧坏设备。I2C具有三种传输模式： 标准模式：传输速率100kbit/s快速模式：传输速率400kbit/s高速模式：传输速率3.4Mbit/s(大多还不支持) 三、协议层 I2C读写过程： 开始信号S：在SCL信号为高时(空闲时SCL为高)，SDA从高电平到低电平转变SLAVE ADDRESS：将要通信的从机的地址总上SDA总线，该地址可以是7位或是10位R/W：表示数据传送方向，1表示从从机读取数据，0表示向从机写数据，常跟地址数据一起发送，组成8位数据A：从机向主机发送应答信号，才能继续向下进行DATA：接受到应答信号后开始发送数据，一次发送8位数据。数据发送完成后如果收到从机的应答信号(ACK)，则会继续发送数据，直到收到非应答信号(NACK)或主机发送停止信号停止信号P：在SCL保持高电平时，SDA由低电平向高电平转变 数据的有效性： SDA在SCL的一个时钟周期内传输一位数据，在SCL为高时数据有效，此时SDA为高表示1，为低时表示0；在SCL为低时SDA数据无效，一般在这个时候进行电平切换。
用9个时钟周期传输8位数据，第9个时钟周期是应答信号。
四、I2C在单片机的初始化 初始化过程： //配置i2c引脚 I2C_InitTypeDef i2c_congig = {0}; RCC_APB1PeriphClockCmd(RCC_I2C_CLOCK, ENABLE); i2c_congig.I2C_Mode = I2C_Mode_I2C;//i2c模式 i2c_congig.I2C_ClockSpeed = 100000;//标准模式：100kHz 快速模式：400kHz i2c_congig.I2C_DutyCycle = I2C_DutyCycle_2;//Tlow/Thigh = 2 i2c_congig.I2C_Ack = I2C_Ack_Enable;//使能应答信号 i2c_congig.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;//7位地址 i2c_congig.I2C_OwnAddress1 = MASTER_ADDRESS;//i2c地址 I2C_Init(I2C_TYPE,&amp;i2c_congig); //开启i2c I2C_Cmd(I2C_TYPE,ENABLE); I2C写一个字节数据： /*********************************************** * @brief : I2C向指定地址写入一个字节数据(8位) * @param : addr:写入的地址 * data:写入的数据 * @return: void * @date : 2023.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7177594039b7bdbcaf68d8f2c1445773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb34582514fafd586590b692312c955/" rel="bookmark">
			Java关于AbstractProcessor的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Step1 项目准备Step2 开发一个自定义的AbstractProcessorStep3 Debug AbstractProcessor替换源码内容运行SpringBoot应用测试源码内容是否成功替换 背景：我们都知道，在正常情况下，我们无法去变更二方，三方包中源码的Java文件的内容，但是在某些场景下，我们又希望可以去改动源码中的java文件中的代码，让其最终编译出来以后加载到Jvm当中的是我们改动以后的文件，那么有这样的一种方式可以做到，就是AbstractProcessor，下面给大家看一个例子，原理就是AbstractProcessor提供了一个process的抽象方法，允许你在应用的编译期进行一些处理，在你的Java文件还未编译成class文件时，你可以利用这种机制去更改Java文件，使得应用最终加载到Jvm中的class文件是你更改以后的文件，以此来达到更改源码文件内容的效果
Step1 项目准备 准备一个SpringBoot应用与一个父子模块的应用，目录结构如下
SpringBoot应用：
父子模块的应用（主要是为了在这个模块中开发AbstractProcessor二方包，让SpringBoot引用）：
Step2 开发一个自定义的AbstractProcessor 首先因为AbstractProcessor本身是属于jdk的rt包总的内容，所以不需要额外引入。但是需要引入如下依赖
这个依赖主要是为了使得应用可以自动生成META-INF/services/javax.annotation.processing.Processor文件的，这个文件是为了激活我们自己定义的AbstractProcessor，是必不可少的。
然后我们再定义一个注解，这个注解是为了可以在AbstractProcessor的process让我们去识别处理的，可以理解为触发机制，比如我标注了这个注解，那么才需要去做一些编译期的替换内容的动作
整体的目录结构如下，@CompileTag注解的内容则是我们自定义的一些内容了，比如我可以设计一个源文件字段，一个目标文件字段，编译期想做的事情就是去把这两个文件做一个替换等等
那么接下来再看看我们自定义的编译器Processor是长啥样的
@SupportedAnnotationTypes标识了这个编译器所支持的注解
@SupportedSourceVersion标识了这个编译器所支持的Java版本
@AutoService(Processor.class)则是为了生成META-INF/services/javax.annotation.processing.Processor文件的注解
那么核心其实就是在prosess方法里面的逻辑了，这个就是要自己开发拉
Step3 Debug AbstractProcessor替换源码内容 当我们开发完以后就要去debug我们的处理器，看是否有生效了，我们在demoSync中引入shutdown的二方包，这样就引入了我们对应的处理器，然后在应用中打上CompileTag注解，方便识别
debug方式：
第一步：在idea的terminal控制台输入mvnDebug clean install进行回车，会看到如下界面
第二步：创建一个连接8000端口的Jvm Debug进程
然后运行该debug，并且在自己的processor方法处打上断点，不一会儿就可以看到断点进来了
运行SpringBoot应用测试源码内容是否成功替换 我自己的话是实验了一下在org.springframework.boot.autoconfigure.jdbc.DataSourceProperties的afterPropertiesSet方法执行处多执行一行代码，日志做一个打印，是有正确输出的，因此还是比较有成就感的哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e37f48270288fbc6b707c13774c81e6/" rel="bookmark">
			OpenMV识别寻找色块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenMv寻找色块的主要功能是在摄像头画面内可以寻找出相应的颜色，并对其框选出来。
# Single Color RGB565 Blob Tracking Example # 单色RGB565颜色追踪示例 # This example shows off single color RGB565 tracking using the OpenMV Cam. # 该示例展示了如何使用OpenMV Cam进行单色RGB565颜色追踪。 import sensor, image, time, math threshold_index = 0 # 0 for red, 1 for green, 2 for blue # 阈值索引（0表示红色，1表示绿色，2表示蓝色） # Color Tracking Thresholds (L Min, L Max, A Min, A Max, B Min, B Max) # The below thresholds track in general red/green/blue things.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e37f48270288fbc6b707c13774c81e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdff405d0340b86702dcefb41a1e214/" rel="bookmark">
			Android13音频子系统分析(二)---初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、AudioPolicyService初始化
1.1 AudioPolicyService::onFirstRef()函数
1.2 AudioCommandThread线程
1.3 AudioPolicyManager初始化
1.3.1 解析audio_policy_configuration.xml配置文件
1.3.2 解析audio_policy_engine_configuration.xml配置文件
1.3.3 AudioPolicyManager::onNewAudioModulesAvailableInt()函数
1.3.4 AudioPolicyManager::updateDevicesAndOutputs()函数
二、AudioFlinger初始化
2.1 AudioFlinger::loadHwModule()函数
2.2 AudioFlinger::openOutput()函数
三、AudioService初始化
本文我会分别介绍AudioFlinger、AudioPolicyService和AudioService这三个模块的初始化过程。AudioHAL进程的核心源码AOSP里面没有，所以这里不做介绍。想了解AudioHAL进程的启动流程，可以从/hardware/interfaces/audio/common/all-versions/default/service/service.cpp文件的main()函数入手，进行分析。
大家知道分析代码的执行流程，一般画时序图比较合适，但是我在分析的过程中发现，当跟进一个复杂模块的函数调用流程时，画出来的时序图会非常大，完全看不清楚，所以，这里我会使用伪代码的方式来说明调用流程。
AudioPolicyService和AudioFlinger都是运行在AudioServer进程中的模块，它们的入口是在/frameworks/av/media/audioserver/main_audioserver.cpp文件中的main()函数中，由init进程通过解析audioserver.rc文件启动。main()函数干的事也比较简单，就是创建AudioPolicyService和AudioFlinger对象，并将它们两个作为Binder服务，添加进ServiceManager中。
由于AudioPolicyService和AudioFlinger都继承了RefBase类，所以它们的初始化函数有两个：构造函数和onFirstRef()函数。不了解Android RefBase类和强弱指针机制的朋友，可以在网上搜一下，写这部分的文章很多。
一、AudioPolicyService初始化 AudioPolicyService的构造函数撒也没干，所以它的初始化入口就只剩下了一个onFirstRef()函数。下面我们看看onFirstRef()函数干了什么事。
1.1 AudioPolicyService::onFirstRef()函数 总体来说onFirstRef()函数主要干了三件事：
创建两个AudioCommandThread，名称为"ApmAudio"和"ApmOutput"。这两个是循环运行的独立线程。ApmAudio线程主要用来通知AudioFlinger设置路由、进行音量配置。ApmOutput线程主要用来通知上层注册的监听者有数据状态更新。调用createAudioPolicyManager()函数，创建并初始化AudioPolicyManager模块。调用AudioSystem.cpp的audioPolicyReady()函数，通知AudioFlinger自己已经初始化完成了。 调用流程如下：
AudioPolicyService.cpp-&gt;onFirstRef() |--&gt;new AudioCommandThread("ApmAudio") |--&gt;new AudioCommandThread("ApmOutput") |--&gt;AudioPolicyService.cpp-&gt;loadAudioPolicyManager()//加载"libaudiopolicymanagercustom.so"，默认没有这个库 |--&gt;AudioPolicyService.cpp-&gt;createAudioPolicyManager()//创建并初始化AudioPolicyManager对象 |--&gt;AudioPolicyManager.cpp-&gt;canBeSpatializedInt()//判断当前系统中是否支持空间音频。只有存在AUDIO_OUTPUT_FLAG_SPATIALIZER的流才代表支持。如果存在，就创建Spatializer对象。同时，空间音频功能目前只支持AUDIO_USAGE_MEDIA和AUDIO_USAGE_GAME这两个场景。 |--&gt;AudioSystem.cpp-&gt;audioPolicyReady() |--&gt;AudioFlinger.h-&gt;audioPolicyReady()//通知AudioFlinger，自己已经初始化完成 1.2 AudioCommandThread线程 AudioCommandThread是AudioPolicyService定义的内部类，继承了Android标准的循环线程类Thread.h。所以，当它的run()函数被调用后，线程就会循环一直调用threadLoop()函数。我们来看一下AudioCommandThread类的初始化函数AudioCommandThread::onFirstRef()函数。在这个函数中它调用了父类Thread.h的run()函数，所以当AudioCommandThread对象被创建时，就会启动此线程。
在线程运行函数AudioCommandThread::threadLoop()中，它会一直遍历自己的消息队列Vector &lt; sp&lt;AudioCommand&gt; &gt; mAudioCommands，当消息队列中没有待处理的消息时，它就会调用Condition类的wait()函数，让自己这个线程睡眠。而外部在向线程的消息队列中插入数据时,又会调用Condition类的signal()函数，将当前线程唤醒。AudioFlinger中的PlaybackThread线程，也是采用这种方法实现：当有播放track时，唤醒线程。没有播放时，线程睡眠，降低CPU占用率，减少功耗。
/** *向AudioCommandThread的消息队列中添加新消息 **/ status_t AudioPolicyService::AudioCommandThread::sendCommand(sp&lt;AudioCommand&gt;&amp; command, int delayMs){ insertCommand_l(command, delayMs);//插入新的待处理消息 mWaitWorkCV.signal();//唤醒当前线程 } /** *AudioCommandThread线程循环运行函数 */ bool AudioPolicyService::AudioCommandThread::threadLoop(){ if (waitTime == -1) { mWaitWorkCV.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdff405d0340b86702dcefb41a1e214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ce60f96af9a8ea137308e1089eb55d/" rel="bookmark">
			浮点数除法和整数除法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浮点数除法和整数除法的区别 问题描述 在Java中，对于给定的整数数组arr[]，假设使用以下两种方式计算该数组的平均值，结果会有所不同：
使用浮点数除法：double avg = (double) sum / arr.length;使用整数除法后再进行类型转换：double avg = (double) (sum/arr.length); 在上述两种方式中，为什么使用浮点数除法可以得到更准确的平均值结果？而整数除法后再进行类型转换为浮点数会导致什么样的结果呢？
区别 首先，让我们看一下这两种写法的具体区别。
double avg = (double) sum / arr.length; 这种写法先将sum转换为double类型，然后进行除法操作。通过强制类型转换 (double) sum，确保除法操作是在浮点数上进行的，避免了整数除法截断小数部分的问题。因此，得到的结果是一个带有小数位的精确平均值。 double avg = (double) (sum/arr.length); 这种写法先进行了sum/arr.length的整数除法操作，然后再将结果强制转换为double类型。由于整数除法会直接截断小数部分，所以得到的结果将是一个不包含小数的整数。通过强制类型转换，将整数结果转换为浮点数类型，但已经丢失了小数部分的信息。因此，得到的结果是一个不准确的平均值。 结论 如果您需要计算真实的平均值，并且希望保留小数位数，请使用 double avg = (double) sum / arr.length; 这种写法。这将确保除法操作在浮点数上进行，得到的结果是一个精确的带有小数位的平均值。
如果您只关心整数部分的平均值，并且不需要小数位数，请使用 double avg = (double) (sum/arr.length); 这种写法。这将先进行整数除法操作，然后将结果转换为浮点数类型。注意，这种写法获得的结果将会舍弃小数部分，因此是一个近似的平均值。
在实际应用中，根据场景和需求选择合适的写法非常重要。如果您需要精确的平均值，并且希望保留小数位数，那么第一种写法将更适合您。如果您只需要整数部分的平均值，那么第二种写法则可以满足您的需求。
在实际应用中，根据场景和需求选择合适的写法非常重要。如果您需要精确的平均值，并且希望保留小数位数，那么第一种写法将更适合您。如果您只需要整数部分的平均值，那么第二种写法则可以满足您的需求。
总结起来，这两种写法之间的区别在于对小数位处理的准确性。了解这些区别，可以帮助我们在计算平均值时选择合适的方法，以满足具体的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6755a1daf9c33144d27b7f5b4cb12aa8/" rel="bookmark">
			Opencv-python去图标与水印方案实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RGB色彩模式是工业界的一种颜色标准，是通过对红（R）、绿（G）、蓝（B）三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是运用最广的颜色系统之一。
RGB 模式的彩色图像在读入 OpenCV 内进行处理时，会按照行方向依次读取该 RGB 图像的 B 通道、G 通道、R 通道的像素点，并将像素点以行为单位存储在 ndarray 的列中。例如，有一幅大小为 R 行×C 列的原始 RGB 图像，其在 OpenCV 内以 BGR 模式的三维数组形式存储。
import numpy as np import matplotlib.pyplot as plt import cv2 img=cv2.imread('img\GDP.JPG') h,w,l=img.shape img.shape (347, 496, 3) 注：数据存储格式，每个单元数据范围在0~255，RGB中（255，255，255）为白色，（0，0，0）为黑色，在二位平面图上，原点（0，0）在图的左下角。
1. 按水印颜色范围滤除水印或按曲线颜色提取图形 按水印颜色范围滤除水印方案，主要是针对简单、水印背景颜色单一，例如上图中的灰色。使用windows系统自带工具“图画”，获取RGB颜色值。
如图中，选中1号位置取色器，放置到水印图标上2号位置，通过3号位置的颜色编辑器获取颜色数值。（默认灰色为：128，128，128）
R=242，G=242，B=244
删除灰色，以及临近灰色，同时，也可能把临近的灰色坐标也删除，删除就删除了吧，下一篇再说用处。
import numpy as np import matplotlib.pyplot as plt import cv2 img=cv2.imread('img\GDP.JPG') h,w,l=img.shape img.shape for j in range(h): for k in range(w): # 删除灰色水印 if img[j][k][0] &gt; 128 and img[j][k][1] &gt; 128 and img[j][k][2] &gt; 128 : img[j][k][0] = 255 img[j][k][1] = 255 img[j][k][2] = 255 # 删除标题 if img[j][k][0] &lt; 150 and img[j][k][1] &lt; 150 and img[j][k][2] &lt; 150 : img[j][k][0] = 255 img[j][k][1] = 255 img[j][k][2] = 255 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6755a1daf9c33144d27b7f5b4cb12aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad70d4da749ea2944564a561e0354dc7/" rel="bookmark">
			Java项目打包成jar包后，代码中读取文件路径错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始我通过下面的方式获取文件路径，对文件进行操作，本地运行是完全没有问题的！
File directory = new File(pathName); reportPath = directory.getCanonicalPath(); String url = reportPath + "/templates/" + templateName + ".xlsx"; InputStream inputStream = new FileInputStream(url); 但是当我打包项目，部署后发现代码显示找不到文件！！！神马情况？！
经过多方的查询资料，解释如下：
当将 Java 代码打包成 JAR 文件并部署到环境中时，路径获取的方式可能会有所不同。在 JAR 文件中，文件路径不再是操作系统文件系统上的绝对或相对路径，而是相对于 JAR 文件本身的路径。
好的，找寻别的解决方式：
public class Main { public static void main(String[] args) { // 获取文件的输入流 InputStream inputStream = Main.class.getResourceAsStream("/templates/file.xlsx"); // ... } } 通过getResourceAsStream直接获取文件的流，完美解决问题！！！
最后，希望觉得有用的小伙伴们一键三连支持一下哈~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8526eccdeada98fc75d6430702ad396/" rel="bookmark">
			K8S：pod集群调度及相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.pod集群调度概念1.调度约束( List-Watch组件)2.List-Watch的工作机制（1）List-Watch的工作机制流程（2）List-Watch的工作机制图示 3.调度的过程（1）调度的任务（2）调度选择pod节点（3）调度的过程（4）调度的算法（5）调度的优先级 二.pod集群调度示例1.指定调度节点示例2.通过节点标签调度（nodeSelector）示例3.平均调度节点示例 三.亲和性（节点亲和、pod亲和）1.节点亲和（1）节点亲和概念（2）键值运算关系（3）创建节点硬策略亲和示例：（4）创建节点软策略亲和示例：（5）节点软硬策略亲和示例 2.pod亲和性与反亲和性（1）Pod亲和性与反亲和性的调整策略（2）Pod亲和性示例（3）Pod 反亲和性调度示例1（4）Pod 反亲和性调度示例2 四.污点(Taint) 和 容忍(Tolerations)1.污点(Taint)（1）污点概念（2）污点的组成格式及污点的存在选项（3）查看节点污点（4）节点污点示例 2.容忍(Tolerations)（1）容忍(Tolerations)概念（2）节点容忍示例（３）污点注意事项 五．维护操作１．cordon调度器（１）对节点执行维护操作（２）cordon调度器 2.drain命令 六.Pod启动阶段（相位 phase）1.pod启动过程2.phase 的可能状态3.故障排除步骤 总：1.list-watch2.scheduler3.pod 调度到指定节点的方法4.节点亲和性和反亲和性5.相关标签命令6.污点和容忍7.Pod启动阶段(相位) 5个状态8.排除故障方法 一.pod集群调度概念 1.调度约束( List-Watch组件) Kubernetes 是通过 List-Watch的机制进行每个组件的协作，保持数据同步的，每个组件之间的设计实现了解耦。
用户是通过 kubectl 根据配置文件，向 APIServer 发送命令，在 Node 节点上面建立 Pod 和 Container。
APIServer 经过 API 调用，权限控制，调用资源和存储资源的过程，实际上还没有真正开始部署应用。这里 需要 Controller Manager、Scheduler 和 kubelet 的协助才能完成整个部署过程。
2.List-Watch的工作机制 （1）List-Watch的工作机制流程 在 Kubernetes 中，所有部署的信息都会写到 etcd 中保存。实际上 etcd 在存储部署信息的时候，会发送 Create 事件给 APIServer，而 APIServer 会通过监听（Watch）etcd 发过来的事件。其他组件也会监听（Watch）APIServer 发出来的事件。
Pod 是 Kubernetes 的基础单元，Pod 启动典型创建过程如下：工作机制
（1）这里有三个 List-Watch，分别是 Controller Manager（运行在 Master），Scheduler（运行在 Master），kubelet（运行在 Node）。 他们在进程已启动就会监听（Watch）APIServer 发出来的事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8526eccdeada98fc75d6430702ad396/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f14b3801df719a9e6964dd243ad8fbad/" rel="bookmark">
			K8S：pod资源限制及探针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.pod资源限制1.pod资源限制方式2.pod资源限制指定时指定的参数（1）request 资源（2） limit 资源（3）两种资源匹配方式 3.资源限制的示例（1）官网示例（2）Pod和容器的资源请求和限制格式（3）CPU 资源单位介绍（4）内存资源单位（5）资源限制示例1：（6）资源限制示例2： 二.健康检查：又称为探针（Probe）1. 探针的规则2.Probe支持三种检查方法3.探针三种方式示例（1）exec方式（2）httpGet方式（3）tcpSocket方式（4）就绪检测示例（5）示例5：就绪检测2（6）启动、退出动作 三.扩展1.pod的状态2.Container生命周期3.pod的生命周期 总：1.pod的资源限制2.pod容器探针3.三种探测方式：4.pod容器的启动动作和退出的动作 一.pod资源限制 对pod资源限制原因：高并发占用所有的cpu资源、内存资源、会造成雪崩，
方式：对pod做限制、对k8s做限制
1.pod资源限制方式 当定义 Pod 时可以选择性地为每个容器设定所需要的资源数量。
最常见的可设定资源是 CPU 和内存大小，以及其他类型的资源。
2.pod资源限制指定时指定的参数 （1）request 资源 当为 Pod 中的容器指定了 request 资源时，调度器就使用该信息来决定将 Pod 调度到哪个节点上。
（2） limit 资源 当还为容器指定了 limit 资源时，kubelet 就会确保运行的容器不会使用超出所设的 limit 资源量。kubelet 还会为容器预留所设的 request 资源量， 供该容器使用。
如果 Pod 运行所在的节点具有足够的可用资源，容器可以使用超出所设置的 request 资源量。不过，容器不可以使用超出所设置的 limit 资源量。
（3）两种资源匹配方式 如果给容器设置了内存的 limit 值，但未设置内存的 request 值，Kubernetes 会自动为其设置与内存 limit 相匹配的 request 值。 类似的，如果给容器设置了 CPU 的 limit 值但未设置 CPU 的 request 值，则 Kubernetes 自动为其设置 CPU 的 request 值 并使之与 CPU 的 limit 值匹配。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f14b3801df719a9e6964dd243ad8fbad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af2837d2bc6dfe5b1f383f4312accbe/" rel="bookmark">
			使用OpenCV和ROS发布cv::Mat图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当然！以下是C++代码的示例，使用OpenCV和ROS发布cv::Mat图像： "'cpp #包含&lt;ros/ros. h&gt; #包含&lt;sensor_msgs/Image. h&gt; #包含&lt;cv_bridge/cv_bridge. h&gt; int main（int argc， char**argv） { //初始化ROS节点 ROS::init（argc， argv，"image_publisher"）； ROS::NodeHandle nh； //创建发布者对象 ROS::Publisherimage_pub=nh.广告&lt;sensor_msgs::图像&gt;（"image_topic"，1）； //使用OpenCV加载图像 ::垫图像=cv::imread（"path_to_image. png"，cv::IMREAD_COLOR）； //创建sensor_msgs::图像消息 sensor_msgs::ImagePtr msg=cv_bridge::CvImage（std_msgs::Header（），"bgr8"， image）.toImageMsg（）； //循环发布图片 ROS::loop_rate（10）；//以10 Hz发布 而（ros::ok（）） { //发布图片消息 image_pub出版（味精）； //旋转一次处理回调 ROS::旋转一次（）； //睡眠以保持所需的发布速率 loop_rate睡眠（）； } 返回0； } ``` 在此代码中，您需要将“path_to_image. png”替换为图像文件的实际路径。代码创建一个ROS节点，为“image_topic”主题初始化一个发布者，并使用OpenCV加载图像。然后，它使用cv_bridge库将cv::Mat图像转换为sensor_msgs::图像消息。图像使用image_pub发布者以10 Hz的速率循环发布。最后，代码旋转以处理任何回调并休眠以保持所需的发布速率。 Certainly! Here's an example of C++ code to publish a cv::Mat image using OpenCV and ROS: ```cpp #include &lt;ros/ros.h&gt; #include &lt;sensor_msgs/Image.h&gt; #include &lt;cv_bridge/cv_bridge.h&gt; int main(int argc, char** argv) { // Initialize ROS node ros::init(argc, argv, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7af2837d2bc6dfe5b1f383f4312accbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ba3b40acd3fb5f30da0e03506f8d01/" rel="bookmark">
			MAC地址格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 格式"aa.bb.cc.dd.ee.ff"转换为""aabb-ccdd-eeff
sed -r 's#(.*)\.(.*)\.(.*)\.(.*)\.(.*)\.(.*)#\1\2-\3\4-\5\6#g' mac.txt OR awk -F '.' '{print $1$2"-"$3$4"-"$5$6}' mac.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d022e3d42f4b038df0ffe6c1f61f83/" rel="bookmark">
			FreeRTOS移植以及核心功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 freertos和ucos区别，优缺点比较移植步骤核心功能内存管理（5种内存管理策略）FreeRTOS任务调度算法有三种时间管理通信管理 栈管理 freertos和ucos区别，优缺点比较 FreeRTOS（Free Real-Time Operating System）和 uC/OS（Micro-controller Operating System）都是常见的实时操作系统（RTOS），用于嵌入式系统开发。它们有以下区别和特点：
FreeRTOS:
FreeRTOS 是由 Richard Barry 创建的免费开源的实时操作系统。FreeRTOS 非常轻量级，使用较少的内存资源，适用于资源有限的嵌入式系统。提供了任务管理、调度、时间管理、同步和通信等常见的操作系统功能。FreeRTOS 的核心是一个协程调度器，支持协作式多任务处理。支持多种处理器架构，包括 ARM、MIPS、X86 等。 uC/OS:
uC/OS 是由 Jean J. Labrosse 创建的商业实时操作系统，也有免费的开源版本（uC/OS-II）。uC/OS 具有丰富的功能，提供了任务管理、调度、同步、通信、内存管理等操作系统服务。对于实时性要求较高的应用，uC/OS 提供了可选的抢占式调度方式。支持多种处理器架构，包括 ARM、MIPS、ColdFire 等。uC/OS-III 是 uC/OS 的最新版本，相比于旧版本，具有更强大的功能和改进的性能。 两者的优缺点比较如下：
FreeRTOS 优点：
轻量级、简单易用，适合资源受限的系统。开源免费，可根据需求修改和定制。社区活跃，有大量的文档、示例和支持资源。 FreeRTOS 缺点：
功能相对较少，相比于某些商业 RTOS，可能缺乏一些高级特性和工具支持。部分功能需要额外的模块或者移植。 uC/OS 优点：
提供丰富的功能，满足大部分实时系统的需求。具有商业版和开源版可供选择。支持抢占式调度，适合对实时性要求高的应用。 uC/OS 缺点：
商业版需要购买授权，并且较为昂贵。文档和社区资源相对较少。 在选择 FreeRTOS 还是 uC/OS 时，应根据具体需求、项目要求、开发团队经验和资源等进行综合考虑。如果项目对资源和成本有限制，或需要轻量级的操作系统，那么选择 FreeRTOS 可能更合适。如果项目对实时性要求较高，或需要丰富的功能和工具支持，而且有购买授权的预算，那么 uC/OS 可能更适合。
移植步骤 在将FreeRTOS移植到STM32上之前，您需要进行以下配置：
配置硬件：确保您的STM32芯片与所选择的FreeRTOS版本兼容，并且具备足够的内存资源（ram资源）。您可以参考芯片的数据手册和FreeRTOS的系统要求来确认这些信息。
引入FreeRTOS源代码：将FreeRTOS源代码添加到您的项目中。您可以从FreeRTOS官方网站下载最新的稳定版本或者适用于STM32的移植版。
配置FreeRTOSConfig.h文件：这个文件包含了FreeRTOS的核心配置参数。您需要根据STM32的硬件特性和应用需求进行相应配置。以下是一些可能需要配置的参数：
定时器配置：根据STM32的定时器资源，配置用于FreeRTOS的系统节拍定时器。内存管理器配置：根据可用的RAM大小和需要的内存管理策略，配置内存管理器选项。任务优先级配置：定义任务优先级的范围和默认优先级。栈配置：为每个任务定义适当大小的栈空间。优化配置：根据应用需求进行合适的编译优化设置。 创建任务：在main.c（或其他文件）中创建需要运行的任务，通过调用FreeRTOS提供的API函数进行任务的创建、启动和管理。
配置中断：根据您的应用需求，配置适当的中断处理程序，并使用FreeRTOS提供的接口函数来在中断中进行任务切换。
配置时钟和系统节拍：根据STM32的时钟设置和FreeRTOS的节拍定时器配置，确保系统节拍的准确性和稳定性。
编译和烧录：将修改后的代码编译为可执行文件，并将其烧录到STM32芯片中进行测试和调试。
请注意，以上步骤仅提供了一个大致的概述，实际移植过程可能会因STM32型号、FreeRTOS版本和应用需求而有所差异。建议您参考针对您具体芯片和FreeRTOS版本的移植指南或示例代码，以获得更详细和准确的配置信息和步骤。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d022e3d42f4b038df0ffe6c1f61f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db5e4d216503c0a32c8dee96e764898/" rel="bookmark">
			基于 k8s和docker 构建一个高可用的 web 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目整体架构图
二、项目描述
三、项目准备
1.修改主机名
2.规划项目集群机器的IP地址
3.关闭selinux和firewall
4.升级系统（也可以不升级）
5.添加域名解析
四、项目步骤
1.kubeadm安装k8s单master的集群环境
1.1.配置主机之间无密码登录
1.2.关闭交换分区
1.3.修改机器内核参数
1.4.配置阿里云的repo源
1.5.配置时间同步
1.6.安装docker服务（这一步也可以放在最前面，先安装好docker，再做其他的操作）
1.7.安装kubeadm,kubelet和kubectl（初始化k8s需要的软件包）
1.8.部署Kubernetes的Master节点
1.9.node节点服务器加入k8s集群
1.10.实现master上的pod和node节点上的pod之间通信
2.部署ansible完成相关软件的自动化运维工作
2.1.建立免密通道 在ansible主机上生成密钥对
2.2.上传公钥到所有服务器的root用户家目录下
2.3.验证是否实现免密码密钥认证
2.4.在管理节点上安装ansible
2.5.编写主机配置
3.部署nfs服务器，为整个web集群提供数据
3.1.搭建好nfs服务器
3.2.设置共享目录
3.3.挂载共享目录
3.4.创建pv及pvc使用nfs服务器上的共享目录
4.部署镜像仓库harbor
4.1.前提
4.2.搭建harbor
5.搭建gitlab
5.1.官方部署文档
5.2.安装和配置必须的依赖项
5.3.下载/安装极狐GitLab
5.4.查看密码
5.5.部署成功后使用
6.部署简单的nginx业务
6.1.打包使用python+flask完成的简单项目，制作成镜像
6.2.镜像上传至本地harbor仓库
6.3.在k8s集群上安装ingress-nginx来暴露应用
6.4.使用dashboard对整个集群资源进行掌控
6.5.手工部署应用镜像到k8s使用
6.6.部署过程有报错，报错及解决
PS：拓展
一、项目整体架构图 二、项目描述 三、项目准备 1.修改主机名 hostnamcectl set-hostname k8s-master
hostnamcectl set-hostname k8s-node1
hostnamcectl set-hostname k8s-node2hostnamcectl set-hostname k8s-node3 2.规划项目集群机器的IP地址 serveripk8s-master192.168.205.143k8s-node1192.168.205.144k8s-node2192.168.205.145k8s-node3192.168.205.146ansible192.168.205.138nfs192.168.205.136harbor192.168.205.135prometheus192.168.205.134gitlab192.168.205.190 [root@k8s-master network-scripts]# cd /etc/sysconfig/network-scripts/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db5e4d216503c0a32c8dee96e764898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baddf657713b2afbf1e9d31990aab6ba/" rel="bookmark">
			golang实现远程控制主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ssh原理使用golang远程下发命令使用golang远程传输文件 ssh原理 说到ssh原理个人觉得解释最全的一张图是这张华为画的
Connection establishment
这一步就是建立tcp连接
version negotiation
这一步是ssh客户端(连接者)和被ssh服务端(连接者)进行协议的交换，比如ssh客户端支持那些加密协议，协商出最后使用的协议，还有就是协商ssh版本
Key Exchange
在说Key Exchange之前，我们要知道主机有2类的ssh-key分别是hostkey和user ssh key，每类key都分公钥和私钥，公钥可以加密，私钥可以解密
hostkey：
user ssh key：
首先hostkey，当ssh server安装的时候这个hostkey就会默认生成，在第一次连接对端的时候会显示的提醒我们叫我们确认时候继续连接如下
The authenticity of host '192.168.152.132 (192.168.152.132)' can't be established. ECDSA key fingerprint is SHA256:MzAmI+qRcIEb0AS+6XMcAH5gtxnB779KpHRa1vOvAMs. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes	这是啥意思呢我们第一次连接ssh服务端，服务段会发送自己的hostkey的hash后的值给我们，我们如果选择yes，这段hash后的ssh服务端的hostkey被存入本地的.ssh/know_hosts中这是为了防止中间人攻击，有了这个hostkey之后，会使用diffie-hellman，这个算法用于为2端同时生成session key，因为diffie-hellman算法的特新session key必定相等，后续session建立后都会用这个session key进行加密传输
Key Authentication
随后是user ssh key，这个东西是用户用ssh-keygen生成的(也是ssh -i指定的identity_file])，当用户使用key认证而非密码认证的时候，这个就非常重要，ssh客户端将自己的public user ssh key发送给服务端(因为是session，用session可以进行加密)，然后每当ssh客户端登录到服务端都会自己生成一个随机数用user 自己的userprivate key进行加密通过session传递给客户端，服务端再用接收客户端的公钥进行解密再发送回客户端，客户端进行check，是自己刚刚生成的key就发送验证成功的消息给服务端，最后验证通过，每当客户端向服务端进行数据传输都会使用之前的session key进行加密，服务段接收后用相同的session key进行解密
使用golang远程下发命令 package main import ( "fmt" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baddf657713b2afbf1e9d31990aab6ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88cf16a44c661b4070d07072010800a/" rel="bookmark">
			automake工具基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下以hello.c程序为例
1.执行autoscan
生成configure.scan
这个为configure.ac的模板，内容如下与解释如下
#-- Autoconf --
#Process this file with autoconf to produce a configure script.
#AC_PREREQQ宏声明本文件要求的autoconf版本，这里是2.69
AC_PREREQ([2.69])
#AC_INIT定义软件的名称和信息。(DULL-PACKAGE-NAME为软件名，VERSION为软件
#的版本号，BUG-REPORT-ADDRESS为bug的报告地址，一般为软件作者的邮箱)
AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])
#AC_CONFIG_SRCDIR用来侦测指定的源码文件是否存在，确定源码目录的有效性。此处
#为当前目录下hello.c
AC_CONFIG_SRCDIR([hello.c])
#AC_CONFIG_HEADER用于生成config.h文件，以便autoheader使用
AC_CONFIG_HEADERS([config.h])
#Checks for programs.
#AC_PROG_CC用来指定编译器，以便不指定的时候默认为gcc
AC_PROG_CC
#Checks for libraries.
#Checks for header files.
#Checks for typedefs, structures, and compiler characteristics.
#Checks for library functions.
#AC_OUTPUT用来设定config要产生的文件。如果是Makefile,config会把它检查出
#来的结果带入Makefile.in文件产生合适的Makefile.
AC_OUTPUT(Makefile)
2.修改configure.scan为configure.ac，并且修改内容
修改后如下
AC_PREREQ([2.69])
AC_INIT([hello, 1.0, xxxxxx.qq.com)
#必须添加AM_INIT_AUTOMAKE,否则下auromake会发生报错
#这个宏描述了我们将要生成的软件包的名字和版本号
AM_INIT_AUTOMAKE（hello,1.0）
AC_CONFIG_SRCDIR([hello.c])
AC_CONFIG_HEADERS([config.h])
AC_PROG_CC
#Checks for libraries.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c88cf16a44c661b4070d07072010800a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808c11470ea11629c5ba521290883b0d/" rel="bookmark">
			2023华为OD统一考试（B卷）题库清单（按算法分类），如果你时间紧迫，就按这个刷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 专栏导读华为OD机试算法题太多了，知识点繁杂，如何刷题更有效率呢？ 一、逻辑分析二、数据结构1、线性表① 数组② 双指针 2、map与list3、优先队列4、滑动窗口5、二叉树6、并查集7、栈 三、算法1、基础算法① 贪心算法② 二分查找③ 分治递归④ 搜索算法⑤ 排序算法 2、字符串① KMP② 字符串处理③ 正则表达式 3、深度优先搜索① 广度优先搜索② 最短路③ 拓扑排序 4、动态规划① 基础dp② 背包dp 5、数学 专栏导读 本专栏收录于《华为OD机试（JAVA）真题（A卷+B卷）》。
刷的越多，抽中的概率越大，每一题都有详细的答题思路、详细的代码注释、样例测试，订阅后，专栏内的文章都可看，可加入华为OD刷题群（私信即可），发现新题目，随时更新，全天CSDN在线答疑。
五月份之前，如果你参加华为OD机试，收到的应该是2022Q4或2023Q1，这两个都是A卷题。
5月10日之后，很多小伙伴收到的是B卷，那么恭喜你看到本文了，抓紧刷题吧。B卷新题库正在更新中。
华为机试有三道题，第一道和第二道属于简单题，分值为100分，第三道为困难题，分值为200分，总分400分，150分钟考试时间。
华为的考试平台是牛客网，大家可以提前去牛客网找到华为机考门槛进行练习，主要是熟悉平台操作练习一下怎么处理输入输出哈！后面我也分享了很多牛客网上的华为OD试题。
华为机考的分数是按照测试用例通过的比例来确定的，比如第一题满分100，如果你提交代码后显示测试用例通过率为80%，那么这道题你就只能得80分，所以其实成绩你在考试的时候就心知肚明了！
150分是华为统一的通过分数线。但各部门的要求又不一样，通常非目标院校的分数要求更高些。300+是高分，260+是较为安全的分数。总之分数越高越高，对后续的定级、综面、HR审批都有益处。
一般来说对接你的HR会问你啥时候可以笔试，你觉得准备的ok了就会发你一个机考链接，这个机考链接的有效期为7天，你在这七天时间内找个时间参加考试即可！华为OD机考会影响薪资的，300分以上和300分一下的价格是不一样的，所以我建议大家好好准备争取超过300分，能拿高分就拿高分。
机试没考过的话，会有半年的冷冻期。
为什么我说华为机考并不难，原因很简单，因为这个考试是有题库的！你在进入机考页面的时候网页上会显示正在组卷中，其实就是去题库里找两个简单题一道复杂题。既然这是一场有题库的考试，那我们最重要的当然是获取最全面的题库对吧，这个大家放心我已经帮大家整理好了，未来也会持续更新！
我觉得准备机考前的第一件事是选择一门合适的编程语言，华为机考对编程语言是没有限定的，你可以选择自己最喜欢的编程语言。考虑到大部分华为OD的应聘者都是技术基础较为薄弱甚至非科班的同学，我还是满建议大家使用Java来应付机考还有后面的手撕代码的，当然如果你会JS、Python、C++的话也可以用来考试。
如果基于我提供的题库开始认认真真刷题，不开玩笑的说遇到原题是肯定的，正常情况下遇到两道原题是不难的，很多同学是直接三题全部命中！因为华为题库三个月会更新一部分新题进来，所以大家尽量不要在新题刚刚更新的时候去做，建议在新题发布一个月后再考我感觉命中两道很正常的！
下面，哪吒将华为OD机试真题归归类，让大家一目而了然。
关于订阅华为OD机试真题的后续问题
订阅专栏后，专栏内的文章都可看，以后还会继续更新新题；每道题都包含题目、解题思路、代码详解（关键行包含详细注释）、代码运行截图（保证代码100%正确，通过率100%）；已经订阅的小伙伴，推荐新人订阅可享 8 折优惠，私信我即可； 在考试的时候，最好不要用CSDN专栏里的源码去答题，因为华为OD机试是有查重的，这个一定要注意！最好是改一改变量名称，加一加注释，改一改逻辑顺序，掌握答题思路才是关键，下面的题中我都加了详细的答题思路，代码中也有详细的注释说明，代码运行是100%正确无误的，每一题都有样例测试，全网独一份。
如果你刚刚参加完机试考试，欢迎提供真题到哪吒这里，直接红包转账收题。
很多考过的小伙伴，总结了宝贵的经验，多刷题，先易后难，前期积累自信，后期逐一突破，效果最佳。
华为OD机试算法题太多了，知识点繁杂，如何刷题更有效率呢？ 我觉得可以按照“算法和数据结构”去刷，把华为OD机试涉及到的“算法和数据结构”列出来，一个算法刷10道题，那我岂不是无敌了？
首先，了解算法和数据结构有哪些知识点，在后面的刷题中有 大局观 。
下面是我花了一天时间整理的 算法和数据结构的知识结构，大家可以看看。
后面是为大家 精心挑选的华为OD机试题单，并根据题目知识点的类型分好了类别，大家可以根据每个知识点，进行有针对性的刷题。
一、逻辑分析 华为OD机试 - 求字符串中所有整数的最小和 - 逻辑分析（Java 2023 B卷 100分）
华为OD机试 - 羊、狼、农夫过河 - 逻辑分析（Java 2022 Q4 100分）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/808c11470ea11629c5ba521290883b0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18b978bcd13bcf974a0af278cd17bf9/" rel="bookmark">
			Vim快捷用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下为文本操作 1.快速切换
行首^(shift+6)
行尾$(shift+4)
文章开始gg
位置末尾G
向下翻页CTRL+B
向上翻页CTRL+F
2.删除内容
删除一行 dd
3.复制粘贴
复制一行yy
粘贴 p
4.撤销操作
撤销操作 u
恢复操作ctrl+r
以下都为底行操作 1.显示行号
set nu
2.多文件分屏阅读
加入阅读 vs filename
切换阅读 ctrl+w+w
3.查找字符
查找Keyword字符 /keyword
上面输入后按回车
寻找下一个匹配 n
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a24d765d777a5b678a98a6074aa26d/" rel="bookmark">
			websocket 心跳重连
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var wsUrl = 'ws://' + (document.domain || '127.0.0.1') + ':8282'; var ws = null; // WebSocket 对象 var heartbeatTimer = null; // 心跳定时器 var isReconnect = true; // 是否自动重连 // 创建 WebSocket 连接 // @auth https://so.csdn.net/so/ai function createWebSocket() { if ("WebSocket" in window) { ws = new WebSocket(wsUrl); // WebSocket 打开事件 ws.onopen = function () { console.log("WebSocket 已连接"); // 开始心跳定时器 startHeartbeat(); }; // WebSocket 收到消息事件 ws.onmessage = function (evt) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a24d765d777a5b678a98a6074aa26d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386fe42c16fb745f3b2cf65b51da7a88/" rel="bookmark">
			02 GPU深度学习环境搭建：Win11&#43;CUDA 11.7&#43;Pytorch1.12.1&#43;Anaconda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 查看显卡驱动及对应cuda版本关系
1.1 显卡驱动和cuda版本信息查看方法
1.2 根据显卡驱动 和 CUDA版本对应关系选择 CUDA
2. 安装CUDA
2.1下载CUDA
2.2. 安装CUDA
3. 安装cuDANN
4. 选择 CUDA 对应的Pytorch、Pytorch 对应的Python
5.安装Python环境（安装Anaconda 或 Miniconda）
5.1 安裝Anaconda3
5.2 安装Miniconda
6.安装虚拟环境（如只需一个python环境此步可忽略）
6.1打开这个Anaconda Prompt应用
6.2 创建虚拟环境
6.3 激活环境
6.4 配置清华镜像源（此步可省略）
7、安装pytorch
7.2 进入官网获取安装命令
7.2 进入虚拟环境，执行安装
8、验证安装是否成功
9、环境迁移（了解）
9.1 查看项目所安装的第三方库
9.2 生成依赖环境文件
9.3 环境迁移
此案例是以win11环境的gpu即nvidia为案例，进行深度学习环境搭建，选择工具及版本分别为CUDA 11.7、Pytouch1.12.1、Miniconda3_py38(含Python3.8)
1. 查看显卡驱动及对应cuda版本关系 1.1 显卡驱动和cuda版本信息查看方法 在命令行中输入【nvidia-smi】可以当前显卡驱动版本和cuda版本。
根据显示，显卡驱动版本为：Driver Version: 527.47，CUDA 的版本为：CUDA Version 12.0。
此处我们可以根据下面的显卡驱动和cuda版本对应关系得知，Driver Version: 527.47 &gt;516.31，所以可以使用 CUDA Version 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/386fe42c16fb745f3b2cf65b51da7a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9cb702ad57bbc555dcf46edfc0862f6/" rel="bookmark">
			linux安装Oracle11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux安装Oracle11g 一、准备工作 一、官方最低要求配置 内存：1G（官方最低要求1G） 硬盘：40G（企业版安装所需4.29G和1.7G数据文件） 二、准备工作 1、安装环境介绍 系统：CentOS 7.5 64位 Oracle版本：Oracle 11gR2 2、下载Oracle安装文件 官网下载地址 下载出来是这样两个压缩包： linux.x64_11gR2_database_1of2.zip linux.x64_11gR2_database_2of2.zip 需要了解：Oracle密码？ 主机名？ip? 实例名字？ 环境变量要求？ 二、检查 uname - m # 检查 -x86_64 cat /etc/redhat-release -Centos Linux release 7.4.1708 (Core) 检查YUM源： ll /etc/yum.repos.d/ 需要手动配置： df -h 查看yum源位置 将其余repo改名 vi local.repo [AppStream] name=AppStream baseurl="file:///run/media/wxl/RHEL-7.5 Server.x86_64" enabled=1 gpgcheck=0 三、修改主机 修改主机名： sed -i "s/HOSTNAME=localhost.localdomain/HOSTNAME=oracledb/" /etc/sysconfig/network hostname oracledb 添加主机名： yum -y install vim # 安装vim，如已安装请忽略 vim /etc/hosts # 编辑 hosts 在下面添加： ip 主机名 四、操作 关闭Selinux sed -i "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9cb702ad57bbc555dcf46edfc0862f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8267c3e3bdccfba9d85ce2f412ad6d48/" rel="bookmark">
			grid布局时 justify-*、align-*, *-content *-items 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		justify-* 是沿水平方向设置排列方式；（靠左，靠右、居中）
align-* 指沿垂直方向设置排列方式。（靠上，靠下，居中）
*-items：容器内flex-wrap设置none，所有子项可以用*-items来设置子项的对齐方式，否则设置无无效。
应为flex-wrap设置为none,所有元素排成一行或一列，当排成一行，用align-items设置上、中、下对齐，当排成一列时，用justify-items设置左、中、右对齐。
*-content:容器内flex-wrap设置wrap，所有子项作为容器的内容（content），用*-content来设置对齐方式，否则设置无无效。
flex或grid 布局时，将容器划分为多个矩形区域,如果所有子元素的尺寸相加小于容器的尺寸，即容器有多余空间，*-content用以设置如何分配空白空间。水平方向的多余空间如何分配，用justify-content来设置，设置值为left，表示所有子元素靠左，空白区域留在右侧，设置值为space-evenly,表示均匀分配剩余空间，其余值也很容易理解。类似的，align-content用来设置垂直方向的多余空间分配
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e951fe6594e4a63e4c1d51a193d38083/" rel="bookmark">
			基于Python flask 的某招聘网站爬虫，招聘岗位可视化系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 招聘信息可视化系统 一、介绍 原文地址
今天为大家带来的是Python基于Flask的招聘信息爬取，招聘岗位分析、招聘可视化系统。
此系统是一个实时分析招聘信息的系统，应用Python爬虫、Flask框架、Echarts、VUE等技术实现。
本项目利用 Python 从某招聘网站抓取海量招聘数据，进行数据清洗和格式化后存储到关系型数据库中（如mysql、sqlite等），利用 Flask + Bootstrap + Echarts 搭建招聘信息可视化分析系统，实现不同岗位的学历要求、工作经验、技能要求、薪资待遇等维度的可视化分析，并根据岗位所在地进行不同地域维度的细粒度分析。同时依据用户需求实现热门岗位的推荐，
Python基于flask的招聘数据可视化，招聘岗位分析系统
二、系统运行图 1、数据概览 将爬取到的数据进行展示，点击公司信息和职位信息可以跳转到相应的网址，支持多条件查询
2、城市招聘分布 将数据通过工作城市进行分组，计算每个城市有多少条招聘信息，通过echarts柱状图进行展示
3、福利词云 分析公司福利， 用词云图进行展示
4、薪资统计
通过行业、学历要求和工作地点分析薪资占比
5、招聘要求 经验和学历两个维度分析各个行业的招聘要求占比
6、公司信息分析 对公司属性、公司性质、公司规模进行分析
7、薪资预测 通过工资中位数对薪资进行预测
8、数据爬取 输入爬取关键字（职业关键字）和爬取页数进行数据在线获取，管理员有此功能权限，普通用户则无
9、爬取日志 展示数据获取日志，管理员有此功能权限，普通用户则无
三、系统启动说明 1、启动Flask 启动app.py
2、启动vue 输入npm run serve ，访问系统（http://localhost:8099/）
四、软件架构 基础环境：
python3.8
Flask
BootStrap
Echarts
VUE
五 源码咨询 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/456e4b7b3c414de097d315d1a613d8e2/" rel="bookmark">
			中小型互联网公司如何搭建自己的技术架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用范围
本文主要针对中小型互联网公司，特别适用于手机APP或者pc的后台架构，基本可以支撑5万日活
本文会对可能用到的相关技术进行技术选型的说明，以及技术的架构介绍，技术架构的介绍课程后面有地址，可以点进去查看。
技术指标
说一下一些技术指标的计算过程可以作为其他同学的参考
QPS， 如果是5万日活，使用集中在每天的4小时，每个用户大概产生100的请求，那么平均下来，我们系统大概应该支撑的请求为：50000 100 / (4 60 * 60) = 350 qps/s
业务数据 业务量，我们自己是新闻业务，可能会有其他的业务，比如游戏，商城等等，基本每天新增的业务数据都会在同一个量级， 每日10000， 另外跟用户相关的信息也是比较大的一块，比如用户的订阅等行为，一共5万的用户，保存相关信息可能大概需要100条的数据。
缓存大小 主要业务数据和用户相关的热点数据限时保存在缓存中， 大概需要5个G左右。
日志大小 用户日志和请求日志。 大概每天3个G左右
技术架构
[img59cde995b396e.png]
整体架构因为是小公司，我们基于阿里云来搭建，对图中的内容和技术选型进行一下说明：
负载均衡
可选方案： SLB, Nginx.
SLB要收钱，但是比较便宜，有保证，不会挂。 但是可配置的很少，不能根据域名做ip映射
Nginx, 没啥缺点，需要一定的知识。
建议： SLB + Nginx, SLB绑定域名作为统一的入口，然后每个服务器上再搭建Nginx.
CDN
用于缓存静态文件等等。 七牛和阿里的都还可以。
七牛要做的久一点， 各种图片处理的接口要完善一些
阿里的CDN要稍微好一点点， 但是没有不安全的访问方式，访问稍微没有那么灵活。 图片处理功能弱一点。
分布式调用框架
目前可选的有ZK + dubbo. ZK + Motan, ZK + dubbox, edas。
dubbo, 阿里的服务治理框架，已经不维护了，切换反应有点慢
dubboX, 当当基于dubbo搞的，还在维护可以一用，推荐。
Motan, 微博的服务治理矿建， 刚开源，需要学习一下， 推荐。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/456e4b7b3c414de097d315d1a613d8e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ad32a53e902acf539c7149769266a9/" rel="bookmark">
			css3各种动画效果合集（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		七、双重加载环 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;双重加载环&lt;/title&gt; &lt;style&gt; body{ margin: 0; padding: 0; background: #060606; } .loader{ position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 200px; height: 200px; box-sizing: border-box; background: #000; } .loader .face{ position: absolute; border: 2px solid #121212; } .loader .face.face1{ left: 0; right: 0; top: 0; bottom: 0; background: #090909; box-shadow: 0 0 10px rgba(0, 0, 0, 1); border-radius: 50%; border-left: 2px solid #ffff00; border-top: 2px solid #ffff00; animation: animate 3s linear infinite; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ad32a53e902acf539c7149769266a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337bfb1ebbc6c634d16b70705253d724/" rel="bookmark">
			3D WEB引擎HOOPS Commuicator助力Naval Architect Jumpstart快速启动船舶信息建模平台开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		行业：造船业
挑战：新公司希望将创新的船舶信息建模产品推向市场-基于浏览器的产品需要支持高级可视化和强大的数据转换，以处理大型、复杂的造船项目-小型开发团队的任务是雄心勃勃的平台发布计划。
解决方案： Tech Soft 3D提供领先的SDK，可加速强大的工程Web应用程序的开发。
结果：利用第三方组件进行3D Web轻量化、数据转换和3D建模，提供强大的开箱即用功能-释放开发资源，专注于数字化造船流程的核心价值主张-减少实现下一步所需的时间用于造船上市的新一代云设计平台，有助于确保行业创新者的地位。
我们应用程序的大部分前端（视图、客户看到的内容）都是围绕HOOPS Communicator构建的。根据我们的经验，HOOPS Communicator是唯一能够在Web浏览器中显示3D CAD数据方面表现出色的技术，因此我们非常自豪能够在我们的软件中使用它，它使我们能够真正快速启动我们的应用程序。具有开箱即用的网络查看功能的应用程序开发。”
——Sebastian Greshake，造船师创始人兼首席执行官
HOOPS中文网http://techsoft3d.evget.com/
面临困境
Naval Architect总部位于德国罗斯托克，是一家年轻的公司，专注于构建下一代造船云设计平台。“我们的使命是将造船项目的利益相关者联系起来，以便在正确的时间向正确的人提供正确的信息，”Naval Architect创始人兼首席执行官Sebastian Greshake解释道。“我们正在通过基于浏览器的软件来做到这一点，该软件将数字船舶模型和所有相关项目信息放在一个地方。” 通过这种方式，Naval Architect正在让建筑等行业的数字化在造船领域获得更多立足点。“AEC领域已经采用了建筑信息模型(BIM)，”Naval Architect联合创始人兼业务开发主管Derrick Wan说道。“我们正在努力让造船业转向SIM：船舶信息建模。它基于相同的想法和概念，并且具有增强协作和优化大型复杂项目流程的相同优势，有助于消除代价高昂的错误。” 为了将其创新产品推向市场，Naval Architect为自己制定了雄心勃勃的开发计划。“我们计划在今年年底发布内测版本，在新的一年发布公测版本，然后在明年年底发布完整的商业系统”塞巴斯蒂安说。“我们不是一家大公司；为了满足这些开发期限，我们知道我们需要能够支持我们的愿景并帮助我们实现目标的技术合作伙伴。”
全面的工具加速开发
全球领先的开发工具提供商Tech Soft 3D为Naval Architect提供了一系列功能强大的SDK，以帮助加快其平台的开发。该公司正在利用HOOPS Communicator进行基于Web的可视化，并利用HOOPS Exchange进行数据导入和转换。此外，该公司还使用世界领先的3D几何建模内核技术Parasolid，该技术由Tech Soft 3D转售并与HOOPS SDK紧密集成。
对于像Naval Architect这样的基于浏览器的平台，先进的3D Web可视化是必需的，而HOOPS Communicator可以为3D和2D工程数据提供令人惊叹的图形。这甚至可以使最大的船舶设计可视化，以便向其他利益相关者展示设计、准备营销材料、或者更好地理解船舶内复杂的空间关系。
“我们应用程序的3D查看器是围绕HOOPS Communicator构建的，”Sebastian说。“根据我们的经验，HOOPS Communicator是目前最好的技术，它在Web浏览器中显示3D CAD数据方面表现出色，因此我们非常自豪能够在我们的软件中使用它，它使我们能够真正快速启动我们的应用程序开发具有开箱即用的网络查看功能。” 同样，HOOPS Exchange正在帮助Naval Architect在其平台中构建强大的数据转换技术，包括访问30多种CAD文件格式。
“数据交换是许多造船工程师和造船界其他人士最关心的问题，”塞巴斯蒂安说。“通过HOOPS Exchange，我们正在为从供应商以各种格式导入船舶零部件奠定基础，并提供将数据导出为造船界使用的所有标准文件格式的能力。” 同时，Parasolid为Naval Architect提供了用于3D建模应用程序开发的理想核心，从而降低了开发成本和风险。“3D建模是我们产品的一个小但重要的部分，”Sebastian说。“Parasolid让我们能够提供这种能力，而无需将资源从我们的核心开发重点中夺走：提供‘单一事实来源’，汇集相关信息，并允许用户在整个项目中共同处理船舶的数字表示生命周期。” 全面的，Naval Architect对它的前进道路及其对造船界产生重大变革的潜力感到兴奋。“我们的平台是市场上第一个能够实现真正的流程数字化和造船业全面数字化转型的解决方案，”Derrick说。“我们有机会使船舶信息建模成为行业内的规范，HOOPS正在帮助我们实现这一目标。”
&gt;&gt;&gt;申请HOOPS 60天免费试用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1731360e94f181e09d8b60e09043cd/" rel="bookmark">
			导入虚拟机镜像文件ovf与vdmx遇到的报错及处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
使用VMware esxi服务器，导入ovf与vdmx镜像文件报错
前言 在某次测试过程中，由于测试方的要求，需要进行相关环境的搭建。搭建过程中就涉及到需要将已有的虚拟机环境（ovf、vdmx）导入到VMware esxi服务器里。由于是初次尝试，本以为事情会顺风顺水，结果却是处处碰壁。还好，最后通过不停的探寻，终于找到了错误所在。
提示：以下是本篇文章正文内容，下面案例可供参考
一、导入虚拟机镜像文件ovf与vdmx遇到的报错 报错：
1、先报vmx-17（暂无截图）
2、缺少所需的磁盘影响映像（截图如下）
3、报错电源失败（截图如下）
二、处理方法 1、报vmx-17，将ovf文件里的vmx-17改为vmx-10，报错解决
2、然后就开始报图示的错误，经过排查，是由于因为虚拟机原名有点问题，不好区分。所以后来重命名过，需要在vmdk这个位置改成重命名之后的。现在ovf 文件里面写的名字是之前的名字
3、参考链接
修改之前的
修改之后的（需要与文件名保持一致）
总结 希望以上内容能够对各位正在使用VMware环境的网友起到帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf47af9f2882770ef5d5781990f1bec/" rel="bookmark">
			瓶装液化气末端管理系统-燃气安全信息监管系统-旭华智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个信息化、数字化的时代，各行各业都在努力寻求创新和提升。对于那些涉及到气体充装和使用的企业来说，如何提高运营效率、确保生产安全和降低能源消耗，一直是困扰他们的难题。而瓶装液化石油气末端管理系统正是为了解决这些问题应运而生的一种智能化解决方案。
旭华智能瓶装液化石油气末端管理系统在技术上具有诸多优势。
首先，它可以通过记录每个气瓶的详细信息，提高气瓶的安全系数，有效避免由于气瓶质量或充装不当引发的安全事故。
其次，该平台还可以提升生产效率。健全燃气企业、储配站、危化车、供应站、配送人员、用户、钢瓶等信息的电子档案，对不合格、存在安全隐患的问题进行记录、整改。既提高了效率，又保障了安全。
此外，他还提供线上咨询、预约、交易、投诉等服务，让用户买的方便，用的放心！
该系统与物联网可燃气体探测器共同组成，通过在液化气瓶附近离地30cm的地方安装可燃气体探测器，一旦发现气体泄漏会发出声光警报，并将报警信息通过小程序、短信、智能语音电话将等形式报送用户及监管中心。
此外，他还有智能联动控制设计，可以配接燃气切断阀、排风扇，报警时可自动关闭燃气切断阀并开启排风设备，避免因液化气泄漏发生火灾或爆炸等事故。
通过应用该系统，企业可以实现全面跟踪和追溯液化气瓶的安全管理，提高充装效率，降低能源消耗和安全事故率，从而实现更安全、更高效、更节能的液化气使用。此外，用户安装报警器也是对自身的一种保护。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/56/">«</a>
	<span class="pagination__item pagination__item--current">57/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/58/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>