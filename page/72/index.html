<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e891bc43ec5aabbc5221bcbe3c7edd/" rel="bookmark">
			【学习】华为交换机配置镜像端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、配置观察口
observe-port 1 interface GigabitEthernet0/0/1 // 镜像组1，观察口为0/0/1 2、配置镜像口
进入接口，在接口下配置镜像口。 [Huawei]interface GigabitEthernet 0/0/2 [Huawei-GigabitEthernet0/0/10]port-mirroring to observe-port 1 inbound/outbound/both 同时进入多个接口，再配置镜像口。 interface range GigabitEthernet 0/0/2 to GigabitEthernet 0/0/20 port-mirroring to observe-port 1 inbound/outbound/both 3、验证
display port-mirroring //查看镜像口 display observe-port //查看观察口 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96e907165b259da6c56a69e9a4ff471/" rel="bookmark">
			mongo-将一个字段更新到另一个字段中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mongo-将一个字段更新到另一个字段中 场景 有文档
{ "id":1, "registerTime":"2023-01-09 12:32:10" "tags":[ { "name":"tom", "createTime":"2023-01-09 12:32:10" } ] } 将 registerTime 字段数据更新到 tag.createTime
db.getCollection('t_user').updateOne( { "id":2}, [ {"$set": {"tag.createTime": "$registerTime"}} ] ) //或 db.getCollection('t_user').updateMany( {}, [ {"$set": {"tag.createTime": "$registerTime"}} ] ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c76d69786b4e40d0ca297a99cca07e8/" rel="bookmark">
			nginx 健康检查方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx 健康检查方案 ngx_http_proxy_module模块（自带） 超时时间设置 无特别场景需求都可直接采用默认60s 语法: proxy_connect_timeout ``time``; 默认值: proxy_connect_timeout 60s; 作用域: http, server, location 该指令设置与upstream server的连接超时时间，有必要记住，这个超时不能超过75秒。这个时间Nginx与上游服务器 尝试建立连接，如果60s内都没有建立成功，则会放弃这个连接。 语法: proxy_read_timeout ``time``; 默认值: proxy_read_timeout 60s; 作用域: http, server, location 定义从后端服务器读取响应的超时。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭（连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间））。 语法:	proxy_send_timeout time; 默认值: proxy_send_timeout 60s; 作用域: http, server, location 设置将请求传输到代理服务器的超时。仅在两个连续的写操作之间设置超时，而不是为整个请求的传输。如果代理服务器在此时间内未收到任何内容，则关闭连接。（后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据）。 语法: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 |http_404 | off ...; 默认值: proxy_next_upstream error timeout; 作用域: http, server, location 后端返回状态码:指定在何种情况下一个失败的请求应该被发送到下一台后端服务器： 1、nginx 被动check 方法 Nginx(自带)有健康检查模块：ngx_http_upstream_module，可以做到基本的健康检查 参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c76d69786b4e40d0ca297a99cca07e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28170d4b875049029c7b4c764f451604/" rel="bookmark">
			双网卡电脑共享网络的实现：通过网线，将A电脑的网络共享给B电脑，既能共享文件和网络还能用A/B电脑远程控制B/A电脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象描述： 日常中，一台电脑在进行多任务操作时，往往比较容易卡顿。我希望同时操作2台电脑来提高工作效率，在A电脑运行大型软件的时候，在B电脑进行其他零碎任务，同时两台电脑可以共享文件，而且能够共享键盘和鼠标。
硬件准备： 一根网线，双网卡主板（我是从单网卡主板升级过来的，主板没有双网卡的话试试用拓展设备来增加一个网卡）
环境设置： （1）A电脑连接一个可以访问外网的适配器
（2）我这里是在公司环境中，连接的是公司的以太网。具体的IP设置，大家根据自身环境进行设置
（3）用网线把以太网3和B电脑连接起来，同时将（2）中的适配器网络共享给以太网3，
（4）设置以太网3的Interne协议版本4，并记下这个适配器的IP地址（后面2位可以自行设置，我的B电脑自动分配的IP是192.168.137.108，后来重启电脑后一直连不上。今天研究半天终于搞明白了，还是把A/B电脑的IP都固定住比较稳妥）
（5）设置B电脑的以太网Interne协议版本4，从而组建A/B电脑之间的局域网。注意：B电脑的IP的前3位需要与A电脑的前3位保持在一个网段中。
完成以上设置后，A电脑的网络连接状态如下：1
B电脑的网络连接状态如下：
（6）访问B电脑的网络共享文件，需在B电脑设置共享的文件夹，并开放访问权限。A电脑可以通过B电脑的以太网IP访问B电脑的共享文件，B电脑也可以通过A电脑的以太网2/3的IP来访问A电脑的共享文件
开放共享权限
在安全选项卡中，如果没有Everyone用户的话，需要在高级中进行添加设置，开放Everyone的用户权限，不然A电脑将无法访问B电脑的共享文件也无法进行修改或者删除
（6）对A/B电脑的本地安全策略进行设置，开放Guest用户的访问权限，并将网络访问的本地账号设为经典模式
删除Guest用户的拒绝访问选项
（7）进行远程访问（win10和win11家庭版是没有远程桌面功能的）。在搜索框中输入“远程”即可找到远程桌面连接程序，连接成功后可以将本次连接保存起来，方便后续快速远程控制B电脑，默认保存到“文档库”中。同样的，B电脑也可以远程控制A电脑。
异常处理（2023-06-21追加）： 由于一些莫名其妙的原因，可能我更改了某些设置（记不清了），再次导致我的B电脑失去网络，明明同时固定了A和B两台电脑的IP，现在A电脑还是能正常联网，B电脑却不能。这时，我试了重启电脑大法，没用。
然后，就重新配置一次环境，发现只需重新共享A电脑的用来共享网络以太网即可。以我的A电脑为例，重新共享一次后，以太网3的IP又恢复为自动分配的IP：192.168.137.1，而B电脑那边如果选中自动分配IP的话，那么B电脑的IP可能会和上次不一样。这是我不希望看到的，毕竟变化的IP，会导致路径依赖失效的问题，所以还得参照前面的步骤，给A/B电脑设置固定IP。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0447922ee777f9c3a3cafd867607b10c/" rel="bookmark">
			PHP循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP while 循环 PHP SwitchPHP For 循环 PHP while 循环在指定条件为 true 时执行代码块。
PHP 循环 在您编写代码时，经常需要反复运行同一代码块。我们可以使用循环来执行这样的任务，而不是在脚本中添加若干几乎相等的代码行。
在 PHP 中，我们有以下循环语句：
while - 只要指定条件为真，则循环代码块do...while - 先执行一次代码块，然后只要指定条件为真则重复循环for - 循环代码块指定次数foreach - 遍历数组中的每个元素并循环代码块 PHP while 循环 只要指定的条件为真，while 循环就会执行代码块。
语法 while (条件为真) { 要执行的代码; } 下例首先把变量 $x 设置为 1（$x=1）。然后执行 while 循环，只要 $x 小于或等于 5。循环每运行一次，$x 将递增 1：
实例 &lt;?php $x=1; while($x&lt;=5) { echo "这个数字是：$x &lt;br&gt;"; $x++; } ?&gt; PHP do...while 循环 do...while 循环首先会执行一次代码块，然后检查条件，如果指定条件为真，则重复循环。
语法 do { 要执行的代码; } while (条件为真); 下面的例子首先把变量 $x 设置为 1（$x=1）。然后，do while 循环输出一段字符串，然后对变量 $x 递增 1。随后对条件进行检查（$x 是否小于或等于 5）。只要 $x 小于或等于 5，循环将会继续运行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0447922ee777f9c3a3cafd867607b10c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c6d2a84b8a13fc62ec646c5aa87501/" rel="bookmark">
			Python中if有哪些易错点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中if有哪些易错点 if语句在Python中是非常常用的条件控制语句，但由于其灵活性，可能存在一些易错点。以下是一些可能会导致错误的情况：
缺少冒号: if语句后面必须加上冒号(:)，否则会导致语法错误。
# 错误示例 if x &gt; 0 # 缺少冒号 print("x is positive") 缩进错误: Python通过缩进来表示代码块，因此在if语句下的代码块必须正确缩进。如果缩进不正确，可能会导致意外的结果。
# 错误示例 if x &gt; 0: print("x is positive") # 缺少缩进 误用赋值运算符=: if语句中的条件表达式应该使用相等运算符==而不是赋值运算符=。赋值运算会将条件表达式的结果赋值给变量，而不是进行条件判断。
# 错误示例 if x = 10: # 应该使用 x == 10 print("x is equal to 10") 条件表达式错误: 条件表达式应该返回布尔值(True或False)，否则可能会导致不正确的判断。
# 错误示例 name = "Alice" if name: # 此处条件表达式返回True，因为name非空字符串，但可能不是你期望的结果 print("Hello, Alice!") 多重条件判断错误: 多个条件之间应该使用逻辑运算符(and, or, not)来连接，以正确地表达多重条件判断。
# 错误示例 x = 10 if x &gt; 0 and x &lt; 20: # 应该使用 0 &lt; x &lt; 20 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7c6d2a84b8a13fc62ec646c5aa87501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edbae96e6214d6e5b9700ba76404f15/" rel="bookmark">
			私有Gitea仓库 - 树莓派安装Gitea_Gitlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本来是在树莓派3B上安装GitLab，装了，用不了，设备性能跟不上啊！！后来就找到了一个极易单间的自助Git服务Gitea。
目录 前言1 Gitea简介对比Gitea与其它Git托管工具 2 Gitea安装与初始化3 Gitea初体验3.1 配置gitea在后台运行 4 Gitea创建仓库4.1 创建账户4.2 创建仓库 5 问题记录5.1 无法识别'git'命令：exec: "git": executable file not found in $PATH 1 Gitea简介 Gitea 是一个自己托管的Git服务程序。他和GitHub, Bitbucket or Gitlab等比较类似。他是从 Gogs 发展而来。Gitea的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。我们采用Go作为后端语言，这使我们只要生成一个可执行程序即可。并且他还支持跨平台，支持 Linux, macOS 和 Windows 以及各种架构，除了x86，amd64，还包括 ARM 和 PowerPC。
易安装：可以根据操作系统平台通过二进制运行，还可以通过Docker、Vagrant或包管理安装跨平台：任何Go语言支持的平台都可以运行Gitea，包括windows、Mac、Linux以及Arm。轻量级：一个廉价的树莓派的配置足以满足Gitea最低系统硬件要求。开源化：所有代码开源在GitHub上。 对比Gitea与其它Git托管工具 以上内容来自Gitea官网，让我们正式搞起
2 Gitea安装与初始化 下载前搞个文件夹放gitea的安装包。我这里新建了一个文件夹 # 到当前用户的根目录下 cd /home/xlb # 创建一个linux文件夹 mkdir linux # 在linux文件夹下创建一个gitea文件夹 cd linux mkdir gitea 2. 下载gitea
wget -O gitea https://dl.gitea.io/gitea/1.16.8/gitea-1.16.8-linux-arm-6 获取当前用户对gitea的权限，执行 chmod +x gitea # 启动一次gitea 测试 # 退出 gitea 输入 ctrl+C 即可 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edbae96e6214d6e5b9700ba76404f15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f343f14b1d2abca6aa05b28769ed3ecd/" rel="bookmark">
			数学建模的神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学建模中常常用到神经网络，下面我讲一下我通过网络的资料以及相关书籍的知识说认识到的神经网络。
神经网络（Neural Network,NN),在机器学习和认识科学领域，是一种模仿生物神经网络的结构和功能的数学模型和计算模型，用于对函数进行估计或近似。神经网络由大量的人工神经元联结进行计算，具有学习功能，是一种非线性的统计性数据建模工具。
人工神经元模型：
人工神经元模型由三个基本要素构成：
（i）一组连接，连接强度由各个连接上的权值表示，权值正表示激活，权值为负表示抑制。
（ii）一个求和单元，用于求取各输入信号的加权和，这个是线性组合。
（iii）一个非线性的激活函数，起非线性映射作用并将神经元的输出幅度限制在一定范围里。
人工神经元就是将输入向量与权向量的内积后，经过一个非线性传递函数得到一个标量的结果。
神经网络分类：根据网络结构及工作方式可以将其分为两种连接方式：
（i）前馈型网络
各神经元接受前一层的输入，并且输出给下一层，没有反馈。节点分为两类：计算单元和输入单元。每一层计算单元有任意个输入，但是只有一个输出。
一种常见的多层结构的前馈网络（Multilayer Feedforward Network）由三部分组成，
输入层（Input layer），众多神经元（Neuron）接受大量非线形输入消息。输入的消息称为输入向量。输出层（Output layer），消息在神经元链接中传输、分析、权衡，形成输出结果。输出的消息称为输出向量。隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。隐层可以有一层或多层。隐层的节点（神经元）数目不定，但数目越多神经网络的非线性越显著，从而神经网络的强健性（控制系统在一定结构、大小等的参数摄动下，维持某些性能的特性）更显著。习惯上会选输入节点1.2至1.5倍的节点。 这种网络一般称为感知器（对单隐藏层）或多层感知器qi（对多隐藏层）。
（ii）反馈型网络
所有节点都是计算单元，同时可以接受输入与输出。
下面利用蠓虫分类问题来具体介绍一下神经网络。
蠓虫分类问题可概括叙述如下：生物学家试图对两种蠓虫（Af 与 Apf）进行鉴别，
依据的资料是触角和翅膀的长度，已经测得了 9 支 Af 和 6 支 Apf 的数据如下：
Af:(1.24,1.27)，(1.36,1.74)，(1.38,1.64)，(1.38,1.82)，(1.38,1.90)，(1.40,1.70)，(1.48,1.82)，(1.54,1.82)，(1.56,2.08).
Apf:(1.14,1.82)，(1.18,1.96)，(1.20,1.86)，(1.26,2.00)，(1.28,2.00)，(1.30,1.96).
（i）根据如上资料，如何制定一种方法，正确地区分两类蠓虫。
（ii）对触角和翼长分别为 (1.24,1.80),(1.28,1.84) 与 (1.40,2.04) 的 3 个标本，用所得到的方法加以识别。
利用BP神经网络可得代码：
p1=[1.24,1.27;1.36,1.74;1.38,1.64;1.38,1.82;1.38,1.90; 1.40,1.70;1.48,1.82;1.54,1.82;1.56,2.08]; p2=[1.14，1.82；1.18,1.96;1.20,1.86;1.26,2.00 1.28,2.00;1.30,1.96]; p=[p1;p2]'; pr=minmax(p); goal=[ones(1,9),zeros(1,6);zeros(1,9),ones(1,6)]; plot(p1(:,1),p1(:,2),'h',p2(:,1),p2(:,2),'o') net=newff(pr,[3,2],{'logsig','logsig'}); net.trainParam.show = 10; net.trainParam.lr = 0.05; net.trainParam.goal = 1e-10; net.trainParam.epochs = 50000; net = train(net,p,goal); x=[1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f343f14b1d2abca6aa05b28769ed3ecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e06e90d8ad6eec8a4c11aeb09adccc/" rel="bookmark">
			超详细go语言环境配置！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言环境安装及配置 Go语言下载环境配置修改镜像编译第一个程序——Hello，World！ 记录参加第五届字节跳动青训营go语言学习内容，转载请标明出处！
Go语言下载 Go语言官网下载地址(需要科学上网才能下载)国内Go语言下载地址 根据自己电脑的系统Windows、Linux、macOs下载，这里以Windows为例，下载后缀为msi的二进制进行下载，选择好安装目录，尽量不要安装在C盘下(这里都是傻瓜式安装)
环境配置 打开环境变量
选择系统环境变量添加GOROOT、GOPATH
这里我们自己建一个GOPATH目录，替代c盘的内容
在系统变量的Path中添加%GOROOT%\bin和%GOPATH%新建Go_WorkSpace,并在Go_WorkSpace下建立bin pkg src三个文件夹
确认保存环境变量，一定要点击确认！！！！！！一定要点击确认！！！！！！一定要点击确认！！！！！！保存后，通过Win+R cmd验证 输入 go env 以下目录跟配置的地址一样表示正确
如果这里我们的GOPATH无法修改，通过管理员启动终端输入setx GOPATH 'GOPATH的路径' 例如setx GOPATH 'D:\Go_WorkSpace'(这是我的目录) 修改镜像 国内镜像https://goproxy.cn/
官方有详细介绍
在cmd中输入一下内容，则修改成功
$ go env -w GO111MODULE=on $ go env -w GOPROXY=https://goproxy.cn,direct 验证是否成功 编译第一个程序——Hello，World！ package main import "fmt" func main() { fmt.Println("Hello, World!") } 复制上面代码，在桌面新建一个.txt文件，粘贴保存，修改文件名为 hello.go win+R打开终端
先cd Desktop 再运行go run hello.go，出现Hello，World！恭喜你！完成了go语言的安装和配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4492b4521a530dcb5ba919eaf19da16c/" rel="bookmark">
			Maven全局配置文件settings.xml详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven全局配置文件settings.xml详解 一、概要1. settings.xml 的作用2. settings.xml 文件的位置3. 配置的优先级 二、settings.xml元素详解1. 顶级元素概览1.1 LocalRepository1.2 InteractiveMode1.3 UsePluginRegistry1.4 Offline1.5 PluginGroups1.6 Servers1.7 Mirrors1.8 Proxies1.9 Profiles1.9.1 Activation 1.10 ActiveProfiles 三、参考链接 一、概要 1. settings.xml 的作用 它是用来设置 Maven 参数的配置文件。并且，settings.xml 是 Maven 的全局配置文件。settings.xml中包含类似本地仓库、远程仓库和联网使用的代理信息等配置。
2. settings.xml 文件的位置 settings.xml 文件一般存在于 Maven 的安装目录的 conf 子目录下面，或者是用户目录的 .m2 子目录下面。
3. 配置的优先级 其实相对于多用户的 PC 机而言，在 Maven 安装目录的 conf 子目录下面的 settings.xml 才是真正的全局的配置。而用户目录的 .m2 子目录下面的 settings.xml 的配置只是针对当前用户的。
当这两个文件同时存在的时候，那么对于相同的配置信息用户目录下面的 settings.xml 中定义的会覆盖 Maven 安装目录下面的 settings.xml 中的定义。
用户目录下的 settings.xml 文件一般是不存在的，但是 Maven 允许我们在这里定义我们自己的 settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4492b4521a530dcb5ba919eaf19da16c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acfc1d30450d19d13a0f527421a9cd33/" rel="bookmark">
			Multipart: Boundary not found multer上传文件报错解决(node.js)/前端vue上传formData中file为{}空对象解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在前端使用vue用formdata进行文件的传输时后台node报错
Multipart: Boundary not found multer 前端控制台当中发现接口传输的file文件为空值{}，因为在axios请求时设置
请求头Content-Type为multipart/form-data 时发现在后面没有Boundary 这个参数，正常来说除了multipart/form-data
multipart/form-data；boundary :**************** 后面应该还有一串boundary 参数，首先千万不要自己去拼接Boundary 后面的内容，否则需要自己重新去配置所有的内容参数
后面发现是请求方式的原因，要按步骤的方式进行请求
解决方式如下
首先封装一个axios实例
const axios=axios.create({ baseURL:'http://localhost:3000', // baseURL:'http://192.168.123.127:3000', //配置请求超时时间 timeout: 5000 }) 然后在写接口的地方使用axios即可（切记下面的要原样写，不可以直接写路径，方法如 axios.post(“/login”,function{}）这种）
// 上传文件, export function reqUploadImg(file, user_id) { return axios({ url: '/uploadImg', method: 'POST', Headers: { "content-type": "multipart/form-data", }, data: file, params: { user_id } }) } 就可以解决了这个问题，它就会在后面自动拼接一段字符串，或者我从网上看到是"content-type": "multipart/form-data"中后面的 "multipart/form-data"设置为fasle也会自动拼接后面的参数，但是亲自实验了一下发现类型都变成了json格式，是axios源码自动生成的，所以没有成功，需要自己重新创建一个实例，但是上面这样就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4998fc16097b4759b1a35a7bea963c5d/" rel="bookmark">
			解决电脑内存不足问题：Win10虚拟内存设置指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在使用Windows 10操作系统时，可能会遇到电脑内存不足的情况。这可能导致系统性能下降和应用程序运行缓慢。幸运的是，通过正确设置Win10的虚拟内存，我们可以有效地解决这个问题。本文将为您提供一份Win10虚拟内存设置指南，帮助您优化系统资源管理，提升电脑性能。
具体操作如下：
1.首先，右键点击桌面上的“计算机”，选择“属性”，然后打开该窗口。
2.在属性面板中，找到并点击“高级系统设置”。
3.进入“高级”选项卡页面，然后点击“设置”按钮。
4.再次进入“高级”选项卡，进行修改。
5.取消勾选“自动管理所有驱动器的页面文件大小”，然后继续下一步。
6.点击“自定义大小”，接着可以设置初始大小和最大值。
7.完成后，点击“设置”，然后点击“完成”。这样就完成了Windows 10虚拟内存的设置。
打开电脑的高级设置，在性能选项中将虚拟内存设置为推荐值。尽管Windows10默认智能分配虚拟内存，但最好手动调整。虚拟内存的页面文件通常为PageFile.sys，使用者可以根据实际情况进行自定义和调整。虚拟内存不一定要设置在C盘，也可以选择其他盘符。如果您使用的是固态硬盘，则需要设置虚拟内存。根据个人经验，当涉及大量数据交换和内存操作时，有必要设置虚拟内存。如果您认为这对您来说不实用，则可以忽略此步骤。如果你的电脑内存较大，也可以适当增大虚拟内存的大小。现在就去设置吧！
通过合理设置Win10的虚拟内存，我们可以充分利用硬盘空间来扩展电脑的可用内存，从而解决内存不足的问题。这样可以改善系统的响应速度、减少应用程序的崩溃和卡顿现象。请根据您的具体需求和硬件配置，参考本文提供的Win10虚拟内存设置指南，以实现最佳的系统性能和稳定性。记得在进行任何更改之前备份重要数据，并谨慎设置虚拟内存大小，以避免过度占用磁盘空间。
以上就是我今天要同大家一起分享的全部内容了，大家觉得怎么样呢？是否能让大家了解到更多的知识呢？如果大家们觉得有帮助的话，记得分享给大家身边的朋友一起学起来哦，那么我们就下一次再见面啦！拜拜咯！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2964687d81522c4b8ba984b2b513b557/" rel="bookmark">
			同一个接口调用次数过多后无法请求404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在浏览器查看一下当前页面的 cookie ，如果一个地址每次都塞入一个新的cookie不删除之前的cookie，cookie会增加，到一定时候无法塞入cookie ，就会报错了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c1989ab899b1abd0b286aca87a5a9e6/" rel="bookmark">
			ambari&#43;hdp下重装/卸载服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ambari界面对服务各个组件进行卸载完成后，需要手动去服务器上清理服务的相关目录和文件，已知有：
一.对应在hdfs上的目录，直接删除掉，否则下次重装该服务会读取卸载残留文件，导致错误频出；
二.对应日志目录下的文件，直接删光。比如删除hive的日志，为rm -rf /usr/log/hive/*
三.部分服务可能需要删除在zookeeper上的节点，比如hbase.
四.[可能] 删除在mysql中相关表
五.部分服务需要删除数据。
举例：干净卸载kafka(数据不重要情下)
1.查看hdfs上面没有对应目录，过
2./var/logs/kafka/* 删除光 rm -rf /var/logs/kafka/*
3.查看zk，删除/brokers节点： rmr /brokers
4.不需要删除mysql上对应数据
5.删除数据
查看配置文件定义的数据文件路径:Kafka Broker：Log directories：/kafka-logs/*
每个broker节点都进行删除
清理完毕后，再重新安装服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91e003399421f3bdfb639638f32540b/" rel="bookmark">
			ZYNQ学习笔记——5.AXI_GPIO实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.AXI_GPIO实验 简介 AXI（高级可扩展接口）是一种高性能、低功耗的总线协议，用于在不同的硬件模块之间进行通信。PS和PL之间的连接通常使用AXI接口，以实现数据传输和控制信号的交换。这种连接方式可以实现高速数据传输和灵活的系统集成，使得PS和PL之间可以进行有效的通信和协作。
AXI_GPIO AXI GPIO是一种特定的GPIO（通用输入/输出）控制器，它使用AXI（高级可扩展接口）总线协议进行通信。以下是关于AXI GPIO的一些相关知识：
功能：AXI GPIO用于控制和读取GPIO引脚的状态。它可以配置GPIO引脚的输入/输出模式、电平状态和中断触发方式，并可以读取GPIO引脚的当前状态。
AXI接口：AXI GPIO使用AXI总线协议进行与处理器或其他外设的通信。AXI是一种高性能、低功耗的总线协议，用于在不同的硬件模块之间进行数据传输和控制信号的交换。
寄存器：AXI GPIO通过特定的寄存器来实现控制和读取操作。这些寄存器包括配置寄存器、数据寄存器和中断寄存器等，用于配置GPIO引脚的属性和读取/写入GPIO引脚的状态。
中断功能：AXI GPIO可以配置中断触发方式，并在GPIO引脚状态发生变化时产生中断信号。这样可以实现对外部事件的实时响应，例如按键按下、传感器检测等。
应用领域：AXI GPIO广泛应用于嵌入式系统中，用于与处理器或其他外设进行通信，以控制和读取GPIO引脚的状态。它可以用于连接各种外设，如LED、按钮、传感器等，实现与外部环境的交互。
实验记录 set_property PACKAGE_PIN D19 [get_ports {AXI_GPIO_tri_io[0]}] set_property IOSTANDARD LVCMOS33 [get_ports {AXI_GPIO_tri_io[0]}] set_property IOSTANDARD LVCMOS33 [get_ports {GPIO_0_0_tri_io[0]}] set_property PACKAGE_PIN R14 [get_ports {GPIO_0_0_tri_io[0]}] 代码 #include "stdio.h" #include "xparameters.h" #include "xgpiops.h" #include "sleep.h" #include "xscugic.h" #include "xgpio.h" //实现功能：用BTN0来控制LED0 //BTN1没有用到 #define GPIOPS_ID	XPAR_XGPIOPS_0_DEVICE_ID //PS 端 GPIO 器件 ID #define INTC_DEVICE_ID	XPAR_SCUGIC_SINGLE_DEVICE_ID	//中断控制器器件ID #define AXI_GPIO_ID	XPAR_AXI_GPIO_0_DEVICE_ID	//AXI_GPIO 器件ID //AXI_GPIO 中断号 61 #define AXI_GPIO_INTERRUPT_ID	XPAR_FABRIC_AXI_GPIO_0_IP2INTC_IRPT_INTR //AXI_GPIO 通道1 #define GPIO_CHANNEL1	1 #define LED0	54 XGpioPs_Config * gpiops_cfg_ptr; XGpioPs Gpio;	/* The driver instance for GPIO Device.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91e003399421f3bdfb639638f32540b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec868bf06b61c82501d61489994d77f/" rel="bookmark">
			STM32F103操作DS1302时钟芯片串口显示（标准库和HAL库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
DS1302的性能指标
DS1302的寄存器及片内RAM
标准库实现
HAL库实现
源码链接
单片机型号：STM32F103C8T6 在日常生活中，很多情况下会需要使用时间，单片机中虽然也是有定时器但并不能较为准备的实现计时功能，而且定时计时纯属浪费资源，因此，为了解决此问题，就引入了时钟芯片，时钟芯片能够实现较为精确计时，可实现电子钟/闹钟等功能。
市面上时钟芯片种类很多，本文选用使用较为广泛的DS1302芯片。 DS1302是DALLAS公司推出的涓流充电时钟芯片，内含一个实时时钟/日历和31字节静态RAM，通过简单的串行接口与单片机进行通信。实时时钟/日历电路提供秒、分、时、日、周、月、年的信息，每月的天数和闰年的天数可自动调整。时钟操作可通过AM/PM指示决定采用24或12小时格式。DS1302与单片机之间能简单地采用同步串行的方式进行通信，仅需用到三个口线: (1) RST复位(2) I/O数据线(3)SCLK串行时钟。
时钟/RAM的读/写数据以一个字节或多达31个字节的字符组方式通信。DS1302工作时功耗很低保持数据和时钟信息时功率小于1mW。
下面是其电路图，通过自己设计也是可以实现的，电路图如下：
如果自己不想设计电路，也可以在网上购买时钟模块，其实就是按照上述电路图设计制成，效果图如下：
接下来简单介绍一下DS1302，网上关于其知识点很多，大家也可以自行学习：
DS1302的性能指标 1）可以计算2100年之前的秒、分、时、日、星期、月、年，并且可以调整闰年。
2）内部有31个字节静态RAM,供用户访问
3）串行数据传送方式（SPI3线接口）
4）工作电压：2.0~5.5v
5) 工作电流：2v时，小于300nA(功耗低)
6）时钟或RAM数据的读写，有两种传送方式：单字节传送、多字节传送
7）主电源和负电源双电源供电（备份电源可以用电池或大电容实现）
DS1302的寄存器及片内RAM DS1302内部包括1个控制寄存器，12个寄存器（7个与日历、时钟相关，存放的数据是BCD码形式）和31个RAM
1)控制寄存器
用于存放ds1302的控制命令字，DS1302的复位引脚回到高电平后写入的第一个字就是控制命令，控制着ds1302的读写过程。
D7D6D5D4D3D2D1D01RAM/CKA4A3A2A1A0RD/W 其中：D7：固定为1D6：RAM/CK位，=1片内RAM，=0日历、时钟寄存器选择位。D5-D1：地址位，用于选择进行读写的日历、时钟寄存器或片内RAM。对日历、时钟寄存器或片内RAM的选择。D0：读写选择，=0写，=1读 寄存器0：最高位 CH 是一个时钟停止标志位。如果时钟电路有备用电源，上电后，我们要先检测一下这一位，如果这一位是0，那说明时钟芯片在系统掉电后，由于备用电源的供给，时钟是持续正常运行的；如果这一位是1，那么说明时钟芯片在系统掉电后，时钟部分不工作了。如果 Vcc1 悬空或者是电池没电了，当我们下次重新上电时，读取这一位，那这一位就是1，我们可以通过这一位判断时钟在单片机系统掉电后是否还正常运行。剩下的7位高3位是秒的十位，低4位是秒的个位，这里再提请注意一次，DS1302 内部是 BCD 码，而秒的十位最大是5，所以3个二进制位就够了。
寄存器1：最高位未使用，剩下的7位中高3位是分钟的十位，低4位是分钟的个位。
寄存器2：bit7 是1的话代表是12小时制，0代表是24小时制；bit6 固定是0，bit5 在12小时制下 0代表的是上午，1代表的是下午，在24小时制下和 bit4 一起代表了小时的十位，低4位代表的是小时的个位。
寄存器3：高2位固定是0，bit5 和 bit4 是日期的十位，低4位是日期的个位。
寄存器4：高3位固定是0，bit4 是月的十位，低4位是月的个位。
寄存器5：高5位固定是0，低3位代表了星期。
寄存器6：高4位代表了年的十位，低4位代表了年的个位。请特别注意，这里的00～99指的是2000年～2099年。
寄存器7：最高位一个写保护位，如果这一位是1，那么是禁止给任何其它寄存器或者那31个字节的 RAM 写数据的。因此在写数据之前，这一位必须先写成0。
接下来是代码实现：
接线表设计：
时钟模块STM32F103VCC5V/3.3VGNDGNDCLKPA0DATAPA1RSTPA2-PA9（串口1）-PA10（串口1） 标准库实现： DS1302.c
#include "ds1302.h" #include "delay.h" u8 read_time[7]; struct TIMEData TimeData; char DS1302_data_1[10]; char DS1302_data_2[8]; /* * SCLK 和 CE初始化 */ void ds1302_gpio_init() { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ec868bf06b61c82501d61489994d77f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bf9f57b997749007b8ebedfb0526a00/" rel="bookmark">
			Java LocalDate的详细方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、LocalDate now() 从默认时区的系统时钟获取当前日期。
LocalDate a = LocalDate.now(); System.out.println(a); // 2023-06-06 2、LocalDate now(ZoneId zone) 从默认时区的系统时钟获取当前日期 LocalDate a = LocalDate.now(ZoneId.systemDefault());//系统默认 System.out.println(a); // 2023-06-06 3、 LocalDate now(Clock clock) 从指定的时钟获取当前日期
LocalDate a = LocalDate.now(Clock.systemDefaultZone());//系统默认 System.out.println(a); // 2023-06-06 4、LocalDate of(int year, int month, int dayOfMonth) 从年、月和日获取实例 LocalDate
year – 代表年份，从MIN_YEAR年到MAX_YEAR年
month – 代表的月份，从1月1日（1月）到12日（12月）
dayOfMonth – 表示从 1 到 31 的月份中的某天
LocalDate localDate = LocalDate.of(2023,6,5); System.out.println(localDate);//2023-06-05 5、LocalDate ofYearDay(int year, int dayOfYear) 从一年和一年中的某天获取实例 LocalDate
year – 代表年份，从MIN_YEAR年到MAX_YEAR年
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bf9f57b997749007b8ebedfb0526a00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f37a07ea46c1bb175bad9f75b0d65b16/" rel="bookmark">
			STM32 hal库编程定时器清除中断标志位，开启定时器中断会立即进入中断的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include "tim.h" __HAL_TIM_CLEAR_FLAG(&amp;htim2,TIM_FLAG_UPDATE);	//清除中断标志位 1、如果不清除中断标志位，开启定时器中断的话，不能完成相应的计时，会立即进入中断。
2、如果在开启定时器中断前清除了中断标志位，就会等待计时完成再出发中断。
3、主要是针对单次计时使用，尤其是对第一次计时有要求的程序。
HAL_TIM_Base_Start_IT(&amp;htim2); //开启定时器中断的函数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975972b5be03c600dc6d3fb6407f8a6a/" rel="bookmark">
			信源编码的Matlab实现：费诺编码、香农编码、哈夫曼编码、算术编码、LZ编码、连续信源编码量化 M02014167方正，P02114173陆康超
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
一、概要
二、离散信源编码
1.1 费诺编码
1.2 香农编码
1.3 哈夫曼编码
1.4 算术编码
1.5 LZ78编码
二、连续信源编码
2.1均匀量化
2.2非均匀量化
一、概要 信源编码是为了提高通信系统的有效性，通 过压 缩信息的冗余度来实现。与之对应的信道编码，则是增加信息冗余度来实现，从而提高信息传输的安全性 和信源与信道的适配性。信源分为离散信源和连续信源，要先判断信源的类型，然后采取相应的编码方法，但编码途径都是解除序列符号之间的相关性与概率均匀化。本文介绍几种基本的离散信源编码：费诺编码、香农编码、哈夫曼编码、算术编码及LZ-78编码并给出Matlab实现代码，最后简要介绍连续信源编码的量化方法。
二、离散信源编码 1.1 费诺编码 费诺码即‘’香农-范诺编码‘’（Shannon–Fano coding）是一种基于一组符号集及其出现的或然率（估量或测量所得）构建前缀码的技术，它是一种无失真信源编码方法，由Ralph Fano 于1949年在香农的"A Mathematical Theory of Communication" (1948)文章基础上提出。费诺码在编码效率上，它并不能与霍夫曼编码一样实现编码（code word）长度的最低期望；然而，与霍夫曼编码不同的是，它确保了所有的编码长度在一个理想的理论范围之内。
费诺码的构建过程是递归的，它根据符号的概率分布来确定每个符号所对应的编码。具体步骤如下：
将概率按从大到小的顺序排列，不失一般性，令；
按编码进制数将概率分组，使每组概率和尽可能接近或相等。如编二进制码就分成两组，编m进制码就分成m组；
给每组分配一位码元；
将每一分组再按同样原则划分，重复步骤2和3，直至概率不再可分为止。
费诺码适用于符号概率已知的情况，且在概率分布不平衡时表现较好，可以达到较高的压缩效率。然而，费诺码并不是最优的编码方法，它不能达到信息熵的下界，即香农编码的压缩效率。在实际应用中，霍夫曼编码等其他编码方法通常比费诺码更常用，因为它们可以更接近信息熵的极限。
程序 迭代函数
function[next_P,code_num,next_index]=compare(current_P,current_index); n=length(current_P); add(1)=current_P(1); %1)求概率的依次累加和 for i=2:n add(i)=0; add(i)=add(i-1)+current_P(i); end %2)求概率和最接近的两小组 s=add(n); for i=1:n temp(i)=abs(s-2*add(i)); end [c,k]=min(temp); %3)对分组的信源赋ASCII值 if(current_index&lt;=k) next_index=current_index; code_num=48; next_P=current_P(1:k); else next_index=current_index-k; code_num=49; next_P=current_P((k+1):n); end 编码函数 function[W,L,q]=fano(P) %1)排序 n=length(P); x=1:n; % 2)将信源符号分组并得到对应的码宇 for i=1:n current_index=i; j=1; current_P=P; while 1 [next_P,code_num,next_index]=compare(current_P,current_index); current_index=next_index; current_P=next_P; W(i,j)=code_num; j=j+1; if(length(current_P)==1) break; end end l(i)=length(find(abs(W(i,:))~=0));%得到各码宇的长度 end L=sum(P.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/975972b5be03c600dc6d3fb6407f8a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297e3b88a5a5bd57517e10b993b74470/" rel="bookmark">
			vue 项目热更新失效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网上找了很多种解决方法并未解决，重新下node_modules 也没有用，
最后是更新了@vue/cli-service 的版本，重新启动就可以了
原本是 3.3 升级为3.12
更新语句：
npm update @vue/cli-service 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d4b7c504398ac7b5a4d0d0926894f5/" rel="bookmark">
			Git的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 常见的版本控制工具
Git sVN ( Subversion ) cvs ( concurrent Versions System ) vss ( Micorosoft Visual SourceSafe ) TFS ( Team Foundation Server ) Visual Studio Online
版本控制分类
1、本地版本控制 ​ 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。
2、集中版本控制（SVN） ​ 所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改
​ 所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品:SVN、CVS、vSS
3、分布式版本控制（Git） ​ 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。
Git与SVN主要的区别
​ SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。
​ Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的∶比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件!
Git是目前世界上最先进的分布式版本控制系统。
Git历史 ​ Linux 内核开源项目有着为数众广的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991 -2002年间)。到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper 来管理和维护代码。
​ 到了2005年，帐BitKeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用
BitKeeper的权力。这就迫使Linux开源社区(特别是Linux的缔造者Linus Torvalds)基于使用BitKeeper时的经验教训，开发出自己的版本系统。也就是后来的Git !
Git是免费、开源的，最初Git是为辅助Linux内核开发的，来替代BitKeeper
​ Linux和Git之父李纳斯·托沃兹( Linus Benedic Torvalds ) 1969、芬兰
Git环境配置 软件下载
官网：https://git-scm.com/ 下载对应操作系统的版本即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9d4b7c504398ac7b5a4d0d0926894f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d42ab6a24b5ebf66172a75f25375b74/" rel="bookmark">
			C&#43;&#43;:lower class obj访问upper class obj
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先本篇文章不讨论集成，而是一个class 包含另一个class obj，比如下面代码，base class里面包含了derive class的obj
class derive{ public: derive(){} ~derive(){} }; class base{ public: base() :d(){ } ~base(){} private: derive d; }; 那么问题来了，如果class A包含2个class obj，分别是B和C，而C又包含一个class obj D，此时D obj想调用B obj的某个成员函数怎么办？如下图
class A class B class C class D 解决方案 这里建议在class C中传入class B的obj指针到D中如下代码,class B有一个成员函数，而class D的obj想调用它
#include &lt;iostream&gt; class B{ public: B(){std::cout &lt;&lt; "B construct" &lt;&lt;std::endl;} ~B(){std::cout &lt;&lt; "B destruct" &lt;&lt; std::endl;} int get_id(){return id_;} private: int id_ = 10; }; class D{ public: D(class B *b):b_(b){std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d42ab6a24b5ebf66172a75f25375b74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3cd3782ac73399cf3e5c70ef38afdb/" rel="bookmark">
			车载以太网之DoIP协议_第二篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		车载以太网之DoIP协议_第二篇 1、DoIP使用场景2、诊断仪和车辆的DoIP诊断流程3、车辆网络3.1 .External test equipment3.2 DoIP edge node gateway3.3 DoIP gateway3.4 DoIP node 4、DoIP诊断连接与使用4.1连接建立4.2 车辆发现（即ECU与诊断设备连接）4.3 DoIP会话建立 1、DoIP使用场景 ISO13400-1:2012中，定义了这样几个DoIP的使用场景
2、诊断仪和车辆的DoIP诊断流程 1）FOTA节点首先发送车辆识别请求,待刷写ECU 进行响应；
2）FOTA节点收到车辆识别响应后与待刷写ECU 建立TCP 链接；
3）TCP 链接建立后，FOTA 节点发送通信激活
请求,待刷写ECU 进行通信激活请求响应；
4）FOTA 节点收到通信激活响应后,开始进行诊断报文交互
3、车辆网络 整车的网络拓扑被分为了两个部分，即内部网络和外部网络
下图简要描述了带以太网节点的车载网络和外部网络里的测试设备之间链接。在车载网络中有且仅有1个边缘节点，用于连接外部测试设备。边缘节点可以再连接支持DoIP的网关和其他网络节点，边缘节点本身也具有网关功能，能够通过车内的网络连接到其他的ECU群体。
图中network node可以默认为支持以太网连接的某个节点，如，雷达，摄像头等，但不支持DoIP协议。
名称中含有DoIP前缀的节点可以进行网络分析。
3.1 .External test equipment 外部测试设备，通常为OBD诊断仪或者其他诊断客户端
3.2 DoIP edge node gateway 和DoIP gateway没什么区别。一的区别就是多了个使能线的判断。
1）它是个gateway，作为一个网关它的子网内挂载着若干ECU，与DoIP gateway一样。
2）它是车内网与车外网交互的一个入口，具有控制着DoIP协议栈是否工作的一个开关功能。
3）同时支持Server端和Client端，Server端即测试设备可以诊断该网关下的某个ECU节点；Client端和内部其它子网的DoIP ECU进行交互，另外一个场景是OTA升级，DoIP edge node gateway的应用层可以跑一个OTA客户端程序，进行对内网ECU的诊断及刷写，此时就是一个Client身份。
3.3 DoIP gateway 与 DoIP edge node gateway类似
3.4 DoIP node 支持以太网连接同时又支持DoIP协议的ECU认为是DoIP node。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb3cd3782ac73399cf3e5c70ef38afdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b82c0c1531f28355c01441ecac2cd8/" rel="bookmark">
			数据标注丨智能驾驶的进阶之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周，北京市高级别自动驾驶示范区工作办公室开放智能网联乘用车“车内无人”商业化试点的行动，标志着无人驾驶出租车进入商业化试点的新阶段。
据悉，本次试点共出动116台测试车，累计行驶近200公里，无人驾驶出租车的订单量已达150万人次，用户好评率高达95%以上。
此次开放后，根据《北京市智能网联汽车政策先行区自动驾驶出行服务商业化试点管理细则(试行)》修订版政策，北京市企业在达到相关标准后可在高级别自动驾驶示范区开展自动驾驶出行付费服务。
而这也意味着该阶段示范区对自动驾驶企业能力的考核将更为严格，包括技术能力、安全性、法律合规性以及风险管理等方面的综合评估。
北京市自动驾驶办公室的相关负责人表示，通过持续迭代创新政策与监管体系，先行区为企业的技术能力验证和服务经验积累创造了良好的营商环境。本次开放车内无人商业化试点是基于前两阶段对无人化技术能力充分验证的结果，旨在考察企业的技术服务能力。
企业需要在技术上展现出更高的成熟度和可靠性，确保自动驾驶系统的性能达到更高标准。
全“无人”模式的变革 全无人驾驶是一项具有颠覆性潜力的技术，它的出现将会为交通出行、城市规划、社会经济等领域带来革命性变化。
1. 交通出行：全无人驾驶技术的应用将改变传统的交通出行方式。人们可以更便捷地进行出行，无需亲自驾驶车辆，减少了交通拥堵、事故和交通违法行为的风险。同时，智能化的交通管理系统可以优化道路利用率，提高交通效率。
2. 城市规划：全无人驾驶技术有助于重新规划城市道路和交通网络。无人驾驶车辆具有高度智能化的行驶能力和通信能力，通过与智能交通系统的连接，无人驾驶车辆可以根据实时交通数据和路况信息进行自动调整和优化，使道路的利用率更高，减少交通拥堵。
3. 社会经济：全无人驾驶技术的推广应用将带来新的商业机会和就业岗位。相关产业链将涉及无人驾驶车辆制造、技术研发、数据处理、维护和保险等领域。同时，减少交通事故带来的医疗、法律和保险成本也将对社会经济产生积极影响。
当然，在赞扬全无人自动驾驶的同时，也不能忽视其现阶段技术面临的一系列瓶颈。
自动驾驶技术瓶颈 现阶段，自动驾驶面临的最大瓶颈在于其尚未获得安全可靠的感知能力，即视觉感知能力。
视觉感知通过摄像头、激光雷达和雷达等传感器，利用计算机视觉和深度学习算法来理解和解释周围环境。其主要表现在以下两个方面：
目标检测和识别：自动驾驶系统需要准确地检测和识别道路上的行人、车辆、交通标志和路况等目标。然而，复杂的场景、光照条件的变化以及目标的多样性和遮挡问题都增加了目标检测和识别的难度。
环境感知和判断：自动驾驶车辆需要实时感知道路的结构、车道线、障碍物和行驶状态等信息，以做出准确的决策和规划。然而，复杂的交通环境和不确定的因素使得环境感知和判断变得更加复杂。
现阶段自动驾驶基本处于L3等级，感知能力是影响其等级提升的主因之一。为提升感知力，各大厂商纷纷在汽车上堆传感器，寄希望于借助多种传感器的不同能力提升感知能力。
而提升感知能力，不仅需要传感器的辅助，优质数据也是较为重要的一环。
自动驾驶数据标注 优质数据对于提升感知能力至关重要。
由于自动驾驶感知目前主流的方法都是采用深度学习，需要用到大量的标注数据集来训练模型，所以能够更快更高效的生成大量标注数据，是无人驾驶感知技术提升的关键。
传感器可以收集到大量数据，但是这些原始数据需要经过特殊处理，才能变成可用于训练和优化模型的高质量数据。
优质数据具有以下几个特点：
1. 多样性：数据需要涵盖不同的场景，以保证模型的泛化能力。通过多样性的数据，模型可以学习到更广泛的特征和模式，从而更好地适应复杂多变的现实环境。
2. 准确性：数据标注的准确性对于有效训练模型至关重要。标注过程中的错误或不一致性会对模型的性能产生负面影响。因此，需要严格的质量把控，确保数据的准确性。
3. 海量数据：数据量对于训练深度学习模型来说非常重要。更多的数据意味着模型能够学习到更多的特征，提高模型的准确性和泛化能力。因此，收集大规模数据集是提升感知能力的关键之一。
4. 实时性：对于某些应用场景，实时性的数据非常重要。例如，自动驾驶领域需要实时收集传感器数据来感知和应对环境变化。因此，及时收集和处理数据是确保模型能够做出快速响应的关键。
为了获取优质数据，需要建立有效的数据收集和标注流程，同时结合人工和自动化的方法进行数据处理和标注。此外，与合适的数据提供商合作，利用开放数据集和众包平台等资源，也可以扩大数据规模和多样性，提高数据质量。
曼孚科技作为行业领先的自动驾驶数据标注服务商，总结了许多自动驾驶数据标注经验与方案，为自动驾驶场景化应用保驾护航。
在标注类型方面，MindFlow SEED平台支持图像(2D框、旋转2D框、多边形、关键点、多段线、曲线、3D框、椭圆、日形框等)、语音(ASR转写)、文本(OCR转写)、3D点云(单帧、连续帧、点云融合、点云语义分割)等多种自定义标注方案，满足自动驾驶、高精地图、导航等多个场景需求。
总结 综上所述，优质数据是提升感知能力不可或缺的一环，它为模型提供了丰富、准确、多样且实时的信息，促使模型在现实场景中具备更好的表现。
尽管全无人驾驶技术还面临一些挑战和障碍，但它的出现已经引发对交通出行和城市规划的全新思考，无人驾驶技术有望进一步减少交通事故、缓解交通拥堵，并优化车辆行驶路线，从而减少尾气排放，提高能源利用效率，为可持续发展做出积极贡献。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e6b41d800fa948006ca2a7eb362f80/" rel="bookmark">
			递归 斐波那契数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要求：用递归思想实现斐波那契数列
package com.practice; import java.util.Scanner; public class P1 {//克隆对象 public static void main(String[] args){ T t = new T(); System.out.println("请输入需要求第几位斐波那契数列："); Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.println(t.Sum(n)); } } class T{ public int Sum(int n){ if(n &gt;= 1){//保证输入的值符合要求 在1-正无穷范围内 if(n &gt;= 3){//从第三位开始 数值是前两位数值的和 return Sum(n-1) + Sum(n - 2); } else //若是前两位 则直接赋值为1 return 1; } else System.out.println("要求输入的值大于等于1"); return -1; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688bee362e332acd8176693c3dd7ef9a/" rel="bookmark">
			Java 岗史上最全八股文面试真题汇总，堪称 2023 年面试天花板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 很多同学会问 Java 面试八股文有必要背吗？ 我的回答是：很有必要。你可以讨厌这种模式，但你一定要去背，因为不背你就进不了大厂。 国内的互联网面试，恐怕是现存的、最接近科举考试的制度。 而且，我国的八股文确实是独树一帜。以美国为例，北美工程师面试比较重视算法（Coding），近几年也会加入 Design 轮（系统设计和面向对象设计 OOD）和 BQ 轮（Behavioral question，行为面试问题）。 那么为什么国内面试不采取这样的考察方式呢？简单来说，互联网 IT 行业的求职者太多了，如果考察的是清一溜的算法题和设计题，那么会要求面试官有极高的技术水平，还要花大量的时间成本和精力。 也许现行的八股文面试不是最优的解法，但的确是最符合当前国内 IT 环境的做法。 所以，我采访了超过 20 位资深大厂面试官后，一直在尽量精炼准确的整理一套切实可行的八股文，现在已经有 512 位粉丝通过这套题走入了理想的岗位，所以分享出来给大伙看看，有什么不足之处欢迎评论补充。
我分享的这份春招 Java 后端开发面试总结包含了 JavaOOP、Java 集合容器、Java 异常、并发编程、Java 反射、Java 序列化、JVM、Redis、Spring MVC、MyBatis、MySQL 数据库、消息中间件 MQ、Dubbo、Linux、ZooKeeper、 分布式 &amp;数据结构与算法等 25 个专题技术点，都是小编在各个大厂总结出来的面试真题，已经有很多粉丝靠这份 PDF 拿下众多大厂的 offer，今天在这里总结分享给到大家！
我这篇分享篇幅可能有点长，观看的朋友可以先了解一下目录
JavaOOP 面试题
Java 集合/泛型面试题
Java 异常面试题
Java 中的 IO 与 NIO 面试题
Java 反射面试题
Java 序列化面试题
Java 注解面试题
多线程 &amp;并发面试题
JVM 面试题
Mysql 面试题
Redis 面试题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/688bee362e332acd8176693c3dd7ef9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700ca2ed067264400d4c92cc6e2a2e83/" rel="bookmark">
			RHCE第二次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
#进入/etc/chrony.conf vim /etc/chrony.conf #使用pool.ntp.org中的公共服务器编辑 #iburst表表示首次同步的的时候快速同步 server 0/centos.pool.ntp.org iburst server 1/centos.pool.ntp.org.iburst server 2/centos.pool.ntp.org.iburst server 3/centos.pool.ntp.org.iburst #指定ntp客户端地址，以允许或拒绝连接到扮演时钟服务器 #allow 192.168.95.135 #编辑完成后，保存退出 systemctl restart chronyd #重启服务 chronyc sources -v #时间同步 timedatectl status Local time: 二 2023-07-18 00:15:41 CST Universal time: 一 2023-07-17 16:15:41 UTC RTC time: 一 2023-07-17 16:15:38 Time zone: Asia/Shanghai (CST, +0800) System clock synchronized: yes #yes表示已同步 NTP service: active RTC in local TZ: no 2. useradd redhat #新建用户redhat passwd redhat #设置密码 ssh-keygen -t rsa #制作公钥对，-t指定密钥类型 cd .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700ca2ed067264400d4c92cc6e2a2e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a799c5d190cbab05850336c39542c5e2/" rel="bookmark">
			word目录格式设置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时word 生成的目录格式不符合要求，需要自己调整。
目录格式设置 随后更改字体，段落缩进等等。
目录上各级目录缩进不一致问题 这里选择空格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d67d5aab16035717aa32186560f887a/" rel="bookmark">
			【微信小程序】通过绑定点击事件来实现点击交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序中，可以通过绑定点击事件来实现点击交互。以下是点击事件的实现步骤：
在WXML文件中，找到需要绑定点击事件的元素，例如按钮、图片等。在该元素上添加bindtap属性，并指定一个对应的事件处理函数，例如：&lt;button bindtap="handleTap"&gt;点击我&lt;/button&gt; 在对应的页面或组件的JS文件中，定义事件处理函数。在事件处理函数中，可以编写具体的逻辑代码来响应点击事件，例如：Page({ handleTap: function() { console.log("点击了按钮"); // 这里可以编写其他逻辑代码 } }) 保存文件并运行小程序，在点击绑定了点击事件的元素时，就会触发对应的事件处理函数。 需要注意的是，点击事件的绑定和处理函数的编写需要在对应的页面或组件的JS文件中进行。另外，点击事件的绑定可以使用bindtap属性，也可以使用catchtap属性，区别在于bindtap会继续向上冒泡，而catchtap会阻止事件冒泡。
希望对你有所帮助！如果还有其他问题，请随时提问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8a651ab6e39ab0ca0a17b96bebb72b/" rel="bookmark">
			MySQL(三):切分，主从复制，读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、切分水平切分垂直切分水平切分策略 二、主从复制三、读写分离 一、切分 水平切分 水平切分又称为sharding,它是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多的时候，sharding是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力。
垂直切分 垂直切分指的是将一张表按列拆分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列进行切分到不同的表中。
在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。
水平切分策略 哈希取模:hash(key) % N;
范围：可以是ID范围也可以是时间范围
映射表：使用单独的一个数据库来存储映射关系
二、主从复制 原理如下图所示:
主要涉及到了三个线程: binlog线程, IO线程,SQL线程。
1.binlog线程: 负责将主服务器上的数据更改写入二进制的日志
2.IO线程：负责从主服务器读取二进制日志，并写入slave服务器的relay log。
3.sql线程： 负责读取relay log,解析出主服务器已经执行的数据更改并且写入slave 服务器中。
三、读写分离 主服务器处理写操作和实时性要求比较高的读操作，而slave服务器处理读操作。
读写分离能提高性能的原因在于：
主从服务器负责各自的读和写，极大程度缓解了锁的争用；从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；增加冗余，提高可用性。 读写分离常用代理的方式来进行时西安，代理服务器接收应用层传来的读写请求，然后决定转发到哪一个服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492e91b9bb0dc0c0bed24dfddcf6ba6f/" rel="bookmark">
			利用vscode对ros2的代码进行断点调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu22.04+ros-humble
在代码的工作目录下找到 .vscode 目录，新建 launch.json文件（如果存在直接进行修改）,
launch.json中的内容如下：
{ "configurations": [ { "name": "(gdb) 启动", "type": "cppdbg", "request": "launch", "program": "/home/rocket/robot/src/install/test_cpp/lib/test_cpp/test_cpp", "args": [], "stopAtEntry": false, "cwd": "${fileDirname}", "environment": [], "externalConsole": false, "MIMode": "gdb", "setupCommands": [ { "description": "为 gdb 启用整齐打印", "text": "-enable-pretty-printing", "ignoreFailures": true }, { "description": "将反汇编风格设置为 Intel", "text": "-gdb-set disassembly-flavor intel", "ignoreFailures": true } ] } ], "version": "2.0.0" } 其中“program”中的内容为：可执行程序的地址
即："program": "/home/用户名/工作空间/install/功能包/lib/功能包/可执行文件"
之后便可进行对代码的调试；
若调试时出现加断点后断点出现断点为灰色，且报如下错误:
module containing this breakpoint has not yet loaded or thebreakpoint address could not be obtained 解决方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/492e91b9bb0dc0c0bed24dfddcf6ba6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e673928e72d524b40c684ddb4cfb999/" rel="bookmark">
			数据同步接口开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又来活了，这次的接口是调用一个外部接口同步数据然后入库。开干
首先定义一下PO，数据有哪些属性 @Getter @Setter @ToString @Accessors(chain=true)//开启链式编程 public class SysJobPO implements Serializable { private static final long seriaVersionUID = 1L; private String jobId; private String userId; ...... } ps. 现补了一下PO、VO、DTO的概念：
PO：数据对象实体类，字段与数据库字段相对应
VO：（View Object)表现层对象，主要对应展示界面显示的数据对象，用一个VO对象来封装整个界面展示所需要的对象数据。
DTO：(Data Transfer Object) 是一种设计模式之间传输数据的软件应用系统。用来转换从 entity 到 VO，或者从 VO到 entity 的中间的东西。
定义VO @Getter @Setter @ToString @Accessors(chain=true)//开启链式编程 public class SysJobVO implements Serializable { private static final long seriaVersionUID = 1L; private String jobId; private String userId; ...... } ps. 补一下序列化相关：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e673928e72d524b40c684ddb4cfb999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d4e319cdd2cd6de6dc0d458781028c/" rel="bookmark">
			EasyExcel 操作excel导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、核心依赖
2、导出
前端:一个小页面
后端 实体类
controller dao.xml
sql
效果
导入
前端
后端
实体类(加校验注解)
controller
util包
dao.xml
效果
1、核心依赖 &lt;!-- easyExcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.6&lt;/version&gt; &lt;/dependency&gt; 2、导出 前端:一个小页面 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;excel导入导出&lt;/title&gt; &lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="easyExcelBtn" type="button" &gt; 下载列表数据easyExcel &lt;/button&gt; &lt;script&gt; /** * easyExce导出 */ //给"批量导出"按钮添加单击事件 $("#easyExcelBtn").click(function () { //发送同步请求 window.location.href="easyExcel/write"; }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 后端 实体类 /** * 校验 */ @Data @NoArgsConstructor @AllArgsConstructor public class EasySysUser { // @ExcelProperty("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d4e319cdd2cd6de6dc0d458781028c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701745161f16b5f1d66f6ecc55b64d9c/" rel="bookmark">
			用python做一个自动向微信公众号推送消息的脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标： 做一个类似的消息推送脚本，可以用python试着做一个这样的微信公众号，会一些基础爬虫就可以了，不会的话也不影响，但会了更好，当初学了一点爬虫就做了个这种模板消息推送来玩。
学习内容： 例如：
会一些简单的爬虫了解html的相关知识会基础的python语法 学习过程： 申请微信公众平台接口测试帐号 链接：微信公众平台接口测试帐号申请记住上面的相关信息用接受消息的微信号关注这个测试公众号新增测试模板，参数需以{{开头，以.DATA}}结尾，像上述一样，可以自行添加和修改，并且记住模板ID
通过这个接口调用请求获取到Access token 填写相关参数，例如data,weather,temperature,word可自行填写相关参数，也可以通过爬虫爬取相关数据进行动态获取数据 注意：这个变量要跟自己创建的模块的DATA前的变量要一直
7.如果可以的话也可以设置定时任务每天定时推送消息
8.这样就是请求发送成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04537ebf8674a61ac34c014f147203d2/" rel="bookmark">
			nginx配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		try_files $uri $uri/ /index.html;
添加这个可以自由的进行跳转不受路由控制
#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04537ebf8674a61ac34c014f147203d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e5449751d0dfea066fd93b407a947a/" rel="bookmark">
			SSH时报错：(eog:43872): Gtk-WARNING **: cannot open display:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh连接别人的电脑后，想打开一张图片怎么办？
好不容易找到了可以用eog命令但是却显示
(eog:43872): Gtk-WARNING **: 21:43:44.755: cannot open display: 这时候：
如果在自己电脑上打开，只需要在ssh时把命令换成 ssh username@IP -X 或者
ssh username@IP -Y 即可
如果在所连接的电脑上打开，则需要在开启ssh后加入一段命令 ssh username@IP export DISPLAY=:1 默认情况下DISPLAY是0， DISPLAY是用来设置将图形显示到何处的环境变量
结果如下：
如果只设置DISPLAY没用的话，请检查： 1. X11Forwarding 是否被设置为yes，如果是no，请更改为yes
vim /etc/ssh/sshd_config 2. 禁用访问控制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c79a1d781bb0d609a5151903cdb3573/" rel="bookmark">
			【分享】Redis的持久化策略（RDB和AOF）和适用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的持久化策略 Redis的持久化策略有两种：RDB和AOF。RDB持久化适用于需要快速备份和恢复数据的场景，而AOF持久化适用于对数据精确度和安全性的要求更高的场景。Redis也支持同时使用RDB和AOF两种持久化方式。
RDB持久化（Redis DataBase） RDB持久化是将内存中的数据快照保存到磁盘中。可以手动触发RDB快照或者通过设置定时快照的方式自动触发快照操作。
RDB优点：
RDB快照可以提供更好的备份和恢复机制。RDB快照能够避免AOF的潜在问题。RDB快照对于大规模数据的恢复速度比AOF快。 RDB缺点：
RDB 快照是定期进行的，如果Redis服务意外停止，则最后一次快照和更新之间的所有数据都将丢失。RDB 快照可能会对Redis服务器的性能产生一些负面影响，尤其是在生成快照时，Redis实例可能会暂停服务。 AOF持久化（Append Only File） AOF持久化是将Redis服务器接收到的每个写操作都追加到一个AOF文件中。AOF文件可以重放来重新构建数据集，这意味着如果Redis服务器关闭或崩溃，数据集不会丢失。
AOF优点：
AOF 能够提供更精细的数据持久化和恢复机制。AOF 可以很好地保护数据，即使Redis服务意外停止，最多只会丢失一些写操作。 AOF缺点：
AOF文件通常比RDB文件大，因为它记录了每一个写操作，所以可能会占用大量磁盘空间。AOF文件通常比RDB文件慢，因为每个写操作都需要写入磁盘。 AOF功能特别强大，但是它的写入频率也就更高，因此可能会影响性能。 Redis持久化的过程 RDB持久化过程 RDB持久化是将Redis中的数据保存到一个二进制文件中。可以在Redis配置文件中设置保存RDB文件的时间间隔，以实现自动保存。也可以通过命令手动创建RDB快照。开启RDB持久化的命令如下：
redis-cli config set save "900 1 300 10 60 10000" AOF持久化 AOF持久化是将Redis中的所有写命令以追加方式写入一个文件中。在Redis配置文件中设置AOF文件的保存方式，可以实现自动保存，也可以通过命令手动创建AOF文件。开启AOF持久化的命令如下：
redis-cli config set appendonly yes 开启持久化之后，可以使用以下命令进行手动创建快照或者切换持久化策略：
1. 手动创建快照
redis-cli bgsave 2. 切换持久化策略
redis-cli config set appendonly no redis-cli config set save "" #设置为yes appendonly yes #存储的文件 appendfilename "appendonly.aof" 以上命令可以关闭持久化，也可以通过修改参数来切换持久化策略。
Redis的AOF(Aappend-only file)持久化方式可以实现对数据的持久化保存，通过将Redis的指令追加到AOF文件中，可以实现对数据的可靠持久化。
Redis提供了多种AOF设置触发机制，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c79a1d781bb0d609a5151903cdb3573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a6d3ac39018723c24a08d65eb36574/" rel="bookmark">
			基于pytorch在VGG9中加入CBAM注意力机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import torch from torch import nn # CBAM注意力机制 自己加的 class CBAMLayer(nn.Module): def __init__(self, channel, reduction=16, spatial_kernel=7): super(CBAMLayer, self).__init__() # channel attention 压缩H,W为1 通道注意力机制 self.max_pool = nn.AdaptiveMaxPool2d(1) self.avg_pool = nn.AdaptiveAvgPool2d(1) # shared MLP self.mlp = nn.Sequential( # Conv2d比Linear方便操作 # nn.Linear(channel, channel // reduction, bias=False) nn.Conv2d(channel, channel // reduction, 1, bias=False), # inplace=True直接替换，节省内存 nn.ReLU(inplace=True), # nn.Linear(channel // reduction, channel,bias=False) nn.Conv2d(channel // reduction, channel, 1, bias=False) ) # spatial attention 空间注意力机制 self.conv = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6a6d3ac39018723c24a08d65eb36574/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5583d94095c692ee618292e797d42d/" rel="bookmark">
			I.MX8MM系统构建 -- 3.根文件系统制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 根文件系统制作有多种方式如下：
busybox制作buildroot制作yocto制作出厂镜像修改 本次采用修改出厂镜像的方式进行制作。
出厂镜像说明 开发板在资料中提供镜像文件myir-image-full-myd-imx8mm.sdcard,其中包含uboot，dtb，内核，根文件系统。
镜像结构 将镜像导入到ubuntu中，使用fdisk ./myir-image-full-myd-imx8mm.sdcard指令，输入参数p即可查看其分区结构如下： book@100ask:~/Turing_imx8mm/images$ fdisk ./myir-image-full-myd-imx8mm.sdcard Welcome to fdisk (util-linux 2.31.1). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): p Disk ./myir-image-full-myd-imx8mm.sdcard: 1.7 GiB, 1801820160 bytes, 3519180 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x8487319c Device Boot Start End Sectors Size Id Type .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b5583d94095c692ee618292e797d42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df843d8744dd7d47f516ddac7d7fe67/" rel="bookmark">
			ELK中索引生命周期ilm和滚动rollover的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题场景 最近在做日志平台项目，项目中会收集很多机器节点的日志，归集后做分析处理。原先的设计是按日志类型及日期来划分索引，索引命名格式如 ： test-job-log-v1-1-2023-07-01 ， 但是有些类型的日志数据量比较多，可能单个索引主副本的数据会超过100g。考虑到大索引对于后续的维护存在故障恢复时间长的风险，且会造成写入期间机器负载不均衡，因此想用更合适的方式来规划索引，使负载更均衡， 应用索引生命周期ilm和滚动rollover方式，可以更好的限制索引大小，处理起来也比较方便，现将详细的使用过程做汇总说明。
索引生命周期设置 ES的索引生命周期分为hot \ warm \ cold \ delete 四个阶段 ，
HOT为必须的阶段外，其他为非必须阶段，可任意选择配置。因为日志索引只需要满足自动删除功能，所以我们一般只需规划日志索引的HOT、Warm和DELETE三个阶段； HOT阶段 HOT阶段用来写入日志数据和查询日志数据 WARM阶段 WARM阶段用来存储相对的历史日志数据和查询日志数据，可使用手动迁移，或者自动迁移的方式,可缩减副本数 ，强制合并减少segments数量，设为只读索引 COLD阶段 COLD阶段和warm阶段的操作有些类似， 主要适用与查询进一步减少的索引 DELETE阶段 DELETE阶段是用来对日志数据的删除，日志数据满足DELETE阶段的删除条件（如：超过180天的索引数据），即可配置相关策略，手动或者脚本自动进行删除索引数据 rollover策略定义 ES的rollover策略和java应用中日志的rollover方式有一定相似性，java日志中对于日志文件到一定大小后，就进行日志文件的归档，打包压缩，然后将日志输出到新文件中，当前的日志文件名一般保持不变，归档的日志会限制保留的数量 ，比如只保留7个或保留7天的。
由前面kibana中索引HotPhase 的Rollover设置中可以看到可以定义
最大主分片大小 、最大时长、最大文档数量或索引最大大小等来配置rollover方式。
索引模板设置 索引模板设置，其实可以理解对一定格式的索命名称，进行模式上的预定义，可以预先设定一些字段的属性、索引的副本数量、定义一些脚本处理，当然也可以关联索引生命周期策略，便于对索引进行生命周期管理。
测试期间可以修改ilm的检查时间间隔， 默认是10分钟
Logstash 中使用 logstash 中的output 模块中可以配置elasticsearch 作为输出， es的配置中可以直接输出到指定的索引中，也可以用动态索引的方式
原先用按日期来划分缩影的方式如下：
后尝试ilm+rollover方式配置如下：
此时启动logstash 会有rollover alias调用
ES 中索引效果 以上就是本次在ELK中应用索引生命周期ilm和滚动rollover的过程和效果
参考文档 Logstash：为 Logstash 日志启动索引生命周期管理_ilm_rollover_alias
Rollover API | Elasticsearch Guide [7.17] | Elastic
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d72d505661a774c6c96cfe04b3a32b35/" rel="bookmark">
			Ubuntu 22.04自动挂起后无法唤醒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可实现在键盘、鼠标断电后的唤醒 2023.7.17ps:最好别合上笔记本屏幕
但是为了以防万一，建议在设置中将挂起有关选项全部关闭
一、安装（这个不知道干嘛的） sudo apt-get install pm-utils 二、检测是否安装了laptop-mode-tools dpkg -l|grep laptop-mode-tools 若没有输出，则进行第三步；若有输出，则跳过
三、安装 sudo apt-get install laptop-mode-tools 以下代码检验是否安装成功
dpkg -l|grep laptop-mode-tools 出现 ii laptop-mode-tools 1.74-1.1 all Tools for Power Savings based on battery/AC status 四、判断并修改 1. 判断Laptop是否启用了laptop_mode，如果显示结果为0，则表示未启动，如果为非0的数字则表示启动了
cat /proc/sys/vm/laptop_mode 2. 启动laptop_mode并可查看结果
sudo laptop_mode start 3. 修改配置文件，解决鼠标键盘自动休眠导致的失灵问题
sudo gedit /etc/laptop-mode/conf.d/runtime-pm.conf 为了解决鼠标键盘自动休眠导致的失灵问题,需要执行命令:sudo gedit /etc/laptop-mode/conf.d/runtime-pm.conf
把AUTOSUSPEND_RUNTIME_DEVID_BLACKLIST=""
改为AUTOSUSPEND_DEVID_BLACKLIST="usbhid usb-storage"
————————————————
版权声明：本文为CSDN博主「zaf赵」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zaf0516/article/details/103105916
4. 配置laptop_mode
sudo gedit /etc/laptop-mode/laptop-mode.conf 第83-100行：将以下置1
# # Enable laptop mode power saving, when on battery power.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d72d505661a774c6c96cfe04b3a32b35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64f53e5d170ec126e27b62c0a2b8178/" rel="bookmark">
			最新DM8搭建dblink连接Oracle 11G_(19c的OCI)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关说明 本方案直接使用19c的OCI连接达梦数据库，即便Oracle版本是11g也没有关系，因为oci版本是向下兼容的。如使用11g的OCI而达梦的版本是1.3.12及以后版本大概率会搭建不起来。本方案操作之前请先确认oracle到dm的网络端口畅通并且orale的监听已经配置完成。 一、下载Oracle客户端驱动 以下的下载包已经放到资料包中，也可在官网直接下载
下载地址：Oracle Instant Client Downloads
目前Oracle Instant Client驱动包已经支持ARM架构平台环境。
选择对应平台的Basic和ODBC驱动包：
二、解压安装Oracle Instant Client包 ## 上传安装包到服务器，然后创建目录并解压 [root@localhost ~]# mkdir -p /opt/dm_dblink [root@localhost dm_dblink]# cd opt/dm_dblink [root@localhost dm_dblink]# unzip instantclient-basic-linux.x64-19.19.0.0.0dbru.zip [root@localhost dm_dblink]# unzip instantclient-sdk-linux.x64-19.19.0.0.0dbru.zip [root@localhost dm_dblink]# unzip instantclient-sqlplus-linux.x64-19.19.0.0.0dbru.zip #解压以后会在同级目录下生成instantclient_19_19目录 [root@localhost oracle]# cd instantclient_19_19/ [root@localhost instantclient_19_19]# pwd /opt/oracle/instantclient_19_19 ## 所有的驱动包都在/opt/oracle/instantclient_19_13目录下 ## ls -l 如下图注意看下有没有下载的版本关系 ## 这里注意下libclntsh.so文件有没有软连接 ## 因为用的是19c的oci连11g的库，所以这个软连接特别重要 三、确认libclntsh.so的对应关系 #ldd查看依赖库的关系,缺一个都不行哦 [root@localhost instantclient_19_19]# ldd libclntsh.so 缺少libnnz19.so [root@localhost instantclient_19_19]# ldd libclntsh.so linux-vdso.so.1 (0x00007ffe047a2000) libnnz19.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64f53e5d170ec126e27b62c0a2b8178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06db4557a34c50355a37ab4e51355881/" rel="bookmark">
			多线程问题合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.volatile如何和cas结合保证原子性
在多线程编程中，要保证某个操作的原子性（Atomicity），即在并发执行的情况下，这个操作要么完全执行成功，要么完全不执行。volatile关键字可以用于确保变量的可见性，而CAS（Compare and Swap）是一种原子操作，可以实现对变量的原子更新。
要结合volatile和CAS来保证操作的原子性，可以使用以下步骤：
将需要保证原子性的变量声明为volatile类型。这样可以确保每次访问该变量时，都会从主内存中读取最新的值，而不是使用线程的本地缓存。
使用CAS操作来进行原子更新。CAS操作由三个参数组成：需要更新的变量、期望的值和新值。它会先比较变量的当前值是否与期望的值相等，如果相等，则将变量的值更新为新值；如果不相等，则不进行更新。CAS操作是原子的，因此可以确保只有一个线程能够成功更新变量的值。
下面是一个简单的示例代码，演示了如何使用volatile和CAS结合来保证操作的原子性：
import java.util.concurrent.atomic.AtomicInteger; public class AtomicExample { private volatile int counter = 0; private AtomicInteger atomicCounter = new AtomicInteger(0); public void increment() { // 使用volatile变量进行操作 counter++; } public void atomicIncrement() { // 使用CAS操作进行原子更新 atomicCounter.getAndIncrement(); } } 在上面的代码中，increment()方法使用volatile变量counter来进行操作，但是由于不是原子操作，可能会存在线程安全问题。而atomicIncrement()方法使用AtomicInteger类提供的原子操作来保证更新的原子性。
需要注意的是，volatile关键字只能保证变量的可见性，无法保证复合操作的原子性。如果需要进行多个操作的原子执行，可以使用Atomic类提供的原子操作，或者使用锁机制（如synchronized关键字或Lock接口）来保证原子性。
2.新建 T1、T2、T3 三个线程，如何使用join方法保证它们按顺序执行
public class ThreadOrderExample { public static void main(String[] args) { Thread t1 = new Thread(new MyRunnable("T1")); Thread t2 = new Thread(new MyRunnable("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06db4557a34c50355a37ab4e51355881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e4802d77fe6ef302678801a8889c24/" rel="bookmark">
			【网络安全】常见的网路安全设备及功能作用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的网路安全设备及功能作用总结 WAF：Web应用防火墙 —应用层的攻击防护IDS：入侵检测系统 —IPS：入侵防御系统SOC：安全运营中心SIEM：信息安全事件管理Vulnerability Scanner：漏洞扫描器UTM：统一威胁管理抗DDOS产品FireWall：防火墙—上网行为管理软件，主机安全VPN：虚拟专用网络DBAudit：数据库审计 一、 WAF 应用防火墙 范围：应用层防护软件
作用：
通过特征提取和分块检索技术进行模式匹配来达到过滤，分析，校验网络请求包的目的，在保证正常网络应用功能的同时，隔绝或者阻断无效或者非法的攻击请求
可防：（源自应用程序的安全漏洞）
SQL注入漏洞，跨站脚本XSS，文件包含和安全配置错误等漏洞
特点：
区别与传统防火墙，可以防护特定的应用程序，传统防火墙只能在服务器之间作用
缺点：
1） 特定的防护手段可以被绕过或者无效化，必须同攻击手段一起升级进步，否则将失去效用。
2） 需要和入侵检测系统等安全设备联合使用，且防护程度和网络的性能成反相关。
二、IDS 入侵检测系统： 范围：网络层防护软件
作用：（识别攻击行为并且报警）
积极主动的防护措施，按照一定的安全策略，通过软件，硬件对网络，系统的运行进行实时的监控，尽可能地发现网络攻击行为，积极主动的处理攻击，保证网络资源的机密性，完整性和可用性。
特点：
1） 是一个积极主动的监听设备。
2） 无需有流量经过，可以实时镜像流量过去给它分析监控就好。
3） 不影响网络的性能。
4） 部署位置尽可能靠近攻击源或者受保护资源（服务器区域交换机，互联网接入路由后第一个交换机，重点保护源交换机）
缺点：
1） 误报率高
2） 没有主动防御能力，仅仅是监控或者少量的反制能力
3） 不能解析加密的数据流
三、IPS 入侵防御系统（入侵检测+入侵防御） 范围：
作用：（实时监控网络行为，中断或者调整隔离网络非法行为，比IDS具有防御能力）
是计算机网络安全设施，是对防病毒软件和防火墙的补充。入侵预防系统是一部能够监视网络或网络设备的网络数据传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络数据传输行为。
必要性：
传统防火墙作用在2-4层，对4层以上的防护作用很小（4层以上需要拆数据包，而拆数据包会影响速率），病毒软件工作在5-7层，这样中间4-5层属于空挡，所以IPS是作为病毒软件和防火墙的补充，作用在4-5层
特点：
比IDS不仅可以防护还具有了反制，组织攻击的能力，防攻兼备
缺点：
IPS的防护方式一般以阻断受保护源和外界的联系为主，这样带来的一个弊端就是，网络资源被保护了，但是同时该网络资源的对外提供的服务也被阻断了或者削弱了，这就导致了一种敌我两伤的局面，而有些服务一旦停止，对运营者来说将是一笔不小的损失。
四、SOC 安全运营中心 作用：（不是一个防护产品，而是一个防护系统）
SOC，全称是Security Operations Center，是一个以IT资产为基础，以业务信息系统为核心，以客户体验为指引，从监控、审计、风险和运维四个维度建立起来的一套可度量的统一业务支撑平台，使得各种用户能够对业务信息系统进行可用性与性能的监控、配置与事件的分析审计预警、风险与态势的度量与评估、安全运维流程的标准化、例行化和常态化，最终实现业务信息系统的持续安全运营
特点：
既有产品又有服务，需要运营，流程以及人工的有机结合，是一个综合的技术支持平台。他将安全看成一个动态的过程（敌人的攻击手段在变，漏洞在更新，我方的防火手段，业务产品，人员调度等都在变动，没有一个系统可以一劳永逸的抵御所有攻击，只有“魔”，“道”维持一个相对的平衡才是安全）态势感知的根基就是安全运营中心
态势感知：
态势感知是一种基于环境的、动态、整体地洞悉安全风险的能力，是以安全大数据为基础，从全局视角提升对安全威胁的发现识别、理解分析、响应处置能力的一种方式，最终是为了决策与行动，是安全能力的落地。
态势感知特点：（大数据成为态势感知的主要驱动力，足够的数据分析）
检测：提供网络安全持续监控能力，及时发现各种攻击威胁与异常，特别是针对性攻击。
分析、响应：建立威胁可视化及分析能力，对威胁的影响范围、攻击路径、目的、手段进行快速研判，目的是有效的安全决策和响应。
预测、预防：建立风险通报和威胁预警机制，全面掌握攻击者目的、技战术、攻击工具等信息。
防御：利用掌握的攻击者相关目的、技战术、攻击工具等情报，完善防御体系。
五、SIEM 信息安全和事件管理 SIEM=SEM+SIM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2e4802d77fe6ef302678801a8889c24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b0f2e3b03eee64d0f9678ca4478fe0/" rel="bookmark">
			python中应用requests库模拟postman请求携带token，使用get和post方法请求头携带token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 实际开发中，Python程序中需要调用后台接口，充当前端，后端规定请求头需要携带token
封装的get和post类: class RequestMethodCarryJson: """ 定义请求类型 以json方式传递参数 """ def __init__(self): """初始化参数""" self.data = {} self.files = {} def get(self, url, data, headers): """ 定义get方法请求 :return: """ try: return requests.get(url=url, data=data, headers=headers, timeout=60) except TimeoutError: return print('%s get request timeout!' % url) def getCarryToken(self, url, data, headers): """ 定义get方法请求 :return: """ try: return requests.get(url=url, json=data, headers=headers, timeout=60) except TimeoutError: return print('%s get request timeout!' % url) def post(self, url, data, headers): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b0f2e3b03eee64d0f9678ca4478fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d95cec80e43872622bcecf8fdd3a5df/" rel="bookmark">
			【计算机毕业设计】实验室预约管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java SpringBoot实验室预约管理系统，后端基于SpringBoot框架进行开发，前端页面效果通过使用Vue进行编码实现，主要实现了学生跟管理员角色，实现了任务领取管理、实验室预约管理等功能。
项目运行
环境配置：
Jdk1.8 + Tomcat8.5 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
JAVA + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
技术栈
后端：JAVA mybatis前端：vue+css+javascript+jQuery+easyUI+highcharts 使用说明
使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；使用IDEA/Eclipse/MyEclipse导入项目，修改配置，运行项目；
3.管理员账号：abo 密码：abo
4.开发环境为Eclipse/idea，数据库为mysql 使用java语言开发。
5.运行SpringbootSchemaApplication.java 即可打开首页
6.数据库连接src\main\resources\application.yml中修改
7.maven包版本apache-maven-3.3.9.
8.后台路径地址：localhost:8080/项目名称/admin
# Tomcat server: tomcat: uri-encoding: UTF-8 port: 8080 servlet: context-path: /springboot3wku7 spring: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d95cec80e43872622bcecf8fdd3a5df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8628e67ace7065b89cfef763324d899/" rel="bookmark">
			报错：‘module‘ is not defined.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错：
'module' is not defined.
解决方法：
.eslintrc.cjs 文件
env: { browser: true, es2021: true, node: true, // 加上这行 }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bcdd2493b3af188006e4f8349780a0/" rel="bookmark">
			竞赛管理系统实现自动化测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、为竞赛管理系统设计测试用例
二、根据测试用例进行测试
登录页面测试
功能测试
界面测试 用户注册页面 功能测试
界面测试
竞赛信息列表页面测试 界面测试 添加竞赛信息页面测试
功能测试
界面测试 修改竞赛信息页面测试 功能测试
一、为竞赛管理系统设计测试用例 二、根据测试用例进行测试 定义驱动为全局变量，在测试之前，需要获取到驱动。
public static EdgeDriver getDriver(){ if(driver == null){ synchronized (PrepareTest.class){ if(driver == null){ EdgeOptions options = new EdgeOptions(); options.addArguments("--remote-allow-origins=*"); driver = new EdgeDriver(options); } } } return driver; } 登录页面测试 定义start()和close()方法确保测试之前和测试之后都执行一次这两个方法。
@BeforeAll public static void start(){ driver = getDriver(); driver.get("http://43.143.208.132:8086/login.html"); //使用隐式等待渲染页面完成 driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(3)); } @AfterAll public static void close(){ driver.quit(); } 功能测试 对正确的用户名和密码进行接口测试： /** * 测试正确登录 */ @ParameterizedTest @CsvSource(value = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34bcdd2493b3af188006e4f8349780a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6214f7804df136b0f22e5b47f582d30/" rel="bookmark">
			解决Python明明已经下载好库，为什么导入还是报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很有可能是库下载到的位置和你现在这个项目的位置使用的环境不是同一个
解决：
1.进入setting
2.找到Python Interpreter 然后点击右上方蓝色字体Add Interpreter
3.点击第一个Add
4.这里你会发现Location的路径和你Base的不一致，所以我们需要√选下面的inherit把Python310里面的库继承过来，就可以了
或者你可以把你需要的库复制到site目录下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc13dc627545e667dcb4a0e7497d7add/" rel="bookmark">
			解决Vmware虚拟机和windows互相拖拽文件以及复制粘贴问题（亲测有用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu运行命令
sudo apt-get autoremove open-vm-tools sudo apt-get install open-vm-tools sudo apt-get install open-vm-tools-desktop 安装完VMware Tools后，不要点重新启动客户机，需要先关闭客户机，然后再启动客户机就可以实现windows和虚拟机互相复制粘贴
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03cf4381ad51e178bae920fc2a645cd6/" rel="bookmark">
			牛客小白月赛75 方豆子（递归模拟）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿宁最近对吃豆子感兴趣，阿宁想要用程序输出一下，但是图形化对于阿宁来说太难。因此他决定用字符，并且是方形的模样。
给一个正整数nnn，输出nnn级好豆子。
一级好豆子： ****** ****** ****** ***... ***... ***... 一级坏豆子： ...... ...... ...... ...*** ...*** ...*** 二级好豆子： 一级坏豆子 一级坏豆子 一级坏豆子 一级好豆子 二级坏豆子： 一级好豆子 一级好豆子 一级好豆子 一级坏豆子 ... x级好豆子： x-1级坏豆子 x-1级坏豆子 x-1级坏豆子 x-1级好豆子 x级坏豆子： x-1级好豆子 x-1级好豆子 x-1级好豆子 x-1级坏豆子 ... 输入描述: 输入一个整数n。 1≤n≤10 输出描述: 输出3×2n行，每行长度为3×2n的字符串。 示例1
输入 1 输出 ****** ****** ****** ***... ***... ***... 示例2
输入 2 输出 ............ ............ ............ ...***...*** ...***...*** ...***...*** ......****** ......****** ......****** ...******... ...******... ...******... 感觉是一个很好的递归模拟
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03cf4381ad51e178bae920fc2a645cd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fcbf99ce0d265e329ea424d15bd97e9/" rel="bookmark">
			Stm32定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TIM简介 TIM（Timer）定时器
定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断
16位计数器（每来一个时钟，计数器加1）、预分频器（对计数器的时钟进行分频）、自动重装寄存器的时基单元（设定多少个时钟申请中断），在72MHz计数时钟下可以实现最大59.65s（1/（72/65536/65536））的定时，还可用级联（多个定时器串联）增加定时时长。
不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能
根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型
STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4
预分频寄存器：对时钟进行预分频，写0时不分频，就是1分频（输出频率=输入频率），写1时就是2分频（输出=输入/2），依次类推。
计数器寄存器：计数时钟每来一个上升沿，计数+1的向上计数模式，到达65535，产生中断后重回0。
自动重装寄存器：存的是写入的计数目标，当计数值等于设定值时就产生中断信号，清零计数器寄存器 。UI通向NVIC，U会触发其他电路的工作。
通用定时器这里包含了基本定时器的功能，但基本定时器只有向上计数的模式，而通用和高级定时器还支持向下（从重装值开始向下自减，减到0回到重装值同时申请中断）和中央对齐的模式（从0开始，先向上自增，计到重装值，申请中断，然后向下自减，减到0再申请中断）。
在基本时钟上方的部分为内外时钟源和主从触发模式结构：ETR为外部时钟，对应PAO口。TRGI主要用作触发输入来使用，也可以当做外部时钟使用，这一路叫做外部时钟模式1。TRGO可以接回到ITR部分的可以实现定时器的级联，连接方式见手册14.4.3,
在基本定时器右下部分是输出比较电路1-4，可用于输出PWM波形，驱动电机。左边的是输入捕获电路，用于测输入方波的频率、中间的是捕获/比较寄存器。
运行控制是控制启动停止、向上或向下计数等功能，中断输出控制只允许一个中断。使用定时器中断时就需要配置这些定时器。
CK_PSC:预分频的输入时钟，选内部时钟一般是72（由时钟决定）。
CK_EN:计数器使能，决定工作
CK_CNT:前半段为预分频的时钟，系数变2，时钟也变一半。
计数寄存器：自增到FC从0开始，重装值就是FC同时UEV产生更新事件或者中断。
上述以下的的就是为了改写分频值后不会立刻发生改变，而是计完这个周期才开始变。0的时候就输出CNT后半部分的时钟。（通用定时器电路图中有阴影的就是带有这种功能）
计数器计数频率：CK_CNT = CK_PSC / (PSC + 1)
计数器溢出频率：CK_CNT_OV = CK_CNT / (ARR + 1)
= CK_PSC / (PSC + 1) / (ARR + 1)
以下是使用定时器进行1s的时间更新一次中断并显示在OLED屏上
//定时器代码C #include "stm32f10x.h" // Device header extern uint16_t Num; void Timer_Init(void) { RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);//选择TIM2定时器 TIM_InternalClockConfig(TIM2);//由内部时钟驱动 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; //预分频系数1 TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;//向上计数模式 TIM_TimeBaseInitStructure.TIM_Prescaler=7200-1;//在72M进行7200分频	=10K的计数频率,产生一次更新事件 TIM_TimeBaseInitStructure.TIM_Period=10000-1;//10K的频率下，计算10000个数得到定时1S的时间，-1因为公式里面PSC+1了，而这里配置的就是PSC TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;//高级定时器的中的重复计数器的 TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);//时机单元初始化函数 TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);//使能中断 TIM_Cmd(TIM2,ENABLE); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fcbf99ce0d265e329ea424d15bd97e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9869a9dee53f7600df90d65afaaad3da/" rel="bookmark">
			第十二周：机器学习周报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
1 What is GNN？
2 Why need GNN？
3 Spatial-based GNN
3.1 模型一：NN4G（Neural Network for Graph）
3.2 模型二：DCNN（Diffusion-Convolution Neural Network）
3.3 模型三：DGC（Diffusion Graph Convolution）
3.4 模型四：MoNET（Mixture Model Networks）
3.5 模型五：GAT（Graph Attention Networks）
4 Spectral-based GNN
4.1 图信号的傅里叶变换
4.2 拉普拉斯变换
4.3 频率
4.4 能量差
4.5 分析与合成
4.6 Filter
4.7 最终形态
4.7 方法的弊端 5 GNN模型代码分析
总结
摘要 图神经网络（GNN）与其他模型不同的是它的输入和输出都是图，GNN可以通过卷积将图的结构和每个节点和边的特征转化为一般的神经网络的输入，GNN中的卷积有两种方法，一种是Spatial-based（基于空间的），另一种是Spectral-based（基于谱域的）。本周学习GNN的两种卷积方式，Spatial-based GNN方法采用类似CNN的卷积得到每个隐藏层的值，再将所有层的值集合成为整个graph的输出，Spectral-based GNN方法通过傅里叶变换与逆傅里叶变换得到图神经网络的卷积输出。
Abstract The difference between Graph Neural Network(GNN) and other models is that its input and output are graphs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9869a9dee53f7600df90d65afaaad3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c7b2cde806f1312a966f70d5d6d978/" rel="bookmark">
			Stm32 旋转编码器简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向
类型：机械触点式/霍尔传感器式/光栅式
第一个是运动了对射红外线的功能，通过旋转时有透过遮挡透过等感应再输出相应的波形。第二个是通过金属触点，相当于正旋转时先接触B，弹回来再接触A，输出相应的波形，但相反A输出的波形超前B波形90°，根据这个超前判断旋转方向。
//编码器 #include "stm32f10x.h" // Device header int16_t Encoder_Count; void Encoder_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);//中断引脚选择 GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);//中断引脚选择 EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(&amp;EXTI_InitStructure); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c7b2cde806f1312a966f70d5d6d978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5a383e65e6bf00cdd5f7bac481444c/" rel="bookmark">
			stm32配置介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C盘工程stm32工程模板的start文件是启动配置。Stm32f10x.h相当于51单片机的头文件一样，描述有哪些寄存器和它对应的地址，两个system文件是配置时钟，两个cm3是内核的寄存器描述。在Keil5新建组添加文件，但只能选择一个启动文件（符合自已单片机类型的），下图就是对应型号，此单片机是选择后缀为md.s的
缩写
释义
Flash容量
型号
LD_VL
小容量产品超值系列
16~32K
STM32F100
MD_VL
中容量产品超值系列
64~128K
STM32F100
HD_VL
大容量产品超值系列
256~512K
STM32F100
LD
小容量产品
16~32K
STM32F101/102/103
MD
中容量产品
64~128K
STM32F101/102/103
HD
大容量产品
256~512K
STM32F101/102/103
XL
加大容量产品
大于512K
STM32F101/102/103
CL
互联型产品
-
STM32F105/107
然后后面所有的.c和.h都添加进来。要让Keil5找到路径点击魔术棒按钮-C/C++-include path栏-把start的文件路径添加进来，此后添加了文件的都要这样添加路径让Keil5找到路径。C盘的User文件通常是保存C语言的main函数。调试方法一般根据设备，此单片机用的是stlink，在Keil5魔术棒-Debug-user选择相应的调试器，在旁边setting-Flash Download勾选上Rest and Run方便下载程序后立马复位执行。C盘中Library存放的是库函数，通过库函数进行调用，库函数已经封装好所有的调用寄存器的所有函数。Uer文件里面的.c和.h，在conf.h的找到8296行开始的三行语句放到魔术棒-C/C++-Define栏，这样调用库函数的功能都全部完成。
备注：所学的是江科大的视频，只是我的学习笔记，如有侵权请联系本人删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb352a567a6a20af9c358bacd79cf764/" rel="bookmark">
			RuntimeError: radix_sort: failed on 1st step: cudaErrorInvalidDevice: invalid device ordinal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：错误代码为"cudaErrorInvalidDevice"，表示设备顺序无效。
原因：这可能是由于设备驱动程序或CUDA版本不兼容导致的。可以尝试更新CUDA驱动程序或安装支持的CUDA版本的PyTorch版本。
两张方案解决：
1.这是torch1.8.x的bug，需要将pytorch版本升为1.9.0就可以解决了
2.训练的时候指定显卡进行训练，在训练代码中添加代码
os.environ['CUDA_VISIBLE_DEVICES'] = '1'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d2f8027cda625aaa2909f54559ec6a/" rel="bookmark">
			内网渗透ICMP隧道搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内网渗透ICMP隧道搭建 192.168.0.x模拟外网机器，1.1.1.x模拟内网机器
Linux（1.1.1.111/192.168.0.138）为WEB服务器，模拟getshell了WEB服务器的情况，通过该被控制机器将内网Windows机器（1.1.1.99）的3389远程端口映射到外网VPS（192.168.0.130）的2320端口上，黑客机器通过RDP连接192.168.0.130:2320实现远控内网Windows机器，在内网机器存在ICMP协议出网情况下即能ping通外网机器，可以搭建ICMP隧道
环境检查 在搭建隧道前需要确认被攻击的内网机器可以被远程连接，以下是需要检查的一些操作
开启3389端口
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 关闭3389端口
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f 查看注册表不是0xd3d说明3389端口被修改过
reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber 关闭防护墙
NetSh Advfirewall set allprofiles state off netsh firewall set opmode mode=disable IP策略和防火墙的阻拦禁用服务
net stop sharedaccess net stop policyagent 出现身份验证错误
Win+R =&gt; regedit
找到路径：计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System
在System文件夹内创建文件夹项：\CredSSP\Parameters
在Parameters文件夹内，新建 DWORD（32）位值（D），文件名为 AllowEncryptionOracle，值为2
之后重新连接
使用普通用户提示需要授权
普通用户3389连接不上
需要有权限的账号连接，使用管理员的账号
在成功远程连接后继续进行隧道搭建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d2f8027cda625aaa2909f54559ec6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6477f097010d2d23d7c91a07a520b59/" rel="bookmark">
			浏览器中Cookie的全面介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在Web前端开发时，我们经常会遇到一些浏览器存储相关的工具，例如Cookie。Cookie的英文本意是曲奇，但是在Web中，它被用作浏览器中存储的数据。Cookie都是name=value的结构，name和value都为字符串。
使用流程 在首次访问网站时，浏览器发送请求中并未携带Cookie。浏览器看到请求中未携带Cookie，在HTTP的响应头中加入Set-Cookie。浏览器收到Set-Cookie后，会将Cookie保存下来下次再访问该网站时，HTTP请求头就会携带Cookie。 下图分别为设置Cookie和携带Cookie的示例。
设置Cookie
携带Cookie
配置属性 在上面Set-Cookie的图中，我们可以看到，设置Cookie时，除了最前面的name和value之外，还配置了其他属性。实际上Cookie还有更多属性，可以查看浏览器的Application-Storage，获取当前网站的Cookie。
这里简单描述一下每个属性的含义：
属性含义NameCookie的名称Value对应名称的值DomainCookie的域名PathCookie生效的路径Expires过期时间，过了这个时间后Cookie失效Max-age生效时间，表示Cookie在多长时间后失效SizeCookie的长度，为name和value的长度和HttpOnly防止通过JavaScript访问CookieSecure只在HTTPS协议的情况下才会将Cookie传到后端SameSite是否允许跨站请求时发送CookiePartitioned第三方Cookie分区Priority优先级 下面我们对其中一些属性和作用进行讨论。
生命周期 Cookie是有生命周期的，在设置Cookie值时，可以同时设置有效期。当超过了这个有效期之后，Cookie便会失效，前端请求时，不会携带过期的Cookie。
Cookie的有效期有三种类型：
Session 这里的Session并不是存储在服务端的Session，而是指浏览器会话。如果Cookie的有效期为Session，一般关闭会话时，Cookie便会失效；而一些浏览器重启时，也会将会话恢复，此时Cookie并不会失效。
Expires Expires表示过期时间，是一个确定的日期时间。例如Expires=Wed, 21 Oct 2015 07:28:00 GMT。当浏览器端本地的当前时间超过这个时间时，Cookie便会失效。
Max-age Max-age表示Cookie的存活时间，以秒作为单位。例如Max-age=3000。当获取到该Cookie后开始倒计时，3000秒之后便失效。
注意：上述的生命周期都是服务端指定的。如果设置了Expires，则是把服务器时间和浏览器本地时间相比较，如果时间不同步，配置就会出现问题。而Max-age设置的是秒数，始终是浏览器本地时间自己相比较，不会出现时间不同步的问题。
作用范围 作用范围主要由Domain和Path两个属性来控制。
Domain Domain用来设置Cookie作用的域名，即Cookie在哪个网站生效。默认情况下，生效的域名为当前访问的域名。例如我们在jzplp.com设置的Cookie，就只能限制该网站内使用。
多级域名 如果访问的网站有多级域名，则Cookie默认仅在访问的多级域名内生效。如果希望在更大范围内生效，可以指定域名。
例如我们在a.jzplp.com下设置的Cookie，就只在这个域名下生效。但是如果我们在设置cookie时同时设置了domain=jzplp.com，则该Cookie可以在jzplp.com下的任何域名内生效。比如：
jzplp.coma.jzplp.comb.jzplp.comc.d.jzplp.com Path 有时候，我们希望Cookie仅仅在部分路径下生效，就可以使用Path进行限制。这里的路径就是网站的路由。默认的path=/，即在所有路径下生效。
如果设置了path=/abc，则只在/abc路径下生效。比如：
jzplp.com 不生效jzplp.com/abc 生效jzplp.com/abc/def 生效jzplp.com/qaz 不生效jzplp.com/qaz/abc 不生效 个数和大小限制 限制规则 不同的浏览器允许的Cookie大小并不相同，通常的限制为：
个数限制: 20~50总大小限制: 4KB左右 网络上也有人整理各种浏览器详细的限制。
IE6.0IE7.0/8.0OperaFirefoxSafariChromecookie个数每个域为20个每个域为50个每个域为30个每个域为50个没有个数限制每个域为53个cookie大小4095个字节4095个字节4096个字节4097个字节4097个字节4097个字节 来源：Cookie个数限制及大小
一个Cookie的大小可以在浏览器中查看Size属性得知，这个大小是key和value的和。
Priority优先级 当Cookie的数量超过限制时，路蓝旗会清除一部分Cookie。清除哪些合适呢？Priority属性用来定义Cookie的优先级，低优先级的Cookie会优先被清除。
Priority属性有三种： Low, Medium, High
HttpOnly 通常的Cookie在客户端（一般指浏览器）是可以通过脚本代码（一般指js）访问的。方式可见JavaScript中操作Cookie。
如果设置了HttpOnly属性，则该Cookie在浏览器中无法通过js代码访问，经过我测试也无法写入。这样可以防止窃取Cookie信息，一般用来防止XSS攻击。
跨站与Samesite设置 Samesite是Cookie的跨站属性，也可以看做是“更高级”的作用范围设置。部分内容参考了几篇文章：SameSite Cookie，防止CSRF攻击， Cookie 的 SameSite 属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6477f097010d2d23d7c91a07a520b59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7c45db92a720651e0f1fb84803da03/" rel="bookmark">
			Ant Design Vue组件，a-select标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a-select标签是组件里的选择框，具体使用可以查看官网，这里记录一下在使用中遇到的问题。
最近在做项目的时候有一个需求在 a-modal 标签中加入 a-select 标签，a-modal 是模态对话框，意思就是在模态对话框里面添加选择框，点击选择框的时候，选择项会随页面滚动。
刚点开的时候：
之后滚动页面：
只有鼠标悬浮在选择项上滚动才会出现这种情况，悬浮在其他地方是不会出现的。
之后我查看了页面的结构，出现这种情况是因为 选择项是默认渲染到 body 上的。
a-select节点的位置：
选项菜单的位置：
所以只要把选项也放到 id='app' 这个标签里就可以避免这个问题。
组件提供了一个属性：
在标签里添加 :getPopupContainer="triggerNode =&gt; triggerNode.parentNode" 这个属性，改变页面结构。
而日期选择框也有这个问题：
antdv组件在三版本时是用 getPopupContainer ，而在三版本之前是使用 getCalendarContainer 。
&lt;a-button style="margin-top: 50vh" type="primary" @click="showModal"&gt;Open Modal&lt;/a-button&gt; &lt;a-modal :visible="isShowModal" @cancel="detailsTemplateModelClose" :closable="false" :keyboard="false":maskClosable="false" :confirm-loading="spinning":cancel-button-props="{ props: { disabled: spinning } }" cancelText="关闭" title="Modal" @ok="handleOk"&gt; &lt;a-select placeholder="请选择" :getPopupContainer="triggerNode =&gt; triggerNode.parentNode" :options="selectData"/&gt; &lt;br&gt; &lt;a-date-picker :value="value" :getCalendarContainer="triggerNode =&gt; triggerNode.parentNode" /&gt; &lt;/a-modal&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e3c1278daa0cf6471e23b1fcc85f9e/" rel="bookmark">
			NUC972开发板学习过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、搭建linux环境的过程，设置交叉编译器的环境变量过程中会出现各种问题；
解决方法：
第一步、一定要Ubuntu系统换源，换源后sudo apt-get update；
第二步、sudo apt-get install lib32stdc++6
第三步、使用 vim编辑器编辑 bashrc 文件。 #vim /root/.bashrc 编辑/root/.bashrc 文件，在最后一行添加： export PATH=$PATH:/usr/local/arm_linux_4.8/bin （注意，要把arm_linux_4.8的放置到默认/usr/local/路径底下） #source /root/.bashrc #arm-linux-gcc -v 显示 gcc version 4.8.4(GCC) 成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f64537c225698294b417a16dbaa6ec01/" rel="bookmark">
			Redis 五大数据类型/结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Redis 五大数据类型/结构操作文档Redis 数据存储格式Redis 数据类型-5 种常用string说明String 常用指令&amp;演示 list双向链表示意图解图list 常用指令&amp;演示list 最佳实践应用场景 setset 常用指令&amp;使用set 指令操作示意图 hashhash 常用指令&amp;使用hash 指令操作示意图 有序集合Zset(sorted set)简介sorted set 常用指令&amp;使用 Redis 五大数据类型/结构 操作文档 官方文档: https://redis.io/commands
中文文档: http://redisdoc.com/
Redis 数据存储格式 一句话: redis 自身是一个Map，其中所有的数据都是采用key : value 的形式存储
key 是字符串，value 是数据，数据支持多种类型/结构
Redis 数据类型-5 种常用 string
hash
list
set
sorted_set
string 说明 String 是Redis 最基本的类型，一个key 对应一个value。String 类型是二进制安全的, Redis 的string 可以包含任何数据。比如jpg 图片或者序列化的对象。String 类型是Redis 基本的数据类型，一个Redis 中字符串value 最多可以是512M String 常用指令&amp;演示 set &lt;key&gt;&lt;value&gt;添加键值对 get &lt;key&gt;查询对应键值 append &lt;key&gt;&lt;value&gt;将给定的&lt;value&gt; 追加到原值的末尾 strlen &lt;key&gt;获得值的长度 setnx &lt;key&gt;&lt;value&gt;只有在key 不存在时设置key 的值 incr &lt;key&gt; 将key 中储存的数字值(字符串)增1， 只能对数字值操作，如果为空，新增值为1 decr &lt;key&gt; 将key 中储存的数字值(字符串)减1 ， 只能对数字值操作，如果为空，新增值为-1 incrby / decrby &lt;key&gt;&lt;步长&gt;将key 中储存的数字值增减。自定义步长 mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f64537c225698294b417a16dbaa6ec01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1696dbade92bed06463140d531017cfb/" rel="bookmark">
			Redis数据操作工具类--Java语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import jakarta.annotation.Resource; import org.springframework.data.redis.core.BoundSetOperations; import org.springframework.data.redis.core.HashOperations; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.ValueOperations; import org.springframework.stereotype.Component; import java.util.*; import java.util.concurrent.TimeUnit; /** * Redis缓存工具类 * * @Author:JERRY * @Date: 2023/7/16 */ @Component public class RedisCacheUtil { @Resource public RedisTemplate redisTemplate; /** * 缓存基本对象 * * @param key 键 * @param value 值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) { redisTemplate.opsForValue().set(key, value); } /** * 缓存基本对象，含有效时间 * * @param key 键 * @param value 值 * @param timeout 超时时间 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Long timeout, TimeUnit timeUnit) { redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1696dbade92bed06463140d531017cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08e90d918db0170c5803653742c97c8/" rel="bookmark">
			CSDN竞赛63期题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 这次竞赛由三道老题目和一道表述不清的题目构成，老题目尝试新的方法去做，慢悠悠的写着也花了不少时间。最后一道虽然表述不清，但是如果仔细斟酌也是可以AC的。由于第一名的书籍之前拿过了，不太感兴趣也就没有执着于AC，当然也没有故意少通过几个用例去控制排名。对C站竞赛的态度基本是：遇见做过的题目尝试用新的方法去求解，遇见有问题的题目尝试去猜测出题人的意图。大多数同学看见最后一道表述不清就直接骗点分交卷了，尝试猜测题意比再打一遍老题目的代码还是更有意义一点的。
题目列表 1.小玉家的电费 题目描述 夏天到了，各家各户的用电量都增加了许多，相应的电费也交的更多了。小玉家今天收到了一份电费通知单。小玉看到上面写：据闽价电[2006]27号规定，月用电量在150千瓦时及以下部分按每千瓦时0.4463元执行，月用电量在151~400千瓦时的部分按每千瓦时0.4663元执行，月用电量在401千瓦时及以上部分按每千瓦时0.5663元执行;小玉想自己验证一下，电费通知单上应交电费的数目到底是否正确呢。请编写一个程序，已知用电总计，根据电价规定，计算出应交的电费应该是多少。
输入描述：
输入一个整数，表示用电总计（单位以千瓦时计），不超过10000。
输出描述：
输出一个数，保留到小数点后1位（单位以元计，保留到小数点后1位）。
输入样例：
267
输出样例：
121.5
分析 考过的签到题，按照规则模拟下就可以了。
代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; int main() { int n; cin&gt;&gt;n; double res = 0; if (n &lt;= 150) res += n * 0.4463; else { res += 150 * 0.4463; if (n &lt;= 400) res += (n - 150) * 0.4663; else { res += 250 * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08e90d918db0170c5803653742c97c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad44b0c2c02bf9176754bc0b30b41cb/" rel="bookmark">
			Arduino单片机串口驱动相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 视频教程链接：https://www.bilibili.com/video/BV1tT411V7G1/
检查串口驱动问题，常用的有3个方法：
方法1：检查单片机串口芯片和USB数据线 有些单片机可能本身的串口芯片已经损坏，所以导致无法识别。有些USB数据线只有供电功能，没有数据传输功能，很多人在淘宝上买到的便宜数据线便是如此，需要先和商家确认具有数据传输功能。如下图中的数据线是没有数据传输功能的。
因此，最好有备用的单片机和数据线做实验对比。 方法2：安装对应的串口驱动程序 Arduino/ESP8266/ESP32等单片机通常都会在开发板上使用不同的串口芯片，比如CH340C、CP2102、FT232等等，它们的价格也不同。不同系列的串口芯片需要安装不同的串口驱动程序，电脑才能识别。
但是一般来讲，针对Windows电脑，在安装Arduino IDE的时候，就会自动安装一系列常用的的串口驱动程序，比如CP2102、FT232、16u2等等，国产电脑一般也会自带CH340驱动程序。特别的串口驱动需要向卖家询问。
在官网下载Arduino IDE时，推荐下载“.exe”格式进行一步步安装，而不是直接下载“.zip”格式压缩包解压后，使用文件夹里面的arduino.exe。
当然个别电脑，确实可能需要安装/更新驱动，下面的百度网盘链接中提供了常用驱动程序以及官网驱动链接，可以按需下载使用。
博客文章链接：https://blog.yyzt.site/167/.html
方法3：禁用驱动程序强制签名 部分Windows电脑在插上开发板后，可能会出现串口无法识别的问题，在检查时，会发现“Windows 无法验证此设备所需的驱动程序的数字签名。某软件或硬件最近有所更改，可能安装了签名错误或损毁的文件，或者安装的文件可能是来路不明的恶意软件。(代码52)”。
根据下面的步骤，来解决这个问题。
第1步：打开电脑设置。 第2步：打开进入设置界面，找到里面的“更新和安全”。 第3步：打开更新和安全，左侧的“恢复”，点击高级启动中的“立即重启”按钮。 第4步：系统自动进入安全操作界面，选择“疑难解答”。 第5步：进入疑难解答，选择“高级选项”。 第6步：进入高级选项，里面有系统修复、启动修复、命令提示符、启动设置等，选择“启动设置”。 第7步：进入启动设置界面，点击“重启”按钮。 第8步：进入启动设置界面，有9个不同的选项，是进入安全模式，按一下键盘上的F7，即数字7，1=F1，2=F2依次类推。 第9步：然后会自动重启电脑，打开电脑的设备管理器，驱动应该就能识别了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ae8b09b81e08dcd1d1f26e269533cc/" rel="bookmark">
			自制Arduino Package离线安装，100%成功！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 视频教程链接：https://www.bilibili.com/video/BV19G4y1t7JM/
1、优点 1、完全离线安装，过程可以不需要联网。2、支持ArduinoIDE 1.x.x和2.x.x版本，支持VSCODE中的Arduino插件。3、支持不同版本共存。比如可以同时安装ESP32 1.0.6、ESP32 2.0.5版本。4、不同于其他人做的离线安装包，这个不会和第三方或官方的package相冲突，也不会删除第三方或官方的package。5、编译和上传测试没有任何问题，没有修改包内的内容，与官方包一样，可放心使用，无毒无污染。 2、支持的电脑系统和Package版本 电脑系统：
**Windows：**仅支持window10或window11的x64(64位)系统，不支持window7或x86(32位)系统！
**MacOS：**由于没有Mac电脑，目前还没有做成一键式离线安装程序，等待后续开发…
**Linux：**看大家的需要，等待后续开发…Package版本： 平台AVRESP32ESP8266官方STM32官方MBED_RP2040第三方RP2040版本1.8.3
1.8.61.0.6
2.0.5
2.0.92.7.4
3.0.2
3.1.22.3.03.1.12.2.2 3、安装方式 第1步：在百度网盘中下载自己需要的ArduinoPackage离线安装包。
博客文章链接：https://blog.yyzt.site/107/.html
或者在淘宝购买远程安装服务，链接：https://item.taobao.com/item.htm?spm=a1z10.1-c.w137644-24413150650.26.51762f68hNqlgu&amp;id=675184592304第2步：安装ArduinoIDE。
如果已经安装ArduinoIDE，并且已经打开过ArduinoIDE的，可以跳过这一步。如果没有安装ArduinoIDE，可参考以下文章进行安装。
Arduino IDE安装教程
注意：安装完成后，需要打开ArduinoIDE，打开以后再关闭ArduinoIDE。本离线安装包支持最新的ArduinoIDE 2.0版本。第3步：运行软件安装包。
下面以安装ESP32 1.0.6 package为示例：
双击或者鼠标右键选择打开该程序。
第4步：将密钥复制后粘贴到密钥框内。
打开“密钥.txt”文件，复制文件中的内容，然后可以选择右键“Paste”粘贴，或者点击“粘贴”按键。
第5步：点击“安装”，再点击“确定”。
第6步：等待一会儿，弹出“安装成功！”提示，再点击“确定”。
弹出“安装成功！”提示则表示该离线安装包已经安装好了，然后可以退出该软件了。
第7步：打开ArduinoIDE，出现“一叶遮天_ESP32_V1.0.6”。
第8步：程序编译和上传验证。
下面用“WiFiScan”这个自带的示例程序进行编译和上传。
选择正确的串口，可以看到已经成功编译上传。
打开串口监视器，选择正确的波特率，可以看到程序已经正常运行，附近的WIFI设备扫描成功。
4、卸载方式 第1步：运行软件安装包。
下面以卸载ESP32 1.0.6 package为示例：
双击或者鼠标右键选择打开该程序。
第2步：点击“卸载”，再点击“确定”。
此操作不需要输入密钥。
第3步：等待一会儿，弹出“卸载成功！”提示，再点击“确定”。
弹出“卸载成功！”提示则表示该离线安装包已经删除了，然后可以退出该软件了。
卸载前和卸载后比较，此操作会真正彻底删除离线安装包所占用的电脑C盘储存空间，如果是使用ArduinoIDE开发板管理器中的删除，则不会删除package文件夹目录下的文件，仍然会占用电脑C盘储存空间。
5、注意事项 1、如果使用的是ArduinoIDE 2.0以下版本，比如1.8.19，在运行该离线安装包后，会在附加开发板管理器网址中自动增加2个json网址，请不要删除，如果删除后，将会识别不到开发板，需要重新安装。
使用的是ArduinoIDE 2.0或以上版本不受影响。2、如果使用的是ArduinoIDE 2.0或以上版本，并且你的电脑上安装了相同平台的不同版本，比如同时安装了ESP32 1.0.6、ESP32 2.0.5版本，在切换不同平台编译程序时可能会报错，需要关闭ArduinoIDE 2.0，再重新打开软件编译即可。
使用的是ArduinoIDE 2.0以下版本没有这种情况。3、请不要随意修改和删除“Arduino15”文件夹下的内容，否则可能会导致无法识别到开发板，需要重新安装。 6、Github官方教程 AVR：https://github.com/arduino/ArduinoCore-avrESP32：https://github.com/espressif/arduino-esp32ESP2866：https://github.com/esp8266/Arduino官方STM32：https://github.com/stm32duino/Arduino_Core_STM32官方MBED_RP2040：https://github.com/arduino/ArduinoCore-mbed第三方RP2040：https://github.com/earlephilhower/arduino-pico/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa09ae7b9fc62d6e3a13650f0df41da/" rel="bookmark">
			使用网络分析工具进行网络流量分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的网络分析工具 Wireshark Wireshark是一款免费的网络协议分析器。它可以捕获和分析网络流量，并提供详细的协议分析和统计信息。Wireshark支持多种协议，包括TCP、UDP、HTTP、DNS等。
tcpdump tcpdump是一个命令行工具，用于捕获和分析网络流量。它可以捕获网络数据包，并提供详细的协议分析和统计信息。tcpdump支持多种协议，包括TCP、UDP、ICMP、DNS等。tshark：tshark是Wireshark的命令行版本。它可以捕获和分析网络流量，并提供详细的协议分析和统计信息。tshark支持多种协议，包括TCP、UDP、HTTP、DNS等。
Fiddler Fiddler是一款免费的Web调试代理工具。它可以捕获和分析Web应用程序的流量，并提供详细的协议分析和统计信息。Fiddler支持HTTP、HTTPS、FTP等协议。
Burp Suite Burp Suite是一款专业的Web应用程序安全测试工具。它可以捕获和分析Web应用程序的流量，并提供详细的协议分析和统计信息。Burp Suite支持多种协议，包括HTTP、HTTPS、WebSocket等。
网络分析工具进行网络流量分析的步骤 安装和配置网络分析工具 首先，需要选择适合自己需求的网络分析工具，并进行安装和配置。常见的网络分析工具包括Wireshark、tcpdump、tshark、Fiddler和Burp Suite等。
安装完成后，需要配置网络分析工具的参数，以确保正确地捕获和分析网络流量。这些参数包括：
捕获网络接口：选择要监测的网络接口，例如无线网卡或有线网卡。
过滤器：根据需要设置过滤器，以便只捕获特定类型的网络流量。例如，可以设置过滤器只捕获HTTP协议或只捕获来自特定IP地址的流量。
协议解析：配置网络分析工具的协议解析功能，以便正确地解析捕获的网络流量。
捕获网络流量 启动网络分析工具，开始捕获网络流量。在Wireshark中，可以通过单击“开始捕获”按钮来开始捕获网络流量。在tcpdump中，可以使用命令行参数来启动捕获。
在捕获网络流量时，需要注意以下几点：
选择正确的捕获网络接口，以确保捕获到所需的网络流量。
根据需要设置过滤器，以便只捕获特定类型的网络流量。
避免在高负荷时进行捕获，以免影响网络性能。
分析网络流量 对捕获的网络流量进行分析。可以使用网络分析工具提供的协议解析功能，对网络流量进行深入的分析和解释。
在Wireshark中，可以使用“过滤器”功能，筛选出特定协议或特定源目的IP地址的数据包。可以使用Wireshark提供的统计信息和图表，对网络流量进行进一步的分析和识别。
在tcpdump中，可以使用命令行参数来设置过滤器，以便只捕获特定类型的网络流量。可以使用tcpdump提供的统计信息和图表，对网络流量进行进一步的分析和识别。
识别异常流量 通过分析网络流量，识别异常流量，例如未经授权的访问、攻击行为等。可以使用网络分析工具提供的统计信息和图表，对异常流量进行进一步的分析和识别。
在Wireshark中，可以使用“统计”功能，查看网络流量的统计信息。可以使用Wireshark提供的图表和分析工具，对异常流量进行进一步的分析和识别。
在tcpdump中，可以使用命令行参数来设置过滤器，以便只捕获特定类型的网络流量。可以使用tcpdump提供的统计信息和图表，对异常流量进行进一步的分析和识别。
建立安全策略 根据分析结果建立相应的安全策略，例如限制特定IP地址的访问、封锁特定类型的攻击等。可以使用网络分析工具提供的统计信息和图表，对安全策略进行进一步的分析和制定。
在Wireshark中，可以使用“过滤器”功能，筛选出特定协议或特定源目的IP地址的数据包。可以使用Wireshark提供的图表和分析工具，对安全策略进行进一步的分析和制定。
在tcpdump中，可以使用命令行参数来设置过滤器，以便只捕获特定类型的网络流量。可以使用tcpdump提供的统计信息和图表，对安全策略进行进一步的分析和制定。
总之，使用网络分析工具进行网络流量分析可以帮助识别网络中的异常流量和安全威胁，并为制定相应的安全策略提供帮助。需要注意的是，在进行网络分析时，需要遵守相应的法律法规和道德规范，不得对他人的网络进行未经授权的访问或攻击行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad43e4f4ecb064bf757c9ee90398e0de/" rel="bookmark">
			了解常见的漏洞类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL注入漏洞： 这种漏洞发生在应用程序未正确处理或验证用户提交的数据时。攻击者可以在用户输入的数据中注入SQL代码，并利用这些代码来访问或篡改数据库中的敏感信息，如用户账户、密码、信用卡信息等。为了防止SQL注入漏洞，应用程序需要正确处理和验证用户输入的数据，使用参数化查询或预处理语句，以确保输入的数据不会被解释为SQL代码。
跨站点脚本攻击（XSS）： 这种漏洞发生在应用程序未正确处理或验证用户提交的数据时。攻击者可以在Web页面上注入恶意脚本，这些脚本可以窃取用户的信息，如Cookies、会话ID等，也可以冒充用户进行操作，如点击广告、提交表单等。为了防止XSS漏洞，应用程序需要正确处理和验证用户提交的数据，使用输入验证和输出编码来防止恶意脚本的注入。
跨站点请求伪造（CSRF）： 这种漏洞发生在应用程序未正确验证请求来源时。攻击者可以在另一个站点上欺骗用户，使其在应用程序中执行某些操作，例如更改密码、提交订单等，从而模拟用户的身份，实施非法操作。为了防止CSRF漏洞，应用程序需要正确验证请求的来源，使用令牌或随机数等方式来防止伪造请求。
文件包含漏洞： 这种漏洞发生在应用程序未正确处理或验证用户提交的数据时。攻击者可以利用应用程序中的不安全文件包含功能，将恶意代码注入到应用程序中，从而执行恶意操作。为了防止文件包含漏洞，应用程序需要正确处理和验证用户提交的数据，使用绝对路径或限制包含的文件类型，以确保不会包含恶意文件。
逻辑漏洞： 这种漏洞通常是由于应用程序中的设计错误或缺陷而导致的。攻击者可以利用这些漏洞绕过某些安全措施或直接访问敏感信息。逻辑漏洞通常很难被检测到，因此需要进行全面的安全测试和审计，以确保应用程序中没有逻辑漏洞。
缓冲区溢出漏洞： 这种漏洞通常出现在本地应用程序中。攻击者可以向应用程序输入超过其预期长度的数据，从而覆盖程序内存中的其他数据，从而达到控制程序的目的。为了防止缓冲区溢出漏洞，应用程序需要正确处理和验证用户输入的数据，限制输入的长度和类型，以确保不会出现缓冲区溢出。
身份验证和会话管理漏洞： 这种漏洞通常发生在Web应用程序中。攻击者可以利用弱身份验证机制或会话管理机制，窃取用户的身份或绕过身份验证。为了防止身份验证和会话管理漏洞，应用程序需要使用强密码策略、多因素身份验证、使用安全Cookie等措施，以确保用户身份得到保护。
不安全的API： 这种漏洞通常出现在Web应用程序中，其中包含了API接口。攻击者可以通过这些接口访问应用程序中的敏感数据或执行非法操作。为了防止不安全的API漏洞，应用程序需要正确限制API的访问权限、使用安全的身份验证和授权机制、对API接口进行安全测试和审计等，以确保API接口的安全性。
1.HTTP 参数污染
它可以被定义为通过插入查询字符串分隔符来达到覆盖或添加HTTP GET / POST参数的目的
2.后门
后门一般是指那些绕过安全性控制而获取对程序或系统访问权的程序方法。
3.Cookie 验证错误
4.跨站请求伪造
跨站请求伪造通常缩写为CSRF或者XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。
5.SQL 注入
SQL 注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
6.CRLF 注入
CRLF 指的是回车(ASCII 13, \r) 和换行 (ASCII 10, \n)。利用 CRLF 注入可以提交换行符给应用程序，达到比如修改请求头的作用。
7.XML 注入
XML注入又叫XXE攻击，全称为XML External Entity，从安全的角度来理解，可以叫做XML外部实体攻击。在XML实体中，关键字‘’system‘’可以让XML解析器从URL中读取内容，并允许他在XML文档中被替换。服务端解析用户提交的xml文件时未对xml文件引用的外部实体做合适的处理，并且实体的URL支持file://和php://等协议，攻击者可以在xml文件中声明URI指向服务器本地的实体造成攻击。
8.SSI 注入
ssi是赋予html静态页面的动态效果，通过ssi执行命令，返回对应的结果，若在网站目录中发现了.stm .shtm .shtml等，且对应SSL输入没有过滤，可能存在SSI注入漏洞简单的说ssi注入就是寻找输入点输入类似&lt;!--#exec cmd="命令" --&gt; 格式，看看能不能
运行系统命令
9.XQuery 注入
类似于 XPath 注入，XQuery 注入攻击是指利用 XQuery 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的 XQuery 查询代码，以获得权限信息的访问权并更改这些信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad43e4f4ecb064bf757c9ee90398e0de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d50a831060482b82a4bb7592ba99eeb/" rel="bookmark">
			渗透测试的方法和流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		渗透测试，是为了证明网络防御按照预期计划正常运行而提供的一种机制。不妨假设，你的公司定期更新安全策略和程序，时时给系统打补丁，并采用了漏洞扫描器等工具，以确保所有补丁都已打上。如果你早已做到了这些，为什么还要请外方进行审查或渗透测试呢？因为，渗透测试能够独立地检查你的网络策略，换句话说，就是给你的系统安了一双眼睛。而且，进行这类测试的，都是寻找网络系统安全漏洞的专业人士。 渗透测试就是利用我们所掌握的渗透知识，对网站进行一步一步的渗透，发现其中存在的漏洞和隐藏的风险，然后撰写一篇测试报告，提供给我们的客户。客户根据我们撰写的测试报告，对网站进行漏洞修补，以防止黑客的入侵！ 渗透测试的前提是我们得经过用户的授权，才可以对网站进行渗透。如果我们没有经过客户的授权而对一个网站进行渗透测试的话，这是违法的。
渗透测试基本流程
明确目标
信息收集
漏洞挖掘
漏洞利用
权限提升
内网渗透
痕迹清理
撰写报告
渗透测试分为黑盒测试和白盒测试
黑盒测试又被称为所谓的“Zero-Knowledge Testing”，渗透者完全处于对系统一无所知的状态，或者只知道这个网站的URL。通常这类型测试，最初的信息获取来自于DNS、Web、Email及各种公开对外的服务器。 白盒测试与黑箱测试恰恰相反，测试者可以通过正常渠道向被测单位取得各种资料，包括网络拓扑、员工资料甚至网站或其它程序的代码片段，也能够与单位的其它员工（销售、程序员、管理者...）进行面对面的沟通。这类测试的目的是模拟企业内部雇员的越权操作。
明确目标 授权许可 从客户或该公司获取书面渗透测试委托授权书
确定范围 测试目标的范围、ip、域名、内外网、整站或部分模块、测试账户等
确定规则 使用代理IP还是IP访问白名单、能渗透到什么程度（发现漏洞为止还是继续扩大范围挖掘尽可能多的风险），时间限制、能否修改上传、能否提权等。
目标系统介绍、重点保护对象及特性。
是否允许数据破坏？
是否允许阻断业务正常运行？
测试之前是否应当知会相关部门负责人？
接入方式？外网和内网？
测试是发现问题就算成功，还是尽可能的发现多的问题？
渗透过程是否需要考虑社会工程？
More...
确定需求 应用系统渗透、数据库系统渗透、主机操作系统渗透、网络设备渗透等
信息收集 信息收集的方式可以分为两种：主动和被动。
主动信息收集：通过直接访问、扫描网站，这种流量将流经网站
被动信息收集：利用第三方的服务对目标进行访问了解，比例：Google hack搜索、Shodan搜索等
基础信息 Whois信息（域名所有人、域名注册商、邮箱、联系方式、Whois反查）
域名对应IP（多地Ping判断是否存在CDN，获取服务器真实IP）
旁站（同一服务器下其他网站）
C段（同一网段其他服务器）
子域名(顶级域名下的域名，如：www.example.com是顶级域名example.com的子域名)
DNS（大型网络的企业，一般都有自己的DNS服务器）
More...
常用工具 方法 Google语法查询
基于SSL证书查询
More...
工具 Dig
Nmap
Masscan
Nslookup
subDomainsBrute
Layer子域名挖掘机
More...
常用网站 爱站网
DNSdb
Shodan
ZoomEy
微步在线
千寻查询工具
傻蛋联网设备搜索
站长工具-站长之家
Certificate Search
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d50a831060482b82a4bb7592ba99eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40d42a1ba026fe31277ede55213a3a1/" rel="bookmark">
			网络与系统安全概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全基础知识 计算机安全
保护计算机系统，使其没有危险，不受威胁，不出事故。
网络系统安全定义
1、网络系统安全指信息系统的硬件、软件及其系统中的数据受到保护，不会遭到偶然的或者恶意的破坏、更改、泄露,系统能连续、可靠、正常地运行，服务不中断。
2、网络安全简单的说是在网络环境下能够识别和消除不安全因素的能力。
网络系统安全的基本需求
1、可靠性 2、可用性 3、保密性 4、完整性 5、不可抵赖性 6、可控性 7、可审查性 8、真实性
网络系统安全内容
网络系统安全的主体是保护网络上信息系统中数据、通信及应用的安全。
1、数据安全性是一组程序和功能，用来阻止对数据进行非授权的泄漏、转移、修改和破坏。
2、通信安全性是一些保护措施，要求在通信中采用保密安全性、传输安全性、辐射安全性的措施，并依要求对具备通信安全性的信息采取物理安全性措施。
3、应用安全性是一组程序和功能，用来对保障应用执行过程中的可靠及可用性，同时对应用中涉及的数据、通信安全性进行防护。
网络安全的重要性
随着网络的快速普及和网络的开放性、共享性出现，网络的重要性和对社会的影响也越来越大。 1、网络上的各种新业务的兴起，比如电子商务，电子政务，电子货币，网络银行等，以及各种专业用网的建设，使得安全问题显得越来越重要。
2、我国信息化进程虽然刚刚起步，但是发展迅速，计算机网络在我国迅速普及。短短的几年里，发生了多起针对、利用计算机危害计算机网络的种种威胁。必须采取有力的措施来保护计算机网络的安全。
严峻的网络安全问题
1、当前，互联网上黑客技术的泛滥和无处不在的黑手，对我们的个人计算机安全、工作计算机安全、单位网络乃至社会公共秩序已经造成了不容忽视的威胁。
2、攻击者利用黑客技术获取机密信息、牟取暴利，已经形成了一条完整的地下产业链。
我国网络系统安全现状
1、我国网络安全法律法规政策保障体系逐步健全
2、我国互联网网络安全威胁治理取得新成效
3、勒索软件对重要行业关键信息基础设施威胁加剧
4、越来越多的APT攻击行为被披露
5、云平台成为发生网络攻击的重灾区
6、拒绝服务攻击频次下降但峰值流量持续攀升
7、针对工业控制系统的定向性攻击趋势明显
8、虚假和仿冒移动应用增多且成为网络诈骗新渠道
9、数据安全问题引起前所未有的关注
网络安全的根源
信息系统自身安全的脆弱性 信息系统脆弱性，指信息系统的硬件资源、通信资源、软件及信息资源等，因可预见或不可预见甚至恶意的原因而可能导致系统受到破坏、更改、泄露和功能失效，从而使系统处于异常状态，甚至崩溃瘫痪等的根源和起因。
安全漏洞（Vulnerability）：计算机系统在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷和不足。这里我们从以下三个层面分别进行分析：
1、硬件组件 信息系统硬件组件安全隐患多源于设计，主要表现为物理安全方面的问题。 硬件组件的安全隐患除在管理上强化人工弥补措施外，采用软件程序的方法见效不大。在设计、选购硬件时，应尽可能减少或消除硬件组件的安全隐患
2、软件组件 软件组件的安全隐患来源于设计和软件工程实施中遗留问题： 软件设计中的疏忽 软件设计中不必要的功能冗余以及软件过长过大 软件设计部按信息系统安全等级要求进行模块化设计 软件工程实现中造成的软件系统内部逻辑混乱
3、网络和通信协议 安全问题最多的网络和通信协议是基于TCP/IP协议栈的Internet及其通信协议。 随着物联网应用的扩展，工控系统的通信协议也成为黑客等攻击的目标。
脆弱性与漏洞存在的原因：
1、支持Internet运行的TCP/IP协议栈原本只考虑互联互通和资源共享问题，并未考虑也无法兼顾解决来自网际的大量安全问题。
2、基于TCP/IP的Internet是在可信任网络环境中开发出来的成果，体现在TCP/IP协议上的总体构想和设计本身，基本未考虑安全问题，并不提供人们所需的安全性和保密性。
3、TCP/IP协议最初设计的应用环境是互相信任的。
4、安全与效率之间的矛盾限制了安全机制的部署与实施。
信息系统面临的安全威胁
基本威胁： 安全的基本目标是实现信息的机密性、完整性、可用性。对信息系统这3个基本目标的威胁即是基本威胁。
1、信息泄漏：信息泄漏指敏感数据在有意或无意中被泄漏、丢失或透露给某个未授权的实体，如数据窃取、流量分析等。
2、完整性破坏：以非法手段取得对信息的管理权，通过未授权的创建、修改、删除和重放等操作而使数据的完整性受到破坏。
3、拒绝服务：信息或信息系统资源等被利用价值或服务能力下降或丧失。产生服务拒绝的原因：受到攻击所致。信息系统或组件在物理上或逻辑上受到破坏而中断服务。
4、未授权访问：未授权实体非法访问信息系统资源，或授权实体超越权限访问信息系统资源，如身份假冒等。
威胁信息系统的主要方法：
1、冒充 某个未授权的实体假装成另一个不同的实体，进而非法获取系统的访问权利或得到额外特权 攻击者可以进行下列假冒： 假冒管理者发布命令和调阅密件； 假冒主机欺骗合法主机及合法用户； 假冒网络控制程序套取或修改使用权限、口令、密钥等信息，越权使用网络设备和资源； 接管合法用户欺骗系统，占用合法用户资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40d42a1ba026fe31277ede55213a3a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c4c40e3a3e3b4859be6b8f6325ceeb/" rel="bookmark">
			如何用C语言输出“hello world”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、添加头文件 #include &lt;stdio.h&gt; 二、定义main函数 int main(){ } 三、写出代码主体 printf("hello world"); return 0; 四、总体代码 #include &lt;stdio.h&gt; int main() { printf("Hello World!"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032d00ca1978eb14e6d04ca0c110cadb/" rel="bookmark">
			k8s常用重启pod的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 优雅方式暴力方式 优雅方式 #首先确定是什么资源对象，可以看yaml文件，如果没有yaml文件可以使用-o yaml导出查看 #确定了资源对象以后可以使用 kubectl rollout restart 资源对象 -n 名称空间 资源对象名称 #此方式非常优雅，极度推荐 暴力方式 #如果是deploy或者sts资源对象可以使用 kubectl delete po -n 名称空间 pod名称 注意，以上方法如果修改了yaml文件，重启不会生效yaml文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf6073a7d42d2c598a62615ac13e3b1/" rel="bookmark">
			k8s搭建mysql集群实现主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境介绍一、部署NFS服务器二、创建PV三、编写MySQL的yaml文件四、启动MySQL五、验证MySQL主从复制 环境介绍 名称版本操作系统IP备注K8S集群1.20.15Centos7.9192.168.11.21 192.168.11.22 192.168.11.2321为k8s-master 22为k8s-node01 23为k8s-node02MySql5.7Centos7.9一主两从nfs服务器Centos7.9192.168.11.24共享目录为/nfs 一、部署NFS服务器 11.24：
1.创建NFS共享目录 mkdir -p /nfs 2.安装NFS服务 yum -y install nfs-utils rpcbind 3.编辑NFS配置 echo "/nfs *(rw,async,no_root_squash)" &gt;&gt;/etc/exports 4.启动服务 systemctl enable --now nfs-server systemctl enable --now rpcbind 5.验证 showmount -e ##看是否能看到/nfs *字段；如果没有该命令yum -y install showmount 11.21/22/23（所有K8S节点）：
1.安装NFS yum -y install nfs-utils 2.测试是否能检测到NFS共享目录 showmount -e 192.168.11.24 ##看是否能看到/nfs * 二、创建PV 11.21：
1、创建存放MySQL的yaml清单目录 mkdir -p /webapp cd /webapp 2、创建NFS的YAML文件 vim nfs-client.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nfs-client-provisioner labels: app: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default spec: replicas: 1 strategy: type: Recreate selector: matchLabels: app: nfs-client-provisioner template: metadata: labels: app: nfs-client-provisioner spec: serviceAccountName: nfs-client-provisioner containers: - name: nfs-client-provisioner image: registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcf6073a7d42d2c598a62615ac13e3b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad29c134425c1d5c4d8708a4ae0a89c/" rel="bookmark">
			初始化K8S集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用介绍环境介绍一、刚开始搭建k8s集群时重新初始化（node节点还未添加）二、K8S搭建完毕后重新初始化 使用介绍 当刚开始搭建k8s集群报错（端口/数据已经生成）或k8s集群正在使用时遇到了不可修复的问题需要初始化集群时可以使用。谨慎使用 环境介绍 名称版本操作系统IP备注K8S集群1.20.15Centos7.9192.168.11.21 192.168.11.22 192.168.11.2311.21为k8s-master01
11.22为k8s-node01
11.23为k8s-node02 一、刚开始搭建k8s集群时重新初始化（node节点还未添加） 11.21：
rm -rf /etc/kubernetes/* kubeadm reset #如果不能重置，使用-f 强制 rm -rf /etc/kubernetes/* rm -rf ~/.kube/* rm -rf /var/lib/etcd/* rm -rf /var/lib/cni/ rm -fr /etc/cni/net.d 重新使用kubeadm init初始化即可 二、K8S搭建完毕后重新初始化 11.21：
kubectl cordon k8s-node01 ##标记节点为不可调度 kubectl cordon k8s-node02 kubectl drain k8s-node01 --ignore-daemonsets ##驱逐指定节点的pod（pod会重新运行在其他节点）如果报错再加一个--force和--delete-local-data kubectl drain k8s-node02 --ignore-daemonsets 所有节点删除网络插件 kubectl delete nodes k8s-node01 kubectl delete nodes k8s-node02 node（所有node节点）：
systemctl stop kubelet rm -rf /etc/kubernetes/* kubeadm reset 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad29c134425c1d5c4d8708a4ae0a89c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf78c8f92e317dc3922aef988fcda91/" rel="bookmark">
			K8S搭建Zabbix6.2.6版本＜详细版＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介环境介绍一、部署MySQL服务1.1、准备软件包1.2、卸载mariadb1.3、安装MySQL1.4、登录mysql数据库，创建用户、库、修改权限 二、搭建NFS四、创建PV4.1、创建nfs的deployment4.2、创建nfs-rbac4.3、创建nfs-sc4.4、启动PV 五、创建zabbix-service5.1、创建zabbix-service.yaml5.2、启动zabbix-server5.3、启动zabbix的web页面5.4、启动zabbix的web页面5.5、访问zabbix的web页面 六、Helm部署zabbix-proxy&amp;zabbix-agent6.1、安装Helm工具6.2、添加Helm Chart Repository6.3、Zabbix Helm Chart,并解压6.4、配置Chart6.5、配置values.yaml6.6、修改kube-state-metrics 依赖Chart参数配置6.7、Helm 安装zabbix Chart 7、登录Web界面配置proxy7.1、创建proxy7.2、验证proxy状态7.3、创建主机组7.4、添加主机7.5、查看IP查看token7.6、定义变量7.7、 创建k8s-cluster主机，用于自动发现服务组件7.7.1、创建主机7.7.2、定义变量7.7.3、验证主机 简介 以下实验由yaml清单部署PV+zabbix-server，使用helm构建zabbix-proxy/agent完成
环境介绍 名称版本信息操作系统IP备注信息K8S集群1.20.15Centos7.9192.168.11.21
192.168.11.22
192.168.11.23
21:k8s-master
22:k8s-node01
23:k8s-node02Zabbix6.2.6Centos7.9容器内所有zabbix容器都在zabbix名称空间MySQL8.0.30-glicCentos7.9192.168.11.24MySQL程序在/home/application下NFSCentos7.9192.168.11.24共享目录为/nfs K8S集群在此不做演示,请先搭建K8S集群再做以下实验
一、部署MySQL服务 1.1、准备软件包 本次实验使用8.0.30-glibc版本：https://downloads.mysql.com/archives/community/
1.2、卸载mariadb #查看是否存在MariaDB rpm -qa|grep mariadb #卸载mariadb yum remove mariadb* 1.3、安装MySQL root@mysql-nfs-server]─[~] mkdir -p /home/application/mysql ##创建mysql工作目录 tar -xf mysql-8.0.30-linux-glibc2.12-x86_64.tar.xz mv mysql-8.0.30-linux-glibc2.12-x86_64 /home/application/mysql/app ##将mysql目录移动并改名 echo "export PATH=$PATH:/home/application/mysql/app/bin" &gt;&gt; /etc/profile ##永久添加mysql的命令路径 . /etc/profile ##已经生效 useradd -s /sbin/nologin mysql -M ##创建mysql用户，用来运行mysql程序 mkdir -p /home/application/mysql/data ##创建mysql的数据目录 chown -Rf mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf78c8f92e317dc3922aef988fcda91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aea8a5ebb89ea2269d42bdb6e488426/" rel="bookmark">
			nginx通过upstream反代，部分页面404的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介贴上配置文件 简介 因为项目需求，需要安装前置机（nginx代理）。安装之前通过静态解析发现所有页面都是正常，但是代理过后部分页面404的问题
贴上配置文件 这是原配置文件，出现部分页面404，后经过公司大佬排查，说是缓存太多，把所有的expires去掉及访问正常……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444f8c2b16c4842ed03dc3339f6df988/" rel="bookmark">
			Android调用google原生裁剪，兼容三方相册裁剪功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android调用google原生裁剪，兼容三方相册裁剪功能 效果图实现功能编写CropImage类继承 ActivityResultContract调用 效果图 实现功能 本篇文章裁剪功能实现兼容Android6+，解决部分google手机（有部分Android10的Google手机无法使用google自带裁剪功能）解决三星手机多相册非系统裁剪失败问题
关于拍照和图库选取的功能可以参考《compose中实现拍照和选取相册功能兼容android 13+》，本篇不做赘述。
编写CropImage类继承 ActivityResultContract class CropImage : ActivityResultContract&lt;CropImageResult, PictureResult&gt;() { var outUri: Uri? = null companion object { val instance get() = Helper.obj } private object Helper { val obj = CropImage() } override fun createIntent(context: Context, input: CropImageResult): Intent { //系统裁剪 val intent = Intent("com.android.camera.action.CROP") val mimeType = context.contentResolver.getType(input.uri) val imageName = "${input.imageName}.${ MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType) }" outUri = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) { val values = ContentValues() values.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444f8c2b16c4842ed03dc3339f6df988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/896a169a8023a0dc5d69e28b9f7cc286/" rel="bookmark">
			C语言经典面试题10道（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		51. main()
{
int a[5]={1,2,3,4,5};
int * ptr=(int*)(&amp;a+1);
printf(“%d，%d”,*(a+1),*(ptr-1));
}
请问输出：
答案：2，5
详解：a代表数组首地址，即* a=1，* (a+1)=2
&amp;a代表数组指针，其类型为int (*)[5]，所以&amp;a+1可以理解为在数组指针的基础上偏移为5，然后强制转换为int类型的指针赋给ptr，所以是下个数组的首地址，ptr-1即为上个数组的最后一位，所以是a[4]=5
52.请问下面程序有什么错误? int a[60][250][1000],i,j,k;
for(k=0;k&lt;=1000;k++)
for(j=0;j&lt;250;j++)
for(i=0;i&lt;60;i++)
a[i][j][k]=0;
答案：内外层循环反了，正确应该是：
int a[60][250][1000],i,j,k;
for(k=0;k&lt;=60;k++)
for(j=0;j&lt;250;j++)
for(i=0;i&lt;1000;i++)
a[k][j][i]=0;
53.以下是求一个数的平方的程序,请找出错误: #define SQUARE(a)((a)*(a))
int a=5;
int b;
b=SQUARE(a++);
答案：在替换后b=((a++) * (a++))，算得b=(5 * 6)=30。可能在不同编译器下得到不同答案。
54. #define Max_CB 500
void LmiQueryCSmd(StructMSgCB * pmsg)
{
unsigned char ucCmdNum;
...... for(ucCmdNum=0;ucCmdNum&lt;Max_CB;ucCmdNum++)
{
......;
} } 这段代码执行有什么问题？
答案：死循环，因为unsigned char 的取值范围在0~255之间，所以ucCmdNum永远小于Max_CB。
55.嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。 答案：while(1);或者for ( ;1;) ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/896a169a8023a0dc5d69e28b9f7cc286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b5ba4f06beee527e08898853e90bc00/" rel="bookmark">
			Quartus-II 9.0版本实现半加器，1位全加器，4位加法器的设计(数字逻辑课程实验1—半加器设计，1位全加器设计，4位加法其设计)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面的设计均采用Quartus-II 9.0版本实现，包括时序仿真和功能仿真。
目录
一、半加器设计
1.实验原理
2.Quartus建立工程
3.实验结果展示
半加器原理图
半加器功能仿真结果图
半加器时序仿真结果图
4.补充说明
二、1位全加器设计
1.实验原理
2.Quartus建立工程
3.实验结果展示
全加器原理图
全加器功能仿真结果图
全加器时序仿真结果图
三、4位加法器设计
1.实验原理
2.Quartus建立工程
3.实验结果展示
4位加法器原理图
4位加法器功能仿真结果图
4位加法器时序仿真结果图
一、半加器设计 1.实验原理 半加器的设计由两个基本逻辑门元件组成，包括与门和逻辑门。
半加器的逻辑表达式：S = A ⊕B； C = A ● B；
就是S等于A异或B，C等于A与B。其中S是和值端口，C是进位端口，A、B是数据输入端口。
半加器真值表：
半加器真值表 ABSC0000011010101101 2.Quartus建立工程 （1）打开Quartus软件，开始一个新项目，依次点击File-&gt;New Project Wizard-&gt;next
（2）选择项目保存位置以及命名，依次点击next
（3）根据设计要求选择相应的芯片类型，继续点击next ，直到Finish
（4）依次点击New-&gt;Block Dicgram/Schematic File，进入原理图编辑窗口
（5）双击原理图编辑窗口，选择相应电路元器件，这里我们依次选择异或门，与门，输入和输出引脚 ，按照设计好的原理图进行设计
​​​​
（6）按照设计好的半加器原理图进行设计连线
（7）设计完成后保存（这里必须保存，如果你直接用别人已经完成好的文件，则需要另存）
（8）接下来使用编译工具进行编译，依次点击Processing-&gt;Compiler Tool-&gt;Start
（9）编译成功后得到如下结果
（10）接下来进行网表设计，依次点击File-&gt;New-&gt;Vector Waveform File，进入网表设计界面
（11）依次选择Edit-&gt;End Time设置截止时间，Edit-&gt;Insert-&gt;Insert Node Bus设置测试向量文件 （12）设置输入引脚X,Y激励波形，设置完成后保存（这里也必须保存，与之前文件保存在同一目录下）
（13）接下来进行功能仿真，依次点击Processing-&gt;Simulator Tool，在模拟器窗口中必须点击Generate Functional Simulation Netlist，否则会出现报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b5ba4f06beee527e08898853e90bc00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2987b6e2412b7d0f3f0c9152088a0b0/" rel="bookmark">
			markdown输出数学公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学公式语法 公式两边添加$,或者$$.$$表示公式居中.复杂算式可以用{}包起来.
上标,下标 上标用^,
例 x^2
下标用_,
例: y_2
( x 2 + x y ) x y + x 1 2 = y 1 − y 2 x 1 − y 1 2 (x^2 + x^y )^{x^y}+ x_1^2= y_1 - y_2^{x_1-y_1^2} (x2+xy)xy+x12​=y1​−y2x1​−y12​​
分数 公式 分子 \over 分母
例 ：x \over x+y
x x + y x \over {x+y} x+yx​
开方 公式 \sqrt[n]a,n等于2,可以省略
例 ： \sqrt[3]4或 \sqrt9
4 3 \sqrt[3]4 34 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2987b6e2412b7d0f3f0c9152088a0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9a3a03c910adf63f47333e198f8a8d/" rel="bookmark">
			C# 枚举使用整理_C# enum详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、枚举的定义
枚举类型 是由基础整型数值类型的一组命名常量定义的值类型。
System.Enum 类型是所有枚举类型的抽象基类。 它提供多种方法来获取有关枚举类型及其值的信息。 有关更多信息和示例，请参阅 System.Enum API 参考页。
可在基类约束中使用 System.Enum（称为枚举约束），以指定类型参数为枚举类型。 所有枚举类型也都满足 struct 约束，此约束用于指定类型参数为不可为 null 的值类型。
使用枚举的优点：
1.增加代码的可读性，使代码更加清晰；它允许使用描述性的名称表示整数值。
2.标准化业务归类、业务类型；有助于确保给变量指定合法的、期望的值。
使用场景：
数据分类，操作类型，订单状态/流程状态
二、枚举的使用
默认情况下，枚举成员的关联常数值为类型 int；
它们从零开始，并按定义文本顺序递增 1。
可以显式指定任何其他整数数值类型作为枚举类型的基础类型。
还可以显式指定关联的常数值。关键词 enum
enum Season { Spring,//标识0 Summer,//标识1 Autumn,//标识2 Winter //标识3 } 指定数字
enum ErrorCode : ushort { None = 0, Unknown = 1, ConnectionLost = 100, OutlierReading = 200 } 三、枚举和数字的转换
数据类型转换：
//将枚举，转换成数字 int num = Season.春天.GetHashCode(); Console.WriteLine(num); //将数字，转换成枚举 Season seson = (Season)System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9a3a03c910adf63f47333e198f8a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee4d270cf8f0149321d96a205598003/" rel="bookmark">
			【边缘计算】【第一章 什么是边缘计算】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		边缘计算 序第一章 什么是边缘计算概念章鱼说应用场景数据单位转换边缘计算的前世今生CDN（Content Delivery Network）内容分发网络微云（Cloudlet）雾计算——雾是接近地面的云MEC边缘计算大事记 边缘计算核心技术概述1 网络技术2 隔离技术3 边缘操作系统4 算法执行框架5 安全和隐私保护技术 序 边缘计算的基本理念是将计算任务在接近数据源的计算资源上运行，是个连续统（定义:若A与实数集R等势，则称A为连续统。），可以有效减少数据传输带宽，减小计算系统的延迟，缓解云计算中心的压力，提高可用性，并能够有效保护数据安全和隐私。
第一章 什么是边缘计算 概念 Edge Computing“Edge Computing: Vision and Challenges”ACM and IEEE 联合举办边缘计算会议（ACM/IEEE Symposium on Edge Computing, SEC） 章鱼说 多个小脑 + 一个大脑
应用场景 VR/AR智慧城市车联网 移动边缘计算技术（Mobile-Edge Computing, MEC） 企业专网 MEC服务器为企业提供一个虚拟的RAN（Radio Access Network） 网络视频优化加速 边缘部署可以给中心视频服务器提供动态网络分析信息，辅助TCP拥塞控制和码率适配，改善内容分发效率低下的情况。 工业互联网 改善性能保证数据安全和隐私减少操作成本 数据单位转换 边缘计算的前世今生 CDN（Content Delivery Network）内容分发网络 关键技术：内容存储、分发技术原理：广泛采用各种缓存服务器MIT Leighton and Lewin1998 Akamai 全球最大的CDN服务提供商CDN强调内容的备份和缓存，而边缘计算的基本思想则是功能缓存（Function Cache），这实际上是借鉴了CDN的基本思想。CDN是边缘计算的最初原型 微云（Cloudlet） 2009年“盒子里的数据中心”OEC（Open Edge Computing）的研究结果卡内基梅隆大学发起其源代码和搭建方式可以在OEC的官网获取微云的主要技术支撑是虚拟机合成和OpenStack，虚拟机合成实现将计算任务卸载到微云，OpenStack提供虚拟计算和存储服务的资源设计灵感：致力于实现信息的超低延时传输的触觉互联网（Tactile Network）四个关键属性： 只有软状态功能强大、连接良好且安全临近性扩展性 雾计算——雾是接近地面的云 为了解决面向数据传输、计算和存储过程中的计算负载和数据传输带宽的问题雾计算（Fog Computing ）、移动边缘计算（Mobile Edge Computing, MEC）思科提出概念，定义为迁移云计算中心任务到网络边缘设备执行的一种高度虚拟化的计算平台本地化的云计算云计算强调计算的方式，雾计算强调计算的位置2015年11月，思科、ARM、戴尔、英特尔、微软等联合成立开放雾联盟（OpenFog） MEC 2014，欧洲电信标准协会（ETSI）给出的定义：MEC通过在无线接入侧部署通用服务器，从而为无线接入网提供 IT 和云计算的能力。2017，M 被解释为”Multi-Access“，移动边缘计算 变成了 多接入边缘计算 边缘计算大事记 2016年11月。华为、中科院沈阳自动化研究所、英特尔、ARM等在北京成立边缘计算产业联盟（Edge Computing Consortium,ECC）2017年7月。ETSI 多接入边缘计算（Multi-Access Edge Computing ）行业规范工作组（ISG）,发布了首套标准化应用程序接口（API），以支持边缘计算的互操作性2018年1月。《边缘计算》出版，施巍松、刘芳、孙辉、裴庆祺2018年9月17日。在上海召开世界人工智能大会，以【边缘计算，智能未来】为主题举办了边缘智能主题论坛，这是中国从政府层面上对边缘计算的发展进行了支持和探讨2019年3月。两会期间，周鸿祎将【IMABCDE】写入提案，分别表示：IoT、移动通信、人工智能、区块链、云计算、大数据、边缘计算。2019年5月11日。第三届边缘计算技术研讨会在杭州召开。2019年9月。边缘计算开源项目 StarlingX，一个专注于对低延迟和高性能应用进行优化的边缘计算及物联网云平台KubeEdge，将 Kubernetes 容器存储标准CSI 带到边缘。 2019年11月28日。边缘计算产业联盟（Edge Computing Consortium, ECC）发布三份白皮书： 《边缘计算安全白皮书》《运营商边缘计算网络技术白皮书》《边缘计算IT基础设施白皮书1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ee4d270cf8f0149321d96a205598003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5da5749ff90a9f0b9def09840fe32b6/" rel="bookmark">
			AutoCAD如何通过C#进行插件开发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.引言1.开发工具准备2.VS（C#）创建插件3.使用插件 0.引言 AutoCAD是一款广泛应用于工程设计和建筑行业的计算机辅助设计软件。通过使用C#语言进行插件开发，可以扩展AutoCAD的功能，实现定制化的需求。插件可以实现自动化绘图、数据处理、批量操作等功能，提高工作效率和准确性。在本文中，总结使用C#语言进行AutoCAD插件开发并记录。
1.开发工具准备 （1）安装Visual Studio
在百度等浏览器搜索“Visual Studio2022”安装包，然后安装即可。
（2）安装AutoCAD2022
在百度等浏览器搜索“AutoCAD2022”安装包，然后安装即可。
2.VS（C#）创建插件 （1）新建项目
（2）引用AutoCAD2022的链接库
"acmgd.dll" "accoremgd.dll" "AcCui.dll" "acdbmgd.dll" （3）设置链接库
（4）添加命名空间
using Autodesk.AutoCAD.ApplicationServices; using Autodesk.AutoCAD.DatabaseServices; using Autodesk.AutoCAD.EditorInput; using Autodesk.AutoCAD.Runtime; using Autodesk.AutoCAD.Colors; （5）设置外部启动程序
（6）编写插件功能
[CommandMethod("TestDemo")] //指令名称 public void TestDemo() { // 声明命令行对象 Editor ed = Application.DocumentManager.MdiActiveDocument.Editor; // 向命令行输出一段文字 ed.WriteMessage("hello, AutoCAD!"); } 3.使用插件 参考资料：
[1] CREECLEEXIN. 工程人员的CAD编程(C#对CAD进行二次开发)系列; 2021-05-08 [accessed 2023-07-15].
[2] Linxson. 【C#】AutoCAD二次开发笔记; 2022-06-13 [accessed 2023-07-15].
[3] ‭494. C# CAD二次开发初步（HelloWorld）; 2020-09-28 [accessed 2023-07-15].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5da5749ff90a9f0b9def09840fe32b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b44610789b32f1d0fcb7d65614c754/" rel="bookmark">
			Vue项目的启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
由于最近开始实习，负责人上来就给我丢一个前端vue项目和后端文件，让我在本机完成部署，由于之前学的基本上都是后端相关知识，很少有了解到前端的东西，因此在这里将自己部署Vue项目时遇到的问题和解决过程进行一个总结，希望对你有所帮助。
前缀知识：
1.前端工程化： 是指在企业级的前端项目开发中，把前端开发所需要的工具、技术、流程、经验等进行规划化、标椎化。一般使用的工具就是vue官方提供的脚手架工具即Vue-cli
2.Vue-cli是Vue官方提供的一个脚手架、用于快速生成一个Vue的项目模板，其提供的功能有统一的目录架构、本地调试、热部署、单元测试、集成打包上线等。需要依赖NodeJS环境
3.Nodejs是一个基于Chrome V8 引擎的 JavaScript 运行时环境，对于没饿浏览器都有自己的javaScript解析引擎，浏览器中的javascript引擎负责来解析和执行我们待执行的js代码，并且每个浏览器中都提供有内置的BOM、DOM这样的API函数，我们能够根据这些内置API函数编写出一些待执行的js代码，最后由我们的浏览器中的JavaScript引擎去执行。
不同的浏览器使用不同的JavaScirpt解析引擎：
浏览器 JavaScirpt解析引擎 Chrome —— V8 FireFox —— OdinMonkey Safri —— JSCore IE	—— Chakra 那么nodejs相对于浏览器而言，其知识一个后端的JavaScript运行环境而已，其js解析引擎基本上和浏览器的js解析引擎结构一模一样，只不过其是直接基于V8引擎 ，内置的API也和浏览器中是不一样的。
如何启动一个Vue项目：
1.Vue项目结构
一般我们拿到手的vue项目结构是这样子的（大致上是这样的）
2.我们要去下载Vue项目启动的依赖环境nodejs
我们进入Nodejs官网Node.js (nodejs.org)
选择自己需要的版本,竟可能选择后缀是LTS（长期维护版本）,其比较稳定
下载完成后，我们启动对应的exe文件，然后根据提示点击，安装到自己需要的目录下即可，并且该程序会帮我们自动配置好nodejs的环境变量（配置环境变量后，就可以直接在命令行中的任意文件目录中，通过命令启动当前配置的环境变量目录下所对应程序启动文件），如果需要自己去配置环境变量，可以去网上搜一下配置环境变量的方法。
之后我们可以在命令行中，通过node -v命令查看一下当前下载node-js的版本，如果成功显示版本号，表示当前node -js安装成功
3.配置npm的全局路径安装路径
npm（Node Package Manager）： Node.js包管理工具，NPM是Node.js标准的软件包管理器。在2017年1月时，NPM仓库中就已有超过 350000 个软件包，这使其成为世界上最大的单一语言代码仓库，并且可以确定几乎有可用于一切的软件包。它起初是作为下载和管理Node.js包依赖的方式，但其现在也已成为前端JavaScript中使用的工具。NPM是随同Node.js一起安装的包管理工具，能解决Node.js代码部署上的很多问题，常见的使用场景有以下几种：
允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的Node.js已经集成了NPM，所以要想使用NPM就得安装Node.js。
配置：
我们通过管理员身份运行命令行，在命令行中，执行下面的命令
npm config set prefix "D:\tool\Node.js" 说明：”“内为当前自己的node.js的目录 4.切换npm的淘宝镜像
由于npm在下载软件包的时候，默认是从国外进行下载，所以速度是比较慢的，因此我们可以为其配置国内的镜像，这样就可以快速下载我们需要的软件包。
配置的命令如下
npm config set registry https://registry.npm.taobao.org 4.安装Vue-cli（vue的脚手架文件）
我们通过npm去帮我们下载对应的Vue-cli文件
在命令行中执行如下命令
npm install -g @vue/cli 在安装完成后，我们可以通过如下指令查看一下我们当前安装的vue脚手架的版本号，如果安装陈宫了，就可以成功显示，如下图所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b44610789b32f1d0fcb7d65614c754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd336b8a7241f1eefec45709d66c3229/" rel="bookmark">
			JDBC链接MySql及查询操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：使用JDBC的准备工作
二：连接数据库的简单流程
2.1:注册驱动
2.2:获取连接
2.3:创建发送SQL语句对象
2.4:发送sql语句，并获取返回结果
2.5:结果集解析
​2.6:资源关闭
三：上述操作存在的问题及改进
3.1：注册驱动操作冗余
3.2:Statement语句的危险性
四：查询代码样例
一：准备工作 使用JDBC前需前往MySql官网下载JDBC提供的类文件，下载箭头所指文件并解压，在你的IDEA项目中创建lib文件，并将其解压后的.jar文件放入，并将其中jar文件导入你的工程文件模块即可。最后再创建一个自己的数据库(本篇用mydb作为样例)https://dev.mysql.com/downloads/connector/j/
安装成功后我选择创建一个名为"mydb"的数据库，其中有一个students表储存了学生信息
二：连接数据库的简单流程 大致分为以下6步：
2.1:注册驱动 使用registerDriver方法进行注册，
DriverManager.registerDriver(new Driver()); 2.2:获取连接 getConnection(String url,String user,String password)
Connection connection=DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/mydb","root","222222"); //url写法:"jdbc:数据库名://数据库ip，是本机就填127.0.0.1:端口(默认3306)/目标数据库" //本机例子:jdbc:mysql://127.0.0.1:3306/mydb 或可简写为 jdbc:mysql:///mydb 2.3:创建发送SQL语句对象 Statement statement=connection.createStatement(); 2.4:发送sql语句，并获取返回结果 String inf="select * from students;"; ResultSet resultSet=statement.executeQuery(inf); 2.5:结果集解析 其所返回的resultSet是一个将数据打包成的类，其中提供了许多定位数据的方法。.next方法会根据下一条的数据内容是否为空来返回boolean类型。.get参数()方法提供了使用脚标返回列元素,使用当前列名返回列元素这两种方法来返回数据。例如目前表中有这样的数据，并且数据解析代码如下
while(resultSet.next()){ int a=resultSet.getInt(1); String b=resultSet.getString("name"); int c=resultSet.getInt(3); String d=resultSet.getString("residence"); System.out.printf("%d %s %d %s\n",a,b,c,d); } 结果如下：
2.6:资源关闭 resultSet.close(); statement.close(); connection.close(); 三：上述操作存在的问题及改进 3.1：注册驱动操作冗余 通关观察DriverManager.registerDriver(new Driver());中的.register()方法和Driver()方法的源代码可见
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd336b8a7241f1eefec45709d66c3229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72b5c3da06c377adaf5419834cb8c1f/" rel="bookmark">
			【分享】Redis的五种基本数据类型和应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： Redis支持五种基本数据类型：
String（字符串类型）：可以是普通字符串，也可以是整数或浮点数值。可以设置过期时间；可以对字符串进行append、get、set、incr、decr等操作。Hash（哈希类型）：类似于一个数组，其中每个元素都是一个field和value的键值对。可以对整个哈希表或单个元素进行增删查改等操作。List（列表类型）：一个链表，链表中的每个节点都包含一个字符串。可以对链表头尾进行pop、push等操作。Set（集合类型）：一个类似于列表的无序集合，支持添加、删除、查找等操作。集合中每个元素都是唯一的。Zset（有序集合类型）：也是一个无序集合，与set不同的是每个元素都会关联一个分数，分数可以让集合中的元素按照一定规则排序。可以对集合中元素的分数进行增减等操作。 以上五种基本数据类型的特点及方法使用各有不同，可以根据具体需求进行选择。
字符串String类型： Redis中的字符串可以是任何二进制数据，例如JPEG图片或JSON对象等。字符串类型主要用于缓存、计数、限流等场景。
以下是Redis的String类型的一些特点：
Redis的String类型可以存储任何形式的字符串，包括二进制数据。Redis的String类型有着很高效的存储和访问速度，支持读、写、追加、删除等常规操作。Redis的String类型还支持一些特殊功能，例如可对指定字符串进行自增或自减操作，或者对字符串进行位操作等。 1.字符串 Redis中的字符串可以是任何二进制数据，例如JPEG图片或JSON对象等。字符串类型主要用于缓存、计数、限流等场景。
# 设置一个字符串 &gt; SET name "Alice" OK # 获取字符串 &gt; GET name "Alice" # 修改字符串 &gt; SET name "Bob" OK # 获取修改后的字符串 &gt; GET name "Bob" 2.整数 Redis的字符串也可以存储数字，它可以自增或者自减。这些操作都是原子性的，可以用于计数器、排行榜等场景。
# 将一个整数设置到key中 &gt; SET count 10 OK # 自增 &gt; INCR count 11 # 自减 &gt; DECR count 10 # 自增指定的值 &gt; INCRBY count 5 15 # 自减指定的值 &gt; DECRBY count 2 13 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b72b5c3da06c377adaf5419834cb8c1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b74a8e187ff0baa7ec075b3840c32f/" rel="bookmark">
			Python CV2 图片转为拼图 Puzzle，素材库这不就又丰富了~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import math import random import cv2 import numpy as np import base64 def convex_concave(): if random.random() &lt; 0.5: return -1 return 1 def random_blueprint(row, col): blueprint = [] # init for i in range(0, row): blueprint.append([]) for j in range(0, col): blueprint[i].append({ 'top': 0, 'bottom': 0, 'left': 0, 'right': 0 }) for i in range(0, row): for j in range(0, col): # top if i != 0: blueprint[i][j]['top'] = blueprint[i - 1][j]['bottom'] * -1 # bottom if i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b74a8e187ff0baa7ec075b3840c32f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08948663d86fa108d2ab9f3f55042749/" rel="bookmark">
			家用可燃气体探测器-旭华智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b43b7ba994ddb06ada45663a7fcb24b/" rel="bookmark">
			vue如何启动项目！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要启动Vue项目，您可以按照以下步骤进行操作：
1. 确保您的计算机已经安装了Node.js。您可以在命令行中输入`node -v`来检查是否已经安装了Node.js，并查看其版本号。
2. 使用以下命令安装Vue的命令行工具（Vue CLI）：
```
npm install -g @vue/cli
```
这将全局安装Vue CLI，它是一个用于创建和管理Vue项目的工具。
3. 创建一个新的Vue项目。在命令行中，导航到您希望创建项目的目录，然后运行以下命令：
```
vue create &lt;project-name&gt;
```
将`&lt;project-name&gt;`替换为您想要的项目名称。然后，Vue CLI会向您展示一些预设选项，您可以选择手动配置或选择预设模板。
4. 完成项目创建后，导航到项目目录：
```
cd &lt;project-name&gt;
```
5. 启动开发服务器。运行以下命令：
```
npm run serve
```
这将启动一个开发服务器，并编译和热重载您的Vue项目。您将在命令行中看到服务器的地址和端口号。
6. 打开浏览器并访问服务器地址。通常，默认地址是`http://localhost:8080`，但您也可以在命令行中查看实际的地址和端口号。
现在，您的Vue项目已成功启动，并可以在浏览器中进行访问和开发。您可以在项目的根目录中编辑代码文件，保存后浏览器将自动更新以显示更改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6beacd8a54783e4bb3a64a20c9c27ac/" rel="bookmark">
			C&#43;&#43;编程必备：掌握变量命名规则的终极指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++编程必备：掌握变量命名规则的终极指南 博主简介一、引言二、基础概念和原则2.1、变量命名的基本规则和限制2.2、选择有意义且易于理解的变量名称2.3、遵循常见的命名约定和惯例2.4、如何避免模糊或具有二义性的命名 三、命名风格和建议3.1、驼峰命名法 vs 下划线命名法3.2、类型前缀和后缀的使用规范3.3、使用缩写和首字母缩写的注意事项 四、变量类型和作用域4.1、命名局部变量和全局变量的最佳实践4.2、成员变量和类成员函数的命名规则4.3、命名常量和枚举值的推荐方式 五、高级技巧和建议5.1、命名空间和命名空间成员的命名5.2、命名模板类、函数和类型别名的指导原则5.3、使用注释来进一步解释变量名称的含义和用途 总结 博主简介 💡一个热爱分享高性能服务器后台开发知识的博主，目标是通过理论与代码实践的结合，让世界上看似难以掌握的技术变得易于理解与掌握。技能涵盖了多个领域，包括C/C++、Linux、Nginx、MySQL、Redis、fastdfs、kafka、Docker、TCP/IP、协程、DPDK等。
👉
🎖️ CSDN实力新星，CSDN博客专家
👉
👉我的博客将为你提供以下内容：
👉
💡1. 高性能服务器后台开发知识深入剖析：我将深入探讨各种技术的原理和内部工作机制，帮助你理解它们的核心概念和使用方法。
👉
💡2. 实践案例与代码分享：我将分享一些实际项目中的应用案例和代码实现，帮助你将理论知识转化为实际应用，并提供实践中的经验和技巧。
👉
💡3. 技术教程和指南：我将编写简明扼要的教程和指南，帮助初学者入门并逐步掌握这些技术，同时也为有经验的开发者提供深入的技术进阶指导。
👉
💡无论你是一个刚入门的初学者，还是一个有经验的开发者，我的博客都将为你提供有价值的内容和实用的技术指导。让我们一起探索高性能服务器后台开发的奥秘，共同成长！
一、引言 变量命名在C++编程中扮演着关键的角色。通过选择清晰、具有描述性的名称，并遵循编程规范，可以提高代码的可读性、维护性和可重用性，为自己和团队创造更好的开发体验和效。
代码可读性：良好的变量命名能够使代码更易于阅读和理解。通过使用清晰、描述性的变量名称，可以让其他开发人员迅速理解代码的意图和功能，减少阅读代码时的困惑和猜测。同时，一致的命名规范还可以帮助团队成员之间更好地协作。
代码维护性：合适的变量命名可以提高代码的可维护性。当您或其他人需要修改、扩展或调试代码时，良好的变量命名可以减少出错的可能性。具有自描述性的变量名称可以让您更容易追踪代码中的逻辑和数据流，减少引入bug的风险。
可重用性：使用恰当的变量命名可以增加代码的可重用性。当您将代码片段应用于不同的上下文时，有意义的命名可以使您更快地理解代码的含义，并在其他情况下重用它们，节省时间和精力。
文档化：良好的变量命名可以作为自文档化代码的一部分。通过选择具有描述性的名称，您可以在不添加大量注释的情况下传达变量的用途和含义。这有助于维护代码的文档，并使其他人更容易理解和使用您的代码。
符合规范：良好的变量命名遵循了一定的编程规范和约定。这不仅提高了代码的一致性，还使代码更易于与其他人分享和交流。符合规范的命名还可以减少错误和歧义，提高代码的质量和可靠性。
二、基础概念和原则 2.1、变量命名的基本规则和限制 C++变量命名具有重要性和作用，它们对代码的可读性、可理解性和可维护性起着至关重要的作用。
字符集：C++允许使用字母、数字和下划线来命名变量。变量名称必须以字母或下划线开头，不能以数字开头。
大小写敏感：C++区分大小写，因此"myVar"和"myvar"被视为不同的变量。
标识符长度：标准C++要求变量名的长度至少为一个字符，并且不能超过特定编译器的限制（通常为255个字符）。
保留字：不能使用C++中的保留字（例如if、for、int等）作为变量名。
合法命名示例：合法的变量名称示例包括"age"、“myVariable”、"my_var"等。
不推荐使用的命名方式：虽然在语法上是合法的，但应避免使用单个字母或无意义的变量名，因为这样会导致代码难以理解和维护。
规范约定：尽可能选择有意义且描述准确的变量名，以便让其他人能够轻松理解代码的含义。
命名风格：常见的命名风格包括驼峰命名法和下划线命名法。在团队合作中，应遵循统一的命名风格。
清晰明了：使用具有描述性的变量名可以提高代码的可读性，使其更易于理解和维护。
2.2、选择有意义且易于理解的变量名称 确保C++变量命名表达清晰和易于理解非常重要。
变量用途：选择与变量实际用途相关的名称，包括其表示的数据、功能或角色。
避免缩写：避免使用令人困惑的缩写或简写。选择完整单词来描述变量的含义，这样其他开发人员更容易理解代码。
使用自然语言：使用自然语言中具有相关性的词汇或短语。例如，如果变量表示购买商品的总价，可以将其命名为"totalPrice"。
显式数据类型：对于某些情况下需要明确指定数据类型的变量，可以在变量名中包含它们。例如，对于表示整数数量的变量，可以将其命名为"numItems"。
命名一致性：在整个代码中保持命名的一致性。相似概念的变量应该有相似的命名方式，这有助于提高代码的可读性。
避免单字母变量名：除非用于循环索引或其他特定情况，在大多数情况下应避免使用单个字母作为变量名。选择更具描述性的变量名。
注释配合：如果变量的用途不能直接从名称中清楚地理解，可以使用注释来提供更多的上下文和解释。
避免违反规则和限制：确保变量名遵循C++变量命名的规则和限制，如不以数字开头、不使用保留字等。
2.3、遵循常见的命名约定和惯例 C++变量命名通常遵循一些常见的命名约定和惯例，以提高代码可读性和一致性。
驼峰命名法：在驼峰命名法中，变量名首字母小写，后续每个单词的首字母大写，不使用下划线。例如：myVariable, totalAmount。
下划线命名法：在下划线命名法中，单词间用下划线分隔。变量名通常使用全小写字母。例如：my_variable, total_amount。
类型前缀：有时可以在变量名中使用类型前缀，以指示变量的数据类型。这有助于增加代码的清晰度。例如：strName（字符串类型的名称），nCount（整数类型的计数）。
合理缩写：在变量名中使用合理的缩写是可以接受的，但要确保被广泛接受并易于理解。避免使用令人困惑的缩写。
注意命名空间：如果在命名中使用命名空间，应该使用命名空间限定符来表示层次结构。例如：myNamespace::myVariable。
保持一致性：在整个代码中保持命名的一致性非常重要。相似概念的变量应该有相似的命名方式，这有助于提高代码的可读性和维护性。
避免过长的变量名：尽量避免过长的变量名，以免影响代码的可读性。选择简洁而具有描述性的名称。
2.4、如何避免模糊或具有二义性的命名 明确表达意图：选择能够清晰表达变量用途和含义的名称。避免使用过于泛化或模糊的词汇，而是选择更具体和确切的词汇。
避免常见缩写：避免使用广泛使用但可能产生歧义的常见缩写。确保缩写在上下文中明确且易于理解。如果必须使用缩写，应在注释或文档中进行解释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6beacd8a54783e4bb3a64a20c9c27ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a22bdd35682baadf6107f828fa9f338/" rel="bookmark">
			Linux系统中ps命令用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ps命令是Linux系统中用于查看当前运行的进程状态的命令。它提供了许多选项和参数，用于显示不同类型的进程信息。下面是ps命令的常用选项和用法的详细解释：
1、ps命令的基本用法 ps: 显示当前终端会话中属于当前用户的进程列表。ps -ef: 显示系统中所有进程的列表，包括其他用户的进程。ps -aux: 显示详细的进程信息，包括CPU和内存使用情况等。 2、常用的ps命令选项 -e选项：显示所有进程，而不仅仅是当前终端会话的进程。这对于查看整个系统的进程列表非常有用。-f选项：使用全格式显示进程信息。全格式显示了更多的列，包括父进程ID（PPID）、进程状态、CPU使用率（%CPU）、内存使用率（%MEM）等。-l选项：显示长格式的进程信息。长格式显示了更多的信息，例如进程命令行、进程状态（S）、进程的会话ID（SID）等。-u选项：显示与指定用户相关的进程信息。可以通过指定用户名来限制显示的进程列表。-p选项：显示指定进程ID的进程信息。可以通过指定PID来查看特定进程的详细信息。-o选项：自定义输出格式。使用该选项可以指定要显示的列和排序方式。例如，ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem会显示进程ID、父进程ID、命令行、内存使用率和CPU使用率，并按内存使用率降序排序。 3、常用的ps命令示例 ps -ef | grep &lt;进程名&gt;：查找指定进程名的进程。ps -ef | grep -v grep | grep &lt;用户&gt;：查找指定用户的进程。ps -ef --forest：以树形结构显示进程和它们的父进程。ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head：按内存使用率排序显示前几个进程的信息。 4、更多ps命令的选项和用法，请参考ps命令的帮助文档 man ps：查看ps命令的手册页。ps --help：显示ps命令的简要帮助信息。 5、对输出结果进行解释 该命令输出了系统中所有以python关键字开头的进程。解释如下：
第一行输出的进程是由/usr/sbin/tuned命令启动的。这是一个系统调优工具，它会根据系统的配置和需求自动调整系统的参数以提高性能。该进程的进程ID（PID）为921，父进程ID（PPID）为1，即init进程。第二行输出的进程是由main_5001.py脚本启动的。这是一个Python脚本，由Python 3解释器运行。该进程的PID为1012，PPID为1，即init进程。 总结来说，第一行输出的进程是系统调优工具的一部分，而第二行输出的进程是一个Python脚本的实例。
参数具体解释：
root：这是进程的所有者用户名，表示这两个进程都是以root用户身份运行的。921和1012：这是进程的ID（PID），用于唯一标识每个正在运行的进程。1：这是父进程的ID（PPID），表示这两个进程的父进程都是init进程。init进程是所有进程的祖先进程。0：这是进程的优先级，表示这两个进程都没有明确指定优先级。5月14和7月01：这是进程的启动时间，分别表示进程在5月14日和7月01日启动。?：这是进程的TTY（终端）信息，表示这两个进程没有关联到任何终端。00:08:22和00:00:01：这是进程的运行时间，分别表示进程已经运行了8小时22分钟和1秒钟。/usr/bin/python2和python3：这是进程的可执行文件路径，分别表示第一个进程是使用Python 2解释器运行的，第二个进程是使用Python 3解释器运行的。-Es /usr/sbin/tuned -l -P和main_5001.py：这是进程的命令行参数和参数值，分别表示第一个进程是以这些参数运行的系统调优工具，第二个进程是以这个参数值运行的main_5001.py脚本。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e7e82510c703c27adc62dbe748d5b3/" rel="bookmark">
			C语言分支与循环语句全面详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天介绍分支与循环语句，希望大家看过会轻松玩转分支与循环语句！
1.C语言中的控制语句 控制语句用于控制程序的执行流程，以实现程序的各种结构方式（C语言支持三种结构：顺序结构、选择结构、循环结构），它们由特定的语句定义符组成，C语言有九种控制语句。
可分成以下三类：
条件判断语句也叫分支语句：if语句、switch语句；循环执行语句：do while语句、while语句、for语句；转向语句：break语句、goto语句、continue语句、return语句。 2.分支语句（选择结构） 人生中常会面临选择。比如现在你是一位大学生，一位美女选择了你，而你可以选择和她在一起，也可以选择努力学习，为自己的将来做准备。那么你会选择哪个呢？果真很难选择
2.1 if语句 （1）if语句的语法结构
每个if(表达式)语句里放的都是表达式，如果表达式为真，则执行下边的语句，如果不是真，则判断下一个分支语句。
C语言里：0表示假，非0表示真
注意：
if语句一个分支只能出现一次，且在最前放。（一个分支的开始）
else在if语句中只能出现一次而且只能出现在if语句的最后。
else语句可以出现多次，且总是在else语句的前面。（一个分支的结束，因为else已经包含了除前面if，else if限定的条件之外的所有条件。因此这个分支结束。）
用代码给大家实现一下：
#include&lt;stdio.h&gt; int main() { int choose = 0; printf("你选则美女（1）还是好好学习（0）\n"); scanf("%d",&amp;choose); if(1 == choose) { printf("你的未来未知\n"); } else if(0 == choose) { printf("你的未来光明\n"); } return 0; } 这里剩下的就看大家的选择了。
（2）悬空else问题
大家认为这个代码的结果是什么呢？可以思考一下。
#include &lt;stdio.h&gt; int main() { int a = 0; int b = 2; if(a == 1) if(b == 2) printf("hehe\n"); else printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e7e82510c703c27adc62dbe748d5b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1706a6275c2c074c8b3ffccbfc14b6/" rel="bookmark">
			资深测试整理，APP专项测试方法总结，看这篇就够了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 APP专项测试
1、网络测试
可使用抓包工具辅助网格测试推荐：fiddler，Charles
网络切换：
2G-3G-4G-wifi-网络信号差–无网
网络信号弱：
关注是否出现ANR、crash
2、中断测试
意外中断：
来电；短信；闹铃；断网；断电；视频聊天；语音聊天；无响应；系统更新提醒；内存不足提醒；其他app的消息通知
任务切换：
锁屏；切换到其他应用
3、兼容测试
不同的机型；
不同的操作系统版本；
注意：app兼容测试方法
手工测试（一般适用于用户量小、且对兼容测试要求不高的项目）；
云测试平台（一般适用于用户量大、且对兼容测试要求高的项目）；
目前市场上主流云测试平台包括：
腾讯云测：http://wetest.qq.com
百度云测：http://mtc.baidu.com
阿里云测：http://mqc.aliyun.com/
testin云测：https://www.testin.cn/
4、性能测试
客户端性能测试：
流量消耗；耗电量；CPU；内存消耗
服务器端性能测试：
5、UI测试
横竖屏切换；
手势操作：
长按呼出菜单；双手捏合放大放小；滑动
输入信息界面自适应键盘遮挡；
其他UI测试要点与web基本相同；
6、安全测试
密码不明文显示；
密码框不支持复制；
敏感信息加密传输；
多次登录失败，锁定账号；
登录成功后，长时间不操作软件，session是否丢失，提示重新登录；
权限控制；
SQL注入；
7、稳定性测试（使用monkey完成）
8、安装测试
安装前：
干净的安卓系统；
装有旧版本的安卓系统；
装有本版本的安卓系统；
装有最新版本的安卓系统（需要安装旧版本）；
装有杀毒软件的安卓系统；
装有同行业其他软件的安卓系统；
内存不足的安卓系统；
安装过程中：
意外中断；
许可确认提示；
是否显示安装进度；
安装后：
软件是否可以正常启动；
检查安装文件是否齐全；
检查许可权限；
统计安装总时长；
9、升级测试
自动升级；
弹出是否升级的提示，人工选择；
升级过程中意外中断；
升级过程中内存不足；
升级后数据是否同步；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b1706a6275c2c074c8b3ffccbfc14b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c23caec8641face43bfaa6df4734e37/" rel="bookmark">
			Thingsboard编译 Failed to execute goal com.github.eirslett:frontend-maven-plugin:1.12.0:yarn (yarn pkg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先放一波编译成功的图，久经波折啊
一定不要没编译就在IDEA打开项目，在cmd窗口编译完再打开。
先放一个maven仓库镜像，这一个就够了。
&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt; 在下面这个地方卡了最久 Failed to execute goal com.github.eirslett:frontend-maven-plugin:1.12.0:yarn (yarn pkg) on project web-ui: Failed to run task: 'yarn run pkg' failed. org.apache.commons.exec.ExecuteException: Process exited with an error: 1 (Exit value: 1)
往上翻可以看到
Error: EBUSY: resource busy or locked, rename 'D:\thingsboard3.5\thingsboard\msa\web-ui\target\thingsboard-web-ui-win.exe' -&gt; 'D:\thingsboard3.5\thingsboard\msa\web-ui\target\package\windows\bin\tb-web-ui.exe'
意思是系统繁忙，需要手动复制一个thingsboard-web-ui-win.exe文件到thingsboard\msa\web-ui\target\package\windows\bin\目录下，并重命名为tb-web-ui.exe
重命名后再次执行mvn clean install -DskipTests命令
另一个相似错误，是因为c盘用户下的.pkg-cache\v3.4文件夹下没有fetched-v16.15.0-linux-x64和fetched-v16.15.0-win-x64文件，可以在网盘链接中获取。
链接：https://pan.baidu.com/s/1oEyWpHGxLtPSikmQ-41oQw?pwd=cldg Failed to execute goal com.github.eirslett:frontend-maven-plugin:1.12.0:yarn (yarn pkg) on project web-ui: Failed to run task: 'yarn run pkg' failed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c23caec8641face43bfaa6df4734e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc9f7bf355afc80c545d5b9001857d5/" rel="bookmark">
			Mysql分区表----分类、优势、特点、优点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		范围分区（Range Partitioning、哈希分区（Hash Partitioning）列
表分区（List Partitioning）、键值分区（ Key partition ）
文章目录 mysql分区表概述：MYSQL分区表简单而言就是将一张大的表按照一定的规则划分为物理上的很多小表,而逻辑上仍然维持一个大表.对应用是透明的. mysql分区表分类范围分区（Range Partitioning哈希分区（Hash Partitioning）列表分区（List Partitioning）键值分区（ Key partition ） mysql分区表的使用环境、特点使用环境特点 分区的最大优势 分区优点分区优点之- 提高访问速度分区优点之- 提高数据可用性 分区字段与分区索引的简单规则 mysql分区表 概述：MYSQL分区表简单而言就是将一张大的表按照一定的规则划分为物理上的很多小表,而逻辑上仍然维持一个大表.对应用是透明的. mysql分区表分类 范围分区（Range Partitioning 哈希分区（Hash Partitioning） 列表分区（List Partitioning） 键值分区（ Key partition ） mysql分区表的使用环境、特点 使用环境 mysql在以上三种情况下可以进行表分区
特点 1、大数据对象 (表, 索引)被分成小物理段当分区表建立时，记录基于分区字段值被存储到相应分区。 2、分区字段值可以修改。(row movement enabled)分区可以存储在不同的表空间 3、分区可以有不同的物理存储参数 分区的最大优势 性能
• Select和DML操作只访问指定分区
• 并行DML操作
• Partition-wise Join
可管理性：数据删除，数据备份
• 历史数据清除
• 提高备份性能
• 指定分区的数据维护操作
可用性
• 将故障局限在分区中
• 缩短恢复时间
分区目标优先级
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cc9f7bf355afc80c545d5b9001857d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d5f4614b8f40c8c1bbc976da886dde/" rel="bookmark">
			基于策略路由的双线网络接入设计（完整文档&#43;ensp拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘 要
随着计算机网络爆发式的增长，个人以及公司的网络需求正在急剧上升，给所要网络的质量也在不断增长，所以为改善个人以及公司的用网问题，使用策略路由可以让网络进行划分，从而提高网络质量。
我们通过使用双线网络来使网络链接的稳定性以及安全性得到提升，通过在网络出口设置两条出口链路，这样能增加网络出口的宽带，又能让公司网络出口链路多元化，这样就会实现网络流量的负载均衡，减少网络负担，从而提升网络质量。
本论文将从策略路由的双线网络接入方案的规划与设计入手，对策略路由的双线网络接入方案的规划与设计进行总体规划和分析。本网络系统涉及到需求分析，网络总体设计，组网技术与实现，无线设计等模块，基于华为模拟器，运用划分VLAN，DHCP自动获取IP，OSPF协议，VPN配置等技术，对策略路由的双线网络接入规划功能模块进行划分、设计和系统的实现。
不同用户会对所需要的配置有不同的要求，策略路由可以根据他们的要求进行路由以及转发，与此同时对可以的规则进行抓包，他也可以根据人们的需求来设置指定的策略路由，为此极大的是策略路由变得更加灵活和方便控制。同时在对路由表不改变的情况下灵活改变。使用ENSP模拟软件模拟网络环境和策略路由。在实验环境中，分别网络仿真环境和策略路由，并运行了相应的测试以验证TCP流量分流的有效性。
关键词：策略路由 双线网络接入 设计与部署
Abstract
With the explosive growth of computer networks, the demand for personal and corporate networks is rising rapidly, and the quality of the networks to be delivered is also growing, so in order to improve the use of networks by individuals and companies, using policy routing can divide the network and improve the quality of the network.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d5f4614b8f40c8c1bbc976da886dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a6db2ec0caedb79ea9f929aaf7a8e6/" rel="bookmark">
			基于ensp大学网络规划与设计（完整文档&#43;ensp拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘 要
本课题已广西医科大学的网络规划设计为研究对象，并且有针对性地在内部网络、外部网络、服务器网络、网络安全这四个方面进行分析，为校园网络规划设计的具体内容为相关研究与实务应用提供参考。校园网建设是高校信息化建设的重中之重,本文从校园网拓扑结构、网络冗余、局域网的技术和广域网的技术以及网络安全入手,规划和设计了以万兆跨校区冗余链路联接,千兆光纤到所有大楼,百兆到桌面的高速、安全、可靠、可控可管的校园网络。本设计需要在详尽的需求分析基础上，为广西医科大学设计一个功能完善、安全稳定、高性能的园区型局域网，要求即将建成的网络系统能够为学校师生提供安全高效、稳定可靠的基础网络服务，以满足学校教学和管理等工作的各种需求。设计完成后给出网络系统需求分析和详细的网络系统设计说明书，并给出规范的逻辑拓扑结构图、虚拟子网划分及地址分配方案、设备选型等。并使用模拟器搭建一个该设计的模型网络，以证实该设计的可行性，同时给出主要设备的配置代码，测试网络基本的连通性。
关键词：校园网络、可靠、局域网
Abstract
This topic has taken the network planning and design of Guangxi Medical University as the research object, and analyzed the internal network, external network, server network and network security, so as to provide a reference for the specific content of campus network planning and design and the related research and practical application. The construction of campus network is the most important part of the information construction in Colleges and universities.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1a6db2ec0caedb79ea9f929aaf7a8e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217464e98ee001da67fc17b732977dd7/" rel="bookmark">
			基于ensp校园网络（完整文档&#43;ensp拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘要 随着21世纪信息化程度的不断提高，教育的形式需要进行改革创新，亟待需要提高教育资源的利用程度。而校园网作为满足信息化教学环境的一项基础设施，是教育信息化建设的重要组成部分，成为高校信息化教育、网络化教学与管理的重要基础。它为师生获得更多的教育资源，丰富教育手段提供了重要的平台，是全面实现素质教育的重要手段。由计算机、网络设备和软件组成的校园网是为学校教育教学和管理服务的集成应用系统，它是校园所有计算机及附属设备互联运行的网络，通过广域网与科教网的互联实现信息交流和资源共享。
本项目以阜蒙县育才高中的网络建设为背景，研宄利用网络相关技术构建一个性能优越、具有较高稳定度、安全性的网络平台。从层次化结构设计、出口设计、地址设计、安全设计进行规划设计。在本文中采用路由技术，用于虚拟局域网的VLAN技术、用于地址隐藏的地址转换技术、用于网络结构规划的拓扑技术、网络安全技术。构建一个高效稳定的网络平台。通过按端口地址VLAN的划分、汇聚层交换机、核心层交换机的配置、防火墙策略配置、地址转换的使用、出口路由器的配置、无线网络的规划与配置，通过测试方案，显示所设计和实现的网络平台达到了预期效果。
关键词：校园网；网络规划；网络技术
ABSTRACT
With the continuous improvement of information level in the 21st century, the form of education needs to be reformed and innovated, and the utilization of educational resources needs to be improved. Campus network, as an infrastructure to meet the information-based teaching environment, is an important part of the education information construction and an important foundation for the information-based education, network-based teaching and management in Colleges and universities.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217464e98ee001da67fc17b732977dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafcefdd969a75354ff02c189e3f46a9/" rel="bookmark">
			基于OSPF技术的某企业网络设计（完整文档&#43;ENSP拓扑图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘 要
全国经济的飞速发展，信息化的飞速发展，标志着信息时代的到来。随着科技的发展和网络的普遍存在，用户对网络的需求和要求越来越高，不仅仅只是要求能够满足用户能够上外网，能够共享网络资源，在实现这些基础上还需要保证网络的稳定和安全性。对于一些对网络比较敏感的企业或用户，对网络的要求较高，对于网络的稳定性和安全性也有较高的要求。
这次我的毕业设计主要对网络规划与设计，以企业网络为背景，对某个中型企业网络进行规划设计，该企业总部在南京，在常州有一个分公司，需要实现总部和分公司能够访问外网，能够让分公司内的用户或主机访问总部服务器的资源，并且保证数据的安全性。总部可能有多个部门，需要让有些部门不能访问一些重要的部门，限制一些部门之间的连通性。网络拓扑设计用经典的接入层和核心层，接入层连接用户终端PC、打印机和服务器；总部内部用户网关配置在核心层交换机上，部署两台核心交换机通过集群术虚拟化成一台，核心层交换机连接出口路由器，与路由器间配置动态OSPF路由，实现网络的连通性。分公司网络拓扑设计用二层结构（接入层、核心层），接入层连接用户终端、核心层配置用户网关。总部和分公司之间部署VPN，在internet公共网络基础上通过配置IPsec VPN实现总部与分公司之间的相互访问。
网络设计仿真通过华为ensp模拟器仿真，添加一些网络设备二层交换机、三层交换机、路由器、PC和服务器进行组网连接。通过相关配置实现网络的连通性，并进行网络相关测试。
关键词：企业网；网络规划；IPsec VPN
ABSTRACT
The rapid development of national economy and informatization marks the arrival of the information age. With the development of science and technology and the widespread existence of the network, the demand and requirements of users for the network are more and more high, not only to meet the requirements of users can be on the external network, to share network resources, in order to achieve these on the basis of the need to ensure the stability and security of the network.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bafcefdd969a75354ff02c189e3f46a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96add34e449b0633ac49e8fcbf39fbdf/" rel="bookmark">
			基于SSL VPN技术的中小企业网络接入设计与实现（完整文档&#43;思科拓扑图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘 要
随着网络技术的高速发展,拥有多个异地分支机构的企业在其信息化建设中,必须具备良好的移动办公能力和需求, 虚拟专用网(VPN) 是通过公共网络建立的一条临时的、安全的连接，相比传统方式的专线租赁，成本更低，此外利用隧道、加密技术，可以更好地保证信息在公司内网上传递的安全性。企业员工在基于Internet或4G网络下能随时异地访问企业内部网络,高效开展各类办公业务.SSL VPN是远程用户访问企业内部数据最快、最安全、最有效的技术.用户可以通过其快捷安全地实现远程办公,帮助企业提高生产力,增强网络安全.同时也可以降低企业的管理和运维成本。
本文介绍了VPN的基本原理和几种重要的实现技术。分析对比了SSL VPN 和IPsec VPN的优缺点，说明如何使用SSL VPN技术构建企业内联网。概述了SSL VPN技术,针对SSL VPN网络技术在企业信息系统中的应用进行了分析与研究,旨在为了利用SSL VPN技术来解决大中型网络应用中存在的不足,以确保企业信息系统的安全。
使用SSL VPN构建企业网络，员工出差或者在家就可以拨号连入公司内部网络，进行数据之间安全的进行传递，应用前景广阔，并且对安全性的要求更高，对实现远程办公的行为更加方便和稳定。
关键词： SSL 企业 安全 隧道 网络
Abstract
With the rapid development of network technology, enterprises with multiple branches in different places must have good mobile office ability and demand in their information construction. Virtual private network (VPN) is a temporary and secure connection established through public network.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96add34e449b0633ac49e8fcbf39fbdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208e771664f415a1103d25be1c9e36cc/" rel="bookmark">
			TIOBE 2023年7月编程语言排行榜:C&#43;&#43;即将超越C!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TIOBE统计数据（2023年7月）
TIOBE Index编程社区指数是编程语言流行度的一个指标。评级基于全球熟练工程师的数量、课程和第三方供应商的数量。Google、Bing、Yahoo!、维基百科、亚马逊、YouTube 和百度等流行搜索引擎用于计算评级。
七月头条：C++即将超越C
几个月前，编程语言C++声称在TIOBE索引中排名第3（以牺牲Java为代价）。
但C++还没有完成它的崛起。
C似乎是它的下一个受害者。
目前，两者之间的差距仅为0.76%。
除此之外，本月还有其他一些有趣的举动。JavaScript 达到位置 #6，这是历史最高点。
Matlab，Scratch和Rust也分别在#10，#12和#17的位置上匹配了他们的历史最高记录。
在TIOBE指数的其他地方，我们看到COBOL在很长一段时间后重新进入前20名，而Julia正在认真接近它
-- Paul Jansen TIOBE Software 首席执行官 --
（1）2023年7月的编程语言流行度指数排行 （2）编程语言多年流行回顾（年度编程语言） （3）C/C++工作需求占比
距离 C 的第一次发布已经过去了 50 年，距离后来首次被命名为“C with Classes”的 C++ 的出现也已经过去了 37 年。在这个漫长的时间窗口中，C/C++ 通过定期添加和改进语言保持了其受欢迎程度。
C/C++在行业中的使用被广泛扩展，在游戏、办公软件、图形处理、网站、搜索引擎、操作系统、图形界面层、关系型数据库、浏览器、邮件客户端、软件开发集成环境/IDE、编译器、3D 引擎、Web Servers （网页服务）、CD/DVD 刻录、媒体播放器、和许多其他方面找到。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/71/">«</a>
	<span class="pagination__item pagination__item--current">72/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/73/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>