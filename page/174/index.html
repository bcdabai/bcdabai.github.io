<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597c769bca55384ecb69ac3676ae473d/" rel="bookmark">
			人机交互-任务3：命令语言交互界面的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 任务目的实验内容方案设计核心代码运行结果完整项目+成品下载 任务目的 (1) 通过人机界面的显示风格和用户操作方式等内容的学习，帮助学生了解界面设计的主要内容。
(2) 使用掌握的计算机语言完成命令语言交互界面的设计，充分考虑以用户为中心的设计理念。进一步体会命令语言交互界面设计中的重要因素。
实验内容 任务1：文本交互界面的设计使用C语言完成。
编写程序，输入若干个按由小到大的整数（可能有重复数），保存到数组中，利用循环删除所有重复的值，使相等的数只保留一个。
在程序设计中，要实现程序的模块化设计。在界面设计中，要解释说明如何是以用户为中心进行设计的。
方案设计 （1）算法设计：本程序包含三个算法。一是根据用户需要输入并创建数组；二是基础的使用相邻去除法来去除数组中重复元素；三是了让程序更具有可用性使用了排序算法中较为简洁的冒泡排序对数组中的数字进行简单排序。
（2）流程描述：运行程序后用户根据文字提示输入数组元素个数，能满足不同元素个数都能使用的效果；数组创建完成后选择两个功能，根据提示输入以空格形式隔开的随意整数，敲击回车键后，显示运行结果。运行结果分别输出排序后数组、排序后删除重复值后的数组。
核心代码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int del(int a[],int COUNT){ //删除重复值函数 int m,count=COUNT,k; for(k=COUNT-1;k&gt;0;k--){ if(a[k]==a[k-1]) { for(m=k-1;m&lt;COUNT-1;m++) a[m]=a[m+1]; count--; //删除重复值 } } return count;	} void sort(int a[], int length){ //排序数组函数 int i, j, temp; for(i = 0; i &lt; length; ++i){ for(j = i + 1; j &lt; length; ++j){ if(a[j] &lt; a[i]){ //如果后一个元素小于前一个元素则交换 temp = a[i]; a[i] = a[j]; a[j] = temp;}}} printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597c769bca55384ecb69ac3676ae473d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b9cb923c79b88255293a2fc1c02af7/" rel="bookmark">
			Action client not connected: franka_state_controller/follow_joint_tr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(base) bionic@bionic-DL:~$ rostopic list /attached_collision_object /camera/depth_registered/points /collision_object /execute_trajectory/cancel /execute_trajectory/feedback /execute_trajectory/goal /execute_trajectory/result /execute_trajectory/status /franka_control/error_recovery/cancel /franka_control/error_recovery/feedback /franka_control/error_recovery/goal /franka_control/error_recovery/result /franka_control/error_recovery/status /franka_state_controller/F_ext /franka_state_controller/franka_states /franka_state_controller/joint_states /franka_state_controller/joint_states_desired /joint_states /joint_states_desired /move_group/cancel /move_group/display_contacts /move_group/display_planned_path /move_group/feedback /move_group/filtered_cloud /move_group/goal /move_group/monitored_planning_scene /move_group/ompl/parameter_descriptions /move_group/ompl/parameter_updates /move_group/plan_execution/parameter_descriptions /move_group/plan_execution/parameter_updates /move_group/planning_scene_monitor/parameter_descriptions /move_group/planning_scene_monitor/parameter_updates /move_group/result /move_group/sense_for_plan/parameter_descriptions /move_group/sense_for_plan/parameter_updates /move_group/status /move_group/trajectory_execution/parameter_descriptions /move_group/trajectory_execution/parameter_updates /pickup/cancel /pickup/feedback /pickup/goal /pickup/result /pickup/status /place/cancel /place/feedback /place/goal /place/result /place/status /planning_scene /planning_scene_world /position_joint_trajectory_controller/command /position_joint_trajectory_controller/follow_joint_trajectory/cancel /position_joint_trajectory_controller/follow_joint_trajectory/feedback /position_joint_trajectory_controller/follow_joint_trajectory/goal /position_joint_trajectory_controller/follow_joint_trajectory/result /position_joint_trajectory_controller/follow_joint_trajectory/status /position_joint_trajectory_controller/state /rosout /rosout_agg /rviz_bionic_DL_12366_768688103650989075/planningscene_planning_scene_monitor/parameter_descriptions /rviz_bionic_DL_12366_768688103650989075/planningscene_planning_scene_monitor/parameter_updates /rviz_visual_tools /rviz_visual_tools_gui /tf /tf_static /trajectory_execution_event 报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0b9cb923c79b88255293a2fc1c02af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56817c1a03927ab1fed583f302ee294a/" rel="bookmark">
			LVGL学习记录：按键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按键按下加一 程序
#include &lt;lvgl.h&gt; #include &lt;TFT_eSPI.h&gt; /*If you want to use the LVGL examples, make sure to install the lv_examples Arduino library and uncomment the following line. #include &lt;lv_examples.h&gt; */ // #include &lt;lv_demo.h&gt; #define LV_USE_LOG 1 TFT_eSPI tft = TFT_eSPI(); /* TFT instance */ /*Change to your screen resolution*/ static const uint32_t screenWidth = 320; static const uint32_t screenHeight = 240; static lv_disp_draw_buf_t draw_buf; static lv_color_t buf[ screenWidth * 10 ]; #if LV_USE_LOG !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56817c1a03927ab1fed583f302ee294a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e76ad11cd44709fb5b0b260ddf08fa/" rel="bookmark">
			ESP8266作为无线串口设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在之前做的一版设备，用的蓝牙做的无线串口，但是发现会有数据传输错误的情况，所以在改进设备的时候想着把蓝牙换成WIFI模块看一下效果，这里记录一下，ESP8266的配置过程。
ESP8266作为无线串口设置 ESP8266的特性ESP8266的配置1、设置WIFI模式2、重启生效3、连接路由器4、设置上电自动连接IP进行透传5、查询模块IP6、在电脑上使用网络助手，创建一个server7、连接到server8、开启透传模式9、开始透传10、退出透传模式（想要将wifi模块当做无线串口使用，不要进行这个操作） ESP8266的特性 ATK_ ESP8266 模块支持STA/AP/STA+AP三种工作模式。
◆STA模式: ESP8266模块通过路由器连接互联网，手机或电脑通过互联网实现对设备的远程控制。
◆AP模式:默认模式ATK_ESP8266模块作为热点，实现手机或电脑直接与模块通信，实现局域网无线控制。
◆STA+AP模式:两种模式的共存模式，(STA模式)即可以通过路由器连接到互联网，并通过互联网控制设备; (AP模式)也可作为wifi热点，其他wifi设备连接到模块。这样实现局域网和广”域网的无缝切换，方便操作。
ESP8266的配置 1、设置WIFI模式 AT+CWMODE=1 2、重启生效 AT+RST 3、连接路由器 AT+CWJAP="HUAWEI-XNNCV3_HiLink","1234567890" 4、设置上电自动连接IP进行透传 如果需要模块上电自动连接到某个IP并进入透传模式，这个时候需要在模块连接到路wifi热点之后，发送AT+SAVETRANSLINK=1,“192.168.1.xxx”" ,8000,“TCP”,设置模块为上电自动连接到TCP Server: 192.168.1.xxx， 8000，并进入透传模式。当发送AT+SAVETRANSLINK指令后，模块断电再上电会自动进入透传模式，此时发送AT指令模块是不会回复的(即使透传的服务器不存在，模块也会进入透传模式的)。模块要恢复到AT指令模式参考第10步先退出透传模式，然后勾选发送新行，再发送“AT+SAVETRANSLINK=0”， 这样上电模块就不会再.上电进入透传了。
AT+SAVETRANSLINK=1,"192.168.3.24",8000,"TCP" 5、查询模块IP AT+CIFSR 6、在电脑上使用网络助手，创建一个server 7、连接到server AT+CIPSTART="TCP","192.168.3.24",8000 8、开启透传模式 AT+CIPMODE=1 9、开始透传 AT+CIPSEND 连接成功！！
10、退出透传模式（想要将wifi模块当做无线串口使用，不要进行这个操作） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e861eda5659b14cda258df1edc263b/" rel="bookmark">
			网络编程问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、无线传输方式
二、网络编程VS进程通信 三、怎么才能实现网络通信，需要那些支持
1、通信设备
2、 通信协议
四、什么是通信协议，有什么作用
五、window和Linux的网络协议模型和作用
1、Windows七层网络模型
2、 协议栈为什么要分层？
六、 什么是IP地址VS mac地址
七、公网ip和私网ip
1、公网ip（广域网通信）
2、私网ip（局域网通信）
八、子网掩码的作用
九、如何解决IP地址荒
1、问题提出
2、 如何解决IP地址荒？
3、IPV4和IPV6的区别
十、NAT技术
十一、什么是域名
十二、什么是端口号
十三、TCP和UDP的区别
十四、TCP协议如何实现可靠传输
十五、TCP传输协议的优缺点
1、优点 传输安全性，可靠，通过严格的报文格式和传输方式进行控制 2、缺点 传输效率慢，实时性差，只能进行一对一方式的传输，并且实现方式困难，对资源的要求高
3、应用场景
十六、UDP传输协议的优缺点
1、优点
2、缺点
3、 应用场景
十七、TCP流量控制
十八、TCP拥塞控制
十九、 拥塞控制 VS 流量控制 二十、TCP协议的三次握手和四次挥手
1、三次握手
1、实现过程
2、存在的缺点
2、 四次挥手
二十一、抓包工具Wireshark的作用
1、概念 2、工作原理：
二十二、什么是网络编程
二十三、TCPC/S服务器的实现
1、TCP服务器的实现过程
2、TCP客户端的实现过程
二十五、UDP C/S实现
1、概念（相当于两个客户端）
2、UDP通信过程
二十四、UDP的广播和组播
1、广播
2、组播
二十五、C/S架构&amp;B/S架构
二十六、服务器模型
1、 概念
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4e861eda5659b14cda258df1edc263b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17171df60df15e3ec5923d7ef653b9c6/" rel="bookmark">
			Mac补充操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在线下载 curl -O https://download.sublimetext.com/Sublime%20Text%20Build%203143.dmg 如果报错"curl: (35) Server aborted the SSL handshake"
那么加上参数--insecure即可,如下
curl -O --insecure https://download.sublimetext.com/Sublime%20Text%20Build%203143.dmg 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b24b4d8fdff2de4355d1b58aa71bae2/" rel="bookmark">
			Springboot秒杀项目，前端经过MD5之后的数据与后端经过MD5之后的数据不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot秒杀项目，前端经过MD5之后的数据与后端经过MD5之后的数据不一致 后端代码，MD5Util前端代码 login.html前后端得到的经过之后不一致的原因 后端代码，MD5Util package com.wyf.seckill.util; import org.apache.commons.codec.digest.DigestUtils; /** * @author: wyf * @date:2022/1/9 17:50 */ public class MD5Util { public static String md5(String str){ return DigestUtils.md5Hex(str); } private static final String salt = "1a2b3c4d"; //输入的密码转化为表单的密码 //千万要注意：str = “” + .... 等号后面千万不要忘记有一个空字符串，否则会导致前后端产生的formPass不一致 public static String inputPassToFormPass(String inputPass){ String str = salt.charAt(0) + salt.charAt(2) + salt.charAt(4) + inputPass + salt.charAt(1) + salt.charAt(3) + salt.charAt(5); return md5(str); } //将表单提交的密码转化为数据库密码 public static String formPassToDbPass(String formPass, String saltDb){ String str = saltDb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b24b4d8fdff2de4355d1b58aa71bae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb0de1e097b69acb33bf61031e733c08/" rel="bookmark">
			如何用gitee的pull request交作业？网页端5步轻松完成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的老师喜欢用gitee接收学生的作业，这对于没用过的同学来说令人头大，而百度的一些方法还需要下载各种工具，很烦，下面分享一下在网页端pull request的方法，5步轻松搞定。
1. 找到老师的项目 进到老师的仓库页面，点进你要交作业的那个项目：
2. 进去后fork它 注意是在老师的仓库里fork，左上角有ID：
fork的作用相当于创建了一条链接，fork完之后，进到你自己的仓库页面，会发现你已经新建了一个同名的仓库，点蓝色的链接进去（注意不要点成灰色“forked from xxx”那行，不然会进到老师的仓库）。
3. 进入你的仓库，上传文件 4. 交完之后，同样是在自己的仓库里，点这个pull request 5. 出现这个界面就差不多了 把这个页面上的表单填完，然后提交就可以了。
6. 检查自己有没有提交成功 再次进入老师的仓库界面，点进pull request栏，这里会显示所有同学提交的项目，如果能找到你的，那就说明提交成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e8e2c7cefc591204bfb0cf2b6d6366/" rel="bookmark">
			GoFrame Step by Step Demo - P1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GoFrame Step by Step Demo P1 框架说明文档GFTool 安装Web框架学习 文章目录 GoFrame Step by Step Demo P1参考Demo记录安装GF Tool加入环境变量创建并初始化项目配置项目数据数据表构建路由1. API2. 鉴权3. 用户4. 权限Code验证码 本片后记 参考Demo StandAlone Projects using GoFrame
gf-demos - (Official) GoFrame新手入门基础演示项目。gf-cli - (Official) GoFrame Command Line Interface.focus-single - (Official) GoFrame开源社区项目，可作为一个完整项目示例。gfast - 基于GoFrame框架的后台管理系统。gmanager - 基于GoFrame框架的管理平台。gf-vue-admin - 基于GoFrame+Vue搭建的后台管理系统框架。gf-admin-api - 一个前后端分离项目，前端Vue.js、后端GoFrame。gea - 基于GoFrame、Vue &amp; Element的前后端分离权限管理系统。dmicro - 基于GoFrame的rpc框架。 Libraries and Plugins using GoFrame
polaris - Polaris with GoFrame.gtoken - 基于GoFrame框架的token插件，通过服务端验证方式实现token认证.gf-jwt - GoFrame HTTP JWT middleware.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67e8e2c7cefc591204bfb0cf2b6d6366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47735f59aeaf405f3166e010280e160b/" rel="bookmark">
			Reactor模型你知道都有哪些吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下的图片都来自Doug lea大神的《Scalable IO in Java》，也推荐大家去阅读下，就是对英文不好的小伙伴不太友好了，大家也可以看我的翻译版本，就是有些翻译的不太好，将就着看哈哈：Doug lea《Scalable IO in Java》翻译
系列文章 你知道都有哪些I/O模型吗？Java NIO三大角色Channel、Buffer、SelectorDoug lea《Scalable IO in Java》翻译Reactor模型你知道都有哪些吗？Netty服务端创建源码流程解析EventLoopGroup到底是个啥？未完待续… 创作不易，如果对您有帮助，麻烦辛苦下小手点个关注，有任何问题都可以私信交流哈。
祝您虎年虎虎生威。
单Reactor 单线程模型 最基础的Reactor模型，指的是所有的I/O操作都在同一个NIO线程上完成。下图为线程模型：
Reactor模型使用的是异步非阻塞I/O，所有的I/O操作都不会导致阻塞，理论上一个县城可以独立处理所有IO操作，例如：通过Acceptor接收客户端的TCP连接请求消息，当连接建立完成后，通过Dispatch将对应的ByteBuffer派发到指定的Handler上进行消息的解码。用户线程消息编码后通过NIO线程发送给客户端。
​
适用场景：适用于处理器链中业务处理组件能快速完成的场景
缺点：对于高负载，大并发的应用场景不适合， 原因如下：
一个NIO线程线程同时处理成百上千个连接，性能上无法支撑当NIO线程负载过重后，处理速度将变慢，这回导致大量客户端连接超时，消息挤压和处理超时，最终称为系统的性能瓶颈可靠性问题，一旦NIO线程意外died，会导致整个系统通信模块不可用，不能接收和处理消息 基于上边的这些问题，演进出了单Reactor多线程模型。
单Reactor 多线程模型 特点：
有专门一个NIO线程——Acceptor线程用于监听服务端，接收客户端的TCP连接请求网络I/O操作——读、写等由一个NIO线程池负责，线程池可以使用JDK的线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送响应一个NIO线程可用同时处理N条链路，但是一个连接只对应一个NIO线程，防止发生并发操作问题 这种单Reactor多处理线程的模型在绝大多数场景下可用满足性能需求，但是在个别特殊场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题，比如服务端需要对客户端进行安全认证，认证的过程又非常损耗性能，那就会出单点性能不足问题，因此又演进出了多Reactor多处理线程模型。
多Reactor 多线程模型 这种模型又被称为 “主从Reactor多线程模型”。
第二种模型将事件处理放到了线程池中进行多线程处理，第三种模型是将Reactor的职责进行了划分，服接收客户端连接的不再是一个单独的NIO线程，而是一个独立的NIO线程池，分为了两部分：
mainReactor：负责监听ServerSocketChannel，用来处理客户端新连接的建立，并将建立的客户端的SocketChannel指定注册给subReactorsubReactor：维护自己的Selector，基于mainRactor建立的客户端的SocketChannel多路分离IO读写事件，读写网络数据，对于业务处理的功能，扔给worker线程池来完成 Netty的Reactor模型 客户端 EventLoopGroup group = new NioEventLoopGroup(); //这里使用的是Bootstrap，服务端使用的是ServerBootstrap Bootstrap b = new Bootstrap(); Netty NIO客户端来说，仅创建一个EventLoopGroup一个EventLoop可以对应一个Reactor，EventLoopGroup可以理解为Reactor的分组一个Bootstrap的启动只能发起对一个远程地址的连接，所以只会使用一个NIO Selector，也就是说仅适用一个Reactor，即使，我们在声明使用一个EventLoopGroup，该EventLoopGroup也只会分配一个EventLoop对IO事件进行处理如果一个业务线程使用Netty NIO客户端，可以认为是“单Reactor单线程模型”如果有多个业务线程使用Netty NIO客户端，可以任务是“单Reactor多线程模型”同时我们可以创建多个Netty NIO客户端来实现“多Reactor多线程模型” ​
服务端 // 创建两个 EventLoopGroup 对象 EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 创建 boss 线程组 用于服务端接受客户端的连接 EventLoopGroup workerGroup = new NioEventLoopGroup(); // 创建 worker 线程组 用于进行 SocketChannel 的数据读写 // 创建 ServerBootstrap 对象 ServerBootstrap b = new ServerBootstrap(); // 设置使用的 EventLoopGroup b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47735f59aeaf405f3166e010280e160b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d3b551af8256d34656af2dde327a36/" rel="bookmark">
			SimpleDateFormat使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中，我们经常会用到时间，我们有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成我们需要的格式。最常用的方法就是使用SimpleDateFormat类。
SimpleDateFormat是Java提供的一个格式化和解析日期的工具类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。SimpleDateFormat使得可以选择任何用户定义的日期- 时间格式的模式。在Java中，可以使用SimpleDateFormat的format方法，将一个Date类型转化成String 类型，并且可以指定输出格式。比如：
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = new Date(); System.out.println(simpleDateFormat.format(date)); 由于SimpleDateFormat比较常用，而且在一般情况下，一个项目中的时间显示模式都是一样的，所以很多人经常使用如下方式定义SimpleDateFormat：
private static final SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); public static void main(String[] args) { Date date = new Date(); System.out.println(simpleDateFormat.format(date)); } 这是一个看上去功能比较简单的类，初看没什么问题，但是SimpleDateFormat是线程不安全的，如果真这么使用会有大问题。下面做个测试，测试代码如下：
private static final SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); private static final ThreadFactory THREAD_FACTORY = new ThreadFactoryBuilder().setNameFormat("date-test-pool-%d") .build(); private static final ExecutorService executorService = new ThreadPoolExecutor(10, 10, 60L, TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d3b551af8256d34656af2dde327a36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e73bb5cdb83ef2cb6389be94a0048c2/" rel="bookmark">
			Java的四种引用类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一文读懂java中的Reference和引用类型简介强引用Strong Reference软引用Soft Reference弱引用weak Reference虚引用PhantomReferenceReference和ReferenceQueue四大状态三个Queue/List WeakHashMap总结(原作者) 在看JVM的时候，发现Java引用类型反复出现；遂找了一篇总结博客来学习。
一文读懂java中的Reference和引用类型 一文读懂java中的Reference和引用类型
简介 java中有值类型也有引用类型，引用类型一般是针对于java中对象来说的，今天介绍一下java中的引用类型。java为引用类型专门定义了一个类叫做Reference。Reference是跟java垃圾回收机制息息相关的类，通过探讨Reference的实现可以更加深入的理解java的垃圾回收是怎么工作的。
本文先从java中的四种引用类型开始，一步一步揭开Reference的面纱。
java中的四种引用类型分别是：强引用，软引用，弱引用和虚引用。
强引用Strong Reference java中的引用默认就是强引用，任何一个对象的赋值操作就产生了对这个对象的强引用。
我们看一个例子：
public class StrongReferenceUsage { @Test public void stringReference(){ Object obj = new Object(); } } 上面我们new了一个Object对象，并将其赋值给obj，这个obj就是new Object()的强引用。
强引用的特性是只要有强引用存在，被引用的对象就不会被垃圾回收。
软引用Soft Reference 软引用在java中有个专门的SoftReference类型，软引用的意思是只有在内存不足的情况下，被引用的对象才会被回收。
先看下SoftReference的定义：
public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; SoftReference继承自Reference。它有两种构造函数：
public SoftReference(T referent) 和：
public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) 第一个参数很好理解，就是软引用的对象，第二个参数叫做ReferenceQueue，是用来存储封装的待回收Reference对象的，ReferenceQueue中的对象是由Reference类中的ReferenceHandler内部类进行处理的。
我们举个SoftReference的例子：
@Test public void softReference(){ Object obj = new Object(); SoftReference&lt;Object&gt; soft = new SoftReference&lt;&gt;(obj); obj = null; log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e73bb5cdb83ef2cb6389be94a0048c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d92366f81b8828e162627f145ae106/" rel="bookmark">
			MySQL学习记录（五）-排序、连接、null值处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序 order by子句 用途：
用于设置字段的排序方式，然后返回搜索结果
语法
SELECT field1, field2,...fieldN FROM table_name1, table_name2... ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] //asc:升序 //desc：降序 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。
你可以设定多个字段来排序。
你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。
你可以添加 WHERE…LIKE 子句来设置条件。
举例：
select * from 表 order by 列名 asc/desc; GROUP BY语句 用途：
根据一个或多个列对结果进行分组
在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。
语法：
SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; 举例
执行：
SELECT name, COUNT(*) FROM employee_tbl GROUP BY name; 得到结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4d92366f81b8828e162627f145ae106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5deeba91cc51f02a8941358a7bc8134a/" rel="bookmark">
			GIT 学习指导（6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git成名的地方在于分布式版本管理。其中的关键技术是远程分支。开发者的本地作品，相对于另一个开发者就是一个远程分支（别人的远程分支也是自己的本地分支，都是相互相对的）。本地分支和远程分支并行演进。如下图所示：
上图中的origin/master显然是一个指针，指向了”上次“与远程仓库通信时，记忆的分支位置。虽然逻辑上，此时的origin/master应该指向y这个节点，但是如果本机不联网，无法感知这个位置的。我们可以通过联网通讯，把远程分支同步到本机，这样origin/master就可以前进到y这个位置了。所以origin/master是个特殊的指针，叫做远程跟踪分支指针。本机的分支指针master随着本机的commit等操作前进，origin/master只能通过远程传输相关操作前进。
“远程"这个词可以扩展一下，在git里，本机的另外一个文件夹存储另一份仓库数据，也可以认为是一个远程仓库。利用这一点，可以方便的在本机做远程分支的实验。
1）在C盘建立一个中心仓库（位于c:/aaa）
cd aaa
git init --bare 2) 在D盘clone中心仓库（位于d:/aaa）
git clone file://c:/aaa
3）同时，我们D盘建立项目的初始文件，这里只有一个文件
cd d:/aaa
git add a.c
git commit -m "V1"
4) 把D盘的成果上传到C盘中心库
git push
5）在E盘，再克隆出另一个仓库，可以模拟2个开发者协作（D和E）
git clone file://c:/aaa
D开发者和E开发者，都获得完全一致的仓库状态。如下图：
6) D盘开发者继续开发，提交一次，看到的本地视图如下：
7) E盘开发者继续开发，提交一次，看到的本地视图如下：
8）D盘开发者把工作成果上传
git push
9) E盘开发者把工作成果上传，但是......
git push 失败了，提示： ! [rejected] master -&gt; master (fetch first) 系统检测出冲突，两个平行的开发分支必须解决合并问题！这是对的，越早合并越好，否则一个向南极开发，一个向北极开发，将越来越难合并。因此E盘开发者需要按错误提示所指示的，把远程分支同步到本地。
10) E盘开发者下载远程分支
git fetch
这样就可以得到D的工作成果，如下图：
这个图是不是很熟悉？远程分支下载到本地，与前文的master和slave本地分支没有啥特殊之处了。我们选择用rebase命令合并这两个分支。
11）E盘开发者合并分支，解决冲突。
git rebase origin/master #结果如下图
现在的master就基于V2做了合并。这正是我们要的结果。上次在第9)步我们失败了，现在再执行上传就可以成功了。
12）E盘开发者重新上传
git push #结果如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5deeba91cc51f02a8941358a7bc8134a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cbdf5f9aa4ed0484cb97a06101b8546/" rel="bookmark">
			HTML常用标签之＜h1＞到＜h6＞标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在学习html，在这里分享下自己的学习笔记~
h1到h6标签也叫标题标签，它的使用见以下代码
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;h3&gt;我是标题&lt;/h3&gt; &lt;h4&gt;我是标题&lt;/h4&gt; &lt;h5&gt;我是标题&lt;/h5&gt; &lt;h6&gt;我是标题&lt;/h6&gt; &lt;/body&gt; &lt;/html&gt; 代码的预览图如下~
关于标题标签有以下几点注意事项：
标题标签从&lt;h1&gt;到&lt;h6&gt;，里面的文字大小依次变小标题标签内的文字自带加粗效果每个标签独占一行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ff135be96f404f9aa3f5560388387c/" rel="bookmark">
			保姆级指南：jekins&#43;docker构建部署react项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大厂技术 高级前端 Node进阶
点击上方 程序员成长指北，关注公众号
回复1，加入高级Node交流群
王志远，微医前端技术部医疗支撑组
前置概念 CI的含义 CI 的意思是 持续构建 。
负责拉取代码库中的代码后，执行用户预置定义好的操作脚本，通过一系列编译操作构建出一个 制品 ，并将制品推送至到制品库里面。常用工具有 Gitlab CI，Github CI，Jenkins 等。这个环节不参与部署，只负责构建代码，然后保存构建物。构建物被称为 制品，保存制品的地方被称为 制品库。
CD的含义 CD 则有2层含义：持续部署（Continuous Deployment） 和 持续交付（Continuous Delivery） 。
持续交付 的概念是：将制品库的制品拿出后，部署在测试环境 / 交付给客户提前测试。持续部署 则是将制品部署在生产环境。
初始化环境 从现在开始，我们就要真正实操CI、CD啦，建议搞一台新的服务器，避免搞乱环境，如果需要购买，可以参考文档 保姆级指南：购买阿里云ecs服务器。无论是新买的还是自己电脑，电脑基础环境如下
docker
git
java：jenkins基于java环境
jenkins
假定机器有了，基于centos，接下来我们就开始搭建服务吧
docker安装 yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum install docker-ce -y systemctl start docker systemctl enable docker 此处需要配置下docker镜像源为阿里云，不然之后docker下载镜像等操作都会巨慢
sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ff135be96f404f9aa3f5560388387c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21dd3746eab7190a8807c9aced62a2a/" rel="bookmark">
			Excel如何批量将文本型数值转为数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图B列数据为文本型数字，现在想要将其快速转换为数值型数字。
为了方便演示，我将B列数据复制一份到C列中。（实际操作中不需要这一步）
全选C列文本型数字单元格区域
点击下图选项（Excel插件，百度即可了解详细的下载安装方法，本文这里不作详细叙述）
点击【数值】
选择【文本型数字转换】
点击【确定】即可完成
完成效果如下图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21602318c7b4be162cac4858d3dfbc2a/" rel="bookmark">
			STM32 精准采集ADC电压,误差分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADC模块采集电压流程
数字世界和模拟世界的桥梁，对于嵌入式软件而言，大家止于采集功能的实现。
本文目的在于深入理解ADC，积累技术做出更加稳定优秀的产品。
STM32 大部分系列都是使用SAR 逐次逼近型电压采集
VIN是采集的模拟输入口，VREF表示参考电压。Sa PIN和内部ADC的开关。Sb 接地开关。
电压采集阶段
电压采集阶段就是内部电容充电的过程。Sb闭合后ADC内部（这里称之为采样保存电路，并不是转换器核心）的电容会进行充电，这个过程需要消耗一定的时间。一但采集完成，相当于复制了一份模拟输入引脚的 电压值。采集阶段完成后这个时候VIN已经不需要了，也就是说这个Pin 上的电压已经采集完毕。
等效电路就是VIN对电容2C进行充电。
前面说道这里是采用保持电路，所以有保持阶段
这个阶段就是各个电容充电完毕，在ADC核心转换器工作前的这断时间。这个时候VIN PIN模拟输入引脚已经和ADC断开了。Sb开路。
也就是说实际上ADC 转换核心转换的是采样保持电路的电压。所以务必要根据手册，明确采样阶段最小用时，确保充电阶段完成。
其等效电路入上图所示电容器一断的电压为-VIN
转换阶段
这个阶段的重点在于每次二分。
这里设计到一些电路的知识，如果是软件开发会比较难懂
具体的过程讲起来比较复杂，软件工程师只需要对其逐次逼近转换的二分思路有理解即可。
这个可能会因为各个芯片的转换核心而异
本节重点：
1.ADC的采样保持电路 ，采集VIN电压，形成副本供ADC转换核心使用
2.电压转换逐次逼近转换的二分思路 0.5+0.25+0.125+…=1
关于采样时间，采样时间是电容充电的过程，如上图所示，实线代表充电过程虚线代表放电。
t =RC, C 为采样电容，R为充电回路的电阻。
一般来说需要5 RC采样时间，这样内部电容可以精准的采集到输入电压。
5RC 时间大概采集到两端电压的99.3%
6RC 时间大概采集到两端电压的99.8%
这个电压值永远都无法充电到100%V，一般来说5RC的时间，认为充满。
5RC 充满到99.3%，还有千分之七的电压未采集。 7/1000
一般的ADC 12位 1/4049的采样精度。这个时候需要去看产品的设计要求。一般情况下不需要做补偿。
ADC module 转换误差 对于STM32 ADC，电压的最小可检测增量变化用LSB表示为：
1 LSB 表示ADC模块可分辨的最小电压
12 位ADC 其一个单位表示V* 1/4096
10 位ADC 其一个单位表示V* 1/1024
为了后面书写方便 1LSB的系数表示为 12 位ADC P = 1/4096 ，10 位ADC P= 1/1024
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21602318c7b4be162cac4858d3dfbc2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d7e9e8ce306a2277941e105d445eb0/" rel="bookmark">
			JavaScript - 面向对象与面向对象的发展过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、面向对象与面向过程 面向过程 c注重问题的解决面向对象 JAVA完成对真实世界的模拟，把一个对象的共同特点抽离出现，有了所有的’属性’和’方法’ class js并不是一个真正的面向对象的语言 , js在模拟面向对象
对象的特点：属性 + 方法
对象在js里面是由构造函数new出来的
这里我们举个例子~：
问题1：有一只两岁的柯基
// 面向过程 const dog = '柯基' ; const age = 2 ; // 面向对象 const obj = { dog : '柯基' , age : 2 } 问题2：又来了一只3岁的二哈
// 封装函数 function dog(type, age) { console.log('有一只' + age + '岁的' + type); } dog('二哈', 3) //有一只3岁的二哈 // 面向对象 function Dog(type, age) { const obj = { dog: type, age, say: function() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d7e9e8ce306a2277941e105d445eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31bb61dd83d6d7ce4a36e6ce28859e26/" rel="bookmark">
			虚拟机Ubuntu下/etc/sudoers损坏的解决方案：从别的系统拷贝新的sudoers文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天一基友说他sudoers文件坏了，叫我拷贝给ta一份，由于自己操作不当，所以把自己的/etc/sudosers也给搞崩了。今天才恢复好，记录一下。
sudoers文件错误，运行sudo提示如下：
zcxaubuntu:~$ sudo &gt;&gt; /etc/sudoers: syntax error near line 1 &lt;&lt;&lt; sudo:k parse error in letc sudoers near line1 sudo: no valid sudoers sources found, quitting sudo: unable to initialize policy plugin 一、进入Linux系统root用户模式（注：如果忘记root密码，请自行百度进入单用户模式）
因为/etc/sudoers文件的权限是只读，所以需要进入root用户修改损坏sudoers文件的权限，不然复制不进去。
进入root用户模式
su root 查看/etc/sudoers的权限
ll /etc/sudoers 修改/etc/sudoers的权限
chmod 777 /etc/sudoers 二、将另外一个完整系统的sudoers文件拷贝
我使用的系统是Ubuntu18.04.6为了重新找到一模一样的系统去了阿里云重新下了一个同版本的ios镜像，然后在虚拟机上安装了。
(1)运行新系统将/etc/sudoers文件先复制到Desktop，然后直接拉出windows的桌面下（注意：如果虚拟机没有安装VMware Tools工具是没有Windows和虚拟机系统进行文件传输的功能的哦！）
cp -r /etc/sudoers /home/你的用户名/Desktop 如图：
(2)将Ubuntu桌面环境下的sudoers文件更改权限，不然无法传输。
sudo chmod 777 /home/你的用户名/Desktop/sudoers 然后可以通过桌面拖拉的方式直接拉到Windows环境下了。
(3)将sudoers文件复制已损坏的系统
可以看到两个系统我都打开了，现在直接把Windows桌面下的sudoers文件拉到已损坏的系统桌面下即可。
然后将其移到/etc目录下
cp -r /home/你的用户名/Desktop/sudoers (4)运行sudo
发现提示了以下问题，不过莫慌。
sudo:sudo /etc/sudoers is world writable
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31bb61dd83d6d7ce4a36e6ce28859e26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076a1a8c24e076b0b5963047ff02a1d5/" rel="bookmark">
			Markdown语法简易入门版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐编译器：Typora
文件后缀：xxx.md
语法 下面出现的+号，是不实际输入的，我打出来是作拼接的意思。
1. 标题 #+空格+标题名，为一级标题。##+空格+标题名，为二级标题。#数量决定标题大小，Markdown最多只支持到六级标题。
效果：
六级标题 2. 字体样式 粗体和斜体
*字体内容*，将字体内容变斜体
**字体内容**，将字体内容加粗
***字体内容***，将字体内容加粗且变斜体
效果：
斜体
加粗
斜体且加粗
加删除线
~~字体内容~~，效果：删除线
设置字体颜色
&lt;font color=“RGB值或其他颜色表示方式”&gt;字体内容&lt;/font&gt;，可以使字体内容变成color属性中规定的颜色。原文及效果：
字体内容
设置字体大小
&lt;font size=“数字”&gt;字体内容&lt;/font&gt;，可以使字体内容大小变成size属性中规定的大小，数字越大字体越大。原文及效果：
字体内容
设置字体样式
&lt;font face=“字体样式”&gt;字体内容&lt;/font&gt;，可以使字体内容变成face属性中规定的样式。原文及效果：
字体内容
引用
&gt;+空格+字体内容，引用需要新起一行，可以使用空行来结束引用。原文和效果：
引用
表示次方
^+次方数值+^，可以时内容缩小显示在上方，一般在表示次方时使用。原文和效果：
22分割线
***或---或___。原文和效果：
3. 超链接 [超链接说明]+(URL地址)
原文和效果：
C#使用TCP消息通信实现简易群聊功能
4. 列表 有序列表：
数字+英文句号+空格+文字内容+回车，效果： abc 无序列表：
*或+或-空格+内容+回车，原文和效果：
a b c 5. 表格 |头部表格内容|头部表格内容|
|–|--|(此处为分隔线)
|表格内容|表格内容|
原文和效果：
姓名性别出生日期张三男1997.07.01 6. 图片 图片引用：!+[图片内容]+(URL路径)
原文和效果：
7. 代码 ```+语言类型+回车+代码内容，原文和效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/076a1a8c24e076b0b5963047ff02a1d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a40434ceeef070da7b11b642dec11da/" rel="bookmark">
			javax.crypto.IllegalBlockSizeException: last block incomplete in decryption
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javax.crypto.IllegalBlockSizeException: last block incomplete in decryption 用使用AES加密后还需使用Base64编码方式再进行一次加密，所以解密的时候需要先用Base64解密，再用AES的方法解密之后再次报错同样的错误，求解析。 用使用AES加密后还需使用Base64编码方式再进行一次加密，所以解密的时候需要先用Base64解密，再用AES的方法解密之后再次报错同样的错误，求解析。 javax.crypto.IllegalBlockSizeException: last block incomplete in decryption
at org.bouncycastle.jce.provider.JCEBlockCipher.engineDoFinal(Unknown Source)
at javax.crypto.Cipher.doFinal(Cipher.java:2164)
at com.yujiankang.common.utils.AESUtils.decryptAES(AESUtils.java:126)
at com.yujiankang.common.utils.AESUtils.decode(AESUtils.java:186)
at com.yujiankang.yyinfo.utils.BusinessUtils.ajaxData(BusinessUtils.java:97)
at com.yujiankang.yyinfo.utils.BusinessUtils.ajaxDataObj(BusinessUtils.java:67)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/390812af7151be9922e863e2b66d7985/" rel="bookmark">
			折半查找排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本思路
在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;
若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败
实现步骤
在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;
若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;
若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。
不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败。
int findKey(int values[], int length, int key) { // 定义一个变量记录最小索引 int min = 0; // 定义一个变量记录最大索引 int max = length - 1; // 定义一个变量记录中间索引 int mid = (min + max) * 0.5; while (min &lt;= max) { // 如果mid对应的值 大于 key, 那么max要变小 if (values[mid] &gt; key) { max = mid - 1; // 如果mid对应的值 小于 key, 那么min要变 }else if (values[mid] &lt; key) { min = mid + 1; }else { return mid; } // 修改完min/max之后, 重新计算mid的值 mid = (min + max) * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/390812af7151be9922e863e2b66d7985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0199b5aa2baca972447ccb1faf1680/" rel="bookmark">
			python将列表中的str类型数据转换为int或者float类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python将列表中的str类型数据转换为int或者float类型 方法：
我们可以利用map内置函数
在python2中使用map函数直接返回一个list，而在python3中使用map函数会返回一个map迭代器，我们需要手动将其转换为list。
语法：map(func_to_apply, list_of_inputs)
举一个例子：
number = ['1', '2', '3', '4', '5', '6'] number = list(map(int, number)) print(number) 结果:
[1, 2, 3, 4, 5, 6] 再举一个例子：
number = ['1', '2', '3', '4', '5', '6.0', '9.321'] number = list(map(int, number)) print(number) 结果会报错：
报错结果表示我们不能用int转换小数，这个地方需要注意，所以我们采用float函数
修改一下上述代码：
number = ['1', '2', '3', '4', '5', '6.0', '9.321'] number = list(map(float, number)) print(number) 结果：
[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 9.321] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e9d02cd63d05d51085e6f04ac2aa79/" rel="bookmark">
			VUE&#43;Element实现树形结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 VUE+Element实现树形结构缘由数据前端代码解决 VUE+Element实现树形结构 缘由 最近想做一个属性菜单结构的页面展示，我的前端使用的技术是VUE+Element。发现根据官网上的例子，名字怎么也展示不出来，其实是自己没有仔细看官网，特此记录下。
数据 先看下后台返回的数据及格式。
pid为0，则为1级菜单，二级菜单的pid为一级菜单的id。
前端代码 &lt;el-tree :data="data" show-checkbox node-key="typeId" default-expand-all :expand-on-click-node="false"&gt; &lt;span @click="click(data)" class="custom-tree-node" slot-scope="{ node, data }"&gt; &lt;span&gt;{{ node.name }}&lt;/span&gt; &lt;span&gt; &lt;el-button type="text" size="mini" @click="() =&gt; append(data)"&gt;添加&lt;/el-button&gt; &lt;el-button type="text" size="mini" @click="() =&gt; remove(node, data)"&gt;删除&lt;/el-button&gt; &lt;/span&gt; &lt;/span&gt; &lt;/el-tree&gt; 展示效果：
好像对了，又好像不太对。我的类型名称都没展示，但是这个结构好像是对的，node.name的值没有展示。
解决 我是参考官网的这个例子做的，代码可以说一模一样的，还就是不展示名字。奇怪
以后还是要认真看文档，其实文档下面写的很清楚、很详细。
修改代码
在defaultProps中配置树菜单数据的key即可。
defaultProps: { children: "children", label: "name", isLeaf: "leaf", } 大概是说，label实际使用的是我自己数据中的name列。
再次查看效果：
nice!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841f212290e078b76d7ecb9275e5d4db/" rel="bookmark">
			Vue 数组/对象数据 更新，但是页面不渲染问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 已经赋值过的对象、数组时，向对象中添加新的属性，如果更新此属性的值，页面不会更新视图。是因为我们用错更新方法
由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。
对于对象/数组 Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。例如
// `vm.a` 是响应式的
var vm = new Vue({
data:{ a:1 }
})
// `vm.b` 是非响应式的
vm.b = 2
我们需要使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。例如，对于：Vue.set(vm.someObject, 'b', 2)
您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：
this.$set(this.someObject,'b',2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed91f861d09ec4e931de191ec8b33802/" rel="bookmark">
			CMake 设置Target输出目录和后缀名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		敲代码还是离不开CMake呀。关键是完全自学《CMake从入门到放弃》（PS:官方文档）真的好难呀。
没办法，对于CMake的语法和规则只能要一条一条慢慢用，慢慢记。
本条转载自：CMake 设置Target输出目录和后缀名
分享给大家，方便更多人看到。
一.
SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/…/bin)
上面的语句能设置可执行文件的输出目录
在Win + VS环境下,会自动在你所设置的目录后面扩展一层 /CONFIG 目录,所以最终生成的Debug版本程序会在 ${PROJECT_SOURCE_DIR}/…/bin/Debug 目录下,Release版本程序会在 ${PROJECT_SOURCE_DIR}/…/bin/Release 目录下.
在Linux + GCC环境下,无论是Debug还是Release,生成的可执行程序会直接放在你所设置的目录下,不会有差异.
二.
SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/…/lib)
上面的语句能设置库文件的输出目录
在Win + VS环境下,会自动在你所设置的目录后面扩展一层 /CONFIG 目录,所以最终生成的Debug版本库会在 ${PROJECT_SOURCE_DIR}/…/lib/Debug 目录下,Release版本库会在 ${PROJECT_SOURCE_DIR}/…/lib/Release 目录下.
在Linux + GCC环境下,无论是Debug还是Release,生成的库文件会直接放在你所设置的目录下,不会有差异.
三.
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${PROJECT_SOURCE_DIR}/…/bin) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${PROJECT_SOURCE_DIR}/…/bin)
上面两条语句分别设置了Debug版本和Release版本可执行文件的输出目录,
一旦设置上面的属性,在任何环境下生成的可执行文件都将直接放在你所设置的目录.
四.
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${PROJECT_SOURCE_DIR}/…/lib) set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${PROJECT_SOURCE_DIR}/…/lib)
上面两条语句分别设置了Debug版本和Release版本库文件的输出目录,
一旦设置上面的属性,在任何环境下生成的库文件都将直接放在你所设置的目录.
五.
set(CMAKE_DEBUG_POSTFIX “_d”)
set(CMAKE_RELEASE_POSTFIX “_r”)
上面两条语句分别设置了Debug版本和Release版本下库文件的后缀名.
六.
set_target_properties(${TARGET_NAME} PROPERTIES DEBUG_POSTFIX “_d”)
set_target_properties(${TARGET_NAME} PROPERTIES RELEASE_POSTFIX “_r”)
上面两条语句分别设置了Debug版本和Release版本下可执行文件的后缀名.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0818ef5fca998d3497821c9e7cba7bd/" rel="bookmark">
			C语言 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是函数 （模块化设计） 概念： 函数（function)是C语言用来实现一个或多个功能的代码块（个人理解），实现了C语言面向过程，面向结构的设计思路，是C语言的核心和主体。（后面加括号就表示它是一个函数） 函数对C语言的作用（优化C语言中结构套结构的问题） 1、提高代码的复用
相同的功能可以封装成一个函数，用到该功能时直接调用函数；
2、提高代码的扩展性
增删功能，不用在整体代码上删改，这样容易出错，把功能封装成函数后，只要修改相应功能模块就行了
3、增强代码的维护性
出现问题可以直接找到实现该功能的代码，方便修改和判断位置
补：
面向过程：把问题分解成一个个步骤（功能），按照一定顺序实现一个个步骤（功能），实现模块化程序设计的思路。
面向对象：面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。 二、函数的相关语法 1、函数的三要素 函数名 函数形参 函数返回值 int main (int argc,char ** argv) int 表示函数的返回值类型是整形
main 主函数名，程序运行第一个执行的函数
(int argc,char ** argv) 函数形参,命令行参数，Linux终端运行程序时用来给主程序传入参数 ，./run也算一个命令行参数，argc 表示命令行参数个数，char ** argv也可以写成char * argv[ ],数组指针，指针指向数组的每一个元素
return 0;在Linux中给系统返回程序运行状态，最好加上，可以及时回收系统资源，其他情况return可以返回不同类型（根据定义类型）的函数返回值
命令行参数例：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main(int argc,char ** argv) { if(argc!= 3) { printf("please input three name"); exit(1); } printf("%s %s\n",argv[1],argv[2]); return 0; } 2、函数的使用形式 函数声明 函数定义 函数返回值（越学越感觉重要） 1、函数调用包含元素：函数名 实参的变量名或地址（重点传值还是传地址） 2、函数声明包含元素：函数名 返回值 形参的类型，可以不提供变量名（函数声明不是定义，不分配内存） 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0818ef5fca998d3497821c9e7cba7bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3318aec1c90925628f805e9e9912a6ec/" rel="bookmark">
			Jetson NX通过SSD硬盘启动的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetson NX通过SSD硬盘启动的方法 通过m.2接入ssd，启动系统后:
给ssd分区:
sudo parted -s /dev/nvme0n1 mklabel gpt
sudo parted -s /dev/nvme0n1 mkpart primary 2048s 100%
sudo mkfs.ext4 -F /dev/nvme0n1p1拷贝emmc上的文件到ssd
设备连网的情况下，执行:
sudo apt-get install rsync
然后执行:
sudo mount /dev/nvme0n1p1 /mnt
sudo rsync -aAXv / --exclude={"/dev/","/proc/","/sys/","/tmp/","/run/","/mnt/","/media/*","/lost+found"} /mnt用附件中的initrd替换/boot下的initrd，并修改权限
sudo cp ~/initrd /boot
sudo chown root /boot/initrd
sudo chgrp root /boot/initrd、
sync
重启后，可挂载rootfs到ssd. 请注意，此方法只在Jetson NX上验证过。
其余平台，无法保证是否能够使用，请注意备份，防止风险。
转载：https://forum.miivii.com/forum.php?mod=viewthread&amp;tid=299&amp;highlight=ssd&amp;_dsign=b824ac27
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb914d4f19dc0d519e38cf65845aea5/" rel="bookmark">
			ubuntu 安装mysql实战版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 16.04 安装MySQL 5.7.33 apt-get install mysql-server=5.7.33-0ubuntu0.16.04.1 安装的过程中需要设置root的密码，根据提示操作即可
安装完成后默认只能本地访问，如果需要其他地址也可以访问需做如下操作
编辑配置文件
vim /etc/mysql/mysql.conf.d/mysqld.cnf 对以下行进行注释或者修改
# bind-address = 127.0.0.1 完成后对文件进行保存
同时对root用户的权限进行如下操作
mysql -uroot -p123456 grant all privileges on *.* to 'root'@'%' identified by '123456'; flush privileges; 查询用户信息
select host,user from mysql.user; 退出mysql quit
重启mysql
service mysql restart 整个操作过程如下
mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '123456'; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; flush privileges; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adb914d4f19dc0d519e38cf65845aea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef04f2b5613c810707107cfced61c119/" rel="bookmark">
			vue3子组件update:modelValue不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是看到的文章
我去看了一眼，可能我跟他的问题是一样的，用event去做绑定
&lt;ChildComponent :title=“title” @update:title = “title = $event” /&gt;
也就是加上 @update:title = “title = $event” 测试成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f2f3d461fd0dcfe432205791ffc0a2/" rel="bookmark">
			对象拷贝，entity与vo的各种类型之间相互转换, 不想写连表查询的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个工具类, 用于将实体、集合、page的entity与vo之间的类型转换工具类。
在有使用Mybatis Plus的项目框架中，我们从库中查询出来的数据只能映射到实体类， 不能够很好的适应我们的VO对象，而且有时候分页查询时往往会涉及连表查询等等， 通常得通过写sql来得到VO类型的输出。
如果你不想写sql怎么办？只想通过调用简单快捷的Mybatis Plus的方法进行对表操作， 那么就可以使用这个工具类了。
我工作中追求的是减少复杂的开发过程， 提高开发效率，代码可复用化。
进入正题.
通常copy一个对象简单的方法是使用工具类BeanUtils.copyProperties(), 但是对于我们的集合和Page对象束手无策， 但还是先了解一下copyProperties（）的使用
BeanUtils.copyProperties(source, target); source是被复制的对象，target是被赋值的对象。即将source中的数据拷贝到target对象中， 使用前先得new一个target对象。需要注意的是，两个对象之间只有相同字段和类型的值才能被成功拷贝，否则拷贝后需对不成功的字段进行赋值
完整代码 了解了copyProperties（）的使用过程， 我们就可以用它作为copy的基础来编写我们的工具类了。
先上一波完整代码，粘贴到你的util中即可， 可通过实例化工具或者直接使用静态方法两种方式调用。
ModelUtil.java
/** * 类型转换 * entity &lt;----&gt; entityVO, * List&lt;entity&gt; &lt;----&gt; List&lt;entityVO&gt;, * Page&lt;entity&gt; &lt;----&gt; Page&lt;entityVO&gt; * @author Huzz * @created 2021-12-07 9:55 */ @Component public class ModelUtil&lt;Source, Target&gt; { private static final Logger log = LoggerFactory.getLogger(ModelUtil.class); /** * 通过静态方法调用(单例模式) */ private static ModelUtil modelUtil = new ModelUtil(); public ModelUtil(){ } /** -----------------------静态方法方式调用-------------------------------------- */ /** * 转换为目标对象 * @param source 源对象 * @param type 目标对象类 * @return 目标对象 */ public static Object toEntityStatic(Object source, Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f2f3d461fd0dcfe432205791ffc0a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d770ad319f144bb638ad60fdc4ba6c/" rel="bookmark">
			2021 年 25 大 DevOps 工具（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DevOps 正在改变全球软件开发的状态，DevOps 正以某种形式有效地提高提高全球软件公司的上市速度、可销售性、创新和产品质量。
2021 年是 DevOps 的重要一年。由于 DevOps 跨越开发、运营、IT、安全和产品团队等等，以及软件开发的不同阶段，因此有大量工具可供选择。
本文介绍目前市场上可用的一些顶级 DevOps 工具，同时牢记 CI/CD 生命周期的重要类别。上篇为配置管理、构建、源代码、部署工具，本篇主要是漏洞管理、质量、监控、协作工具。
网络威胁及漏洞管理 TwistLock 对基于容器的应用程序来说，TwistLock 提供了威胁和漏洞。该服务以其与 Kubernetes 和 Docker 容器的集成而闻名。TwistLock 现在归 Palo Alto Networks 所有，通过其运行时应用安全保护和容器自动扫描进行安全检查。
TwistLock 有一个强大的文档，它易于部署并强制优化资源消耗。它还以其 CI/CD 管道集成、对容器安全协议的强合规性和图像扫描而闻名。
TwistLock 还以其精细的安全分析而闻名。该服务还用 AI 功能来了解环境，尽管有些公司已经发现，它自动触发的 cron 作业非常令人困惑。
他们还提供基于 SaaS 的安全扫描（prisma 云）和本地解决方案。
Sysdig Sysdig 是一种用于云基础架构、服务和应用程序的监控工具。Sysdig 通常用于对PaaS基础设施进行容器安全确认、监控及监控安排。
Sysdig 还可用于监控 OpenShift 集群，因为它提供粒度数据来分析指标。
使 Sysdig 脱颖而出的是其容器监控与编排层的强大集成。
如果你想深入了解进程网络流量，Sysdig 也很有用。Sysdig Opensource 允许在内核系统调用级别权限以获取主机的详细信息。捕获信息过程也可以通过 DaemonSet 或直接代理过程自动部署为 Docker 容器。
Anchore Anchore 是一个完整的容器安全工作流解决方案，可与各种开发工具和平台无缝集成。Anchore 为一系列不同的应用程序提供定制的容器检查和合规性解决方案，使团队能够符合行业安全标准。
安全团队可以审计和验证整个组织的合规性。
功能包括：
支持webhook，包括云托管或本地 Kubernetes 环境和 CI/CD 平台
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59d770ad319f144bb638ad60fdc4ba6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a68d2509a42544872233a9c1284c96/" rel="bookmark">
			intel realsensed455使用realsense-viewer命令显示连接不到相机的一个现象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用中想调整intel RealsenseD455相机输出的图像大小的时候，发现在使用ros命令：
roslaunch realsense2_camera rs_rgbd.launch 打开相机的时候，再使用
realsense-viewer 打开官方集成的SDK相机操作界面的时候，操作界面显示无法连接到相机，情况如下：（终端表示使用ROS命令打开的相机节点）
！！！！！！诡异的事情来了！！！！！
如果把ROS打开的相机节点关掉的话，realsense-viewer打开的操作界面就能连接到相机，显示图像了，如下：
我也不知道是光我遇到这样的问题还是他本来就这样的，反正让我玉门了半天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47039003c9dbd6820cdb0a9fff1ddbae/" rel="bookmark">
			本题要求对两个整数a和b，输出其中较大的数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数接口定义： int max( int a, int b ); 其中a和b是用户传入的参数，函数返回的是两者中较大的数。
裁判测试程序样例： #include &lt;stdio.h&gt; int max( int a, int b ); int main() { int a, b; scanf("%d %d", &amp;a, &amp;b); printf("max = %d\n", max(a, b)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： -5 8 输出样例： max = 8 int max( int a, int b ){ if(a&gt;b){ return a; }else{ return b; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd40d294e516d1491028eed3b66e9fb2/" rel="bookmark">
			MySQL 模糊查询，再也用不着 like &#43; % 了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“Java精选”，选择“设为星标”
别问别人为什么，多问自己凭什么！
下方有惊喜留言必回，有问必答！
每天 08:15 更新文章，每天进步一点点...
前言
我们都知道 InnoDB 在模糊查询数据时使用 "%xx" 会导致索引失效，但有时需求就是如此，类似这样的需求还有很多，例如，搜索引擎需要根基用户数据的关键字进行全文查找，电子商务网站需要根据用户的查询条件，在可能需要在商品的详细介绍中进行查找，这些都不是B+树索引能很好完成的工作。
通过数值比较，范围过滤等就可以完成绝大多数我们需要的查询了。但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较，全文索引就是为这种场景设计的。
全文索引（Full-Text Search）是将存储于数据库中的整本书或整篇文章中的任意信息查找出来的技术。它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。
在早期的 MySQL 中，InnoDB 并不支持全文检索技术，从 MySQL 5.6 开始，InnoDB 开始支持全文检索。
倒排索引 全文检索通常使用倒排索引（inverted index）来实现，倒排索引同 B+Tree 一样，也是一种索引结构。它在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射，这通常利用关联数组实现，拥有两种表现形式：
inverted file index：{单词，单词所在文档的id}
full inverted index：{单词，（单词所在文档的id，再具体文档中的位置）}
上图为 inverted file index 关联数组，可以看到其中单词"code"存在于文档1,4中，这样存储再进行全文查询就简单了，可以直接根据 Documents 得到包含查询关键字的文档；而 full inverted index 存储的是对，即（DocumentId,Position），因此其存储的倒排索引如下图，如关键字"code"存在于文档1的第6个单词和文档4的第8个单词。
相比之下，full inverted index 占用了更多的空间，但是能更好的定位数据，并扩充一些其他搜索特性。
全文检索 创建全文索引 1、创建表时创建全文索引语法如下： CREATE TABLE table_name ( id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY, author VARCHAR(200), title VARCHAR(200), content TEXT(500), FULLTEXT full_index_name (col_name) ) ENGINE=InnoDB; 输入查询语句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd40d294e516d1491028eed3b66e9fb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7149c7684e6542434a13d69c8d93b50/" rel="bookmark">
			关于‘\n‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天正式开始学C语言，我想在这上面把自己的点点滴滴记录下来，每解决一个前一刻不会的问题都值得庆贺。
怎样用一个printf语句将两个字分两行打印出来（一行一个字），开始我以为是把这两个字分两行输入,示例输入：关于
printf("关
于\n");
但编译不能通过，missing terminating character,缺少结束符号，之后改正为：
printf("关\n于\n");
输出正确。
我的问题是既然C语言书写规则是宽泛的，一行可以写多条语句，一条语句也可以分多行来写，但为什么这样编译不能通过呢？要怎样改正才可以编译通过呢？（Dev-c++）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c0711a7e38bd1fea1f9bf898334e0b/" rel="bookmark">
			Docker安装Nextcloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		群晖硬件：DS218+ 系统版本：DSM 7.0-41890 docker版本：20.10.3-1239 前言：NextCloud有不少应用，安装好后可以使用更丰富的应用。
1、安装Nextcloud映像 docker的注册表中搜索nextcloud，选中星最多的第一个右键下载
2、docker的映像中启动Nextcloud 映像中选中并启动
与此同时，点击右边按钮，下滑并找到如下界面
3、配置Nextcloud 存储空间添加文件夹，左侧是本地文件夹的位置，自定义即可，装载路径必须填写：
/var/www/html
本地端口固定为8888或其他，容器端口默认80即可
4、路由器开放端口 网路：一级路由器是光纤入户，二级路由器接入一级路由器，二级路由器在一级路由器下的IP是192.168.1.2
电脑连接二级路由器，浏览器输入192.168.124.1进入二级路由器设置界面（不同路由器输入不同），开始端口映射，外部和内部端口都设置为8888，内部服务器IP是NAS在二级路由器下的固定IP，这里是192.168.124.200。
外部端口是二级路由器对一级路由器的端口，当电脑连接二级路由器的时，输入192.168.1.2:8888即可进入，但这个方法不推荐，有可能失败。
推荐NAS和电脑在同级路由器下，内部端口是二级路由器内部的端口，当电脑连接二级路由器的时候，浏览器输入192.168.124.200:8888即可进入。
5、进入Nextcloud 浏览器输入192.168.124.200:8888进入Nextcloud，设置管理员和密码，安装过程需要等待。进入后可以安装自己想要的应用。
后记
无法远程使用，除非有公网IP。应用挺多，有群晖没有的思维导图应用，功能简单但是能用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6461efed85d7b3f5c92b75677678b4ba/" rel="bookmark">
			vue.js和vue.runtime.js之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue.js 是完整的版本包含了模板编译函数，通过查看vue.js源码发现，当使用完整版本的vue.js 时，调用$mount函数进行挂载的时候，$mount函数调用的是入下函数:
Vue.prototype.$mount = function ( el, hydrating ) { //query会根据el去查询要挂载到的节点，如果传的是字符串，类似dom元素的id、css类名或者元素类型如P div等等 el = el &amp;&amp; query(el); /* istanbul ignore if */ if (el === document.body || el === document.documentElement) { warn( "Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead." ); return this } var options = this.$options; // resolve template/el and convert to render function if (!options.render) { var template = options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6461efed85d7b3f5c92b75677678b4ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa231cfe18579cf697ee30fa524bcc73/" rel="bookmark">
			Linux下使用odbc连接sqlserver-202201-06
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：公司有一个需求，就是把集群上的数据查询出来导入到SQLserver中，但是有一个问题，需要集群可以访问这个SQLserver服务器，集群上需要安装一个客户端工具（类似于mysql），但是在Linux下SQLserver是没有的，MS从来没有提供过SQLServer for Linux,所以也不要去尝试在Linux系统安装SQLServer,但是可以通过ODBC连接Windows系统的SQLServer数据库； 系统环境：centos7 需要安装的软件 unixODBC-2.3.7.tar.gz
freetds-1.00.96.tar.gz
下载这两个压缩包的地址：
ftp://ftp.freetds.org/pub/freetds/stable/
ftp://ftp.unixodbc.org/pub/unixODBC/
也可以直接去下载我成功安装的版本，来我上传的地址
https://download.csdn.net/download/qq_38220334/74438120
安装步骤 第一步：上传两个安装包到服务器上 第二步：安装unixODBC，先安装这个，后安装freetds 注意：这里如果安装顺序不一致，就不会产生libtdsodbc.so驱动文件（非常重要）
解压unixODBC-2.3.7.tar.gz安装包 tar -zxvf unixODBC-2.3.7.tar.gz 进入解压后的目录后，按顺序执行下面的三个命令 ./configure --prefix=/usr/local/unixODBC make make install 第三步：安装freetds 解压freetds-1.00.96.tar.gz安装包 tar -zxvf freetds-1.00.96.tar.gz 进入解压后的目录后，按顺序执行下面的三个命令 说明：第一条命令的执行是依赖于unixODBC环境的
./configure --prefix=/usr/local/freetds --with-unixodbc=/usr/local/unixODBC make make install 第四步：配置freetds驱动 安装完成后，我们需要在usr/local/freetds-1.00.96/etc/freetds/freetds.conf中配置连接SQLServer的信息（不同版本的Linux系统存放文件的位置可能不同，你可以通过locate freetds.conf命令查看FreeTDS配置文件的可能位置）。该文件中默认已经有了配置连接信息的示例，我们只需追加以下信息即可（注意修改host、port为你真实的数据库网络地址与端口）,
[SQLSERVER]	# TDS服务名称 host = serverIP	# 数据库网络地址 port = 1433	# 数据库网络端口 tds version = 8.0	# TDS版本号 client charset = UTF-8	# 客户端字符集 接下来我们尝试使用命令tsql -S SQLSERVER -U username来连接SQLServer（其中-S指定了已经配置好的 TDS服务名称，-U指定登录数据库的用户名），连接成功则证明驱动配置正确。如果连接出现错误，很可能是因为tds version设置的不正确，你可以尝试修改该值重新连接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa231cfe18579cf697ee30fa524bcc73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b7be1c7e57bf5d9fa81a932ea9d9ef/" rel="bookmark">
			Embedding之padding_idx学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目解释举例case1:padding_idx=Nonecase2:padding_idx=0case3:padding_idx=3case4:padding_idx=3,将单词顺序变化 题目 padding_idx学习
解释 Embedding类
参数含义padding_idx (int, optional)If specified, the entries at :attr:padding_idx do not contribute to the gradient; therefore, the embedding vector at :attr:padding_idx is not updated during training, i.e. it remains as a fixed “pad”. For a newly constructed Embedding,the embedding vector at :attr:padding_idx will default to all zeros,but can be updated to another value to be used as the padding vector. |
什么意思呢？
意思就是padding_idx默认为None，如果指定的话，则padding_idx对应的参数不会对梯度产生影响，因此在padding_idx处词嵌入向量在训练过程中不会被更新。
举例 # 原段落有有5个单词,分别为 # index : word # 0 hello # 1 world # 2 morning # 3 goodbye # 4 sunshine case1:padding_idx=None #index=[0,1,2,3,4]分别代表上述单词 seq = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b7be1c7e57bf5d9fa81a932ea9d9ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878109286906e7bbf4cef5b8901b8b9e/" rel="bookmark">
			Spring的JdbcTemplate操作数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring的JdbcTemplate操作数据库 1、数据库结构2、引入相关 jar 包3、在 spring 配置文件配置数据库连接池4、配置JdbcTemplate对象，注入 dataSource5、实体类6、创建 service 和 dao 类7、数据库操作（1）增删改（2）查询返回某个值（3）查询返回对象（4）查询返回集合（5）批量处理 1、数据库结构 2、引入相关 jar 包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、在 spring 配置文件配置数据库连接池 &lt;!-- 开启组件扫描 --&gt; &lt;context:component-scan base-package="com.workhah"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123123"/&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="url" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878109286906e7bbf4cef5b8901b8b9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10ed04f917e70dfc6041613d24c6fc1/" rel="bookmark">
			DOS环境下编译出现报错:“ 非法字符: ‘\ufflb‘ 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非法字符: '\ufflb'的报错是属于 中英文符号 的问题.
出现这样的报错基本上就是友友的 分号 写成中文版的了 ,咱们吧分号改成英文版的分号就可以啦!
快去试一试吧!!!!
(小编也在努力学习更多哟!以后会多多分享哒!)
希望对友友们有所帮助!!!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd5d51e69710fa83c49d5ca19903433/" rel="bookmark">
			快速了解电力IEC104协议规约
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 规约简介
IEC104规约是一个广泛应用于电力、城市轨道交通等行业的国际标准。
2 专业术语解释
遥脉（电度量）：是指对现场某装置所发出的脉冲信号进行周期累计的一种远程计数操作。其实，遥脉也可以看成是被具体规定了采用脉冲计数作为测量方法的一种遥测手段，它是遥测中的一种。而传统意义上的四遥中是没有提及遥脉一词的。
四遥指的是：遥信、遥测、遥控和遥调（设点）；分别对应数字输入DI、模拟输入AI、数字输出DO和模拟输出AO
单点与双点的区别，以遥信为例，单点就是用一位标识一个遥信量，比如开关位置，只采集一个常开的辅助接点，值为1表示合位，0表示分位；而双点需要采集常开合常闭两个辅助接点位置，，当常开点值为1并且常闭点值为0，即10，则认为开关在合位；当常开点值=0并且常闭点值为1，即01，认为开关在分位；当两个位置值都为1，或两个值都为0，则认为开关位置不能确定。遥控也是一样的道理，SPI为遥信状态值。单点遥信，0分1合；双点遥信，1开2合，0和3为中间状态。
遥测的上送方式主要有定时主动上送（01H），响应总召唤上送（14H），越限上送（03H），而遥测值又分为归一化值、标度化值、短浮点数。
各遥测报文。其报文主体结构未变，改变是传送原因及类型标识。
归一化值（NVA）
值的范围为[-1，1]。归一化，即是将大于1的数映射到1以内的空间，通常就是用实际值除以额定值，即得到归一化的小数。具体表示法可以有F13或F16位的。占2个字节。
标度化值（SVA），值的范围为[-32768，~32767]，即带符号整数。占２个字节。它的真实值就是标度值*小数点的位数，量程和小数点位置是固定的参数。（相当于16位有符号整数）
注意：归一化值与标度化值都是两个字节。高字节的最高位为符号位， 0表示正数，1表示负数。15位数据位，正数是原码，负数是补码。
短浮点数（R32-IEEE STD 754） 即计算机内浮点数的表示法，占４字节
双传输，信息体元素可以用同一个信息对象地址来构成不同的ASDU，即带时标或者不带时标的单点信息。
遥测最多可配16384个，遥测最多可配4096个，遥控最多可配256个，遥脉最多可配512个。
3 104主站和从站之间的通信过程
104通讯过程:
a,建链、启动传输
b,是否启动确认 (未确认等待启动帧返回a)
c,站召唤
d,回答全数据
e,回答结束否 (等待d结束,未结束返回d)
f,有无定时任务
g,遥控遥调
h,对时测试
i,超时处理
j,接收变化数据
k,S-FORMAT确认 (确认完毕,返回f)
4 IEC104协议结构
第一个字节：启动字符固定16进制数68H，十进制为104（正好代表104规约吧），二进制为：0110 1000。
第二个字节：APDU长度，注意APDU长度并不包括1字节的启动字符和1字节的APDU长度本身，而由于只有1字节代表数据长度，其最大值为255(2^8 - 1)，所以最大值为255 - 2 = 253，又由于APCI除了这两个字节外还包括了4个字节的控制域（1~4），那么剩下的ASDU（可选的应用服务数据单元）长度为253 - 4 = 249字节。
5 104报文帧分类
IEC104协议的帧格式有三种（I帧、U帧、S帧）
I帧为信息帧，用于传输数据，长度大于6个字节，为长帧；
S帧为确认帧，用于确认接收的I帧，长度为6个字节，为短帧；
U帧为控制帧，用于控制启动/停止/测试，长度为6个字节，为短帧；
5.1 U格式：
不计数的控制功能类型，用于传输控制命令的报文。（U格式的APDU只包含APCI，帧长6字节。）
格式
类型
5.2 S格式：
计数的监视功能类型，用于传输对站端的确认的报文。（S格式的APDU只包含APCI，帧长6字节。）
格式
S格式的APDU的帧内容为如下6个字节：68 04 01 00 98 53 前四个字节固定，后两个字节表示接收序号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dd5d51e69710fa83c49d5ca19903433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a276f7f3a09cb1e133e26f61b384082c/" rel="bookmark">
			mysql 退出当前命令行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在’&gt; 再输入一个’(英文逗号)后再输入\c就可以退出了。事实是这样的:需要和&gt;前面的那个逗号’作匹配，再输入一个逗号作为结束字符后输入\c就可以退出了。
在&gt;后输入&gt;前的字符作为结束字符,再输入\c就可以sql命令行了。
例如‘&gt; 就需要输入‘\c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91952b8baaf0a4fecb4a8e367cae7398/" rel="bookmark">
			Redis的执行模型（Redis源码解析Redis真的是单线程模型吗？）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的执行模型 今天这篇文章，我们来聊聊 Redis 的执行模型。所谓的执行模型，就是指 Redis 运行时使用的进程、子进程和线程的个数，以及它们各自负责的工作任务。
在实际使用 Redis 的时候，可能经常会听到类似“Redis 是单线程”“Redis 的主 IO 线程”，“Redis 包含多线程”等不同说法。我也听到不少同学提出困惑和疑问：Redis 到底是不是一个单线程的程序？
其实，彻底理解这个问题，有助于指导我们保持 Redis 高性能、低延迟的特性。如果说 Redis 就是单线程程序，那么，我们就需要避免所有容易引起线程阻塞的操作；而如果说 Redis 不只是单线程，还有其他线程在工作，那么，我们就需要了解多线程各自负责什么任务，负责请求解析和数据读写的线程有几个，有哪些操作是后台线程在完成，而不会影响请求解析和数据读写的。
所以，今天这篇文章，我就从 Redis server 启动后运行的进程开始，带你一边学习 Redis 源码中子进程和线程的创建方式，一边掌握 Redis server 运行时涉及到的进程、子进程和线程情况。
下面，我们先来看 Redis server 启动时的进程运行。
从 shell 命令执行到 Redis 进程创建 我们在启动 Redis 实例时，可以在 shell 命令行环境中，执行 redis-server 这个可执行文件，如下所示：
./redis-server /etc/redis/redis.conf shell 运行这个命令后，它实际会调用 fork 系统调用函数，来新建一个进程。因为 shell 本身是一个进程，所以，这个通过 fork 新创建的进程就被称为是 shell 进程的子进程，而 shell 进程被称为父进程。关于 fork 函数的具体用法，我一会儿还会给你具体介绍。
紧接着，shell 进程会调用 execve 系统调用函数，将子进程执行的主体替换成 Redis 的可执行文件。而 Redis 可执行文件的入口函数就是 main 函数，这样一来，子进程就会开始执行 Redis server 的 main 函数了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91952b8baaf0a4fecb4a8e367cae7398/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7014e879d98e365b8ddee6cbd1fac67d/" rel="bookmark">
			数字图像处理试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首发于
编程技术
写文章
登录
数字图像处理
水dong方块
水dong方块
1 人赞同了该文章
主观题
大题拉普拉斯滤波器好像是每年必考，空域和频域的转换，这个参考课后题用傅里叶变化的性质。 今年还考了一个ADI如何得到没有运动物体的背景图（没有认真看哭了）。 另外主成分分析也是喜欢考的，会考均方误差（等于没有算进去的特征值的和）
一、直方图均衡 给出8灰度级图像灰度分布频率，求： 1.直方图均衡的计算步骤 2.画出直方图 3.说明图像对比度和直方图之间的关系 4.举例说明直方图在图像分割中的应用
二、 给定模板 T=[-1 -1 -1；-1 9 -1；-1 -1 -1]，求 1.记图像为f(x,y)，求用模板T在空间域处理后的图像g(x,y)的表达式。 2.求该模板对应的h(x,y) 3.求H(u,v) 4.该模板滤波效果与在实际中的应用情况举例 三、用某工业相机拍摄一堆苹果的灰度图像 1.如果成像过程中，被0均值9方差噪声污染，如何去噪 2.被10%胡椒、10%盐粒噪声污染，如何去噪 3.被周期干扰，如何去除，去噪参数如何确定。 4.现考虑图像内容为一堆香蕉，成像过程中由于镜头缺陷发生了退化，退化可以用某H模拟（H已给出），问复原方式，该复原方式有什么缺陷 5.如何克服上述缺陷
四、形态学 一张简单图像，四个结构元，只涉及膨胀、腐蚀、开操作，注意非对称结构元即可。
五、霍夫变换 1.直线的法线方程与斜截式方程的参数对应关系
2.图像为一个正方形，正方形的四角和中心共五个点12345，给出霍夫空间的五条正弦曲线abcde，求对应关系；求五条正弦曲线中某几条的几个交点的精确坐标。
3.在图像上标出了另一个点，画出其霍夫变换曲线
六、 1.黄光照射到青色物体上，看到什么颜色 2.RGB转HSI 3.忘了 4.忘了
5.主分量压缩：给出6个特征值，在只保留2个的情况下，计算解码图像与原图像之间的均方误差
六、3、 物体30像素x30像素，13帧，沿东北方向匀速直线运动了60√2，求速度 4、物体红色，问能否利用计算机通过某种算法提取出背景，剔除物体（大概是这么个意思？
19年 一、直方图均衡 给出8灰度级图像灰度分布频率， 求： 1.直方图均衡的计算步骤
每一级的概率求和
求累计分布函数. ni/n求和 x L-1, 四舍五入取整 ,同一级的合并.
2.画出直方图
3.说明图像对比度和直方图之间的关系
均衡后的直方图跨越了更宽的灰度范围，增强了对比度
4.举例说明直方图在图像分割中的应用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7014e879d98e365b8ddee6cbd1fac67d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e0c401d41cdb26ca5db7f6057178767/" rel="bookmark">
			提示‘utf-8‘ codec can‘t decode byte 0xc8 in position 0: invalid continuation byte解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pd.read_csv(fpath,encoding='gb18030')
国标编码
其他解决办法参考：
用python3读csv文件，出现UnicodeDecodeError: 'utf-8' codec can't decode byte 0xd0 in position 0: invalid con_moledyzhang的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7bcde86f7cd1827372bab3ebeac908/" rel="bookmark">
			【git】git简单操作--项目gitlab命令集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载git 官网链接
安装可参考博客 点击此处
二、初始化git
①进入文件夹
②第一次进入，应该只出现的是文件目录
git init 出现 master就ok了
三、clone项目
①gitlab或github上复制项目链接
②bash窗口输入 clone命令
git clone xxxxxx.git 四、本地仓库操作
4.1把工作区代码上传到暂存区（查看status 可以看到文件名是绿色的，未add之前文件名是红色的）
git add hello.txt 4.2把暂存区的代码提交到本地仓库
git commit -m "kristina first commit" hello.txt 五、远程仓库操作
5.1查看已经配置的远程仓库服务器【列出每一个远程服务器的简写 origin，如果没配置的话，没有返回结果】
git remote git remote -v 【注】①第一条命令只出现远程库的简写（add远程库时自定义的名称）
②第二条命令在远程库简写后面出现具体的服务器路径，包括fetch和push
5.2添加远程仓库
git remote add [简写] [远程库路径] 5.3从远程仓库克隆
git clone [远程库路径] 5.4移除远程仓库（只是从本地移除远程仓库的记录）
git remote rm [简写] 5.5把暂存区的代码上传到版本库
git push origin master:[branchname] 【注】若直接master分支上传，即master:master
5.6从远程仓库中拉取最新版本的到本地仓库，不会自动merge
git fetch [简写] [分支] 5.7拉取之后手动合并
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7bcde86f7cd1827372bab3ebeac908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951a3c92a26c2411d218eebc97019b60/" rel="bookmark">
			git修改远程仓库地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法1： 命令：直接修改
git remote set-url origin url
方法2： 命令：先删再加
git remote rm origin
git remote add origin url
注：修改完地址，每次git pull都要重新输入git账号密码
可通过执行命令 git config --global credential.helper store
之后再进行git pull ，输入一次账号密码，会记住，就不用输入了
方法3： 直接修改.git目录下config文件中远程url
idea： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e29c27861d43fd3fc3574bc862ff35b/" rel="bookmark">
			electron electron-builder 打包exe 排除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 排除文件，不会压缩进 app.asar 的资源，但是会出现在resources/app.asar.unpacked文件夹下
"win":{ "target": [{ "target":"nsis" }], "icon":"build/favicon.ico", "asarUnpack":[ "src/**", "README.md" ] }, 如果不想文件出现在 resources/app.asar.unpacked，还可以排除打包，这样就不会被打包进程序
{ "build": { "files": [ "src/**", "README.md" ], } } 如果还行复制资源到安装包中，可以这样配置：
{ //其他内容省略 “build”:{ //打包时复制项目目录下的res中文文件到 打包后的exe所在目录的res文件夹中，文件夹下没有文件的话不会复制 "extraResources": [{ "from": "./res/", //默认打包到resources目录下 所以这里使用了../ // "to": "res" 则是复制到 resources/res 目录下 "to": "../res" },{ "from": "./zz", "to": "zz" }] } } electron-builder中两个常用的配置选项extraResources(拷贝资源到打包目录Resources中)、extraFiles(拷贝资源到打包目录的根路径), 详细文档 帮助我们轻松实现增量更新。 参考链接：
electron 打包时文件复制到程序目录下 - 荣超 - 博客园
electron-builder 打包项目并生成安装包的方法 | 梓喵出没
Electron客户端场景化更新升级方案实践 - 知乎 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6cde07460b27144ceb09b350894bb5/" rel="bookmark">
			如何利用后端给的url，前端下载图片、音频、视频等文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端给了url，让前端处理下载，刚开始只处理图片url下载，然后用最简单的方式，创建a标签，叫download属性，发现竟然不行，找了一下原因，原来是url地址跨域了，这里需要让后端处理一下服务器对url跨域问题，然后前端代码线上：
downPic(urls, fileName) {
const image = new Image()
// 解决跨域 Canvas 污染问题
image.setAttribute('crossOrigin', 'anonymous')
image.onload = () =&gt; {
const canvas = document.createElement('canvas')
canvas.width = image.width
canvas.height = image.height
const context = canvas.getContext('2d')
context.drawImage(image, 0, 0, image.width, image.height)
canvas.toBlob((blob) =&gt; {
const url = URL.createObjectURL(blob)
const a = document.createElement('a')
a.download = fileName || 'photo'
a.href = url
a.click()
a.remove()
URL.revokeObjectURL(url)
})
}
image.src = urls
},
后端处理服务器跨域问题之后，这种方式的确可以下载图片；但是！后来增加需求，要同时满足下载音频和视频，用这种方式就不行了！只能想其他办法：
后来去网上找了很多办法，最终了解到，想要下载音频和视频 只能让后端把url转成文件流格式的数据，然后前端才能下载；上代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc6cde07460b27144ceb09b350894bb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409c08f7477d1ff8762ed3f1e8cd7643/" rel="bookmark">
			Linux高性能服务器编程笔记（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 TCP/IP通信案例 4.2 部署代理服务器 4.2.1 HTTP代理服务器的工作原理 正向代理服务器：要求客户端自己设置代理服务器的地址，客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源（client-&gt;proxy-&gt;Internet），示例：翻墙
反向代理服务器：被设置在服务器端，用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端。（Internet-&gt;proxy-&gt;client）
透明代理服务器：只能设置在网关上，可以看做正向代理的一种特殊情况
4.4 DNS服务器 DNS的过程：
程序通过读取/etc/resolv.conf文件获取DNS服务器的IP地址，然后将控制权传递给内核中的UDP模块。UDP模块将DNS查询报文封装成UDP数据报，同时将源端口号和目标端口号加入UDP数据报头部。调用IP服务，将UDP数据报封装成IP数据报，将源端IP和通过步骤1查询到的DNS服务器IP地址加入IP数据报头部（值得留意的是src和dst的IP在传输过程中是不变的）。此时，IP模块查询路由表。由于只能匹配默认路由项，因此先被发送至路由器，然后通过路由器转发。（此时的dstIP地址仍然是DNS服务器）ARP缓存中没有与路由器对应的缓存项，需要发起ARP广播来查询路由器的IP地址。查询成功后，以太网举动程序将IP数据报封装成以太帧发给路由器。 4.6 HTTP请求 4.6.1 HTTP请求方法 其中，HEAD,GET,OPTIONS和TRACE是安全的，而POST,PUT,DELETE和PATCH则影响服务器上的资源。
GET,HEAD,OPTIONS,TRACE,PUT和DELETE等请求方法被认为是等幂的，即多次连续的、重复的请求和只发送一次该请求具有完全相同的效果。则POST方法则不同，连续操作可能进一步影响服务器上的资源。
PS：GET和POST的区别？
GET是从服务器上获取资源，POST是向服务器提交数据。GET是幂等的，也就是重复操作具有相同效果，而POST的重复操作可能影响到服务器的资源。
4.6.2 HTTP应答 常见的状态码和状态信息及其含义
Cookie的作用：
Cookie是服务器发送给客户端的特殊信息（通过HTTP应答的头部字段“Set-Cookie”），客户端每次向服务器发送请求的时候都需要带上这些信息（通过HTTP请求的头部字段“Cookie”）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7868a7838937928798673f4cd3cf71a9/" rel="bookmark">
			VSCode中vue代码的ctrl&#43;点击无法跳转定义问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode中vue代码的ctrl+点击无法跳转定义问题 安装三个插件：
vscode-elm-jump：常规的代码跳转定义
Vue CSS Peek：按ctrl可以跳转css定义
vue-helper：变量函数跳转定义
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97e6b10341bf2a4d700d02d1bfe1a12/" rel="bookmark">
			程序设计语言基础 部分题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-3 将x的平方赋值给y (5 分) 假设x的值为3，计算x的平方并赋值给y，分别以“y = x ∗ x”和“x ∗ x = y”的形式输出x和y的值。
输入格式： 本题无输入
输出格式： 按照下列格式输出代入x=3的结果：
作者 颜晖 单位 浙大城市学院
y = x * x x * x = y #include&lt;stdio.h&gt; int main() { int x=3,y=x*x; printf("%d = 3 * 3\n3 * 3 = %d",y,y);//空格 return 0; } 7-4 计算物体自由下落的距离 (5 分) 一个物体从100米的高空自由落下。编写程序，求它在前3秒内下落的垂直距离。设重力加速度为10米/秒2。
输入格式: 本题目没有输入。
输出格式: 按照下列格式输出
height = 垂直距离值 结果保留2位小数。
作者 C课程组 单位 浙江大学
#include&lt;stdio.h&gt; int main() { int g=10,t=3; double h=g*t*t/2;//int h=g*t*t/2,g=10,t=3;error: ‘g’ undeclared (first use in this // function) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c97e6b10341bf2a4d700d02d1bfe1a12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adde99872054702721e48c9ae1606551/" rel="bookmark">
			程序设计语言部分总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算公式：C=5×(F−32)/9，//如果直接复制公式，可能有中文空格或者中文字符导致编译错误。 1. int n; scanf("%d\n",&amp;n);//下面有gets输入字符串函数，scanf必须加\n book a[n]; for(int i=0;i&lt;n;i++) { gets(a[i].name); scanf("%lf\n",&amp;a[i].price);//回车别敲错了,当scanf与gets一同使用时，scanf必须加\n } 2. int max(b a[],int n)最大值函数 { int m=0; for(int i=1;i&lt;n;i++)//比较时，下标从1或0开始都可以 { if(a[i].price&gt;a[m].price) m=i; } return m; } 3.f表示结构体类型 void sort(f a[],int n)//年龄从大到小,shengri是整型的，由小到大1960&gt;1964的年龄,其实就是由int小到大排序 { for(int i=0;i&lt;n-1;i++) { for(int j=i+1;j&lt;n;j++) { if(a[i].shengri&gt;a[j].shengri)//排序是结构体整体排序，不仅仅是shengri排序 { /*f t; t.shengri=a[i].shengri; a[i].shengri=a[j].shengri; a[j].shengri=t.shengri;就错得离谱*/ f t=a[i];//应该是整个结构体交换数据，不能只交换结构体一部分数据 a[i]=a[j]; a[j]=t; } } } } 1.根号函数:sqrt(n); 幂函数,pow(n,3);n3 c=n%100;//取百位 2.Switch结构 Switch(n) { case 1:0000;break; default :0000;break; } Switch(op) { case ‘+’:c=a+b;break; case ‘-’:c=a-b;break; default : break; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adde99872054702721e48c9ae1606551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6fdfea8f603def861e3ce4ff03c41d3/" rel="bookmark">
			PTA 6-1 找两个数中最大者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求对两个整数a和b，输出其中较大的数。
函数接口定义： int max( int a, int b ); 其中a和b是用户传入的参数，函数返回的是两者中较大的数。
裁判测试程序样例： #include &lt;stdio.h&gt; int max( int a, int b ); int main() { int a, b; scanf("%d %d", &amp;a, &amp;b); printf("max = %d\n", max(a, b)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： -5 8 结尾无空行
输出样例： max = 8 结尾无空行
int max( int a,int b) { if(a&lt;b) { return b; } else if(a&gt;b) { return a; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3734d57a8c47e60b46f1319e2b833a0e/" rel="bookmark">
			松下，日立，索尼，NEC，三菱，爱普生，东芝，飞利浦，等投影机灯清零方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对一些朋友对投影机不了解，需要 投影机灯清零方式，搜集了以下投影机灯清零方式方式，如果有其它需要补充请私信我增加
Panasonic (松下) 投影机的清零方法
松下投影机的清零方法:先按“MENU”找到灯泡使用时间，再按“ENTER”三秒，出现“POWER OFF”后，关掉电源重新启动OK！
Hitachi(日立) 投影机清零方法
日立投影机清零方法:开机中，按RESET健3秒，出现时间对话,选择0就OK了。
SONY (索尼) 投影机清零方法
索尼清零方法：RESES+左+右+确定（适用索尼大部分机型）
NEC(日电) 投影机清零方法
830/840/850/440等系列时间到的话会出现二个指示灯亮，包括LAMP指示灯,清零方法是待机下按遥控器OFF健20秒左右，在遥控器底部有一个耳机插口，如果有线的话可连接到投影机的遥控器输入口，这样清零会方便一点。
3M　投影机清零方法
日立OEM的清零方法:在开机下，按RESET健3秒,会出现一个时间有对话,选择0就好了。
Mitsubishi (三菱) 投影机清零方法
三菱投影机清零方法:在待机下按左+右+电源。
Epson (爱普生) 投影机清零方法
爱普生投影机清零方法(只适用灯架处有电阻)的机器，在灯架处有一个小电阻（清零用的），只要把机器中相对应的４个小针短路一下就行了，这个会烦一点，且短路弄不好还会可能烧主板。
Toshiba(东芝) 投影机清零方法
东芝投影机清零:在不接电源下按电源+菜单+确定+输入,按住不放接电源3秒钟，适用780以前所有的机器。
Philips(飞利浦) 投影机清零方法
飞利浦投影机清零方法:开机中，菜单中选择灯泡时间栏,按投影机上的OK键3秒。
SANYO(三洋)、EIKI(爱其)、Canon(佳能)投影机清零方法
全部在菜单中，有LAMP字样这栏,全部是YES，
PLUS(普乐士) 投影机清零方法
PLUS U2-811 U2-815 U2-815C U2-1110 U2-1130 U2-X1130C U2-1150 ，灯泡在1100个小时内清零菜单选到时间上，按遥控器上ON8秒钟左右。使用1100小时后无法开机状态下直接按遥控器上ON25秒左右
PLUS U3-810SFC U3-1080SFC U3-810WZC U3-1080WZC U2-X200UC 4-161 U4-121 、V-1080C V-807C V-1100C U2-850 U2-1500 U2-850W U2-1500W U5-121 U5-162 ，菜单里灯泡定时器清零
INFOCUS(富可视)、ASK(美投神) 、Proxima(宝施玛)、IBM投影机清零方法
一般的是在菜单里清，富可视500/530 在开机下,按菜单+音量减3秒钟,后打开菜单看看有没有清,如没有可以多试几次，IBM是INFOCUS代工的，参考INFOCUS 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3734d57a8c47e60b46f1319e2b833a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640b0df67d3e32477007ba8514b4bcae/" rel="bookmark">
			docker嵌入式开发(七)docker安装qt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker安装qt 1. 前言2. 安装ubuntu-desktop3. 安装qt4. 注意4.1 TCP4.2 QtXlsx 5.目录 1. 前言 之前开发产品，数据通过TCP通信发送到个人电脑上，进行数据分析，现在部署到服务器，需要Linux编译环境，然后打包再发布到其他服务器。
2. 安装ubuntu-desktop $ sudo docker pull dorowu/ubuntu-desktop-lxde-vnc $ docker run -dit \ --name ubuntu-desktop-lxde-vnc \ -p 6080:80 -p 5900:5900 -p 6004:22 -p 6005:6005\ -e VNC_PASSWORD=liulinjie \ -v /dev/shm:/dev/shm \ dorowu/ubuntu-desktop-lxde-vnc 参数作用-p 6080:80web桌面-p 5900:5900vnc桌面-p 6004:22ssh连接-p 6005:6005tcp通信-e VNC_PASSWORD桌面登录密码 web登录：宿主机IP:6080
配置ssh
# apt-get update /* 配置容器登录密码 */ # apt-get install passwd # passwd 输入密码 /* 安装软件包 */ # apt-get install openssh-server net-tools inetutils-ping git vim /* 配置SSH */ # vim /etc/ssh/sshd_config 修改PermitRootLogin yes # service ssh restart 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/640b0df67d3e32477007ba8514b4bcae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6277e607f4b1aecb8242ef7b3a7226/" rel="bookmark">
			安装 Samba 网络共享服务， 可以通过网络访问我们指定的文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		samba 是一种网络共享服务， 可以通过网络访问我们指定的文件夹。
做嵌入式开发， 大部分的时间都是在写代码或者修改代码， 这个过程我们一般是在 windows 上进行的， 然后把我们改好的代码放到 ubuntu 上进行编译， 这一步我们可以使用 tftp 软件来完成。 但是如果我们经常修改代码， 这一步就太麻烦了， 有一个简单的办法， 即可以安装 samba 文件来实现。 比如把我们 ubuntu 的存储空间指定为我们 windows 上的一个磁盘， 然后我们在这个磁盘里面创建 .c 文件， 进行我们代码的修改和编写， 可以安装 samba 文件来实现。
第一步： 下载 samba
sudo apt-get install samba
第二步： 修改 samba 配置文件
sudo vi /etc/samba/smb.conf
添加如下内容：这些信息都是 samba 的说明和设置， 把这些复制上， 格式要设置对， 使用 Tab 键缩进， 然后把注释删除， 不然可能会出错。
[ubuntu_samba]
comment = arm ubuntu samba dir #说明
path = /home/samba #共享的 samba #目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6277e607f4b1aecb8242ef7b3a7226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75ba73c0dddf9ce6e19b2d4acadf2b3/" rel="bookmark">
			开发工具IEDA的使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发工具IEDA的使用技巧 一、项目初始配置二、开发中必会的技能三、运行与调试项目四、高级进阶五、常用插件 此处的介绍来自慕课网的课程 https://www.imooc.com/video/20965，开发工具IDEA从入门到爱不释手 一、项目初始配置 略
二、开发中必会的技能 1、高级的代码编辑技能
(1)纵向选择多行文本： Alt + 鼠标左键并拖动
(2)复制光标所在行： Ctrl + D
(3)当前行向上/下移动一行： Alt + shift + 上/下
(4)移动选中的多行： 1）shift + 上，选中两行； 2）Alt + shift + 上/下移动
2、快速跳转
(1)跳到行首：Home键；跳到行尾：End键
(2)一次跳一个词：Ctrl + 左/右
(3)向左/向右选中一个词：Ctrl + shift + 左/右
(4)跳到指定行（生产环境）：Ctrl + G
(5) Tabs快速切换：Alt + 左/右
(6)查看浏览过的文件： Ctrl + E
(7)快速打开文件所在的文件夹： 选中文件 -&gt; 右键 -&gt; show In Explorer
(8)自动生成返回值：Ctrl + Alt + V
3、快速查找和替换
(1)当前文件的查找 ： Ctrl + F
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75ba73c0dddf9ce6e19b2d4acadf2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b6830b0b920032b01a14ca1496b091/" rel="bookmark">
			Oracle11g 数据库详细完整卸载步骤图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 完全卸载oracle11g步骤： 一、停止服务二、软件卸载三、注册表删除四、删除环境变量五、删除组和图标六、删除本地文件七、其他 ) 一、停止服务 开始－-＞设置－-＞控制面板－-＞管理工具－-＞服务- -&gt;停止所有Oracle服务
二、软件卸载 开始－-＞程序－-＞oracle - OraHome81－-＞Oracle Installation Products－-＞ Universal Installer，单击“卸载产品”–“全部展开”，选中除“OraDb11g_home1”外的所有目录，然后删除。
三、注册表删除 运行输入regedit，删除以下注册表
HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services删除所有Oracle入口
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application删除所有Oracle入口
HKEY_CLASSES_ROOT目录下所有以Ora、Oracle、Orcl或EnumOra为前缀的键。
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\MenuOrder\StartMenu\Programs中所有以oracle开头的键。
HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI中除MicrosoftODBC for Oracle注册表键以外的所有含有Oracle的键。
尽量把注册表中的包含oracle的注册表删除干净
四、删除环境变量 我的电脑—&gt;属性—&gt;高级—&gt;环境变量，删除环境变量CLASSPATH和PATH中有关Oracle设定。
五、删除组和图标 从桌面上、STARTUP（启动）组、程序菜单中，删除全部有关Oracle的组和图标。
六、删除本地文件 删除全部与Oracle相关的目录(如果删不掉，重启计算机后再删就可以了)包括：
C:\Program file\Oracle的目录。ORACLE_BASE目录(oracle安装目录)。C:\WINDOWS\system32\config\systemprofile\Oracle的目录。C:\Users\Administrator\Oracle或C:\Documents and Settings\Administrator\Oracle的目录。C:\WINDOWS下删除以下文件ORACLE.INI,oradim73.INI、oradim80.INI、oraodbc.ini等。C:\WINDOWS下的WIN.INI文件中若有[ORACLE]的标记段，删除该段。 七、其他 如有必要，删除全部Oracle相关的ODBC的DSN最后重启电脑查看任务管理器中服务中是否还存在有关oracle的服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9f8762a7557f63a85e7bebfdb96bcf/" rel="bookmark">
			Linux下通过定时任务检测进程并重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、重启特定进程的脚本 #! /bin/bash ps -ef | grep "进程名字" | grep -v grep #如果进程搜索不出来，则$?的值为1，否则值为0 #当$?值不等于0的时候，重新启动进程 if [ $? -ne 0 ] then cd "进程所在目录" &amp;&amp; "执行进程的语句" else echo "running" fi 二、将上述脚本设置为定时任务 设置定时任务需要用到crontab
crontab [-u username]　//省略用户表表示操作当前用户的crontab -e (编辑工作表) -l (列出工作表里的命令) -r (删除工作作) 用crontab -e进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。
crontab的命令构成为 时间+动作，其时间有分、时、日、月、周五种，操作符有
取值范围内的所有数字/ 每过多少个数字-从X到Z，散列数字 每五分钟执行 */5 * * * * 每五小时执行 0 */5 * * * 每天执行 0 0 * * * 每周执行 0 0 * * 0 每月执行 0 0 1 * * 每年执行 0 0 1 1 * 三、一些坑 crontab定时任务需要至少有能够执行crontab命令的权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe9f8762a7557f63a85e7bebfdb96bcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593c6120d9787c4d1dbd3caa06c72cbd/" rel="bookmark">
			软件测试之测试理论(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 什么是软件测试2. 测试主流技能3. 测试常用分类4. 模型4.1 质量模型4.2 W模型 5. 测试流程6. 测试用例 1. 什么是软件测试 软件测试就是使用技术手段验证软件功能是否符合要求
2. 测试主流技能 功能测试
跟进开发文档, 使用正向思维及逆向思维验证软件功能是否实现自动化测试
使用工具或者代码, 代替人工来进行批量测试.接口测试
针对模块与模块或系统与系统之间数据请求地址进行测试.性能测试
模拟多人使用软件, 查找服务器缺陷 目前市场划分大致
功能+接口自动化+接口接口+性能 3. 测试常用分类 按阶段划分 单元测试: 针对程序源代码进行测试(开发)集成测试: 又称接口测试, 主要针对模块与模块或系统与系统之间的接口进行验证.系统测试: 针对软件全面进行验证(功能, 兼容, 安全, 性能)验收测试: 使用内测, 公测来实现 内测: 公司内部进行测试.公测: 让玩家来进行测试. 按代码可见度划分 黑盒测试: 又称功能测试(完全看不见程序源代码, 只能针对功能进行验证)灰盒测试: 又称接口测试(看不见部分代码)白盒测试: 又称单元测试(针对程序源代码进行测试) 扩展-总结 系统测试和黑盒测试重点核心是功能测试自动化测试归属功能测试集成测试和灰盒测试又称接口测试单元测试和白盒测试是针对代码进行测试性能测试, 安全测试归属专项测试 扩展-测试策略 冒烟测试: 大规模执行测试之前, 针对程序主功能进行验证, 保证程序具备可测性.
面试题: 你们公司的提测标准是什么–&gt;冒烟测试通过. 测试之前要怎么做?–&gt;冒烟测试 4. 模型 软件测试有两个模型
质量模型测试模型 4.1 质量模型 质量模型提供测试设计的不同角度视野和验证方向
换句话说, 质量模型我们学会的是针对任何软件或硬件, 我们能知道测试的方面有哪些.需要考虑的有哪些方面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/593c6120d9787c4d1dbd3caa06c72cbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8ee99ebcc0b14e00a755acf5e68486/" rel="bookmark">
			Android基础之Material Design | NavigationView | FloatingActionButton | SnakerBar等 | 带源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Material Design 简介 一套全新的界面设计语言，包含了视觉、运动、互动效果等特性 ToolBar 在res下新建一个menu文件夹，新建一个toobar.xml文件 &lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;!-- showAsAction的三种含义 always表示永远显示在toolBar中 ifRoom表示若屏幕空间足够显示在toolBar中 never表示永远显示在菜单当中 且toolBar中只会显示图片 菜单中只会显示文字--&gt; &lt;item android:id="@+id/backup" android:icon="@drawable/ic_backup" android:title="@string/backup" app:showAsAction="always"/&gt; &lt;item android:id="@+id/delete" android:icon="@drawable/ic_delete" android:title="@string/delete" app:showAsAction="ifRoom"/&gt; &lt;item android:id="@+id/settings" android:icon="@drawable/ic_settings" android:title="@string/settings" app:showAsAction="never"/&gt; &lt;/menu&gt; activity_main.xml &lt;androidx.appcompat.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="?attr/colorPrimary" android:minHeight="?attr/actionBarSize" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/Theme.AppCompat.Light" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; MainActivity public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); } public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8ee99ebcc0b14e00a755acf5e68486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc654b1eb360c389c3c420b540c0e38/" rel="bookmark">
			【周一通勤电台】Spring Data JPA 极速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，大家好，这里是翊君@周一通勤电台频道。
0.阅读完本文你将会学会 如何在Spring项目中引入Spring Data JPA 本文一共约1800读时长大概等于一首黑眼豆豆的《Where Is The Love?》。
1. 概述 这篇文章将重点介绍如何在Spring项目中引入Spring Data JPA，并全面配置持久化层。
2.Spring Data生成的DAO–不再有DAO的实现 DAO层的设计中含有很多样板代码，它应该被简化。这种简化的好处有很多：减少我们需要定义和维护的组件数量；维护数据访问模式的一致性；以及维护配置的一致性。
Spring Data将这一简化又向前推进了一步，使得完全删除DAO的实现成为可能。现在DAO的接口是我们唯一需要明确定义的组件。
为了开始利用JPA的Spring Data编程模型，一个DAO接口需要扩展JPA特定的Repository接口JpaRepository。这将使Spring Data能够找到这个接口并自动为其创建一个实现。
通过扩展接口，我们得到了标准DAO中可用的CRUD方法。
3.自定义访问方法和查询 正如上文所讨论的，通过实现Repository的一个接口，DAO将定义和实现一些基本的CRUD方法和查询。
为了定义更具体的访问方法，Spring JPA支持以下选项：
只需在接口中定义一个新的方法通过使用@Query注解来提供JPQL查询。使用Spring Data中更高级的Specification和Querydsl支持。通过JPA命名查询定义自定义查询 第三个选项，Specification和Querydsl支持，类似于JPA标准，但使用更灵活和方便的API。这使得整个操作的可读性和可重用性大大增强。在处理大量的固定查询时，这种API的优势将变得更加明显，因为我们有可能通过数量较少的可重用代码块来更简洁地表达这些查询。
最后一种方案的缺点是，它要么涉及到XML，要么让实体类承担查询的负担。
3.1 自动的自定义查询 当Spring Data创建一个新的Repository实现时，它分析了所有由接口定义的方法，并试图从方法名称中自动生成查询。虽然这有一些局限性，但这是一种非常强大和优雅的方式，只需少量工作就可以定义新的自定义访问方法。
我们可以看一个例子。如果实体有一个名字字段以及Java Bean标准的getter和setter方法，我们将在DAO接口中定义findByName方法。这将自动生成正确的查询：
public interface IFooDAO extends JpaRepository&lt;Foo, Long&gt; { Foo findByName(String name); } 这是一个相对简单的例子。查询创建机制支持更多的关键词：
如果解析器不能将该属性与域对象字段相匹配，我们会看到以下异常。
java.lang.IllegalArgumentException: No property nam found for type class com.jayxu.spring.data.persistence.model.Foo 3.2 手动自定义查询 现在让我们看看一个自定义查询，我们将通过@Query注解来定义。
@Query("SELECT f FROM Foo f WHERE LOWER(f.name) = LOWER(:name)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc654b1eb360c389c3c420b540c0e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f856cbd8afd67cbbf58a4afecc6bd2d/" rel="bookmark">
			二级索引（hbase和es）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二级索引是为了让HBase能够提供多维度的查询能力。
ES+HBase实现二级索引：
查询条件和Rowkey存储到ES，适合复杂的条件查询和聚合查询。需要到处与结果相关联的原始数据时，根据结果的Rowkey去HBase查找。
图片类似：https://img-blog.csdn.net/20150707220421422
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd5f6222d3abba6b30f981782bb386c/" rel="bookmark">
			关于芯片中电源纹波抑制比PSRR参数的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
1.电源纹波抑制比PSRR： 一般的转换器芯片都有这个参数，其就是评估芯片对供电电源纹波的抑制能力的一个参数。对于任意一款芯片，按照要求给芯片VCC管脚供电时，其可以输出一定的信号，满足我们的使用。但若是给芯片VCC管脚供电的电源有一定幅度的纹波时，芯片的输出是否正常呢。因此就引出了PSRR这个参数。
PSRR参数有直流PSRR和交流PSRR两种区分。我们一般只谈交流PSRR。其公式为：**
PSRR(db)=20log(Vinripple/Voutripple)。
Vinripple一般为芯片供电电源的纹波电压幅度，Voutripple为芯片的输出纹波电压幅值，不同的芯片，Voutripple所指的参数不一致，现一一介绍。
2.LDO芯片的PSRR 对于LDO芯片而言，PSRR是一个比较重要的指标。其表征了LDO芯片对电源纹波的抑制能力。下图是TLV1117芯片的PSRR参数的数据图片。
可以看出，PSRR参数跟芯片的负载电流Iout、Vin-Vout的差值有关。从图中可以看出，1khz时，芯片的PSRR参数数据为65db。我们来一一分析一下。
这个65db的含义表示，当对LDO芯片的电源端供电时，电源端输入1khz，1v的纹波电压，LDO芯片的输出端产生的纹波为560uv（根据公式计算）。
这个数据还是比较理想的，说明LDO芯片对纹波的抑制能力还是不错的。那么我们接着看上图的图片。对于1M的纹波，其PSRR为40db，相当于纹波缩小了100倍。随着频率越来越高，PSRR参数下降的越厉害。
3.运放芯片的PSRR PSRR是运放芯片的一个重要参数。针对运放而言，
PSRR(db)=20log(Vinripple/Voutripple)。
这里Voutripple为Vos电压，即运放的失调电压。因此，运放芯片的电源纹波一定要小，纹波太大，会引起运放较大的失调电压，导致芯片的输出产生偏差。
上图是芯片AD8618的PSRR参数数据。可以看出，高频时，芯片对纹波的抑制能力较差。我们以一个电路进行分析一下。
我们以此电路进行分析。我们假设运放芯片的电源输入端的纹波为1Mhz，100mv，通过查询PSRR约为30db。
通过公式计算可得，输入端为1Mhz，100mv的纹波，其传递给运放芯片的Vos为3.16mv。然而，此电路运放的放大倍数为100倍，因此，最终在负输入端的3.16mv失调电压，最终传递到Vout端便为316mv的误差电压，此数据会影响运放的精度。
另外，像芯片ADC、DAC也有PSRR参数，其对应的参数不一样，在此不进行介绍。其实就是一句话，PSRR就是评估芯片对输入电源纹波的抑制能力的参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b3cd4b7cc93c845cc7640ac18839e02/" rel="bookmark">
			cubemx快速使用串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cubemx快速使用串口 前言一、使用cubemx进行串口基本配置二、说明三、实验内容1.串口打印2.串口中断实现回显3.串口接收选择回显内容 前言 助力于快速使用串口功能，如果想了解串口协议等知识点等请自行搜索， 这里注明串口下功能实现常用的fputc、字符串发送函数、fgetc函数等函数写法。 实验了三个例子来展示printf函数、串口中断使用、串口基本使用。 一、使用cubemx进行串口基本配置 二、说明 一般配置好串口我们就可以实验使用串口向上位机发送内容了，即使用板子与PC端串口调试助手或者其他设备进行信息收发。
而进行信息发送一般使用HAL库自带的发送函数HAL_UART_Transmit
另一种方法便是调用C库中的printf打印函数，而该函数是依照fputc实现的，因此需要重写该函数才可以使用printf函数。而scanf函数是依靠fgetc完成的
下面常用函数详细说明这里不做赘述，喜欢自行查阅资料
重写fputc代码
int fputc(int ch,FILE * fp) { HAL_UART_Transmit(&amp;huart1,(uint8_t * )&amp;ch,1,0xffff); return ch; } **重写fgetc实现程序可调用scanf及getchar等函数** int fgetc(FILE *f) { int ch; /* 等待串口输入数据 */ while (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_RXNE) == RESET); HAL_UART_Receive(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xFFFF); return (ch); } 注意：使用时别忘记勾选微库选项，否则printf 不起作用
注意：使用时别忘记勾选微库选项，否则printf 不起作用
注意：使用时别忘记勾选微库选项，否则printf 不起作用
字符串发送函数
void Usart1_String(char *str) { int k=0; do { HAL_UART_Transmit(&amp;huart1,(uint8_t * )(str+k),1,0xffff); k++; } while(*(str+k)!='\0'); return; } 接收中断回显服务函数（板级支持包，放入串口中断服务函数中使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b3cd4b7cc93c845cc7640ac18839e02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ee49c93008a85463b5de2d1be7b727/" rel="bookmark">
			基于微信小程序的投票系统——计算机毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 随着我国经济迅速发展，人们对手机的需求越来越大，各种手机软件也都在被广泛应用，但是对于手机进行数据信息管理，对于手机的各种软件也是备受用户的喜爱，投票系统小程序被用户普遍使用，为方便用户能够可以随时进行投票系统小程序的数据信息管理，特开发了基于投票系统小程序的管理系统。
投票系统小程序的设计主要是对系统所要实现的功能进行详细考虑，确定所要实现的功能后进行界面的设计，在这中间还要考虑如何可以更好的将功能及页面进行很好的结合，方便用户可以很容易明了的找到自己所需要的信息，还有系统平台后期的可操作性，通过对信息内容的详细了解进行技术的开发。
投票系统小程序的开发利用现有的成熟技术参考，以源代码为模板，分析功能调整与投票系统小程序的实际需求相结合，讨论了基于投票系统小程序的使用。
运行环境 开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
投票系统小程序的系统项目的概述设计分析，主要内容有平台的具体分析，进行数据库的是设计，数据采用mysql数据库，并且对于系统的设计采用比较人性化的操作设计，对于系统出现的错误信息可以及时做出处理及反馈。
基于投票系统小程序的设计基于现有的手机上可以运行，可以实现管理端；首页、个人中心、用户管理、作品展示管理 、投票信息管理 、论坛交流、系统管理等功能。方便微信端；首页、作品展示、论坛交流、我的等详细的了解及统计分析。根据系统功能需求建立的模块关系图如下图：
图4-1管理员功能模块图
图4-2用户功能模块图
此系统功能较为全面如下图系统功能结构如图4-6所示。
图4-6系统功能结构图
小程序端 后端管理界面 目 录
摘 要 I
Abstract II
第一章 绪 论 1
1.1选题背景 2
1.2研究现状 3
1.3研究内容 4
第二章 开发工具及关键技术介绍 6
2.1微信开发者工具 7
2.2小程序框架以及目录结构介绍 8
2.3 JAVA技术 8
2.4 Mysql数据库 8
2.5 SSM框架 8
第三章 系统分析 10
3.1需求分析 10
3.2可行性分析 10
3.2.1技术可行性：技术背景 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ee49c93008a85463b5de2d1be7b727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adbe838f5865c15ed05a1dbbae7dfee3/" rel="bookmark">
			Linux高性能服务器编程笔记（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 TCP协议详解 参考引用：
关于三次握手和四次挥手，面试官想听到怎样的回答？ - 车小胖的回答 - 知乎
https://www.zhihu.com/question/271701044/answer/398114686
关于三次握手和四次挥手，面试官想听到怎样的回答？ - 小林coding的回答 - 知乎
https://www.zhihu.com/question/271701044/answer/1279809269
终于到重点中的重点的TCP协议了T_T！
3.1 TCP服务的特点 面向连接、字节流和可靠传输。
对应的UDP的特点是，不面向连接，数据报和不可靠传输。
不面向连接：发送不需要通信双方建立连接。
数据报：数据的发送和接受有边界限制，体现在通信双方需要执行相同次数的读写操作。
不可靠传输：在UDP协议的层次上不具备传输失败后重传的能力，也不拥有接受数据后应答的能力。
3.2 TCP头部结构（整个结构都需要记忆，有被问过） 3.2.1 TCP固定头部结构 16位端口号：进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则选择知名服务端口号。（知名端口号都定义在/etc/services中）
32位序号：A与B进行TCP通信，A发送给B的第一个TCP报文段中，序列值为系统初始化为某个随机值ISN。后续的序号值被设置成ISN加上该报文段所携带数据的第一个字节在整个字节流的偏移，如发送1025-2048字节，那么序列号为ISN+1025。
PS:ISN的作用？
ISN作为发送方的字节数据编号的原点，让对方生成一个合法的接受窗口；
ISN是动态随机的，目的有两个：
增加安全性，为了避免被第三方猜到，从而被第三方伪造的RST报文Reset;使得每个tcp session的字节序列号没有重叠，如果出现**tcp五元组（源IP，源端口，目的IP，目的端口和传输层协议）**冲突这种极少概率情况的发生，也能分清不同session的数据。 32位确认号：用作对另一方发送来的TCP报文段的响应。值为收到的报文段的序号值加一，对于上面的例子，B收到ISN+1025序号的TCP数据包后，应该回复ISN+1025+1的确认号并带上ACK标志的报文段。
6位标志位（每个标志位的作用都需要记忆）：
URG：表示紧急指针是否有效；
ACK：表示确认号是否有效；
PSH：提示接收端应用程序应该立即从TCP接受缓冲区读走数据（若不将数据读走，将一直停留在TCP接受缓冲区）
RST：表示要求对方重新建立连接，携带RST标志的TCP报文段为复位报文段；
SYN：请求建立一个连接，携带SYN标志的TCP报文段为同步报文段；
FIN：表示通知对方本端要关闭拦截了，携带FIN标志的TCP报文段为结束报文段。（书上提到四次挥手中的第一次挥手主动关闭方需要发送一个FIN，但实际上会发送FIN+ACK，因为RFC793规定，除了第一次握手报文SYN除外，其他报文必须将ACK设为1）
16位窗口的大小：TCP流量控制的一个手段，指接受通告窗口。
16位校验和：由发送端填充。校验不仅包括TCP头部，还包括数据部分。也是TCP可靠传输的一个保障（TCP的可靠传输包括接受应答，定时重传，数据校验等等）
3.2.2 TCP头部选项（即头部的最后一个选项字段option） 需要注意的是
kind=3：窗口扩大因子选项，能让TCP模块允许的接受通告窗口远超65535，为了提高TCP通信的吞吐量。
kind=4：选择性确认SACK选项。一般情况，TCP通信时，如果某个报文段丢失，TCP模块会重传最后被确认的TCP报文段后续的所有报文段，一些已经正确传输的报文段也可能被重传。SACK技术使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的报文段。
kind=5：SACK实际工作的选项。因为一个块的信息占用8个字节，所以TCP头部选项中实际最多可以包含4个这样的不连续数据块。（头部选项最长为40字节）
3.3 TCP连接的建立和关闭 3.3.1 三次握手和四次挥手 A向B进行TCP连接（三次握手的过程）：
第一次握手：A发送的TCP报文段包含SYN标志及一个ISN值，因此它是一个同步报文段。
第二次握手：B发送的TCP报文段包含SYN标志，表示同意与A建立连接；同时发送自己的ISN值作为序号，并对第一个同步报文段进行确认，确认号在A的ISN值基础上加一，加上ACK标志表示确认，发送给A。
第三次握手：A对B发送的SYN-ACK报文段进行确认，即在B的ISN值基础上加一，加上ACK标志表示确认，发送给B。
PS：经典问题，为什么要三次握手？
可以转化成为啥不能两次或者四次？
主要原因：TCP两次握手无法阻止历史连接。
如果只有两次握手，被动发起方没有中间状态给主动发起方来阻止历史连接，导致被动发起方可能建立一个历史连接，造成资源浪费。
例子：
我们假设A向B建立TCP连接。两次握手下，B收到SYN报文后，就进入了established状态，意味着可以给A发数据，但A还没进入。假设这次是由于A的历史连接而建立连接，那么B所发送的数据中包含的确认号不正确，因此A将回复RST报文来断开连接。这样B就浪费了一次建立连接和一次发送数据的资源了。
当三次握手的情况下，B如果收到了历史连接，它会根据收到的序列号回复对应的确认号给A，此时仍然处于SYN_RCVD状态。A收到回复后，发现对方的确认号不正确，于是发起了RST报文中止连接。一段时间后，B收到了新的同步报文段，于是回复给A新的确认号，此时A确认无误后就进入established状态，同时给B回复对应的确认报文，最后B也进入了established状态。
当四次握手的情况下，其实就是将B第二次握手的SYN，ACK分开发送，即回复一个确认报文和发送一个同步报文。这个动作可以合并成一个动作，也就是三次握手的情况。
A向B断开连接（四次挥手）
第一次挥手：A向B发送FIN结束报文段。
第二次挥手：B向A发送ACK确认报文段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adbe838f5865c15ed05a1dbbae7dfee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd269aceecfd2a0300526ec2db6d8955/" rel="bookmark">
			Linux高性能服务器编程笔记（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第二章 IP协议详解 2.1 IP服务的特点 无状态：指IP通信双方不同步传输数据的状态信息，所有IP数据包的发送、传输和接受都是相互独立。只要接受端收到完整的IP数据包，就将数据部分上交给上层协议。（重新排序的工作交给上层协议）
无连接：不长久地维持对方的任何信息
不可靠：不能保证数据报能准确地到达接收端
2.2 IPv4头部结构 其中，
16位总长度指整个IP数据包的长度，超过MTU（最大传输单元）的数据包都将被分片传输，所以实际传输的每个数据包都远没有达到最大值。
32位源端IP地址与32位目的端IP地址在传输的过程中一般保持不变，不论经过多少个中转路由器。（因为改变的是在数据链路层包装的MAC地址）
2.4 IP路由 IP模块基本工作流程:
根据IP头部选项来调用数据报转发子模块处理该数据报，（松散源路由选择：经过指定的的所有路由，也就是可以经过更多的路由；严格源路由选择：只能经过指定的路由器）本机的就分派给上层协议不是本机的就先检查是否允许转发，不允许就丢弃；允许就进行转发将等待转发的IP数据包放入IP输出队列 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ad8c549b0f74ea6f5f528cac43f222/" rel="bookmark">
			2021游戏开发的小总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		21年由于疫情的原因，五月份才开始找工作，中间也面试了几家互联网公司(基本都是线上面试)。最后也拿到了几份offer,虽然都不是我自己最满意的offer,但想了想现在最要紧的还是先找到一份工作，然后再慢慢的计划之后，不能一直处于毕业即失业的状态，也不想一直吃家里的老本了。
最后选择了一家游戏公司(具体公司就不说啦)。
六月份踏上了自己工作之旅。初入职场刚开始感觉还是不太适应，自己之前在学校里学的一些知识好像暂时也没有用到太多，基本都是通过公司的两三个月的培训重新学习。从最基本的编程语言开始，然后接触到一些引擎、ui、网络交互、信号相关的基础知识，这些东西都是后面工作日常所需要接触的东西。从一开始的难以下手，到后来的慢慢适应，可能很多人都需要迈过这一步，特别是我这种菜鸟，很多时候下班之后还要在公司继续把自己的进度给赶一赶(好累啊，但我没有资本emo)。
这半年的工作给我带来了很多(发际线堪危)，我感觉很好的一点就是我的生活状态比在学校好太多了，生活上每天正常的作息时间，而不是在学校那种早睡晚睡都没事，有时候熬夜到很晚。现在每天到了点就洗漱睡觉，保证第二天上午有一个比较好的状态。每隔一天下班之后都会去跑四到五公里(出汗的感觉真的很爽)，跑完之后洗个澡整个人状态直接拉满，之前周六没事也会去公司的健身房锻炼半小时，很棒的体验。
工作上感觉这半年来不仅仅是自己编码能力的提升，更重要的是可以遇到很多优秀的同事，他们都是我学习上的榜样，他们让我意识到熟练使用工具的重要性，这样让你在工作的时候可以很好的提升自己的效率，还有就是一些软件快捷键的使用，要提前去熟练，这样你在开发过程中就能更好的将自己的思维放在业务逻辑上面去。
半年说长也不长，说短也不短。2022也要加油啊，回想21年自己好像也没有什么拿得出手的事情，真的很惭愧，所以这正是一个很好的开始，从新开始，也给自己定个小目标吧。
工作上:
争取可以早一点让自己升一级
学习上：
学习自己编程语言的更深层次
将自己在csdn获得的五本书看完(很感谢csdn)
每周至少更新一篇技术博客
每月看完一本经典书籍
生活上：
完成200公里跑步(21年半年完成100公里目标)
学会一些基本的尤克里里弹奏,至少学会5首歌(买了一直没时间学)
争取去旅游一次
学会一项其他技能
这就是小菜鸡的一年~，明年的今天我来看看自己完成了多少！祝大家在新的一年也要快快乐乐的啊，一起加油。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a1271308a36e68957ed750bbb20ed9/" rel="bookmark">
			VS无法安装WIN10SDK问题解决方法（找不到头文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
博主因为之前下过visual stdio，之后改过盘块（删除了D盘），所以再次使用有错误，具体表现是再编写程序时找不到头文件。
解决方法：
修改注册表，具体修改参考博客：
VS2017安装时出现win 10SDK安装不了的问题，错误代码：1327_小豪的八戒的博客-CSDN博客_vs2017无法安装sdk
上面改完了之后如果还不行可以看看这些地方的注册表路径对不对：
\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSBuild
\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\MSBuild
\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Microsoft SDKs
注：博主并没有修改，而是看到有D盘（我删除了D盘所以有D盘就是错的）的就删掉
由于博主看到D盘就删除，或许还有遗漏，大家自行查找
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8e2ddfb7deaef8d0d68084b11cd1b8/" rel="bookmark">
			Python 日期时间格式化输出，带年、月、日、时、分、秒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用time模块，输出格式化日期时间字符串：
import time date_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()) print(date_str) 输出当前时间如下：
2022-01-03 16:32:06
其中可以传入的字符有限，Unicode字符前256个中，只有如下列表中的字符可以传进去作为连接符：
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 166, 170, 173, 178, 179, 185, 186, 208, 221, 222, 226, 240, 253, 254]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a8e2ddfb7deaef8d0d68084b11cd1b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d130be80e21a5ff5ee184ecf4caad1a6/" rel="bookmark">
			docker嵌入式开发(一)简述和目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述和目录 1.简述2.常识3.目录 1.简述 作为一个嵌入式开发工程师，对配置Linux开发环境深恶痛绝，正好公司购置了服务器，所以就准备把编译工作放在服务器上运行。个人也在用二手服务器，不过使用的vmware exsi和谐版，安装了Ubuntu/OpenWRT/TureNas，工作中不太好使用这种昂贵方案，所以就在服务上安装docker，使用容器。博主对此并无深入，只是能简单满足嵌入式开发工作需求。
2.常识 docker是什么？
Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。镜像和容器
镜像可以理解为C++中的类，容器可以理解为C++中的对象，使用镜像可以创建多个容器。 3.目录 docker嵌入式开发(一)简述和目录
docker嵌入式开发(二)ubuntu安装docker
docker嵌入式开发(三)docker安装ubuntu
docker嵌入式开发(四)docker可视化管理
docker嵌入式开发(五)docker导出容器到镜像
docker嵌入式开发(六)docker安装nextcloud云盘
docker嵌入式开发(七)docker安装qt
docker嵌入式开发(八)docker动态修改端口映射
docker嵌入式开发(九)docker安装frp内网穿透
[docker嵌入式开发(十)docker安装gitlab]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f52173461c644c39c152cfd68feb84/" rel="bookmark">
			关于Microsoft Visual Studio 2017 找不到或打不开 Visual Studio Installer 的解决方法， 或不知名原因导致VS installer闪退的一种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Visual Studio 运行 Visual Studio Installer 闪退 网上找了很多文章，本来都要放弃了，后来不死心，发现一篇文章，写了关于软链接问题，忽然想到，当时在安装VS的时候，想搞离线安装，后来，把文件夹删除了，应该是这个问题，找到日志以后，发现果然有这个相关提示，下边是日志里的内容，加粗一行就是问题部分 Error Information
AppInsightsEvent Name = vs/setup/bootstrapper/error
Description = DirectoryNotFoundException
TelemetrySession = ‘53295939-9be5-4f6b-a7eb-b42a3dbf1c8a’ Started = True OptIn=True IsInitialized = False Cloned = False
WatsonEventType = VisualStudioNonFatalErrors2
UTC time = 2022-01-03T03:51:59
Exception:
System.IO.DirectoryNotFoundException
未能找到路径“C:\ProgramData\Microsoft\VisualStudio\Packages_bootstrapper”的一部分。
System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
System.IO.Directory.InternalCreateDirectory(String fullPath, String path, Object dirSecurityObj, Boolean checkHost)
System.IO.Directory.InternalCreateDirectoryHelper(String path, Boolean checkHost)
System.IO.Directory.CreateDirectory(String path)
Microsoft.VisualStudio.Setup.Services.FileSystem.CreateDirectory(String path)
Microsoft.VisualStudio.Setup.Bootstrapper.Utilities.GetBootstrapperPackageCacheDirectory(IServiceProvider services)
Microsoft.VisualStudio.Setup.Bootstrapper.Program.Parse(String[] args, IServiceProvider serviceProvider, IC2RSignatureReaderInterop c2rSignatureReader, String entryAssemblyProcessName, String entryAssemblyProcessFullName)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f52173461c644c39c152cfd68feb84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4d849488dd5bf7565bf10b8e364fd48/" rel="bookmark">
			Vue3中获取鼠标在浏览器x轴和y轴的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发和工作中我们经常遇到需要获取鼠标指向的当前位置，很多人感觉很难并不好理解，但是看文本文我相信你会对这个知识有更深层的认识。 使用onMounted定义document.addEventListener，第一个参数是鼠标指向类型，也可以单击 click、mousedown，第二个参数是事件函数。另外最后一个参数决定该事件的响应顺序； ① 如果为true事件执行顺序为 addEventListener---标签的onclick事件---document.onclick。 ② 如果为false事件的顺序为 标签的onclick事件---document.onclick---addEventListener 一、第一种 此时我们的事件函数里可以在控制台打印出来当前信息。将它赋值给我们定义的变量即可。 二、第二种。使用reactive，方便前期书写和后期维护。 三、第三种。使用封装 ① assets目录下新建js文件，把获取x、y轴封装起来。在使用的页面直接引入即可调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9823361e17c17f2a1ef0a2c76d491156/" rel="bookmark">
			使用autoencoder技术提取特征并降维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考虑到在针对股票市场的预测模型中的变量过多/维数过高问题，我们需要降维。这里我们使用autoencoder技术（AE）
首先本文使用调用tushare库提取股票历史数据。
pip install tushare #获取使用接口 def get_token(): ts.set_token("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx") pro=ts.pro_api() return pro ##获取数据列表 def get_data_list(cursor,sql,conn): cursor.execute(sql) res=cursor.fetchall() conn.commit() ts_codes_list=list(res) ts_codes_list=[",".join(list(x)) for x in ts_codes_list] return ts_codes_list ##获取数据 def get_data(ts_codes_list,pro): daily=pd.DataFrame(columns=["ts_code","trade_date","open","close","high","low","volume"]) ##获取相应的列信息 for i in range(0,len(ts_codes_list),100): j=i+100 if(j&gt;=len(ts_codes_list)): j=len(ts_codes_list) name=",".join(ts_codes_list[i:j]) part= pro.daily(ts_code=name, trade_date=get_date())[["ts_code","trade_date","open","close","high","low","volume"]] daily=pd.concat([daily,part],ignore_index=True) daily["trade_date"]=daily["trade_date"].apply(get_date_format) return daily 使用stockstats库进行对OHCLV的转换。 ```python from stockstats import StockDataFrame as Sdf df = data.copy() df = df.sort_values(by=['tic','date']) stock = Sdf.retype(df.copy()) unique_ticker = stock.tic.unique() for indicator in self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9823361e17c17f2a1ef0a2c76d491156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d927d3f7c798bc02aa36490a16f58b98/" rel="bookmark">
			【Kivy】基于Kivy实现倒计时（心流状态）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		心流状态介绍 Kivy介绍 能够全平台开发App，支持windows，macos，linux，安卓等等
PS：本文的窗口 保持在最前功能，调用了KivyOnTop，只支持Windows，
Kivy安装 参考python编程（Kivy 安装及使用教程）
python -m pip install docutils pygments pypiwin32 kivy.deps.sdl2 kivy.deps.glew python -m pip install kivy.deps.gstreamer python -m pip install kivy """ test.py from kivy.app import App from kivy.uix.button import Button class TestApp(App): def build(self): return Button(text='iPaoMi') TestApp().run() """ python test.py # 可选（窗口保持最前，仅支持windows） pip install pywin32 心流代码效果 在桌面正上方出现一个简单的计时器，点击就会倒计时，再次点击就会重置。
心流代码 # test.py from kivy.app import App from kivy.uix.boxlayout import BoxLayout from kivy.clock import Clock from time import time from kivy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d927d3f7c798bc02aa36490a16f58b98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45382be216635df082c20792bdeff204/" rel="bookmark">
			allegro如何等长走线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开规则管理器
2、找到等长规则设置将需要做等长的网络选中建立一个等长组
3、填写等长组名称
4、设置等长长度
此长度为正负范围的。例如需要1.27mm表示 -1.27mm到1.27mm。
5、打开分析模型。analyze→analysis modes。
6、需要等长走线的等长组需要预留走等长的空间，然后将等长组的参考网络固定，系统默认等长组中最长的网络为参考
7、走等长。使用此功能将不等长的线走至等长误差范围之内。
8、走等长时，，右下角有等长延迟提示将延迟提示控制在绿色就是在误差范围之内 9、如果遇到等长组内有差分信号则需要同时满足差分信号线之间等长和等长组内的额等长两个条件。差分对之间的等长设置如下图，如果差分等长没打开还需要打开
10、如果等长组内的一个网络中有连接多点器件，则可以只选最长的一根进行等长
11、如果设置好等长组之后对等长组进行等长分析，就会显示线长等数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b480df31cde2eaf6b442b3d210d654e6/" rel="bookmark">
			Oracle中SID INSTANCE_NAME Service_Name DB_Name等的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle中SID INSTANCE_NAME Service_Name DB_Name等的介绍 在Oracle数据库中有SID、Service_Name、TNS_Name、DBName等名称，估计很多人也分不清它们之间到底有什么区别，在使用过程中也不清楚到底要使用哪个，结合网上的一些查询，在此做个简单的记录
Oracle_SID &amp; SID &amp; INSTANCE_NAME Oracle中SID的作用类似于一个“开关变量”—引导Oracle在实例启动时如何去默认位置下读取适当的参数文件并加载，以正确启动实例，通过SID来命名后台进程。
操作系统也必须通过SID来和Oracle实例打交道，操作系统并不知道什么INSTANCE_NAME，只知道Oracle_SID，在Oracle内部由Oracle自己根据这个SID去识别不同的实例。所以ORACLE_SID更多的是Oracle和外部操作系统沟通的一个窗口。
OS(Oracle_SID) &lt;--------&gt; ORACLE 数据库 &lt;----- (instance_name(实例名))
上图表示实例名instance_name、Oracle_SID与数据库及操作系统之间的关系
虽然这里两个参数都是数据库实例名，但 instance_name参数是Oracle数据库的参数，此参数可以在参数文件中查询到；而Oracle_SID参数则是操作系统环境变量，与 Oracle_BASE、Oracle_HOME等用法相同，用于和操作系统交互。
也就是说，在操作系统中要想得到实例名，就必须使用 Oracle_SID。且Oracle_SID必须与instance_name的值一致，否则，你将会收到一个错误，在unix平台，是“Oracle not available”,在winnt平台，是“TNS:协议适配器错误”。
简单来说就是： Oracle_SID = SID = INSTANCE_NAME
-- 查询当前数据库实例名 -- 方法一： select instance_name from v$instance; -- 方法二： show parameter instance Service_Name Service_Name是Oracle实例提供的服务名。是从oracle 9i，10g开始引入的参数。用Service_names表示。数据库服务名与全局数据库名相同。它隔离了Oracle实例，客户端仅仅需要知道Service_Name就可以访问实例。而不需要知道实例的SID。更不需要知道DB_NAME等信息。
Service_names为实例定义一个或多个Service_name，这样可以通过多个Service_name将不同的用户连接区分开来。
Service_Name似乎应该分为两种，一种是实例服务名 instance service name，一种是网络服务名 net service name （也叫TNSName），如下tnsnames.ora所示：
net_service_name = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 199.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b480df31cde2eaf6b442b3d210d654e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e9fd180d8b2d2f995b0b2c7865a34b/" rel="bookmark">
			在navicat中创建表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、首先登陆Navicat，然后顺利连接数据库，建立并命名一个数据库，如下图所示。
二、在左侧选项卡点击“表”，然后右键点击选择“创建新表”，之后将弹出下图的新建表界面
三、在“名”这一栏添加字段，之后选择类型和长度，设置小数点和是否允许空值，如下图所示。如果想增加字段，则点击“添加栏位”即可。（注：要初始化一个栏位后才能增加下一个栏位，类型会自动补充）
四、下图中，作为演示。添加了id、name、age、adress四个栏位，并将id设置为主键，id的顺序为自动递增，如下图所示。
五、设置完成之后，按下快捷键Ctrl+s，保存设置的内容，弹出表名菜单，如下图所示。在表名窗口中需要输入表名，在这里将表命名为bobby，之后点击确定即可，然后点击该表格弹出如下：
六、然后在表格中输入内容，增加栏数，按下快捷键Ctrl+s保存，即可完成一张表格（注：一行内容输入完毕才可增加行数） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/befbf07ae171d57ce5762cbe126d4e6e/" rel="bookmark">
			ARMv7和ARMv8的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一些关键的变化:
对工程师来说Armv8-A有什么新东西？ Armv8-A架构引入了许多变化，可以设计出可实现的性能更高的处理器。
因为pc端逐渐对arm架构的偏爱,大的内存和寻址空间就很有必要,原始的32bit只能支持4gb内存
大的物理地址
这使处理器能够访问超过4GB的物理内存。
64位虚拟寻址
这使虚拟内存越过4GB限制的。 这对使用内存映射文件I / O或稀疏寻址的现代桌面和服务器软件很重要。
自动信号事件
这使得高效，高性能的自旋锁成为可能。
更大的寄存器文件
有31个64位通用寄存器，这提高了性能并减少了堆栈的使用。
高效的64位立即生成
文字池的需求较少。
较大的PC相对寻址范围
在共享库和位置无关的可执行程序中的有效的数据寻址范围是+/- 4GB。
额外的16KB和64KB转换粒度
这降低了转换后备缓冲区（TLB）不命中率和页面访问的深度。
新的异常模型
这降低了OS和hypervisor 程序的复杂度
高效的缓存管理
用户空间缓存操作提高了动态代码生成效率。 快速数据缓存clear 操作使用数据缓存清零指令清除。
硬件加速密码技术
提供比软件加密更好的3倍到10倍速度性能。 这对于由于太小而不能有效转载到硬件加速器的细粒度解密和加密很有用，例如https。
加载-获取，存储-释放的指令
专为C ++ 11，C11，Java内存模型而设计。 它们通过消除显式的内存屏障指令来提高线程安全代码的性能。
NEON双精度浮点高级SIMD
这使得SIMD矢量化可以应用于更广泛的算法集合，例如科学计算，高性能计算（HPC）和超级计算机。
工作模式 在不同的处理器模式中,有不同的硬件访问权限 privilege level.
主要有两个 privilege level
a) non-privilege : 其中只有User模式属于non-privilege level，其它均是privilege level。
安全起见，大多数时候，软件都运行在User mode。一旦需要其它操作，则需要切换到相应的privilege模式下。这是最原始、最朴素的 l安全思想，当然，只防君子，不防小人。
b)privilege:除了user模式外,都是特权模式,不同的模式,都有自己的寄存器—&gt;让模式切换中更加高效
armv7之前:参考arm9 armv7之前处理器可以工作在7种工作模式（称作processor mode):
用户模式(Usr)：用于正常执行程序；
快速中断模式(FIQ)：用于高速数据传输；
外部中断模式(IRQ)：用于通常的中断处理；
管理模式(svc)：操作系统使用的保护模式；
数据访问终止模式(abt)：当数据或指令预取终止时进入该模式，可用于虚拟存储以及存储保护；
系统模式(sys)：运行具有特权的操作系统任务；
未定义指令中止模式(und)：当未定义的指令执行时进入该模式，可用于支持硬件；
armv7-a实现 armv7和之前一样,不同的是将privilege level命名了，称作PL0和PL1,后来出现了PL2，用于虚拟化扩展（Virtualization Extension）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/befbf07ae171d57ce5762cbe126d4e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e52df7608473af4c183b2dc4c0f00a35/" rel="bookmark">
			yolov5踩坑记录（1）No module named ‘utils‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pytorch的代码查看本地环境
https://raw.githubusercontent.com/pytorch/pytorch/master/torch/utils/collect_env.py # ModuleNotFoundError: No module named 'utils'
在我运行tutorial.ipython里面的示例时出现的报错，
提示没有找到utils包。然后我看了下目录，这个文件夹是存在的，并且也有一个init.py。但这里的utils也是飘着红线。
在原仓库找到了这个issue：https://github.com/ultralytics/yolov5/issues/1181
维护者说ModuleNotFound是当python找不到一个可引入的包目录时候提出的错误。里面提到可能有这几个原因：
1、有其他的第三方的包叫utils，导致了重复。
解决方法是pip uninstall utils。但我没有叫utils的第三方包。
2、utils的同名文件夹
这个和第一个差不多，但也不是我的问题。
3、直到最下边有一个人提到工程文件的问题。我之前是把yolov5克隆到了我的工程文件夹中，然后通过二级目录打开，于是我在pycharm中以yolov5作为根目录打开后，红线都消失了。于是判断是目录的问题。
在/yolov5里面建了个本子，修改代码为
终于成功。
# 没有总结
有些模糊的感觉知道是什么原因，但已经在这里花太多时间了，就不继续深挖了。可能多花半个小时了解一下背后的原因能让我这半个来小时的debug学习到两倍甚至以上的收获，我也很清楚这点。为什么conda solving environment这么慢的那个答案还在我文件夹里躺着，而我一直没有再打开。和自己和解把，承认自己的懒惰。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e14ea9402e17a4769fbb3d7b89a1f1c/" rel="bookmark">
			STM32之DAC音频输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、DAC简介二、获取正弦信号二、截取音乐中的音频三、总结四、参考 一、DAC简介 此应用演示的目的是为 STM32 微控制器提供一种音频播放器解决方案，用于播放 .WAV 文件。该过程经过优化，需要的外部组件数量最少，最终用户可以灵活选择自己的 .WAV 文件。STM32 中的音频文件通过 MicroSD 存储卡提供。
二、获取正弦信号 文件-&gt;新建-&gt;音频文件
采样率为2000Hz，声道单声道，位深度为16.
点击效果，生成基本音色
设置如下
文件-&gt;导出-&gt;文件，设置格式如下
二、截取音乐中的音频 找一首自己喜欢的音乐，点击截取其中的一段音频，并且右键，点击存储，更改设备如下，确定完成
打开WavToc软件，这是一个将WAV文件转化为C语言的代码文件
可以点击试听，生成代码即可。
会看到有个.H文件生成。
打开原子哥的DAC输出正弦波的程序，程序连接如下：
链接：https://pan.baidu.com/s/1t_didU-KQUDFnTpwVYGk8w
提取码：a330
修改代码如下：
修改好后进行编译，然后就可以烧录到硬件里面听音乐了，但是由于这里资源有限，没有硬件，小编就不过多赘述了。
三、总结 由于没有用示波器观察，具体效果不明显，但是按照原理上来讲这是没有问题的。在前人的基础上，我们把别人的代码进行二次封装改造能实现一定的实验效果。
四、参考 https://blog.csdn.net/qq_45748462/article/details/112392144
https://blog.csdn.net/qq_43279579/article/details/111990896
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6396af0c259492518d3dbd131da82d0a/" rel="bookmark">
			数表排序之红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.基本概念1.1.红黑树的引进1.2.红黑树的规则1.3.红黑树的举例 2.红黑树的性质3.红黑树的操作4.总结 1.基本概念 1.1.红黑树的引进 AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，为了确保AVL树的特性，几乎都需要通过旋转操作保持平衡。在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣。为了解决这个问题，引进的红黑树。
红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL
红黑树插入时的不平衡，不超过两次旋转就可以解决。删除时的不平衡，不超过三次旋转就能解决
红黑树的红黑规则。
1.2.红黑树的规则 节点不是红色就是黑色，根节点是黑色红黑树的叶子节点并非传统的叶子节点，红黑树的叶子节点是null节点（空节点）且为黑色同一路径，不存在连续的红色节点 1.3.红黑树的举例 如下图所示，这就是一颗红黑树。
2.红黑树的性质 节点不是黑色，就是红色（非黑即红）根节点为黑色叶节点为黑色（叶节点是指末梢的空节点 Nil或Null）一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度） 我们需要注意的是，每一次插入操作，都默认待插入的元素节点都是红节点。
3.红黑树的操作 这幅图表示向一颗红黑树插入红节点而导致使得红黑树失衡的失衡时需要进行的转化操作。
这个表格还是非常好理解的！
这个操作过程用文字描述起来异常麻烦，建议看视频。
非常清晰易懂的红黑树视频
事实上，信息论与编码的知识告诉我：一个视频所携带的信息量远远大于一篇博客！！！
Red/Black Tree Visualization
上面这个网页是视频里面提到的，这个大家可以模仿一下视频里面的内容！
4.总结 如果把红黑树中的所有红色节点改为黑色节点，就是一个AVL树
红黑树之所以可以解决AVL树频繁维护BF（平衡因子）所需要大量的资源是因为降低了平衡的要求。AVL树严格确保BF的绝对值为1，而红黑树只需要确保该节点到叶子节点的所有路径中包含黑色节点的个数相同（由于我们解决的是二叉树，所以只需要确保节点的左右子树满足这个特性就可以了）
红黑树的维护操作起始就是在AVL树操作的基础上进行着色，如果AVL树的操作非常熟悉，那么红黑树也就很简单了。
红黑树本质上还是二叉搜索树，只是为了改正AVL树的缺点而提出来的新的数据结构，不要忘记这个性质。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756f6b6dce1e499497b64b544723ffc8/" rel="bookmark">
			Nginix反向代理---https重定向后变http问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginix反向代理---https重定向后变http问题解决 0. 故障现象1. 原因分析2. 配置文件3. 结果 0. 故障现象 继上次的Nginx反向代理端口丢失后又发现了个小问题.
输入url: http:/xxx.xxx.xxx.xxx:777/aaa/ 可以正常访问到登录页面
输入用户名密码后,页面跳转.
跳转后url: http:/xxx.xxx.xxx.xxx/aaa/main.do?method=main 无法正常显示页面
手工将url改为 http:/xxx.xxx.xxx.xxx:777/aaa/main.do?method=main 可以正常访问页面
但此时原先的https变成了http
由于从外网访问,防火墙关闭了80端口.导致400报错
1. 原因分析 后端服务器是http,跳转的proxy_pass 会将url改为http://pana/
如果直接写proxy_pass https://pana/;会因为后端没有https提供服务导致400报错
那么只需要强制再把http 跳转成https即可.修改conf/nginx.conf的以下配置:
proxy_redirect http:// https://; 2. 配置文件 upstream pana { server 192.168.31.70:8088 max_fails=1 fail_timeout=10s; } server { listen 777; server_name pana.cn;	charset utf-8; access_log logs/host.access.log main; location / { proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host:$server_port; proxy_pass http://pana/; proxy_redirect http:// https://; } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756f6b6dce1e499497b64b544723ffc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cbe16c40b9a39835472f9906fb0467a/" rel="bookmark">
			1-5 线性表元素的区间删除 PTA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List Delete (List L,ElementType minD,ElementType maxD) { int i=0,j=0; for(i=0;i&lt;=L-&gt;Last;i++) { if (L-&gt;Data[i]&gt;=maxD||L-&gt;Data[i]&lt;=minD) { L-&gt;Data[j]=L-&gt;Data[i]; j++; } } //这里跟4有点出入，不需要else，不需要浮标长度，因为L-&gt;Last直接就可指向了长度 L-&gt;Last=j-1;//别忘了-1，因j++多加了1 return L; } (53条消息) 1-4 数组元素的区间删除 PTA_nahnah_的博客-CSDN博客
与这个思路相同，都是一个数组来实现，线性表的话与1-4不同的是：不需要浮标长度，因为
L-&gt;Last直接代表了长度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257c12a677811c63594387088f033c90/" rel="bookmark">
			记录一些杂碎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端搜索高亮: 整段多个关键词：
highlight(str) { let keyWord = this.keyWord.split(' ') let newStr = str keyWord.forEach(item =&gt; { const reg = new RegExp(item, 'ig') newStr = newStr.replace( reg, `&lt;span style="color: #0672FF"&gt;${item}&lt;/span&gt;` ) }) return newStr } 看实际情况，关键词多的情况下后端返回高亮片段最好。
剔除富文本标签： function matchReg(str){ let reg=/&lt;\/?.+?\/?&gt;/g; console.log(str.replace(reg,'')); } input只能输入数字/禁止空格： &lt;el-input placeholder="请输入" v-model="str" @keypress="keydown" @paste.capture.prevent="() =&gt; {}" // 阻止粘贴 type="number" &gt;&lt;/el-input&gt; const keydown = (e: { key: string; returnValue: Boolean }) =&gt; { let key = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/257c12a677811c63594387088f033c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1ee2ed084bdab84f4d61d180af005a6/" rel="bookmark">
			代码初学者可以看看这样可不可以快速理解链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果用js来模拟链表操作，我们应该怎样理解？网上大部分就是贴一下概念，一张图，一篇代码，但是对于小白来说还是很抽象。什么指针？什么next？为什么一会儿next=值一会儿next=next?
令很多初学代码的人很困惑，而且JavaScript是弱类型语言，没有“指针”这一概念，导致对很多文章里说的指针不太不理。
链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。
在我们用JavaScript表示指针时，可以把它当做是一个小推车。
“小明有一个小推车（小推车里有小梅）” -&gt;“小梅有一个小推车（小推车里有小虎）”-&gt; “小虎有一个小推车（小推车里有小丽）”
单向 我们假设工厂有个工作流水线，最开始流水线上没有人：
class Liushuixian { constructor(){ this.head = null } } 以“人”为一个节点，一个人带有一些信息 还有一个推车，车里没有东西
class People { constructor(people) { this.people = people this.next = null } } 假如我们招来第一个人：
class Liushuixian { constructor(){ this.head = null } // 添加人 appendRen(people) { // 入职 let newPeople = new People(people) this.head = newPeople } // 打印结果 print() { let str = '' let current = this.head while(current) { str += current.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1ee2ed084bdab84f4d61d180af005a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345add1937f3333ab7cb852698f7a2b9/" rel="bookmark">
			ELK——一套实用、易用的监控架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
ELK是什么
ELK的主要优点
为什么要使用elk
ELK 的好处：
elk组件的作用
elasticsearch核心概念（属于elk的老大）
分片的两个最主要原因:
logstash的基本概念
Kibana 主要功能
ELK工作原理
使用场景
搭建elk
​ 使用插件管理 登录 Apache主机 做对接配置
安装kibana
对接Apache主机的Apache 日志文件（访问的、错误的）
启动日志
总结
本次所用到的软件包
ELK是什么 通俗来讲，ELK是由Elasticsearch（日志存储和搜索）、Logstash（日志收集）、Kibana（查看日志）三个开源软件的组成的一个组合体，ELK是elastic公司研发的一套完整的日志收集、分析和展示的企业级解决方案，在这三个软件当中，每个软件用于完成不同的功能，ELK又称为ELKstack。 官方域名为elastic.co。
ELK的主要优点 处理方式灵活：elasticsearch是实时全文索引，具有强大的搜索功能 （支持任意key全文搜索）
配置相对简单：elasticsearch的API全部使用JSON接口，logstash使用模块配置，kibana的配置文件部分更简单。
检索性能高效：基于优秀的设计，虽然每次查询都是实时，但是也可以达到百亿级数据的查询秒级响应。
集群线性扩展：elasticsearch和logstash都可以灵活线性扩展，节点读写出现瓶颈可以扩容（3 5 7 11个服务器）
前端操作绚丽：kibana的前端设计比较绚丽，而且操作简单（早期比较简单）
为什么要使用elk ELK 组件在海量日志系统的运维中，可用于解决以下主要问题：- 分布式日志数据统一收集，实现集中式查询和管理
故障排查
安全信息和事件管理
报表功能
ELK 的好处： ELK 组件在大数据运维系统中，主要可解决的问题如下：
日志查询，问题排查，故障恢复，故障自愈
应用日志分析，错误报警
性能分析，用户行为分析
elk组件的作用 elasticsearch核心概念（属于elk的老大） 1、接近实时(NRT)
elasticsearch是一个接近实时的搜索平台，这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒)
2、集群(cluster)
一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。其中一个节点为主节点，这个主节点是可以通过选举产生的，并提供跨节点的联合索引和搜索的功能。集群有一个唯一性标示的名字，默认是elasticsearch,集群名字很重要，每个节点是基于集群名字加入到其集群中的。因此，确保在不同环境中使用不同的集群名字。 一个集群可以只有一个节点。强烈建议在配置elasticsearch时，配置成集群模式。
3、节点（node)
节点就是一台单一的服务器，是集群的一部分，存储数据并参与集群的索引和搜索功能。像集群一样，节点也是通过名字来标识默认是在节点启动时随机分配的字符名。当然，你可以自己定义。该名字也很重要，在集群中用于识别服务器对应的节点。
节点可以通过指定集群名字来加入到集群中。默认情况，每个节点被设置成加入到elasticsearch集群。如果启动了多个节点，假设能自动发现对方，他们将会自动组建一个名为elasticsearch的集群。
4、索引(index)
一个索引就是一个拥有几分相似特征的文档的集合。
比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，如果你想，可以定义任意多的索引。
●索引相对于关系型数据库的库。
5、类型（type）
在一个索引中，你可以定义一种或多种类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/345add1937f3333ab7cb852698f7a2b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b65f5bf0e995d31522be062cb6e1a5/" rel="bookmark">
			vivado编译出错 [Synth 8-729] [Synth 8-787]解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vivado编译出错 [Synth 8-729] [Synth 8-787]解决方法 问题：在VIVADO中通过对已有功能的裁剪，生成需要的IP核，并在另一个工程中调用，进一步封装，但出现编译错误，提示缺少IP实例化后的DCP文件。 问题：在VIVADO中通过对已有功能的裁剪，生成需要的IP核，并在另一个工程中调用，进一步封装，但出现编译错误，提示缺少IP实例化后的DCP文件。 在这篇中看到了解决的思路
但按照其中的方法我仍然没有解决，但是在这个我这个信息栏Design Runs提示我有错误，然后按照1，2的步骤做了一下，但其中不要选择Out of context per IP,而是选择Global就可以解决问题了。
现在我的信息栏还是有错误，但是不再是error 729和787，而是我自己的其他问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861a62d54d1bd862875a6808026b03ee/" rel="bookmark">
			复数知识结合Numpy实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境：
numpy 复数（complex number ）
表达式模幅角a+bir= |z|= a 2 + b 2 \sqrt{a^{2}+b^{2}} a2+b2 ​ θ \theta θ=Arg(z)
∈ [ − π , π ] \in[-\pi,\pi] ∈[−π,π]内的称为幅角主值numpy：np.abs(a+bi)np.angle(a+bi,deg=True)
deg:False(默认)返回弧度；True返回角度 例子： import numpy as np z=3+4j print(np.abs(z))#模 print(np.angle(z))#弧度 print(np.angle(z)*180/np.pi)#弧度转换角度 print(np.angle(z,deg=True))#法2：直接调用函数求角度 结果：
5.0 0.9272952180016122 53.13010235415598 53.13010235415598 附：
注：图片来源，百度百科https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365?fr=aladdin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7469b6afca57bc71feac6231ab2ca8a/" rel="bookmark">
			2021年氧化工艺新版试题及氧化工艺模拟试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
安全生产模拟考试一点通：2021年氧化工艺新版试题为正在备考氧化工艺操作证的学员准备的理论考试专题，每个月更新的氧化工艺模拟试题祝您顺利通过氧化工艺考试。
1、【单选题】 浆料泵停车时,首先要()。（ A ）
A、将泵入口浆料切换成冲洗液
B、关闭机械密封冲洗液阀门
C、停止泵运转
2、【单选题】酒精与水的混合溶液中,有酒精15kg,水25kg,则酒精的质量分率为()。（ C ）
A、0.625
B、0.357
C、0.375
3、【单选题】 废水中来源于有机物中的氨基,胺基,脲基,尿酸,含氮化合物等的硝化反应形成水中的是()。（ C ）
A、COD
B、氮氧化物
C、氨氮
4、【单选题】 劳动防护用品必须具有“三证”,不属于“三证”的是()。（ B ）
A、安全鉴定证
B、检验合格证
C、生产许可证
5、【单选题】 压力离心机分离的好坏可以通过()来观察。（ C ）
A、滤饼含杂质量
B、母液含PT酸量
C、滤饼含湿量
6、【单选题】 煤油裂解制乙烯和丙烯。煤油加料量为12t/h,得2700kg/h乙烯和1500kg/h丙烯,乙烯的收率为()%。（ C ）
A、12.5
B、77.5
C、22.5
7、【单选题】 两相触电比单相触电()。（ A ）
A、更危险
B、更安全
C、一样
8、【单选题】 职业病目录中,职业中毒有()种。（ B ）
A、54
B、56
C、65
9、【单选题】 降低生产过程新鲜水的消耗,装置冷却水应使用()水。（ C ）
A、江河
B、工业
C、循环
10、【单选题】 疑似职业病病人在诊断、医学观察期间的费用,由()承担。（ B ）
A、当地政府
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7469b6afca57bc71feac6231ab2ca8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0c590753cbfb02604fd2300386f892/" rel="bookmark">
			Mybatis入门程序-根据id查询数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVAEE实践系列 1. Spring入门程序 2. 依赖注入实现方法 3. Bean基于注解方式的装配 4. AspectJ开发及其两种实现方法 5. Mybatis入门程序-根据id查询数据 Mybatis入门程序 JAVAEE实践系列概括一、步骤截图1. 在mysql数据库中创建mybatis06的数据库，创建t_costomer表，插入三条数据安装mysql数据库[安装MySQL可视化工具之Navicat for MySQL](https://blog.csdn.net/pc915968220/article/details/100763987?utm_source=app&amp;app_version=4.21.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen) 2.创建web项目，导入jar包。将mybatis的核心jar包，lib目录下的依赖包，以及mysql数据库的驱动jar包添加到web项目的lib目录下，并发布到类路径中。mysql驱动jar包的下载 3.在src目录下创建log4j.properties。mybatis默认使用log4j输出日志信息，所以配置日志文件，用于查看控制台输出的sql语句关于如何创建log4j.properties文件 4. src目录下创建po包，创建pojo类Customer，声明属性以及getter，setter方法。5. src目录下创建mapper包，创建映射文件CustomerMapper.xml6. src目录下创建MyBatis的核心配置文件mybatis-config.xml7. src目录下创建test包，创建创建测试类MybatisTest，在类中编写测试方法findCustomerByIdTest().Juint测试的使用 二、输出结果三、整体代码目录结构1. log4j.properties2. POJO类：po包下Customer.java3. 映射文件：Mapper包下CustomerMapper.xml4. 核心配置文件：mybatis-config.xml5. 测试类：Test包下MyBatisTest.java 今日感受 概括 本文包括以下内容：
Mybatis入门程序：创建mysql数据库，导入需要的jar包，编写映射文件以及核心配置文件等扩展内容包括安装mysql数据库，安装MySQL可视化工具之Navicatfor MySQL，mysql驱动jar包的下载，关于如何创建log4j.properties文件，Juint测试的使用 一、步骤截图 1. 在mysql数据库中创建mybatis06的数据库，创建t_costomer表，插入三条数据 安装mysql数据库 安装MySQL可视化工具之Navicat for MySQL 2.创建web项目，导入jar包。将mybatis的核心jar包，lib目录下的依赖包，以及mysql数据库的驱动jar包添加到web项目的lib目录下，并发布到类路径中。 mysql驱动jar包的下载 3.在src目录下创建log4j.properties。mybatis默认使用log4j输出日志信息，所以配置日志文件，用于查看控制台输出的sql语句 不要求掌握直接复制即可
关于如何创建log4j.properties文件 new–&gt;others–&gt;输入file并选择–&gt;输入文件名时加上你想要的后缀即可
4. src目录下创建po包，创建pojo类Customer，声明属性以及getter，setter方法。 客户持久化类POJO类，声明属性，及其对应的getter和setter方法
5. src目录下创建mapper包，创建映射文件CustomerMapper.xml 映射文件，里面有sql语句
select是执行查询操作的配置 ，参数如下：
id指定了其唯一标识符parameterType指定了传入参数的类型，这里表示传递给执行sql的是一个integer类型的参数resultType指定了返回结果的类型，这里表示返回的数据是Customer类型（包+Customer类名） sql语句中：
定义查询的sql语句，#{}用于表示一个占位符，相当于"?"而’#{id}表示该占位符等待接收参数的名称是id’ 6. src目录下创建MyBatis的核心配置文件mybatis-config.xml 配置了mybatis的运行环境等信息，其主要内容是获取数据库连接
7. src目录下创建test包，创建创建测试类MybatisTest，在类中编写测试方法findCustomerByIdTest(). Juint测试的使用 二、输出结果 三、整体代码 目录结构 1. log4j.properties #Global logging configuration log4j.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0c590753cbfb02604fd2300386f892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/406a996b4499f05d3c83206e806e4529/" rel="bookmark">
			给定一个带头节点的单链表，所有数据值无序，删除介于min和max的所有值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;math.h&gt; typedef struct LNode{ int data; struct LNode *next; }LNode,*LinkList; void RangeDelete(LinkList &amp;L,int min,int max){ LNode *p=L-&gt;next; LNode *pre=L; while(p!=NULL){ if(p-&gt;data&gt;=min&amp;&amp;p-&gt;data&lt;=max){ pre=p-&gt;next; printf("%d",p-&gt;data); free(p); p=pre; } else{ pre=p; p=p-&gt;next; } } } void input(LNode *head) { printf("\nINPUT\n"); LNode *p; p=head;/*指向表头*/ int a; for(int i=0;i&lt;=5;i++) { scanf("%d",&amp;a); if(a==-1) return ; LNode *q=new LNode ; q-&gt;data=a; q-&gt;next=NULL; p-&gt;next=q; p=q; } } int main() { LNode *L=new LNode; L-&gt;next=NULL; input(L); int min1,max1; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/406a996b4499f05d3c83206e806e4529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e600a60a6ffc93db5e0694fc0abb9a8b/" rel="bookmark">
			Java Date类的使用（日期处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中获取当前时间，可以使用 java.util.Date 类和 java.util.Calendar 类完成。其中，Date 类主要封装了系统的日期和时间的信息，Calendar 类则会根据系统的日历来解释 Date 对象。下面详细介绍Date类的具体使用。
Date 类 Date 类表示系统特定的时间戳，可以精确到毫秒。Date 对象表示时间的默认顺序是星期、月、日、小时、分、秒、年。
1. 构造方法 Date 类有如下两个构造方法。
Date()：此种形式表示分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒），使用该构造方法创建的对象可以获取本地的当前时间。
Date(long date)：此种形式表示从 GMT 时间（格林尼治时间）1970 年 1 月 1 日 0 时 0 分 0 秒开始经过参数 date 指定的毫秒数。
这两个构造方法的使用示例如下：
Date date1 = new Date(); // 调用无参数构造函数 System.out.println(date1.toString()); // 输出：Wed May 18 21:24:40 CST 2016 Date date2 = new Date(60000); // 调用含有一个long类型参数的构造函数 System.out.println(date2); // 输出：Thu Jan 0108:01:00 CST 1970 Date 类的无参数构造方法获取的是系统当前的时间，显示的顺序为星期、月、日、小时、分、秒、年。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e600a60a6ffc93db5e0694fc0abb9a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d527178891b59aed7c449516b7086b/" rel="bookmark">
			pta期末答案（编程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-1 数组重排
import java.util.Scanner;
public class Main {
public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int a=in.nextInt();
int [] b=new int [a];
for(int i=0;i&lt;b.length;i++){
b[i]=in.nextInt();
}
if (b == null || b.length &lt; 2) {
for(int i=0;i&lt;b.length;i++){
System.out.print(b[i]+" ");
}
}
int start = 0;
int end = b.length - 1;
while (start &lt; end) {
while (start &lt; end &amp;&amp; b[start] % 2 != 0) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34d527178891b59aed7c449516b7086b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90974df1976d76aa628c9717d4f4ddb3/" rel="bookmark">
			axios请求SpringBoot数据接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios访问SpringBoot的接口需要跨域，故需要在SpringBoot添加CORS配置。
package com.example.util; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; /**配置全局跨域 * @author SMILE */ @Configuration public class CorsConfig { private CorsConfiguration buildConfig() { System.out.println("跨域配置。。。"); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); // 1允许任何域名使用 corsConfiguration.addAllowedHeader("*"); // 2允许任何头 corsConfiguration.addAllowedMethod("*"); // 3允许任何方法（post、get等） return corsConfiguration; } @Bean public CorsFilter corsFilter() { System.out.println("启动跨域方法。。。。。"); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", buildConfig()); // 4 return new CorsFilter(source); } } 请求接口
@RestController public class AxiosController { // @ResponseBody用在方法上 // 方法的返回值不再表示view视图页面，而是把返回值直接作为响应结果显示在浏览器上 // @RequestBody用在方法参数上 // 把请求参数编码方式为application/json的对象，转换成一个bean对象 @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90974df1976d76aa628c9717d4f4ddb3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/173/">«</a>
	<span class="pagination__item pagination__item--current">174/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/175/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>