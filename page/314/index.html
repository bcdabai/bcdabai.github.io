<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b793d54b320fab61f1a9e5fd92442390/" rel="bookmark">
			Modbus TCP和Modbus Rtu协议的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Modbus rtu和 Modbus tcp两个协议的本质都是 MODBUS协议，都是靠MODBUS寄存器地址来交换数据；但所用的硬件接口不一样，Modbus RTU一般采用串口RS232C或RS485/422，而Modbus TCP一般采用以太网口。现在市场上有很多协议转换器，可以轻松的将这些不同的协议相互转换 如：Intesisbox可以把 modbus rtu转换成 Modbus tcp 实际上Modbus协议包括ASCII、RTU、TCP。 标准的Modicon控制器使用RS232C实现串行的Modbus。Modbus的ASCII、RTU协议规定了消息、数据的结构、命令和就答的方式，数据通讯采用Maser/Slave方式。 Modbus协议需要对数据进行校验，串行协议中除有奇偶校验外，ASCII模式采用LRC校验，RTU模式采用16位CRC校验. ModbusTCP模式没有额外规定校验，因为TCP协议是一个面向连接的可靠协议。
TCP和RTU协议非常类似，只要把RTU协议的两个字节的校验码去掉，然后在RTU协议的开始加上5个0和一个6并通过TCP/IP网络协议发送出去即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f970a40d5f6d6b9d8821ed958ce73a43/" rel="bookmark">
			MODBUS TCP和MODBUS RTU的差别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP和RTU协议非常类似，只要把RTU协议的两个字节的校验码去掉，然后在RTU协议的开始加上5个0和一个6并通过TCP/IP网络协议发送出去即可 MBAP Header长度共7个字节，分别为Transaction identifier(事务标识符),Protocol identifier(协议标识符),Length(长度), Unitidentifier(单元标识符)组成，具体如下表所示： +------------+---------+-----------------------------+----------------------+----------------------------+ | 字 段 | 长 度 | 描 述 | 客 户 端 | 服 务 端 | +------------+---------+-----------------------------+----------------------+----------------------------+ | 事务标识符 | 2 Bytes | 标示一个MODBUS请求/响应事务 | 由客户端初始化 | 从接收到的请求数据帧中复制 | +------------+---------+-----------------------------+----------------------+----------------------------+ | 协议标识符 | 2 Bytes | 0 = MDOBUS协议 | 由客户端初始化 | 从接收到的请求数据帧中复制 | +-------------+--------+-----------------------------+----------------------+----------------------------+ | 长 度 | 2 Bytes | 下列各项的字节数 | 由客户端初始化(请求) | 由服务端初始化(响应) | +-------------+--------+-----------------------------+----------------------+----------------------------+ | 单元标识符 | 1 Bytes | 标示一个已连接在串行线或 | 由客户端初始化 | 从接收到的请求数据帧中复制 | | | | 其他总线的远程从站连接 | | | +------------+---------+-----------------------------+----------------------+----------------------------+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f970a40d5f6d6b9d8821ed958ce73a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732a635897023bed6b2e42ea63e8112e/" rel="bookmark">
			怎样选择VoIP系统中的语音压缩编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VoIP系统中，语音编码是用于把话音转换成数据方式来传输，传输协议中包括了 RTP，UDP，与IP 一起成为一个完整的语音协议。我们不难想象，传输中包头也占传输的一个重要部分，在20ms 的语音封包长度，包头可以占40字节，实际语音只有20字节，这文章主要是讨论语音压缩编码对VoIP话音与传输的各种影响。至于包头的压缩，则不在这讨论范围。 在IPV4里，IP包占20字节，UDP包占8字节，RTP包头占12字节，共占40字节，此外，以太网占14字节，在每秒20msec 的负荷和以G.729编码为例，实际要传输的字节数为20＋12＋8＋20＋14＝74；传输速度应为：74字节/20msec=29.6K; 在相对的环境下，G.711编码却需要85.6K/sec的带宽。 带宽与编码 在实际的应用过程中，用户真正的关心并不是算法的原理以及采用的压缩技术，而是每种算法的使用特点，下面列出4种VoIP系统最常用的算法来进行比较。 表一 编码算法与性能比较 编码类型 G.711 G.723.1 G.729A GSM iLBC 语音编码速率(kbps) 64 5.3 8 13 13.3 RTP封包长度(ms) 20 30 20 20 30 净语音数据(bytes) 160 20 20 33 50 分组包总长度(bytes) 54+160 54+20 54+20 54+33 54+50 实际总速率(kbps) 85.6 19.7 29.6 34.8 27.7 CPU需求 （MIPS） － 16 18 ~10 19 语音质量(PESQ MOS) 4.5 3.7 3.9 3.4 4.0 iLBC － 一种新的编码协议 语音质量一直是VoIP应用的主要难点，如何保证和提高IP网络传输语音的通话效果，是VoIP应用迫切需要解决的问题。"iLBC"编解码的出现，解决了在包交换的IP网络中，传输语音所遇到的网络丢包严重影响通话质量等实际问题，实现了"语音质量的飞跃"。 下图为在不同的网络丢包环境下，使用iLBC与G.729A、G.723.1编解码的语音质量比较。 无论在高丢包率条件下还是在没有丢包的条件下，iLBC的语音质量都优于目前流行的G.723.1, G.729A等标准编解码；而且丢包率越大，使用iLBC的语音质量优势越明显。通常情况下，为了衡量IP网络语音质量，将≥5％丢包率的网络情况定义为VoIP的极限网络条件。经过语音质量测试，即使在5％丢包率的情况下，iLBC仍然能够提供相当于GSM手机的语音质量。 对IP-PBX的编码要求 由表一可以看到，不同的语音编码协议有各种不同的带宽、话音质量、CPU处理要求，因此上述几种编码协议也没有一种是绝对可以取代其他的能力。G.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/732a635897023bed6b2e42ea63e8112e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516a71ccf4c295c136e1a84780de2aa7/" rel="bookmark">
			细菌英难2.0上线，指尖上进化！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我觉得《降魔篇》里空虚公子控制剑的方式很酷，既然大家都说按钮操作糟透了，我干脆模仿一下那个极品吧。
细菌英雄 (Super Germ) 2.0版主要改进： 1，删除按钮，改用全手势操作。 2，缩小游戏体积，由240MB，减小到65MB。 3，降低关卡难度，很多关卡都重做或修改了参数，使过关更容易。 4，每关增加了带图示的提示牌。 5，重写了游戏说明(Help)，更切中重点。
肯定还有不完善的地方，但是我有杀手锏：改进。大家一定要多提意见啊！(提出来我才好改进 ) 应用地址：https://itunes.apple.com/us/app/super-germ/id655390338?ls=1&amp;mt=8
操作方法：
基本操作见下图。另外补充两个tip：
1，如何跳远？-- 跳起后可继续按住屏幕在空中前进 2，可以在空中转弯吗？--可以，跳起后在空中可以做前进、后退、左转、右转等任意动作。 演示视频： 视频一：（前三关） http://v.youku.com/v_show/id_XNTcxOTc0NTM2.html 视频二：（中间两关） http://v.youku.com/v_show/id_XNTczNTgxMDUy.html 截图： 了解更多：http://user.qzone.qq.com/350479720/blog/1372071057
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c6f7782942b829804d04780acadce0/" rel="bookmark">
			Windows线程同步之互锁函数（Interlocked）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下进程内部的各个线程之间的同步不需要借助内核对象，Windows提供的默认在用户模式下的线程同步工具。
互锁函数为多线程同步访问共享变量提供了一个简单的机制。如果变量在共享内存，不同进程的线程也可以使用此机制。
互锁函数对共享变量的操作是原子的，这个原子性体现在保证多线程在同一个时刻只能有一个线程获得对该同步变量的操作权限。
（1）InterlockedExchangeAdd() LONG __cdecl InterlockedExchangeAdd( _Inout_ LONG volatile *Addend, _In_ LONG Value ); LONGLONG __cdecl InterlockedExchangeAdd64( _Inout_ LONGLONG volatile *Addend, _In_ LONGLONG Value ); //Addend：指向一个32位变量的指针； //Value：共享变量上要加的值； //Return value：返回修改前变量的值； InterlockedExchangeAdd互锁函数提供了对变量进行加法操作，保证了同一时刻只有一个线程对这个变量进行加法操作。Value是正数的时候进行加法操作，是负数的时候进行减法操作。
（2）InterlockedIncrement()&amp;InterlockedDecrement() LONG __cdecl InterlockedIncrement( _Inout_ LONG volatile *Addend ); LONG __cdecl InterlockedDecrement( _Inout_ LONG volatile *Addend ); //Addend：指向一个32位变量的指针； //Return value：修改前变量的值； InterlockedIncrement互锁函数对一个32变量进行增1操作，InterlockedDecrement则进行减1操作。保证线程之间的互斥的进行访问。这两个函数都是16位和64位版本。
（3）InterlockedExchange() LONG __cdecl InterlockedExchange( _Inout_ LONG volatile *Target, _In_ LONG Value ); //Target：指向一个32位变量的指针； //Value：要替换的值； //Return Value：修改之前的值； PVOID __cdecl InterlockedExchangePointer( _Inout_ PVOID volatile *Target, _In_ PVOID Value ); //Target：指向一个32位变量的指针的指针； //Value：要替换的指针的值； //ReturnValue：修改之前的值； InterlockedExchange函数把第一个参数指向的内存地址的值，以原子的方式替换为第二个参数的值。并返回原来的值。InterlockedExchangePointer替换的是指针而已。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2c6f7782942b829804d04780acadce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81843ee4c119c97cbcf4b6d1a3c13cd9/" rel="bookmark">
			ifconfig没有eth0解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、如果输入ifconfig,没有eth0:,那你需要安装网卡驱动，如下：
ubuntu中查看网卡类型及是否安装网卡驱动程序 1输入： lspci 或者 lspci –v 或lspci–vv
会显示所有的硬件信息和版本，然后在网上搜索linux下的驱动程序
03:00.0 Ethernet controller: Broadcom Corporation BCM4401-B0 100Base-TX (rev 02) 03:01.0 FireWire (IEEE 1394): Ricoh Co Ltd R5C832 IEEE 1394 Controller (rev 05) 03:01.1 SD Host controller: Ricoh Co Ltd R5C822 SD/SDIO/MMC/MS/MSPro Host Adapter (rev 22) 03:01.2 System peripheral: Ricoh Co Ltd R5C592 Memory Stick Bus Host Adapter (rev 12) 03:01.3 System peripheral: Ricoh Co Ltd xD-Picture Card Controller (rev 12) 0c:00.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81843ee4c119c97cbcf4b6d1a3c13cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f70534bfede25d87d14129b674d85e/" rel="bookmark">
			gdb(四)查看运行时数据和更改调试程序的执行路线和变量值等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 查看运行时数据：
(一)print命令(p)：查看当前程序的运行数据。(inspect类似)
*格式：print &lt;expr&gt;或print /&lt;f&gt; &lt;expr&gt;.
*expr是表达式；&lt;f&gt;是输出格式。
(二)程序变量：
(1)在gdb中可以查看三种变量的值：全局变量(所有文件可见)、局部变量(当前scope可见)和静态全局变量(当前文件可见)。
(2)局部变量会隐藏全局变量，如果需要查看全局变量的值需使用"::"。
*file::variable：哪个文件中的变量。
*function::variable：哪个函数中的变量。
*::variable：全局变量。
(3)注意：如果程序编译启动了优化选项，那么gdb调试被优化的程序时，可能发生某些变量不能访问或取得错误码，因为优化程序会删改你的程序，整理你程序的语句顺序，删除一些无意义的变量等。
(三) 数组：
(1)有时需查看一段连续的内存空间的值。比如：数组或是动态分配的数据的大小。
(2)方法：@左边是第一个内存的地址的值；@右边是你想查看内存的长度。
*查看数组元素：print *array@len
(四)输出格式：
(1)一般，GDB会根据变量类型输出变量的值，但你也可自定义GDB的输出格式。如：输出十进制数的十六进制格式。
(2)格式：print /&lt;f&gt; &lt;expr&gt;。
(3)f是输出格式:
*x：十六进制格式显示变量。
*d：十进制格式显示变量。
*u：十六进制格式显示无符号整型。
*o：八进制显示变量。
*t：二进制格式显示。
*a：十六进制格式显示变量。
*c：字符格式显示变量。
*f：浮点数格式显示变量。
(五)查看内存的值(x)：
(1)使用x命令来查看内存地址中的值。
(2)格式：x/&lt;n/f/u&gt; &lt;addr&gt;。n,f,u是可选的参数。
*n：是一个正整数，表示显示内存的长度。
*f：表示显示格式。
*u：表示当前地址往后请求的字节数。
*addr：表示一个内存地址。
(3)help x：
(六)自动显示：
(1)可以设置一些自动显示的变量，当程序停住时，或是你在单步追踪时，这些变量会自动显示。
(2)display命令格式：
*display &lt;expr&gt;
*display /&lt;fmt&gt; &lt;expr&gt;
*display /&lt;fmt&gt; &lt;addr&gt;
*expr表示表达式；fmt表示显示格式；addr表示内存地址。
(3)help display：
(七)设置显示选项：
(1)help set print如下图：
(八)历史记录：
(1)当使用print查看程序运行时的数据时，你的每一个输出都会被GDB记录下来。GDB会以$1、$2、$3...这样的方式为你每一个print命令编上号。
(九)GDB环境变量(set)：
(1)可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。
(2)格式：set $var=var1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f70534bfede25d87d14129b674d85e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac3cc950f5912fbc2c6ceb95dbf5a59/" rel="bookmark">
			数码管SR420561K SR410561K的引脚图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先数码管有共阴极和共阳极之分，区别他们的方法是若公共端接地，其他端接电源，若各段测试能亮，说明是共阴的，反之共阳的；若公共端接电源，其他端分别接的，测得各端亮，则说明是共 阳的，反之为共阴的。 世面上的四位一体的数码管一般都没有datasheet，所以掌握他们管脚的分布是很重要的一个环节。下面是一张四位一体数码管引脚分布图
4位一体数码管，其内部段已连接好，引脚如图所示（正面朝自己，小数点在下方）。a、b、c、d、e、f、g、dP为段引脚，1、2、3、4分别表示四个数码管的位。 1 a f 2 3 b 。 。 。 。 。 。 。 。 。 。 。 。 e d dp c g 4 即：12-9-8-6为依次为从左至右数码管的公共端 A-11 B-7 C-4 D-2 E-1 F-10 G-5 DP-3 ark sr420561k 共阴极 ark sr410561k 共阳极 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d887054312d41dc3121bd5807e729a86/" rel="bookmark">
			suse时区配置，GMT加减号的意思与Windows中含义相反
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SuSE中时区表示方式与Windows不同， 加减号表示相反的意思。 其 /etc/sysconfig/clock中配置如果写GMT+8则表示为西8区的时间，若配置北京时间须写成GMT-8. 如图示TIMEZONE=“Etc/GMT+5”表示西五区时间，即哥伦比亚波哥大时间，如须配置东五区（伊斯兰堡/卡拉奇，Islamabad/Karachi）须写成GMT-5，或使用地区国家的格式，如：Asia/Tashkent。
使用Yast的系统管理修改系统时间和时区也可以。 修改后须重启Oracle实例和监听，否则会造成时间不准确。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00196b58a348b0be58a53c4e92aa1b5/" rel="bookmark">
			java.lang.NoSuchMethodError: javax.servlet.ServletContext.getContextPath()Ljava/lang/String;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在eclipse中启动tomcat6.0，总是报错：java.lang.NoSuchMethodError: javax.servlet.ServletContext.getContextPath()Ljava/lang/String；
解决方法：检查jre，发现在jre\lib\ext路径下缺少servlet-api.jar，拷过去之后重启正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc9ee28b7e105ad39fae3899fbfb837/" rel="bookmark">
			UIView设置圆角、边框和阴影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们经常需要对view进行圆角设置，有些view是通过设置属性来设置圆角，一般需要用修改view的layer属性。
1、直接通过已有属性设置圆角
对于UIButton、UITextField等，可以通过对已有属性的设置来显示圆角。
UIButton * button = [UIButton buttonWithType:UIButtonTypeRoundedRect];
UITextField * textField = [UITextField allo]initWithFrame:rect];
textField.borderStyle = UITextFieldBorderStyleRoundedRect;
2、修改layer来设置圆角
要导入&lt;QuartzCore/QuartzCore.h&gt;
#import &lt;QuartzCore/QuartzCore.h&gt;
代码如下：
view.layer.masksToBounds = YES;
view.layer.cornerRadius = 5.0;
修改layer除了可以设置圆角之外，还可以给view添加边框和阴影
3、添加border
代码如下：
view.layer.borderColor = [UIColor colorWithRed:value green:value blue:value alpha:1].CGColor;
view.layer.borderWidth = 1.0;
4、添加阴影
代码如下：
view.layer.shadowOffset = CGSizeMake(1, 1);
view.layer.shadowRadius = 5.0;
view.layer.shadowColor = [UIColor blackColor].CGColor;
view.layer.shadowOpacity = 0.8;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a0c360905dd6fc1a8bd90cfdb0881e/" rel="bookmark">
			iOS独立游戏Super Germ（细菌英雄）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		----更新：
细菌英雄2.0已上线，看此帖：http://blog.csdn.net/iwantnon/article/details/9167207
----更新：
细菌英雄(Super Germ)2.0前三关视频：http://v.youku.com/v_show/id_XNTcxOTc0NTM2.html
----更新：
细菌英雄(Super Germ)1.0由于过多地使用了按钮，被网友批评，于是本人卧薪尝胆两天，实现出一种全手势操作方法，将在未来的2.0版中跟大家见面。先看一下视频吧：
细菌英雄(Super Germ) 2.0全手势操作预览：http://v.youku.com/v_show/id_XNTcwNDY1NDgw.html
----更新：
游戏已上线，地址：https://itunes.apple.com/us/app/super-germ/id655390338?ls=1&amp;mt=8
----历史帖子：
Super Germ，第三人称3d冒险游戏。平台：iOS。
程序、美术、关卡、音效都是我一个人搞的，现在已经接近完成。
开发日志：http://user.qzone.qq.com/350479720/blog/1354573732
游戏主要元素：
截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70145f9a218515f47873ae5517ec4f2/" rel="bookmark">
			glassfish创建连接池失败（Class name is wrong or classpath is not set for : com.mysql.jdbc.jdbc2.optional.My）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.向服务器已有实例glassfishv3\glassfish\domains\domain1\lib\ext目录下添加数据库驱动包
2.创建数据库连接池
3.创建数据为连接资源
4.发布应用
备注：glassfish V3 旧版当部署EJB应用时，如果没有事前添加数据库驱动包到glassfishv3\glassfish\domains\domain1\lib\ext下，部署也可以通过，但在客户连接时报错（报出来的错也看不明白是哪里的错，会让人莫明其妙），高一点的版本会在部署时就提示这个校验错误然后部署不通过，所以部署引用了数据库驱动包的一定记得先部署数据库驱动包哦。
注意如果忘了将数据驱动包放进glassfish目录下，之后放进去后，记得重新启动glassfish(可以在netbeans中启动)，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015562e138bc8e28778b79600d5f81a4/" rel="bookmark">
			cmd命令 从C盘转到D盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点开始 点运行。输入 CMD 回车。进入DOS提示符状态下。输入
cd\ 回车 表示进入 c:\&gt; 也就是C盘根目录下。
输入
d: 回车 是进入D盘当前目录，并不一定是根目录。
然后
cd\ 就进入D盘根目录。
如果在 C盘根目录下输入
cd windows 回车。表示进入C盘WINDOWS文件夹。注意 CD 与WINDOWS之间有一个至少一个空格
然后，输入 dir 回车 可以显示 windows 目录下面的其他目录与文件进入这些子文件夹，方法雷同，
输入 CLS 回车。表示 清屏。 清除你打的那些命令与显示的信息等。
cd\ 回到根目录
D:转到D盘
cd soft
转到soft文件夹
补充 cd .. 进入父目录
ASSOC 显示或修改文件扩展名关联。
AT 计划在计算机上运行的命令和程序。
ATTRIB 显示或更改文件属性。
BREAK 设置或清除扩展式 CTRL+C 检查。
CACLS 显示或修改文件的访问控制列表(ACLs)。
CALL 从另一个批处理程序调用这一个。
CD 显示当前目录的名称或将其更改。
CHCP 显示或设置活动代码页数。
CHDIR 显示当前目录的名称或将其更改。
CHKDSK 检查磁盘并显示状态报告。
CHKNTFS 显示或修改启动时间磁盘检查。
CLS 清除屏幕。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015562e138bc8e28778b79600d5f81a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcbc39ddfbe232bf715515d4a1a66584/" rel="bookmark">
			java练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class A{float a;static float b;void setA(float a){this.a=a;}void setB(float b){this.b=b;}float getA(){return a;}float getB(){return b;}void inputA(){System.out.println(a);}static void inputB(){System.out.println(b);}}public class Example{public static void main(String args[]){A.b=100;A.inputB();A cat=new A();A dog=new A();cat.setA(200);cat.setB(400);dog.setA(150);dog.setB(300);cat.inputA();cat.inputB();dog.inputA();dog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcbc39ddfbe232bf715515d4a1a66584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606764da535eae40cb20712bc7ba6bb6/" rel="bookmark">
			学习了photoshop能做什么？学习ps的认知和看法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在在网上部分人会用美图秀秀来加工处理一些照片、图片。其根本原因是因为美图秀秀操作比较简单，容易入门上手使用。如果真正说到对图片进行后期的专业软件的话，那莫过于photoshop这款软件。说到为什么学习photoshop？其实很简单，我们就是通过photoshop来学会对图片进行二次加工，看起来更真实，更有吸引力。下面就一起来看看学无忧对Ps的一些认知和看法。 一、为什么要学习photoshop？ 我们的照片一般都是通过摄影师通过在外场拍照所拍摄得到的照片，但是这些照片不管摄影师是有多高超的拍摄技术，它也是有一定的局限性，总会在一些地方稍有欠缺。而这里photoshop就可以通过后期二次加工来将部分瑕疵来进行修饰，这就是一个摄影师和一个修饰图片的人员一起完成的作品。不能勘称完美，但是也趋于很完美。所以这就是我们每个人学习photoshop就更能做出更美丽、更真实的作品来给大家欣赏。 对ps的一些认知和看看 学习photoshop并不是一朝一夕的事情，这往往需要不断的坚持、努力、创新才能到达一个境界。photoshop主要包括图像编辑、图像合成、校色调色、特效制作、绘图功能以及图像输出几大部分。比如图像编辑就是对图片一个放大、缩小、旋转、镜像、偏移、等系列的处理。这也是photoshop最基本的操作。在之后对图片进行特效制作是在Photoshop中主要由滤镜、通道及工具综合应用完成。包括图像的特效创意和特效字的制作，在我们学无忧免费视频教程网就有很多ps后期处理的图形特效教程案例，你有兴趣可以去看看。 二、其次我们学习了photoshop能做什么？ 多数人对于Photoshop的了解仅限于“一个很好的图像编辑软件”，并不知道它的诸多应用方面，实际上，Photoshop的应用领域非常的广泛，在图像、图形、文字、视频、出版各方面都有涉及。就比如最新推出的photoshop-cs6版本就新增加了3D制作应用。下面简单的讲述一下它的一些应用领域： 1、平面设计 2、照片修复 3、广告摄影 4、 影像创意 5、艺术文字 6、网页制作 7、建筑效果图后期修饰 8、绘画 9、绘制或处理三维帖图
三、学习ps一般都是有哪些出路？
1、摄影师,多数会学一些基本功来调颜色。这也是刚刚出道的人员都是需要学习经历的一个过程。
2、平面广告制作,设计,做Visual,简单的把照片拼在一起,或合成,多数不大理会小细节,这些广告商在排版上面很重视，因为最后照片会由Studio拍过,再经过修图师处理,再Replace回广告中。
3、数码绘图师，就是需要有自己的创意去绘制出图片作品。这就必须有一定的功底。
4、3D大师，这就是要更深层的技术来对图片进行后期处。 5、修图师,对Photoshop比较有深入的运用,制作平面广告图片,产品包装图片,Billboard,结婚照!,Fashion相片等方面。
以上就是为什么要学习photosho及学无忧对ps的一些认知和看法。如果你要对photoshop进行系统学习的话，可以在学无忧看看ps大师之路视频教程。希望能帮到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/049639e619ba50116571889481647f18/" rel="bookmark">
			LNMP启停控制自动脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常常在更改LNMP配置之后，需要重启LNMP，在此写了一个自动化脚本，方便重启LNMP。 除了方便重新启动，还增加了关闭与开启功能。 Operating System： Ubuntu Server 代码 #!/bin/bash function start(){ sudo service nginx start sudo service php5-fpm start } function startall(){ start sudo service mysql start } function stop(){ sudo service nginx stop sudo service php5-fpm stop } function stopall(){ stop sudo service mysql start } function restart(){ sudo service nginx restart sudo service php5-fpm restart } function restartall(){ restart sudo service mysql restart } ## main() case "$1" in "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/049639e619ba50116571889481647f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc16c42624b15dd597d669d032ef69f/" rel="bookmark">
			android自定义相机若干问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一直和照相机打交道，学到了不少东西！
具体怎么调用不说了，分享一下洒家所遇到的一些问题以及解决方法1
一、Parameters.setPreviewSize()以及Parameters.setPictureSize()后异常突出
某款相机camera只支持某几种固定的参数，比如中兴ZTE880E只支持480X640的，如果强行设置便会出错。可以Size size=paramet.getPictureSize();获取相关参数，再设置。对于多分辨路的摄像头有一个获取支持参数数组的方法getSupportedPreviewSizes()获取一个list，然后再设置。
二、相机预览及图片倒转问题
手机默认是横屏的，用&lt;applicayion&gt;android:screenOrientation="portrait"设置，
然后你发现预览图倒转90度，再用Camera.setDisplayOrientation(90)调整过来，
然后我擦你又发现拍的照片也特么的旋转了90度，用parameters.setRotation(90)就可以轻松调整过来了！
三、最最最恶心的照片拉伸问题
有时候需要全屏之类的，你的预览是拉伸的，但是照片却正常，但是设置parameters会出错，
好吧，极大地可能是surfaceview大小与照片大小及比例不符合所致，动态设置一下组件的大小就好了！
源代码会贴出来，感兴趣的可以下载下来看一下！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dad48e371ebe70820fb5c2e83aab7b6/" rel="bookmark">
			文件重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数名：freopen 声明：FILE *freopen( const char *path, const char *mode, FILE *stream ); 所在文件： stdio.h 参数说明： path: 文件名，用于存储输入输出的自定义文件名。 mode: 文件打开的模式。和fopen中的模式（如r-只读, w-写）相同。 stream: 一个文件，通常使用标准流文件。 返回值：成功，则返回一个path所指定文件的指针；失败，返回NULL。（一般可以不使用它的返回值） 功能：实现重定向，把预定义的标准流文件定向到由path指定的文件中。标准流文件具体是指stdin、stdout和stderr。其中stdin是标准输入流，默认为键盘；stdout是标准输出流，默认为屏幕；stderr是标准错误流，一般把屏幕设为默认。通过调用freopen，就可以修改标准流文件的默认值，实现重定向。
#include &lt;iostream&gt;#include &lt;cstdio&gt; using namespace std; int main() { int a,b; freopen("d:\\in.txt","r",stdin); //输入重定向，输入数据将从in.txt文件中读取 freopen("d:\\out.txt","w",stdout); //输出重定向，输出数据将保存在out.txt文件中 while(cin&gt;&gt; a &gt;&gt; b) { cout&lt;&lt; a+b &lt;&lt;endl; // 注意使用 endl } fclose(stdin); //关闭文件 fclose(stdout); //关闭文件 return 0; } freopen("in.txt","r",stdin) 的作用就是把标准输入流 stdin 重定向到 in.txt 文件中，这样在用 scanf 或是用 cin 输入时便不会从标准输入流读取数据 , 而是从 in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dad48e371ebe70820fb5c2e83aab7b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98616586a84b847a5d4a472dd125fb4/" rel="bookmark">
			Java Servlet 获取服务器各种路径信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.shop.uitl; import javax.servlet.http.HttpServletRequest; import org.apache.struts2.ServletActionContext; public class ServerUrl { /** * 获取服务的url基本地址 * @param request * @return */ public static String getServerPath(HttpServletRequest request){ String path = request.getContextPath(); String basePath = request.getScheme() + "://"+ request.getServerName() + ":" + request.getServerPort()+ path + "/"; return basePath; } /** * 获取带目录的url地址 * @param request * @param directory * @return */ public static String getServerPath(HttpServletRequest request,String directory){ String path = request.getContextPath(); String basePath = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98616586a84b847a5d4a472dd125fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdb924b066eec96998e7d64db805499/" rel="bookmark">
			SPOJ 1167(Move To Invert-三角形硬币阵颠倒)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SPOJ Problem Set (classical) 1167. Move To Invert Problem code: MINCOUNT 将左边的三角形变成右边这样至少需要挪几枚硬币？ For h=4 at least 3 coins must be moved to invert it.
Input In the first line N will be given and then N lines follow with each line having a integer which is the height of triangle in that test case.00≤h&lt;1010;
Output For each test case output in a seperate line the minimum number of moves required to invert the triangle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdb924b066eec96998e7d64db805499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0684564bd70c05f884604b1cbe94ef63/" rel="bookmark">
			将多个excel表格打包成一个压缩包文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章讲解了如何生成excel文件，name这一章我们来谈谈如何将多个excel文件打包成压缩包的形式
首先看一下主函数：
public static void main(String[] args) throws IOException { try { File file1 = new File("students1.xls"); File file2 = new File("students2.xls"); File file3 = new File("students3.xls"); //创建三个文件，放入list中 ArrayList list = new ArrayList(); list.add(file1); list.add(file2); list.add(file3); //创建临时压缩包 File file = new File("e:/certpics.rar"); //创建文件输入输出流 FileOutputStream fous = new FileOutputStream(file); /**打包的方法我们会用到ZipOutputStream这样一个输出流*/ ZipOutputStream zipOut= new ZipOutputStream(fous); //进入打包方法 zipFile(list, zipOut); zipOut.close(); fous.close(); } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } 主函数里面包含一个zipFile()的方法，接下来展示给大家： /** * 把接受的全部文件打成压缩包 */ @SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0684564bd70c05f884604b1cbe94ef63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9711ba233f439e7ba91730660ded73/" rel="bookmark">
			NRF24L01 使用小结/自动应答/通道地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自：http://hi.baidu.com/huyudu
nrf24L01被设置为接收模式后，可通过6个不同的数据通道（data pipe）接收数据。
每个数据通道都有一个唯一的地址但是各数据通道的频率是相同的。这意味着可以有6个被配置成发送状态的nRF24L01可以和一个配置成接收状态的nRF24L01通信，并且接收方可以区分（通过判断状态寄存器的1-3位即可达到区分的目的）。
数据通道0有一个唯一的40bit的可设置的地址。其余的通道1到通道5则地址前32位相同，而后8位不同。所有的数据通道都可以实现Enhanced ShockBurst模式。
在发送端，数据通道0被用来接收确认信息，因此发送端的数据通道0的地址必须等于发送地址，这样才能收到应答信息。
当一个24L01发送结束后，它会打开接收器并等待确认。如果没有收到确认，则重发，直到收到确认。当重发超过一定次数则发出中断并改变状态寄存器。重发次数的限制在SETUP_RETR_ARC寄存器中设置。
无论何时收到确认，都会认为上一个数据包发送成功，这个数据包将被从发送缓冲区清除，并且把TX_DS IRQ置为高。
每次开始spi写，读回来的都是状态字。
增强型ShockBurst包格式
前置域1byte
地址域3-5byte
包控制域9bit
载荷0-32字节
CRC1-2字节
地址域是接收机地址
包控制域
载荷长度6bit
Pid2bit
NO_ACK1bit
载荷长度：6bit说明最多32字节
Pid：用于包编号，用于确定是重发包还是新包
NO_ACK：用于表示是否自动应答，如为1则表示无需自动应答
自动应答的延时和重发次数是可编程的。
24L01的工作模式和寄存器及IO口的关系如下
CE引脚的作用
一个ESB（Enhanced ShockBurst）周期，发送一个字节连带收到ACK大约339us
从powerdown状态需要先进入standyby状态，该状态转换需要1.5ms延迟，从standyby状态进入rx/tx状态，需要130us
置高CE维持最少10us，启动Enhanced ShockBurst发送。
Enhanced ShockBurst™模式下发送数据流程
1.配置config寄存器，将PRIM_RX置为0，表示发送模式
2. 当需要发送数据时，首先需要配置地址TX_ADDR，这个地址应该是接收端地址（即应该是接收端6个data pipe地址中的一个即可保证对方收到）。如果要使用自动应答，因为应答消息由发送端的datapipe0接收，所以发送的datapipe0的地址应等于TX_ADDR（若是和上一次发送是相同地址，则可不用重写地址）。
3.配置数据负载长度TX_PLD，将需要发送的数据送入nrf24L01，通过SPI连续写入数据载荷时，nrf24L01将自动对字节数计数。（数据载荷必须在cs为低的时候连续写入）
4.将CE置高并维持最少10us，这个脉冲将启动ShockBurst发送
5.NRF24L01：
a)打开射频
b)启动晶振
c)数据打包
d)发送数据
6.如果启动了自动应答（且重传次数未达到最大值），NRF24L01将自动转入接收状态。
1：若在规定时间内收到了应答包，则这是一次成功的发送，TX FIFO中的数据被清除，同时置高status寄存器中的TX_DS位。
2：如果在规定时间内未收到应答包则自动重传（当启用自动重传时，由SETUP_RETR寄存器中的ARC位指定重传次数）。
3：当重传次数到达最大值依然没有收到应答，则status寄存器中的MAX_RT被置高，TX FIFO缓冲区中的数据并不被移除。
MAX_RT或TX_DS被置高都会在IRQ引脚上引起中断（低电平有效，重写status寄存器中的对应位可清除）。在到达最大重传次数并引发中断后，在没有清除MAX_RT之前，任何数据都不能发送。每次发生MAX_RT中断，PLOS_CNT计数器都会加1，用于统计丢包数。
7.CE置低以后，设备进入STANDBY_I状态。否则TX FIFO缓冲区中的下一个数据载荷将被发送。如果数据缓冲区空，而CE仍然为高，设备将进入STANDBY-II模式。
8.如果设备处于STANDBY-II模式，当CE置低后，设备将进入STANDBY-I模式。
（STANDBY模式可减少电流的消耗，在该模式下，SPI通信仍然可以完成）
Enhanced ShockBurst™模式下接收数据流程
1.设置config寄存器中的PRIM_RX为1，且置CE为高
2.130us之后，NRF24L01开始监视射频信号
3. 当合法的包被接收到（地址匹配），数据被存储到RX-FIFO缓冲区中，status寄存器中的RX_DR被置高，IRQ引脚同时发出中断信号（如果未屏蔽该信号）。Status寄存器中的RX_P_NO指示这个应该接收该数据的DATA PIPE号。
4.如果自动应答启用的话，一个应答信号将被发出
5.MCU将CE置为低将进入STANDBY-I模式
6.MCU可通过SPI读出接收到的数据
另外：关于24L01组网想说明几点应注意的地方：
（1）注意地址的分配
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c9711ba233f439e7ba91730660ded73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d1d3c66d5e2ef254e7c56b14b625c3/" rel="bookmark">
			温度场有限容积法程序入门之四：网格剖分.边界条件设置.迭代.导出后处理数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先给出代码：
package Soong.Solver { import flash.net.FileReference; public class TSolverMgr { public var xDim:Number = 20;//Dimension in X Direction public var yDim:Number = 20;//Dimension in X Direction public var dx:Number = 1;//Grid Size in X Direction public var dy:Number = 1;//Grid Size in Y Direction public var IDsteel:uint = Math.pow(2, 1);//ID of material Steel public var IDair:uint = Math.pow(2, 2);//ID of material Air public var steel:Material = null;//Material Steel public var air:Material = null;//Material Air public var Tambient:Number = 30;//Temperature of Ambient Space (Eg: Air) public var ConvectionCoeff:Number = 100;// private var xGridNum:uint = 0;//Number of Grid Allocated in X Direction private var yGridNum:uint = 0;//Number of Grid Allocated in X Direction private var totalGridNum:uint = 0;//Total Number of Grid Allocated in 2D Plane private var keyGridNum:uint = 0;//Number of Key Grid private var xKeyGridNum:uint = 0;//Number of Key Grid in X Direction private var yKeyGridNum:uint = 0;//Number of Key Grid in Y Direction private var solver:TSolver = null; private var nodeList:Vector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81d1d3c66d5e2ef254e7c56b14b625c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a45fcaa5a8af6a98a7448e3a8786f69/" rel="bookmark">
			C&#43;&#43;11中的原子操作（atomic operation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。
在以往的C++标准中并没有对原子操作进行规定，我们往往是使用汇编语言，或者是借助第三方的线程库，例如intel的pthread来实现。在新标准C++11，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。
我们还是来看一个实际的例子。假若我们要设计一个广告点击统计程序，在服务器程序中，使用多个线程模拟多个用户对广告的点击：
#include &lt;boost/thread/thread.hpp&gt; #include &lt;atomic&gt; #include &lt;iostream&gt; #include &lt;time.h&gt; using namespace std; // 全局的结果数据 long total = 0; // 点击函数 void click() { for(int i=0; i&lt;1000000;++i) { // 对全局数据进行无锁访问 total += 1; } } int main(int argc, char* argv[]) { // 计时开始 clock_t start = clock(); // 创建100个线程模拟点击统计 boost::thread_group threads; for(int i=0; i&lt;100;++i) { threads.create_thread(click); } threads.join_all(); // 计时结束 clock_t finish = clock(); // 输出结果 cout&lt;&lt;"result:"&lt;&lt;total&lt;&lt;endl; cout&lt;&lt;"duration:"&lt;&lt;finish -start&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a45fcaa5a8af6a98a7448e3a8786f69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b925d9120e340c57bc1043f7a8f4ce0/" rel="bookmark">
			Create user中采用externally操作系统认证方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装完oracle,会自动在操作系统中添加用户组ORA_DBA, ORA_OPER, 在这两个用户组里的操作系统用户, 以sysdba身份登陆oracle是不需要密码的..
2、执行create user aaa identified EXTERNALLY;用户的密码是什么?
通过OS系统认证，验证的是OS用户的口令
3、在系统中建立一个用户test，指定和oracle用户相同的组。（sun solaris）
在数据库中创建用户test。
create user test indentified externally;
(初始化参数OS_AUTHENT_PREFIX="")
grant dba to test;
使用test用户登陆系统，输入用户名，密码。
bash-2.03$ sqlplus /nolog
SQL*Plus: Release 8.1.7.0.0 - Production on Wed Apr 16 14:52:20 2003
(c) Copyright 2000 Oracle Corporation. All rights reserved.
SQL&gt; connect / as sysdba
Connected.
SQL&gt;
SQL&gt; connect /
Connected.
SQL&gt; select user from dual; USER
--------------------------------------------------------------------------------
TEST
SQL&gt; connect / as sysdba
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b925d9120e340c57bc1043f7a8f4ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ebbc8520f87cddcb6337a4855e4ad41/" rel="bookmark">
			BZOJ 1013([JSOI2008]球形空间产生器sphere-gauss消元练习)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1013: [JSOI2008]球形空间产生器sphere Time Limit: 1 Sec Memory Limit: 162 MB Submit: 1181 Solved: 654 [ Submit][ Status][ Discuss] Description 有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。 Input 第一行是一个整数，n。 接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。每一个实数精确到小数点后6位，且其绝对值都不超过20000。 Output 有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后3位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。 Sample Input 2 0.0 0.0 -1.0 1.0 1.0 0.0 Sample Output 0.500 1.500 数据规模： 对于40%的数据，1&lt;=n&lt;=3 对于100%的数据，1&lt;=n&lt;=10 提示：给出两个定义： 1、 球心：到球面上任意一点距离都相等的点。 2、 距离：设两个n为空间上的点A, B的坐标为(a1, a2, …, an), (b1, b2, …, bn)，则AB的距离定义为：dist = sqrt( (a1-b1)^2 + (a2-b2)^2 + … + (an-bn)^2 ) gauss消元 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdlib&gt; #include&lt;functional&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; #define MAXN (10+10) #define MAXAi (20000) #define eps (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ebbc8520f87cddcb6337a4855e4ad41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ea7caf66c86b3bb3ecdfb17c66eff2/" rel="bookmark">
			SQL2008 SQL Server 代理服务提供的凭据无效。若要继续操作，请为 SQL Server 代理服务提供有效的帐户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From:http://blog.sina.com.cn/s/blog_43f5c8b40100yral.html
安装到服务器配置时出的错误:
为 SQL Server 代理服务提供的凭据无效。若要继续操作，请为 SQL Server 代理服务提供有效的帐户和密码。
解决方法：直接在所有的“账户名”下拉菜单选项中选system ，就可以通过系统来在下一步设置密码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650bb499920f4135f5d6987328a32333/" rel="bookmark">
			BZOJ 3132(上帝造题的七分钟-树状数组求和&#43;2D逆求和数组)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3132: 上帝造题的七分钟 Time Limit: 20 Sec Memory Limit: 128 MB Submit: 46 Solved: 18 [ Submit][ Status][ Discuss] Description “第一分钟，X说，要有矩阵，于是便有了一个里面写满了0的n×m矩阵。
第二分钟，L说，要能修改，于是便有了将左上角为(a,b)，右下角为(c,d)的一个矩形区域内的全部数字加上一个值的操作。
第三分钟，k说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。
第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。
第五分钟，和雪说，要有耐心，于是便有了时间限制。
第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过32位有符号整数类型的表示范围的限制。
第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”
——《上帝造裸题的七分钟》
所以这个神圣的任务就交给你了。
Input 输入数据的第一行为X n m，代表矩阵大小为n×m。
从输入数据的第二行开始到文件尾的每一行会出现以下两种操作：
L a b c d delta —— 代表将(a,b),(c,d)为顶点的矩形区域内的所有数字加上delta。
k a b c d　—— 代表求(a,b),(c,d)为顶点的矩形区域内所有数字的和。
请注意，k为小写。
Output 针对每个k操作，在单独的一行输出答案。
Sample Input X 4 4 L 1 1 3 3 2 L 2 2 4 4 1 k 2 2 3 3 Sample Output 12 HINT 对于100%的数据，1 ≤ n ≤ 2048, 1 ≤ m ≤ 2048, 1 ≤ delta ≤ 500,操作不超过200000个,保证运算过程中及最终结果均不超过32位带符号整数类型的表示范围。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/650bb499920f4135f5d6987328a32333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7cc087351d86c59db341f9ce8536df/" rel="bookmark">
			SecureCRT自动记录日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在推特上看到有人谈起SecureCRT日志记录的问题，貌似很多人都有这习惯
我是开始工作后才使用SecureCRT，一直没记录过日志
不过搜了下，看看这功能不错，可以看看自己做什么，有时甚至可以看看之前是不是犯了什么错，很不错的功能
所以我也决定开始记录日志，设置很简单，不过我自己瞎捣鼓发现还可以自动分文件夹，不知道大家是否都知道，因为我搜的几篇文章都没提到
下面开始说怎么设置吧，希望能帮到你
在菜单里选择“选项”——“全局选项”
然后选择常规——默认会话——编辑默认设置
然后选择日志文件
在日志文件名里填入你想保存的日志路径名加日志文件名
这里为了可以每个会话都打成一个日志，可以采用支持的参数
%H 主机名 %S 会话名
%Y 年份 %M 月份 %D 日
%h 小时 %m 分钟 %s 秒
例如我填写的E:\Development\SecureCRT\Logs\%H\%Y-%M-%D_%h%m%s.log
就是会保持在E:\Development\SecureCRT\Logs\目录下，路径里也可以使用参数
\%H\这样设置可以把同一个主机的日志到到一个文件夹里，文件夹名就是主机名，没有会自动创建文件夹
这里可以勾选上连接上开始记录日志
因为我们经常开着SecureCRT，但不一定一直在用，为了知道我输入的每一行命令是在什么时候，可以在“在每行”这个设置里填写[%h:%m:%s]
这样就会记录每行日志打入的时间
不知你是否也想要记录自己的日志，试试吧
From:http://xfeng.me/securecrt-auto-record-logs/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dee0953a1655132b0e6d92c804f4a02/" rel="bookmark">
			TCP segment of a reassembled PDU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周在公司里遇到一个问题，用wireshark抓系统给网管上报的数据发现里面有好多报文被标识为“TCP segment of a reassembled PDU”，并且每一段报文都是180Byte，当时看到这样的标识，觉得是IP报文分片，以为系统的接口MTU值为设置小了，通过命令查询发现是1500，没有被重设过，当时有点想不通。 回来查了一下，发现自己的理解是错的，“TCP segment of a reassembled PDU”指的不是IP层的分片，IP分片在wireshark里用“Fragmented IP protocol”来标识。详细查了一下，发现“TCP segment of a reassembled PDU”指TCP层收到上层大块报文后分解成段后发出去。于是有个疑问，TCP层完全可以把大段报文丢给IP层，让IP层完成分段，为什么要在TCP层分呢？ 其实这个是由TCP的MSS(Maximum Segment Size，最大报文段长度)决定的，TCP在发起连接的第一个报文的TCP头里通过MSS这个可选项告知对方本端能够接收的最大报文（当然，这个大小是TCP净荷的大小），以太网上这个值一般设置成1460，因为1460Byte净荷+20Byte TCP头+20Byte IP头 ＝ 1500字节，正好符合链路层最大报文的要求。 至于收到一个报文后如何确定它是一个"TCP segment"？如果有几个报文的ACK序号都一样，并且这些报文的Sequence Number都不一样，并且后一个Sequence Number为前一个Sequence Number加上前一个报文大小再加上1的话，肯定是TCP segment了，对于没有ACK标志时，则无法判断。 既然收到的TCP报文都是180Byte的segment，那么应该是协商的时候PC端告知了MSS为180Byte，至于为什么这样，只能等抓包后确认是MSS的问题再排查了。另外，有一种情况也可能导致这个问题：被测系统因为MTU为220Byte而设置MSS为180Byte，但是这种情况现在可以排除，因为前面讲过，已经查询过MTU值为1500。 今天利用windows查找功能对网络上的一个共享文件夹里的内容进行查找，发现查找网络文件时流量巨大。好奇用wireshark抓包发现wireshark Info栏里有很多“TCP segment of a reassembled PDU”提示信息。不解百度了一下发现大家都在询问这个问题网上并没有很好的解答。想到“TCP segment of a reassembled PDU”只是wireshark的提示信息，那么在sniffer pro里会给出什么样的提示呢，用sniffer打开同样的trace 发现里面提示“Continuation of missing frame”和"Continuation of frame xx"现在大概知道“TCP segment of a reassembled PDU”是什么意思，其实主机响应一个查询或者命令时如果要回应很多数据（信息）而这些数据超出了TCP的最大MSS时，主机会通过发送多个数据包来传送这些数据（注意：这些包并未被分片）。对wireshark来说这些对相应同一个查询命令的数据包被标记了“TCP segment of a reassembled PDU” 问题，wireshark如何识别多个数据包是对同一个查询数据包的响应? wireshark是根据sequence number来识别，这些数据包ACK number是相同的，当然number的数值与查询数据包中的next sequence number也是一样的。 CIFS/SMB协议对待文件查询效率多么的低下！对待一个文件名的查询要用两个帧长1514字节和一个1294字节的帧长来响应。 本文来自CSDN博客，转载请标明出处：http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dee0953a1655132b0e6d92c804f4a02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855aeebc3a2c2e4c2857e16e3f86a10e/" rel="bookmark">
			SetUnhandledExceptionFilter生成Mini-dump文件分析(代码整理)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 代码: 新建一个WIN32 工程, 加入以下代码就行
#include "stdafx.h" #include &lt;windows.h&gt; #include &lt;dbghelp.h&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; #pragma comment(lib, "dbghelp") #ifndef _M_IX86 #error "The following code only works for x86!" #endif void DisableSetUnhandledExceptionFilter() { void *addr = (void*)GetProcAddress(LoadLibrary(_T("kernel32.dll")), "SetUnhandledExceptionFilter"); if (addr) { unsigned char code[16]; int size = 0; code[size++] = 0x33; code[size++] = 0xC0; code[size++] = 0xC2; code[size++] = 0x04; code[size++] = 0x00; DWORD dwOldFlag, dwTempFlag; VirtualProtect(addr, size, PAGE_READWRITE, &amp;dwOldFlag); WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL); VirtualProtect(addr, size, dwOldFlag, &amp;dwTempFlag); } } LONG WINAPI MyUnhandledExceptionFilter(struct _EXCEPTION_POINTERS* lpExceptionInfo) { TCHAR szProgramPath[MAX_PATH] = {0}; if(GetModuleFileName(NULL, szProgramPath, MAX_PATH)) { LPTSTR lpSlash = _tcsrchr(szProgramPath, '//'); if(lpSlash) { *(lpSlash + 1) = '/0'; } } TCHAR szDumpFile[MAX_PATH] = {0}; _stprintf(szDumpFile, _T("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/855aeebc3a2c2e4c2857e16e3f86a10e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca53134391cc0e1792da23de35d1c47/" rel="bookmark">
			电容三点式振荡器电路图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电容三点式振荡器电路图 2008年01月31日 22:33 本站原创 作者：本站 用户评论（0） 关键字： 电容三点式振荡器电路
这个电路适合产生几十兆赫以上的信号，常用来作射频振荡器。第二个图是LC振荡回路的等效电路图，从图上可以看到，电路的振荡频率由L、C、C1、C2决定，基极有一个大电容（1000~2000pF），起交流接地的作用。由于电感和电容的数值都比较小，所以有些情况下三极管的极间电容、电感线圈的匝间电容都不能忽略。它们对总电容的贡献量大约几个皮法。
设三极管的极间电容以及电感线圈的匝间电容以及其它分布电容的总等效电容为C0,为了计算方便，选C0＝2pF那么
电容三点式振荡电路又称考毕兹振荡电路，如图Z0808所示，其结构与电感三点式振荡电路相似，只是将电感、电容互换了位置。为了形成集电极回路的直流通路，增设了电阻RC。该电路的交流通路如图Z0809 所示。可以看出，它符合三点式振荡电路"射同基反"的构成原则，满足自激振荡的相位平衡条件。
在LC谐振回路Q值足够高的条件下，电路的振荡频率为
其中
这种振荡电路的特点是振荡频率可做得较高，一般可达到100MHz以上，由于C2对高次谐波阻抗小，使反馈电压中的高次谐波成分较小，因而振荡波形较好。电路的缺点是频率调节不便，这是因为调节电容来改变频率时，（既使C1、C2 采用双连可变电容）C1与C2也难于按比例变化，从而引起电路工作性能的不稳定。因此，该电路只适宜产生固定频率的振荡。
用集成运放构成的电容三点式振荡电路，如Z0810所示。可以证明，其振荡频率为：
各种振荡器电路的计算器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9742f36e9651b0eca44521470fc73f4c/" rel="bookmark">
			获取webshell权限的45种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1, 到GoogLe,搜索一些关键字,edit.asp? 韩国肉鸡为多,多数为MSSQL数据库! 2, 到Google ,site:cq.cn inurl:asp 3, 利用挖掘鸡和一个ASP木马. 文件名是login.asp 路径组是/manage/ 关键词是went.asp 用'or'='or'来登陆 4, 关键字：Co Net MIB Ver 1.0网站后台管理系统 帐号密码为 'or'='or' 5. 动感购物系统 inurl:help.asp登陆，如未注册成为会员! upLoad_bm1.asp和upLoad_c1.asp这两个随便选个，一般管理员都忽视了这2漏洞 6. 默认数据库地址blogdata/acblog.asa 关键字：acblog 7. 百度 /htdocs 注册里可以直接上传asa文件！ 8. /Database/#newasp.mdb 关键词：NewAsp SiteManageSystem Version 9. 用挖掘机 关键字：Powered by WEBBOY 页面：/upfile.asp 10. baidu中搜索关键字Ver5.0 Build 0519 (存在上传漏洞) 11. Upfile_Article.asp bbs/upfile.asp 输入关键字：powered by mypower ， 12. inurl:winnt\system32\inetsrv\ 在google里面输入这个就可以找到很多网站 13. 现在GOOGLE搜索关键字 intitle:网站小助手　inurl:asp 14. 键字： 首页 最新动态 新手指南 舞曲音乐 下载中心 经典文章 玩家风采 装备购买 站内流言 友情连接 本站论坛 挖掘鸡的关键字 添 setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9742f36e9651b0eca44521470fc73f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be1f7ed30c522d0d4b5be2428c6a2505/" rel="bookmark">
			FreeLibrary死锁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加载一个dll，退出的时候通过FreeLibrary进行释放，发现进入死锁状态，无法退出。一般这种情况是dll中的线程没有退出，导致一直处于等待状态。查看代码发现确实是在dll退出函数中调用::WaitForSingleObject(pLog-&gt;m_hSemaphore, INFINITE)一直在等待线程退出。线程是通过_beginthreadex进行创建，而在调用WaitForSingleObject之前已经将线程运行标志置为false，所创建的线程函数已经运行结束。但是WaitForSingleObject还是一直处于等待状态。
目前还没找到对应原因，只能将WaitForSingleObject的等待时间置为1秒，避免无限期等待。有哪位大侠知道原因或者解决思路的请留言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bf9ee7342a4832608a6b4ee75c413b/" rel="bookmark">
			Boost.Lockfree官方文档翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Boost_1_53_0终于迎来了久违的Boost.Lockfree模块，本着学习的心态，将其翻译如下。（原文地址：http://www.boost.org/doc/libs/1_53_0/doc/html/lockfree.html）
Chapter 17. Boost.Lockfree 第17章．Boost.Lockfree Table of Contents
目录
Introduction&amp; Motivation
简介及动机
Examples
例子
Rationale
解释
DataStructures
数据结构
MemoryManagement
内存管理
ABAPrevention
ABA预防
InterprocessSupport
进程间支持
Appendices
附录
FutureDevelopments
未来发展
Introduction&amp; Motivation 简介和动机 Introduction &amp; Terminology 简介及术语 The term non-blocking denotes concurrent data structures,which do not use traditional synchronization primitives like guards to ensurethread-safety. Maurice Herlihy and Nir Shavit (compare "TheArt of Multiprocessor Programming")distinguish between 3 types of non-blocking data structures, each havingdifferent properties:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80bf9ee7342a4832608a6b4ee75c413b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8f004f9d1cd5d3093a2d6a28f60bbe/" rel="bookmark">
			UVA 11538(Chess Queen-矩阵对角线长度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Problem A
Chess Queen Input: Standard Input
Output: Standard Output 王后互相攻击的前提是在一行，一列，或一对角线。:
在 (NxM) 的棋盘上 2 王后互相攻击，求方案数.
Input 输入数据不超过 5000 行 ，每行为M and N (0&lt; M, N£106) ,数据以0 0结尾.
Output 每行一个整数表示方案数，保证它在u64范围内.
Sample Input Output for Sample Input 2 2 100 223
2300 1000
0 0
12 10907100
11514134000 Problemsetter: Shahriar Manzoor
Special Thanks to: Mohammad Mahmudur Rahman
首先，一个矩形的长宽若为m,n(m&gt;=n)
那么它一个方向的对角线应为1..(n-1)各2条,n有(m-n+1)条
知道这个的化，本题就转化为，在一列一行或一对角线任取2点，有几种取法。
#include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;functional&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; using namespace std; #define MAXN (1000000+10) unsigned long long n,m; int main() { while (cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m) { if (n&gt;m) swap(n,m); cout&lt;&lt;n*m*(n+m-2)+2*n*(n-1)*(3*m-n-1)/3&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e48b2e2d1d1a57e24b11d4aab0e4ca2/" rel="bookmark">
			Windows下的双显的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XP系统下设置双显的过程
电脑：AUSUS K50I
显卡为NVIDIA N1-0P-GE
在桌面上右击，选属性。在弹出窗口中找到设置选项卡，会看到有两个显示器编号。点选2号显示器。在下面找到两个选项，先选择下面的扩展桌面到此监视器，然后再选上面的设置此显示器为主显示器。点下面的应用按钮，然后选1号显示器，把下面两个选项中的扩展桌面到此监视器这个选项取消选择，就可以了。
2、一些应用程序在双显时的特性 （1） PPT
把PPT拖到副显，此时按F5放映PPT。却是在主显示PPT全屏放映，而副显还是显示编辑状态的PPT。
（2） RDP
RDP7不支持双显。Win7 下的RDP才支持双显。
（3） 按Ptr Sc键，把桌面的屏幕保存到mspaint中，此时看到是两个屏幕的和。
长*宽是否２６４６＊７６８ ，这个大小就是双显的大小
可以看到2646是主显的分辩率的宽+副显的分辨率的宽。（1280+1366）
Introduction
This has been an ongoing topic for a while and I keep on getting question(s) on how can we launch Windows or in our case application(s) in different screens. In the place that I currently work, City of Dreams, we have many different types of adapters for many A/V systems and the applications like Lucky Draw, Slot Results, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e48b2e2d1d1a57e24b11d4aab0e4ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0fd634c1f8813638ec4b983df18555/" rel="bookmark">
			QT中用Qpainter的drawText方法程序crash的可能原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT中用Qpainter的drawText方法程序crash的可能原因 (2010-11-17 11:43:20)
转载▼
标签：
杂谈
分类： c/cpp 早上遇到这个很神奇的问题，之所以说神奇，是因为以前drawText完全没问题。
google到这个：http://bugreports.qt.nokia.com/browse/QTBUG-5634
原来是因为我们是在dll中drawText，而dll中没有实例化QApplication对象导致的。简单地给dll加个QApplication全局变量？这个我喜欢。但是程序直接罢工了。
只能再google，发现原来是QT与dll之间的龌龊导致的。解决方法可参考：http://blog.csdn.net/tingsking18/archive/2009/12/08/4967172.aspx
于是下载了QTWinmigrate进行了一番折腾。终于搞定了这个问题。
搞定是搞定了。但我反思了下，qt+dll这种方式其实有不合理之处。最好还是不要这么做。
分享： 分享到新浪Qing 喜欢
阅读┊ 评论 ┊收藏 ┊转载 ┊ 喜欢▼ ┊打印┊举报 加载中，请稍候......
前一篇：QT4.6中将QImage保存为JPG格式
后一篇：我不可能像对待老婆一样去对待客户
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a11f67e335061ca9d680a9178fcdeae/" rel="bookmark">
			扩展OSGi控制台，通过web访问操作console，支持3.4、3.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在开发基于OSGi的应用时，不可避免的要通过它的控制台进行相关调试。在开发阶段，调试可以直接在eclipse控制台输入相关命令，而当我们把程序部署到web服务器上后就不能再采用这样的方式了。但幸运的是，我们可以扩console以满足自己的需要，因此可以实现一个通过web访问console的方式。扩展conso可以参考基于 Equinox 的 OSGi Console 的研究和探索。
由于equinox 3.4和3.6在代码结构上的差异，要扩展一个通用的通过web控制的console，用反射是个好的选择，eg. FrameworkConsole的构造函数不一致，3.6已经没有OSGi这个类...以下是详细实现：
WebConsoleServlet.java，发布该servlet让客户端访问，并通过参数cmd传输相关的OSGi命令：
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); try { String command = request.getParameter("cmd"); try { final CommandServiceFacade facade = CommandServiceFacade.INSTANCE; facade.setContext(Activator.bundleContext); facade.setOut(response); facade.execute(command); } catch (Exception e) { e.printStackTrace(); } } catch (Exception e) { e.printStackTrace(); } }CommandServiceFacade.java，封装具体实现： public class CommandServiceFacade { private static final String OSGI_VERION_3_4 = "3.4"; private static final String OSGI_VERION_3_6 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a11f67e335061ca9d680a9178fcdeae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/454e28c98066c1595fac3a947cd7b38a/" rel="bookmark">
			[转]autowire属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://zgzd13575java.iteye.com/blog/274547
采用的是Spring2.0的xml,在这里,IOC控制反转,我只探讨autowire的四个比较常用的属性 一:系统默认的autiwire="no" &lt;bean id="show" class="com.zgz008.web.ShowListBean" autowire="no" &gt; &lt;property name="showService"&gt; &lt;ref bean="showService"&gt;&lt;/ref&gt; &lt;/property&gt; &lt;/bean&gt; proprtty name属性指的是com.zgz008.web.ShowListBean内部反射成set方法生成的,并不是说一定是属性名showService ref bean指的就是我们的id号啦 二: autowire="byName" &lt;bean id="show" class="com.zgz008.web.ShowListBean" autowire="byName" /&gt; 自动根据applicationContext.xml里面的bean id属性反射成set方法,去查询com.zgz008.web.ShowListBean有没有拥有这个方法 有的话就自动依赖注入 三:autowire="byType" &lt;bean id="show" class="com.zgz008.web.ShowListBean" autowire="byType" /&gt; 只要com.zgz008.web.ShowListBean有一个属性与Spring容器中的属性相匹配,那么就会自动装载进来,调用的是set方法（不用管属性名） 四:autowire="constructor" &lt;bean id="show" class="com.zgz008.web.ShowListBean" autowire="constructor" &gt; &lt;constructor-arg index="0" type="com.zgz008.service.IShowService""&gt; &lt;ref bean="showServiceOK" /&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 使用的是构造器注入,ref bean指的是id号,只要类型匹配就会自动注入,（不用管属性名） 总的来说，只要你命名规范符合标准,应该不会有什么大问题的 以下内容转载 no 不使用自动装配。必须通过ref元素指定依赖，这是默认设置。由于显式指定协作者可以使配置更灵活、更清晰，因此对于较大的部署配置，推荐采用该设置。而且在某种程度上，它也是系统架构的一种文档形式。 byName 根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的bean，并将其与属性自动装配。例如，在bean定义中将autowire设置为by name，而该bean包含master属性（同时提供setMaster(..)方法），Spring就会查找名为master的bean定义，并用它来装配给master属性。 byType 如果容器中存在一个与指定属性类型相同的bean，那么将与该属性自动装配。如果存在多个该类型的bean，那么将会抛出异常，并指出不能使用byType方式进行自动装配。若没有找到相匹配的bean，则什么事都不发生，属性也不会被设置。如果你不希望这样，那么可以通过设置dependency-check="objects"让Spring抛出异常。 网管论坛bbs_bitsCN_com constructor 与byType的方式类似，不同之处在于它应用于构造器参数。如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。 autodetect 通过bean类的自省机制（introspection）来决定是使用constructor还是byType方式进行自动装配。如果发现默认的构造器，那么将使用byType方式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91607d1fc554e867ee820b7ed86574b2/" rel="bookmark">
			gdb结合coredump定位崩溃进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux环境下经常遇到某个进程挂掉而找不到原因，我们可以通过生成core file文件加上gdb来定位。
linux下如何产生core file? 我们可以使用ulimit这条命令对core file文件的大小进行设定。 一般默认情况下，core file的大小被设置为了0，这样系统就不dump出core file了。 这时用如下命令进行设置： ulimit -c unlimited 这样便把core file的大小设置为了无限大，同时也可以使用数字来替代unlimited，对core file的上限值做更精确的设定。 生成的core file在哪里? core file生成的地方是在/proc/sys/kernel/core_pattern文件定义的。 改动到生成到自己定义的目录的方法是： echo "pattern" &gt; /proc/sys/kernel/core_pattern 并且只有超级用户可以修改这两个文件。 "pattern"类似我们C语言打印字符串的格式，相关标识如下： %%: 相当于%
%p: 相当于&lt;pid&gt;
%u: 相当于&lt;uid&gt;
%g: 相当于&lt;gid&gt;
%s: 相当于导致dump的信号的数字
%t: 相当于dump的时间
%h: 相当于hostname
%e: 相当于执行文件的名称 这时用如下命令设置生成的core file到系统/tmp目录下，并记录pid以及执行文件名 echo "/tmp/core-%e-%p" &gt; /proc/sys/kernel/core_pattern 测试如下代码 ? 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;stdio.h&gt; int func( int *p) { *p = 0; } int main() { func(NULL); return 0; } 生成可执行文件并运行 gcc -o main a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91607d1fc554e867ee820b7ed86574b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cde1af39d424143b48f1ba6ec12d4b1/" rel="bookmark">
			POJ 2553(The Bottom of a Graph-缩点求出度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Language: Default The Bottom of a Graph Time Limit: 3000MS Memory Limit: 65536KTotal Submissions: 7308 Accepted: 3003 Description
We will use the following (standard) definitions from graph theory. Let V be a nonempty and finite set, its elements being called vertices (or nodes). Let E be a subset of the Cartesian product V×V, its elements being called edges. Then G=(V,E) is called a directed graph. Let n be a positive integer, and let p=(e1,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cde1af39d424143b48f1ba6ec12d4b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01837530a3d3d90cd269f1a94f67fc86/" rel="bookmark">
			最好的程序员大多是自学成才的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Twitter创始人：最好的程序员大多是自学成才的
摘要：Twitter的创始人Jack Dorsey相信最好的程序员大多数都是自学成才的。想想看还真是，编程作为一门手艺，现在会教而且肯教的师傅恐怕还不太多。 28岁时的Jack Dorsey，那时候他还只是一个无名小卒（图片来自Wikipedia） 据 BusinessInsider报道，3月1日在纽约大学企业家节（ NYU Entrepreneur Festival）上，Twitter的创始人Jack Dorsey（噢，他现在可能更愿意被成为Square的创始人吧）在Keynote演讲后的访谈环节中表示，他相信最好的程序员大多数都是自学成才的。从我的观察来看，某种程度上这是真的。记得有一次CSDN的活动期间聚餐，一桌业界知名的技术专家，我问：“你们谁是计算机专业科班出身的？”居然没有一个人举手……为什么呢？非计算机专业的同学，最后靠自学成为专业程序员的，往往是因为确实对这事儿感兴趣有热情。而且他们中不少人视野更宽、兴趣更广泛，因此更有可能取得较高成就。即使是计算机科班出身、到后来仍然战斗在一线、技术不错的同学，恐怕直接从学校教育、老师那里所得也不会太多吧。其实Dorsey本人就是一个自学成才的例子。与乔布斯、盖茨、Zuckerberg一样，Dorsey也没有读完大学。他解释说：“我在校外学得更多而且更有效率。” 有意思的是，Dorsey最近却和盖茨、Zuckerberg等一起为促进更多学校增加编程教育而做了影响很广的 宣传。他表示培养孩子学习编程很重要，这会给你另一种思考的方式。“很多人认为编程和工程很机械，其实它也是一种艺术形式，是另一种语言。”类似的话，乔布斯在失而 复得的1995年视频里说过：“每个人都应该学习编程，因为这能教你如何思考。” Dorsey可能是现在全世界里有数的传奇程序员（也是最牛的产品经理）之一，他的个人经历非常有意思，推荐阅读之前我在《程序员》杂志发表的文章 “改变世界的程序员——Jack Dorsey”。计算机编程教育目前是一个热点，软件在吞噬世界，背后的人当然是程序员，而程序员的能力和数量都将成为国家竞争力的关键要素。这个问题其实很大，有机会还要深入探讨。编程非自学不能成才也，这事儿你怎么看？
http://www.csdn.net/article/2013-03-03/2814318-jack-dorsey-on-best-programmers 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133391890d0ce282b2da79f81b904e63/" rel="bookmark">
			字符串处理(七)strtod、strtof、strtold等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1815dac4dafbe1c41bdb959813745388/" rel="bookmark">
			POJ 1631
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：POJ 1631（最长上升子序列）
看了题目以后就知道这是最长上升子序列，本来想跳过去不做了。后来，觉得不能自满，于是就又敲了一边最长上升子序列的代码。结果TL了。这下囧了！一直不知道最长上升子序列还能优化的。百度了一下，原来很简单。
开一个数组d[],用d[i]表示长度为i的最小的那个数，这样可以大大地减小重复的次数。而且这样做空间复杂度还是一样的。不难发现d[i]十一个递增的数列。那么再查找的时候还可以二分（没有用二分也能过）
代码如下：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int const N = 40005; int main() { int n, p; int a[N], d[N]; while(scanf("%d", &amp;n) != EOF) { while(n--) { int ans = 1; scanf("%d", &amp;p); for(int i = 0; i &lt; p; ++i) scanf("%d", a + i); d[1] = a[0]; int tt = 1; for(int i = 1; i &lt; p; ++i) { for(int j = tt; j &gt; 0; --j) { if(a[i] &gt; d[j]) { if(j &lt; tt &amp;&amp; d[j + 1] &gt; a[i]) d[j + 1] = a[i]; else if(j == tt) ++tt,d[tt] = a[i]; break; } else if(j &lt;= 2 &amp;&amp; a[i] &lt; d[1]) d[1] = a[i]; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1815dac4dafbe1c41bdb959813745388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450aae4f3e6dc3468add69a85638cb96/" rel="bookmark">
			SQL Server 2008 高可用性视频（二）-- 日志传送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做数据库的朋友都知道, 其实数据库的工作大致可以分为三类: 数据库设计与开发, 数据库管理, 数据库商业智能. 其中数据库管理的工作大部分是由DBA在做, DBA们除了要保证正常的数据库运行, 还要采取必要措施提升数据库的性能, 比如数据库的性能优化, 以及保证数据库系统的高可用性. 我在前面发了几篇对SQL Server数据库进行调优的文章, 下面会再开一个SQL Server高可用性解决方案的主题.
笔者工作中也有很多场景会用到HA, 但因为没有进行过系统的学习, 所以处理HA问题时总觉得捉襟见肘. 索性, 就下决心把这几种高可用性解决方案都系统地过了一遍. 一下手, 才知道, 除了枯燥的MSDN文档, 完整讲解HA知识点的文档真心不多, 视频更是找不到, 估计很多朋友都跟我有相同的感受. 好吧, 那我就自己学, 自己配, 自己录, 把知识点及配置的过程都以视频形式记录下来, 以后用到的时候好复习, 有机会发到网上, 其他朋友看到后也更容易接受. 需要提一下的是, 这期间, 刚好有个IT学习网站让帮忙做些数据库视频, 所以中间会有一些他们的Logo, 希望大家不要介意. 今天上传的是第一种高可用性解决方案： 日志传送。 它的特点是设置简单， 对环境的要求相对比较低， 更多时候用在报表数据库上。 不足是实现的功能也相对简单， 不能实现自动故障转移群集， 不能进行双向更改。
视频链接
SQLServer高可用性(二)-日志传送
视频提纲：
o 事务日志传送是如何工作的
建立一个备用的服务器
更新时间可以被配置
需要使用完整恢复模型或大容量日志模型
依赖于备份/还原操作
不需要特殊的硬件支持
可以有多个备用数据库
o 角色:
主数据库,备用数据库,监测数据库
o 过程:
在主服务器上创建事务日志备份
文件被复制到备用服务器上
日志被还原到备用服务器上
NORECOVERY (数据库保持脱机状态)
STANDBY (数据库是只读的)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/450aae4f3e6dc3468add69a85638cb96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce355ce33d09071ce0c5a082bcbc955/" rel="bookmark">
			各常见数据类型范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		char -128 ~ +127 (1 Byte)
short -32767 ~ + 32768 (2 Bytes)
unsigned short 0 ~ 65536 (2 Bytes)
int -2147483648 ~ +2147483647 (4 Bytes)
unsigned int 0 ~ 4294967295 (4 Bytes)
long == int
long long -9223372036854775808 ~ +9223372036854775807 (8 Bytes)
double 1.7 * 10^308 (8 Bytes)
unsigned int 0～4294967295 long long的最大值：9223372036854775807
long long的最小值：-9223372036854775808
unsigned long long的最大值：1844674407370955161
__int64的最大值：9223372036854775807
__int64的最小值：-9223372036854775808
unsigned __int64的最大值：18446744073709551615
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e1067ea3f77b004ec2dc284fd45fa1/" rel="bookmark">
			CH 白色情人节1(②第一天-KM算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 下过雨的夏天傍晚 我都会期待 唱歌的蝉 嘿 把星星都吵醒 月光晒了很凉快 就是这样回忆起来 第一次告白 尴尬的我 看 爱装得很哲学的你其实很可爱 你说活在明天 活在期待 不如活得今天很自在 我说我懂了 会不会太快 未来 第一天要展开 描述 时间回溯到男女主认识的第一天——女主同学举办的联谊会，男主迟到了那天的联谊会，而男主到达现场时女主也刚好没有男伴，这就是他们的第一次相遇。 男主回想起来不禁一阵感慨(为啥这么好的妹子你们都不搭讪呢)，突然男主想到，如果当时 已经配对的n对男女好感值之和不是 最大，会不会自己就遇不上女主了呢？ 输入格式 第一行两个正整数n和queen，表示已有n对男女可以配对和女主的编号queen。(男编号为X 1~X n，女编号为Y 1~Y n+1) 接下来n*(n+1)行，每行三个正整数X i，Y i，Z i，表示男X i女Y i之间的好感度为Z i， 保证每对(Xi,Yi)没有重复，即两人的关系至多一条。 不存在男与男、女与女之间的好感度！ 输出格式 前n行输出联谊会上n对男女的配对情况 (会多出来一名女生)，每行两个正整数X i和Y i(空格隔开)，任意一种符合条件的方案均可。 第n+1行， 对于你输出的方案，如果女主未配对，输出"YES"(不含引号)，表示女主会遇到男主，否则输出"NO"(不含引号)。 样例输入 2 3 1 1 15 1 2 20 1 3 17 2 1 22 2 2 14 2 3 14 样例输出 1 2 2 1 YES 数据范围与约定 对于100%的数据， 。 样例解释 如图，已经配对的关系有是 男1号女2号和 男2号女1号。 来源 *****关系~ km算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e1067ea3f77b004ec2dc284fd45fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ec0a57dd962efa20464cddc3fa7b193/" rel="bookmark">
			网络常用命令(三)ifconfig、ifup和ifdown
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 ifconfig概述：
(1)ifconfig命令能够启用或者禁止一个网络接口，设置它的ip地址和子网掩码，设置虚拟接口以及设置其他各种选项和参数。ifconfig常常在系统引导时运行，从配置文件获得命令行参数，也可以通过手工执行来修改网络配置。
(2)格式：(需要root权限)
ifconfig[-v] [-a] [-s] [interface]
ifconfig [-v] interface [fimary] options | address ...
(3)ifup和ifdown:
ifup：用来打开指定的网络接口。
ifdown：用来关闭指定的网络接口。
例如：
sudo ifup eth0
sudo ifdown eth0
二 使用细则：
(1)网络接口配置和运行信息的显示：
*ifconfig：显示当前活动(active)网络接口的配置和运行信息。
*ifconfig interface：显示interface接口的配置和运行信息。(interface表示这一命令用于哪个网络接口上，通常表示是2或3个字符的设备名后跟一个数字，比如：eth0、eth1等，lo为linux上的环回接口)。
*ifconfig -a：显示所有网络接口的配置和运行信息，包括活动的和不活动的。
*ifconfig -s：和netstat -i，显示网络接口的简短信息。
如下图：
RX packets和TX packets报告各个接口从机器启动以来接受和发送的包的个数。
error：存放各种不同类型的错误，显示有个别错误是正常的。
collisions：给出包在发送期间遇到的冲突次数。
(2)参数family：
参数family告诉ifconfig命令要配置哪一种网络协议("地址簇")。在一个网络接口上可以配置多种网络协议，并同时使用它们，但是每种协议必须单独配置。这里的协议主要有两种选项：IPv4的inet和IPv6的inet6。
(3)参数address：
参数address：指定了接口的IP地址。这里也接受一个主机名作为地主参数，在系统引导时必须把这个主机名解析为一个IP地址。对于一个机器的主网络接口来说，这意味着这个主机名必须出现在本地的/etc/hosts文件中，因为其他解析主机名的方法都要依靠网络配通之后才可以用。
用法：ifconfig eth0 10.3.8.251
关键字up:启动网络接口。用法：ifconfig eth0 up
关键字down:停止网络接口。用法：ifconfig eth0 down
(4)虚拟接口：
一台机器可以在网络上对比它的物理网络接口更多的IP地址做出响应。
好处：可以把多个站点放在一台服务器机器上，节约成本等。
linux上虚拟接口按照interface:instance的方式命名。例如：以太网为eth0，那么与之相关联的虚拟接口就应该是eth0:0,eth0:1等。
命令如下：
$sudo ifconfig eth0:0 10.3.8.252 netmask 255.0.0.0 up #这个是临时有效，重新启动后就无效了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ec0a57dd962efa20464cddc3fa7b193/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b084c82a9e88f43104af9c63498c594/" rel="bookmark">
			字符串处理(六)atoi、atof、atol和atoll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述(使用时要包含&lt;stdlib.h&gt;文件，否则结果输出可能不正确)：
(1)atoi
功 能： 把字符串转换成整型数。
名字来源：ASCII to integer 的缩写。
原型： int atoi(const char *nptr);
函数说明: 参数nptr字符串，如果第一个非空格字符存在,并且，如果不是数字也不是正负号则返回零，否则开始做类型转换，之后检测到非数字(包括结束符 \0) 字符时停止转换，返回整型数。
*补充：itoa(int value，char *str，int radix)。
功能：把整型转化为字符串,value是要转换的值，str是目标字符串地址，radix是转换后的进制。
(2)atof
功 能: 把字符串转换成浮点数
用 法: double atof(const char *nptr);
(3)atol
功 能: 把字符串转换成长整型数
用 法: long atol(const char *nptr)
(4)atoll
功 能: 把字符串转换成长长整型数 用 法: long long atoll(const char *nptr);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b35e912ec09271004f2324c203f3235/" rel="bookmark">
			【Linux】linux常用基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中许多常用命令是必须掌握的，这里将我学linux入门时学的一些常用的基本命令分享给大家一下，希望可以帮助你们。
这个是我将鸟哥书上的进行了一下整理的，希望不要涉及到版权问题。
1、显示日期的指令： date 2、显示日历的指令：cal 3、简单好用的计算器：bc 怎么10/100会变成0呢？这是因为bc预设仅输出整数，如果要输出小数点下位数，那么就必须要执行 scale=number ，那个number就是小数点位数，例如：
4、重要的几个热键[Tab],[ctrl]-c, [ctrl]-d [Tab]按键---具有『命令补全』不『档案补齐』的功能
[Ctrl]-c按键---让当前的程序『停掉』
[Ctrl]-d按键---通常代表着：『键盘输入结束(End Of File, EOF 戒 End OfInput)』的意思；另外，他也可以用来取代exit
5、man 退出用q，
man -f man
6、数据同步写入磁盘： sync 输入sync，那举在内存中尚未被更新的数据，就会被写入硬盘中；所以，这个挃令在系统关机戒重新启劢乀前， 径重要喔！最好多执行几次！
7、惯用的关机指令：shutdown 此外，需要注意的是，时间参数请务必加入指令中，否则shutdown会自动跳到 run-level 1 (就是单人维护的登入情况)，这样就伤脑筋了！底下提供几个时间参数的例子吧：
重启，关机： reboot, halt,poweroff
8、切换执行等级： init Linux共有七种执行等级：
--run level 0 :关机
--run level 3 :纯文本模式
--run level 5 :含有图形接口模式
--run level 6 :重新启动
使用init这个指令来切换各模式：
如果你想要关机的话，除了上述的shutdown -h now以及poweroff之外，你也可以使用如下的指令来关机： 9、改变文件的所属群组：chgrp 10、改变文件拥有者：chown 他还可以顸便直接修改群组的名称
11、改变文件的权限：chmod 权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。
--数字类型改变档案权限：
--符号类型改变档案权限：
12、查看版本信息等 13、变换目录：cd 14、显示当前所在目录：pwd 15、建立新目录：mkdir 不建议常用-p这个选项，因为担心如果你打错字，那么目录名称就回变得乱七八糟的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b35e912ec09271004f2324c203f3235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417b4af2cef399d4431e0c74ccd83ebf/" rel="bookmark">
			设置默认VS2005的调试浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FF的由于我装了很多插件 启动相当慢 但是不知道怎么恢复用IE调试 今天才查了一下 才查到方法 1.随便找到一个aspx页面 右键 弹出的窗口如下: 2.选择"浏览方式..." 3.在弹出的对话框找到要设定的浏览器 "设定为默认值"就OK了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2443647659123e8772b61101a39dabd0/" rel="bookmark">
			最新颜色代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在弄布局颜色时候发现自己对颜色的定义差的无地自容所以特意找了颜色代码来记录。 #000000
#2F0000
#600030
#460046
#28004D
#272727
#4D0000
#820041
#5E005E
#3A006F
#3C3C3C
#600000
#9F0050
#750075
#4B0091
#4F4F4F
#750000
#BF0060
#930093
#5B00AE
#5B5B5B
#930000
#D9006C
#AE00AE
#6F00D2
#6C6C6C
#AE0000
#F00078
#D200D2
#8600FF
#7B7B7B
#CE0000
#FF0080
#E800E8
#921AFF
#8E8E8E
#EA0000
#FF359A
#FF00FF
#9F35FF
#9D9D9D
#FF0000
#FF60AF
#FF44FF
#B15BFF
#ADADAD
#FF2D2D
#FF79BC
#FF77FF
#BE77FF
#BEBEBE
#FF5151
#FF95CA
#FF8EFF
#CA8EFF
#d0d0d0
#ff7575
#ffaad5
#ffa6ff
#d3a4ff
#E0E0E0
#FF9797
#FFC1E0
#FFBFFF
#DCB5FF
#F0F0F0
#FFB5B5
#FFD9EC
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2443647659123e8772b61101a39dabd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def4c72cf040b2a2d06c3d33c3184cd8/" rel="bookmark">
			English learning-(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里记录一些英语方式的表达，以免在需要用到的时候可以拿来用，熟悉一些，也尽量不会让人家感觉到外行。
1. 在工作中，经常有时候跟老外打交道，当你准备远程call她（他），而这时对方正在忙其他事，不方便的时候，可以回答：
a、it's OK/it's all right, go ahead please/ please take your time/ See your later / I'll call your back later. 2. 由于经常会跟老外打交道，而你们又是一个团队的，需要经常邮件来往，一封写得好的，比较地道的邮件会产生不同的效果。
邮件的格式：
Hi, xxx:
Focusing on the *** problem, I found that ****(这里描述问题的现象，原因)
Best wishes.
Shows
3. 如果对方call你，而你在忙，可以先告知对方你正在忙（开会，或者其他）就可以啦，一般对方会理解：
I am in a meeting now
如果开完会了，你可以继续说：yes, I am here
这样就可以提醒对方，你现在已经有时间啦。
4. 场景，问题汇报
产品开发过程中发现问题是一件很正常的事情，如果问题出现，那么你需要把问题汇报给上级，这里要描述清楚现象，原因，解决方案可以暂时不提。
Focusing on the problem of SpO2 module,it happens whenever I put my finger into the sensor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/def4c72cf040b2a2d06c3d33c3184cd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc917791379d54ea7fcfc20b48722e3c/" rel="bookmark">
			setuid  seteuid  setreuid 三个函数讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int setuid(uid_t uid)
1) 若进程具有超级用户权限，则setuid将实际用户ID、有效用户ID及保存的设置用户ID设置为uid
2) 若进程没有超级用户权限，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid
int seteuid(uid_t uid)
1) 若进程具有超级用户权限，则setuid只将有效用户ID设置为uid
2) 若进程没有超级用户权限，则setuid只将有效用户ID设置为uid, 但是uid必须等于实际用户ID或保存的设置用户ID，
int setreuid(uid_t ruid, uid_t euid)
1) 针对设置用户ID位的程序: 交换有效用户ID和保存的设置用户ID
2) 针对没有设置用户ID位的程序: 交换有效用户ID和实际用户ID
函数作用效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/233948557d0d33aa6c5da5fcee31d8d6/" rel="bookmark">
			Eclipse如何自建目录发布到WEB-INF/classes目录下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为项目文件更加清晰，我们习惯用目录来存放。
但新建目录eclipse不
现在有一个目录结构
src
config
-hibernate 存放hibernate配置文件
-spring 存放spring配置文件
-struts2 存放struts2相关文件
WebRoot
如何使config目录下的文件自动发布到WEB-INF/classes下呢？
在Package Explorer 下，选择config目录，点右键菜单。选择Build Path/Use as Source Folder。可以看到图标发生变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e04361341d96fca787aea6f2f8a3cf/" rel="bookmark">
			pyqt 使用 Qt Designer 设计的ui文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt的一个强大之后便是可以直观地使用 qt designer 设计界面，pyqt也可以使用这个ui文件，大大简化了ui的设计时间。
使用方法：
如果没有使用eric一类的IDE，那么可以使用命令行的方式将ui文件转化成.py文件，pyqt是自带pyuic.py这个工具的。
首先，必须在给python安装了pyqt，安装方法见http://blog.csdn.net/lainegates/article/details/8656102
然后，使用Qt Designer设计好ui文件，保存为form.ui，假设路径为D:/
最后，打开cmd，进入pyqt的uic目录，我的是C:\Python26\Lib\site-packages\PyQt4\uic，输入 "python pyuic.py -o D:/ui_form.py D:/form.ui"，然后就会在form.ui所在目录生成它对应的.py文件了。
测试载入UI文件：
class UItest(QtGui.QMainWindow): def __init__(self,parent=None): QtGui.QWidget.__init__(self,parent) self.loginGui() def loginGui(self): self.ui = Ui_Dialog() self.ui.setupUi(self) self.show() app = QtGui.QApplication(sys.argv) myqq = UItest() sys.exit(app.exec_()) pyuic参数说明： NAME pyuic4 - compile Qt4 user interfaces to Python code SYNOPSIS pyuic4 [OPTION]... FILE DESCRIPTION pyuic4 takes a Qt4 user interface description file and compiles it to Python code. It can also show a preview of the user interface.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e04361341d96fca787aea6f2f8a3cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e24ea0ddfd5414adde1183e4cf677382/" rel="bookmark">
			pyQt4 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt是c++库，在python中使用这个库就必须要有接口，使用python能够调用C++代码，qt官方选择了sip这个python与qt的接口库。
在pyqt的官网上，http://www.riverbankcomputing.co.uk/software/pyqt/download/
可以找到sip下载链接：http://www.riverbankcomputing.co.uk/software/sip/download
现在安装pyqt4：
1.安装python，我使用的是python-2.6.6.msi
2.安装sip，我下载到的是sip-4.14.4.zip。我将sip解压到了python的目录下，C:\Python26\Lib\site-packages
3.安装pyqt4，由于有现成的安装包，所以很简单，在官网下载到最新版PyQt4-4.10-gpl-Py2.6-Qt4.8.4-x32.exe，一路next，安装完成。
最后测试下：
Python shell中输入：
import sys from PyQt4.QtGui import * a = QApplication(sys.argv) w = QWidget() w.resize(320, 240) w.setWindowTitle("Hello, World!") w.show() sys.exit(a.exec_()) 能正常运行，就说pyqt4安装完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9609c405a1d523e561aaa51639f7b9/" rel="bookmark">
			傅里叶三角级数和复数表示的级数之间的转变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在opencv中提供了一个函数叫cvDFT，这个函数可以将一系列数值进行傅里叶变换，它可以进行正变换，也可以进行逆变换。假如一个数组的长度是64，在进行正向傅里叶变换后的形式为
其中Re代表实部，Im代表虚部。这样实际的大小减少了一半。
这种转后是用复数的形式表示的，也就是
但是实际情况中我需要用的是三角级数的表示方法，得到相关的三角级数的系数，三角级数的系数表示方法我们在高等数学里面已经学过，其表达式如下：
那么复数形式表示的系数和三角级数表示的系数之间有什么对应关系么？这就是我想得到的答案，在老师的帮助下终于得到如下结论，三角级数中的an表示复数形式的实部，bn表示虚部。
推导的借助以下下PPT的内容：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c97073b6dc0e113fb5668590f10b854/" rel="bookmark">
			人偶师(Gauss消元xor版-多解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem 2 人偶师(alice.cpp/c/pas)
【题目描述】
n点m双向边的图，每个点有2个状态：开和关。每次操作改变一个点的状态，以及与其有边直接相连的点的状态。问开启所有点至少需要多少次操作。
【输入格式】
第一行2个整数n,m。
第二行n个整数，第i个数表示第i点的状态，0为关，1为开。
第3..m+2行，每行2个整数a,b，表示a和b直接相连，同一条边不会出现多次。
【输出格式】
第一行一个整数k表示最少的操作次数，所有数据保证至少有一组可行解。
第二行k个整数，表示操作的点的编号。
【样例输入】
4 3
1 1 0 0
2 3
1 3
2 4
【样例输出】
3
1 2 3
【数据范围】
对于30%的数据，1&lt;=n&lt;=10，0&lt;=m&lt;=40
对于60%的数据，1&lt;=n&lt;=30，0&lt;=m&lt;=100
对于100%的数据，1&lt;=n&lt;=40，0&lt;=m&lt;=500
这题还是高斯消元xor.
不同的是要考虑多解. 高斯消元多解考虑方法：
Gauss();
dfs(n,1)//把值往回代
如果遇到a[i][i]==0,则分情况dfs.
这样做的好处是O(2^n) 如果求出所有情况再往回代就是O(n^2*2^n) #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;functional&gt; #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; using namespace std; #define MAXN (40+2) #define MAXM (500+10) int a[MAXN][MAXN]; int ans[MAXN],tot=MAXN,tot2=0,ans2[MAXN]; int n,m; /* void print(int a[MAXN][MAXN],int _n) { for (int i=1;i&lt;=_n;i++) { for (int j=1;j&lt;=n+1;j++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c97073b6dc0e113fb5668590f10b854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874cb7ab8cfd1bcb33830d61cdd0e743/" rel="bookmark">
			一个例子全部说明java泛型中的K,V,T,E,?,object的意思及其用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.意思 jdk中的K,V,T,E等泛型名称很多人以为是固定写法，其实这些名称是可以改的，比如改成zhangsan,lisi都可以，jdk为了容易看懂，所以用K表示键，V表示值，T表示type类型，E表示enum枚举，其实这四个都只是符号，都是表示泛型名称,下面的例子的T全部可以换成E，也可以换成K,V,zhangsan，都没关系。 ? 表示不确定的类型 Object java中所有类的父类。 2.使用方法 Java代码 import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; //T1,T2都是随便定义的东西，注意1:他们不会关联到其他类，只是在本类中通用，只是告诉我们new的时候要加入泛型 public class Test&lt;T1, T2&gt; { public static void main(String[] args) { System.out.println(new Test().getaa()); new Test&lt;String, String&gt; ().getbb(""); new Test().getcc(Test.class); //注意下6:面这个HashMap的括号里面不能是T,E,T1,T2等不确定的东西,但可以是? HashMap&lt;Object, String&gt; map = new HashMap&lt;Object, String&gt;(); List&lt;?&gt; list = new ArrayList&lt;String&gt;(); } T2 getaa() { //注意2:T2将自动转型为String,这个不需要去担心 return (T2) "few"; } public &lt;T&gt; void getbb(T x) { //注意3:Class&lt;T&gt;前面缺少&lt;T&gt;将编译错误 System.out.println(x.getClass().getName()); } public &lt;T&gt; Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/874cb7ab8cfd1bcb33830d61cdd0e743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37201cf2b0a09d1b533c98f42fade54c/" rel="bookmark">
			apache出事啦   tfy      struts2的错误处理机制的缺点：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 struts2的错误处理机制的缺点： * 如果要在action中的方法进行错误处理，有多少方法写多少try catch * 如果在action中抛出异常，程序员是不能干预异常的处理的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee029f4c531b68cce47563409014451/" rel="bookmark">
			linux 中root默认密码不知道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 请先用该建立的第一个用户登入，使用 sudo passwd root 即可修改 root 密码. ps: 若要输入密码，该密码就是执行 sudo 该用户的密码。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b23129ff703f701745181101e88bbf71/" rel="bookmark">
			根据安装好的第一个linux虚拟机节点怎么创建相同的第二和第三个虚拟机节点...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为学习hadoop需要创建多个虚拟节点，在安装好第一个linux虚拟节点后，我们需要找到节点的文件夹。例如我的文件夹在E:\My Virtual Machines 中的Ubuntu文件夹。
然后我们在关闭虚拟机的前提下复制Ubuntu文件夹，打开虚拟机在复制的文件夹中找到Ubuntu.vmdk这个文件，双击打开然后再虚拟机种选择 Ｉｃｏｐｉｄｅ。。。
至此相同的虚拟节点创建成功。然后再修改名称等工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b244eaa81003d97c4decc94c238e153/" rel="bookmark">
			java多线程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java多线程总结 以前没有写笔记的习惯，现在慢慢的发现及时总结是多么的重要了，呵呵。虽然才大二，但是也快要毕业了，要加油了。
这一篇文章主要关于java多线程，主要还是以例子来驱动的。因为讲解多线程的书籍和文章已经很多了，所以我也不好意思多说，呵呵、大家可以去参考一些那些书籍。我这个文章主要关于实际的一些问题。同时也算是我以后复习的资料吧，。呵呵大家多多指教。
同时希望多结交一些技术上的朋友。谢谢。
----------------------------------------------------------------------------------------------------------------------------------------------------
java中的多线程
在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口。
对于直接继承Thread的类来说，代码大致框架是：
? 1 2 3 4 5 6 7 8 9 10 11 12 class 类名 extends Thread{ 方法 1 ; 方法 2 ； … public void run(){ // other code… } 属性 1 ； 属性 2 ； … } 先看一个简单的例子：
? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * @author Rollen-Holt 继承Thread类,直接调用run方法 * */ class hello extends Thread { public hello() { } public hello(String name) { this .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b244eaa81003d97c4decc94c238e153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ca1a84ec26007ceaf225403aea9393/" rel="bookmark">
			centos普通用户登录提示鉴定故障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上次设了定时关机，时间每到强制关机，
今天打开电脑登录提示鉴定故障，系统5分钟后关机，但是root可以登录，网上搜索说是密码错了，肯定不是。新建账户也出现同样的问题
解决方法居然是：重启电脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f006d00ae2df0c7ea87f30375715860f/" rel="bookmark">
			11gr2 新特性之：Oracle Flashback Data Archive（FDA） -（total recall）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Oracle 11g里又出了一个新特性：Oracle FlashbackData Archive（FDA）. 在11g的官方文档里搜到了相关内容说明，参考：
Using Oracle Flashback Technology
--Using Flashback Data Archive (Oracle Total Recall)
http://download.oracle.com/docs/cd/E11882_01/appdev.112/e17125/adfns_flashback.htm#BJFIEJGG
一. Flashback Data Archive 说明
官网的定义如下：
A Flashback Data Archive provides the ability to track and store transactional changes to atable over its lifetime. A Flashback Data Archive is useful for compliance with record stage policies and audit reports.
--Flashback Data Archive 在它的有效期内将保存事务改变的信息。
A Flashback Data Archive consists of one or more tablespaces or parts thereof.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f006d00ae2df0c7ea87f30375715860f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f8061ed53c4f6a405fd2b62f22105f/" rel="bookmark">
			搭建OpenWrt开发环境（包括编译过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【转】搭建OpenWrt开发环境（包括编译过程） OpenWrt是一个高度模块化、高度自动化的嵌入式linux发行版，其编译和安装过程比普通的linux发行版而言，要简单太多了。如果您是新手，您那恐惧的心大可放到肚子里，呵呵。对于新手来说最麻烦的恐怕是安装开发环境需要的软件了。
最基本条件：
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1.PC一台，性能强点，性能好编译得就快。linux推荐安装ubuntu 8.04中文版（或者suse）和fedora 11（对于初学者而言，最好是装在虚拟机如VM里，可省去很多麻烦。如何在VM里安装linux，您可多google或者baidu） 2.宽带一条，需要速度好点，因为有很多软件包是网络下载后安装。 3.耐心和时间。
编译环境准备（安装linux发行版和软件包）：
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1.安装好ubuntu8.04中文版本或者fedora 9或者11，搞定网络连接。
以非root用户登陆，打开“应用程序—-附件—-终端”。如果您已经安装好linux, 那么此步骤请略去。
2.如果您选择ubuntu, 那么ubuntu开发环境需要的软件有sudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip sharutils subversion libncurses5-dev ncurses-term zlib1g-dev
然后
sudo apt-get update
如您选择安装fedora11或者fedora9
Fedora 11 or 9: # yum install autoconf binutils bison bzip2 flex gawk gcc gcc-c++ gettext make ncurses-devel patch unzip wget zlib-devel 由于fedora 安装包本来就很全面，所以需另外安装的东西较少。所以一般情况下，推荐安装fedora 11。对于初学者而言，最方便的方法是在VM上安装linux。
由于ubuntu本来就是基于suse， 所以如果您要以suse为开发环境，那么您参考ubuntu的安装步骤即可。
如果你能阅读英文，那么请参考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f8061ed53c4f6a405fd2b62f22105f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6a354d0c2269db62019a3549676fc9/" rel="bookmark">
			金融信息交换协议(FIX)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网络的使用，目前所有大型的金融机构都已经实现了自动化和数字化。当中肯定少不了互联网的加入，那么在这当中，我们主要介绍一下FIX协议。它是由国际FIX协会组织提供的一个开放式协议，目的是推动国际贸易电子化的进程，在各类参与者之间，包括投资经理、经纪人，买方、卖方建立起实时的电子化通讯协议。Fix协议的目标是把各类证券金融业务需求流程格式化，使之成为一个个可用计算机语言描述的功能流程，并在每个业务功能接口上统一交换格式，方便各个功能模块的连接。
FIX协议结构
当前,FIX协议的格式存在着两种结构:"标记（Tag）〉=〈值（Value）"域结构和 FIXML 结构。下面针对域结构模式对FIX协议的组成，连接建立、信息交换方法等进行简要说明，以便于了解FIX协议的概念。
FIX信息格式
(1) 信息格式
一条FIX协议信息的基本格式是：
《标准头》+《信息正文域》+《标准尾》
每条信息都是由一系列带有〈标记（Tag）〉=〈值（Value）〉的域组成的。在每个域之间通过"&lt; &gt;"分开。除了一些特殊规定外，信息中的域可按照任意顺序排列。所有域在都以"定界符"（#001；0x01H,文档中写为&lt;SOH&gt;）表示终止。
(2) 标准的信息标题
每条命令或应用信息都有一个标准的标题。标题表明了信息类型、长席、目的地、序号、起始点和时间。
(3) 标准的信息尾部
所有的信息，无论是命令类的，还是应用类的，以一个标准结尾终止。尾部被用来把信息分离，并包括含有3位数的"检验和"值。
(4) 数据类型
各域所使用的数据类型包括以下几种：整数、浮点数、布尔数、字符串、多元值串、货币、交易所字符串域、国际标准时时间戳、国际标准时时间、本地市场日期等。
(5) 数据完整性
信息数据内容是否完整可以通过"检查信息长度"和字符的简单"检验和"两个方法进行检查。
(6) 加密
为了保证信息安全，对传递的信息需要加密，加密方法的选择由传送中的有关双方协议而定。任何域都可被加密并被添加于"密码"的域内，不过，被确信可被清楚识别的域必须以非加密方式进行传送，这些公开的域（非加密）能在密码的域内被重复以完整地检验公开的数据。
FIX协议的连接建立
建立一个FIX连接包括：电信层面连接的创立、经由接收方对发起方的确认、信息同步三个步骤。
FIX信息交换过程的实施
FIX信息交换过程的定义为：
在两方之间，一个连续的序号系列范围内的双向定单信息传送。每条信息都有独特的序号识别。在每次FIX交换过程开始时，就是序号的开始，首先从1开始，并依次增加直至贯穿整个交换过程。当在FIX交换过程中重新进行连接的时候，监控序号将能使各方能识别错过的信息，并能做出反应，来使应用方达到一致地同步。
在整个信息没有被激活的时期里，信息交换方将在有规则的时间间隔里产生"心跳信息"。通过"心跳信息"可监控通信连接的状况，识别进入的序号缺口，并确认是否接收到最后的信息串。"心跳间隔"是由交换过程发起人使用"心跳指令"域在"登录"信息中宣布的。
当信息交换连接的任何一方在"心跳指令"的时间内都不发送任何数据的时候,"心跳信息"将被传送。当连接的任何一方在"心跳指令"+"合理的传输时间"的时间内仍没有收到"心跳信息"，那么，可以认为此次连接失败，而且需开始实施修正操作。如果"心跳指令"被设置为零，将不会生成定期的"心跳信息"。
FIX的连接注销
信息交换过程的正常结束是通过双方互相发送"注销"（Logout）信息来完成。"注销"信息是开始或确认一个FIX过程终止的信息，未经"注销"信息的交换而断开的连接是反常情况，并应按错误来处理。
FIX通信协议的应用
针对国内的证券交易模式的分布式结构，即证券公司的各营业部、分支机构数据分布存放，各自独立，直接与交易所联系，国内券商正在探讨并逐步推出集中交易系统,集中交易系统可以带来集中风险控制、提高系统效率等优势，可以在集中交易系统的构建、规划过程中，借鉴应用FIX标准化协议，构建具有数据层、核心业务层+FIX通信层、应用层的广义三层结构。用FIX金融信息交换协议包取代过去的文件或通信包交换的模式。
在FIX协议的应用过程中应该注意到，由于亚洲地区的证券交易方式与FIX协议的主导地区美洲和欧洲国家有一定的差异，因此直接利用现有的FIX协议，特别是证券业务流程上的规范有一定的困难。
例如FIX协议在日本证券行业的应用就遇到了信息定义内容和信息流程顺序上的问题。因此国内的FIX的开展首先要关注FIX及其在中国的适用性，吸收其它市场的经验，将国内外不同的交易程序加以比较，分析协议的使用方法以及协议使用环境，结合国内证券市场的实际，使得该项协议既能成为一项标准又能为中国证券市场服务，为中国证券交易的标准化过程中发挥作用。
1 简介 FIX会话协议与选择用于电子数据传递的物理介质（铜缆，光纤，卫星传输等）及传输协议规范（X.25，同步，TCP/IP等）无关。它提供了一个消息传递的可靠数据流。直到2006年10月，FIX会话协议与FIX应用协议一道，为用户提供了一个可靠的传输FIX应用消息的传输机制。 FIX会话层与数据传输相关，而FIX应用层则定义了商业相关的数据内容。 2006年10月，FPL’s Global Techenical Committee 引入了一个新的框架，将FIX会话层协议从FIX应用层协议分离开来。这就使应用协议消息可以使用任何适的会话传输技术进行传送，而FIX会话层协议是这些可选的协议中的一个。在新的框架下，GTC引入了一个新的别名，之后FIX会话层协议版本为FIXT.x.y，第一个版本为FIXT1.1。 2 FIXML及其它基于XML数据的传输 尽管FIX会话协议的标准头（Standard Header），标准尾部（Standard Trailer）和管理消息是基于“tag=value”语法的，但它能够支持传输FIXML及其它基于XML的数据。FIXML及其它XML数据被夹在FIX标准头与FIX标准尾部中间，并通过标准头的XmlDataLen域指定其内容长度，XmlData域包含其具体的数据。这样，FIX引擎可以通过多年使用的，可靠的，实时地异步传输机制传送FIXML及其它XML数据。当MsgType域值为’n’时，代表传输的数据为FIX未在MsgType中定义的XML数据。 3 FIX消息传送 3.1 Sequence Numbers 序列编号 所有的FIX消息都由一个唯一的序列号进行标示。序列号在每一个FIX会话开始时被初始化为1，并在整个会话期间递增。监控序列号可以使会话参与者识别和处理丢失的消息，当在一个FIX会话中重新连接时能够优雅地进行应用程序同步。 每个会话将建立一组互不依赖的接受和发送序列。会话参与者将维护一个赋予发送消息的序列和一个监控接受消息的消息块间隙序列号。 3.2 Heartbeats 心跳信号 在消息交互期间，FIX应用程序将周期性产生Heartbeat心跳消息。该心跳消息可以监控通信链路状态及识别接受序列号间隙。发送Heartbeat的周期间隔由会话发起者使用在Logon消息中HeartBtInt域进行定义。Heartbeat心跳消息的时间间隔应当在每一个消息发送后复位，即发送一个消息后，在间隔给定的时间内无其它消息发送则发送一个Heartbeat心跳消息。HeartBtInt的值应当被会话双方认同，由会话发起方定义并由会话接收者通过Logon消息进行确认。同一个HeartBtInt被会话双方——登录的发起者和登录的接受者共同使用。 3.3 Ordered Message Processing 消息序列处理 FIX协议假设消息在所有参与者间完全按照顺序进行传输。协议的实现者在设计消息间隙填充处理时应当考虑这个假设。有两种方式处理消息间隙。每一个都要求所有的消息时最后一个接收消息的后续消息或在维护一个所有新消息有序序列时，请求特定丢失消息。比如：接收方丢失了5个消息块中的第二个，程序能忽略第3到第5个消息，产生一个对消息2到消息5的重传请求，或者从消息2到无穷大消息编号的重传请求。另外的方式是暂时存储消息3到消息5，仅要求重传消息2。对于这两种方式，消息3到消息5都不应该先于消息2进行处理。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d6a354d0c2269db62019a3549676fc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4adc86f51d30b012f0e194a718b2a9d/" rel="bookmark">
			【男人必看十大经典】[经典合集][DVD-Rmvb/7.70GB] 【原音中文字幕】已测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【男人必看十大经典】[经典合集][DVD-Rmvb/7.70GB] 【原音中文字幕】已测 【男人必看十大经典】[经典合集][DVD-Rmvb/7.70GB] 【原音中文字幕】已测 - 『资源高速下载区』 圣城家园BT下载 720P 1080P高清电影下载|高清播放机|中英字幕|迅雷下载|高清电影|MV|APE音乐|游戏|最新电影大片下载
[欧美电影]
【男人必看十大经典】[经典合集][DVD-Rmvb/7.70GB] 【原音中文字幕】已测
posted on 2013-02-10 09:16 lexus 阅读( ...) 评论( ...) 编辑 收藏 转载于:https://www.cnblogs.com/lexus/archive/2013/02/10/2909725.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b75dca5c8266e6d0192476874a2c82/" rel="bookmark">
			JS window.open() 用法与参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言:经常上网的朋友可能会到过这样一些网站，一进入首页立刻会弹出一个窗口，或者按一个连接或按钮弹出，通常在这个窗口里会显示一些注意事项、版权信息 、警告、欢迎光顾之类的话或者作者想要特别提示的信息。其实制作这样的页面效果非常的容易，只要往该页面的HTML里加入几段Javascript代码即可实现。下面我就带您剖析它的奥秘。 【1、最基本的弹出窗口代码】 &lt;SCRIPT LANGUAGE="javascript"&gt; &lt;!-- window.open ('page.html') --&gt; &lt;/SCRIPT&gt; 因为着是一段javascripts代码，所以它们应该放在&lt;SCRIPT LANGUAGE="javascript"&gt;标签和&lt;/script&gt;之间。&lt;!-- 和 --&gt;是对一些版本低的浏览器起作用，在这些老浏览器中不会将标签中的代码作为文本显示出来。要养成这个好习惯啊。window.open ('page.html') 用于控制弹出新的窗口page.html，如果page.html不与主窗口在同一路径下，前面应写明路径，绝对路径(http://)和相对路径(../)均可。用单引号和双引号都可以，只是不要混用。这一段代码可以加入HTML的任意位置，&lt;head&gt;和&lt;/head&gt;之间可以，&lt;body&gt;间&lt;/body&gt;也可以，越前越早执行，尤其是页面代码长，又想使页面早点弹出就尽量往前放。 【2、经过设置后的弹出窗口】
下面再说一说弹出窗口的设置。只要再往上面的代码中加一点东西就可以了。 我们来定制这个弹出的窗口的外观，尺寸大小，弹出的位置以适应该页面的具体情况。
&lt;SCRIPT LANGUAGE="javascript"&gt; &lt;!-- window.open ('page.html', 'newwindow', 'height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no,location=n o, status=no') //这句要写成一行
--&gt; &lt;/SCRIPT&gt; 参数解释： &lt;SCRIPT LANGUAGE="javascript"&gt; js脚本开始； window.open 弹出新窗口的命令； 'page.html' 弹出窗口的文件名； 'newwindow' 弹出窗口的名字（不是文件名），非必须，可用空''代替； height=100 窗口高度； width=400 窗口宽度； top=0 窗口距离屏幕上方的象素值； left=0 窗口距离屏幕左侧的象素值； toolbar=no 是否显示工具栏，yes为显示； menubar，scrollbars 表示菜单栏和滚动栏。 resizable=no 是否允许改变窗口大小，yes为允许； location=no 是否显示地址栏，yes为允许； status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许； &lt;/SCRIPT&gt; js脚本结束
【3、用函数控制弹出窗口】 下面是一个完整的代码。 &lt;html&gt; &lt;head&gt; &lt;script LANGUAGE="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1b75dca5c8266e6d0192476874a2c82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c245cdaea16fad328c0fd0e558201a02/" rel="bookmark">
			Hibernate的查询与更新技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．Criteria 我的理解：Criteria就是Hibernate生成的一个由根据一定约束条件查询session或数据库而得到的结果的List和一些添加约束条件的方法所组成的对象。 （1）.创建criteria：Criteria crit = session.createCriteria(MyMessage.class)àList&lt;MyMessage&gt;对象 （2）.设置结果集最大个数：crit.setMaxResults(2) （3）.查询、得到结果集：List&lt;MyMessage&gt; messages = crit.list()，list函数执行带有条件的对Criteria对象集合的查询。 注意：如果不使用crit.uniqueResult()，Criteria.list()返回的就是一个List&lt;Object[]&gt; （4）.添加约束： Criteria.add(Criterion的实现类)； 原理：org.hibernate.criterion.Restrictions利用其静态方法创建单个或多个（or、and）约束条件的组合形成SimpleExpression对象，再有Criteria的add方法添加到Criteria对象，最后有list方法执行条件查询返回查询结果。 org.hibernate.criterion.Restrictions静态方法如下： 1） 单个约束： SimpleExpression extends Criterion; public static SimpleExpression ne(String propertyName,Object value); //!= public static SimpleExpression lt(String propertyName,Object value); //&lt; public static SimpleExpression gt(String propertyName,Object value); //&gt; public static SimpleExpression le(String propertyName,Object value); //&lt;= public static SimpleExpression ge(String propertyName,Object value); //&gt;= public static SimpleExpression like(String propertyName,Object value); //like //说明：此处的value有4种情况：“%subString”、“subString%”、“%subString%”、“subString” public static SimpleExpression like(String propertyName,Object subString, MatchMode); //like //说明：subString表示匹配字符串，MatchMode也有4个常量值： MatchMode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c245cdaea16fad328c0fd0e558201a02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43b1f2fc9bb0ca1249c113fae3949cf/" rel="bookmark">
			Hibernate HQL基础 限定查询条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创作品，允许转载，转载时请务必以超链接形式标明文章 原始出处 、作者信息和本声明。否则将追究法律责任。 http://wujuxiang.blog.51cto.com/2250829/403701 在HQL中可以使用表达式完成指定的运算或者作为限制查询结果的条件。如下表所示 |-----------------------------------------------------------| | 类别 | 运算符 | |---------------------------|-------------------------------| |逻辑运算符 |or、and及not | |---------------------------|-------------------------------| |数学运算符 |+、-、*、/ | |---------------------------|-------------------------------| | |=、&lt;&gt;、!=、&lt;、&gt;、&lt;=、&gt;=、like、| | |not like、between、not between | |比较运算符 |in、not in、is null、 | | |is not null、is empty、 | | |is not empty、member of、 | | |not member of | |---------------------------|-------------------------------| |字符串连接 | || | |---------------------------|-------------------------------| |分支选择 |case及case...when...then...else| | |....end | |---------------------------|-------------------------------| |集合运算 |some、exists、all、any | |---------------------------|-------------------------------| 1、where子句 在HQL中使用where子句来限定查询条件，该子句后跟表示限定查询条件的表达式。如： Query query = session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c43b1f2fc9bb0ca1249c113fae3949cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120f5bc7b1a3d5fa4a15a4185a92fd01/" rel="bookmark">
			linux下并行计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高性能并行计算所处理的问题具有程序规模庞大、编写困难、计算量大、运行时间长，以及数据量巨大等特点，因此选择一个好的并行计算平台和并行编程工具非常重要。Linux是一个非常优秀的操作系统，其上的MPI和PVM是目前最流行的并行编程语言。本文将介绍如何借助Linux来构建并行计算系统，以及如何在Linux平台下开发MPI和PVM并行程序。 并行计算环境 并行计算是提高计算机系统计算速度和处理能力的一种有效手段。它的基本思想是用多个处理器来协同求解同一问题，即将被求解的问题分解成若干个部分，各部分均由一个独立的处理机来并行计算。并行计算系统既可以是专门设计的、含有多个处理器的超级计算机，也可以是以某种方式互连的若干台独立计算机构成的集群。 并行计算基于一个简单的想法：n台计算机应该能够提供n倍的计算能力，不论当前计算机的速度如何，都可以期望被求解的问题将在1/n的时间内完成。显然这只是一个理想的情况，因为被求解的问题在通常情况下都不可能被分解为完全独立的各个部分，而是需要进行必要的数据交换和同步。尽管如此，并行计算仍然可以使整个计算机系统的性能得到实质性的改进，而改进的程度取决于欲求解问题自身的并行程度。 并行计算的优点是具有巨大的数值计算和数据处理能力，能够被广泛地应用于国民经济、国防建设和科技发展中具有深远影响的重大课题，如石油勘探、地震预测和预报、气候模拟和大范围天气预报、新型武器设计、核武器系统的研究模拟、航空航天飞行器、卫星图像处理、天体和地球科学、实时电影动画系统及虚拟现实系统等等。 目前，并行计算已经成为计算机科学研究和应用中的热点，各种并行计算系统层出不穷，其中发展最快的当数基于Linux平台的并行计算环境。使用Linux来构建并行计算平台具有许多优点： ◆ 廉价　Linux最大的优势就是价格，通常只需少量的软、硬件投资就可以拥有一个PC工作站或服务器。相比之下，Linux对硬件的要求比Windows要低得多，即使是普通用户也可以利用Linux来构建一个高性能的并行计算环境，从而替代以往开销昂贵的大型计算机。 ◆ 开放　自由和开放是Linux最吸引人的特点，同时也为提高并行系统的性能提供了更加广阔的空间。开发者可以很容易地深入到系统的核心，从而使在操作系统一级提高性能成为可能。 ◆ 高效　在相同软硬件配置情况下，Linux与其他操作系统相比具有更高的效率，尤其是网络性能和稳定性，而这些正是衡量并行计算平台优劣的关键所在。 并行编程模型 为了简化并行程序的设计，需要采用合适的并行编程模型。目前两种最重要的并行编程模型是数据并行和消息传递。数据并行编程模型的编程级别较高，编程相对简单，但只适用于解决数据并行问题；消息传递编程模型的编程级别较低，编程相对复杂，但却有着更加广泛的应用范围。 数据并行指的是将相同的操作同时作用于不同的数据，从而提高问题求解速度。数据并行很早就被应用于向量计算机。长期的实践表明数据并行可以高效地解决大部分科学与工程计算问题。数据并行模型是一种较高层次上的并行计算模型，它提供给程序员一个全局的地址空间。通常这类模型所采用的语言本身就提供有并行执行的语义，因而程序员只需要简单地指明执行什么样的并行操作和并行操作的对象，就实现了数据并行的编程。例如，对于矩阵运算，要使矩阵B和矩阵C中的对应元素相加后赋给矩阵A，则通过语句： A = B + C 这样就能够完成相应的功能。正因如此，数据并行的表达是相当简单和简洁的，它不需要程序员关心并行系统是如何对该操作进行并行处理的。 数据并行模型虽然可以解决许多科学与工程计算问题，但对于非数值计算类问题，如果仍通过数据并行的方式来进行，则难以取得较高的效率。目前，数据并行模型面临的主要问题是如何实现高效的编译。只有具备了高效的编译器后，数据并行程序才可以在共享内存和分布式内存的并行计算机上取得高效率，才可能提高并行程序设计的效率和可移植性，从而进一步推广数据并行程序设计技术。 在消息传递模型中，各个并行执行的任务之间通过传递消息来交换信息、协调步伐、控制执行。消息传递一般是基于分布式内存的，但同样也适应于共享内存的并行计算机。消息传递模型为程序员提供了更加灵活的控制手段和表达形式，一些用数据并行模型很难表达的并行算法，采用消息传递模型则可以很容易地实现。机动灵活和控制手段的多样化，是消息传递模型能提供很高执行效率的重要原因。 消息传递模型为程序员提供了尽可能大的灵活性，但同时也将各个并行任务之间复杂的信息交换及协调控制交给了程序员，从而在一定程度上加重了程序员的负担。尽管如此，消息传递模型的基本通信模式仍然是简单和清楚的，目前大量并行程序采用的都是消息传递并行编程模型。
并行编程语言 由于消息传递并行编程模型的广泛应用，目前已经出现了许多基于该模型的并行编程语言，其中最流行的是PVM（Parallel Virtual Machine）和MPI（Message Process Interface）。第一个将工作站集群作为并行计算平台并被广泛接受的并行编程语言是PVM。它由美国的Oak Ridge国家实验室、Tennessean大学、Emorg大学、CMU大学等联合开发而成，能够将异构的Unix计算机通过异构网络连接成一个“虚拟”的并行计算系统，为其上运行的应用程序提供分布式并行计算环境。 PVM是一种基于局域网的并行计算环境。它通过将多个异构的计算机有机地组织起来，形成一个易于管理、易于编程、并且具有很好的可扩展性的并行计算环境。目前PVM支持C和Fortran语言。程序员首先参照消息传递模型编写好并行程序，然后将编译后的程序以任务为单位在网络中特定类型的计算机上运行。PVM能够在虚拟机中自动加载任务并运行，并且还提供了任务间相互通信和同步的手段。由于所有的计算任务都被分配到合适的计算节点上，多个节点并行运算，从而实现了任务一级的并行。
PVM为利用现有计算资源进行并行程序的开发与研究提供了一种有效的解决方案。由于PVM免费、开放和易于使用的特性，使得它成为一个被广泛接受的并行程序开发环境，目前几乎所有的并行计算系统都支持PVM。 MPI是为开发基于消息传递模型的并行程序而制定的工业标准，其目的是为了提高并行程序的可移植性和易用性。参与MPI标准制定的人员来自欧美40多个组织，大部分主要的并行计算机制造商、大学研究所、政府实验室、工业组织等都投入到MPI标准化工作。有了统一的并行编程语言标准，并行计算环境下的应用软件及软件工具就都能够实现透明的移植，各个厂商就可以依据标准提供独具特色和优势的软件实现和软件支持，从而提高了并行处理的能力。 MPI是一种基于消息传递模型的并行编程接口，目前已经发展成为消息传递模型的代表和事实上的工业标准，而不是一门具体的语言。迄今为止，所有的并行计算机制造商都提供对MPI的支持，因而从理论上说任何一个正确的MPI程序可以不加修改地在所有并行计算机上运行。 MPI只是一个并行编程语言标准，要编写基于MPI的并行程序，还必须借助某一MPI具体实现。MPICH是Linux平台下最重要的一种MPI实现，是一个与MPI规范同步发展的版本。每当MPI标准推出新的版本时，MPICH就会有相应的实现版本。LAM（Local Area Multicomputer）是Linux平台下另一免费的MPI实现。它由Ohio州立大学开发，主要用于异构的网格计算并行系统。 MPICH的安装和配置 MPICH是MPI的一种具体实现。下面以1.2.4版本为例，介绍如何在Linux上安装和配置MPICH，此处采用的操作系统为Red Hat 7.3。 1.下载MPICH软件包 根据需要及机器配置的不同，可从http://www.mcs.anl.gov/mpi/mpich/download.html下载相应的MPICH软件包。此处采用的软件包是mpich-1.2.4.tar.gz。 $ tar xzvf mpich-1.2.4.tar.gz $ cd mpich-1.2.4 $ ./configure --prefix=/usr/local $ make 4.测试编译的正确性 $ cd examples/basic/ $ make cpi $ ../../bin/mpirun -np 4 cpi 若该程序能正确运行，则表明整个MPI软件包的编译是正确的。注意，若在运行测试程序时出现“Permission denied.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/120f5bc7b1a3d5fa4a15a4185a92fd01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13cc550217d88f0b29516dae7c96589/" rel="bookmark">
			Libvirt错误总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文放在evernote快发霉了，整理一下放出来。
virsh start vm1368544020451 error: Failed to start domain vm1368544020451
error: internal error process exited while connecting to monitor: kvm: -drive file=/dev/sp1368155439693/v1368544020461,if=none,id=drive-virtio-disk0,format=qcow2: could not open disk image /dev/sp1368155439693/v1368544020461: Invalid argument
镜像格式错误，用qemu-img info 检查镜像和xml配置文件中指定的type是否一致。
启动虚拟机错误： lzjun@lzjun-ubuntu:/opt/vm$ sudo virsh start vm0 error: Failed to start domain vm0
error: internal error process exited while connecting to monitor: Could not access KVM kernel module: No such file or directory
failed to initialize KVM: No such file or directory
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13cc550217d88f0b29516dae7c96589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c204f5103ab373ebf1b1cc214f28823/" rel="bookmark">
			﻿﻿解决sqlplus下方向键的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决sqlplus下方向键的问题
linux系统下，使用sqlplus时往往不能痛快的使用方向键，例如输入错误后，不能通过方向键移动光标进行修改，需要重新输入上一条命令时，也不能通过↑进行简洁操作。
这里介绍一款工具——rlwrap，这个工具可以帮助我们再sqlplus工作环境下使用方向键简洁操作。
下载地址：http://utopia.knoware.nl/~hlub/rlwrap/#rlwrap
安装方法：【以下均以root用户完成】
1、切换到root用户
2、./configure
3、make
4、make install
安装完成后，可以进行一下实验：rlwarp sqlplus / as sysdba
SQL&gt;select * from v$log;
输入命令完成后，再次点击↑，看到命令成功输入，左右方向键也能够使光标进行移动，而不产生乱码。如果想要是配置永久生效，可以将配置信息写入高oracle的.bash_profile中
首先以root用户查找rlwrap 的安装位置：
whereis rlwrap 在root用户下再将以下2行添加到/home/oracle/.bash_profile中
alias sqlplus='/usr/local/bin/rlwrap sqlplus'
alias rman='/usr/local/bin/rlwrap rman'
有时候，安装rlwrap会提示这个错误信息：
You need the GNU readline library(ftp://ftp.gnu.org/gnu/readline/ ) to build
this program!
这个时候，需要安装（可以从iso文件中解压出来）：
libtermcap-devel-2.0.8-46.1.i386.rpm
readline-devel-5.1-3.el5.i386.rpm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a521401044495913229d55e1b3bdff2/" rel="bookmark">
			考试成绩管理系统的UML建立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析 考试成绩管理系统是举行成人高考、自学考试等成人高校对每个参与考试的学员成绩进行综合管理的一个系统。本系统的功能性需求如下： (1) 学员报名参加相应的科目考试，通过考试成绩管理系统办理考试报名手续，并产生相应的考试编号。
(2) 每次考试完毕后，系统管理员及时将参加考试学员的考试最终成绩输入到考试成绩管理系统中。
(3) 考试成绩管理系统可以供学员和系统管理人员查询考试的成绩，学员可以根据自己的考试编号查询成绩，系统管理人员可以根据自己的编号查询成绩。
(4) 系统管理人员可以根据自己的权限通过考试成绩管理系统添加，删除，修改各种数据库中的数据。
(5) 考试成绩管理系统能够根据数据库中的学员考试成绩，自动加以分类统计，进行排序显示。
创建系统用例模型 n 创建系统用例的第一步是确定系统的参与者。考试成绩管理系统的参与者包含以下三种： （1）学员
（2）系统管理员
（3）系统数据库
1. 学员用例图:学生在本系统中能够进行考试报名、成绩查询和退出系统的相关操作。
n 3. 系统数据库用例图：系统数据库在本系统中负责考试报名、记录成绩、成绩查询、统计成绩、更新维护成绩、设置考试编号等操作时与数据的彼此交互。 创建系统静态模型 系统类图
n 从前面的需求分析中，创建三个类：学员、系统管理员和系统数据库。 创建系统动态模型 1.学员报名序列图和协作图
(1)学员在操作界面输入报名信息
(2)系统添加相应数据
(3)数据库数据进行更新
(4)系统将考试编号输出
到屏幕。
根据以上步骤创建序列
图和协助图。
2.查询成绩序列图和协作图
(1)学员或系统管理员在系统成绩查询的界面输入查询的条件
(2)系统根据查询结果将结果输出到界面显示。
根据以上步骤创建序列
图和协作图。
3.系统管理员维护成绩序列图和协作图
(1)系统管理员在操作界面执行录入、修改和删除成绩的操作
(2)系统数据库对数据进行相应的处理
(3)统计成绩模块对数据进行更新保存到数据库
(4)向界面返回操作结果。
根据以上步骤创建的序列
图和协作图
4.系统活动图
考试成绩管理系统中，根据学生和系统管理员的活动步骤，我们可以创建活动图。
5.系统状态图
在考试成绩管理系统中，有明确状态转换的类是考试成绩。考试成绩主要有二个状态：一个是原来产生的成绩，另一个是维护更新数据库数据后的成绩。
创建系统部署模型 1.系统构件图
成绩管理系统的构件图我们通过构件映射到系统的实现类中，说明该构件物理实现的逻辑类，在本系统中，我们可以对学员类、系统管理员类、成绩类和系统数据库分别创建对应的构件进行映射，创建的构件图。
2. 系统部署图
成绩管理系统的部署图描绘的是系统节点上运行资源的安排。包括四个节点，分别是：客户端浏览器、Http服务器、数据库服务器和打印机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ee01854e27e4dabc5688811025f926/" rel="bookmark">
			﻿﻿﻿﻿oracle中的db_name,servcie_name,instance_name,oracle_sid,global_dbname
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORACLE中的DB_NAME,SERVICE_NAME,INSTANCE_NAME,ORACLE_SID,GLOBAL_DBNAME介绍 最近查过一些资料，准备把oracle里纷乱的参数整理一下，这里主要讨论以下参数，及其用法的总结， 在init.ora中有db_name，instance_name，service_name 在操作系统中需要配置oracle_sid 在listener.ora中有SID_NAME，GLOBAL_DBNAME， 在tnsname.ora中有SERVICE_NAME，SID init.ora中 Db_name：对一个数据库（Oracle database）的唯一标识，该数据库为第一章讲到的Oracle database。这种表示对于单个数据库是足够的，但是随着由多个数据库构成的分布式数据库的普及，这种命令数据库的方法给数据库的管理造成一定的负担，因为各个数据库的名字可能一样，造成管理上的混乱。为了解决这种情况，引入了Db_domain参数，这样在数据库的标识是由Db_name和Db_domain两个参数共同决定的，避免了因为数据库重名而造成管理上的混乱。这类似于互连网上的机器名的管理。我们将Db_name和Db_domain两个参数用’.’连接起来，表示一个数据库，并将该数据库的名称称为Global_name，即它扩展了Db_name。Db_name参数只能由字母、数字、’_’、’#’、’$’组成，而且最多8个字符。 Db_domain：定义一个数据库所在的域，该域的命名同互联网的’域’没有任何关系，只是数据库管理员为了更好的管理分布式数据库而根据实际情况决定的。当然为了管理方便，可以将其等于互联网的域。 Global_name：对一个数据库（Oracle database）的唯一标识，oracle建议用此种方法命令数据库。该值是在创建数据库是决定的，缺省值为Db_name. Db_domain。在以后对参数文件中Db_name与Db_domain参数的任何修改不影响Global_name的值，如果要修改Global_name，只能用ALTER DATABASE RENAME GLOBAL_NAME TO &lt;db_name.db_domain&gt;命令进行修改，然后修改相应参数。 Service_name：该参数是oracle8i新引进的。在8i以前，我们用SID来表示标识数据库的一个实例，但是在Oracle的并行环境中，一个数据库对应多个实例，这样就需要多个网络服务名，设置繁琐。为了方便并行环境中的设置，引进了Service_name参数，该参数对应一个数据库，而不是一个实例，而且该参数有许多其它的好处。该参数的缺省值为Db_name. Db_domain，即等于Global_name。一个数据库可以对应多个Service_name，以便实现更灵活的配置。该参数与SID没有直接关系，即不必Service name 必须与SID一样。 Net service name：网络服务名，又可以称为数据库别名（database alias）。是客户端程序访问数据库时所需要，屏蔽了客户端如何连接到服务器端的细节，实现了数据库的位置透明的特性。 实例 就是管理相关库的内存结构的名字（由SGA、PGA、服务器进程、用户进程、后台进程等组成） 数据库 就是实际的磁盘上的文件（数据文件、日志文件、控制文件等），负责保存数据，但由对应的实例来操作它的数据 服务名 就是对外公布的名称，为网络监听服务 其实，在我们传统的概念里，数据库是一个统称的名字，在Oracle中，你可以把“数据库”理解成一个大概念，也要把它理解成一个小概念 1、一个Oracle数据库系统中可以同时安装几个数据库，每一个数据库对应一个唯 一的实例，但是OPS系统除外，可以多个实例同时对一个数据库操作，称为并行服务 器 2、只是一个名字，SID即是INSTANCE_NAME，SERVICE_NAMES主要用在监听器中。 在listener.ora中有SID_NAME，GLOBAL_DBNAME 这里SID_NAME指数据库的运行的实例名，应该是和instance_name一致 而对于GLOBAL_DBNAME是listener配置的对外网络连接名称，我们在配置tnsname.ora时会考虑这个参数。这个参数可以任意的设置。 另外有一点需要注意，一般我们会在listener.ora手工配置数据库实例的监听配置。但oracle可以通过pmon进程支持自动注册，这时自动注册的对外网络连接名称就会用到init.ora文件中service_name，有多个值的话就会注册多个，对于上面的例子，在这里就会注册serv1和serv2两个监听服务。如果你还手工配置了一个GLOBAL_DBNAME＝serv3的监听服务的话，那么对于实例instance_name=aking就会有三个监听服务。 在tnsname.ora中有SERVICE_NAME，SID 下面配置客户端的tnsname.ora 对于这里的配置主要要给出要连接的数据库的IP及其连接的实例或服务 在监听配置中我们提到了对外网络连接名称，在这里如果我们用SERVICE_NAME的话，就需要SERVICE_NAME＝（GLOBAL_DBNAME或者service_name这里要求oracle已经自动注册到了监听器中），对于SID＝（instance_name）即可，譬如： SERVICE_NAME＝serv1，serv2，serv3都可以，或者 SID=aking 最后一个是ORACLE_SID参数，这个参数是操作系统中用到的，它是描述我们要默认连接的数据库实例，对于一个机器上有多个实例的情况下，要修改后才能通过 conn / as sysdba连接，因为这里用到了默认的实例名。 1.ORACLE_SID：（ORACLE SYSTEM IDENTIFIER） 以环境变量的形式出现的。 Oracle实例是由SGA和一组后台进程组成的，实例的创建和启动需要一个参数文件，而参数文件的名称就是由ORACLE_SID决定的。对于init文件，缺省的文件名称是init&lt;ORACLE_SID&gt;.ora，对于spfile文件，缺省的文件名称是spfile&lt;ORACLE_SID&gt;.ora 设置不同的ORACLE_SID值，就可以默认使用不同的参数文件启动不同的数据库实例。 另外，ORACLE_SID的作用远远不是作为一个实例入口这么简单的，在实例启动后，实例名称INSTANCE_NAME也是从ORACLE_SID得到的。 2.INSTANCE_NAME: 实例名称，这是Oracle实例的名字，用来区分不通的实例。在Oracle9i之前，该名字存储在两个地方：参数文件和数据库的内部试图（V$INSTANCE）. 而在Oracle10g之后的版本中，该名字不再出现在参数文件中，而是动态从系统中获得，默认是取自ORACLE_SID。 INSTANCE_NAME的作用除了区别不同实例之外，在监听器动态注册时，还会用于向监听器注册。比如instance_name=kanon,监听中将动态注册Instance "kanon",status READY信息。 3.DB_NAME： DB_NAME概念相比于INSTANCE_NAME要重要的多，它决定实例将挂在的数据文件。它出现在数据文件，控制文件，日志文件中。在参数文件中也出现，且必须出现。这个参数涉及到系统的物理文件。 4.SERVICE_NAME和GLOBAL_DBNAME： 这两个参数之所以放在一起讲，是因为他们往往是成对出现的。SERVICE_NAME出现在Tnsnames.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94ee01854e27e4dabc5688811025f926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e42809a3b779bad6a9240870473bdc/" rel="bookmark">
			openwrt 查看wr703n路由上的无线链接数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我通过openwrt的wr703n发出无线路由,但是我想查看到底有多少主机连接到了我的无线路由上,这个时候如何操作呢?
首先在正常进入路由器的配置界面之后,执行如下命令:
cat /proc/net/arp | grep : | grep ^192 或者 netstat -n 或者 vi /tmp/dhcp.leases 通过这三个命令都可以查看你的无线路由目前有多少个主机链接上.可以防止蹭网哦. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ddfb424fa17a0dc7df66a40b37b3960/" rel="bookmark">
			BZOJ 1088(mine)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1088: [SCOI2005]扫雷Mine Time Limit: 10 Sec Memory Limit: 162 MB Submit: 659 Solved: 386 [ Submit][ Status][ Discuss] Description 相信大家都玩过扫雷的游戏。那是在一个n*m的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了，“余”人国流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字表示和它8连通的格子里面雷的数目。现在棋盘是n×2的，第一列里面某些格子是雷，而第二列没有雷，如下图： 由于第一列的雷可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息确定第一列雷有多少种摆放方案。 Input 第一行为N，第二行有N个数，依次为第二列的格子中的数。（1&lt;= N &lt;= 10000） Output 一个数，即第一列中雷的摆放方案数。 Sample Input 2 1 1 Sample Output 2 Dp扫雷题： 一开始居然没有想出方程…天生不敏感？ 显然方程为f(i,x,x_r) 表示第i格时，中间x和右边x_r是否有雷 轻易得到递归方程： 这题的教训是，方程果断列，另当前状态确定差1，由前面得到。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;iostream&gt; #include&lt;functional&gt; #include&lt;cmath&gt; using namespace std; #define MAXN (10000+10) int n,a[MAXN]; int f[MAXN][2][2]={0}; //Middle and 1 int main() { cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; switch (a[1]) { case 2:f[1][1][1]++;break; case 0:f[1][0][0]++;break; default:f[1][0][1]=f[1][1][0]=1; } for (int i=2;i&lt;=n;i++) { switch (a[i]) { case 3:f[i][1][1]=f[i-1][1][1];break; case 0:f[i][0][0]=f[i-1][0][0];break; case 2:f[i][1][0]=f[i-1][1][1];f[i][0][1]=f[i-1][1][0];f[i][1][1]=f[i-1][0][1];break; case 1:f[i][1][0]=f[i-1][0][1];f[i][0][1]=f[i-1][0][0];f[i][0][0]=f[i-1][1][0];break; } } cout&lt;&lt;f[n][1][0]+f[n][0][0]&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c273908ca650a21f5210a652734311f/" rel="bookmark">
			HDU 1465(错排公式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不容易系列之一 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 9829 Accepted Submission(s): 4115
Problem Description 大家常常感慨，要做好一件事情真的不容易，确实，失败比成功容易多了！ 做好“一件”事情尚且不易，若想永远成功而总从不失败，那更是难上加难了，就像花钱总是比挣钱容易的道理一样。 话虽这样说，我还是要告诉大家，要想失败到一定程度也是不容易的。比如，我高中的时候，就有一个神奇的女生，在英语考试的时候，竟然把40个单项选择题全部做错了！大家都学过概率论，应该知道出现这种情况的概率，所以至今我都觉得这是一件神奇的事情。如果套用一句经典的评语，我们可以这样总结：一个人做错一道选择题并不难，难的是全部做错，一个不对。 不幸的是，这种小概率事件又发生了，而且就在我们身边： 事情是这样的——HDU有个网名叫做8006的男性同学，结交网友无数，最近该同学玩起了浪漫，同时给n个网友每人写了一封信，这都没什么，要命的是，他竟然把所有的信都装错了信封！注意了，是全部装错哟！ 现在的问题是：请大家帮可怜的8006同学计算一下，一共有多少种可能的错误方式呢？ Input 输入数据包含多个多个测试实例，每个测试实例占用一行，每行包含一个正整数n（1&lt;n&lt;=20），n表示8006的网友的人数。 Output 对于每行输入请输出可能的错误方式的数量，每个实例的输出占用一行。 Sample Input 2 3 Sample Output 1 2 Author lcy Source ACM暑期集训队练习赛（九） Recommend lcy 难得的中文题。
n错排公式：F[n]=(n-1)*(F[n-1]+F[n-2])
证明：
1.当前n-1个错排时：将其任意一封信与n对调,共(n-1)*F[n-1]
2.当前n-2个错排，1个不错排时,将不错排的那封信与n对调,共(n-1)*F[n-2]
3.当前≤n-3个错排，≥2个不错排时,显然无解.
∴F[n]=(n-1)*F[n-1]+(n-2)*F[n-2]
证毕
记得用long long，不然会爆
#include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;iostream&gt; using namespace std; #define MAXN (20+10) int n; long long f[MAXN]={0,0,1}; int main() { for (int i=3;i&lt;=20;i++) f[i]=(i-1)*f[i-1]+f[i-2]*(i-1); while (cin&gt;&gt;n) cout&lt;&lt;f[n]&lt;&lt;endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18913965b7344b68e3c94d35055e781e/" rel="bookmark">
			瞬联基于OpenStack的私有云解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不知不觉中已经接触云计算领域一年有余了，从CloudFoundry到OpenStack，从虚拟化到云平台，随着项目的深入发现要学的东西越来越多，但时间却总是不够用，所以也想借这篇博文对过去的2012年做一个总结。
值得庆幸的是，我们躲过了世界末日，我们还活着，云计算事业还将继续。
瞬联为什么需要私有云？ 说到这样一个问题，必须要了解一下企业的背景。简单来说，瞬联就是一家外包公司。相信很多人看到这里可能会发出这样的感叹：哦，就是个卖人的公司嘛！相信大多数的外包公司都会留给人这样的印象，但是这句话只说对了一半。从外包的定义上说，除了传统的人力资源外包，项目外包也占据了外包行业的半壁江山。其实在中国，电信行业、金融业的项目，都是以项目打包的方式承包给IT服务企业完成的。
需求一：开发、测试环境的需求 其中占据瞬联业务重要的一部分就是服务即产品(Service as a product)的模式，在瞬联内部有大量为不同客户项目提供解决方案的团队，涵盖电信、移动互联网等诸多方面，其中也包括我们企业私有云解决方案团队，这些团队在项目开发过程中，经常需要使用很多不同的开发环境，但无外乎Windows和各种Linux版本，当项目开始后，项目经理四处寻找空闲资源，当项目结束后，环境又被销毁掉，资源被回收，但是如果项目一旦重新启动，通常的做法是按照文档重新搭建环境，大大浪费人力和时间成本。那么这里通过OpenStack提供的镜像服务以及虚拟机服务可以方便快速的保存、重建开发、测试环境，大大缩短了环境重建的周期，提高效率，也提高了资源的利用率。
但是，从实际使用状况来看，OpenStack主要是面对公有云运营商开发的，所以不会对用户使用资源使用刻意限制，换句话说，你用的越多我越高兴。但对私有云的来说，硬件资源总是有限的，我们不能让所有的用户不加限制的随意占用资源（时间和硬件资源），所以对于企业私有云来说，流程控制是必不可少的。所以针对这一点，我们在Nova项目中开发了一个新的服务Flow，用来控制虚拟机资源的申请流程，以及控制虚拟机资源使用的时间和通知等服务。
另外，对于公司来讲，资源的隔离性也是很很有必要的，不同项目、部门的采购的硬件往往希望独占，所以这里面就涉及到Zone的概念。OpenStack中的Zone是在生成虚拟机时指定的，但是我们并不希望让用户不加限制的去选择Zone信息，这样失去了对用户行为的控制。那么，我们会将Project和Zone由云管理员进行绑定，用户申请时只能选择该Project允许创建虚拟机的Zone。这样就保障了项目对硬件隔离的需求。
需求二：共享存储——私有网盘 此外，基于群组的文件共享也是重要需求之一。在我们企业内部环境中，文件的共享基本通过电子邮件或者wiki的方式实现，但无论哪种方式都有明显的劣势：电子邮件不利于查找而wiki对普通用户使用有门槛。基于以上需求，我们结合OpenStack提供的对象存储模块SWIFT，开发了针对企业私有云平台的网盘服务。另外，对于一些OFFICE、PDF、图片等，大部分的用户只想查看其中的内容，并不需要编辑他们，但往往我们收到这样的文件，只能下载后通过本地的客户端软件打开后才能查看，很浪费时间。所以，我们又开发了针对文档及图片等常见文件格式的在线浏览功能，同时还提供群组分享、内容检索等服务。网盘的应用在企业内部，即保证了数据的安全、可靠，又提高了用户体验。
需求三：VDI远程桌面 最后，是关于VDI，也就是远程桌面系统，用来解决远程办公、软件共享、安全控制等功能。针对这个需求，我们利用OpenStack对虚拟资源的灵活控制，开发了一套基于OpenStack的VDI应用。用户使用任意RDP客户端，每次连接固定的域名，之后选择要使用的软件资源池，用OpenStack用户登陆后即可进入相应的操作系统，使用要使用的软件。并且，用户可以通过网盘服务，将所需要的文档资料拷入拷出，同时，我们为用户提供一块云端硬盘，用户存入此块磁盘的文件可以永久保存，在下一次登陆后，仍然可以方便的使用。
瞬联如何建设私有云？ 记得OpenStack北京行活动时，陈沙克老兄曾经提到过微软的那句名言：Eat your own dog food（吃你自己的狗食）。所以，我们认为如果想提供基于OpenStack的服务，那么必然自己先要用好，这也是我们在内部大力推广我们云服务的重要原因。
在最开始部署我们的私有云服务时，我常常纠结的两个问题是：我需要新的硬件设备吗？我的旧的硬件怎么办？最后，我得出的结论就是我在OpenStack APAC讲的那句话：立足现有装备，打赢未来战争。所以从现有阶段来看，瞬联在私有云硬件成本的投入几乎为零。因为现有的硬件资源完全满足项目需求，我为什么要购置昂贵的硬件设备呢？但并不意味着我们永远不购置新的硬件设备，从一个长远的发展来看，我们的策略是：随着项目逐步迁移到云中，根据实际的需求购买更好的硬件设备，逐步淘汰耗电大，占空间的老旧设备。
因为我们毕竟不像那些预算充裕的大公司，可以随意购置新设备。所以我们的解决方案针对的是像我们一样，花自己的钱，又想构建私有云的中小企业。
这里援引我一位非常要好的哥们对于国内云计算市场评价的话：
“对于云计算的价值，真的是见人说人话，见鬼说鬼话。国内云计算产业，究其源头会发现，基本是IBM、HP、SUN、DELL、VMware、Citrix等这些软硬件提供商在引导，把偌大的国内云计算市场往沟里带，说白了就是为了卖硬件和软件。国内各大运营商、各政府机构等有钱的地方，都有大国盛宴，举国体制的风范，开始跑马圈地，搞集中IDC，搞大事业……”
网络规划&amp;高可用 好了，说了这么多废话，开始说点干货吧。先上一张拓扑图：
我们选用的OpenStack网络是传统的VLAN方式，并没有使用Quantum，这是因为在Essex版本时，Quantum还不是正式的模块，所以到了Folsom版本，我们延续了原有的VLAN方式。VLAN方式很好的实现了各个项目之间的隔离，保证了安全性。
为了能够让各个分公司都能够使用私有云，我们先划定了一条各个分公司都能够访问的VLAN作为提供公共服务的网段，再划定一条VLAN作为虚拟机内部通讯的网络。同时在相关交换机上预留VLAN ID 800~850，50条VLAN与OpenStack内部VLAN相对应，同一VLAN下虚拟机之间通讯不受影响。通过这些手段，保证了无论我们的计算节点位于哪一层的机房，都可以进行通讯。
在图中，最左侧为控制节点，其中OpenStack控制节点和网盘应用形成MySQL集群，用于实时备份数据，任意一台出现问题之后，另外一台可以快速作为对方的备份节点。下面的一台是为了提供自动部署的服务器。
中间靠上的两台服务器，分别提供镜像和卷服务，利用GlusterFS形成冗余，并可互为灾备节点。因为GlusterFS并不支持块设备，所以这里用到的Cinder驱动为NFS。中间的服务器代表一个机房中的某几台服务器形成一个Zone，这个Zone专门为CL这个项目组提供虚拟机服务。中间靠下的服务器是SWIFT服务器，作为网盘的后台。
最右边的服务器，代表OpenStack控制节点所在机房如何和另外一个机房的服务器连接。那么这几台服务器形成一个独立的区域，为整个瞬联内部提供服务。
监控方案采用Nagios，对主机性能及关键进程形成监控，后期准备在已有的Nagios OpenStack Plugin基础上增加一些关键指标的监控。
部署 我们当前采用的OpenStack版本为定制版Folsom，底层操作系统为Ubuntu 12.04 64bit Server版本。操作系统采用kickstart实现推送，本地缓存了所有DEB包，无须网络安装。IT人员只须设定好网络地址，之后由Fabric脚本完成主机名、NTP、Puppet等基础软件的安装。
因为是我们定制的版本，所以市面上所有的部署方案基本都是不适用的，我们基于dodai-deploy，开发了可以部署我们自己软件的版本，并且将所有的数据库全部默认使用MySQL（默认的dodai-deploy只有nova是使用MySQL数据库）。
我们全新部署一台计算节点的时间，从裸机到能够使用大致为30分钟之内。
定制化 还是先上一张图：
凡是有蓝色的模块是我们定制过的模块和增加的模块，主要集中在Keystone、Nova、以及Horizon三个模块，在Cinder中增加了关于NFS驱动层的三个方法。
Nova是我们最早开始改动的模块，为了实现对于虚拟机申请的控制，我们增加了一张表用于存放用户所有申请及状态。之后增加Flow api用于实现相应的请求。最后，增加了nova-flow服务用于通知用户虚拟机过期和删除过期的虚拟机。这样配合Horizon的改动，就可以完成了对虚拟机申请流程的控制。
可供申请的虚拟机列表 用户申请页面，增加申请天数、区域等信息 在Keystone中，为了实现Zone和项目绑定的目的，我们增加了相关方法，并且增加了一个新的角色ProjectAdmin，用于在某一个项目中，完成用户虚拟机申请的审批工作。因为OpenStack主要是针对公有云的开发，所以暂时没有把这部分代码提交到社区。
管理员可以设置Project允许生成虚拟机的区域 Cinder中，因为NFS驱动中，并没有生成卷镜像和从卷镜像生成新镜像的方法，所以这部分代码，正准备提交到社区。
网盘应用 网盘应用基于OpenStack Swift API开发的。提供在线文档、图片浏览、群组分享功能，现在支持的格式：DOC/XLS/PPT/PDF/PNG等多种常见的文档和图片格式。我们准备在近期将我们的版本开源，回馈社区。还是图片最容易说明问题，继续上图：
用户登陆后的页面，私人空间 在线浏览功能 虚拟化桌面应用 虚拟化桌面包括VDI Broker以及Visual两个部分，Broker主要负责处理RDP协议解析以及和Visual交互，而Visual则完全负责资源分配。VDI同时支持添加虚拟机和物理机，现阶段暂时需要云管理员对所有可用服务器进行配置，在下一个阶段将根据需求启停虚拟机。如果用户使用的是虚拟机，那么在用户登陆后，自动挂载一块用户硬盘，用户保存在此硬盘的所有资料，在下一次使用VDI服务时仍然存在。还是来看图：
架构图 标准的RDP客户端连接 用户选择要使用的资源池，完成连接 结语 在半年的内部运行中，系统非常稳定，随着新功能的不断更新，内部的用户也愿意使用云平台服务。各个项目的负责人也积极的将项目的开发、测试环境放到云中运维，而这也直接帮助他们更好的控制项目进度，缩短准备周期。我们相信随着我们不断的努力，一定能让企业私有云在我们的企业日常生活中发挥越来越重要的作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18913965b7344b68e3c94d35055e781e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9e601088801000ab188d1881cb70c3/" rel="bookmark">
			STL之三：deque用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		deque函数： deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。但它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。deque类常用的函数如下。
(1) 构造函数
deque():创建一个空deque
deque(int nSize):创建一个deque,元素个数为nSize
deque(int nSize,const T&amp; t):创建一个deque,元素个数为nSize,且值均为t
deque(const deque &amp;):复制构造函数
(2) 增加函数
void push_front(const T&amp; x):双端队列头部增加一个元素X
void push_back(const T&amp; x):双端队列尾部增加一个元素x
iterator insert(iterator it,const T&amp; x):双端队列中某一元素前增加一个元素x
void insert(iterator it,int n,const T&amp; x):双端队列中某一元素前增加n个相同的元素x
void insert(iterator it,const_iterator first,const_iteratorlast):双端队列中某一元素前插入另一个相同类型向量的[forst,last)间的数据
(3) 删除函数
Iterator erase(iterator it):删除双端队列中的某一个元素
Iterator erase(iterator first,iterator last):删除双端队列中[first,last）中的元素
void pop_front():删除双端队列中最前一个元素
void pop_back():删除双端队列中最后一个元素
void clear():清空双端队列中最后一个元素
(4) 遍历函数
reference at(int pos):返回pos位置元素的引用
reference front():返回手元素的引用
reference back():返回尾元素的引用
iterator begin():返回向量头指针，指向第一个元素
iterator end():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）
reverse_iterator rbegin():反向迭代器，指向最后一个元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d9e601088801000ab188d1881cb70c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298f2e2e18b2535316836a15e1d0d380/" rel="bookmark">
			java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener错误解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在myeclipse自带的tomcat中加载一个web工程，启动tomcat出现java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener错误。一般出现这种错误有可能是spring库没有包含，主要是spring-web.jar。不过工程中已经存在这个库文件，并且同一个工程之前加载过没有出现这种错误。移除tomcat中的工程，启动tomcat还是出现相同的问题。这就可能是tomcat缓存问题，进入tomcat的webapp目录，清空里面的文件，再重新加载工程，启动tomcat，问题解决。
java开发受各种环境配置参数影响较大，多人合作开发时经常会出现各种问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2109163e767ea756eecbaae754d5690/" rel="bookmark">
			修改hMailServer管理密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始菜单 -&gt; hMailServer Administrator -&gt; 输入旧密码
点“设置”，再点击“高级”，在“管理密码”下的框中输入新的密码。
点击“保存”。退出，重新登录。
注意：hMailServer 密码设置时没有密码确认过程。所以设置时要小心，否则自己都无法进入了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d8a1da41ec4f1cef78c3fb1c313661/" rel="bookmark">
			POJ 3304(线段与直线相交）[改]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Language: Default Segments Time Limit: 1000MS Memory Limit: 65536KTotal Submissions: 7144 Accepted: 2135 Description
在平面内给 n 条线段，问是否存在一条直线，使得所有线段在这条直线上的投影有公共点.
Input
第一行输入 T 表示数据组数，接下来 T 组数据每组第一行一个整数 n ≤ 100 表示线段数，接下来n 行每行有 x1 y1 x2 y2 表示线段的两个端点 (x1, y1) 和 (x2, y2) .
Output
对于每组数据,如果存在这样的直线，输出一行 "Yes!", 否则输出 "No!" . 精度|a - b| &lt; 10-8.
Sample Input
3 2 1.0 2.0 3.0 4.0 4.0 5.0 6.0 7.0 3 0.0 0.0 0.0 1.0 0.0 1.0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07d8a1da41ec4f1cef78c3fb1c313661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1deae68362b180dce51786de1d3181de/" rel="bookmark">
			VS调试，提示 函数计算超时。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度关键词：
监视变量提示:由于以前的函数求值超时,函数求值被禁用。必须继续执行才能重新启用
解决方法：
1.关闭： 工具-选项-调试-常规-启用属性求值和其他隐藏函数调用 去掉勾 不过试了一下不好使
2.隐藏“局部变量”窗口 好用。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e4783daf35fbc33e85d91f9386d974d/" rel="bookmark">
			Windows环境下使用MFC进行多线程编程(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处： http://blog.csdn.net/zhangxingping Windows环境下使用MFC进行多线程编程(C++) 进程和线程 （Process andThread） 进程指的是计算机程序的一次执行，或者说是程序执行的一个实例。进程中包含有程序代码及其当前的活动。线程指的是进程中的一个执行路径。一个进程有可能是由多个线程组成，这些线程并发地执行程序指令。
在传统的操作系统中， CPU调度和分派的基本单位是进程。而在现代操作系统中（引入了线程的操作系统中），则把线程作为CPU调度和分派的基本单位，而把进程作为资源分配的基本单位，从而使得传统进程的两个属性分开了，这样可以显著提供系统的并发性。
在引入线程的操作系统中，不仅进程之间是可以并发执行的，而且同一个进程间的线程也是可以并发执行的，因此更好地提供了操作系统的并发性，从而更有效地利用系统资源和提高系统的效率。
MFC中的线程相关知识 MFC中有两种类型的线程：用户接口线程和工作线程。用户接口线程通常是用来处理用户输入，相应用户事件和消息的。工作线程通常是用来完成实际任务的，比如不需要用户输入的复杂计算等。Win32 API中是没有这两中线程的区分的，其中只需要线程开始执行的地址就可以了。MFC则为用户接口线程提供了消息机制，用来处理相关事件。CWinApp就是一个担心的用户接口线程对象，因为它是从CWinThread继承而来，并且能处理用户生成的事件和消息。
创建线程 Windows环境下，创建线程可以通过函数AfxBeginThread()来完成。该函数有两种重载的形式，分别用来创建工作线程和UI线程：
CWinThread* AfxBeginThread(
AFX_THREADPROC pfnThreadProc,
LPVOID pParam,
int nPriority = THREAD_PRIORITY_NORMAL,
UINT nStackSize = 0,
DWORD dwCreateFlags = 0,
LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL );
CWinThread* AfxBeginThread(
CRuntimeClass* pThreadClass,
int nPriority = THREAD_PRIORITY_NORMAL,
UINT nStackSize = 0,
DWORD dwCreateFlags = 0,
LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL );
在这里，先对上述两种形式中的共有的参数的含义进行描述：
参数
含义
nPriority
线程的优先级别。缺省值为NORMAL。更多信息参见SetThreadPriority。
nStackSize 线程运行时期望的栈的大小。缺省值和创建线程的大小一样。
dwCreateFlags
如果想在线程创建后挂起该线程，可以传入CREATE_SUSPENDED。缺省值为0，表示正常启动该线程。
lpSecurityAttrs 线程的属性。缺省属性和父线程一样.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e4783daf35fbc33e85d91f9386d974d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb1faa892799963f30eeccf8940ef8a/" rel="bookmark">
			52 链表处理*
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个函数，给定的带有头结点的单向链表 head，给定某结点的数据域值 m，将该结点移到链首。
结构的定义：
typedef struct node {
int num; struct node *next; } SNODE;
函数的原型：SNODE *movenode(SNODE *head, int m);
其中：参数 head 是单向链表的头指针；参数 m 是某结点的num成员的值。
例如输入结点数 n=7，则将结点数值域值 m=5 的结点移动到链首。函数运行前后链表的情况如下图所示。(....可是没图....看测试用例吧)
预设代码
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct sdata { int num; struct sdata *next; } SNODE; void movenode( SNODE *, int ); void setlink( SNODE * head, int n ) { SNODE *p; while ( n &gt; 0 ) { p = ( SNODE * ) malloc( sizeof( SNODE ) ); p-&gt;num = n; p-&gt;next = head-&gt;next; head-&gt;next = p; n --; } } void outlink( SNODE * head ) { while( head-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecb1faa892799963f30eeccf8940ef8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a623d617b8c79325b5e0a9298defda/" rel="bookmark">
			53 猜数字看人品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 Tom 和 Jerry 做猜数字的游戏，Tom 想一个数字然后让 Jerry 去猜，数字的范围在 1 到 10 之间。对于 Jerry 每讲的一个数，Tom 都要讲这个数是 too high 或者 too low 或者 right on，直到 right on 结束。为了防止 Tom 作弊，Jerry 把每一次的对话记录下来，现在让你去判断 Tom 有没有作弊。
输入 游戏可能做很多次，直到 Jerry 猜 0 的时候游戏结束，每一次猜测由一个正整数和一行回答组成。
输出 对每一次游戏如果 Tom 的回答有自相矛盾的地方，就输出 Tom is dishonest，否则输出 Tom may be honest。
我的代码。
主要思路就是根据问答我们来改变high和low的值(high和low是最后结果的上限和下限)，诚实不诚实就通过最后结果是不是在high和low中。
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { int n,high=11,low=-1; char s[10]; while(scanf("%d",&amp;n)) { if(n==0) break; getchar(); gets(s); if(strcmp(s,"too high") == 0) { if(n &lt; high) { high = n; } } else if(strcmp(s,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1a623d617b8c79325b5e0a9298defda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea9c502d1e3f352181fde75acf2b442/" rel="bookmark">
			编程复习2全能战士
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 全排有n名战士，其中会骑马的有n1人，会摔跤的有n2人，会拳击的有n3人。还知道不少人是多面手，其中会骑马和摔跤的有n12人，会摔跤和拳击的有n23人，会拳击和骑马的有n13，还有若干三项全会。编程，输出三项全能的有几人？
例如：输入：n=50, n1=30, n2=28, n3=20, n12=14，n23=12, n31 = 8。
输出：6&lt;回车&gt;
排列组合?容斥原理?可以拓展到n项全会的.
#include&lt;stdio.h&gt; int main() { int n,n1,n2,n3,n12,n13,n23; scanf("%d %d %d %d %d %d %d",&amp;n,&amp;n1,&amp;n2,&amp;n3,&amp;n12,&amp;n13,&amp;n23); printf("%d\n",n-n1-n2-n3+n12+n23+n13); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990cf8046334a8aeb2af016e06768c42/" rel="bookmark">
			【Linux】Vim编辑器-批量注释与反注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim编辑器---批量注释与反注释
在使用vim编写代码的时候，经常需要用到批量注释与反注释一段代码。下面简要介绍其操作。
方法一 块选择模式 插入注释： 用v进入virtual模式
用上下键选中需要注释的行数
按Control+v（win下面ctrl+q）进入列模式
按大些“I”进入插入模式，输入注释符“#”或者是"//"，然后立刻按下ESC（两下）
取消注释： Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意// 要选中两个，选好之后按d即可删除注释
方法二 替换命令 批量注释： 使用下面命令在指定的行首添加注释：
:起始行号,结束行号s/^/注释符/g
取消注释： :起始行号,结束行号s/^注释符//g
实例演示： 在27 - 30行添加 // 注释
:27,30s#^#//#g
在27 - 30行删除 // 注释
:27,30s#^//##g
在10 - 20行添加 # 注释
:10,20s/^/#/g
在10 - 20行删除 # 注释
:10,20s/^/#/g
注意例子中正则的分割符使用的是相反的符号，如果匹配// 那么使用 #作分隔符这样不需要对/作转义处理，节省输入次数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e337d4f2471943ef1fa90df0a049096/" rel="bookmark">
			java的模板类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java的模板类可以理解为含有Object类型的类。
1. java的模板类的模板参数只能是参数类型，成员变量类型等，模板名是确定的。
2. 运行期，模板参数会被当作Object来处理，已经验证
3. 使用模板类的类型安全，只是利用编译器的类型检查，来自动保证运行期的类型强转的正确与安全。
分享到： 上一篇：UI layout设置技巧下一篇：Android 动画框架详解 class TestTemplate { public static void main(String[] args) { //vector&lt;T&gt; v=new vector&lt;T&gt;(); Byte b=new Byte((byte)0); vector&lt;Byte&gt; v=new vector&lt;Byte&gt;(b); v.add((byte)0); v.add((byte)1); v.add((byte)3); v.add((byte)2); v.visitAll(); } } class vector&lt;T&gt;{ private int size=0; private vectorElement&lt;T&gt; head=null; private vectorElement&lt;T&gt; last=null; public vector(T datum) { System.out.println("vector(T datum)!"); this.head=new vectorElement&lt;T&gt;(datum); this.last=this.head; this.size=1; } public boolean add(T datum){ if(this.size==0){ this.head=new vectorElement&lt;T&gt;(datum); this.last=this.head; this.size=1; }else{ vectorElement&lt;T&gt; temp=new vectorElement&lt;T&gt;(datum); temp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e337d4f2471943ef1fa90df0a049096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c080576ad4852206ea159e815b70740f/" rel="bookmark">
			VS2010  Windows   API  串口编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：在VS2010中没有编写串口的控件，因此，需要自己下载相关的文件并安装。操作比较麻烦。用Win32 API 编程，在VS2010中能够实现同样的功能。仅此，与大家共享一下。
可以使用两种编程方式实现串口通信，其一是使用ActiveX控件，这种方法程序简单，但欠灵活。其二是调用Windows的API函数，这种方法可以清楚地掌握串口通信的机制，并且自由灵活。本文我们只介绍API串口通信部分。
串口的操作可以有两种操作方式：同步操作方式和重叠操作方式（又称为异步操作方式）。同步操作时，API函数会阻塞直到操作完成以后才能返回（在多线程方式中，虽然不会阻塞主线程，但是仍然会阻塞监听线程）；而重叠操作方式，API函数会立即返回，操作在后台进行，避免线程的阻塞。
无论那种操作方式，一般都通过四个步骤来完成：
（1）打开串口
（2）配置串口
（3）读写串口
（4） 关闭串口
（1） 打开串口
Win32系统把文件的概念进行了扩展。无论是文件、通信设备、命名管道、邮件槽、磁盘、还是控制台，都是用API函数CreateFile来打开或创建的。该函数的原型为：
HANDLE CreateFile( LPCTSTR lpFileName,
DWORD dwDesiredAccess,
DWORD dwShareMode,
LPSECURITY_ATTRIBUTES lpSecurityAttributes,
DWORD dwCreationDistribution,
DWORD dwFlagsAndAttributes,
HANDLE hTemplateFile);
lpFileName：将要打开的串口逻辑名，如“COM1”； dwDesiredAccess：指定串口访问的类型，可以是读取、写入或二者并列； dwShareMode：指定共享属性，由于串口不能共享，该参数必须置为0； lpSecurityAttributes：引用安全性属性结构，缺省值为NULL； dwCreationDistribution：创建标志，对串口操作该参数必须置为OPEN_EXISTING；dwFlagsAndAttributes：属性描述，用于指定该串口是否进行异步操作，该值为FILE_FLAG_OVERLAPPED，表示使用异步的I/O；该值为0，表示同步I/O操作；hTemplateFile：对串口而言该参数必须置为NULL； 同步I/O方式打开串口的示例代码： HANDLE hCom; //全局变量，串口句柄
hCom=CreateFile("COM1",//COM1口
GENERIC_READ|GENERIC_WRITE, //允许读和写
0, //独占方式
NULL,
OPEN_EXISTING, //打开而不是创建
0, //同步方式
NULL);
if(hCom==(HANDLE)-1)
{
AfxMessageBox("打开COM失败!");
return FALSE;
}
return TRUE;
重叠I/O打开串口的示例代码： HANDLE hCom; //全局变量，串口句柄
hCom =CreateFile("COM1", //COM1口
GENERIC_READ|GENERIC_WRITE, //允许读和写
0, //独占方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c080576ad4852206ea159e815b70740f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcea8d974bea25ca65403ffabd52f22d/" rel="bookmark">
			WM 虚拟机下Ubuntu系统扩展硬盘容量教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以管理员身份打开， 命令提示符窗口，然后利用命令cd进入Oracle VM VirtualBox安装目录，如下图：
我进入了Oracle VM VirtualBox安装目录：D:\Program Files\Oracle\VirtualBox，然后输入VBoxManage list hdds，回车，查看需要扩容的虚拟硬盘的UUID，然后输入输入命令：VBoxManage modifyhd be05c3ee-3f64-4564-a3e5-7a00bfc4e233 --resize 102400，102400代表要把虚拟硬盘改成多少M。注意，在调整硬盘之前，一定要先关闭该虚拟机，要扩容的虚拟硬盘在以前创建时应该是动态增长的。
然后打开虚拟机，可以看到硬盘空间并没有变化，这是因为虚拟硬盘还没有扩展，这里以windows server 2008 R2虚拟机为例：
点击开始，管理工具里的共享和存储管理，如下图：
右击需要扩展的硬盘，然后填写需要更改的空间大小，确定，然后再查看硬盘的大小。
遇到linux磁盘空间不足的问题，于是网上找了一下，实际操作后，可行！ 如下办法可以办到：（网上搜集） http://hi.baidu.com/zidanexun/item/dd320caf9d38a6ab28ce9df0 ============================================================== 随着Linux虚拟机的不断使用，在VMware中经常遇到 预先装好的 linux 虚拟机的硬盘空间过小的问题，造成很多软件不能安装， 而重新装一个，又挺麻烦。于是，上网搜了下关于 vmware 硬盘扩容的方法。 总结如下：
1、挂载点必须是一个目录。
2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。
一：首先使用VMware工具扩容分配的硬盘空间：
1 、 vmware 提供一个命令行工具， vmware-vdiskmanager.exe ，位于 vmware 的安装目录下，比如
C:\Program Files\VMware\VMware Workstation\vmware-vdiskmanager.exe.
在 windows 下运行 cmd ，转到 vmware 的安装目录
vmware-vdiskmanager.exe 可以查看帮助
2. 对于扩容，可以输入下列命令：
vmware-vdiskmanager -x 50Gb "D:\VMware\WinXP\myLinux.vmdk"
注： 要扩容的系统这时不能在运行 ，参数 "-x" 表示要扩展虚拟机硬盘空间，紧随其后的数字是要扩展到的大小 ( 本例为扩展到 50GB ，这是一个磁盘总量，包含了原先的磁盘容量 ) 。最后是指定要操作的虚拟机磁盘的具体文件，要是路径名中有空格，必须以双引号括起来。按回车键开始执行，执行完毕，退出命令提示符窗口，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcea8d974bea25ca65403ffabd52f22d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb4090c09794b60215ab7b95757ce4a/" rel="bookmark">
			虚拟机中系统扩展硬盘分区大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现状：虚拟机C盘大小4G，需要扩充
由于当初为减小虚拟机大小，所以C盘只分了4G，随着安装的软件很多。C盘大小明显不够用。
1、先在虚拟机中，增加空间
先关闭虚拟系统，在其setting菜单中选择Hard Disk(IDE)
选择右侧中间的“Utilities”下拉菜单，选择Expand，
尺寸由4改成40。
在计算机管理中，选择磁盘管理，格式化新加的分区。
2、下载Acronis Disk Director Suite 10en工具
安装，输入序列号：WYGEP-HTE3J-64EHT-MFHRC-AJP8G；
打开Acronis Disk Director Suite，选择按钮中倒数第三个，双向箭头的按钮 Increase Free Space，
先选择C，再选择新增的分区，确定后第三个工具按钮会亮（旗帜），点击执行。
此时C盘由4G扩充到40G。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e2fc30a88f1e1580dfa0b30b794bd7/" rel="bookmark">
			Myeclipse配置jre&amp;Tomcat配置jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开MyEclipse，选择preferences菜单，
打开树Java节点，在选择Install JREs节点。
选择"add"按钮，选择Standard VM，next，点击JRE Home后的Directory...按钮。
浏览安装的jdk目录。例如：D:\javaenv\jdk1.7.0_01
点击Finish。
打开树MyEclipse，选择Servers节点，选择Tomcat 4.x。（MyEclipse只有Tomcat 4/5/6，实际可以随意配置，并不是4只能配置4。但无法自己扩充Tomcat菜单）
点击Tomcat4.x 选择JDK，选择jdk1.7.0_01
这样对应的Tomcat下的项目，则用jdk1.7进行编译。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae879869c52fd53fd8d857f3b580438/" rel="bookmark">
			Measurement Studio for Visual Studio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Measurement Studio 2010不再支持MFC，C#和BasiC才能使用measurement studio 2010,而C++不行。所以，如果打算在MFC中使用Measurement Studio组件，建议使用Measurement Studio8.6或2009。
8.6的下载地址：
http://www.verycd.com/topics/2726003/
序列号在文件中能找到：镜像文件/crack/serial
参考文章：
http://www.vihome.com.cn/bbs/forum.php?mod=viewthread&amp;tid=27077
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d32ea897aab5afe37540eee616f1d88/" rel="bookmark">
			淘宝TOP程序API接口接入教程--入门篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个中小型网站开发者，淘宝API的开放大大缩短了网站的开发周期和运作效率，面对海量的数据，开发者只要仔细阅读开发文档，熟悉相应的接口，就可以把数据导入自己的网站，这样就不必望洋兴叹了。
目前淘宝TOP的API接口正日益完善，但相应的接口和开发文档还不是很全，经过了3天的仔细研究，今晚上终于把淘宝API的调用弄明白了。不是很完善，文中如有瑕疵，还望批评指正，好，闲话到此为止，请看正文。本文是在测试环境下调用的淘宝API,虽然没有正式上线，但可以作为初学者对开发流程的一个入门。
首先登陆http://open.taobao.com/（淘宝开放平台），选择创建新应用：
2、然后填写表单数据，这里选择自用，应用架构类型选择B/S（WEB应用），应用名称.....这个不用我说了吧，我随便起了个DEMO：
3、创建成功后，淘宝会把AppKey和AppSecret发送到你的账户邮箱（每一个开通淘宝的账户都会有一个自己的绑定邮箱），注意查收自己的邮箱数据。
4、进入测试工具http://open.taobao.com/api_tool/api_test.html，界面如下：
在需要SessionKey的环境下测试，需要给测试工具提供一个SessionKey，很多人到这一步就纠结不清了，我在百度和GG差了很多资料，有幸在CSDN的一篇文章中找到了点线索，但不是很全面，没办法，只能靠自己摸索，好，继续讲解如何获取SessionKey，淘宝的测试工具指南是这样说的：
访问 http://open.taobao.com/isv/authorize.php?appkey={appkey}，选择测试环境账号并填写回调URL，例如回调URL填写为：http://localhost，然后点击“获取授权码”，即可获得授权码，接下来通过授权码获取SessionKey。访问http://container.api.tbsandbox.com/container?authcode={授权码}，页面会跳转到回调URL，http://localhost/?top_appkey={appkey} &amp;top_parameters=xxx&amp;top_session=xxx&amp;top_sign=xxx，回调url上的top_session即为SessionKey 好，我们继续，打开你的邮箱复制AppKey，粘贴到地址栏里：http://open.taobao.com/isv/authorize.php?appkey=你的AppKey,回车，出现如下界面，选择测试环境账号（测试环境账号都是淘宝免费提供的，任意选一个），输入回调地址:
点击“获取授权码”，出现如下界面：
复制文本框里的“授权码”，以如下格式粘贴到地址栏里：
http://container.api.tbsandbox.com/container?authcode={授权码} ，回车后会经过URL解析，然后把解析后的URL复制下来，得到如下格式：
http://www.local.com/?top_appkey=12136788&amp;top_parameters=aWZyYW1lPTEmdHM9MTI4NTc2OTY1MzMyOSZ2aWV3X21vZGU9ZnVsbCZ2aWV3X3dpZHRoPTAmdmlzaXRvcl9pZD0xNzU5NzgyNjkmdmlzaXRvcl9uaWNrPXNhbmRib3hfY18x&amp;top_session=2826927185d3ddf23ad60be9d2fec9a23f607&amp;top_sign=EewaMq%2BRYDXAXMxzR0u2nA%3D%3D
其中top_session就是我们最终得到的SessionKey，写到这我不得不发泄一些我的不满，我实在很讨厌这些步骤的繁琐，在这里给淘宝提一个意见，希望淘宝能改善改善接口的接入流程，使他更人性化一点，操作更友好一点，技术是为人服务的，经过这样的一番周折我感觉我一直在位技术服务，不是吗？好，我们继续。。。
得到SessionKey后，接下来的工作就方便多了，我们只需利用测试工具，得到我们想要的XML数据，经过XML解析，就可以为我为我所用了，如果有不明白的可以阅读淘宝的API开发文档，个人认为文档还是比较全面的：
选择应用程序名，粘贴SessionKey，然后提交测试，最后的测试结果就显示在右边的多行文本框里了，下图是我的操作结果，你做出来了吗？
我们把测试结果的XML数据粘贴到新建的XML文件里，用IE浏览器打开XML文件，如下图所示：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/313/">«</a>
	<span class="pagination__item pagination__item--current">314/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/315/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>