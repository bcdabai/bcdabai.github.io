<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e30568d83b6372f62ed72a847f6cb06/" rel="bookmark">
			vue3&#43;element-plus 封装列表页，分页，排序，导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景描述：
开发流程：
详细开发：
总结：
背景描述： web很多时候，要开发一个列表页，展示大量数据，并且提供一些交互功能，例如排序和分页，导出功能，有时候为了避免麻烦也会封装组件。下面使用 Vue 3 和 Element-Plus 来开发一个列表页。
这里，以一个系统日志的列表页为例。
开发流程： 创建一个名为 recordList.vue 的组件，该组件将用于展示系统日志。
一般这种页面都由三部分组成：
1.页面名称
2.搜索框
3.表格和分页
前两部分，往往和其他页面都是固定的样式，复用样式就行，表格和分页的样式也差不多一样，所以整个页面，大部分都是简单的，封装也比较好封装。
如图：
详细开发： 1.子组件——template(搜索组件是我自己封装的一套）
&lt;template&gt; &lt;div class="dashboard-container"&gt; &lt;el-card class="card-style"&gt; &lt;div class="mt-1"&gt; &lt;h2 class="fwb-mb-1"&gt;{{ listName }}&lt;/h2&gt; &lt;el-row&gt; &lt;!---搜索组件---&gt; &lt;SearchBox v-if="dataReady" :search-options="searchOptions" :showButton="true" :btnLoading="btnLoading" button-name="导出" @search="searchData" /&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;el-table v-loading="loading" :data="tableData" class="table-small-custom" height="calc(100vh - 240px)" stripe @sort-change="changeTableSort" &gt; &lt;el-table-column type="index" width="70" label="序号"&gt; &lt;template #default="scope"&gt; &lt;span v-text="getIndex(scope.$index)"&gt;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column v-for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e30568d83b6372f62ed72a847f6cb06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e940c6190b70a9011c3f33d43a6367aa/" rel="bookmark">
			windows下使用Anaconda Prompt安装软件包，报Permission deny的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在文件属性里面设置安全权限失败的前提下，解决的直接方法是：
以管理员身份运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978f3215784d1233ba91c6ebe7269aa0/" rel="bookmark">
			XLSX.utils.sheet_to_json() 数字格式转为字符串格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 raw 默认为true，设置为false就可以了
XLSX.utils.sheet_to_json(workbook.Sheets[sheet], {raw:false}) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16e779bf3f2b7b3e24dbf130d5045d2/" rel="bookmark">
			XLSX json转文本流 &amp; json转文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装一个公共 xlsx.js
import { read, utils, writeFile } from 'xlsx' // 文本流转json // 入参：文本流 回调 入参{} export const readJsonFromFile = (file, callBackFn, opt) =&gt; { const reader = new FileReader() reader.readAsArrayBuffer(file) reader.onload = function (e) { const workbook = read(e.target.result) console.info('excel读取结果：', workbook) const firstSheetName = workbook.SheetNames[0] const worksheet = workbook.Sheets[firstSheetName] // 读取header const data = utils.sheet_to_json(worksheet, opt) if (callBackFn) callBackFn(data) } } // json转文件 // 入参：文件数组[] 头数组[] 文件名字符串 export const readJsonToFile = (data, header, fileName) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c16e779bf3f2b7b3e24dbf130d5045d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb1a6907ce3f5e213ba5f49bd4ebcb8/" rel="bookmark">
			mit的BEVFusion代码学习——bevfusion.py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码位置：bevfusion\mmdet3d\models\fusion_models\bevfusion.py
from typing import Any, Dict import torch from mmcv.runner import auto_fp16, force_fp32 #auto_fp16 是一种自动混合精度训练的技术，允许在需要时自动切换精度，而 force_fp32 是一种显式指示使用单精度浮点数的选项 from torch import nn from torch.nn import functional as F from mmdet3d.models.builder import ( build_backbone, build_fuser, build_head, build_neck, build_vtransform, ) from mmdet3d.ops import Voxelization, DynamicScatter from mmdet3d.models import FUSIONMODELS from .base import Base3DFusionModel __all__ = ["BEVFusion"] #加载模块，bevfuion的pipeline #一旦类被注册，就可以在配置文件中指定要构建的融合模型类型，然后通过FUSIONMODELS.build(cfg)构建相应的类实例 @FUSIONMODELS.register_module()#装饰器用于将BEVFusion类注册到FUSIONMODELS注册表中 class BEVFusion(Base3DFusionModel): def __init__( self, encoders: Dict[str, Any],#字典[key(字符串),value(允许任何类型的值)] fuser: Dict[str, Any], decoder: Dict[str, Any], heads: Dict[str, Any], **kwargs, #用于接收额外的关键字参数 ) -&gt; None: super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb1a6907ce3f5e213ba5f49bd4ebcb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd378795aa88458dd99c18a852eb05b/" rel="bookmark">
			银行家算法-避免死锁的一个算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银行家算法是由艾德格·迪杰斯特拉（Edsger Dijkstra）于1965年提出的，用于管理并分配资源以避免死锁。该算法基于资源的最大需求量、可用资源数量和进程当前已分配的资源来进行决策。
银行家算法的主要思想是在分配资源之前进行安全性检查，以确保分配资源不会导致系统进入不安全状态，即不会发生死锁。它通过模拟分配资源的情况来判断是否存在安全序列，如果存在安全序列，则进行资源分配；否则，暂时阻塞进程，等待资源变得可用。
银行家算法的步骤包括：
初始化：对每个进程，确定最大需求量、已分配资源和可用资源。安全性检查：通过模拟分配资源的情况来判断是否存在安全序列。请求资源：当进程请求资源时，系统进行安全性检查，如果满足安全性条件，则分配资源；否则，进程等待。释放资源：当进程完成任务后，释放已分配的资源，更新可用资源。 银行家算法的核心目标是确保系统不会进入不安全状态，从而避免死锁的发生。它通过合理地分配和释放资源，以满足进程的需求，并保持系统的安全性。
需要注意的是，银行家算法要求在运行之前预先知道每个进程的最大资源需求量，这对于实际的应用场景可能不太实际。此外，银行家算法也需要考虑资源分配的顺序和策略，以确保公平性和效率性。因此，在实践中，需要综合考虑具体的应用场景和系统需求来选择合适的资源调度算法和策略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb69e62c7860fa2f87d8d14c1038921/" rel="bookmark">
			K8S监控（Prometheus&#43;Grafana&#43;alertmanager&#43;钉钉机器人告警）部署方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构就不细讲，网上一大堆都大同小异，但是自己在部署的过程中发现踩了很多坑，记录一下整个部署过程，开干！
一、部署K8S集群资源数据采集组件：kube-state-metrics yaml文件一共有5个：
1、cluster-role-binding.yaml apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: labels: app.kubernetes.io/component: exporter app.kubernetes.io/name: kube-state-metrics app.kubernetes.io/version: 2.3.0 name: kube-state-metrics roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: kube-state-metrics subjects: - kind: ServiceAccount name: kube-state-metrics namespace: kube-system 2、cluster-role.yaml apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: app.kubernetes.io/component: exporter app.kubernetes.io/name: kube-state-metrics app.kubernetes.io/version: 2.3.0 name: kube-state-metrics rules: - apiGroups: - "" resources: - configmaps - secrets - nodes - pods - services - resourcequotas - replicationcontrollers - limitranges - persistentvolumeclaims - persistentvolumes - namespaces - endpoints verbs: - list - watch - apiGroups: - apps resources: - statefulsets - daemonsets - deployments - replicasets verbs: - list - watch - apiGroups: - batch resources: - cronjobs - jobs verbs: - list - watch - apiGroups: - autoscaling resources: - horizontalpodautoscalers verbs: - list - watch - apiGroups: - authentication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccb69e62c7860fa2f87d8d14c1038921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dfdd6df02418c268b923bd76a1fc143/" rel="bookmark">
			超全教程丨如何正确使用java线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java框架中例如Tomcat、Dubbo等都离不开线程池，这些框架用到线程的地方，都会用线程池来负责。我们在使用这些框架的时候，会设置线程池参数，用于提高性能。那么开多少线程合适？今天我们将围绕这个问题来学习一下线程池。
平常我们使用java线程的时候，都是直接创建一个Thread对象，java线程的创建和销毁都会涉及到Thread对象的创建和销毁，线程切换等问题。创建Thread对象，仅仅是在 JVM 的堆里分配一块内存而已；而创建一个线程，却需要调用操作系统内核的 API，然后操作系统要为线程分配一系列的资源，这个成本就很高了。所以线程是一个重量级的对象，应该避免频繁创建和销毁。
一般可以通过“池化”思想来解决上述的问题，而JDK中提供的线程池实现是基于ThreadPoolExecutor。
使用线程池可以带来一系列好处：
降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
提高响应速度：任务到达时，无需等待线程创建即可立即执行。
提高线程的可管理性：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。
总体设计 顶层接口是Executor，java.util.concurrent.Executor#execute，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。
ExecutorService接口扩展了Executor并增加了一些能力：
扩充执行任务的能力，通过调用submit()或者invokeAll()方法可以为一个或一批异步任务生成Future的方法；
提供了管控线程池的方法，比如调用shutdown()等方法停止线程池的运行。
AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。
具体实现类是ThreadPoolExecutor，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。
ScheduledThreadPoolExecutor又扩展了ThreadPoolExecutor和ScheduledExecutorService接口，增加了调度能力，使任务可以延时定时执行。
另外还有一个提供了线程池创建的工厂方法的类Executors，用来创建线程池。
本章主要说明ThreadPoolExecutor的实现原理，ScheduledThreadPoolExecutor下篇会讨论。
ThreadPoolExecutor实现原理 ThreadPoolExecutor构造参数说明 ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ​ corePoolSize:表示线程池保有的最小线程数。核心线程数，这些核心线程一旦被创建，就不会被销毁。相反，如果是非核心线程，等任务执行完并长时间未被使用则会被销毁。
maximumPoolSize：表示线程池创建的最大线程数。
keepAliveTime&amp;unit：一个线程如果在一段时间内，都没有执行任务，说明很闲，keepAliveTime和unit就是用来定义这个一段时间的参数。也就是说，如果线程已经空闲了keepAliveTime和unit这么久了，而且线程数大于corePoolSize，那么这个空闲线程就要被回收。
workQueue：用来存储任务，当有新的任务请求线程处理时，如果核心线程池已满，那么新来的任务会加入workQueue队列中，workQueue是一个阻塞队列。
threadFactory：通过这个参数可以自定义如何创建线程。
handler:通过这个参数可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略，可以通过这个参数来指定
ThreadPoolExecutor已经提供了四种策略。
CallerRunsPolicy:提交任务的线程自己去执行该任务。
AbortPolicy:默认的拒绝策略，会throws RejectedExecutionException.
DiscardPolicy:直接丢弃任务，没有任何异常输出。
DiscardOldestPolicy:丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。
ThreadPoolExecutor执行流程 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dfdd6df02418c268b923bd76a1fc143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef4622ff1256086351a0e7b2969a785/" rel="bookmark">
			Vue 获取/设置指定组件高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 'split-pane-left-area’是要获取的组件class，可以通过浏览器F12调试，在样式页面查看class信息
目的：将div的高度设置和split-pane-left-area 组件的高度一致
动态绑定style &lt;div :style="{height: listHeight+ 'px'}"&gt; 获取元素高度：通过document.getElementsByClassName，offsetHeight属性即为页面组件的高度 &lt;div :style="{height: listHeight+ 'px'}"&gt; data() { return { listHeight: 565, }; }, mounted() { // 动态绑定审核方案列表高度，确保显示不会超出页面范围 if (document.getElementsByClassName('split-pane-left-area')[0].offsetHeight) { this.listHeight = document.getElementsByClassName('split-pane-left-area')[0].offsetHeight - 30; } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fddcf55025dc691da6dce77f4cd948b/" rel="bookmark">
			Docker安装Mongodb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、宿主机创建目录，存放mongodb配置信息、数据信息 mkdir -p /usr/local/mymongo/conf 二、参考官方配置文档，配置mongod.conf #在上面的conf目录下，创建mongod.conf systemLog: destination: file path: /var/log/mongodb/mongod.log logAppend: true storage: dbPath: /data/db net: bindIp: 0.0.0.0 port: 27017 setParameter: enableLocalhostAuthBypass: false security: authorization: disabled # 挂载配置文件 -v /usr/local/mymongo/conf:/etc/mongo # 挂载数据 -v /usr/local/mymongo/data/db:/data/db docker run -d --name my_mongo -v /usr/local/mymongo/conf:/etc/mongo -v /usr/local/mymongo/data/db:/data/db --restart=always mongo --config /etc/mongo/mongod.conf 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3ef4ad59a19345b24f6be9fe239d5c/" rel="bookmark">
			excel导出-将后端返回的文件流导出为excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的业务场景，需要前端自己将文本流导出为excel有的是后端返回的文本流，有的是调用上传组件后，前端组件生成的文本流，组件上传后点击上传的文件名，要求实现下载功能，这时的导出就需要前端自己处理了
直接上核心代码
// 点击文件下载 onPreview(fileData) { console.log('onPreview:', fileData) const link = document.createElement('a'); let blob = new Blob([fileData.raw], {type: 'application/x-excel'}); link.style.display = 'none'; link.href = URL.createObjectURL(blob); link.download = fileData.name; document.body.appendChild(link); link.click(); document.body.removeChild(link); } 上面 onPreview 的 console.log
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e2acaf5b6276272a0c026982c536e2/" rel="bookmark">
			PyTorch 中所有样本对的余弦相似度快速计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch 定义了 cosine_similarity 函数来计算向量对之间的余弦相似度。但是，目前还没有方法可以计算列表中每对向量之间的余弦相似度。我们将探索一种非常简单且有效的方法来在 PyTorch 中执行此操作。
我们先来看一个公式，这是计算余弦相似度的数学计算公式：
cosine similarity = S C ( A , B ) : = cos ⁡ ( θ ) = A ⋅ B ∥ A ∥ ∥ B ∥ = ∑ i = 1 n A i B i ∑ i = 1 n A i 2 ∑ i = 1 n B i 2 \text{cosine similarity}=S_C(A,B):=\cos(\theta)=\frac{\mathbf{A}\cdot\mathbf{B}}{\|\mathbf{A}\|\|\mathbf{B}\|}=\frac{\sum_{i=1}^nA_iB_i}{\sqrt{\sum_{i=1}^nA_i^2}\sqrt{\sum_{i=1}^nB_i^2}} cosine similarity=SC​(A,B):=cos(θ)=∥A∥∥B∥A⋅B​=∑i=1n​Ai2​ ​∑i=1n​Bi2​ ​∑i=1n​Ai​Bi​​
现在开始系统介绍如何在pytorch中高效计算多对向量之间的余弦相似度（多对向量组成矩阵形式，这在对比学习中经常使用到）
介绍 来自维基百科:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e2acaf5b6276272a0c026982c536e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a239aa910023da2f72a3899375e0de/" rel="bookmark">
			别人ping不通我的ip解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：关闭防火墙 方法二：开启ICMPv4 控制面板\系统和安全\Windows Defender 防火墙-----打开高级设置-----入站规则，开启域和专用两个 ICMPv4
方法三：更改共享选项 控制面板\网络和 Internet\网络和共享中心
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5698e0a8eef0740c3a7dc35955ac7b18/" rel="bookmark">
			pinia
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		* 1.pinia去除 mutations,modules&lt;模块分割&gt;，只有 state，getters，actions; * &lt;vueX 修改state的值都需要commit 一个mutations里的修改函数来修改，来达到追踪数据&gt; * &lt;vueX actions 处理异步时还需要dispatch 一个mutations里的修改函数来修改&gt; * 2. pinia 可以直接修改state或者$patch 或者调用actions中的方法 ，action支持同步和异步 * 3.没有modules模块，只有 store 的概念，store 之间可以自由使用，相互调用，更好的代码分割； * 4.足够轻量，压缩后的体积只有1.6kb;vueX 44kb * 5.支持持久化插件扩展，无需像vueX另外另外处理数据存储 安装 npm install pinia --save 在main.ts挂载 import { createApp } from 'vue' import App from './App.vue' import { createPinia} from 'pinia' // 使用pinia持久化插件 import piniaPluginPersist from 'pinia-plugin-persist' const pinia = createPinia() pinia.use(piniaPluginPersist) createApp(App).use(pinia) createApp(App).mount('#app') 定义State 在 src/store 下面创建一个user.ts import { defineStore } from 'pinia'; //引入另一个store.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5698e0a8eef0740c3a7dc35955ac7b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a21ebbbc0a00a3249cde71d206a5e305/" rel="bookmark">
			Flutter Icons内置图标库MaterialIcons大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只因网站太难打开，所以在这放预览图给各位客官解解馋
icon地址：https://material.io/tools/icons/?icon=sd_storage&amp;style=baseline
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e33b83ba6c681fa7c18cf9ffee88a6/" rel="bookmark">
			4.Vue-Vue调用第三方接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题记 用vue调用第三方接口，以下是全部代码和操作流程。
寻找第三方接口网站 推荐：免费API - 提供免费接口调用平台 (aa1.cn)
下面的代码以下图中的接口为例 安装axios模块 在终端输入以下命令： npm install axios
调用第三方接口代码 调用不需要设置参数的接口 TestView.vue文件如下： &lt;template&gt;
&lt;div &gt;
&lt;ul&gt;
&lt;!--&lt;li v-for="item in items" :key="item.id"&gt;{{ item }}&lt;/li&gt;--&gt;
&lt;!--使用了Vue的指令v-html，它会将组件的data属性的值作为HTML内容进行渲染--&gt;
&lt;div v-html="data"&gt;&lt;/div&gt;
&lt;!--使用了Vue的插值语法{{ }}，它会将组件的data属性的值作为文本进行渲染--&gt;
&lt;!--没有去掉p标签--&gt;
&lt;div&gt;{{ data }}&lt;/div&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
// 导入axios模块，使用axios来发送HTTP请求了
//export default是用于导出模块的语法
import axios from 'axios';
// const data = ref()
// const items = ref([])
export default {
//data()函数是用于定义组件的数据属性的方法
//data属性被初始化为空字符串，可以用来存储数据
data() {
return {
//items: [],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62e33b83ba6c681fa7c18cf9ffee88a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d8b0db78732a193ac423c9617455922/" rel="bookmark">
			如何将Anaconda安装时默认的python版本改成其他版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：命令行修改 1.win+R输入cmd进入命令行，在命令行里输入以下代码：
​​​​​​​conda activate 进入Anaconda的base版本 查看当前python版本号
python -Ｖ　（注意ｖ是大写） 2.查看可选择修改的版本
输入以下命令：
conda search --full --name python 3.选择需要修改成的版本号
执行代码（该过程可能时间很长，请耐心等待）
conda install python=3.7.5 若等待时间过长可以考虑权限问题，重新用管理员身份启动第一步即可
方法二：Anaconda.navigator修改 1.点击environments栏找到python选项可以看到目前python版本为3.8.8
2.点击python前面的绿色钩选择需要修改的版本后点击右下角的Apply按钮即可(该过程也能时间比较长，耐心等待即可)
我用的是第二种方法
2023.5.4 18:06
至
2023.5.4 22:55
完成；
差点准备把电脑待机一夜，历时5小时居然加载成功了，简直是逆了个大天！！！
完成展示1：
结果展示2：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534704d674151630edcf43af643eda51/" rel="bookmark">
			android开源投屏工具scrcpy简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，初识scrcpy
1.1 scrcpy介绍
1.2 scrcpy特点
二，scrcpy指令说明
2.1 画面设置
2.1.1 缩小分辨率
2.1.2 修改画面比特率
2.1.3 限制画面帧率
2.1.4 画面裁剪
2.1.5 锁定屏幕朝向
2.2 屏幕录制
2.3 连接方式
2.3.1 无线
2.3.2 多设备
2.4 窗口设置
2.4.1 标题
2.4.2 位置和大小
2.4.3 无边框
2.4.4 保持窗口在最前面
2.4.5 全屏
2.4.6 旋转
2.5 其它设置
2.5.1 只读
2.5.2 显示屏
2.5.3 保持常亮
2.5.4 关闭设备屏幕
2.5.5 关闭屏保
2.6 文件传输
2.6.1 安装APK
2.6.2 将文件推送至设备
一，初识scrcpy 1.1 scrcpy介绍 首先，我们来认识一下Scrcpy。
Scrcpy 是一个开源的命令行工具软件，被设计用于使计算机用户能通过android adb或通过usb数据线控制其Android设备，支持通过鼠标和键盘对Android设备操作，更重要的是无需root权限。
开源地址：https://github.com/Genymobile/scrcpy
电脑上安装scrcpy后，执行scrcpy命令，弹出镜像窗口如下，
1.2 scrcpy特点 免费开源无需root权限可以运行在Linux，Window和Mac系统上可以共享剪贴板轻量 （原生，仅显示设备屏幕）性能 （30~60fps）质量 （分辨率可达1920x1080或更高）低延迟 (35-70ms)快速启动 （数秒内即能开始显示）无侵入性 （不需要在安卓设备上安装任何程序） 二，scrcpy指令说明 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534704d674151630edcf43af643eda51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49139ef682de82f28eeeac6f352c6b12/" rel="bookmark">
			前后端分离Error: timeout of 10000ms exceeded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端判定的请求超时，超过前端约定时间后，就不会接受后端返回的结果了。
改这里，我用的若依的框架，前后端分离版。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b45b6ea26b20bcf87c898b22f1cc6f3/" rel="bookmark">
			如何在Linux环境中远程访问企业级夜莺监控分析工具？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. Linux 部署Nightingale2. 本地访问测试3. Linux 安装cpolar4. 配置Nightingale公网访问地址5. 公网远程访问Nightingale管理界面6. 固定Nightingale公网地址 前言 夜莺监控是一款开源云原生观测分析工具，采用 All-in-One 的设计理念，集数据采集、可视化、监控告警、数据分析于一体，与云原生生态紧密集成，提供开箱即用的企业级监控分析和告警能力。夜莺于 2020 年 3 月 20 日，在 github 上发布 v1 版本，已累计迭代 100 多个版本。
本地部署后,为解决无法远程访问的难题,今天我们介绍如何实现让本地nightingale 结合cpolar 内网穿透工具实现 远程也可以访问,提高运维效率.
1. Linux 部署Nightingale 本例子采用最快捷的部署方式,docker compose 进行部署,如果是正式生产环境,请参考官方高级部署方案,如果没有安装docker 或者docker compose,请提前安装好,为了方便克隆项目,Git也需要一起安装好.
首先使用Git克隆项目
git clone https://gitlink.org.cn/ccfos/nightingale.git 克隆后可以看到一个nightingale 文件
进入nightingale文件夹里的docker目录
cd nightingale/docker 执行docker compose 命令安装部署
docker-compose up -d 等待下载安装成功后,执行docker ps 即可看到运行的容器
2. 本地访问测试 上面成功安装了nightingale 服务,现在进行本地访问,在浏览器或者外部浏览器访问端口17000,即可看到登录界面,本地访问表示成功.输入默认账号root 和密码root.2020就可以成功登陆,下面我们安装cpolar 内网穿透工具实现远程访问.
3. Linux 安装cpolar 上面我们成功通过docker compose方式安装了Nightingale,下面我们在Linux安装cpolar内网穿透工具,通过cpolar 转发本地端口映射的http公网地址,我们可以很容易实现远程访问,而无需自己注册域名购买云服务器.下面是安装cpolar步骤
cpolar官网地址: https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b45b6ea26b20bcf87c898b22f1cc6f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d7bf2a4a76693e78544a853bd29a06/" rel="bookmark">
			Python123：求各序列的前n项和（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.求N分之一序列前N项和 题目：本题要求编写程序，计算序列 1 + 1/2 + 1/3 + … 的前N项之和。
输入格式： 输入在一行中给出一个正整数N。
输出格式： 在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后6位。题目保证计算结果不超过双精度范围。
输入样例： 6 输出样例： sum = 2.450000 代码1： #include&lt;stdio.h&gt; int main() { int a=1,b=1,i,N; double sum=1; scanf("%d",&amp;N); for(i=1;i&lt;=N-1;i++) { a=1; b=b+1; sum=sum+1.0*a/b; } printf("sum = %.6f",sum); return 0; } 代码2： #include&lt;stdio.h&gt; int main() { int i,n; double sum=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) sum+=1.0/i; printf("sum = %f\n",sum); return 0; } 2.求奇数分之一序列前N项和 题目：本题要求编写程序，计算序列 1 + 1/3 + 1/5 + … 的前N项之和。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d7bf2a4a76693e78544a853bd29a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4bab5d54107f5b5059ccbbb21a1b38e/" rel="bookmark">
			cst导入到ad并组成阵列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cst导出到ad画pcb板(不需要经过cad填充)
1.cst，pick point(快捷键p pick)
选中(注意选金属和介质连接的平面上的点，不要选只有金属的面，那样的话介质板上开孔就不能导出了)需要导出的平面上的点，tab，export，2d，dxf，保存
取消选中的点（快捷键d delete）
2.将需要导出的层逐层导出dxf文件（没有金属只有介质和瞳孔的层不需要导出）
cst里量一下单元边长，view，有一个尺子的图标，点一下，选中需要量的边长
CST2023真tm卡，建议用2022
一.单元的demo板
1.导入
ad，新建pcb文件，导入dxf，单位选择mm，层根据需要选择top layer或bottom layer。导入。
2.移动
选中，移动(上方快捷栏的xy轴标志，选择xy坐标的那个)，输入需要移动的距离，移动。
3.填充
填充。1）规则区域选择，放置填充。根据十字准星选中边缘角的点，填充。有缝隙不怕，实际板子无缝隙
2）不规则区域填充。选中闭合区域(选中方式：从右下到左上选中边，同时按住shift，选中闭合的几条边)，快捷键t(工具)＋v(选择)
＋e(填充选择区域)。进行不规则区域填充。
注意，有的区域尽头是过孔之类的，这样是不闭合的。要先删去过孔，画line，让区域闭合，然后填充，填充后再加上过孔。
对照cst文件，看哪里是需要填充金属的地方
4.加过孔(一般是用于固定的孔)
直接放置过孔，hole size=孔直径，cst里看孔的直接是多少
先放过孔
5.如果有需要加的元器件
导入封装，xy固定位置移动 旋转
二.阵列
1.ctrl c，编辑，特殊粘贴，阵列，选择线性，输入个数和间隔距离。不会出现阵列，左键点一下设置为原点，产生阵列，为一行或一列。1×N
2.再复制，生成多行多列形式。N×N
3.选中，移动标志，移动选中对象。移动至合适区域。
4.选中，设置板子形状。
5.定义板子形状
方法一：选中阵列，板子形状按照选中对象定义
方法二：沿着板子边缘画keepout layer
用shift+s，shift+s两次
只显示当前层（keepout layer层）
然后选中keep outlayer，板子形状按照选中对象定义
再shift +s ，显示全部层
6.加顶层和底层的阻焊层（top solder和bottom solder），使得上表面和下表面不铺绿油
7.中间挖空不铺铜的地方：选中，t+v+t
需要铺铜的地方：根据单元边长和移动的距离，精准设置铺铜的四个角坐标，设置clarence距离为0mm，重铺
8.边框如果没有金属，选中，转换为机械层mechanical1
9.注意看看移动的时候铺铜还有吗，别整丢了
10.依次画出各个独立的板子
后续用连接杆（金属）连接
这相当于是空气介质的超表面，目的是介质太后了，不能加工，所以可以用空气介质，可以把介质板（空气）厚度做的比较厚
三.ad技巧
滚轮：上下移动
右键：平移
shift+滚轮：左右移动
ctrl+滚轮：放大缩小
0：正视图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4981d370c5231e7d0e676e9bc1bed8a/" rel="bookmark">
			Ue4 ＜uasset文件怎么存入现有项目的content目录中＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体步骤 有时候真觉得自己脑袋掉帧，网上很多简单粗暴的语句自己都听不懂）
1.打开你所在项目的路径，如图
2.打开Content目录
3.把已经存放有uasset的文件夹复制到content目录下
4.运行ue4，即可使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce6d54c0cbd3a6d587ab6b3651d68e5/" rel="bookmark">
			Java SimpleDateFormat linux时间字符串转时间轴的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mon Oct 16 09:51:28 2023
这是linux 的 date命令得到的时间，要转换称时间戳。
EEE MMM dd HH:mm:ss yyyy
这样的格式，看起来就是正确的，可是就是报错
Unparseable date: "Mon Oct 16 09:51:28 2023"
下面是正确的代码
String[] fmts = new String[] {"EEE MMM dd HH:mm:ss yyyy", "EEE, MMM d, ''yy"}; String[] vs = new String[] { "Mon Oct 16 09:51:28 2023", "Wed, Jul 4, '01"}; for(int i=0; i&lt;fmts.length; i++) { try { SimpleDateFormat dateFormat = new SimpleDateFormat(fmts[i], Locale.ENGLISH);// Date date = dateFormat.parse(vs[i]); str = (date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce6d54c0cbd3a6d587ab6b3651d68e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ab4bd59d0c31b86901e4925ed650e5/" rel="bookmark">
			有源医疗器械产品技术要求附录A如何编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有源医疗器械技术要求编写要求之附录内容 一、附录A中主要安全特征内容 有源医疗器械产品技术要求附录A中的内容是医疗器械注册时审评中心关注的一个重点内容，同时也是使产品符合标准的要求。
根据 GB9706.1-2020《医用电气设备 第1部分:基本安全和基本性能的通用要求》和 YY9706.102-2021《医用电气设备 第1-2部分:基本安全和基本性能的通用要求 并列标准: 电磁兼容要求和试验》，技术要求附录 A 中主要安全特征内容如下图所示:
二、附录内容简介 1、按防电击类型分类: 根据 GB 9706.1-2020 第5.1条：按照防电击的类型分类可以分为以下几类： 1)I类设备: 具备保护接地，通俗的讲，电源线为三个插脚(含地线)
2)II类设备:电源线为两个插脚(不含地线)(注意:使用功能接地的I 类设备也可能电源线为3个插头)
3)内部电源设备：电源置于设备内部，提供设备工作所需电能的设备
4)具有网源连接装置的双重组合分类，如具有网电源连接装置的内部电源设备(也可其他类型组合，如: I类内部电源类设备)
总结：电源线两个插脚的一定是II类设备，电源线三个插脚的不一定是I类设备。
2、按防电击的程度分类: 根据GB 9706.1-2020第 5.2条:按防电击的程度可以分为以下几类:
1)B型应用部分:对电击有特定防护程度的设备，符合本标准要求，尤其是漏电流容许值要求，也就是只要带应用部分最低就要是B型
2)F型应用部分:与设备其他部分相隔离的应用部分，其绝缘达到，当来自外部的非预期电压与患者相连，并因此施加于应用部分与地之间时，流过其间的电流不超过单一故障状态时患者漏电流的容许值
3)BF型应用部分:有 F型应用部分的型设备，对电击的防护能力和漏电流容许值均不低于 B 型应用部分，而且应用部分应该与其他带电电路和大地进行 F型浮动隔离
4) CF 型应用部分: 直接用于心脏的设备或设备部件必须为 CF 型。CF 型和 BF型在结构上一致，但 CF 可以直接应用于心脏部位，BF 型却不能，CF 型的患者漏电流容许值为 BF型的 1/10
3.按对进液的防护程度进行分类: 根据 GB/T 4208-2017 外壳对有害进液防护程度来区分可分为9个级别(如下图所示):
1) 防水等级书写:IPX5:略第一位特征数字(IP2X: 省略第二位特征数字，为仿固体异物进入)
2)不防水等级可以写为:IPX0
3)其他防水等级:由制造商自己根据实际设计情况进行声称，每个等级都有相对应的试验方法，检验方法详见 GB/T 4208-2017 的要求
4.按在与空气混合的易燃麻醉气或与氧或氧化亚氮混合的易燃麻醉气况下使用时的安全程度分类: 1)AP型:指在正常使用和正常状态下，设备、设备部件或元件必须不会点燃与空气混合的易燃麻醉气
2)APG 型:指在正常使用或单一故障状态时，设备、设备部件或元件必须不会点燃与氧或氧化亚氮混合的易燃麻醉气
3)非AP/APG型:不能在有易燃麻醉剂的情况使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ab4bd59d0c31b86901e4925ed650e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db1555dfc19ced3922651253dc8b2f5/" rel="bookmark">
			java工具类 MB GB TB PB和Mbps之间的转换及编程实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机网络和通信中，Mbps (兆比特每秒)和MB/s (兆字节每秒)是常用的单位,用于示数据传输速度或带宽。虽然它们都表示每秒传输的数据量，但Mbps和MB/s使用的是不同的计量单位，因此在进行转换时需要注意。
首先，我们来了解Mbps和MB/s之间的换算关系。1 Mbps等于1兆比特每秒，而1字节等于8比特。因此，要将Mbps转换为MB/s, 需要将Mbps除以8。换句话说，1 MB/s等于8 Mbps。
下面是java代码实现工具类
MB GB TB PB转换Mbps
public class DataRateConverter { private static final double MB_TO_Mbps = 8.0; private static final double GB_TO_Mbps = 8.0 * 1024; private static final double TB_TO_Mbps = 8.0 * 1024 * 1024; private static final double PB_TO_Mbps = 8.0 * 1024 * 1024 * 1024; public static double convertToMbps(String data, String unit) { double value; try { value = Double.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8db1555dfc19ced3922651253dc8b2f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63159431a039acd04c92cc3438f00f40/" rel="bookmark">
			怎样正确做 Web 应用的压力测试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web应用，通俗来讲就是一个网站，主要依托于浏览器来访问其功能。 那怎么正确做网站的压力测试呢？ 提到压力测试，我们想到的是服务端压力测试，其实这是片面的，完整的压力测试包含服务端压力测试和前端压力测试。 一、Web应用（网站）压力测试范围，包含前后端 Web应用（网站）最开始是不分前后端的（所以，那段时间PHP这门专门用于建站的语言非常火），后来随着网站功能越来越丰富，前后端不分离的架构显得低效和落后，这时候前后端分离的架构应用而生（PHP从此衰弱了）。 在前后端分离的架构模式下，前后端工程师约定好数据交互接口，实现并行开发。所以，一个Web应用（网站）其实是包含前端和后端两个独立的部分。 前后端分离 Google DoubleClick 研究表明：如果一个网页加载时长每增加 1 秒，用户就会流失 10%，加载时长超过 3 秒，用户就会离开。 因此，对于一个新的Web应用来说，除了常见的服务端压力测试，前端的压力测试也是不可或缺的。一个完整的web应用压力测试流程如下图所示： 二、前后端压测流程 step1、确定压测范围和压测目标 压测范围：如果是全新的项目，原则上所有的功能和接口基本都要压测。如果是老项目新增需求，则需要评估影响范围，以便确定老的功能和接口是否需要压测。 压测目标：如果是全新的项目，要根据行业内的基本情况和经验定一个预估目标；如果是老项目，可以根据历史流量峰值作为参考目标。 step2、制定压测方案 根据上一步的预期目标，制定压测方案。具体包含：压测环境，压测时间，相关负责人，测试工具或平台，验收标准。 压测环境：为了还原真实的压力场景，一般选择预发环境或生产环境进行压测。 压测时间：压测一般在功能测试或接口测试完成后介入。 压测工具或平台：前端压测可以使用PageSpeed等平台，后端压测一般会使用 jmeter、loadrunner等工具。（详细内容见补充1，补充2） 验收标准：一般来说要达到压测目标的预估值。 3、压测准备 压测机：准备好压测机群（后端用），用于发送请求。 服务器：由于压测流量会较高，所以需要提前准备服务器集群，用于承接流量或扩容使用 数据准备：准备用于压测的数据，一般来说要和真实数据做区分。准备压测脚本，添加标识，以便于和真实流量区分。 4、实施压测 施压：在施压的过程中，从较小流量开始，逐步加压。 观察：在逐步加压的过程，需要观察rt、error(报错率)、服务器的cpu、内存使用率等数据，如发现异常要及时停止压测，待排查和解决问题后再进行压测。 5、压测观察&amp;瓶颈分析 如何判断应用的承受能力？ 在压测过程中观察报错率、响应时间等指标，如出现指标异常，则说明流量达到当前的瓶颈，需要停止压测分析并排查原因。 以下是几种常见异常的分析方法： ·成功率未达标：查看错误日志，排查错误根本原因，进行性能调优 · 响应时间未达标：对照错误日志、链路追踪结果、服务器性能指标、数据库/中间件监控指标，找到响应时间过长的具体原因 · 吞吐量未达标：如果成功率和响应时间均达标，建议不断增加模拟用户数，重新压测，查看测试结果 什么时候需要增加服务器？ 在上一步出现瓶颈调优之后，继续加压，观察各项指标： · 第一种情况：服务器cpu、内存等指标均未达瓶颈（通常以使用率达到70%-80%为瓶颈），qps、rt、报错率等指标出现异常，此时需要重复上一步，排查问题并优化 · 第二种情况：rt、报错率等指标未出现异常，服务器cpu、内存使用率即将达到瓶颈，且未达到预期的压测目标，此时无法通过调优来解决，需要增加服务器。 服务器指标监控 6、验收 达到预期目标：达到预期目标，一般可以认为压测通过。 未达到预期目标：如因各方面原因（资源、预算等）未达预期目标，需要产品经理和研发经理对压测结果确认。 7、发送压测报告 8、项目上线 前面的步骤都完成之后，项目可以发布上线。 三、补充前端该如何压测 Google 开发者提出了一种 RAIL 模型来衡量应用的前端性能，即 response（响应）、animation（动画）、idle（空闲）与load（加载）。 RAIL 模型的广泛使用关键指标如下： 工具使用：PageSpeed PageSpeed 是 google 一个开源的自动化工具，安装 PageSpeed 扩展程序运行即可 报告结果如图： 该工具功能丰富，报告也非常详细，并给出了优化建议，根据测试报告做对应的优化即可。 四：补充后端该如何压测 后端即指服务端，后端压测就是服务端压测，也可以称为服务器压力测试。 在压测过程中，一般关注下面几个指标：qps(处理的请求量)、rt(响应时间)、error（报错率）、cup(cpu使用率)、mem(内存占用情况)、load(负载)、traffic(网络速率)。 通过观察qps、rt、error等关键指标，找到服务器的性能瓶颈，如果低于预期，则需要调优。 通过压力测试，提前发现服务器瓶颈，及时优化，避免网站一上线就奔溃。 工具：压测常用的工具有LoadRunner和Jmeter。 Jmeter 是一款使用Java开发的，开源免费的测试工具， 主要用来做性能测试，JMeter 可以用于对服务器、网络或对象模拟巨大的负载，有丰富的图形界面+脚本配置，方便易用。 LoadRunner 是一种预测系统行为和性能的负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题。 最后：下方这份完整的软件测试视频教程已经整理上传完成，需要的朋友们可以自行领取【保证100%免费】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63159431a039acd04c92cc3438f00f40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652e9923ffdd889044507daa7304830f/" rel="bookmark">
			idea使用debug无法启动，使用run可以启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、将调试断点清除
使用快捷键ctrl + shift + F8，将勾选的选项去除即可
2、Error running 'SampleApplication': Command line is too long. Shorten command line for SampleApplication or also for Spring Boot default configuration，报这种错误，说明springboot项目启动命令过长！debug也无法启动
再次使用debug模式重启项目， 我这边可以重启成功....
路漫漫其修远兮，吾将上下而求索......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6415005c79077094bb80ea2bf33722/" rel="bookmark">
			Android串口开发之使用JNI实现ANDROID和串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语：Android串口通信在物联网、智能家居等领域具有广泛的应用。本文将详细介绍如何使用JNI技术实现Android设备与串口的通信，包括串口的打开、设置参数和读写数据等过程。
目录 一、背景知识二、环境准备三、创建Android串口项目四、串口通信相关代码实现和JNI调用五、测试与调试六、注意事项 一、背景知识 在开始介绍Android串口开发之前，我们需要了解以下几个概念：
JNI：JNI（Java Native Interface）是一种编程框架，它允许Java应用程序调用和被C/C++代码调用。在Android开发中，通过JNI可以实现Java层和底层库之间的交互。串口通信：串口通信是指通过串口（串行端口）进行数据传输的通信方式，它适用于距离较短、通信速率不高、稳定性要求较高的场景。在Android开发中，常用串口通信来与硬件设备进行数据交互。 二、环境准备 在进行Android串口开发之前，我们需要准备以下开发环境：
Android Studio：作为Android开发的主要集成开发环境，我们需要在Android Studio中进行项目的创建和编码工作。JDK：安装Java Development Kit（JDK）以支持Java编程。SerialPort库：通过SerialPort库，我们能够实现Android与串口设备之间的通信。这个库可以从GitHub上获取。 三、创建Android串口项目 首先，我们需要在Android Studio中创建一个新项目，然后根据项目需求进行相关配置。接下来，我们需要导入SerialPort库到Android项目中。在build.gradle文件中添加SerialPort库的依赖，然后进行Sync操作，确保库已成功导入。
四、串口通信相关代码实现和JNI调用 创建SerialPortHelper类，在该类中实现串口的打开、设置参数和读写数据等功能。具体的代码实现可参考以下示例： public class SerialPortHelper { private static final String TAG = "SerialPortHelper"; static { System.loadLibrary("serial_port"); } // JNI方法调用，打开串口 public native boolean openSerialPort(String device, int baudRate); // JNI方法调用，关闭串口 public native void closeSerialPort(); // JNI方法调用，写入数据到串口 public native int writeData(byte[] data); // 处理读取到的数据 private void processData(byte[] buffer, int size) { // 在这里编写你的数据处理逻辑 } } 在项目的JNI目录下创建C/C++源文件，如serial_port.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6415005c79077094bb80ea2bf33722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/108fc076ec7d9abd46fe789f8d8cd4af/" rel="bookmark">
			【JS逆向】慕课网m3u8源文件解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function imoocJieMi(t, e) { function r(t, e) { var r = ""; if ("object" == typeof t) for (var n = 0; n &lt; t.length; n++) r += String.fromCharCode(t[n]); t = r || t; for (var i, o, s = new Uint8Array(t.length), a = e.length, n = 0; n &lt; t.length; n++) o = n % a, i = t[n], i = i.toString().charCodeAt(0), s[n] = i ^ e.charCodeAt(o); return s } function n(t) { var e = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/108fc076ec7d9abd46fe789f8d8cd4af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d33b95d635354aba68074d882cb3af/" rel="bookmark">
			计算机毕设ssm个人相册管理系统2uhbg9 独有（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
ssm + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 系统用例分析 3.3.1 管理员用例图 个人相册管理系统的最大权限用户是管理员，通过管理员菜单中的系统首页，个人中心，用户管理，相册分类管理，个人相册管理，投诉反馈，交流分享，系统管理等选项来对系统后台信息进行管理。管理员用例如图3-7所示。
图3-7管理员用例图
3.3.2 用户用例图 用户进入系统可以对系统首页，个人中心，个人相册管理进行管理。用户用例如图3-8所示。
图3-8用户用例图
系统结构设计 系统结构设计必须要满足用户的业务需求，系统结构设计完成后要形成系统结构设计文档，开发人员就可根据模块接口说明进行接口开发，接口开发完需进行功能测试，目的是发现并解决系统漏洞，同时还得保证系统的可扩展性和稳定性，满足用户对系统的要求。系统设计需满足以下要求：
安全性易用性柔软性柔软性扩展性 个人相册管理系统的整体结构设计主要分为两大部分：管理员和用户。管理员的职责是管理用户信息及设置用户权限，发布公告等其他基础功能的管理；用户主要负责对个人相册管理进行管理。整体结构设计如图4-2所示。
图4-2 整体结构设计图
4.3 数据库设计 本系统依赖于MySQL数据库来储存信息，系统完成后，所有需要的数据都要从数据库中读取，这也意味着无论是插入、更新还是删除操作，只要对数据有改动的操作都需要与数据库交互，因此，系统的全部数据都要储存在数据库，必须保证数据库在未经授权情况下不得进行删除表结构等危险操作，而且要保证表中字段的准确性。
4.3.1 数据库设计原则 从上而下从下至上逐渐扩大结合方法 4.3.2 数据库实体 E-R图，即实体-联系图，它是一种通过对实例进行抽象，以可视化的方式来描述现实世界的概念模型。根据需求分析绘制出数据库的E-R图，能够直观地映射出各个表之间的关系。
本系统的实体属性图如下图所示：
1、关于我们实体图如图4-3所示：
图4-3关于我们实体图
2、公告信息实体图如图4-4所示：
图4-4公告信息实体图
3、投诉反馈实体图如图4-5所示：
图4-5投诉反馈实体图
4、交流分享实体图如图4-6所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d33b95d635354aba68074d882cb3af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba3a9f395a87f4b9e35bcb386dfcd3d7/" rel="bookmark">
			selenium 驱动 Edge浏览器,解决selenium打开Edge浏览器闪退问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Edge浏览器驱动下载 1、在设置中查看浏览器的版本号
2、在官网中进行对应下载
Microsoft Edge WebDriver - Microsoft Edge Developer
二、环境变量配置 1、打开设置界面
右击【此电脑】---选择【属性】----选择【高级系统设置】-----点击【环境变量】
2、变量设置
在【系统变量】选项中，选择【Path】----》点击新建
将Edge浏览器驱动的路径粘贴进来即可---点击确定保存
三、基本使用 # 相关模块导入 from selenium import webdriver # selenium 4版本必须要设置浏览器选项，否则会闪退 option = webdriver.EdgeOptions() option.add_experimental_option("detach", True) # 实例化浏览器驱动对象，并将配置浏览器选项 driver = webdriver.Edge(options=option) # 设置要打开的目标url,这里以百度为例 url = "https://www.baidu.com" # 使用驱动对象打开网页 driver.get(url=url) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164ba0b91a7936db37c072e2a377feca/" rel="bookmark">
			报错-cv_bridge报错: ImportError: dynamic module does not define module export function (PyInit_cv_bridge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 现象原因解决方法 现象 当执行xx.py ，有如下报错：
Traceback (most recent call last): File "&lt;frozen importlib._bootstrap&gt;", line 971, in _find_and_load File "&lt;frozen importlib._bootstrap&gt;", line 955, in _find_and_load_unlocked File "&lt;frozen importlib._bootstrap&gt;", line 658, in _load_unlocked File "&lt;frozen importlib._bootstrap&gt;", line 571, in module_from_spec File "&lt;frozen importlib._bootstrap_external&gt;", line 922, in create_module File "&lt;frozen importlib._bootstrap&gt;", line 219, in _call_with_frames_removed ImportError: dynamic module does not define module export function (PyInit_cv_bridge_boost) ..... ImportError: dynamic module does not define module export function (PyInit_cv_bridge_boost) 原因 在ROS中默认使用python2，rospy的cv_bridge默认也是python2版本的，在使用python3中导入cv_brdige时会报出以上错误.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/164ba0b91a7936db37c072e2a377feca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6f71911179bc7c8218c3a300c20ace/" rel="bookmark">
			计算机毕设ssm骨科医院信息管理系统设计实现v0lr89 独有（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
ssm + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 系统需求分析 需求的分析中用户需求就是比较的重要，而且可以通过各种的路径，以及各每个用户对于系统的功能需求，你需要对这些内容做出整理以及分类，然后分析这些需求的现实情况下的可能原因，还需要有认真的分析过程，结合现实的情况下最终做出一系列的需求资料。在有关用户的期望分析中能够明确一些可能实现的情况，骨科医院信息系统功能是许多个可以测试的功能相结合的，正是由于这些功可以使得用户能够更加积极的提供出需求，让系统功能可以变得更加的完善。这样就可以保证所有设计的功能模块都是可以用到的，而且也是可测试的，对于后续系统的开发能够有比较关键的作用，也能快速完成用户所提供的需求[9]。
本课题要求实现一套骨科医院信息系统，系统主要包括管理员、医生和患者三大功能模块。
（1）管理员用例图如下所示：
图3-1管理员用例图
（2）医生用例图如下所示：
图3-2医生用例图
（3）患者用例图如下所示：
图3-3患者用例图
为了更好的去理清本系统整体思路，对该系统以结构图的形式表达出来，设计实现该骨科医院信息系统的功能结构图如下所示：
图4-1 系统总体结构图
4.1 数据库设计 4.1.1 基于MySQL数据库的存储设计 在MySQL数据库管理平台上进行了系统的开发。在进行了系统架构的基础上，结合MySQL应用的特性，开发了相应的数据库，并对其进行了存贮和总体的体系架构。数据技术要求数据删除，修改，添加，查询等功能，并对数据进行维护与管理。并针对特定组织优化程序级应用服务。习惯统一管理和维护删除、修改、添加、查询功能[10]。
MySQL数据库主要包括两个部分：指令行和操作接口。该方法利用SQL语句和数据库操作指令来建立数据库，并设计并存储数据库表。但是，命令行的运行模式对操作员的技术要求很高，而且在整个系统中也很难被发现。
4.1.2 数据库E/R图 ER图是由实体及其关系构成的图，通过E/R图可以清楚地描述系统涉及到的实体之间的相互关系。在系统中对一些主要的几个关键实体如下图：
1、医生实体图如图4-2所示：
图4-2医生实体图
2、线上挂号实体图如图4-3所示：
图4-3线上挂号实体图
3、患者实体图如图4-4所示：
图4-4患者实体图
4、药方信息实体图如图4-5所示：
图4-5药方信息实体图
系统功能实现
当人们打开网站的网址后，首先看到的就是首页界面。在这里，人们能够看到骨科医院信息系统的导航条和网站公告等。网站首页界面如图5-1所示： 图5-1 系统首页界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba6f71911179bc7c8218c3a300c20ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f850a4fc580fbd730a7df52a8966601/" rel="bookmark">
			Vue2(一)：初识Vue，模板语法、数据绑定、el和data的两种写法、MVVM、数据代理、事件相关内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Vue21.Vue是什么2.Vue特点3.初识Vue4.模板语法1.插值语法2.指令语法 5.数据绑定1.单向数据绑定（v-bind）2.双向数据绑定（v-model） 6.el和data的两种写法1.el的两种写法2.data的两种写法 7.MVVM模型8.数据代理1.Object.defineProperty方法2.什么是数据代理？3.Vue中的数据代理 9.事件相关内容1.事件处理2.事件修饰符3.键盘事件4.补充两个细节4.补充两个细节 Vue2 1.Vue是什么 一套用于构建用户界面的渐进式Javascript框架
构建用户界面:把数据通过某种方式转变成用户看的见的界面
渐进式:Vue可以自底向上逐层的应用（比方说简单的应用：只需一个轻量小巧的核心库，复杂的应用：可以引入各式各样的Vie插件，可以保证无论是简单的还是复杂都有办法）
2.Vue特点 1.采用组件化模式，提高代码复用率、且让代码更好维护。
2.声明式编码，让编码人员无需直接操作DOM,提高开发效率。
3.使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点。
3.初识Vue Vue实例中的el和data
·el: 用来指定当前Vue实例为哪个容器服务，值通常为css选择器字符串
·data: 用来存储数据，数据给el指定的容器所使用，注意，一旦data中的数据发生更改，Vue模板就会重新解析，这样页面中用到data的地方都会自动更新。data的值可以写成对象，也可以写成函数（后面组件会讲 &lt;!-- 准备好一个容器 --&gt; &lt;div id="root"&gt; &lt;h1&gt;初识Vue 2023.10.13&lt;/h1&gt; &lt;h1&gt;Hello,{{name}}&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建一个Vue实例 new Vue({ el: '#root',//e1用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。 data: { //data中用于存储数据，数据供el所指定的容器所使用,值我们暂时先写成一个对象 name: 'Vue', } }); &lt;/script&gt; 3.总结
1、想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象。
2、root容器里代码依然符合HTML规范，只不过混入了一些特殊的Vue语法。
3、root容器里的代码被称为【Vue模板】。
4、Vue容器与与Vue实例是一对一关系，一个容器只能被一个Vue实例接管，一个Vue实例只能接管一个容器。
5、真实开发中只有Vue实例，并且会配合着组件一起使用。
6、{{xxx}}中的xxx要写js表达式（不能写if，for这样的js代码），且xxx可以自动读取到data中的所有属性。
7、一旦data中的数据发生改变，那么模板中用到该数据的地方也会自动更新。
4.模板语法 1.插值语法 功能：用于解析标签体内容。也就是插值语法都是写在html标签内容里的
写法：{{xxx}},xxx是js表达式，且可以直接读取到data中的所有属性。
2.指令语法 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件等等）。
举例：v-bind:href="xxx"或简写为:href=“xxx”,xxx同样要写js表达式，且可以直接读取到data中的所有属性。
备注：Vue中有很多指令，且形式都为：v-???，此时仅用v-bind举例。
&lt;body&gt; //准备好一个容器 &lt;div id="root"&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h2&gt;你好，{{name}}&lt;/h2&gt; &lt;hr&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f850a4fc580fbd730a7df52a8966601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ddebe11e989105bd074bc787c9fcc8a/" rel="bookmark">
			ZYNQ 调试和固化程序方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZYNQ 调试和固化程序方法 固化程序 1、首先将开发板启动模式改为JTAG模式，将PS_MIO4 和PS_MIO5 拨到0，
然后选择如下：
调试debug 选择对应工程，然后右键，
选择后点击debug即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660806ef90abdc4dc11aa905e842a5ea/" rel="bookmark">
			Android模拟器如何安装搜狗输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android模拟器如何安装搜狗输入法 步骤： 本地下载搜狗输入法安装包x86版本，并存放到任意一盘例如：F:/data/sougou.apk打开cmd命令窗口，输入adb命令进行软件安装:adb install F:\data\sougou.apk安装成功后，打开模拟器在界面上点击搜狗输入法软件，进行输入法设置 注意： 可能会安装失败，换个版本试试使用adb命令之前确保安装了adb，以及确保adb start-server以及adb connect了对应设备的id下载的安装包尽量不要放在根目录，可能会安装失败，建议新建文件夹，例如上述的data文件夹直接将安装包拖拽到模拟器中可能会报错，所以可以尝试adb命令进行安装 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8332edbac60b52b2cf5937b960f21d37/" rel="bookmark">
			【工具】html请求 Content-Encoding=br 返回值乱码的问题 解码返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【工具】Content-Encoding=br 解码返回值
添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.brotli&lt;/groupId&gt; &lt;artifactId&gt;dec&lt;/artifactId&gt; &lt;version&gt;0.1.2&lt;/version&gt; &lt;/dependency&gt; 代码
public static String 解码br(InputStream is) { try { BrotliInputStream stream = new BrotliInputStream(is); BufferedReader reader = new BufferedReader(new InputStreamReader(stream)); StringBuilder result = new StringBuilder(); String str = null; while ((str = reader.readLine()) != null) { result.append(str); } return result.toString(); } catch (IOException e) { e.printStackTrace(); return null; } finally { IOUtils.closeQuietly(is); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceda0cb438c03ea533bba2f2139a6fb5/" rel="bookmark">
			BIM如何通过3D开发工具HOOPS实现WEB轻量化？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着建筑行业的数字化转型和信息建模技术的不断发展，建筑信息模型（BIM）已经成为设计、建造和管理建筑项目的标准。然而，BIM模型通常包含大量的数据，导致在Web上的传输和查看效率低下。为了解决这一挑战，HOOPS技术（Highly Optimized Object-Oriented Parallel Software）崭露头角，为BIM模型实现了Web轻量化，提高了性能、可视化质量和用户体验。
HOOPS中文网http://techsoft3d.evget.com/
BIM和其挑战
BIM是一个综合性的数字建模方法，它将建筑设计和施工过程中的所有信息整合到一个统一的三维模型中。这使得项目的各个阶段之间更加协调和一致，有助于提高项目的效率和质量。然而，随着项目的发展，BIM模型通常变得庞大复杂，包含数百万个元素、几何数据和属性信息。这些庞大的BIM模型在Web上的传输和交互变得非常具有挑战性。
BIM数据的传输需要大量的带宽和时间，而在Web浏览器中查看这些模型通常需要强大的计算机和图形渲染能力。此外，对于移动设备用户而言，这一问题尤为突出。为了解决这一问题，建筑和工程行业需要一种方法，能够在Web上轻松查看、分析和与BIM模型互动，而无需耗费大量资源。这就是HOOPS技术出现的原因。
HOOPS技术的概述
HOOPS技术是一种用于图形和三维数据可视化的高度优化的软件技术。它具有多方面的功能，包括几何处理、图形渲染、交互性、动画、数据压缩和跨平台支持。这使得HOOPS技术成为实现BIM模型的Web轻量化的理想选择。
以下是HOOPS技术如何助力BIM实现Web轻量化的关键方面：
1.高性能的几何处理
HOOPS技术能够高效地处理BIM模型中的复杂几何数据。它采用先进的几何算法，可以快速执行各种几何操作，如剖面分析、体积计算和碰撞检测。这有助于加速BIM模型的加载和操作，提高用户的工作效率。
2.数据压缩和优化
HOOPS技术可以将BIM数据进行压缩和优化，减少数据传输的带宽需求。通过消除冗余数据和使用高效的数据结构，它可以显著降低传输时间，并减少存储成本。这对于在线协作和云端BIM应用非常重要。
3.跨平台支持
HOOPS技术是跨平台的，可以在各种操作系统和设备上运行，包括Windows、Mac、iOS和Android。这意味着BIM模型可以在不同平台上无缝查看和编辑，提供更广泛的可访问性。
4.高质量的图形渲染
HOOPS技术支持高质量的图形渲染，包括光照、阴影、透明度和材质效果。这增强了BIM模型的可视化质量，使用户能够更清晰地理解模型，做出更好的设计和决策。
HOOPS技术的未来展望
HOOPS技术的不断发展和改进将为BIM领域带来更多的机会和可能性。以下是一些未来展望：
更强大的云集成
随着云计算的发展，HOOPS技术将能够更紧密地与云平台集成，为用户提供更多协作和存储选项。这将使多个团队能够实时协作，同时访问和编辑BIM模型，从而提高项目的协同效率。
增强的虚拟现实支持
虚拟现实（VR）和增强现实（AR）在建筑行业中的应用逐渐增多。HOOPS技术可以为这些技术提供更强大的支持，使用户能够在虚拟世界中更好地交互和浏览BIM模型。
更智能的分析和决策支持
未来的HOOPS版本可能会集成更多的智能分析工具，帮助用户进行更深入的数据分析和决策制定。这将有助于提高建筑项目的质量和效率。
更广泛的应用领域：HOOPS技术不仅适用于建筑和工程，还可以在其他领域，如医疗、汽车设计、航空航天等，提供高效的三维可视化解决方案。未来，HOOPS技术可能会扩展到更多的应用领域，为各种行业带来更多好处。
安全性和隐私保护
随着对数据安全性和隐私保护的关注增加，HOOPS技术可能会不断加强安全性功能，以确保BIM数据的保护和合规性。
总之，HOOPS技术已经在BIM领域实现了Web轻量化，提高了可视化效果和性能，同时降低了资源需求。它为建筑行业的数字化转型提供了强大的工具，为建筑项目的成功提供了支持。
随着技术的不断演进，我们可以期待HOOPS技术在BIM和其他领域的更多创新应用，为未来的建筑和工程项目带来更多好处。这将促进建筑行业更加高效、可持续和协同合作，为人们提供更安全、舒适和现代化的建筑环境。
&gt;&gt;点击申请HOOPS试用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa223d34ec98a7129f2f1eb7c3711ed2/" rel="bookmark">
			调用其他js文件中的方法,js文件调用另一个js文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编来为大家解答以下问题，js如何调用另一个js文件里的方法，js调用另一个文件里的函数，今天让我们一起来看看吧！
引言 当我们使用JavaScript写一个复杂界面的业务逻辑时，经常会把所有的函数写在同一个JS文件中。然而随着功能的不断增加，这个JS文件会变得又臭又长，所有的功能像一团乱麻一样交织在一起，自己都不想回头看Deepl降重。为了避免这种情况的发生，我们应该在开始编码的时候就对不同的功能进行封装（即：将不同的业务逻辑写在不同的JS文件中），进而降低代码的耦合性。
因此，就会出现不同JS文件之间函数的相互调用问题。
调用方法方法很简单：我们只需将不同的JS文件在同一个html文件中引用，即可在任一JS文件中调用其他JS文件中的封装的函数了。
根据调用函数位置的不同，我们可以将函数调用方式分为全局调用和局部调用两类。
需要注意的是：不同的调用方式，细节上稍有区别。
1、全局调用 所谓全局调用，就是在函数外部调用其他JS文件中封装的函数。
(1)被调用的JS文件先引用 例如：test.html文件
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt; src="a.js"&gt;&lt;/&gt; &lt; src="b.js"&gt;&lt;/&gt; &lt;/body&gt; &lt;/html&gt; 注：使用VS Code新建html文件，输入“html:5”，回车即可生成HTMl文件的框架。
a.js
function a() { alert("a.js is loading"); } b.js
a(); function b() { alert("b.js is loading"); } 刷新界面，输出：“a.js is loading”，如下图所示。
(2)被调用的JS文件后引用 例如：保持test.html文件不变：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt; src="a.js"&gt;&lt;/&gt; &lt; src="b.js"&gt;&lt;/&gt; &lt;/body&gt; &lt;/html&gt; 注：使用VS Code新建html文件，输入“html:5”，回车即可生成HTMl文件的框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa223d34ec98a7129f2f1eb7c3711ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b3e3aa1991d4c568404d726def1eff/" rel="bookmark">
			DCDN和PCDN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DCDN:（分布式内容交付网络）
分布式架构： DCDN 基于分布式架构，内容分发点（CDP）分布在多个地理位置，通常是全球范围，以确保内容更快速地到达最终用户。
全局覆盖： DCDN 通常具有全球性的覆盖，可以为全球用户提供内容交付服务。
用例: DCDN 适用于全球范围的大型企业、媒体和互联网公司，用于分发大容量的静态和动态内容。
PCDN(边缘内容交付网络)：
边缘计算： PCDN 是一种边缘计算技术，将内容分发点放置在接近最终用户的边缘位置，以减少延迟和提高内容交付速度。
较小的覆盖区域： PCDN 的覆盖区域通常较小，服务于特定地理区域或城市。
用例： PCDN 适用于需要将内容更快速地交付给特定地理区域或城市的应用，如在线游戏、实时流媒体和物联网。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9861679ea3d12c8bd2af43d2cd783be1/" rel="bookmark">
			Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在跟着B站瑞吉外卖实战项目学习Spring Data Redis时，启动redis测试代码一直报错：
Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test 跟着视频一起敲的代码，但就是跑不起来
package com.itheima; import com.itheima.reggie.ReggieApplication; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.test.context.junit4.SpringRunner; @SpringBootTest @RunWith(SpringRunner.class) public class SpringDataRedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testString() { redisTemplate.opsForValue().set("city" , "北京"); Object city = redisTemplate.opsForValue().get("city"); System.out.println(city); } } 后面查资料发现原因在于：测试方法在运行的时候，需要寻找到SpringBoot启动类，默认情况下会直接在当前包路径上寻找
而我的项目结构是这样的：
所以需要在@SpringBootTest注解加上SpringBoot的启动类classes = ReggieApplication.class
修改后的代码：
package com.itheima; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9861679ea3d12c8bd2af43d2cd783be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a986cc5b24b238db174e40916ac769/" rel="bookmark">
			pikachu靶场--＞CSRF漏洞详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
漏洞介绍及原理
漏洞危害
漏洞检测
打靶
CSRF(get)
CSRF(post)
防御措施
漏洞介绍及原理 CSRF（跨站请求伪造）CSRF是攻击者通过伪造用户浏览器的请求，欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。
漏洞危害 未经授权的操作
用户隐私泄露
数据篡改
恶意操作
漏洞检测 一般在用户密码修改、信息修改、添加账户、发布文章等一些敏感操作位置，如果没有进行二次校验或者没有使用安全的token验证，就容易导致请求被伪造
打靶 CSRF(get) 访问pikachu靶场，点击提示，这里以Kobe用户进行登录，并修改个人信息
修改个人信息后，点击submit时，使用BurpSuite抓包
将抓到的包右键--&gt;Engagement tools--&gt;Generate CSRF PoC
点击copy HTML 在桌面新建一个文件夹，再新建一个文本文档，将代码复制进去，并修改后缀名为 .html
使用python3启动一个web服务，为了能让用户访问到这个恶意的html文件
python3 -m http.server 使用另一个浏览器登录pikachu,并用Vince用户进行登录
此时，用登录Vince这个用户的浏览器访问刚刚使用python搭建的web服务
点击按钮，发现vince用户信息被修改
CSRF(post) 访问pikachu靶场，点击提示，这里以allen用户进行登录，并修改个人信息
修改个人信息后，点击submit时，使用BurpSuite抓包
将抓到的包右键--&gt;Engagement tools--&gt;Generate CSRF PoC
点击copy HTML
在桌面新建一个文件夹，再新建一个文本文档，将代码复制进去，并修改后缀名为 .html
使用python3启动一个web服务，为了能让用户访问到这个恶意的html文件
python3 -m http.server 使用另一个浏览器登录pikachu,并用kobe用户进行登录 此时，用登录kobe这个用户的浏览器访问刚刚使用python搭建的web服务
点击按钮，发现kobe用户信息被修改
防御措施 添加token认证
验证referer来源
添加二次校验
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1777baac05e1d401f6506594743115/" rel="bookmark">
			C&#43;&#43;前置声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 前置声明是指对类、函数、模板或者结构体进行声明，仅仅是声明，不包含相关具体的定义。在很多场合我们可以用前置声明来代替#include语句。类的前置声明只是告诉编译器这是一个类型，但无法告知类型的大小，成员等具体内容。在未提供完整的类之前，不能定义该类的对象，也不能在内联成员函数中使用该类的对象。而头文件则一一告之。如：
class person; 前置声明，也称前向声明(forward declaration)。在声明之后，定义之前，类person是个不完整类型(incomplete type)，即已知person是一个类型，但是不知道包含哪些成员。
不完全类型只能以有限方式使用。不能定义该类型的对象。不完全类型只能用于定义指向该类型的指针及引用，或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数。可以通过前置声明配合指针或引用类型声明来减少编译依赖。
前置声明是C/C++开发中比较常用的技巧，主要用在三种情形：
变量/常量，例如extern int var1;函数，例如void foo();，注意类的成员函数无法单独做前置声明；类，例如class Foo;，也可以前置声明模板类：
template class&lt;typename T1, int SIZE&gt;Foo;。
如果类包含在名字空间中，需在名字空间内做前置声明：
namespace tlanyan {class Foo;}，而不能这样：class tlanyan::Foo;。 前置声明主要作用： 避免重复定义变量；避免引入函数定义/声明文件，从而函数文件发生更改时不会重新编译依赖文件；解决循环依赖问题。 函数前置声明 #include &lt;iostream&gt; using namespace std; void fun(int *pValue, double dValue); void main() { int nValue = 100; double dValue = 111.22; fun(&amp;nValue, dValue); system("pause"); } void fun(int *pValue, double dValue) { return; } 类的前置声明： 两个类要互相引用，就会出现“未定义”尴尬，此时可以用前置声明来解决。
因为类Animal中用到了类person，而类person的声明出现在类Animal的后面。如果没有类B的前置说明，下面的程序将不同通过编译.
class person; //类的前置声明 class Animal { public: void eat(person&amp; pn); }; class person { public: friend Animal::eat(person&amp; pn); }； 但前置声明不包括类的详细信息（没有给出相关的定义），所以编译器无法得到前置声明类的size，成员等详细信息，不能试图通过前置声明解决类成员的调用。不能试图通过前置声明来定义类的对象，只能改为定义类对象的指针（指针大小是固定的）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e1777baac05e1d401f6506594743115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08225e6f0029977a2a5a53c64f2125b/" rel="bookmark">
			【Rust基础③】方法method、泛型与特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 6 方法 Method6.1 定义方法self、&amp;self 和 &amp;mut self 6.2 自动引用和解引用6.3 关联函数 7 泛型和特征7.1 泛型 Generics7.1.1 结构体中使用泛型7.1.2 枚举中使用泛型7.1.3 方法中使用泛型为具体的泛型类型实现方法 7.1.4 const 泛型 7.2 特征 Trait7.2.1 为类型实现特征7.2.2 使用特征作为函数参数7.2.3 特征约束(trait bound)多重约束where约束 7.2.4 函数返回中的impl trait7.2.5 两个综合例子为自定义类型实现 `+` 操作自定义类型的打印输出 7.3 特征对象 6 方法 Method Rust中，方法往往和对象成对出现：object.method()。Rust 的方法往往跟结构体、枚举、特征(Trait)一起使用
6.1 定义方法 Rust 使用 impl 来定义方法，例如以下代码：
struct Circle { x: f64, y: f64, radius: f64, } impl Circle { // new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字 // 这种方法往往用于初始化当前结构体的实例 fn new(x: f64, y: f64, radius: f64) -&gt; Circle { Circle { x: x, y: y, radius: radius, } } // Circle的方法，&amp;self表示借用当前的Circle结构体 fn area(&amp;self) -&gt; f64 { std::f64::consts::PI * (self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08225e6f0029977a2a5a53c64f2125b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c5a714853f84b0b584667b47f756c0/" rel="bookmark">
			@NoArgsConstructor注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、注解介绍
该注解作用到类上，用于生成一个无参构造
二、注解相关属性介绍
1、staticName:
生成的构造方法是私有的，并且商城一个无参、返回值类型为当前对象的静态方法，方法名为staticName值
2、onConstructor:
列出所有的注解都放在生成的构造方法上
jdk1.8新写法
onConstructor_ = {@RequestBody} 3、access:
设置构造方法的访问修饰符，如果设置了staticName，那么将设置静态方法的访问修饰符 默认为：public，可选择private、module、protected、none(JDK9新特性，表示不生成构造函数也不生成静态方法，该注解被停用)
4、force：
可以将所有final字段初始化为0、null、false。默认为false
三、实战
@NoArgsConstructor(force = true, staticName = "sss", access = AccessLevel.PRIVATE, onConstructor_ = {@RequestBody}) public class ceshi { private final String name; private final Integer age; private final boolean boo; } 编译后：
public class ceshi { private final String name; private final Integer age; private final boolean isDelete; @RequestBody private ceshi() { this.name = null; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c5a714853f84b0b584667b47f756c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99672719ef193c697747d90430300ccf/" rel="bookmark">
			js的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; let a = 10; let b = 20; let d = 10.5; let c = a + b; console.log(c); //字符串类型 let str = 'hello world'; let str1 = "hello world"; let str2 = `hello world`;// 三种字符串的写法 第三种按键是数字键左边的那个键 console.log(str); console.log('今天天气“不错”'); console.log("今天天气'不错'"); console.log(`今天天气"不错"`); console.log(`今天天气"不错"`);//拼接嵌套的写法 单印号双引号互相嵌套 //转义字符 console.log('今天天气\'不错\''); //字符串的拼接 let str3 = 'hello'; let str4 = 'world'; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99672719ef193c697747d90430300ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7334e53a4905c455f23009cbe9b324d1/" rel="bookmark">
			[L]Ｃ语言一些细碎知识点整理&#43;题集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上机运行一个C程序必须经过编辑、编译、链接和执行4个步骤。
C语言本身没有输入输出语句，它的输入功能是由系统提供的输入函数实现的。
C语言源程序文件的后缀是 .c ;经过编译后,生成文件的后缀是 .obj ;经过连接后,生成文件的后缀是 .exe （经编译链接后生成的文件后缀是.exe）。
字符常量是一个用单引号括起来的单个字符（转义字符自带\开头,带两个或多个字符，但它只代表一个字符,\后跟八进制数据，比如'\101'表示字符A），在C语言中一个字符常量代表ASCII字符集中的一个字符，字符常量在内存。占4个字节，存放的是字符的ASCII码（整型数据） 。C语言规定所有字符常量都作为整型量来处理。此外，字符型数据与整型数据任意通用。
'\\'（√）表示字符斜杠常量\ "a"表示一个字符串（√）
与'a'区别？
C语言中"a"表示一个字符串，在内存中存储为 'a' '\0' 两个字符，大小为2字节。
C语言中'a'表示一个字符，在内存中存储为 'a' 一个字符，大小为1字节。
正确描述的C语言常量
（1）.25（√）
（2）5.（√）
（3）090（×）
原因：以0开头的表示他是一个八进制数，而它的各个位置最大小于8。
（4）'\xAA'=='\xaa' （√）
（5）'\02071' （×）
原因：编译后出现waring：multi-character character constant [-Wmultichar]。转义字符都有意义，而不是随意表示。所有的ASCII码都可以用“\”加数字（一般是8进制数字）来表示。
若有定义：int a=8,b=5,c执行语句c=a/b+0.4后，c的值为1
原因：c为整型变量，小数赋给c后被截断。
5.0%3是错误表达式。
原因：编译时报错c[Error] invalid operands to binary % (have 'double' and 'int')。C语言中"%"运算符的运算对象必须是整型。
数字字符0的ASCII值为48，若有以下程序： main() char a='1'，b='2'； printf("%c,"，b++)； printf("%d\n"，b- a)；
输出结果是2 2
原因：char型变量，表示的是字符，其内部存储的就是ascii码值，以整型方式输出时，打印的就是对应的ascii码值的10进制值。也就是%d输出ASCII码的值，而%c输出ASCII上对应的结果。
实型常量又称实数或浮点数。在C语言中可以用单精度型和双精度型两种形式表示实型常量，分别用类型名float和double进行定义 。
①在C语言中，则以“e”或“E”后跟一个整数来表示以“10”为底数的幂数。且C语言语法规定，字母e或E之前必须要有数字，且e或E后面的指数必须为整数。如e3、7e5.4、.e、e等都是非法的指数形式。注意：在字母e或E的前后以及数字之间不得插入空格。
②小数形式是由数字和小数点组成的一种实数表示形式。注意：小数形式表示的实型常量必须要有小数点。
0.1、.123、123.、0.0都是合法的。
逗号运算符是C语言运算符中优先级最低的运算符，比赋值运算符还低。其语法格式为：表达式1, 表达式2，表达式3。结合方式：自左至右，把最右侧表达式的值作为整个表达式的值。
例① a=5,b=3,a*b a=5,3的运算后的结果都是是5 3+2,10-6运算结果是4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7334e53a4905c455f23009cbe9b324d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec09c1ec714caad1a8c76b0d724f0719/" rel="bookmark">
			js如何遍历数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 JavaScript 中，有多种方式可以遍历数组。以下是几种常见的方法：
for 循环： 使用传统的 for 循环可以遍历数组，通过索引逐个访问数组元素。 let numbers = [1, 2, 3, 4, 5]; for (let i = 0; i &lt; numbers.length; i++) { console.log(numbers[i]); } forEach() 方法： 数组提供了 forEach() 方法，它接受一个回调函数作为参数，对数组中的每个元素依次执行回调函数。 let numbers = [1, 2, 3, 4, 5]; numbers.forEach(function (number) { console.log(number); }); for…of 循环： for…of 循环是 ES6 引入的一种新的循环方式，可以直接遍历数组中的元素值。 let numbers = [1, 2, 3, 4, 5]; for (let number of numbers) { console.log(number); } map() 方法： 数组的 map() 方法也可以用于遍历数组，它会创建一个新的数组，并将每个元素依次传递给回调函数，然后返回回调函数的返回值组成的新数组。 let numbers = [1, 2, 3, 4, 5]; let multipliedNumbers = numbers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec09c1ec714caad1a8c76b0d724f0719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c97b47445404477f2d0042a58ccd5f/" rel="bookmark">
			【linux】报错Error:too many arguments及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 可能成因1：引用的变量名中有空格解决方案 可能成因2：使用if进行条件判断时`[]`使用不当 可能成因1：引用的变量名中有空格 例：转到abc files目录
cd abc files 出现该报错，原因在命令执行时将该变量识别为两个变量
解决方案 用""使变量名被识别为一个整体，即：
cd "abc files" 可能成因2：使用if进行条件判断时[]使用不当 在下学艺不精，现在还不清楚什么情况下用单中括号用双中括号，后续学习后再来补充
我遇到该报错的原因在，使用if判断特定字符串是否存在于字符串数组中时，使用了单中括号：
if [ ! "$arr[@]" =~ "$str" ];then echo "$str isn't exist in the array." fi 将 单中括号 改为 双中括号[[ ]]即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695cae024386a894fa6cda943e534016/" rel="bookmark">
			[JVM]问下,对象在堆上的内存分配是怎样的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 技术体系的自动内存管理,最根本的目标是自动化地解决两个问题:自动给对象分配内存以及自动回收分配给对象的内存
这里面最重要的就是,对象在堆上的内存分配
这篇文章来具体讲讲
堆整体上来说,主要分为 新生代 &amp; 老年代
新生代又分为: Eden 区和 Survivor 区, Survivor 区又分为 from 指针指向的区域和 to 指针指向的区域
Eden : From Survivor : To Survivor = 8 : 1 : 1
(原谅我一下,我实在是懒得画图了,哈哈哈哈
接下来就是对象来了,首先是会把它放在 Eden 区中
如果经历了一次 Minor GC ,它仍然存活,而且此时 Survivor 区域足够,那么就会把它移动到 Survivor 区域中 from 指针指向的区域,同时对象年龄加 1,接下来又是一次 Minor GC ,这个对象依然存活下来了,此时会将 Eden 区和 from 区中的存活对象复制到 to 指针指向的区域中,然后 from 指针和 to 指针会互换一下
以上这个过程一直重复,假设那个对象一直在存活,到一定程度之后(默认是 15 ),会被晋升到老年代
进入了老年代之后,如果要进行垃圾回收,那就需要来一次 Full GC 了,这大概就是整个过程
上面的过程是正常的一个流程,那也有不正常的情况呢,比如经常说的,如果 new 了一个大对象, Eden 区放不下,此时会直接放到老年代里面去
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/695cae024386a894fa6cda943e534016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685c05e96f6db26ec301207e4b041223/" rel="bookmark">
			计算机毕设ssm故障报修管理系统APPw78g09 独有（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
ssm + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 系统功能结构设计 完成了设计思路的构想，接下来就是按照实际要求完成所需功能。该系统功能结构图如图4-2所示：
图4-2 系统功能结构图
4.3 数据库设计 4.3.1 数据库E-R图设计 E-R图即实体-联系图，主要作用是提供了解显示数据类型存在的联系的途径，是藐视现实世界的概念模型，其关键要素是实体型、属性、联系。以下是本系统主要的实体图，如下所示。
（1）在线聊天实体图
图4-3在线聊天实体图
（2）公告信息实体图
图4-4公告信息实体图
（3）订单确认实体图
图4-5 订单确认实体图
（4）用户实体图
图4-6 用户实体图
（5）维修员实体图
图4-7 维修员实体图
APP端功能的实现 5.1.1登录注册界面的实现
首先双击打开app客户端系统，连上网络之后会显示出本系统的登录界面，这是进入app的第初始页面“登录”，能成功进入到该登录界面则代表app的开启是成功的，接下来就可以操作本系统所带有的其他所有的功能。登录界面如图5-1所示。
图5-1 登录界面
5.1.2APP首页功能的实现
app首页是用户注册登录后进入的第一个界面，用户可通过app端首页导航栏进入到相应的网页查看信息展示信息进行详细操作。app首页界面如图5-2所示。
图5-2 app首页界面图
5.1.3用户功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685c05e96f6db26ec301207e4b041223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d9de19915e243cb34cc0235b795037/" rel="bookmark">
			js的输入和输出语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //输出语句 document.write("我是js代码") //输出标签 document.write("&lt;h1&gt;我是js代码&lt;/h1&gt;") //弹出警示框 alert("我是js代码") //控制台输出 一般用于调试 console.log("我是js代码") //输入框 显示一个对话框，用户可以在对话框中输入文本 prompt("请输入你的名字") &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96035abc1f6a97330299b8683d195b59/" rel="bookmark">
			js的注释和结束符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注释：
1.单行注释
2.多行注释
结束符
1. 符号 分号 ;
2. 可写也可不写。 可以统一约定。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //1.js的注释 //单行注释 ctrl+/ /*多行注释 ctrl+shift+ */ //2.js的结尾符号 //js的结尾符号；可以省略。 需要约定统一 alert('hello world1'); alert('hello world2'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab065d436e5d6d947c2fab25f6190dcb/" rel="bookmark">
			Docker 安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、下载redis 镜像 docker pull redis
二、创建数据卷映射路径、配置redis.conf mkdir -p /usr/local/myredis/confvim redis.conf # redis.conf appendonly yes 配置内容可以参考 https://github.com/redis/redis/blob/unstable/redis.conf
启用内存过渡分配
#修改配置 vim /etc/sysctl.conf # 增加如下配置，否则启用redis的时候会有警告 vm.overcommit_memory=1 执行sysctl -p 三、创建redis容器 # -v /usr/local/myredis/conf:/usr/local/etc/redis 挂载配置文件 # -v -v /usr/local/myredis/data:/data 挂载数据 # redis-server /usr/local/etc/redis/redis.conf 以配置文件的形式启动redis docker run -d -v /usr/local/myredis/conf:/usr/local/etc/redis -v /usr/local/myredis/data:/data --name myredis --restart=always -p 6379:6379 redis redis-server /usr/local/etc/redis/redis.conf 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b10a44f8ece4339162d7134846f536c/" rel="bookmark">
			Jetson Orin NX 设置最大 CPU 和 GPU 频率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CPU 频率
# Set CPU frequency to maximum sudo echo "***** Set CPU frequency to maximum *****" sudo echo "- Previous frequency of cores" sudo cat /sys/devices/system/cpu/cpufreq/policy0/scaling_cur_freq sudo echo "- Previous CPU governor of cores" sudo cat /sys/devices/system/cpu/cpufreq/policy0/scaling_governor sudo echo sudo echo "- The list of available frequencies" sudo cat /sys/devices/system/cpu/cpufreq/policy0/scaling_available_frequencies sudo echo userspace &gt; /sys/devices/system/cpu/cpufreq/policy0/scaling_governor sudo echo 1984000 &gt; /sys/devices/system/cpu/cpufreq/policy0/scaling_setspeed sudo echo 115200 &gt; /sys/devices/system/cpu/cpufreq/policy0/scaling_min_freq sudo echo 1984000 &gt; /sys/devices/system/cpu/cpufreq/policy0/scaling_max_freq sudo echo sudo echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b10a44f8ece4339162d7134846f536c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19449ae0416f1cdaee58e4e8883f543c/" rel="bookmark">
			VMware使用ubuntu安装增强功能实现自动缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware使用ubuntu安装增强功能实现自动缩放 1.下载 VMware Tools2.安装tool 1.下载 VMware Tools 1.需要先弹出DVD
2.虚拟机-安装VMware Tools
进入终端
3.把media下的VMware压缩包拷贝到home/下
4.去home下解压
2.安装tool 进入vmware-tools-distrib
sudo ./vmware-install.pl 根据提示yes,然后一直回车
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f565b27439d1a57ffe4b9b4acd07d3/" rel="bookmark">
			js文本框输入提示功能,js输入框旁边提示文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，小编为大家解答js弹出输入框,输入并保存值的问题。很多人还不知道js文本框输入提示功能，现在让我们一起来看看吧！
JavaScript - 基础提示框的使用
在前端开发中，我们经常需要与用户进行交互，其中弹出提示框是一种常见的方式。JavaScript提供了一个简单而有效的方法来实现该功能，即使用提示框（Alert）GPT改写。
提示框是一种简单的对话框，用于显示一条消息并等待用户响应。它可以用于警告用户、提供信息或确认某些操作。
以下是使用JavaScript创建和使用基础提示框的示例代码：
// 弹出一个简单提示框 alert("欢迎访问我们的网站！"); // 提示框显示后，代码会暂停执行，直到用户关闭提示框 // 使用确认提示框 var result = confirm("你确定要删除这个文件吗？") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a95bebfec376bd7aaebb09d2f9fb11/" rel="bookmark">
			基于协同过滤算法实现海洋馆预约服务平台的设计与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：Java、前端、Python开发多年，做过高程，项目经理，架构师
主要内容：Java项目开发、Python项目开发、大学数据和AI项目开发、单片机项目设计、面试技术整理、最新技术分享
收藏点赞不迷路 关注作者有好处
文末获得源码
项目编号：BS-PT-093 一，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
二，项目简介 海洋馆预约服务平台应为广大观众来馆参观预约和管理者使用提供便利，本课题计划设计并实现海洋馆预约服务平台，该平台分为前台和后台两个部分，针对用户角色主要分为超级管理员、管理员、普通用户三个角色；
普通用户具有：个人信息管理、浏览场馆、预约服务管理、查看预约记录等功能。
管理员具有：用户管理、预约管理、服务管理、场馆信息管理、公告管理等功能。
超级管理员具有对管理员基本信息进行修改、增加、删除等功能。
普通用户使用前台模块实现注册、登录、修改密码、浏览海洋馆场馆、预约场馆、查看预约记录、评价、订单管理、会员中心、留言、投诉等功能；后台功能主要为管理员提供，包括系统管理员包括超级管理员，实现系统的运营和维护功能。
前台功能 1）首页：提供一个网站首页，显示该网站LOGO图标，该网站用户的登录，注册，所有场馆的级别分类、门票价格、最新公告和的介绍的展示等。
2）注册登录
用户在没有登录系统时是无法完成海洋馆预定、留言等功能，在此页面上输入相关信息可以进行登录，若尚未注册账号，点击注册即可跳转至注册界面进行注册，且保证用户名唯一则注册成功。
3）场馆预约
用户登录进入主界面，点击场馆即可跳转，该界面主要展示水族馆的地点、开放时间、门票价格等主要信息。
4）公告信息
用户可在首页界面查看海洋馆的最新公告信息，以及紧急特殊情况
5）会员中心
该界面主要包括普通用户的基本信息，即订单中心和账户信息。订单中心包括我的订单和我的留言，我的订单即可查看用户本人订单的情况、付款和待付款等情况；账户信息包括个人资料和修改密码等。
6）协同过滤推荐展示：主要根据用户的个人行为来记录，并根据记录数据采用协同过滤算法来实现推荐
后台管理 超级管理员管理员登录：管理者根据账户和密码进行登录。场馆信息管理：管理者可以对前台显示的场馆级别分类进行管理，包括添加、删除、修改操作。用户管理：管理者可以查看该网站中已经注册过的所有用户的所有信息。 技术说明：
洋馆预约服务平台的设计与开发是采用面向对象的设计思想，以MySQL为后台数据库，以Java为开发语言，运用JSP技术基于B/S架构，使用Eclipse集成开发环境、Tomcat服务器。
B/S架构 随着Internet和WWW的流行，以往的主机/终端和C/S都无法满足当前的全球网络开放、互连、信息随处可见和信息共享的新要求，于是就出现了B/S型模式，即浏览器/服务器结构。B/S架构最大的优点是总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易。
（2）Java
Java是一门面向对象的编程语言，具有功能强大和简单易用两个特征，Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点，可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。
MYsql MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型和大型网站的开发都选择 MySQL 作为网站数据库。
三，系统展示 个性化数据推荐
海洋馆详情
在线评论
地图导航
在线预定
我的订单
后台管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a95bebfec376bd7aaebb09d2f9fb11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0cbf9e8957cd2aba61f8bab6b0d5d1d/" rel="bookmark">
			BAT019:用指定字符替换文本文档中的指定内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：编写批处理程序，实现用指定字符替换文本文档中的指定内容。
一、新建Windows批处理文件 参考博客：
CSDNhttps://mp.csdn.net/mp_blog/creation/editor/132137544
二、写入批处理代码 1.右键新建的批处理文件，点击【编辑】。
​
2.在打开的记事本中写入以下代码：
@echo off
setlocal enabledelayedexpansion
REM 提示用户输入要操作的文件名称
set /p "file=请输入要操作的文件名称(包括扩展名): "
REM 去除文件名中的双引号
set "file=%file:"=%"
REM 获取文件的绝对路径
for %%i in ("%file%") do set "file=%%~fi"
echo.
REM 提示用户输入即将被替换的内容
set /p "replaced=请输入即将被替换的内容: "
echo.
REM 提示用户输入替换字符串
set /p "all=请输入替换字符串: "
REM 遍历文件的每一行，并进行替换
(for /f "delims=" %%i in ('type "%file%"') do (
set "str=%%i"
set "str=!str:%replaced%=%all%!"
echo !str!
)) &gt; "%file%"_tmp.txt
REM 用替换后的临时文件替换原文件
move /y "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0cbf9e8957cd2aba61f8bab6b0d5d1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85738207b31450e363c3622bd8bbd519/" rel="bookmark">
			Windows设置Redis服务使其开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在redis安装目录，例：图示地方输入cmd，然后回车，或按住shift，选择在此处打开黑窗口
输入redis-cli并回车。（redis-cli是客户端程序）如图正常提示进入，并显示正确端口号，则表示服务已经启动
1.redis启动命令 redis-server redis.windows.conf，出现下图显示表示启动成功了。
2.redis开机自动启动 （2）由于上面虽然启动了redis，但是只要一关闭cmd窗口，r edis就会消失。所以要把redis设置成windows下的服务。也就是设置到这里，初次打开会发现是没有这个Redis服务的。
（3）设置服务命令：redis-server --service-install redis.windows-service.conf --loglevel verbose
输入命令之后没有报错，表示成功了，刷新服务，会看到多了一个redis服务。
（4）常用的redis服务命令。
卸载服务：redis-server --service-uninstall
开启服务：redis-server --service-start
停止服务：redis-server --service-stop
（5）启动redis后就会显示如下redis正在运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074ed9eba5e9632a4c0032360b19d003/" rel="bookmark">
			Java集合知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Java集合1 集合的概念2 Collection接口1）Collections工具类 3 List接口与实现类1）ArrayList实现类2）Vector实现类3）LinkedList实现类4）ArrayList和LinkedList的区别 4 泛型和工具类1）泛型引入2）自定义泛型结构（1）泛型类、泛型接口（2）泛型方法（3）通配符（4）泛型受限 5 Set接口与实现类1)HashSet实现类2)LinkedHashSet实现类3）TreeSet实现类 6 Map接口与实现类1）HashMap实现类2）TreeMap实现类 补充知识1）迭代器底层原理（面试题：iterator(),Iterator,Iterable关系）2）hasNext(),next()的具体实现3）ListIterator迭代器4）比较器5）经典面试题 Java集合 数据结构：
逻辑结构：—&gt;思想上的结构（厨房、卧室）—&gt;线性表（数组，链表），图，树，栈，队列物理结构：—&gt;真实结构（钢筋混凝土+牛顿力学）—&gt;紧密结构（顺序结构），跳转结构（链式结构） 1 集合的概念 概念：对象的容器，定义了对多个对象进行操作的常用方法。可实现数组的功能。和数组区别： 数组长度固定，集合长度不固定数组可以存储基本类型和引用类型，集合只能存储引用类型 位置：java.util.* 集合结构图
应用场合：
前后端数据库交互，党需要将相同结构的个体整合到一起的时候，需要集合。实际应用场合：购物网站、邮件等等 2 Collection接口 子接口：List接口，Set接口
常用方法
增加：add(E e) addAll(Collection&lt;? extends E&gt; c)
删除：clear() remove(Object o) removeAll(Collection&lt;?&gt; c)
修改：stream() 返回以此集合为源的顺序
查看：iterator() 遍历 size()
判断：contains(Object o) equals(Object o) isEmpty()
遍历方式：增强for循环、迭代器
/* **Collection常用方法** 增加：`add(E e)` `addAll(Collection&lt;? extends E&gt; c)` 删除：`clear()` `remove(Object o)` `removeAll(Collection&lt;?&gt; c)` 修改：`stream()` 返回以此集合为源的顺序 查看：`iterator()` 遍历 `size()` 判断：`contains(Object o)` `equals(Object o)` `isEmpty()` */ //1 创建对象：接口不能创建对象，利用实现类创建对象 Collection col = new ArrayList(); //2 调用方法： //集合只能存放引用数据类型的数据，不能放基本数据类型 //基本数据类型自动装箱，对应包装，int--&gt;Integer col.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/074ed9eba5e9632a4c0032360b19d003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef56fc7bea8a44cb11f398166ccbaa1/" rel="bookmark">
			Python线上兼职，游戏宅也能接单啦！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言网站推荐1.英选2.开源众包3.程序员客栈4.智城外包5.猪八戒 总结 前言 大学毕业后，不想出去找工作，整天宅在家里打游戏。呃…可是我月入上万= =不找就不找呗，其实也不是完全不工作啦，就是线上接单而已。看不惯我你可以选择加入啊，下面我就来为大家推荐一些Python线上接单的注意事项和网站渠道。
网站推荐 1.英选 这是个外包平台，它的项目管理是特色，项目阶段推进和信息反馈做的比较好。
2.开源众包 开源中国的众包平台，也是个比较老牌的平台了，而且上面的项目主要是众包项目。
据说其接包质量较好，而且它的协助开发工具比较完善。
但是这段时间python的单子好像比较少，可以先观望下。
3.程序员客栈 这是一个国内成立时间比较久，机制相对完善平台，人才数量和质量相当惊人，很多开发者都有大公司的工作经验；而且这个网站依托着其独有的匹配机制、筛选手段和合作流程一路发展到了现在，还是很不错的。
用户群体也一直在增长，也说明这个平台的认可度和安全性；而且平台有一套比较成熟的机制可以保护开发者的收入，起码不用担心甲方带钱跑路的问题。
4.智城外包 这也是一个接外包的网站，是按照竞标的方式来做项目，看来一下平台的python项目，最近的一单在八月中旬，兼职相对比较少。
5.猪八戒 这个网站上面的python兼职比较简单，相对的薪资也会比较低，比较适合新手练练手。
总结 那些几百的小单子对于很多人而言是非常简单的，十几分钟就能搞定，你试想一下十几分钟写完一个单子就是几百块，难道这样还不足以让你有学习Python的动力？
最后提醒一下，作为一个IT人员，不进则退，所以一定不要忘记提升自己。一定要多注意最新的编程动向，紧跟时代的步伐，不要让时代遗忘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a008996fa3904750cb448b48f43ca3ad/" rel="bookmark">
			C&#43;&#43; stl -- stack / queue / priority_queue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、stack
1.1 stack的使用
1.2stack的模拟实现
二、queue
2.1queue的使用
2.2queue的模拟实现
2.3容器适配器
三、deque
3.1vector ， list的优缺点
3.2deque的原理介绍
3.3deque--插入
3.4deque的接口
四、priority_queue
4.1priority_queue的使用
4.2模拟实现
五、仿函数/函数对象
5.1仿函数的实现
5.2仿函数的使用
前言 C语言学习阶段中学习过栈和队列两大基础数据结构 ，只不过C语言中需要自己造轮子 ， c++的stl不仅给我们提供了stack和queue，还提供了一种基于堆的优先级队列--priority_queue ，通过对于这三个序列式容器的学习可以对于适配器和仿函数有更好的理解。
一、stack 1.1 stack的使用 stack的常用接口如下
functionexplanationstack()constructorempty()判断是否空size()返回栈中元素个数top()返回栈顶元素push()压栈pop()弹栈 1.2stack的模拟实现 这里我们使用vector作为我们的适配器，我们阅览源码会发现用的是deque ， deque是一种既能满足任意位置0(1)插入又能随机访问的一种数据结构 ，后续详解
template&lt;class T, class Container = vector&lt;T&gt;&gt;
class stack
{
public:
void push(const T&amp; val)
{
_con.push_back(val);
}
void pop()
{
_con.pop_back();
}
bool empty()
{
return _con.empty();
}
T&amp; top()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a008996fa3904750cb448b48f43ca3ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c53cc829e79f269ac947ac489fc430/" rel="bookmark">
			Android Studio 插件（自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.GsonFormatPlus 这是一个插件，你可以从Json字符串生成Json模型。这个插件只适用于IntelliJ IDEA和Android Studio。基于GsonFormat，更加灵活方便。欢迎来到issue和PR。
2.Android Parcelable code generator JavaBean序列化，快速实现Parcelable接口。
3.ADB WIFI Android wifi无线调试App新玩法ADB WIFI
4.GradleDependenciesHelperPlugin maven gradle 依赖支持自动补全
5.Material Theme UI Material Design Experience for JetBrains IDEs Material Theme UI是JetBrains IDE (IntelliJ IDEA, WebStorm, Android Studio等)的一个插件，它将原始外观更改为Material Design外观和感觉，同时提供了一组广泛的选项，以您想要的方式配置IDE。
最初的灵感来自Sublime Text的Material Theme，这个插件提供了一系列的设置来调整你想要的ide。除了令人印象深刻的主题，它还提供:
漂亮的配色方案支持绝大多数语言用彩色材质设计图标替换所有图标(来自一个单独的插件)定制大多数IDE的控件和组件很多选项，如强调颜色，填充菜单，自定义缩进，箭头样式等一些有用的调整，如项目视图装饰器，语言添加等… 6.Gerry Themes Gerry Themes是一个精致的主题集合，包括10个主题，为舒适的开发体验而设计。
7.Alibaba Java Coding Guidelines 阿里巴巴编程规范约束插件，这个更多是让开发注重代码格式和规范，在写得可能不规范或者容易导致问题出现的地方，都会有提示，让你去进行修改。个人觉得还是蛮不错的，毕竟整洁、规范、不放低级错误的代码是我们都希望的。
报错提示类型：命名或者代码格式注释等不规范、未定义直接使用字符串或者某个数值、隐式启动service等等一系类帮助你更好的写代码的工具。
可参考：《阿里巴巴Java开发手册》《阿里巴巴Android开发规范手册》
8.KDoc-er - Kotlin Doc Generator KDoc-er
介绍一个简单和轻量级的KDoc生成器。
KDoc是一种用于记录Kotlin代码的语言。这个插件有助于为您的项目生成智能KDoc。
这个插件非常轻量级和高效。用于为Kotlin文件生成KDoc。
9.Translation 翻译工具
10.Ktlint (unofficial) 代码自动格式化
自动在Kotlin文件上运行ktlint，并注释发现的任何错误。
在Preferences &gt; Tools &gt; ktlint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25c53cc829e79f269ac947ac489fc430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149b33eccc89ce061d4e6958de1523b8/" rel="bookmark">
			LeetCode——动态规划（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷题顺序及思路来源于代码随想录，网站地址：https://programmercarl.com 目录
121. 买卖股票的最佳时机 - 力扣（LeetCode）
122. 买卖股票的最佳时机 II - 力扣（LeetCode）
123. 买卖股票的最佳时机 III - 力扣（LeetCode）
188. 买卖股票的最佳时机 IV - 力扣（LeetCode）
309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）
714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）
121. 买卖股票的最佳时机 - 力扣（LeetCode） 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 /** * @author light * @Description 买股票的最佳时机。 * * (思路：分为持有和不持有状态：(持有不代表当天买入，持有是一种状态，同理不持有也是 * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149b33eccc89ce061d4e6958de1523b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e2e223256e63f98dd828b865cf6185/" rel="bookmark">
			七种 WebSocket 框架的性能比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 原文地址 colobu.com
前一篇文章使用四种框架分别实现百万 websocket 常连接的服务器介绍了四种 websocket 框架的测试方法和基本数据。
前一篇文章使用四种框架分别实现百万 websocket 常连接的服务器介绍了四种 websocket 框架的测试方法和基本数据。 最近我又使用几个框架实现了 websocket push 服务器的原型，并专门对这七种实现做了测试。 本文记录了测试结果和一些对结果的分析。
这七种框架是：
NettyUndertowJettyVert.xGrizzlyspray-websocketnodejs-websocket/Node.js 最近用 Golang 实现了第八种，Go 表现还不错。
Go 一、测试环境 使用三台 C3.4xlarge AWS 服务器做测试。 一台作为服务器，两台作为客户端机器， 每台客户端机器启动 10 个 client, 一共 20 个 client
C3.4xlarge 的配置如下：
型号vCPU内存 (GiB)SSD 存储 (GB)c3.large23.752 x 16c3.xlarge47.52 x 40c3.2xlarge8152 x 80c3.4xlarge16302 x 160c3.8xlarge32602 x 320 服务器和客户端机器按照上一篇文章做了基本的优化。
以下是测试的配置数据：
20 clientssetup rate 设为 500 * 20 requests/second = 10000 request /second每个 client 负责建立 50000 个 websocket 连接等 1,000,000 个 websocket 建好好，发送一个消息 (时间戳) 给所有的客户端，客户端根据时间戳计算 latency如果服务器 setup rate 建立很慢，主动停止测试监控三个阶段的性能指标： setup 时， setup 完成后应用发呆 (idle) 时，发送消息时 二、测试结果 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19e2e223256e63f98dd828b865cf6185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a1091566aa2bc6af7c934ed338e543d/" rel="bookmark">
			彩票系统java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目要求】：
设计实现一种彩票系统，根据彩票规则，进行开奖和公布开奖结果，设计报告中给出彩票的规则。
【彩票规则】：
系统会随机生成一个四位的号码作为此次的中奖号码，用户根据系统的文字提示输入自己猜测的号码并提交。用户提交之后，彩票系统会显示本次的中奖号码和用户猜测的号码，并根据中奖与否给出相应的提示语。
【代码如下】：
draw.jsp
&lt;%@ page contentType="text/html"%&gt; &lt;%@ page pageEncoding="utf-8"%&gt; &lt;%@ page import="java.util.Random"%&gt; &lt;style&gt; { font-family:黑体;color:black } &lt;/style&gt; &lt;HTML&gt; &lt;body&gt; &lt;p&gt; [彩票系统]&lt;br&gt;随机分配四个0~9之间的数作为中奖号码 &lt;% Random r=new Random(); int number1=r.nextInt(10);//生成0~9之间的随机数 session.setAttribute("drawNumber1",new Integer(number1));//保存中奖号码的第一个数 int number2=r.nextInt(10); session.setAttribute("drawNumber2",new Integer(number2));//保存中奖号码的第二个数 int number3=r.nextInt(10); session.setAttribute("drawNumber3",new Integer(number3));//保存中奖号码的第三个数 int number4=r.nextInt(10); session.setAttribute("drawNumber4",new Integer(number4));//保存中奖好的第四个数 System.out.println(number1+" "+number2+" "+number3+" "+number4); %&gt; &lt;br&gt;输入猜测： &lt;form action="judge.jsp"method="post"&gt; 输入猜测的第一个号码：&lt;input type="text"name="guess1"size=10&gt;&lt;br&gt; 输入猜测的第二个号码：&lt;input type="text"name="guess2"size=10&gt;&lt;br&gt; 输入猜测的第三个号码：&lt;input type="text"name="guess3"size=10&gt;&lt;br&gt; 输入猜测的第四个号码：&lt;input type="text"name="guess4"size=10&gt;&lt;br&gt; &lt;input type="submit"name="submit"id="textStyle"value="提交"&gt; &lt;/form&gt; &lt;/p&gt; &lt;/body&gt; &lt;/HTML&gt; judge.jsp
&lt;%@ page contentType="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a1091566aa2bc6af7c934ed338e543d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a750b99b2cc241148ae1b871861d4c2/" rel="bookmark">
			MySQL --- 图形化工具&amp;DDL表结构操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 图形化工具
1. 介绍
2.3.2 安装
2.3.3 MySQL图形化管理工具使用
二. 表操作
2.1 MySQL-DDL-表结构操作-创建
2.3.1 创建表结构
2.3.1.2 约束
2.2 MySQL-DDL-表结构操作-数据类型
数值类型
字符串类型
日期时间类型
2.3.1 MySQL-DDL-表结构操作-查询&amp;修改&amp;删除
2.3.2 表结构的查询
2.3.3 修改
2.3.4 删除
小结：
一. 图形化工具 1. 介绍 前面学习了DDL中关于数据库操作的SQL语句，在编写这些SQL时，都是在命令行当中完成的。在命令行当中来敲这些SQL语句很不方便，主要的原因有以下 3 点：
没有任何代码提示。（全靠记忆，容易敲错字母造成执行报错）操作繁琐，影响开发效率。（所有的功能操作都是通过SQL语句来完成的）编写过的SQL代码无法保存。 在项目开发当中，通常为了提高开发效率，都会借助于现成的图形化管理工具来操作数据库。
目前MySQL主流的图形化界面工具有以下几种：MySQL客户端工具-图形化工具
我们只需要熟悉这众多工具当中的一个就可以了，因为其它工具的使用都大同小异。
DataGrip是JetBrains旗下的一款数据库管理工具，是管理和开发MySQL、Oracle、PostgreSQL 的理想解决方案。
2.3.2 安装 说明：DataGrip这款工具可以不用安装，因为Jetbrains公司已经将DataGrip这款工具的功能已经 集成到了 IDEA当中，所以我们就可以使用IDEA来作为一款图形化界面工具来操作Mysql数 据库。
2.3.3 MySQL图形化管理工具使用 2.2.3.1 连接数据库
1、打开IDEA自带的Database
2、配置MySQL 3、输入相关信息
输入 comment 备注信息 ; 输入连接的 Host 主机地址 , 默认 localhost; 输入用户名 , 默认 root ;输入密码 , 安装 mysql 的时候 , 设置的 mysql 的访问密码 。 然后点击 Download 下载数据库连接驱动。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a750b99b2cc241148ae1b871861d4c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfb4f0ccc2b733625303d8121539cb6/" rel="bookmark">
			LeetCode刷题总结 - 剑指offer系列 - 持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode刷题总结 - 剑指offer系列 - 持续更新 其他系列链表剑指 Offer II 021. 删除链表的倒数第 n 个结点剑指 Offer II 022. 链表中环的入口节点剑指 Offer II 023. 两个链表的第一个重合节点剑指 Offer II 024. 反转链表（基础模板题）2. 两数相加剑指 Offer II 025. 链表中的两数相加876. 链表的中间结点（基础模板题）剑指 Offer II 026. 重排链表剑指 Offer II 028. 展平多级双向链表剑指 Offer II 029. 排序的循环链表 树剑指 Offer II 043. 往完全二叉树添加节点剑指 Offer 32 - II. 从上到下打印二叉树 II（基础模板题）剑指 Offer II 044. 二叉树每层的最大值剑指 Offer II 045. 二叉树最底层最左边的值剑指 Offer II 046. 二叉树的右侧视图剑指 Offer II 047. 二叉树剪枝剑指 Offer II 049.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfb4f0ccc2b733625303d8121539cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e092cad09a2f8546fe2bfe900b8fba/" rel="bookmark">
			服务器全套基础知识：包含基本概念，作用，服务器选择，服务器管理等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏠 服务器与网站部署知识体系目录
目录
0.说明
1.服务器概念
2.服务器作用
3.服务器主要运营商平台
4.服务器的分类
4.1 按物理形态
4.1.1 ECS服务器
4.1.2 VPS服务器
4.1.3 虚拟主机
4.2 按物理位置
4.2.1 国内主机
4.2.2 国外主机（美国、德国等地区的主机)
5.服务器的关键参数指标
5.1 操作系统
5.1.1 Windows Server
5.1.2 Netware
5.1.3 Unix
5.1.4 Linux
5.2 针对虚拟主机的支持脚本
5.3 空间容量
5.4 主机带宽
5.4 访问流量
5.5 并发量
5.6 CPU和内存
5.7 服务器ip类型:独立ip和共享ip
5.7.1 概念
5.7.2 两者的优缺点简单概述如下几点:
5.8 扩展性能
5.9 安全性能
5.10 CDN
6.如何选择服务器主机
6.1 服务器选购思路(推荐思路)
6.2 根据网站程序选择服务器支持语言
6.3 根据网站受众选择服务器网络
6.4 根据网站内容选择服务器容量
6.5 判断服务器安全性能，品牌与措施
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7e092cad09a2f8546fe2bfe900b8fba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2360a9e300df2c606a455152c942c3/" rel="bookmark">
			【Java】DirectByteBuffer 堆外内存源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、DirectByteBuffer直接缓冲区介绍
1.1 如何使用DirectByteBuffer
1.2 DirectByteBuffer对象实例化过程
1.2.1 构造器
1.2.2 判断是否有足够的空间可供申请java.nio.Bits#reserveMemory
1.2.3 尝试申请内存
1.2.4 为什么要手动调用System.gc()
1.2.5 DirectByteBuffer实现内存分配
1.2.6 内存分配失败回收内存计数：java.nio.Bits#unreserveMemory 1.2.7 内存分配小结
1.3 DirectByteBuffer读写逻辑 二、堆外内存回收
2.1 DirectByteBuffer及对应的堆外内存回收机制Cleaner
2.1.1 Cleaner对象的创建
2.2. 释放堆外内存
2.2.1 守护线程处理对象引用Reference以及ReferenceQueue
2.2.2 如何触发Cleaner中的Deallocator线程释放内存
2.3 DirectByteBuffer有关的JVM选项
三、JVM使用堆外内存的原因
3.1 降低垃圾回收停顿提升性能
3.2 避免JVM大堆常驻无法回收
3.3 提升内存I/O减少内存数据拷贝
四、本节总结
作为Java程序开发者我们都知道编译好的程序需要在Java虚拟机中运行，需要分配内存空间指定堆的大小，通过-Xms2G -Xmx2G参数指定JVM启动堆内存的大小，这是堆内内存的分配。而Java程序往往在开发中需要通过JNI调用lib库，以及使用第三方开发框架，诸如mina,netty Nio框架，这些框架为了提高通信效率，减少内存拷贝减轻Jvm GC压力使用了堆外内存，我们从下图了解一下Java运行时所需内存的分配：
根据上图很直观的发现Java程序运行需要的内存分堆内内存(Heap)和堆外内存(No Heap)，本次介绍的DirectByteBuffer只是堆外内存的其中一部分，除此之外还有字节码、本地native方法调用、JVM运行本身所需内存等。
一、DirectByteBuffer直接缓冲区介绍 DirectByteBuffer是ByteBuffer的一个实现，ByteBuffer有两个类实现，一类是HeapBuffer（堆内内存），另一类是DirectBuffer(堆外内存)
1.1 如何使用DirectByteBuffer 如果需要实例化一个DirectByteBuffer，可以使用java.nio.ByteBuffer#allocateDirect这个方法
public static ByteBuffer allocateDirect(int capacity) { return new DirectByteBuffer(capacity); } 1.2 DirectByteBuffer对象实例化过程 1.2.1 构造器 我们来看一下DirectByteBuffer是如何构造，如何申请与释放内存的，先看看DirectByteBuffer的构造器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d2360a9e300df2c606a455152c942c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77621eefe6dbeee67a45e58fde410a9f/" rel="bookmark">
			5G空口协议栈详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、整体协议栈结构
2、各层功能
layer3层：
（1）NAS（非接入层）
主要用于UE与AMF之间的连接和移动控制。虽然AMF从基站接收消息， 但不是由基站始发的， 基站只是透传UE发给AMF的消息并不能识别或者更改这部分消息， 所以被称为NAS消息。NAS消息是UE和AMF的交互， 比如附着、 承载建立、 服务请求等移动性和连接流程消息。
（2）RRC（无线资源控制层）
RRC层主要用来处理UE与NR之间的所有信令(用户和基站之间的消息)， 包括系统消息、 准入控制、 安全管理、 小区重选、 测量上报、 切换和移动性、 NAS消息传输、 无线资源管理等。
layer2层：
（1）SDAP（ 数据适配协议）
负责Qos流与DRB（数据无线承载）之间的映射；为数据包添加QFI（Qos flow ID）标记。
（2）PDCP（分组数据汇聚协议）
主要负责实现分组数据传输的安全、可靠和高效；PDCP协议的主要工作包括压缩、加密和完整性保护等功能。其中，压缩功能可以将IP数据包进行压缩，从而减小传输延迟和降低网络拥塞。加密功能可以对传输的数据进行加密，保障用户数据不被窃取或篡改。完整性保护则是指在传输过程中，对数据进行校验和验证，确保数据包没有出现错误或丢失。
PDCP协议的主要功能包括：
压缩：将IP数据包进行压缩，减小传输延迟和降低网络拥塞。加密：对传输的数据进行加密，保障用户数据不被窃取或篡改。完整性保护：校验和验证传输过程中的数据，确保数据包没有出现错误或丢失。重排序：按照正确的顺序重新排列数据，以便于后续处理。分段：将较长的IP数据包分成若干个较小的数据包进行传输。头部压缩：将IP数据包的头部信息进行压缩，减小传输延迟。 （3）RLC（无线链路控制层协议）
检错、纠错ARQ（AM实体）；
分段重组（UM实体和AM实体）；
重分段（AM实体）；
重复包检测（AM实体）。
（4）MAC（介质访问控制层）
逻辑信道和传输信道之间的映射；
复用/解复用；
调度；
HARQ；
逻辑信道优先级设置。
Layer1 -PHY（物理层）功能：
NR物理信道与信号
物理信道和物理信号都是一系列资源粒子(RE)的集合， 其区别在于：
物理信道用于承载源于高层的信息；
物理信号不承载源于高层的信息， 并且一般来说物理信号占用的时域和频域资源
相对固定， 发送的内容和使用的功率也相对固定
NR物理信道与信号-下行物理信道
NR物理信道与信号-上行物理信道 ：
SSB结构
同步信号和PBCH块(Synchronization Signal and PBCH block， 简称SSB)由PSS、 SSS、 PBCH和PBCH DMRS等4部分组成。
SSB在时域上占4个符号， 频域上占据连续的20个RB， 时域上位置可以配置PSS/SSS映射到12个PRB中间的连续127个子载波， 占用144个子载波， 两侧分别为8个和9个子载波作为保护带宽， 以零功率发送， PBCH RE = 432。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77621eefe6dbeee67a45e58fde410a9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/029a0375c59b7939a3cd6e07dbbbced0/" rel="bookmark">
			通过API接口获取大量的数据后，需要对这些数据进行处理和分析，以实现业务目标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API接口数据分析是一个比较常见的需求，通过API接口获取大量的数据后，需要对这些数据进行处理和分析，以实现业务目标。以下是一些可能有用的步骤：
数据清洗：获取到的API数据可能存在格式不规范、缺失值、异常值等问题，需要进行数据清洗，以提高数据质量。数据清洗包括检查数据格式是否正确、处理缺失值、检测并处理异常值等。数据筛选与转换：API数据可能不满足所有的业务需求，需要根据业务需求对数据进行筛选和转换。例如，可能需要对数据进行去重、排序、分组、聚合等操作。可视化分析：通过可视化工具对处理过的数据进行深入分析，例如使用图表展示数据的分布、趋势、关联关系等。常见的可视化工具包括Excel、Tableau、PowerBI等。统计学分析：使用统计学方法对数据进行分析，例如假设检验、相关分析、回归分析等。这有助于发现数据中的规律和趋势，为业务决策提供支持。数据挖掘：通过数据挖掘算法对大量数据进行深入分析，例如聚类分析、关联规则挖掘、决策树算法等。这可以帮助发现数据中隐藏的模式和规律，为业务提供更精准的预测和支持。模型优化与迭代：根据业务需求和数据分析结果，不断优化和迭代模型，提高数据分析的准确性和效率。 总之，API接口数据分析需要我们对数据处理和分析有一定的了解，并且需要我们在获得相应的权限后进行相应的操作。同时，我们还需要注意数据的安全性和隐私保护。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f15ac9cddbc0f539746b9f4c89962c2/" rel="bookmark">
			【Rust基础②】流程控制、模式匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 4 流程控制4.1 if else表达式4.2 循环控制4.2.1 for循环4.2.2 while循环4.2.3 loop循环 5 模式匹配5.1 match和if let5.1.1 match匹配使用match表达式赋值模式绑定`_`通配符 5.1.2 if let 匹配5.1.3 matches! 宏 5.2 解构Option5.3 认识模式match 分支if let 分支while let 条件循环for 循环let 语句函数参数let 和 if let 5.3 [全模式列表](https://course.rs/basic/match-pattern/all-patterns.html) 4 流程控制 4.1 if else表达式 if condition == true { // A... } else { // B... } 该代码读作：若 condition 的值为 true，则执行 A 代码，否则执行 B 代码。例如：
fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f15ac9cddbc0f539746b9f4c89962c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a962be28ed46a1fb4c6195854dfc20b1/" rel="bookmark">
			PG14归档失败解决办法archiver failed on wal_lsn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 昨晚Repmgr+PG14主备主库因wal日志撑爆磁盘，删除主库过期wal文件重做备库后上午进行主备状态巡查，主库向备库发送wal文件正常，但是查主库状态时发现显示有1条归档失败的记录。
postgres: archiver failed on 000000010000006F00000086
主库： walsender repmgr 172.28.32.23(36122) streaming 72/1BAC3A10" walsender正常
archiver failed on 000000010000006F00000086" 归档失败
备库： walreceiver streaming 77/9EB6A198" “” “” " walreceiver正常
--查主库数据库状态 [root@pgmaster ~]# systemctl status postgres ● postgres.service - PostgreSQL database server Loaded: loaded (/usr/lib/systemd/system/postgres.service; enabled; vendor preset: disabled) Active: active (running) since Thu 2023-10-12 22:04:08 CST; 13h ago Process: 3710968 ExecStart=/server/data/pgdb/pgsql/bin/pg_ctl start -D $PGDATA (code=exited, status=0/SUCCESS) Main PID: 3710970 (postgres) Tasks: 53 (limit: 201967) Memory: 19.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a962be28ed46a1fb4c6195854dfc20b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927b4610f6b79a99d4b7396c23268ecc/" rel="bookmark">
			LeetCode——动态规划（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷题顺序及思路来源于代码随想录，网站地址：https://programmercarl.com 目录
322. 零钱兑换 - 力扣（LeetCode）
279. 完全平方数 - 力扣（LeetCode）
139. 单词拆分 - 力扣（LeetCode）
198. 打家劫舍 - 力扣（LeetCode）
213. 打家劫舍 II - 力扣（LeetCode）
337. 打家劫舍 III - 力扣（LeetCode）
322. 零钱兑换 - 力扣（LeetCode） 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 import java.util.Arrays; /** * @author light * @Description * @create 2023-10-07 12:32 */ public class CoinChangeTest { public int coinChange(int[] coins, int amount) { int[] dp=new int[amount+1]; Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/927b4610f6b79a99d4b7396c23268ecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323037b72bc445555b14d76b9873b847/" rel="bookmark">
			第八章：分布式系统的麻烦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第八章：分布式系统的麻烦 邂逅相遇
网络延迟
存之为吾
无食我数
—— Kyle Kingsbury, Carly Rae Jepsen 《网络分区的危害》（2013 年）1
文章目录 第八章：分布式系统的麻烦故障与部分失效云计算与超级计算机从不可靠的组件构建可靠的系统 不可靠的网络真实世界的网络故障网络分区 检测故障超时与无穷的延迟网络拥塞和排队TCP与UDP 同步网络与异步网络我们不能简单地使网络延迟可预测吗？ 延迟和资源利用 不可靠的时钟单调钟与日历时钟日历时钟单调钟 时钟同步与准确性依赖同步时钟有序事件的时间戳时钟读数存在置信区间全局快照的同步时钟 进程暂停响应时间保证实时是真的吗？限制垃圾收集的影响 知识、真相与谎言真相由多数所定义领导者和锁防护令牌 拜占庭故障拜占庭将军问题弱谎言形式 系统模型与现实算法的正确性安全性和活性将系统模型映射到现实世界 本章小结参考文献 最近几章中反复出现的主题是，系统如何处理错误的事情。例如，我们讨论了 副本故障切换（“ 处理节点中断”）， 复制延迟（“ 复制延迟问题”）和事务控制（“ 弱隔离级别”）。当我们了解可能在实际系统中出现的各种边缘情况时，我们会更好地处理它们。 但是，尽管我们已经谈了很多错误，但之前几章仍然过于乐观。现实更加黑暗。我们现在将悲观主义最大化，假设任何可能出错的东西 都会 出错 2。（经验丰富的系统运维会告诉你，这是一个合理的假设。如果你问得好，他们可能会一边治疗心理创伤一边告诉你一些可怕的故事）
使用分布式系统与在一台计算机上编写软件有着根本的区别，主要的区别在于，有许多新颖和刺激的方法可以使事情出错【1,2】。在这一章中，我们将了解实践中出现的问题，理解我们能够依赖，和不可以依赖的东西。
最后，作为工程师，我们的任务是构建能够完成工作的系统（即满足用户期望的保证），尽管一切都出错了。在 第九章 中，我们将看看一些可以在分布式系统中提供这种保证的算法的例子。但首先，在本章中，我们必须了解我们面临的挑战。
本章对分布式系统中可能出现的问题进行彻底的悲观和沮丧的总结。我们将研究网络的问题（“不可靠的网络”）; 时钟和时序问题（“不可靠的时钟”）; 我们将讨论他们可以避免的程度。所有这些问题的后果都是困惑的，所以我们将探索如何思考一个分布式系统的状态，以及如何推理发生的事情（“知识、真相与谎言”）。
故障与部分失效 当你在一台计算机上编写一个程序时，它通常会以一种相当可预测的方式运行：无论是工作还是不工作。充满错误的软件可能会让人觉得电脑有时候也会有 “糟糕的一天”（这种问题通常是重新启动就恢复了），但这主要是软件写得不好的结果。
单个计算机上的软件没有根本性的不可靠原因：当硬件正常工作时，相同的操作总是产生相同的结果（这是确定性的）。如果存在硬件问题（例如，内存损坏或连接器松动），其后果通常是整个系统故障（例如，内核恐慌，“蓝屏死机”，启动失败）。装有良好软件的个人计算机通常要么功能完好，要么完全失效，而不是介于两者之间。
这是计算机设计中的一个有意的选择：如果发生内部错误，我们宁愿电脑完全崩溃，而不是返回错误的结果，因为错误的结果很难处理。因为计算机隐藏了模糊不清的物理实现，并呈现出一个理想化的系统模型，并以数学一样的完美的方式运作。CPU 指令总是做同样的事情；如果你将一些数据写入内存或磁盘，那么这些数据将保持不变，并且不会被随机破坏。从第一台数字计算机开始，始终正确地计算 这个设计目标贯穿始终【3】。
当你编写运行在多台计算机上的软件时，情况有本质上的区别。在分布式系统中，我们不再处于理想化的系统模型中，我们别无选择，只能面对现实世界的混乱现实。而在现实世界中，各种各样的事情都可能会出现问题【4】，如下面的轶事所述：
在我有限的从业经历中，我已经和很多东西打过交道：单个 数据中心（DC） 中长期存在的网络分区，配电单元 PDU 故障，交换机故障，整个机架的意外重启，整个数据中心主干网络故障，整个数据中心的电源故障，以及一个低血糖的司机把他的福特皮卡撞在数据中心的 HVAC（加热，通风和空调）系统上。而且我甚至不是一个运维。
—— 柯达黑尔
在分布式系统中，尽管系统的其他部分工作正常，但系统的某些部分可能会以某种不可预知的方式被破坏。这被称为 部分失效（partial failure）。难点在于部分失效是 不确定性的（nondeterministic）：如果你试图做任何涉及多个节点和网络的事情，它有时可能会工作，有时会出现不可预知的失败。正如我们将要看到的，你甚至不知道是否成功了，因为消息通过网络传播的时间也是不确定的！
这种不确定性和部分失效的可能性，使得分布式系统难以工作【5】。
云计算与超级计算机 关于如何构建大型计算系统有一系列的哲学：
一个极端是高性能计算（HPC）领域。具有数千个 CPU 的超级计算机通常用于计算密集型科学计算任务，如天气预报或分子动力学（模拟原子和分子的运动）。另一个极端是 云计算（cloud computing），云计算并不是一个良好定义的概念【6】，但通常与多租户数据中心，连接 IP 网络（通常是以太网）的商用计算机，弹性 / 按需资源分配以及计量计费等相关联。传统企业数据中心位于这两个极端之间。 不同的哲学会导致不同的故障处理方式。在超级计算机中，作业通常会不时地将计算的状态存盘到持久存储中。如果一个节点出现故障，通常的解决方案是简单地停止整个集群的工作负载。故障节点修复后，计算从上一个检查点重新开始【7,8】。因此，超级计算机更像是一个单节点计算机而不是分布式系统：通过让部分失败升级为完全失败来处理部分失败 —— 如果系统的任何部分发生故障，只是让所有的东西都崩溃（就像单台机器上的内核恐慌一样）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/323037b72bc445555b14d76b9873b847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87658933e6a588b20b2022043c0526eb/" rel="bookmark">
			免备案域名 DNS解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、注册购买域名地址（免备案）
Name.com | Domain Names, Registration, Websites &amp; Hosting
注意国家选中国区才可以使用支付宝，信息填写完之后创建账号，邮箱填写自己的邮箱
2、注册完登录账号进去找到Domain Name 搜索自动义域名-选择好域名加入购物车并完成支付
3、点击My Domains勾选刚购买的域名后选择Edit Nameservers ,列表的1、2行需要输入Cloudflare 的DNS解析地址
3、Cloudflare 是一个全球网络 ,旨在让您连接到 Internet 的一切安全、私密、快速和可靠。保护您的网站、API 和 Internet 应用程序、域名解析
https://dash.cloudflare.com/
注册一个cloudflare账号
登录进去之后点击添加站点
输入刚在name.com购买的域名-继续
根据自己需求一般个人使用选择免费的-继续
分别复制 名称服务器1、名称服务器2 到name,com的编辑域名服务器1、2行列表链接-UPDATE NAMESERVERS更新域名服务器
然后回到cloudflare点击检查更新，注册机构可能需要 24 小时来处理名称服务器更新
过大概十几分钟域名站点添加成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ea0607f1a5cafdbe6e2b89854ae764/" rel="bookmark">
			Flask框架配置celery-[1]：flask工厂模式集成使用celery，可在异步任务中使用flask应用上下文，即拿即用，无需更多配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 1、celery框架和flask框架在运行时，是在不同的进程中，资源是独占的。
2、celery异步任务如果想使用flask中的功能，如orm，是需要在flask应用上下文管理器中执行orm操作的
3、使用celery是需要使用到中间件的，简单点就使用redis做中间件
注意：
在flask工厂模式集成celery异步框架，在celery的异步任务中能够获取到flask的应用上下文管理器，也就是说在celery异步任务中你可以去调用flask项目中功能，如orm操作等。
使用本文配置，可以无需修改flask创建app应用的程序，直接将celery相关包创建，运行就可以使用，且能够在异步任务使用flask的功能。
二、项目结构 依赖环境：
celery==4.4.7 eventlet==0.33.3 Flask==2.1.3 Flask-Caching==1.10.1 Flask-Cors==3.0.10 Flask-Migrate==2.7.0 Flask-RESTful==0.3.9 Flask-SocketIO==5.1.1 Flask-SQLAlchemy==2.5.1 PyMySQL==1.0.2 redis==3.5.3 SQLAlchemy==1.4.0 Werkzeug==2.0.2 目录结构：
flask-project
|--apps
|-- user
|-- models
|--views.py
|--urls.py
|--__init__.py
|--ext
|--__init__.py
|--config.py
|--celery_task
|--__init__.py
|--async_task.py
|--celery.py
|--celeryconfig.py
|--check_task.py
|--scheduler_task.py
app.py
三、flask工厂模式下各模块功能 1、apps/user/models.py ： 写了一个user表
2、apps/user/views.py:写了测试调用celery异步任务的接口
3、apps/user/urls.py: 注册路由的
4、ext/__init__.py：cache、db、cors的拓展
5、ext/config.py : cache和cors使用到的配置
6、apps/__init__.py： 一个函数create_app,生成flask应用对象
7、app.py: 启动flask应用对象的模块
本文重点不在flask工厂模式，默认看官都懂如何创建flaks工厂模式的项目了。
在视图中在执行异步任务，并获取异步任务的id：
from celery_task.async_task import send_email_task,cache_user_task #用户资源：get\put\delete, 对单个进行操作 class UserOneResource(ResourceBase): def put(self,id): #测试异步发邮件 email = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ea0607f1a5cafdbe6e2b89854ae764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cdc330222e2ef3717dbcbf718d7b17d/" rel="bookmark">
			【C&#43;&#43; Miscellany】C&#43;&#43;重要的几项改变、标准程序库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++重要的几项改变： 增加了一些新的语言特性：RTTI、namespaces、bool、关键字mutable和explicit、enums作为重载函数之自变量引发的类型晋升转换，以及“在class定义区内直接为整型 const static class members设定初值”的能力；扩充了Templates的弹性：允许member templates存在、接纳"明白只是template当场实例化"的标准语法、允许function templates接受"非类型自变量(non-type arguments)"、可用class templates作为其他template的自变量；强化了异常处理机制：编译期间更严密地检验exception specifications、允许unexcpted函数抛出bad_exception对象；修改了内存分配例程：加入operator new[]和operator delete[]；内存未能分配成功时由operator new/new[]抛出一个异常，提供一个operator new/new[]新版本，在内存分配失败后返回0；增加了新的转型形式：static_cast,dynamic_cast,const_cast和reinterpret_cast；语言规则更为优雅精炼：重新定义虚函数时，其返回类型不再一定得与原定义完全吻合；此外临时对象的寿命也有了规范。 标准程序库 标准程序库的能力 支持C标准函数库；支持strings；支持国别(地域别、本土化、localization)；支持I/O；支持数值应用；支持广泛用途的容器和算法； 标准程序库的特点 标准程序库中每一样东西几乎都是template；所有成分都位于namespace std内。 Standart Template Library(STL) C++标准程序库的最大组成分子为STL：
主要包括容器(container)、迭代器(iterator)、泛型算法(algorithm)：
容器持有一系列对象；迭代器是一种类似指针的对象，用于遍历容器元素；泛型算法是可作用于STL容器身上的函数。 STL是可扩充的，可以将自己的容器、迭代器、算法加入STL家族内。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be1985f68047e9c52a4de78fb6e1ae9/" rel="bookmark">
			【C&#43;&#43;】类模板（二）类模板、函数模板、常量表达式与默认参数值、模板参数设计策略、成员模板函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现一个类模板 格式：
template&lt;typename 占位符&gt; (inline) 返回类型 模板类类名&lt;自定义类型名&gt;:: 模板类成员函数名(const 自定义类型名 &amp;参数名) 一个以函数模板完成的&lt;&lt;运算符 //非模板函数形式 ostream&amp; operator&lt;&lt;(ostream&amp;,const BinaryTree&lt;int&gt;&amp; ); //模板函数形式 template &lt;typename elemType&gt; inline ostream&amp; operator&lt;&lt;( ostream &amp;os,const BinaryTree&lt;elemType&gt;&amp;bt) { os &lt;&lt; "Tree:" &lt;&lt; endl; bt.print(os); return os; } BinaryTree&lt;string&gt;bts; cout&lt;&lt;bts&lt;&lt;endl; //编译器将elemType指定为string，产生一个对应的&lt;&lt;运算符 BinaryTree&lt;int&gt;bti; cout&lt;&lt;bti&lt;&lt;endl; //编译器将elemType指定为int，产生一个对应的&lt;&lt;运算符 常量表达式与默认参数值 也可以用常量表达式作为模板参数：
template&lt;int len,int beg_pos&gt; class num_sequence { public: virtual ~num_sequence(){}; int elem(int pos)const; const char* what_am_i()const; static int max_elems(){return _max_elems;} ostream&amp; print(ostream &amp;os=cout) const; protected: virtual void gen_elems(int pos) const = 0; bool check_integrity(int pos,int size)const; num_sequence(vector&lt;int&gt;*pe):_pelems(pe){} static const int _max_elems = 1024; vector&lt;int&gt; *_pelems; }; template&lt;int length, int beg_pos = 1&gt;//带有默认参数值 class Fibonacci:public num_seuqence&lt;length,beg_pos&gt; { public: Fibonacci():num_sequence&lt;length,beg_pos&gt;(&amp;_elems){} protected: virtual void gen_elems(int pos)const; static vector&lt;int&gt; _elems; }; 全局作用域内的函数和对象，其地址也是一种常量表达式，因此可以用来表达模板参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8be1985f68047e9c52a4de78fb6e1ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8a08f6a8454b4a47af7706f3bd7303/" rel="bookmark">
			【C&#43;&#43;】类模板（一）被参数化的类型、类模板的定义、模板类型参数的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被参数化的类型 类型的相关信息可从模板定义中剥离，由用户使用时再指定。
template机制帮助我们把“与类型相关”和“独立于类型之外”的两部分分离开来；
在一个类模板中，与类型相关的部分会被抽取出来，成为一个或多个参数：
template&lt;typename valType&gt; class BTnode{ pulic: //... private: valType _val; int _cnt; BTnode *_lchild; BTnode *_rchild; }; //类模板名称+尖括号&lt;实际类型&gt; BTnode&lt;int&gt;bti; BTnode&lt;string&gt;bts; 在类模板和类成员的定义中，可不用以模板参数列表进一步限定类模板，其他情况下要用参数列表限定类模板: template &lt;typename elemType&gt; class BinaryTree{ public: //... private: //BTnode必须以模板参数列表加以限定 BTnode&lt;elemType&gt; *_root; } //某个实际类型作为BinaryTree模板类的参数 BTnode&lt;int&gt;st; BTnode&lt;string&gt;it; //BTnode模板类和BinaryTree模板类配合使用 template&lt;typename Type&gt; class BinaryTree;//前置声明 template&lt;typename valType&gt; class BTnode { friend class BinaryTree&lt;valType&gt; //... }; 类模板的定义 在类主体外，类模板成员函数定义语法如下：
template&lt;typename elemType&gt; inline BinaryTree&lt;elemType&gt;::BinaryTree() : _root(0){} 在类作用域运算符出现后，其后所有东西都被视为类定义范围内；
第二次出现的BinaryTree名称就不需要加template&lt;typename elemType&gt;来限定： BinaryTree&lt;elemType&gt;::	//在class定义范围之外 BinaryTree()	//在class定义范围之内 模板类型参数的处理 实际运用中，不论内置类型还是class类型，都可能被指定为类模板的实际类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8a08f6a8454b4a47af7706f3bd7303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4a5fc16a74881971c7bab2aef8f3b6/" rel="bookmark">
			2023NewStarCtf WEB [WEEK1] 超详细题目思路wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、泄漏的秘密 扫描目录得到www.zip，下载到电脑后打开里面有index.php和robots.txt，点开得到两段flag，拼接得到完整flag
2、Begin of Upload 这里上传一句话木马，抓包后修改content-type:image/png绕过检测，这里使用的木马是
php phpinfo(); @eval($_POST['shell']); 这里看见php信息说明木马上传成功，用蚁剑链接flag在根目录下
3、Begin of HTTP 以闯关形式做题，最后抓包修改后的内容如下。
User-Agent：后面表示的是服务器
referer后面改为newstarctf.com，加上X-Forworded-For：127.0.0.1，把所有有网址的地方都改为127.0.0.1
4、ErrorFlask 简单测试了一下就在源码出现了flag
?number1=2&amp;number2=__class__ 5、Begin of PHP 题目如下
&lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_GET['key1']) &amp;&amp; isset($_GET['key2'])){ echo "=Level 1=&lt;br&gt;"; if($_GET['key1'] !== $_GET['key2'] &amp;&amp; md5($_GET['key1']) == md5($_GET['key2'])){ $flag1 = True; }else{ die("nope,this is level 1"); } } if($flag1){ echo "=Level 2=&lt;br&gt;"; if(isset($_POST['key3'])){ if(md5($_POST['key3']) === sha1($_POST['key3'])){ $flag2 = True; } }else{ die("nope,this is level 2"); } } if($flag2){ echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4a5fc16a74881971c7bab2aef8f3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e33a6b12786c214d8302745d00157516/" rel="bookmark">
			ubuntu20.04 nerf Instant-ngp (下) 复现，自建数据集，导出mesh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接
Ubuntu20.04复现instant-ngp，自建数据集，导出mesh_XINYU W的博客-CSDN博客
GitHub - NVlabs/instant-ngp: Instant neural graphics primitives: lightning fast NeRF and more
youtube上的一个博主自建数据集
https://www.youtube.com/watch?v=VsFHX8IgX1o
老样子
可以跟我继续往下走
首先得先完成
ubuntu20.04 nerf Instant-ngp-CSDN博客
的所有步骤,然后再开始
#安装OpenCV参考我的这篇
ubuntu20.04+slambook2+vscode实例配置（至第五章）_slam实例-CSDN博客
ffmpeg安装(Ubuntu20.04 )参考
2.ffmpeg安装(Ubuntu20.04 )_ubuntu安装ffmpeg-CSDN博客
其中可能需要
chmod -x ./configure
如果权限不够可以加sudo 安装ffmpeg可能会遇到的问题
# --enable-libxvid # 解决 ERROR: libxvid not found
# 包下载地址：https://ftp.osuosl.org/pub/blfs/conglomeration/xvidcore/
tar xf xvidcore-1.3.7.tar.gz cd xvidcore/build/generic/ 基本上都是要先
chmod -x ./configure sudo make sudo make install 基本上按照这个就没啥问题
2.ffmpeg安装(Ubuntu20.04 )_ubuntu安装ffmpeg-CSDN博客
然后可以先看一下
youtube上的一个博主自建数据集
https://www.youtube.com/watch?v=VsFHX8IgX1o
先建文件夹，将视频命名为VID.MP4，然后我的colmap2nerf.py是位于~/nerf_instant-ngp/instant-ngp/scripts/，--video_fps 2的2是指一秒几帧
~/nerf_instant-ngp/instant-ngp/scripts/colmap2nerf.py --video_in VID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e33a6b12786c214d8302745d00157516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2500bfa08dec3af40acf4805ca2cd9/" rel="bookmark">
			端口被占用？两步解决端口占用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：Win+R 打开命令提示符，输入netstat -ano|findstr 端口号，找到被占用端口的进程
第二步： 杀死使用该端口的进程，输入taskkill /t /f /im 进程号（ 注意是进程号，不是端口号）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1b46d2efd9538315102b68b97d7b7f/" rel="bookmark">
			搜维尔科技：产品推荐｜Manus OptiTrack Metagloves虚拟现实手套
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述
直接集成到Motive3
OptiTrack Metagloves能够将Quantum finger数据直接添加到Motive 3中。增强您的运动捕捉数据，同时对现有管道的影响变小。轻松地将高度准确和详细的手指数据输入Motive 3。OptiTrack Metagloves提供的手指数据将与Motive 3中的OptiTrack身体数据结合在一起。即将推出。
新一代手指捕捉
亚毫米精度
使用OptiTrack Metagloves将量子跟踪技术添加到Motive 3及其插件中。
OptiTrack Metagloves经过专门开发，可与OptiTrack Motive软件无缝协作。只需点击一下，即可将亚毫米级精确量子跟踪添加到您的设置中。
全新的量子追踪技术
我们的新跟踪系统为OptiTrack系统提供了丰富的手指数据。量子传感器没有漂移，提供高度准确和可靠的手指捕获数据。
Manus先进的手部解算器
Manus Quantum跟踪传感器能够提供精确的指尖位置，并将其应用于Manus基于研究的生物力学手部模型，以准确地重建数字手部骨架。
有了MANUS Core软件、集成和插件，您现在可以在自己的管道中使用先进的数字手部。
先进的手部解算器和生物力学模型是MANUS Core的一部分，其建立在Manus多年的研究和开发之上。
根据您的需求进行佩戴
量子传感器可以以多种方式佩戴在指尖上。我们为用户提供了选择适合他们用例的方法。这里有两个可用选项：
1.手指绑带
需将手指绑带缠绕在指尖上，然后将量子传感器安装在绑带上部的插槽内。
手指绑带可以非常稳定地安装量子传感器。
2.指套
需将指套佩戴在手指上，并将量子传感器安装在上部的插槽内。
指套能够实现快速佩戴量子传感器。指套拥有三种尺寸。
完美整合
Manus OptiTrack Metagloves
‍OptiTrack Metagloves经过专门开发，可与Motive 3无缝协作，Motive 3是世界各地专业人士使用的动作捕捉软件。OptiTrack Metagloves不受磁场干扰。提供12个月的硬件保修和终身支持。
直接集成到Motive3
通过直接集成到Motive3中，‍OptiTrack Metagloves可以快速将实时手指数据传输到您现有的管道中。通过MANUS手指跟踪功能增强OptiTrack系统，为您的动作捕捉注入活力。将手指数据和OptiTrack身体数据作为一个单独的源进行流式传输。即将推出。
专业版
将Manus OptiTrack Metagloves作为独立解决方案，在Motive之外与Plus版配合使用。专业版带有SMPTE时间编码电缆和所有MANUS插件，包括Motionbuilder、Unity和Unreal Engine插件。
连续的工作流程
可更换电池确保长时间使用
Quantum Metagloves配有可更换电池，为您提供不间断的工作流程。在充满电的情况下，电池可以持续使用4小时。此外，Quantum Metagloves也可以通过USB Type-C端口由外部电源供电。
充电站
充电站能够在1小时内同时充满6块电池。充电站还兼容Prime X和Pro Tracker电池，所以您可以同时为Metaglove和SteamVR Pro Tracker电池进行充电。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b2140dd1fdd36cce5cc9a25bfb5080/" rel="bookmark">
			题解 | #最长上升子序列(一)# c&#43;&#43; &amp;amp；&amp;amp； java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云智oc
9.19一面 —— 9.21二面 —— 9.25hr面 —— 10.12ocbase 武汉，腾讯地图部门，手机地图开发中心10月底谈薪，估计是白菜价，但是武汉确
星星充电二面
聊项目说说MVCC？死锁检测怎么实现的？除了dfs检测环，你还有什么办法？具体说说拓扑排序？http和https有什么区别？（非对称加密加密对称加密秘钥和对称加
刚投了多益，有什么需要注意的吗
简历填游戏情况我直接原神启动了，应该不会被挂吧，主要想看看这个测评真的有那么逆天吗[诶嘿]
百度- 机器学习/数据挖掘/自然语言处理工程师
这个岗位大家有offer评估的吗，三面完一直都是面试中，挂了也给我放回人才库吧[牛泪]
网易雷火游戏研发服务端一面面经
面试官很和蔼，会先询问我的技术特点，然后根据我说的来出题。先自我介绍给一段程序输出运行结果，主要是考察继承、左值引用、右值引用相关代码找错大端序与小端序维护有序
😁最近面试老挂
😁最近面试老挂
基恩士三面
基恩士三面只收到一份测评是不是凉了啊 还是说今年都是只有一份行测测评啊
今天面试比亚迪长安大学的友友有没有人出个
今天面试比亚迪长安大学的友友有没有人出个面经，跪求
#牛客在线求职答疑中心(35799)#
#牛客在线求职答疑中心# tp-link sp
浙江大华解决方案工程师
一面二面都是电话面三面视频面 流程推进很快今年还没开奖，了解了一下去年的薪资，感觉不高，杭州薪资水平咋样啊有没有uu解答下！
今年校招还有签字费期权这些说法吗
秋招拿了两个大厂开发的offer，本来已经非常满意了，虽然还没谈薪，但是查了一下往年的开奖情况，发现怎么算都够不上我想象中的宇宙机就业薪资base*月份算出来还
崩溃了 从九月到现在 就面试了7家 还都
崩溃了 从九月到现在 就面试了7家 还都是一面挂
去哪儿一面凉经
自我介绍一个产运专业问题为啥想来有面试抖音快手这些吗？为啥？
#牛客在线求职答疑中心(35799)#
#牛客在线求职答疑中心# 黑龙江省电力设计院
哈工深比亚迪宣讲
爆炸啦
长安科技vs九洲电器vs亚控
四川人。长安，国企给15k*（15-18），这几年都是*17，加班平均40h，项目节点大小周，发布日头一天可能加夜班。不包住，有班车九洲，国企总包一年15万左右
终于轮到我被举报了
9.20约一面9.22一面当天下午约二面9.26二面9.27约HR面9.28HR面10.12ocbase北京到店后端自从HR面过后就一直在焦虑地等看牛客上有不少
人寿研发中心笔试
大家都收到笔试了吗？具体考什么呀？
吉利校招
宣讲会人好多啊 果然只有车企才是中国未来的希望
#牛客在线求职答疑中心(35799)#h
#牛客在线求职答疑中心#h3c FPGA逻辑开发设计笔试
华为2012实验室中央软件院进度😰
投了2012中央软件院的通用软件开发，请问有该部门的hr吗？投了有一个月了，一点动静都没有😭
海能达海外销售
想问一下大家十一之前一面的有消息了吗 等的我难受死了
简历被普联捞了
#Tplink求职进展汇总# 末9本九月初投的普联和联洲的前端开发岗，这俩都是简历挂，然后就没关注了。今晚普联突然给我打电话说我的简历被捞起来了，问我是否接受调
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39b2140dd1fdd36cce5cc9a25bfb5080/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb32342e17790143cdfd63bc8bd4c8e/" rel="bookmark">
			小程序使用uni.createAnimation只执行一次的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路： 在页面创建的时候，创建一个临时动画对象调用 step() 来表示一组动画完成通过动画实例的export方法导出动画数据传递给组件的animation属性还原动画页面卸载的时候，清除动画数据 &lt;template&gt; &lt;view class="content"&gt; &lt;view class="item" v-for="(item,index) in list" :key="item.id"&gt; &lt;view class="left"&gt; {{item.memo}} &lt;/view&gt; &lt;view class="right" @click="praiseMe(index)"&gt; &lt;image src="../../static/praise.png"&gt;&lt;/image&gt; &lt;view class="font11"&gt;点赞&lt;/view&gt; &lt;view :animation="animationDataArr[index]" class="praise-me animation-opacity"&gt; +1 &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { list:[ {id:"001",memo:"苹果"}, {id:"002",memo:"橘子"}, {id:"003",memo:"草莓"}, {id:"004",memo:"香蕉"} ], animationData: {}, animationDataArr: [] }; }, onLoad() { // 1 在页面创建的时候，创建一个临时动画对象 this.animation = uni.createAnimation(); this.animationDataArr=Array(this.list.length).fill({}); }, onUnload() { // 5 页面卸载的时候，清除动画数据 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb32342e17790143cdfd63bc8bd4c8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f31161d9ded75fe63378f7a5d6f8670/" rel="bookmark">
			【C&#43;&#43;14算法】make_unique
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、make_unique函数1.1 什么是make_unique?1.2 如何使用make_unique?1.3 make_unique的函数原型如下：1.4 示例代码示例1: 创建一个动态分配的整数对象示例2: 创建一个动态分配的自定义类型对象示例3: 创建一个动态分配的数组对象示例4: 创建一个动态分配的自定义类对象数组 总结 前言 在C++14标准中引入了一系列方便而强大的函数模板，旨在简化和改进代码的编写和可读性。其中之一是std::make_unique函数模板，它提供了一种更安全和方便的方式来创建和管理动态分配对象。本文将介绍std::make_unique的作用，它是如何使用的，以及四个示例代码来展示其实际应用。
一、make_unique函数 1.1 什么是make_unique? make_unique是C++14引入的一个函数模板，用于创建并返回一个指向动态分配对象的unique_ptr智能指针。它是为了简化代码，避免手动使用new和delete，以及确保资源的正确释放而设计的。
1.2 如何使用make_unique? 使用make_unique非常简单，并且遵循以下步骤：
a. 包含头文件。
b. 调用make_unique函数模板，并传入要创建对象的类型和构造对象所需的参数。
1.3 make_unique的函数原型如下： template&lt; class T, class... Args &gt; std::unique_ptr&lt;T&gt; make_unique( Args&amp;&amp;... args ); 其中，T代表指向动态对象的指针类型，Args代表构造对象时传递的参数类型，而args则是实际的构造参数。
1.4 示例代码 示例1: 创建一个动态分配的整数对象 #include &lt;iostream&gt; #include &lt;memory&gt; int main() { std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42); std::cout &lt;&lt; "Value: " &lt;&lt; *ptr &lt;&lt; std::endl; return 0; } 输出:
Value: 42 示例2: 创建一个动态分配的自定义类型对象 #include &lt;iostream&gt; #include &lt;memory&gt; struct Point { int x; int y; Point(int x, int y) : x(x), y(y) {} }; int main() { std::unique_ptr&lt;Point&gt; ptr = std::make_unique&lt;Point&gt;(10, 20); std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f31161d9ded75fe63378f7a5d6f8670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7da1f5b6389bc94ccf6bd09aca2ddd05/" rel="bookmark">
			亲测解决conda install一直在solving environment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体问题是小虎使用conda install scikit-learn一直在solving environment。解决方法如下。
文章目录 方法一方法二 方法一 conda update conda 这个update如果很久用Ctrl+C打断再来一次就可以了。
conda install scikit-learn 参考资料
conda update scikit-learn (also scipy and numpy)
方法二 这个用navigator下载好像也行，但是我的navigator打不开，用navigator可以参考下面：
https://blog.csdn.net/qq_36791000/article/details/84925854
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e9b7a6cce4950e4bd69b31e55c8aaad/" rel="bookmark">
			阀门井可燃气体监测设备-地下井室可燃气体监测装置-旭华智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现实生活中，燃气管网泄漏引发的安全事故屡见不鲜。为了有效避免这类事故的发生，一款高效实用的阀门井可燃气体监测设备正在崭露头角。这款设备能够实时监测可燃气体浓度，为您的安全保驾护航。
旭华智能阀井燃气监控仪采用了先进的传感器技术，能够实时监测可燃气体浓度。一旦发现燃气泄漏，设备会立即启动报警功能，及时向相关负责人发出预警信息，从而及时采取应对措施，把危险扼杀在萌芽状态，把安全牢牢握在自己手中。
阀井燃气监控仪的设计独具匠心，不仅具有高精度、高稳定性的特点，同时还采用了IP68防护+本安防爆设计，可以轻松适应各种复杂的管道环境。这样的设计使得设备在恶劣环境中仍能保持良好的性能，为我们的安全提供有力保障。此外，该产品搭载一体式高能锂电，能够保证长时间稳定运行。
阀井燃气监控仪是具有无线通讯功能，用于远程监测城市地下管网、井室等密闭空间可燃气体浓度的智能仪表，可广泛应用于燃气阀门井、电力井、通信井等城市地下井室及管道沿线附近等场所。因此，阀井燃气监控仪无疑是保障燃气安全的理想之选。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d32e09f46b399f549db100356a2abd4/" rel="bookmark">
			【PX4】解决Resource not found: px4问题【踩坑实录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【PX4】解决Resource not found: px4问题【踩坑实录】 文章目录 【PX4】解决Resource not found: px4问题【踩坑实录】1. 问题描述2. 错误排查 1. 问题描述 笔者在配置好px4的所有环境后，使用自己写的launch文件时，出现了报错
sjh@sjhR9000X:~$ roslaunch sitl_study setup_2uavs.launch ... logging to /home/sjh/.ros/log/03103cb4-68da-11ee-ac7d-ef8c5ba3678c/roslaunch-sjhR9000X-69133.log Checking log directory for disk usage. This may take a while. Press Ctrl-C to interrupt Done checking log file disk usage. Usage is &lt;1GB. Resource not found: px4 ROS path [0]=/opt/ros/noetic/share/ros ROS path [1]=/home/sjh/test_ws/src ROS path [2]=/home/sjh/catkin_ws/src ROS path [3]=/opt/ros/noetic/share The traceback for the exception was written to the log file 报错显示无法查找到名为px4的包，笔者很困惑，因为之前的时候是好的。接下来排查一下错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d32e09f46b399f549db100356a2abd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e31c78b43a2d35619ae9fb9d4c562b/" rel="bookmark">
			C语言八股（自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、主要知识点
二、指针
1.定义
2.指针的初始化
3.指针的赋值
4.指针的运算
5.指针与一维数组
6.指针与二维数组
7.字符指针与字符串
8.指针数组
9.多级指针
10.void指针
11.面试题
1.野指针是什么？成因以及解决方法？
2. 悬空指针和野指针有什么区别？
三、数组和字符串
1.一维数组
2.二维数组
3.字符数组与字符串
4.字符串函数
5.面试题
1.sizeof关键字与strlen函数的区别
2.strcpy和memcpy区别
四、关键字
1.常量
1.#define
2.运算符
3.变量
1.auto
2.register
3.static
4.extern
4.常见关键字
1.assert
2.const
3.volatile
4.sizeof
5.typedef
5.面试题
1.extern与static区别
2.C 语言的关键字 static 和 C++ 的关键字 static 有什么区别
2.const和define的区别
3.#define和别名typedef的区别
4.#include 的顺序以及尖括号和双引号的区别
cout是有缓冲输出，输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。 printf是无缓冲输出，有输出时立即输出。
5. strcpy函数和strncpy函数的区别？哪个函数更安全？
五、内存
1.内存分区
2.面试题
1. 深拷贝与浅拷贝？
2.. c和c++的区别？
3.堆与栈的区别？
4. new和malloc的区别？
5.讲讲大端小端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91e31c78b43a2d35619ae9fb9d4c562b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cde55f6a3b7e9bc7c93313a9b7e8594/" rel="bookmark">
			深信服安全服务认证（SCSA-S）学习笔记：第一章 网络安全基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、网络安全基础 目录
一、网络安全基础
1、网路安全概述
2、网络安全要素
3、网络安全体系结构
4、网络安全事件
二、网络安全法律法规
1、网络安全法背景概述
2、网络安全法解读
1、网路安全概述 网络空间的定义：2009年美国《网络安全政策评估》中给出Cyberspace定义：信息技术基础设施中相互储存的网络，包括互联网、电信网、计算机系统以及重要工业中的处理器和控制器。常见的用法还指信息及人与人交互构成的虚拟网络。我国官方文件指出：互联网、自动化控制系统、数字设备机器及其承载的应用、服务和数据构成了网络空间，其已成为陆地、海洋、天空、太空、同等重要的人类活动的新领域。
网络空间安全威胁：政治安全、经济安全、文化安全、社会安全、国防安全。
网络强国战略目标：
近期目标：技术强、基础强、内容强、人才强、国际话语强；中期目标：建设网络强国的战略部署与“两个一百年”奋斗目标同步推进，向着网络安全基础设施基本普及、自主创新能力显著增强、信息经济全面发展、网络安全保障有力的目标不断前进；远期目标：战略清晰、技术先进、产业依靠、制网权尽在掌握，网络安全坚不可摧。 战略原则：尊重维护网络空间主权、和平利用网络空间、依法治理网络空间、统筹网络安全与发展。
战略任务：坚定捍卫网络空间主权、坚决维护国家安全、保护关键信息基础设施、加强网络文化建设、打击网络恐怖和违法犯罪、完善网络治理体系、夯实网络安全基础、提升网络安全防护能力、强化网络空间国际合作。
正确的网络安全观：网络安全是整体的、动态的、开放的、相对的、共同的。
2、网络安全要素 网络安全的基本属性：
保密性：又称“机密性”不仅包含对信息内容的保密，还包括信息状态的保密。完整性：指信息未经授权不能进行更改的特性。及信息2在存储或传输过程中保持不被偶然或蓄意的删除、修改、伪造、乱序、重放、插入等破坏和丢失的特性。可用性：指信息可被授权实体访问并按需求使用的特性。 网络安全的演变史：
通信保密阶段：现代通信保密阶段普遍认为是从1949年香农Shannon发表的《保密系统的信息理论》，将密码学的研究纳入了科学的轨道上，主要安全问题是窃听和分析。计算机安全阶段：20世纪70年代，美国国家标准局公布了数据加密标准（DES）、美国国防部（DoD）公布了《可信计算机系统评估准则》（TCSEC），互联网出现后，早期互联网发展的思维方式遵守Postel法则：严于律己，宽以待人。但蠕虫病毒（Morris）的出现极大改变了互联网的开放性。信息系统安全阶段：20世纪90年代后，信息系统安全成为网络安全的核心内容。通信和计算机技术相互依存，安全的需求不断向社会的各个领域扩展，人们的关注对象从计算机转向更具本质性的信息本身，进而关注信息系统的安全。这一阶段除了强调保密性、可用性，人们还关注“不可否认性”。1993年6月，美国政府同加拿大及欧共体共同起草单一的通用准则（CC标准）并推广到国际标准，制定该标准的目的是：建立一个各国都能接受的通用的信息安全产品和系统的安全性评估准则。网络安全空间阶段：进入21世纪，网络逐渐成为既海陆空天之后的第五大人类生存空间。网络空间安全引起各国的高度关注，将其视为国家安全基础。仅从传统的保密性、完整性、可用性来理解已经太够，更需要关注国层面的政治、经济、文化、军事等影响。 3、网络安全体系结构 网络安全体系概述：参照开放系统互联安全体系结构 ISO 7498-2 标准，其核心内容是：为了保证异构计算机进程之间远距离交换信息的安全，定义了系统应当提供的5种安全服务和8种安全机制，确定了安全服务与安全机制之间的关系，以及OSI参考模型中安全服务和安全机制的配置。
OSI参考模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
安全服务：鉴别、访问控制、数据完整性、数据保密性、抗抵赖。
鉴别：鉴别服务是对通信中的对等实体和数据来源的鉴别。访问控制：访问控制决定了什么实体可以访问什么资源，以防止未授权的实体访问系统内的资源。数据完整性：数据完整性服务可以防止或检测信息资源收到篡改等破坏。数据保密性：数据保密性服务是对数据提供保护、使之不被非授权的泄露。抵赖性：抵赖性也称不可否认性，主要变现为原发抗抵赖和接受抗抵赖。即数据发送者无法否认发送数据的事实，数据接收者无法否认其接收过这些数据。 安全机制：加密、数字签名、访问控制、数据完整性、鉴别交换、通信业务填充、路由选择控制、公证。
加密：加密机制能为数据和通信业务流信息提供保密性。数字签名：数字签名机制分为两个过程，一是签名过程，而是签名验证。签名过程是使用签名者所私有的信息，以保证签名的唯一性，验证签名过程所用的程序和信息是公之于众的，以便每个人都可以验证改签名，但无法从中推断签名着的私有信息。访问控制：为了判断一个实体是否具有访问权，访问控制机制可以使用该实体已经鉴别过的身份（如登陆系统后的身份）进行访问控制。如果该实体试图访问非授权的资源，那么访问控制功能会拒绝其访问，并产生日志等警告。数据完整性：分两个方面，一是数据单元完整性，二是数据流的完整性。数据单元完整性又涉及两个过程，分别是发送实体和接受实体。发送实验给数据单元附加上一个量（通常为哈希值），且这个量本身可以被加密，接受实体根据数据单元产生一个相应的量，并与发送方的量进行比较，以此确定发送的数据单元是否被篡改；数据流完整性可以采用顺序号、时间标记或密码链等手段。鉴别交换：鉴别交换机制是通信过程中一方鉴别另一方身份的过程。通信业务填充：指在正常通信流中增加冗余信息，能抵抗通信业务分析。路由选择控制：路由能动态地设定，以便物理上安全的子网络、中继站或者链路使用。公正：由于第一方和第二方相互不信任，故寻找双方都信任的第三方，通过第三方背书在前两方之间建立信任。 安全服务于安全机制关系：
安全产品：防火墙、入侵检测系统、恶意代码防护。
防火墙：在内部网络与不安全网络之间存在的类似防护栏的保护机制，阻断来自外部的网络入侵，保护内部的网络安全。 防火墙功能：访问控制、内容控制、安全日志、集中管理、VPN（虚拟专用网络）、NAT（网络地址转换）等。入侵检测系统（IDS）：通过监视受保护系统或网络的状态，可发现正在进行或已经发生的网络攻击。 IDS功能：监视用户和系统的活、发现入侵行为、记录和警报。IDS分类： 基于主机的IDS:基于主机的IDS用于保护运行关键应用的主机。通过监视和分析主机的审计记录和日志文件来检测入侵。 优点是能确定攻击是否成功、监视粒度更精细、配置灵活、适用于加密网络、不需要额外硬件。基于网络的IDS:基于网络的IDS主要用于实时监测网络关键路径的信息，通过侦听网络上的所有分组来分析入侵行为。 优点是实施提供网络保护、可检测面向网络的攻击、不会影响现有的网络的性能、更全面的监视企业网络、操纵维护相对简单。缺点是无法在加密的环境中使用。恶意代码防护：恶意代码是一个计算机程序或一段程序代码，执行后完成特定的功能，但这些功能是恶意的，，有破坏作用的，如计算机病毒。 恶意代码分类： 病毒：一种通过修改其他程序或进行自身复制，从而感染其他程序的一段程序，具有传染性、隐蔽性、潜伏性、多态性和破坏性等特征。蠕虫：利用操作系统漏洞进行传播，属于病毒的一种发展。特洛伊木马：指一个隐藏在合法程序中的非法程序。该非法程序在用户不知情的情况下执行。隐身的木马程序能实现如删除信息、发送消息等功能。逻辑炸弹：可以理解为满足特定逻辑条件时就试试破坏的计算机程序，不具备病毒的传播性。 4、网络安全事件 APT攻击特性：潜伏性、持续性、单点隐蔽性、攻击渠道多样性、针对特定目标。
安全事件：
震网病毒：世界上第一例针对工控系统的病毒。该病毒不经过互联网传播，而是凭借用户U盘从一台计算机传播到另一台计算机，或者通过局域网传播。利用的漏洞是软件开发者和反病毒公司还未发现的漏洞。内部设置有行动截止日期，当病毒进入一台新的计算机是会检查日期，若晚于规定的时间则停止感染。WannaCry勒索病毒：该病毒利用NSA泄露的“永恒之蓝”黑客武器攻击Windows系统445端口。过去通过邮件、挂马传播。 永恒之蓝：是美国国家安全局（NSA）研发的网络武器，用于攻击特定的政府企业目标。丰收行动：通过鱼叉式钓鱼从而实现信息窃取。摩诃草事件：境外APT组织，主要针对中国、巴基斯坦等亚洲国家进行网络间谍活动。鱼叉攻击：针对特定组织的网络欺诈行为，目的是不通过授权来访问机密数据。常见的方法是将木马程序当做电子邮件发给特定目标，诱使其打开附件。 二、网络安全法律法规 1、网络安全法背景概述 网安法的背景：
国际背景：主要围绕国际间的合作与共赢、冲突和对抗国内背景： 大量的网络安全时间的出现以及所造成的经济损失地下黑产的扩大、网络攻击越来越多新型技术的持续发展与应用我国信息化建设的突飞猛进网络安全人才建设的滞后法律法规条文的分散和监管的滞后 各国网络安全法的重点制度：
机构职责和管理制度监测预警和应急关键信息基础设施保护数据安全保护信技术新业务安全 我国网络安全法发展历程：
2014.2：中央安全和信息化领导小组成立，标志着我国把网络安全提升到了国建安全的高度，并开始酝酿网络安全法编写工作2015.6.26：十二届全国人大常委会第一次审议了《网络安全法（草案）》2016.6.28：十二届全国人大常委会第二次审议了《网络安全法（草案）》2016.10.31：十二届全国人大常委会第三次审议了《网络安全法（草案）》2016.11.7：《中户人民共和国网络安全法》最终审议通过2017.6.1：《中户人民共和国网络安全法》正式实施 三次审议：
第一次审议（2015年6月26日）： 明确网络空间主权原则对关键基础设施安全实施重点保护加强网络安全监测预警和应急制度建设第二次审议（2016年6月28日）： 明确重要数据境内存储，建立数据跨境安全评估制度鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系第三次审议（2016年10月31日）： 进一步界定关键信息基础设施范围增加惩治攻击破坏我国关键信息基础设施的境外组织和个人的规定增加惩治网络诈骗等新型网络违法犯罪活动的规定加强网络安全人才培养、未成年人上网安全 网络安全法建设发展历程：
通信保密安全：保守国家秘密法（1989）（2010年修订）、计算机信息系统安全保护条例计算机安全：计算机信息系统安全保护（1994）、计算机信息系统安全专用产品检测和销售许可证管理办法-97网络信息系统安全：关于维护互联网安全的决定（2000）、互联网信息服务管理办法、计算机病毒防治管理办法、计算机信息系统国际联网保密管理规定-00网络空间安全：网络安全法（2016）、国家安全法（2015）、刑法修正案（七）、刑法修正案（九） 网络安全法特点：
网络安全法是我国的第一部网络安全领域的法律，是保障网络安全的基本法网络安全法不是网络安全立法的重点，而是起点《网络安全法》与《国际安全法》、《保密法》、《反恐怖主义法》、《反间谍法》、《刑法修正案（九）》、《治安管理处罚法》、《电子签名法》等法律同属同一法律阶位网络安全法是我国网络安全的基本法律，与其他相关法律在相关条款和规定上互相衔接，互相呼应，共同构成了我国网络安全管理的综合法律体系网络安全法也是在现行的一些制度的基础上，上升和完善的成果。 2、网络安全法解读 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80fb7cabab92c1e7aa1c5f1af3a796e/" rel="bookmark">
			Modbus通信基础知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus通信基础知识总结 参考资料：
MThings 软件使用说明：(C:\Users\Tony\D\work\program\QT\serve_moter\MThings)
https://blog.csdn.net/zhoutanliang/article/details/106441890
DS5L1系列伺服驱动器用户手册。
http://m.xinje.com/upload/202304/11/202304111045237246.pdf
5.1 Modbus通信协议 Modbus是主从方式通信，其通讯模式半双工，不能同步进行通信。大致分为以下几种:
Modbus-RTU
Modbus-ASCII（ASCII多了帧头和帧尾，也就是说可以有用这个头尾判断一帧字节来判断是否结束，两帧之间要大于3.5个字节时间间隔）
Modbus-TCP
以上三种协议，一个设备只会有一种协议。RTU是主要的，其他是备用。
5.1.1 字符结构 伺服驱动器默认数据格式为：1 位起始位，8 位数据位，1 位停止位。那就是无校验位。
下面是国标要求的。
奇校验：原始码流+校验位 总共有奇数个1
偶校验：原始码流+校验位 总共有偶数个1
5.1.2 帧结构 帧结构 = 地址 + 功能码+ 数据 + 校验
地址: 占用一个字节，范围0-255，其中有效范围是1-247，其他有特殊用途，比如255是广播地址。
功能码：占用一个字节，常见功能码如下：
查询功能码0x03，读
修改功能码0x06，写
批量修改功能码0x10（修改多个寄存器）
示例：
主机发送: 01 03 00 00 00 01 84 0A
从机回复: 01 03 02 19 98 B2 7E
手册中的示例：
功能码03H：读出寄存器内容
例如：读出U0-05寄存器地址H1005内容（母线电压）。
MODBUS 使用一个‘big-Endian’ 表示地址和数据项。这意味着当发射多个字节时，首先发送最高有效位。例如：
16 – 比特 0x1234 发送的第一字节为 0x12 然后 0x34
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d80fb7cabab92c1e7aa1c5f1af3a796e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0321fb8c1e588b0ca44078fad2394bb4/" rel="bookmark">
			Java8中Stream流的常用姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 Stream概述2 Stream的创建3 Stream的使用3.1 遍历/匹配（foreach/find/match）3.2 筛选（filter）3.3 聚合（max/min/count)3.4 映射(map/flatMap)3.5 归约(reduce)3.6 收集(collect)3.6.1 归集(toList/toSet/toMap)3.6.2 统计(count/averaging)3.6.3 分组(partitioningBy/groupingBy)3.6.4 接合(joining)3.6.5 归约(reducing) 3.7 排序(sorted)3.8 提取/组合 4 Stream源码解读 1 Stream概述 Java 8 是一个非常成功的版本，这个版本新增的Stream，配合同版本出现的 Lambda ，给我们操作集合（Collection）提供了极大的便利。
那么什么是Stream？Stream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。
Stream可以由数组或集合创建，对流的操作分为两种：
中间操作，每次返回一个新的流，可以有多个。终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。 另外，Stream有几个特性：
stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。stream不会改变数据源，通常情况下会产生一个新的集合或一个值。stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。 2 Stream的创建 Stream可以通过集合数组创建。
1、通过 java.util.Collection.stream() 方法用集合创建流
List&lt;String&gt; list = Arrays.asList("a", "b", "c"); // 创建一个顺序流 Stream&lt;String&gt; stream = list.stream(); // 创建一个并行流 Stream&lt;String&gt; parallelStream = list.parallelStream(); 2、使用java.util.Arrays.stream(T[] array)方法用数组创建流
int[] array={1,3,5,6,8}; IntStream stream = Arrays.stream(array); 3、使用Stream的静态方法：of()、iterate()、generate()
Stream&lt;Integer&gt; stream = Stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0321fb8c1e588b0ca44078fad2394bb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7173be31554b5cd145a0240ce960f930/" rel="bookmark">
			小程序中跳转H5外部链接使用webview
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 webview组件可以跳转H5链接：
属性：src：跳转的路径；
&lt;web-view :src="url"&gt;&lt;/web-view&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933fa034ef73dcf6cbd6f7e984f0e656/" rel="bookmark">
			Lua的闭包深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lua的闭包深入理解 Lua迭代器lua中什么是闭包？司法域 闭包的应用闭包的实现原理 Lua迭代器 这里如果有不明白迭代器的可以去看我之前的文章Lua迭代器
这里在提一嘴：
无状态迭代器是不保留任何状态的迭代器，这里避免创建闭包花费的额外代价，降低了性能消耗。（典型的就是ipairs）
多状态迭代器需要保留多个状态，而不是简单的保留状态常量和控制变量等，最简单的方法就是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数，仅一个即可。
lua中什么是闭包？ 在Lua中，闭包（closure）是由一个函数和该函数会访问到的非局部变量（或者是upvalue）组成的，其中非局部变量（non-local variable）是指不是在局部作用范围内定义的一个变量，但同时又不是一个全局变量，主要应用在嵌套函数和匿名函数里，因此若一个闭包没有会访问的非局部变量，那么它就是通常说的函数，也就是说，在Lua中，函数是闭包一种特殊情况。另外在Lua中的C API中，所有关于Lua中的函数的核心API都是以closure来命名的，也可视为这一观点的延续。在Lua中，函数是一种第一类型值（First-Class Value），它们具有特定的司法域（Lexical Scoping）。
第一类型值表示函数与其他传统类型的值（例如数字和字符串类型）具有相同的权力。即函数可以存储在变量或table中，可以作为实参传递给其他函数，还可以作为其他函数的返回值，可以在运行期间被创建。在Lua中，函数与所有其他的值是一样都是匿名的，即他们没有名称。当讨论一个函数时（例如print），实质上在讨论一个持有某个函数的变量。
比如：
function foo(x) print(x) end 实质是等价于
foo = function (x) print(x) end 因此一个函数定义实质就是一条赋值语句，这条语句创建了一种类型为“函数”的值，并赋值给一个变量。可以将表达式function(x) --函数主体 end 视为一种函数构造式，就像table的构造式{ }一样。
值得一提得是，C语言里面函数不能在运行期间被创建，因此不是第一类值，不过有时他们被称为第二类值，原因是他们可以通过函数指针实现某些特性，比如常常显现得回调函数得影子。
司法域 司法域是指一个函数可以嵌套在另一个函数中，内部得函数可以访问外部函数的变量。比如：
function f1(n) --函数参数n也是局部变量 local function f2() print(n) --引用外部函数的局部变量 end return f2 end g1 = f1(2015) g1() -- 打印出2015 g2 = f1(2016) g2() -- 打印出2016 注意这里的g1和g2的函数体相同（都是f1的内嵌函数f2的函数体），但打印值不同。这是因为创建这两个闭包时，他们都拥有局部变量n的独立实例。事实上，lua编译一个函数时，会为它生成一个原型（prototype），其中包含了函数体对应的虚拟机指令、函数用到的常量值（数，文本字符串等等）和一些调试信息。在运行时，每当lua执行一个形如function … end这样的表达式时，他就会创建一个新的数据对象，其中包含了相应函数原型的引用及一个由所有upvalue（方法内实例的成员变量）引用组成的数组，而这个数据对象就成为闭包。由此可见，函数是编译期概念，是静态的，而闭包是运行期概念，是动态的。g1和g2的值严格来说不是函数二十闭包，并且是两个不相同的闭包，而每个闭包能保有自己的upvalue值，所以g1和g2打印出的结果当然就不相同了。
这里的函数f2可以访问参数n，而n是外部函数f1的局部变量。在f2中，变量n即不是全局变量也不是局部变量，将其称为一个非局部变量（non-local variable）或upvalue。upvalue实际指的是变量而不是值，这些变量可以在内部函数之间共享，即upvalue提供一种闭包之间共享数据的方法，比如：
function Create(n) local function foo1() print(n) end local function foo2() n = n + 10 end return foo1,foo2 end f1,f2 = Create(2015) f1() -- 打印2015 f2() f1() -- 打印2025 f2() f1() -- 打印2035 注意上面的例子中，闭包f1和f2共享同一个upvalue了，这是因为当Lua发现两个闭包的upvalue指向的是当前堆栈上的相同变量时，会聪明地只生成一个拷贝，然后让这两个闭包共享该拷贝，这样任何一个闭包对该upvalue进行修改都会被另一个探知。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/933fa034ef73dcf6cbd6f7e984f0e656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4b467a1dc88da5d3277d9c0d59239b/" rel="bookmark">
			兼容M1 M2 Navicat Premium 中文最新激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Navicat Premium是一款功能强大的数据库管理工具，它支持多种数据库系统的管理和操作，包括MySQL、MariaDB、MongoDB、SQL Server、Oracle、PostgreSQL和SQLite。
Navicat Premium 中文
以下是对Navicat Premium软件好用与否的说明：
Navicat Premium具有强大的数据库设计和建模功能，支持可视化地设计数据库结构、创建表和关系、定义索引和约束等。它还支持逆向工程，可以根据现有数据库生成数据库模型和结构图。
Navicat Premium提供了灵活的数据导入和导出功能，可以快速地将数据从不同的数据源导入到数据库中，或者将数据库数据导出为多种格式，如CSV、Excel、JSON等。它还支持批量导入导出和数据转换操作。
Navicat Premium具有快速的数据编辑和查询功能，支持直接编辑表数据、执行SQL查询和脚本。它提供了语法高亮、代码自动完成、查询构建器等工具，帮助开发者快速编写和执行复杂的数据库查询和操作。
Navicat Premium还提供了安全和权限管理功能，可以帮助开发者管理数据库用户、角色和权限，控制对数据库的访问和操作。它支持SSL/TLS连接和数据加密，提供了密码保护和加密存储功能，确保数据库的安全性。
Navicat Premium还允许开发者自动化常见的数据库任务和操作，如数据同步、备份、脚本执行等。它提供了任务计划和调度功能，可以按照预定的时间和条件执行任务，以提高工作效率。
总体来说Navicat Premium是一款功能丰富的数据库管理工具，适用于多种数据库系统，具有直观易用的界面和灵活的数据导入导出功能，同时也提供了快速的数据编辑和查询功能以及安全和权限管理功能。但是具体是否适合使用还需要根据用户的实际需求和使用场景来进行评估。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/54/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>