<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9025a567d7410e6f83596d8f1d9c9680/" rel="bookmark">
			C&#43;&#43;学习-List学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;Qlist&gt; #include &lt;list&gt; #include &lt;functional&gt; //仿函数要的头文件 #include &lt;string&gt; 模板函数 template &lt;class _Ty&gt; void PrintfList(QList&lt;_Ty&gt; data) { qDebug() &lt;&lt; "模板函数" &lt;&lt; "\t"; for (auto v : data) { qDebug() &lt;&lt; v &lt;&lt; "\t"; } qDebug() &lt;&lt; "\n"; } 基本操作 QString tmepList[5] = {"3医院","1学校","9学位","0衣","2行"}; QList&lt;QString&gt; strList; for (int i = 0; i &lt; 5; i++) { strList.push_back(tmepList[i]);//尾插法 } strList.push_front("10胶水"); //头插法 for (int i = 0; i &lt; strList.size(); i++) { qDebug() &lt;&lt; strList[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9025a567d7410e6f83596d8f1d9c9680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a316c288784b6fcd39cbcdbc0b5fbd5b/" rel="bookmark">
			web端播放rtsp视频流（摄像头监控视频）教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、ffmpeg是什么？二、ffmpeg安装1.下载2.安装 三、node搭建websocket服务四、web客户端播放视频 前言 像海康大华一些摄像头或者直播源 为rtsp视频流，想在web上播放必须进行协议转换。已知一些方案例如rtsp转rtmp需要flash，现在浏览器基本不支持flash。还有转hls或者flv这些延迟都比较高。经过实践对比比较理想方案是 经转码后视频流通过websocket传送给客户端在将视频流解码成图片通过canvas渲染出来，延迟比较小基本在1s以内。所用工具(插件)为ffmpeg+node（node-rtsp-stream）+jsmpeg
一、ffmpeg是什么？ FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案，简而言之就是一个可以转换各种视频流格式/协议的强大工具。
二、ffmpeg安装 1.下载 ffmpeg下载地址
进入官网选择window图标-点击windows builds form gyan.dev
进入内页下拉找ffmpeg-release-essentials.zip点击下载
下载完解压
在bin目录下有个ffmpeg.exe 程序运行入口
2.安装 ffmpeg添加到全局环境变量 window+i 输入’环境变量’搜索打开系统属性窗口
点击环境变量，在系统变量中找到Path点击编辑
浏览-选择ffmpeg解压出来的bin目录
确定-确定-确定关闭窗口
添加成功后验证是否生效
任意地方打开Powershell窗口或cmd窗口
输入 ffmpeg 打印如下表示成功
三、node搭建websocket服务 此功能需要借助node-rtsp-stream插件，node-rtsp-stream是一个node环境下处理rtsp视频流插件，借助它能通过代码自动调用ffmpeg程序进行推流拉取转换并以websocket形式输出视频流。
由于在node下搭建服务，所以电脑要先安装node环境。怎么安装node环境自行查找其他教程。
新建一个app.js文件，同级目录下npm安装 node-rtsp-stream
npm install node-rtsp-stream -S app.js写入：
const stream = require('node-rtsp-stream') new stream({ name: 'video-stream', streamUrl: 'rtsp://xxxxx',//rtsp地址 wsPort: 9999,//端口号 ffmpegOptions: { '-stats': '', '-r': 30 ,//视频帧数 '-s': '1920*1080' //视频分辨率 } }) 运行
node app.js 出现上面打印一堆推流数据表示node服务启动成功，服务端工作就完成了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a316c288784b6fcd39cbcdbc0b5fbd5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be74a3a226cbed26daad8332c1420b5/" rel="bookmark">
			纯c语言实现的监控windows下U盘的插拔并读取指定文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;windows.h&gt; #include &lt;dbt.h&gt; #include &lt;math.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; int readFile(const char * nodeStatus) { FILE *filePtr; // 文件指针 char filePath[256]; // 存储文件路径的缓冲区 char line[256]; // 存储每行内容的缓冲区 const char *directory; // 文件所在的目录路径 const char *fileName; // 文件名 directory = nodeStatus; fileName = ":\\cfg.ini"; // 拼接文件路径 strcpy_s(filePath, sizeof(filePath), directory); // 添加目录路径 strcat_s(filePath + strlen(directory), sizeof(filePath) - strlen(directory), fileName); // 添加文件名 // 使用fopen_s函数打开文件 if (fopen_s(&amp;filePtr, filePath, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be74a3a226cbed26daad8332c1420b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bfb98988f830eb1a61b39e7f1ab15a/" rel="bookmark">
			加密流量分析的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 流量收集 什么是流量收集 流量采集是指在计算机网络中收集和记录网络流量数据的过程。这一过程通常由网络管理员、安全专业人员、网络分析师或研究人员使用特定工具和技术来执行。流量采集对于理解网络性能、进行故障排除、进行安全监控和进行网络分析都非常重要。
流量收集目的 流量采集的目的可以是多方面的，包括网络性能监测、故障排除、安全威胁检测、网络优化、业务分析等。不同的目标可能需要不同的采集策略和工具。
流量收集方法 数据包捕获： 使用数据包捕获工具（例如Wireshark、tcpdump等），直接捕获网络中传输的数据包。这些工具可以在特定网络接口上监听数据包，并将其详细信息存储到文件中，以供后续分析。流量镜像： 流量镜像是通过配置网络设备（如交换机或路由器）使其复制网络流量，并将其发送到指定的监控端口。这样可以在不影响原始流量的情况下进行实时监测和分析。流量代理： 使用流量代理或代理服务器来中继网络流量。流量通过代理服务器时，可以对其进行监视和记录。这种方法常用于安全网关、VPN服务等场景。网络流日志： 网络设备（如防火墙、路由器、交换机）通常会生成网络流日志，记录网络流量的摘要信息，例如源/目标IP地址、端口、协议等。这些日志可用于分析网络活动。流量生成器： 通过使用流量生成器工具，可以模拟网络流量，生成符合特定场景或负载条件的数据包。这对于性能测试、安全评估和网络规划非常有用。应用层代理： 在应用层使用代理，例如Web代理或代理服务器，可以监测和记录特定应用程序的流量。这对于分析Web浏览、电子邮件等应用层协议非常有用。流量监控设备： 专门的流量监控设备，如入侵检测系统（IDS）、入侵防御系统（IPS）等，可以捕获和分析流经网络的流量，检测异常行为和安全威胁。日志分析： 对网络设备生成的日志进行分析，以识别和了解网络流量。这包括审计日志、系统日志和安全事件日志等。 流量收集工具 有许多专门设计用于采集网络流量的工具。其中一些工具包括Wireshark、tcpdump、tshark、Snort等。这些工具可以捕获网络数据包，显示其详细信息，并将其保存到文件中供后续分析使用。
2. 流量表示 什么是流量表示？ ​ 流量表示指的是以一种结构化的方式呈现计算机网络中的流量数据，以便进行分析、监控或其他相关的网络活动研究。在网络中，流量表示可以采用不同的形式，具体取决于分析的需求和使用的工具。
流量表示的目的 ​ 流量表示的目的是为了更好地理解和分析计算机网络中的数据流动，以便进行网络管理、性能优化、安全监控等任务。对于不同的应用场景，流量表示可能是不同的。优越的流量表示可以提高效率并减少开销。
流量表示方法 数据包级别表示： 最基本的流量表示是在数据包级别。每个数据包都包含有关网络通信的详细信息，如源和目标IP地址、源和目标端口、协议类型、数据包大小等。Wireshark等数据包捕获工具通常以这种方式表示流量。流级别表示： 流级别表示将具有相同源和目标IP地址、端口和协议的一组数据包组合成一个流。这种表示方式更加抽象，用于汇总和分析一组相关的数据包，以便更好地理解通信模式。统计特征表示： 在流量分析中，还可以采用统计特征来表示流量。这包括数据包的长度、到达时间间隔、数据包的数量、总字节数等。通过对这些统计特征的分析，可以洞察网络的性能、行为和异常情况。流量图表示： 流量图是一种图形化表示方法，将网络流量的关系和模式以图形方式展示。流量图可以是时间序列图、拓扑图、饼图等，有助于直观地理解和分析网络流量。协议级别表示： 将流量按照协议进行分类，表示每种协议的流量状况。这有助于识别网络中使用的不同协议和应用程序。应用层表示： 对于特定应用程序的流量分析，可以以应用层协议的方式进行表示。例如，HTTP请求和响应的表示、电子邮件传输的表示等。 3. 加密流量分析方法 基于机器学习基于深度学习基于知识 4. 性能评估 有效性时间开销泛化能力 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbe06c0e796996b4f4347e6787824b91/" rel="bookmark">
			(vue)el-cascader级联选择器实现单/多选最后一级并回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 (vue)el-cascader实现多选最后一级并回显 &lt;el-form-item label="选择算法模型："&gt; &lt;el-cascader v-model="formInline.algorithmId" :options="modelOptions" :props="{ value: 'id', label: 'name', multiple: true, emitPath: false,}" //后俩个重点 filterable clearable placeholder="请选择" style="width: 430px;" @change="modelChange" &gt; //自定义展示 &lt;template slot-scope="{ node, data }"&gt; &lt;span&gt;{{ data.name }}&lt;/span&gt; &lt;span v-if="!node.isLeaf"&gt;({{ data.children.length }})&lt;/span&gt; &lt;/template&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; //算法模型改变 modelChange(val) { console.log("算法模型改变"); console.log(val); }, 拓展：单选只取最后一级 &lt;el-form-item label="工序"&gt; &lt;el-cascader v-model="formInline.processId" :options="processOptions" :props="{ value: 'id', label: 'name' }" :show-all-levels="false" //重点 @change="ziduanSearch" &gt;&lt;/el-cascader&gt; &lt;/el-form-item&gt; //字段 ziduanSearch(val) { this.formInline.processId = val[val.length - 1]; }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de65366ac945d65246c1e85d4aa7c08/" rel="bookmark">
			第九届云计算与大数据分析国际会议（ICCCBDA 2024）即将召开！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
第九届云计算与大数据分析国际会议（ICCCBDA 2024）将于2024年4月25-27日在中国成都召开。ICCCBDA自创办以来，已经成功召开了八届。此次会议将介绍一些当前和未来的前沿技术趋势、创新方案、研究成果，以及和云计算和大数据分析相关领域的企业及其应用的最新发展。我们期待着您来到拥有文化底蕴的美丽成都，这里融合了尖端技术和古老文化，为行业提供了对过去、现在以及未来的融合创新。
会议官网： ICCCBDA 2024 - 成都 | 第九届云计算与大数据分析国际会议
组织单位： ​
征稿主题： 1.云计算模型、计算和云应用
面向大数据的云计算和网格计算
云应用架构
云应用的可伸缩性和可用性
云应用性能和监控
云计算和语义网技术
云计算架构与系统
云计算模型、模拟、设计和范例
云计算技术、服务和应用
2.大数据科学与工程应用
大数据处理的算法和编程技术
大数据分析搜索算法与系统
大数据分析分析和指标
大数据分析架构
大数据存储、索引、检索和查询
大数据分析加密
移动和普适计算中的大数据分析
大数据分析管理
更多征稿主题请访问会议官网
会议出版及检索： 通过会议审核且收录的文章将以 ICCCBDA 2024论文集的形式由IEEE出版，收录至IEEE Xplore, 并在会后被 EI Compendex 和 Scopus 检索。
​
​
ICCCBDA 2024 已列入IEEE官方支持会议列表。
​
特刊出版： 会后优秀文章(扩充至少30%)可推荐至以下期刊发表:
​
Human-Centric Intelligent Systems
Indexing: Baidu, CLOCKSS, CNKI, CNPIEC, DBLP, Dimensions
​
Philosophical Transactions of The Royal Society A-Mathematical Physical And Engineering Sciences
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de65366ac945d65246c1e85d4aa7c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8524166c9dfb4ee7d23a34336b050d21/" rel="bookmark">
			向量与矩阵范数的详细解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、向量 L0范数：向量中非零元素的个数，也称为0范数L1范数：为绝对值之和，也称为范数或者1范数L2范数：通常意义上的模，也称为2范数p范数：即向量元素绝对值的 p p p次方和的 1 / p 1/p 1/p次幂 ∞ \infty ∞范数：取向量的最大值 − ∞ -\infty −∞范数：取向量的最小值 假设有向量 x = ( x 1 , x 2 , … , x n ) T x = (x_1,x_2,\dots,x_n)^T x=(x1​,x2​,…,xn​)T，向量的范数有：
∣ ∣ x ∣ ∣ 1 = ∣ x 1 ∣ + ∣ x 2 ∣ + ⋯ + ∣ x n ∣ ||x||_1 = |x_1| + |x_2| + \dots + |x_n| ∣∣x∣∣1​=∣x1​∣+∣x2​∣+⋯+∣xn​∣
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8524166c9dfb4ee7d23a34336b050d21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417bddcb0909fbb105e0a4c54eb4329a/" rel="bookmark">
			tomcat对数据库信息对进行添加操作和修改操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先在接口方法中添加相应接口方法：
//添加新产品 @Insert("insert into db.brand values(null,#{brandName},#{companyName},#{ordered},#{description},#{status})") void addBrand(brand brand); 在service中添加对应的方法：
public void addBrand(brand brand){ String resource = "mybatis-config.xml"; InputStream inputStream = null; inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); brandMapper brandMapper = sqlSession.getMapper(brandMapper.class); brandMapper.addBrand(brand); sqlSession.commit(); sqlSession.close(); } 然后开始写添加新产品的信息jsp
&lt;%-- Created by IntelliJ IDEA. User: quwenhao Date: 2023/12/28 Time: 19:27 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417bddcb0909fbb105e0a4c54eb4329a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0539dda80821fe358acea25133d8823/" rel="bookmark">
			vim文本编辑器，常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、常用模式
2、基本移动光标
3、插入和替换文本
4、删除和复制文本
5、搜索和替换
6、保存和退出
Vim是一款功能强大的文本编辑器，在Linux系统中被广泛使用。它提供了丰富的编辑和操作功能，适用于编程、文件编辑、配置文件修改等各种任务。
下面是对Vim常用场景详解：
1、常用模式 ①普通模式（Normal Mode）：默认启动时进入的模式，用于浏览、编辑和移动光标。可以进行文本导航、删除、复制、粘贴等基本操作。 可以执行一些命令，如保存文件、退出编辑器等。
②插入模式（Insert Mode）：通过按下 i 键或 a 键进入该模式，用于输入和编辑文本。可以直接输入文本内容，类似于普通的文本编辑器。
③可视模式（Visual Mode）：通过按下 v 键进入可视模式，用于选择并操作一段文本区域。可以选择字符、行或块，并对所选区域执行操作。
④命令行模式（Command-Line Mode）：通过按下 : 键进入命令行模式，用于执行各种命令。可以执行搜索、替换、保存文件、设置选项等高级操作。
2、基本移动光标 h、j、k、l：左、下、上、右移动光标w、b：按单词前进或后退gg、G：跳转到文件开头或结尾^、$：跳转到行首或行尾 3、插入和替换文本 i：在当前位置之前插入文本a：在当前位置之后插入文本o/O：在当前行之后/之前插入新行r/R：替换单个字符/连续替换多个字符 4、删除和复制文本 删除一个字符：将光标定位在要删除的字符上，按下 x 键。删除整行：将光标定位在要删除的行上，按下 dd 键。复制整行：将光标定位在要复制的行上，按下 yy 键。粘贴剪切板内容：将光标定位到目标位置，按下 p 键。 5、搜索和替换 搜索：
/keyword：向前搜索关键字。?keyword：向后搜索关键字。在上述命令后按下回车后，光标会跳转到第一个匹配的结果处。使用 n 键可以继续查找下一个匹配项。 替换：
:%s/old/new/g：全局替换所有匹配的内容。
%s 表示对整个文档进行替换操作。old 是要被替换的内容。new 是要替换成的新内容。g 表示全局替换（即一行中多次出现的匹配都将被替换）。 6、保存和退出 保存文件：在命令模式下输入 :w，然后按回车。退出编辑器：在命令模式下输入 :q，然后按回车。保存并退出：在命令模式下输入 :wq ，然后按回车。强制退出或强制保存退出：在相关命令后面加上叹号，即:q! 或 :wq! 。 自己创建一个文本文件，实践一下吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd28fc9f40654a6c4825c537839f376/" rel="bookmark">
			Windows设置时间同步周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、确认是否存在Windows Time服务
如果没有通过cmd，注册
w32tm /register
2、修改 NTP 同步时间的周期
注册表信息：
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpClient]
双击SpecialPollInterval，修改其数值
切换为十进制
默认为 604800 （60 * 60 * 24 * 7），一周
可以改成 86400 （60 * 60 * 24），一天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488056f09f3e062f7e834d4bdd6a143c/" rel="bookmark">
			五种UI设计师的必备界面设计工具，干货来袭！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具的重要性对设计师来说是不言而喻的。任何想法都需要通过工具来实现。要成为一名优秀的UI设计师，你需要掌握更多的技能来增强你的竞争力。同时，我们也给那些想成为UI设计师的朋友一些工具建议。接下来，让我们来看看那些UI设计师需要掌握的界面设计工具。
1. 即时设计 支持平台：网页端、macOS、Windows、Linux、iOS、Android 和微信小程序
UI设计师的必备免费界面设计工具即时设计是一款支持在线协作的专业级 UI 设计工具，支持 Sketch、Figma、XD 格式导入，海量优质设计资源即拿即用。支持创建交互原型、获取设计标注，为产设研团队提供一站式协同办公体验。https://js.design/?source=csdn&amp;plan=bttcsdn0312
即时设计是一个专业的在线界面设计软件，UI 设计师必备，无需下载，打开浏览器就能免费用，设计、原型、开发一站式完成，高质量的界面设计轻松搞定～
UI 界面设计功能强大，钢笔、蒙版、布尔运算，图形、切片、自动布局，滤镜、阴影、轮廓化，实力强大，是一个高质量的界面设计软件。
拥有 1700 + 的 UI 界面设计资源，想要什么样的界面设计模板及插件，统统都由你挑选，随心设计。
集成 Sketch、Figma、Adobe XD 等主流界面设计软件，与其数据同步，设计稿轻松导入 / 导出，支持用多个软件合力完成一个高质量的界面设计作品。
交互能力强，智能动画、交互事件、原型连线统统一步搞定，出入场动画、交互事件演示等，模拟最真实的页面转化逻辑和用户使用场景。
多人团队成员实时协作，与合作人员和利益相关者直播级同步当前进度及最新修改版本，哪里有意见就直接点哪里反馈评论，方便达成界面设计共识。
海量设计资源就在即时设计即时设计是一款支持在线协作的专业级 UI 设计工具，支持 Sketch、Figma、XD 格式导入，海量优质设计资源即拿即用。支持创建交互原型、获取设计标注，为产设研团队提供一站式协同办公体验。https://js.design/?source=csdn&amp;plan=bttcsdn0312
2. Photoshop-强大的图片处理软件 支持平台：Windows＆Mac Photoshop是最受欢迎的图像编辑器之一，也是UI设计师介绍的必要界面设计工具。我相信我不是设计行业的朋友，我也知道一两个。PS作为UI界面设计的神器，具有强大的图像编辑和处理功能，可以用PS实现任何图形，可以用于摄影的后期制作，可以添加各种滤镜，调整亮度、对比度等，生成高分辨率的图形。图层面板可以非常简单和有效地处理和修复图片；PS提供了不同文件格式的保存选项，调整图像大小和分辨率不会失去图像质量。
特色：
照片处理技术(切割背景、切割、调光、调色、过滤、消除红眼等功能)
强大的图层功能处理副本保存原件
批量处理照片
与其他Abode套件程序兼容，如Aftereffect，InDesign，Illustrator
Photoshop可以将图像保存为各种格式
3.Sketch-强大的矢量绘图工具 支持平台：只支持Mac
Sketch是一个强大的界面设计工具，专门为UI设计师设计的软件，可以使您的界面设计更加简单和高效。如果你是UX或UI设计师，那么你必须知道Sketch，一个强大的UI界面设计软件。如果你想成为一名UI设计师，那么你不能错过这个有用的设计工具。
在Sketch中，用户可以轻松设置图层面板，可以批量命名图层、智能标记页面、填充头像和文字，实现多层填充、渐变、噪声等操作功能；Sketch提供“全导出”功能，因为它是基于矢量的，所以可以导出PDF、JPG和PNG（可选择2x）和其他格式。必须提到的是，Sketch为设计师提供了丰富的插件，可以越来越满足不同人群的设计需求，你需要的所有工具都触手可及。
特色：
优秀的用户体验
非常简单易用
提供大量实用的插件
4. Zeplin-强大的协作工具 支持平台：Windows＆Mac
为UI设计师和开发工程师量身定制的合作界面设计工具。作为一名UI设计师，你需要向开发团队传达你的设计，而Zeplin的设计是为了实现这个目标。Zeplin操作非常简单。设计师直接从Sketch上传UI界面设计，应用程序会自动生成一些注释，直观地看到面板右侧每个元素的大小、颜色、边距甚至代码信息。
此外，UI设计师还可以直接在UI界面上添加注释、标记、注释等。填补了开发和设计之间的沟通障碍，为设计师和开发人员节省了大量宝贵的时间。
特色：
好的用户体验
轻松查看界面间距、尺寸、颜色等
创建风格，帮助设计团队保持一致。
Sketch中的项目通过插件快速同步
支持PS，Sketch，Adobe等工具
5. AE-强大的动效视觉处理软件 支持平台：Windows＆Mac
简称AdobeaferefectsAE“是Adobe推出的图形和视频处理界面设计工具。如今，动态设计在UI界面设计中的应用越来越广泛，国内很多公司都开始重视动态设计，所以作为UI设计师，我们也应该掌握一些动态设计。动态效果在UI设计中的应用实际上比我们想象的要强大。好的动态效果设计可以为用户提供良好的视觉体验，从而加强与用户的互动体验。
AE界面设计工具可以帮助UI设计师处理图像和视频的任何特效。它是一个基于层的灵活的2D和3D后合成软件，包括数百种特效和预设动画效果，可以与Premiere相匹配。Photoshop，Illustrator等软件无缝结合，创造出无与伦比的视觉效果。它还借鉴了许多优秀软件的成功，将图像视频特效合成技术推向了一个新的高度。
特色：
震撼的视觉效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/488056f09f3e062f7e834d4bdd6a143c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6667c3dc95fc379464e725d77832f67/" rel="bookmark">
			HTB Keeper CVE-2023-32784
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTB Keeper
使用nmap进行端口扫描
nmap -sV -sC -v -oN keeper 10.10.11.227 # Nmap 7.93 scan initiated Mon Jan 8 19:01:59 2024 as: nmap -sV -sC -v -oN keeper 10.10.11.227 Nmap scan report for 10.10.11.227 Host is up (1.4s latency). Not shown: 998 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 3539d439404b1f6186dd7c37bb4b989e (ECDSA) |_ 256 1ae972be8bb105d5effedd80d8efc066 (ED25519) 80/tcp open http nginx 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6667c3dc95fc379464e725d77832f67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688ae0ceb0959fb258628d857927df49/" rel="bookmark">
			Spring 源码分析衍生篇十三 ：事务扩展机制 TransactionSynchronization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、TransactionSynchronization1. TransactionSynchronization1.1 TransactionSynchronization 的定义1.2 TransactionSynchronizationManager 2. TransactionSynchronization 原理简述2.1 TransactionSynchronization#beforeCommit2.2 TransactionSynchronization#beforeCompletion2.3 TransactionSynchronization#afterCommit2.4 TransactionSynchronization#afterCompletion 3. 总结 三、TransactionalEventListener1. TransactionalEventListener2. 执行流程2.1 EventListenerMethodProcessor2.1.1 EventListenerMethodProcessor 的注入2.1.2 EventListenerMethodProcessor 的调用 2.2 EventListenerFactory2.3 TransactionalApplicationListenerMethodAdapter2.3.1 TransactionalApplicationListenerSynchronization2.3.2 ApplicationListenerMethodAdapter#processEvent 一、前言 本文是 Spring源码分析的衍生文章。主要是因为本人菜鸡，在分析源码的过程中还有一些其他的内容不理解，故开设衍生篇来完善内容以学习。
全集目录：Spring源码分析：全集整理
背景不知道写啥
二、TransactionSynchronization 1. TransactionSynchronization 我们这里以一个 Demo 为例，如下：当调用 DemoService#testTransactionSynchronization 方法时会往sys_role 插入role_id = 1 和 role_id = 2 的两条记录。同时该方法通过 @Transactional(rollbackFor = Exception.class) 开启了事务。
@Service public class DemoServiceImpl implements DemoService { /** * 节省空间 addRole 和 addPermission 的实现就不给出. 就是简单的往表里插入一条记录 * @return */ @Transactional(rollbackFor = Exception.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/688ae0ceb0959fb258628d857927df49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b838a388cc3eb0f7a8f1dc268cb63f/" rel="bookmark">
			【好书推荐-第三期】《深入理解Java核心技术：写给Java工程师的干货笔记》全网阅读量千万的Java工程师成神之路学习笔记，Java基础知识点查漏补缺
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😎 作者介绍：我是程序员洲洲，一个热爱写作的非著名程序员。CSDN全栈优质领域创作者、华为云博客社区云享专家、阿里云博客社区专家博主、前后端开发、人工智能研究生。公粽号：程序员洲洲。
🎈 本文专栏：本文收录于洲洲的《送书福利》系列专栏，该专栏福利多多，只需 关注+点赞+收藏 三连即可参与送书活动！欢迎大家关注本专栏~专栏一键跳转
🤓 同时欢迎大家关注其他专栏，我将分享Web前后端开发、人工智能、机器学习、深度学习从0到1系列文章。
🌼 同时洲洲已经建立了程序员技术交流群，如果您感兴趣，可以私信我加入我的社群~社群中将不定时分享各类福利
🖥 随时欢迎您跟我沟通，一起交流，一起成长、进步！点此即可获得联系方式~
本文目录 一、前言二、书籍介绍三、抽奖方式总结 一、前言 Hello，各位铁铁，今天给大家推荐一本Java好书：《深入理解Java核心技术：写给Java工程师的干货笔记》，感兴趣的各位铁铁可以直达京东官方购书链接：https://item.jd.com/13727382.html
二、书籍介绍 顾名思义，本书的适读人群自然而然就是：Java程序员，本系列图书是Java程序员系统化学习的良师益友，随书还附赠了一份惊喜彩蛋。
《深入理解Java核心技术：写给Java工程师的干货笔记（基础篇）》内容覆盖了大部分Java基础知识，非常适合Java开发者进行查缺补漏以及系统化的学习。
《深入理解Java核心技术：写给Java工程师的干货笔记（基础篇）》是《Java工程师成神之路》系列的第一本，主要聚焦于Java开发者必备的Java核心基础知识。全书共23章，主要内容包括面向对象、基础数据类型、自动拆装箱、字符串、集合类、反射、序列化、枚举、I/O、动态代理、注解、泛型、时间处理、编码方式、语法糖、BigDecimal、常用工具库及Java新版本特性等，比较全面地覆盖了Java开发者日常工作中用到的大部分基础知识。
“有道无术，术尚可求，有术无道，止于术”。本系列更加注重对Java之“道”的学习，即对原理的解读。对于很多语法概念及使用方式的介绍并不是本书的重点。所以，有一定编程语言常识或者写过Java代码的读者阅读起来会更加容易。
《深入理解Java核心技术：写给Java工程师的干货笔记（基础篇）》既适合读者进行体系化的学习，也适合读者查缺补漏，将以往所学的知识点连成线，进而构建并完善自己的知识体系。
这本书的作者也一直是我关注许久的Java大佬：Hollis。相信搞Java开发的对这Hollis绝对不陌生了，阿里的大佬：
阿里巴巴技术专家，51CTO 专栏作家，CSDN 博客专家，掘金优秀作者，《程序员的三门课》联合作者，《Java工程师成神之路》系列文章作者；热衷于分享计算 机编程相关技术，博文全网阅读量数千万。
本书的结构如下：
三、抽奖方式 抽奖送书老规矩（不点赞收藏中奖无效）：注意记得关注博主及时获取中奖通知。
1. 点赞+收藏 文章 2. 评论区留言：我要成为架构师（留言才能进入奖池，每人最多留言三条） 3. 2024年1月14日-即本周6晚八点随机抽奖5人 4. 京东自营购买链接：https://item.jd.com/13727382.html 总结 Hello，各位看官老爷们好，洲洲已经建立了CSDN技术交流群，如果你很感兴趣，可以私信我加入我的社群。
📝社群中不定时会有很多活动，例如每周都会包邮免费送一些技术书籍及精美礼品、学习资料分享、大厂面经分享、技术讨论、行业大佬创业杂谈等等。
📝社群方向很多，相关领域有Web全栈（前后端）、人工智能、机器学习、自媒体变现、前沿科技文章分享、论文精读等等。
📝不管你是多新手的小白，都欢迎你加入社群中讨论、聊天、分享，加速助力你成为下一个技术大佬！也随时欢迎您跟我沟通，一起交流，一起成长。变现、进步、技术、资料、项目、你想要的这里都会有
📝网络的风口只会越来越大，风浪越大，鱼越贵！欢迎您加入社群~一个人可以或许可以走的很快，但一群人将走的更远！
📝关注我的公众号（与CSDN同ID：程序员洲洲）可以获得一份Java 10万字面试宝典及相关资料！~
📝想都是问题，做都是答案！行动起来吧！欢迎评论区or后台与我沟通交流，也欢迎您点击下方的链接直接加入到我的交流社群！~ 跳转链接社区~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51a0ba2635c34857eb5276ea93aa710/" rel="bookmark">
			井盖异动传感器，守护脚下安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着城市化进程的加速，城市基础设施的安全问题日益受到关注。其中，井盖作为城市地下管道的重要入口，其安全问题不容忽视。然而，传统的井盖监控方式往往存在盲区，无法及时发现井盖的异常移动。为此，我们推出了一款全新的井盖异动传感器，为您的城市安全保驾护航。
旭华智能这款设备采用NB-IoT网络通讯，相比4G来说，穿透力更好，信号传输更稳定，在井下环境中也能够对井盖状态进行实时监控。并且做到了IP68防护，无惧井下复杂环境，内置8500mAh大容量电池，大大增加了设备的使用寿命。如遇检修、安装等状况，可以开启远程撤防，以防多报误报，引起资源浪费。
井盖异动传感器在井盖出现异常，例如：开盖、越限、浸水，倾斜时，终端会在30s内发出警报，并通过手机APP通知管理人员，管理人员会通过平台分析研判，对比监测值与设定值分析报警级别，并根据不同的报警类型，及时联系相应的责任人，从而达到精准高效的处理效果。
在现代城市中，基础设施的安全问题直接关系到人们的生命财产安全。井盖异动传感器作为一种先进的监控设备，将会成为守护城市安全的重要力量。让我们一起行动起来，共同守护城市的安全，让生活更加美好！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d19639e7d9a18a58edf78ec8757f028/" rel="bookmark">
			RabbitMQ（十一）队列的扩展属性（Arguments）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简介二、队列扩展属性清单三、代码示例3.1 实现方式一：channel.queueDeclare()3.2 实现方式二：QueueBuilder.build() 一、简介 RabbitMQ 允许用户在声明队列、交换机或绑定时设置 扩展属性（Arguments），这些扩展属性可以用于 自定义和增强消息处理的行为。这里我们主要探讨 RabbitMQ 的 队列扩展属性。
RabbitMQ 管理界面中的队列扩展属性：
二、队列扩展属性清单 队列扩展属性清单如下：
x-dead-letter-exchange：死信交换机。
x-dead-letter-routing-key：死信队列的路由键。
x-expires：队列在指定毫秒数后被删除。
x-message-ttl：队列的消息过期时间，单位为毫秒。
x-max-length：队列的消息条数限，限制加入 queue 中消息的条数。（先进先出原则，超过限制后，后面的消息会顶替前面的消息。）
x-max-length-bytes：队列的消息容量限制。（该参数和 x-max-length 目的一样，限制队列的容量，但是这个参数是靠队列大小（bytes）来进行限制。）
x-max-priority：队列的优先级，最大优先值为 255。
x-overflow：设置队列溢出行为。这决定了当达到队列的最大长度时消息会发生什么。有效值是：drop-head、reject-publish、reject-publish-dlx。
x-single-active-consumer：表示队列是否是单一活动消费者。
值为 true 时，注册的消费组内只有一个消费者消费消息，其他被忽略。
值为 false 时，消息循环分给所有消费者。（默认）
x-queue-mode：将队列设置为延迟模式，在磁盘上保留尽可能多的消息，以减少 RAM 的使用。如果未设置，队列将保留内存缓存以尽快地传递消息。
x-queue-master-locator：在集群模式下设置镜像队列的主节点信息。
x-ha-policy：创建 HA 队列，此参数已失效。
x-ha-nodes：HA 队列的分布节点，此参数已失效。
注意： 如果队列不是新建，而是 修改队列的扩展属性，启动程序之前需要删除原有队列。否则会报错：inequivalent arg ‘x-dead-letter-exchange’。
三、代码示例 3.1 实现方式一：channel.queueDeclare() 示例：声明一个包含扩展属性的队列。
Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(); args.put("x-message-ttl", 60000); // 消息TTL为60秒 args.put("x-dead-letter-exchange", "myDeadLetterExchange"); // 死信交换机 args.put("x-dead-letter-routing-key", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d19639e7d9a18a58edf78ec8757f028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb0aa6c64d4ca319b2ce272ad835aba6/" rel="bookmark">
			js实现对象数组转树形结构【全网最严谨】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象数组转换为树形结构的主要思路： 初始化一个空数组 tree 用于存储最终的树形结构，以及一个空对象 map 用于存储每个元素的索引。
遍历输入的数组 arr，对于每个元素 item，首先创建一个空数组 item.children 用于存储其子元素，然后将 item.id 和当前索引 i 存入 map。
检查 item.pid 是否存在。如果 item.pid 不存在或者为0，说明 item 是树的根节点，将其添加到 tree 中。如果 item.pid 存在且不为0，说明 item 是某个元素的子节点，将 item 添加到其父节点的 children 数组中。这里通过 map[pid] 可以快速找到父节点在 arr 中的位置。
遍历结束后，返回 tree，即为转换后的树形结构。
这种方法的关键在于使用 map 对象来快速定位每个元素的父节点，从而避免了在添加子节点时需要遍历整个数组的问题。
const arrayToTree = (arr) =&gt; { if (!Array.isArray(arr) || arr.length === 0) return []; const tree = []; const map = {}; // 本次遍历的目的是为了防止在arr数据混乱的情况下，下面的【map[pid]】找不到对应的值 arr.forEach((item, index) =&gt; { map[item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb0aa6c64d4ca319b2ce272ad835aba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1f7b40f948a865e2f454f192a3742a/" rel="bookmark">
			spring boot 自动扫描Controller、Service、Component原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目里面为什么不加上@ComponentScan("com.yym.*")注解，也能加载到子目录里面的Controller，Service，Component的bean呢？
启动类没有@ComponentScan注解
@SpringBootApplication public class BootStrap { public static void main(String[] args) { SpringApplication.run(BootStrap.class, args); } } 原因：
spring boot 启动类加上@SpringBootApplication会自动扫描当前目录，及子目录下的Controller，Service，Component注解的bean。
查看@SpringBootApplication注解源码，里面有@ComponentScan注解
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication 查看Controller，Service注解源码都有Component注解
@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Controller { /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1f7b40f948a865e2f454f192a3742a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7285a7f3fb3cdf51fe095cf7e8374289/" rel="bookmark">
			CentOS常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS常用命令 1 背景知识1.1 Centos 简介1.2 centos 和ubuntu的区别1.3 安装centos的时候需要注意什么 2 常用命令集锦2.1 文件目录类：2.2 驱动挂载类：2.3 关机命令：2.4 查看系统信息命令：2.5 文本命令2.6 系统管理命令：2.7 网络管理命令：2.8 软件包管理命令：2.9 系统监控命令：2.10 磁盘管理命令：2.11 用户管理命令： 1 背景知识 1.1 Centos 简介 CentOS（Community Enterprise Operating System）是Linux发行版之一，是免费的、开源的、可以重新分发的开源操作系统。CentOS Linux发行版是一个稳定的、可预测的、可管理的和可复现的平台，源于Red Hat Enterprise Linux（RHEL）依照开放源代码（大部分是GPL开源协议）规定释出的源码所编译而成。
自2004年3月以来，CentOS Linux一直是社区驱动的开源项目，旨在与RHEL在功能上兼容。CentOS天生支持XFS文件系统，对于文件系统更加可靠。
CentOS主要分为两个主要版本，CentOS Linux和CentOS Stream版。CentOS Linux Linux版每两年发行一次，每个版本的系统会提供10年的安全维护支持。CentOS Linux版为传统CentOS系统，系统的基本源代码由RHEL对应版本的开源代码提供，是RHEL的下游。当RHEL更新后CentOS Linux根据RHEL更新的内容进行更新并修复其中可能的漏洞等。版本略落后于RHEL，更新新特性速度较RHEL慢。提供与CentOS Linux版以前一样的安全服务支持和稳定的服务器操作系统，但CentOS Linux 8服务支持时间被大幅减少，CentOS Linux 7 的维护时间暂时没有改变，且官方维护团队的重心已经转移到Stream版本。CentOS Stream Stream版为滚动更新版，意味着没有固定版本号，是动态更新具体的内容。CentOS Stream版则为滚动更新版，系统的基本源代码也由RHEL对应版本的开源代码提供。但代码更加激进，是合并进 RHEL 前的一个试验场，比RHEL更新新特性更快。等到相关新代码成熟后由RHEL合并，是RHEL的上游。
如需更多有关CentOS的简介，建议访问相关论坛或咨询相关业内人士。
1.2 centos 和ubuntu的区别 CentOS和Ubuntu之间的区别主要在以下方面：
开发背景：CentOS是基于Red Hat Enterprise Linux（RHEL）的源代码进行构建的，而Ubuntu则是基于Debian开发的。软件包管理：CentOS使用yum命令进行软件包管理，而Ubuntu则使用apt-get命令。此外，CentOS支持rpm格式的安装，而Ubuntu不支持。社区支持：Ubuntu具有庞大的社区力量，用户可以方便地从社区获得帮助。在线安装软件中，centos使用的是yum命令，而ubuntu中使用的是apt-get命令。除此之外yum中还有一个从软件源中搜索摸个软件的方法：yum search +软件名。适用场景：CentOS适用于服务器，而Ubuntu则适用于个人桌面。默认配置和文件路径：由于不同的公司制作，很多配置文件的位置和默认的文件路径都有很大区别。
总的来说，CentOS和Ubuntu都是优秀的Linux发行版，它们都有各自的优点和适用场景。选择哪一个更适合你，取决于你的具体需求和偏好。 1.3 安装centos的时候需要注意什么 在安装CentOS时，需要注意以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7285a7f3fb3cdf51fe095cf7e8374289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbeb3426a116aebbcce171ef5188ddbb/" rel="bookmark">
			NVIDIA Container Toolkit（NVIDIA Docker）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Nvidia Docker该项目已被NVIDIA Container Toolkit取代。此存储库提供的工具已被弃用，并且该存储库已存档。
nvidia-docker不再支持包装器，并且 NVIDIA Container Toolkit 已进行扩展，允许用户配置 Docker 以使用 NVIDIA Container Runtime 。
NVIDIA 容器工具包允许用户构建和运行 GPU 加速容器。该工具包包括一个容器运行时库和实用程序，用于自动配置容器以利用 NVIDIA GPU。
一、安装 1. 配置依赖库 curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \ &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \ sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list （可选）配置存储库以使用实验包：
sed -i -e '/experimental/ s/^#//g' /etc/apt/sources.list.d/nvidia-container-toolkit.list 2. 从存储库更新包列表 sudo apt-get update 3. 安装 NVIDIA Container Toolkit 软件包 sudo apt-get install -y nvidia-container-toolkit 二、配置Docker 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbeb3426a116aebbcce171ef5188ddbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af75c964921c9c66bb4b61201f5f7bae/" rel="bookmark">
			Linux安装Redis并设置systemd方式管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装前检查依赖
由于 redis 是用 C 语言开发，安装之前必先确认是否安装 gcc 环境：
# 查看是否已安装gcc环境 gcc --version # 安装命令 yum install -y gcc tcl redis 安装需要make工具，它可以帮助我们自动化编译和构建软件项目
# 查看是否已安装make工具 make --version # 安装命令 yum install make 2、下载redis安装包与解压
# 将redis安装在/usr/local/路径下 cd /usr/local/ # 使用wget方法直接下载，如果没有开通外网权限，也可以下载后上传至服务器 wget http://download.redis.io/releases/redis-5.0.3.tar.gz #解压缩 tar -xzvf redis-5.0.3.tar.gz #文件夹重命名，保证规范 mv redis-5.0.3 redis 3、编译与安装
在redis根目录下直接进行安装。
cd /usr/local/redis/ make make install *区别：
1）make：直接在redis/src目录下编译
2）make install：先在redis/src目录下编译，然后将make编译生成的可执行文件拷贝到/usr/local/bin目录下
5、编辑redis配置文件
配置文件 redis.conf 在我们之前解压的redis根目录下（/usr/local/redis/）。
建议在我们修改配置文件之前，先将配置文件备份一份，以免修改出错造成文件出错：
cp redis.conf redis.conf.bck 然后修改redis.conf文件中相应配置：
vi /usr/local/redis/redis.conf 常用的修改配置如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af75c964921c9c66bb4b61201f5f7bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c7726b8fc1af884f8ce17dcb6340f7/" rel="bookmark">
			http跟https有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS和HTTP的概念：
HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
永久免费SSL证书_永久免费https证书_永久免费ssl证书申请-JoySSL
HTTPS和HTTP的区别主要如下：
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
永久免费SSL证书_永久免费https证书_永久免费ssl证书申请-JoySSL真正完全且永久免费！不用您花一分钱，SSL证书免费使用90天，并且还支持连续签发。JoySSL携手全球权威可信顶级根，自研新一代SSL证书，全系列支持90天免费使用。在这里，你可以申请到免费单域名证书、免费多域名证书以及免费通配符证书。部署于国内的验签服务器3-5分钟极速签发，而且只需要简单的域名解析验证，即可让您的网站开启https安全协议。https://www.joyssl.com/certificate/select/free.html?nid=7HTTP协议传输的数据都是未加密的，传输隐私信息非常不安全，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，所以一些安全性比较高的网站如：网上银行，电子商务网站都需要用https访问！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29f2e899ea8526802858492c0a05a46/" rel="bookmark">
			【设计模式之美】重构一：重构定义、单元测试保证重构正确性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 重构概述1. 为什么要重构（why）？2. 到底重构什么（what）？3. 什么时候重构（when）？4. 该如何重构（how）？5. 如何保证重构不出错？ 二. 单元测试方法论1. 什么是单元测试？2. 为什么要写单元测试？3. 如何编写单元测试？ 一. 重构概述 重构的要求：
一方面，重构代码对一个工程师能力的要求，要比单纯写代码高得多。重构需要你能洞察出代码存在的坏味道或者设计上的不足，并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。
另一方面，很多工程师对为什么要重构、到底重构什么、什么时候重构、又该如何重构等相关问题理解不深，对重构没有系统性、全局性的认识，面对一堆烂代码，没有重构技巧的指导，只能想到哪改到哪，并不能全面地改善代码质量。
1. 为什么要重构（why）？ 重构定义：
这个定义中有一个值得强调的点：“重构不改变外部的可见行为”。
为什么要进行代码重构？
首先，重构是时刻保证代码质量的一个极其有效的手段。
其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。我们无法 100% 遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的。
最后，重构是避免过度设计的有效手段。在我们维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。
2. 到底重构什么（what）？ 根据重构的规模，我们可以笼统地分为大规模高层次重构（以下简称为“大型重构”）和小规模低层次的重构（以下简称为“小型重构”）。
大型重构
大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。
这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大。
小型重构
小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。
小型重构更多的是利用我们能后面要讲到的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小。你只需要熟练掌握各种编码规范，就可以做到得心应手。
3. 什么时候重构（when）？ 提倡的重构策略是持续重构。
就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。
4. 该如何重构（how）？ 每个阶段，要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。
5. 如何保证重构不出错？ 最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合我们对重构的定义。
二. 单元测试方法论 1. 什么是单元测试？ 单元测试相对于集成测试（Integration Testing）来说，测试的粒度更小一些。
集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。 写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。
举例
public class Text { private String content; public Text(String content) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c29f2e899ea8526802858492c0a05a46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2749c6c5bcc670d6ed57e512966d78e/" rel="bookmark">
			程序员必备的面试技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“程序员必备的面试技巧，就像是编写一段完美的代码一样重要。在面试战场上，我们需要像忍者一样灵活，像侦探一样聪明，还要像无敌铁金刚一样坚定。只有掌握了这些技巧，我们才能在面试的舞台上闪耀光芒，成为那个令HR们心动的程序猿！”
面试经历
看实力和运气
实力是一方面，运气也是一方面
遇到的不一定是什么样的人什么样的公司，即使你很优秀有的时候也不一定会被选择，要接受，在当前的大环境下，有个面试的机会都不容易，抱怨也没有什么用，但是真的奉劝那些不想招人的公司别再刷kpi 了，给大家节约一点时间。接下来谈一谈我最近的面试经历吧
背景：面试java，某招标公司
首先我说下薪资，不高，真的不高
一面技术：约一个小时，盯着简历，问的都是常用的东西，没有结合项目，但是都是平时能用得到的东西，基本上完全都能回答上，问的还挺全面的。基本上都在使用层面也有一些深入的东西。但是还行，都是常规的问题，比较正常。
二面技术：约一个小时，结合简历，问了一些项目相关的东西，这次结合项目了，每个项目基本上都聊了一遍，之间也穿插着问了一些技术得问题，还好。之后又介绍了一些公司的业务和技术架构等基本信息。
在之间hr 有来聊过几句，问了一些基本信息，因为是降薪反复确认了能否接受，在确认之后才约后面的面试
三面技术：是一个看起来很年轻的小伙子，聊了有半个小时左右吧，也是问了一些项目相关的东西
第一天面试技术三轮，HR两轮，三个多小时，结束之后，hr 就说先回去，后面给通知。（三个多小时，就给了一杯水喝，嗓子已经开始冒烟了，面试的时候最好自己带瓶水，可能人家公司财政紧缺，没有一口水给的）
一天过去了，没有消息，没有通知（要不要的回复一下也是最起码的尊重吧）
又一天过去了，本来已经不抱有希望了，但是同事说在问一下吧，所以就多问了一嘴，hr说还有一面，但是他们领导只有早上9点有时间，于是就约到了早上9点。
早上早早的就去了，本着不迟到的心理，估计是还没有上班，在前台等了半个多小时，没什么可说的， 自己去早了，到9点的时候，hr来了，之后就说去找领导，在另一个楼层，
去了之后发现领导还没到。说是路上堵车了，等了半个多小时来了。前前后后多等了一个多小时，去的路程一个多小时，那么半天的时间基本就没了（在这里我想说的是你们HR和领导的时间是时间，那我们的时间就不是时间了吗）。
领导还算随和，没有那么强势，不会说你多说一句话就觉得是在浪费时间，那么开始了，从每一段工作经历，每一个项目开始问，都是和业务相关的，没有技术，又聊了聊chatgpt，总共下来有一个小时吧，最后结束了。
hr 又来了，又问了工作经历。等消息吧
又过了一天没有消息，可能是不甘心去了那么多次，于是又问了一下结果，以后在合作。
也没有说原因。可能是自己的问题吧（简历上有一段时间写错的），也可能是其他别的原因，反正最终结果就是凉凉。
昨天的一家，一面完事了，找领导，领导在开会，说让他先回去吧
上面就是自己最近的一些经历，真的希望大家都能互相尊重一下，尤其是在当前的大环境下， 就不要再互相为难了。
面试技巧
首先八股文是必看的， 最起码的技术还是要具备的，虽说面试造飞机，进去造轮子，但是你没有这个门槛就进不去，像java集合、java内存、调优、多线程、高并发、spring 、spring boot 、spring cloud 、分布式事务、分布式锁、数据库sql调优、sql优化、分库分表、redis、kafka 、rebbitmq 、还有算法题。
其次，面试过程要有自信，对于自己熟悉的东西就要多说，不熟悉的想办法往熟悉的上面去引导。给面试官一点暗示。
还有就是简历上面最好是真实的， 不要造假， 把自己最擅长的地方放到最显眼的位置。多写一些技术栈，和自己擅长的技术，多写一些项目成就。
最后再说一句不行就放弃吧，抓紧转行，现在这个环境真的是难上加难，我已经准备去送外卖了，要是有更好的请介绍给我一下，谢谢。
下面的二维码，有我自己整理的刷题小程序，扫码公众号直达小程序，上面说的哪些技术栈都有涵盖，希望对大家有所帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0eab03d7e54cfdf25d575fe4379d49/" rel="bookmark">
			（二）EGE相关教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EGE专栏：EGE专栏
上一篇：（一）EGE介绍
下一篇：EGE新手入门示例程序（一）
目录 一、EGE官网教程1. 新手入门教程2. 入门基础示例3. EGE安装包内demo4. 库函数目录5. github xege6. 进阶教程(1) 官网基础教程(2) 官网范例 二、EasyX官网教程 一、EGE官网教程 1. 新手入门教程 入门学习一定要从EGE官网的新手入门教程看起, 先把里面的示例程序都运行过一遍，看一看大致的写法，对EGE的绘图及功能做个初步的了解，不必深究每一条语句的意思。
1. 创建第一个EGE程序
2. EGE新手入门示例程序（一）
简要地讲解了EGE的基本使用，包含简单作图、色彩的计算、颜色填充、文字、视口裁剪、图像操作、键盘交互和鼠标交互。
2. 入门基础示例 http://xege.org/manual/tutorial/index.htm
包含了绘图入门部分示例（即1. 创建第一个EGE程序）和图形动画入门部分示例。
3. EGE安装包内demo EGE的安装包内也有部分demo。
4. 库函数目录 EGE官网库函数文档
Github EGE项目 ege.h
想知道常用的库函数都有哪些，怎么用，可以到这里来查看。但是这里只有部分函数，具体的可以查看EGE头文件 ege.h。
5. github xege https://github.com/wysaid/xege
github上wysaid代为维护的ege项目，也是目前所用的EGE库。
6. 进阶教程 进阶教程可以先不用看，等学习完基础教程后有时间看看。
(1) 官网基础教程 https://xege.org/category/lesson](https://xege.org/category/lesson
(2) 官网范例 https://xege.org/category/demo
这些demo只是看看都能用来做什么，源码只有部分有。
还有一些其它的，这里不多说了
二、EasyX官网教程 EasyX 官网示例程序 https://codebus.cn/
因为EasyX和EGE的库函数差不多，所以经过一些小修改，就能用移植到EGE上，示例程序也不少。可以去看看别人的实现思路。
EGE专栏：EGE专栏
上一篇：（一）EGE介绍
下一篇：EGE新手入门示例程序（一）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edd235637556640ad2cdcd48df7646a9/" rel="bookmark">
			idea上传springboot项目到GitHub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：右键项目-&gt;Git-&gt;添加
第二步：右键项目-&gt;Git-&gt;提交目录
第三步 ：提交并推送
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6f6e1a63f11aa38ee87083d4271427/" rel="bookmark">
			CentOS 7.9安全加固
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在众多Linux中，CentOS 7.9是一个比较稳定的版本。我在空间里发布的前一篇文章已经过去半年多，因为工作原因没有及时写后续安全加固，今天趁着周末一点时间来完成它。本文将基于CentOS 7.9最小化安装的系统为基础，参考《等级保护2.0》测评指导书——二级测评指导书的通用部分，从“身份鉴别”、“访问控制”、“安全审计”、“入侵防御”、“恶意代码防范”、“剩余信息保护”方面来介绍Linux安全加固。如有不足，欢迎评论区指正！
首先，为了后续操作方便，我们先安装好必要必要的工具包。对于selinux不是很熟的话，还需要关闭selinux。具体操作如下：
i）命令补全包
注意，安装后需要重启系统方可生效！！！
ii）基础网络工具包
*特别提示：假如不清楚具体工具包名称，我们可以使用yum search命令搜索安装包名称，然后再用yum安装：
iii）防火墙开放SSH端口，便于使用SSH工具远程操作
iv）关闭selinux
.
*关闭selinux设置后，可以重启系统使之生效，也可以使用setenforcie 0来临时开放selinux。
在完成上述准备后，我们就可以通过ssh工具远程连接服务器进行安全加固了。我这里使用是xshell。
干货开始===&gt;
一、身份鉴别加固 1.密码安全策略
操作系统和数据库系统管理用户身份鉴别信息应具有不易被冒用的特点，口令应有复杂度要求并定期更换。
1）设置强密码
查看是否存在空密码帐号，如果命令结果为空则无，如果有则为空口令帐号，必须为其设置强密码。
# awk -F: '($2 == ""){print $1}' /etc/shadow
与系统用户沟通，确保密码非弱口令。一般强口令为大写字母、小写字母、数字、特殊符号四种中两种以上组合，且不能有连续重复或有规律的字符组合。
2）配置口令生存期
修改/etc/login.defs配置密码周期策略。注意，此策略只对策略实施后所创建的帐号生效， 以前的帐号还是按99999天周期时间来算。
修改策略设置，编辑文件/etc/login.defs,在文件中加入或修改成如下内容：
# vi /etc/login.defs
解释：
PASS_MAX_DAYS 90 #口令有效期90天
PASS_MIN_DAYS 0 #口令设置后限制修改的天数，0天表示不限制
PASS_MIN_LEN 8 #口令最小长度8位
PASS_WARN_AGE 14 #口令过期提醒14天
3）配置密码安全策略
a）启用密码策略-1
# cp /etc/pam.d/passwd /root/passwd.bak #备份文件
# vi /etc/pam.d/passwd
在/etc/pam.d/passwd末尾增加
1
password required pam_pwquality.so retry=3
# cp /etc/pam.d/system-auth /root/system-auth.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be6f6e1a63f11aa38ee87083d4271427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5fc23d73d33aecf71957550c7435fda/" rel="bookmark">
			网安入门12-文件上传（黑白名单，00截断）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑名单绕过 Pass-03
有的时候后端限制了一些黑名单，比如过滤后缀名.php
我们就可以用黑名单里没有的后缀名进行绕过，例如：
大小写：.phP .pHp .AsPphp1 .php2 .php3 .php9 .phtml（成功率较高）特殊文件名绕过 比如发送的htp包里把文件名改成test.asp.或test.asp_(下划线为空格)，这种命名方式在windows系统里是不被允许的，所以需要在burp之类里进行修改，然后绕过验证后，会被windows.系统自动去掉后面的点和空格，但要注意Unix/Linux系统没有这个特性。
于是我们先上传一个shell.jpg，然后抓包把后缀名改为.php1
发现浏览器按照原文展示，并没有按照php解析这个木马，那我们就尝试别的后缀
我尝试了php1-9，都不行，好在最后尝试了一下phtml，成功了，最后蚁剑一连就行啦
白名单绕过-GET型00截断 当我们遇到白名单了，只允许上传.jpg|.png|.gif
这里先介绍0x00是一个Hex编码，他表示一个空字符（可以理解为一个不可见的字符串）
%00与0x00类似，在URL编码下表示为空字符，URL中%00解码成16进制就是0x00
Pass-11
分析上传包，与之前的关卡不同，请求头第一行多了一个save_path的东西，把我们已知的先填上，先把Content-Disposition的filename改成"1.jpg"
我们猜测这个save_path的作用是指定上传之后的文件具体保存的路径，使的Response里面的src在…/upload目录下，那么我们就对这个目录动手了
尝试改一下，发现上传出错，因为目录里没有这个文件，而且我们没有权限新建这个文件
继续证明我的思路，我用上帝视角在upload文件夹里面新建了一个文件夹叫做123
再次抓包，往这个123文件夹里传图片
按照预期出现了这个上传的图片
这就证明了我们的拼接路径理论
新的上传思路就出来了：我们只需要在save_path里面随便起一个名字.php再用%00解码后的空字符截断后面的拼接上来的其他数据即可
后面这个正方型就是代表了一个不可见字符，后续步骤就一样了在文件夹中可以看到文件名就为zyh.php
白名单绕过-POST型00截断 Pass-12
我们抓包一看，save_path的地方跑到了post数据的区域
抓包分析小技巧：只要是在请求包第一个回车之后的参数全部都是post数据，在请求头第一行的是get数据
我们故技重施，发现失败了
原因在于GET传参和POST传参不同，post数据的特点是我们把包发过去之后，服务器会进行URL二次编码，编码后的参数到了后端再解码执行，相当于传到服务器的是%25%30%30，到了后端还是%00
我们有了新的思路，先给他解码传上去，再让他经过编码解码，到后端还是空字符，选中00%右键转换编码
通杀方法 最后再介绍一个通杀的解法，只要对方服务器不对我们上传的文件进行重命名，那我们可以在filename参数里面直接拼接一个1.php%00.jpg，再对%00进行解码，服务器前后端的校验都可以绕过
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797812b36c67b75f0c80b7e7b6974ade/" rel="bookmark">
			Ansys Lumerical | 曲面波导锥度（varFDTD 和 FDTD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		附件下载 联系工作人员获取附件
在本例中，我们将使用MODE 2.5D变分FDTD求解器确定SOI锥度的最佳形状。
注意：也可以使用特征模态展开 （EME） 求解器来模拟此锥度。
我们将首先对这种锥度的设计进行参数化，如下所示：
在这种情况下，锥形设计将与 x 的指数幂m成正比。在锥形的两端，我们受限于 w1和w2 的波导宽度。
文件 taper_design.lms 包含一个以板状高斯光束为光源的 2.5D 传播器模拟区域。板状高斯光束的焦点设置在距离光源位置 25 微米处。
建立了一个参数扫描项目，以跟踪进入输出波导的传输量与指数 m 的函数关系。您可以使用动画功能查看锥度形状随 m 变化的情况。
指数 m 从 0.1 到 4 的参数扫描结果如下所示。可以看出，当 m 从 0.1 变为 4 时，透射率发生了相当大的变化。峰值接近 1（对应于线性锥度），但如果我们再次运行参数扫描项目，在 0.8 到 1.7 的更窄范围内扫描 m，我们发现最佳值约为 1.15。
我们还可以使用电影监视器查看光在此锥度（m=1.15）中的传播。
值得注意的是，如果使用 3D FDTD，这种模拟（约 30 微米 x 30 微米 x 2 微米）需要很长时间才能完成。2.5D Propagator 是理想的选择，因为它能让我们快速找到 SOI 锥形的最佳形状。在下一页，我们将计算输出波导各个模式的传输，结果显示与 3D FDTD 的结果非常接近。
将结果与3D FDTD进行比较 在上一节中，我们通过将 SOI 锥度参数化为指数函数并使用参数扫描来找到最佳参数值，从而找到了 SOI 锥度的最佳形状。现在，我们将演示如何计算从输入波导到输出波导的各个模式的传输，并将结果与3D FDTD进行比较。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/797812b36c67b75f0c80b7e7b6974ade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d7038a7bfdc36a430f26d0a32dde82/" rel="bookmark">
			GitHub 上传超过 100M 文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub 上传超过 100M 文件方法 报错信息报错原因解决办法 报错信息 remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com. remote: error: Trace: a703cdcc9fade51f2a131142249cb422 remote: error: See http://git.io/iEPt8g for more information. remote: error: File ARCore/Data/resources.assets.resS is 130.82 MB; this exceeds GitHub's file size limit of 100.00 MB remote: error: File ARCore/Libraries/libiPhone-lib.a is 463.62 MB; this exceeds GitHub's file size limit of 100.00 MB ! [remote rejected] master -&gt; master (pre-receive hook declined) error: failed to push some refs to 'https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d7038a7bfdc36a430f26d0a32dde82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71cc254a6e5e396da30e03611c4bc1b/" rel="bookmark">
			RabbitMQ（九）死信队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简介1.1 定义1.2 何时进入死信队列？1.3 死信消息的变化1.4 死信队列的应用场景1.5 死信消息的生命周期 二、代码实现2.1 死信队列的配置步骤2.2 配置类2.3 配置文件2.4 生产者2.5 业务消费者2.6 死信消费者2.7 测试结果 三、总结四、补充4.1 启动报错 inequivalent arg 'x-dead-letter-exchange' RabbitMQ 是流行的开源消息队列中间件，使用 erlang 语言开发，由于其社区活跃度高，维护更新较快，深得很多企业的喜爱。
一、简介 1.1 定义 死信队列（Dead Letter Queue，简称 DLX）是 RabbitMQ 中一种特殊的队列，用于处理无法正常被消费者消费的消息。当消息在原始队列中因为 达到最大重试次数、过期、或者 满足特定条件 时，可以 将这些消息重新路由到一个预定义的死信队列中 进行进一步处理或记录。
1.2 何时进入死信队列？ 当发生以下情况，业务队列中的消息会进入死信队列：
消息被否定确认：使用 channel.basicNack 或 channel.basicReject，并且此时 requeue 属性被设置为 false。消息过期：消息在队列的存活时间超过设置的 TTL 时间。消息溢出：队列中的消息数量已经超过最大队列长度。 当发生以上三种情况后，该消息将成为 死信。死信消息会被 RabbitMQ 进行特殊处理：
如果配置了死信队列，那么该消息将会被丢进死信队列中；如果没有配置，则该消息将会被丢弃。 1.3 死信消息的变化 那么 死信 被丢到死信队列后，会发生什么变化呢？
如果队列配置了 x-dead-letter-routing-key 的话，“死信” 的路由键会被替换成该参数对应的值。如果没有配置，则保留该消息原有的路由键。 举个例子：
原有队列的路由键是 RoutingKey1，有以下两种情况：
如果配置队列的 x-dead-letter-routing-key 参数值为 RoutingKey2，则该消息成为 “死信” 后，会将路由键更改为 RoutingKey2，从而进入死信交换机中的死信队列。如果没有配置 x-dead-letter-routing-key 参数，则该消息成为 “死信” 后，路由键不会更改，也不会进入死信队列。 当配置了 x-dead-letter-routing-key 参数后，消息成为 “死信” 后，会在消息的 Header 中添加很多奇奇怪怪的字段，我们可以在死信队列的消费端通过以下方式进行打印：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a71cc254a6e5e396da30e03611c4bc1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a7b58fd0397cdbbbfbc09852883166/" rel="bookmark">
			消息队列-RockMQ-定时延时发送消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时延时发送消息 任务需要延迟一段时间再进行处理。
生产者
public class Producer { public static void main(String[] args) throws Exception { DefaultMQProducer producer = new DefaultMQProducer("producer_group"); producer.setNamesrvAddr("ip:9876"); producer.start(); List&lt;Order&gt; F = OrderBuilder.build(1, "A", "B", "C"); List&lt;Order&gt; S = OrderBuilder.build(2, "D", "Q"); List&lt;Order&gt; T = OrderBuilder.build(3, "N", "Q", "R"); ArrayList&lt;Order&gt; orders = new ArrayList&lt;Order&gt;() {{ addAll(F); addAll(S); addAll(T); }}; for (Order order : orders) { Message msg = new Message("test-topic", "test-topic_str", order.toString().getBytes()); msg.setKeys("test-topic_trace"); // 官网提供了这些延迟级别 分别对应 0 1 2 // messageDelayLevel = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a7b58fd0397cdbbbfbc09852883166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e608cc3f886b10401df340e5cb11d29/" rel="bookmark">
			VS Code技巧汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS Code技巧汇总 前言设置快捷键插件汇总环境搭建HTMLC/C++Python 远程SSH连接被控端准备安装扩展配置SSH创建SSH连接打开终端窗口通过公钥连接SSH 前言 本文介绍VS Code的使用技巧，内容包含设置、快捷键、插件汇总、环境搭建、远程SSH连接、等等。
设置 中文界面
安装扩展：Chinese(Simplified) Language Pack
自动换行
文件 - 首选项 - 设置，搜索wrap，找到Editor: Word Wrap，将其更改为on。
打开的编辑器
资源管理器右侧的更多，勾选打开的编辑器，左侧会以列表形式展现，方便快捷：
快捷键 编辑快捷键
注释：Ctrl+\缩进：Tab反缩进：Shift+Tab 窗口快捷键
打开终端窗口：Ctrl+`打开输出窗口：Ctrl+Shift+U打开调试窗口：Ctrl+Shift+Y 插件汇总 Basic
Chinese(Simplified) Language Pack
Remote
Remote Development
Remote - SSH
Git
GitLens：光标处显示Git修改记录
Git Blame：状态栏显示Git修改记录
C/C++
C/C++
CMake Tools
C/C++ Extension Pack
Web
Open in browser
Microsoft Edge Tool
Linux
WSL
Tool
AWS Toolkit：AI会话助手
Bito AI Code Assistant：ChatGPT助手
CursorCode：代码生成/补全工具
TabNine：AI编程助手
IntelliCode：AI编程助手
Kite：代码补全工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e608cc3f886b10401df340e5cb11d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b730254a705ecefed59baba78e47fb7e/" rel="bookmark">
			解决liunx下vsftp报530 Permission denied错误信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误信息 状态:	已从服务器断开 状态:	正在连接 192.168.168.4:21... 状态:	连接建立，等待欢迎消息... 状态:	不安全的服务器，不支持 FTP over TLS。 命令:	USER ftpuser 响应:	530 Permission denied. 错误:	无法连接到服务器 故障排除： 首先检查系统是否开启了vsftp服务，如果没有开启，先开启该服务。
方法1.setup–系统服务–自启动服务
方法2.界面设置，service vsftpd restart
检查 /etc/vsftpd/ftpusers配置
/etc/vsftpd/ftpusers： 不受任何配制项的影响，它总是有效，它是一个黑名单，不允许名单中成员连接ftp，主要原因是：基于安全考虑，管理员不希望一些拥有过大权限的帐号（比如root)登入FTP，以免通过该帐号从FTP上传或下载一些危险位置上的文件从而对系统造成损坏。
检查/etc/vsftpd/user_list配置
/etc/vsftpd/user_list：该文件里的用户账户在默认情况下也不能访问FTP服务器，仅当 /etc/vsftpd/vsftpd.conf配置文件里启用userlist_enable=NO同时userlist_deny=NO时才可访问，相当于（白名单，允许名单访问），当userlist_deny=YES时相当于（黑名单，不允许名单人员）
检查/etc/vsftpd/vsftpd.conf配置
/etc/vsftpd/vsftpd.conf：vim查看是否有以下内容，没有则添加以下内容。
pam_service_name=vsftpd userlist_enable=YES userlist_deny=no userlist_file=/etc/vsftpd/user_list 配置修改完成后，执行service vsftpd restart重启vsftpd服务。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d2684d780fa159c0f0d62f4351af69/" rel="bookmark">
			交换机与路由器和电脑的连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、按照拓扑连接网络，观察交换机端口指示灯
2、连接网线前通过console线连接交换机，观察网线连接后CRT有何种提示信息
3、配置PC的IP地址，要求如下：
192.168.x.1 192.168.x.2，配置完成后检查PC的IP地址以及MAC地址（图形化和命令行模式）
4、测试PC的连通性（ping 目的IP地址）
5、通过display mac-address检查交换机的显示信息，得出MAC Address列与Port列的规律
远程登录设备--telnet
1、PC通过console线配置路由器
2、配置路由器选定的接口地址
进入接口试图 interface xxxx
配置IP地址
PC：192.168.x.1 路由器地址：192.168.x.2
ip address x.x.x.x x.x.x.x(255.255.255.0)
3、开启telnet功能
[R]telnet server enable 4、配置VTY接口
//基于password
[R]user-interface vty 0 63
[R-line-vty0-63]set authentication password simple h3c
//基于none
[R]user-interface vty 0 63
[R-line-vty0-63]authentication-mode none
5、测试
PC中的cmd通过telnet x.x.x.x进行测试 //基于用户+密码的验证的方式
1、vty接口选择的验证方式为scheme
authentication-mode schme
2、创建本地用户
local-user admin （“admin”是名字可以更换）
password simple h3c（密码设置为h3c）
3、在pc上测试telnet路由器
DHCP
1、配置路由器接口IP地址
2、开启DHCP功能
dhcp enable
3、创建地址池
gateway-list 192.168.1.254
dns-list 114.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d2684d780fa159c0f0d62f4351af69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2ac23b6fdab0793224643bac8cc153/" rel="bookmark">
			torch.nn.functional.interpolate与torchvision.transforms.Resize方法对张量图像Resize应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、非张量数据使用torch方法resize(transforms.Resize)二、张量数据使用torch方法resize(torch.nn.functional.interpolate) 前言 要使用 PyTorch 对张量进行调整大小，您可以使用 torch.nn.functional.interpolate 函数。要对cpu中类似PIL数据，您可以使用torchvision.transforms.Resize函数。本文将介绍这2种函数应用方法。
一、非张量数据使用torch方法resize(transforms.Resize) 当您使用 PyTorch 时，可以使用 torchvision.transforms 中的 Resize 类来调整图像的大小。以下是一个简单的示例代码，演示如何使用 Resize 类来调整图像的大小。其代码如下：
import torch from torchvision import transforms from PIL import Image # 读取图像 image_path = 'path_to_your_image.jpg' image = Image.open(image_path) # 定义变换 resize = transforms.Resize((100, 100)) # 将图像调整为 100x100 大小 # 应用变换 resized_image = resize(image) # 显示调整后的图像 resized_image.show() 在这个示例中，我们首先使用 PIL 库打开图像，然后定义了一个 Resize 变换，将图像调整为 100x100 大小。接着，我们将这个变换应用到图像上，并显示调整后的图像。
二、张量数据使用torch方法resize(torch.nn.functional.interpolate) 要使用 PyTorch 对张量进行调整大小，您可以使用torch.nn.functional.interpolate 函数。以下是一个简单的示例代码，演示如何使用 interpolate 函数来调整张量的大小。其代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a2ac23b6fdab0793224643bac8cc153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c25eee2580fbad78bea279c9808419/" rel="bookmark">
			debugger失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chrome浏览器debugger失效_chrome debugger不生效-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1dc041dbbe176e486a17c1bf9f3604e/" rel="bookmark">
			【力扣每日一题】力扣2707字符串中的额外字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源 力扣2707字符串中的额外字符
题目描述 给你一个下标从 0 开始的字符串 s 和一个单词字典 dictionary 。你需要将 s 分割成若干个 互不重叠 的子字符串，每个子字符串都在 dictionary 中出现过。s 中可能会有一些 额外的字符 不在任何子字符串中。 请你采取最优策略分割 s ，使剩下的字符 最少 。
示例 示例 1：
输入：s = "leetscode", dictionary = ["leet","code","leetcode"]
输出：1
解释：将 s 分成两个子字符串：下标从 0 到 3 的 "leet" 和下标从 5 到 8 的 "code" 。只有 1 个字符没有使用（下标为 4），所以我们返回 1 。
示例 2：
输入：s = "sayhelloworld", dictionary = ["hello","world"]
输出：3
解释：将 s 分成两个子字符串：下标从 3 到 7 的 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1dc041dbbe176e486a17c1bf9f3604e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c723baec8abc373fea2407c104742f/" rel="bookmark">
			在React和Vue中实现锚点定位功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在React和Vue中实现锚点定位功能的方法略有不同，下面我将分别介绍。
在React中，可以使用useState和useEffect钩子来实现锚点定位功能。首先，需要定义一个状态变量来保存当前选中的锚点，然后在组件挂载时，使用useEffect钩子获取页面滚动距离，并将该距离保存到状态变量中。接着，在渲染锚点时，可以根据当前选中的锚点来设置锚点的样式，例如可以设置锚点的背景颜色、文字颜色等。最后，在锚点被点击时，更新状态变量，并使用useEffect钩子重新获取页面滚动距离，实现锚点定位功能。
在Vue中，可以使用指令来实现锚点定位功能。首先，需要定义一个指令来处理页面滚动。指令的参数可以是锚点的id或class名，也可以是滚动到指定位置的偏移量。指令的回调函数中，可以获取到页面滚动距离，并将其保存到组件的data属性中。然后，在渲染锚点时，可以根据当前选中的锚点来设置锚点的样式。最后，在锚点被点击时，更新data属性，并触发指令处理页面滚动，实现锚点定位功能。
总的来说，实现锚点定位功能需要获取页面滚动距离，并根据当前选中的锚点来设置样式。在React中，可以使用状态变量和钩子来实现；在Vue中，可以使用指令来实现。
以下是在React和Vue中实现锚点定位功能的代码示例：
React:
import React from 'react'; const ScrollToAnchor = () =&gt; { const scrollToSection = (sectionId) =&gt; { const element = document.getElementById(sectionId); if (element) { element.scrollIntoView({ behavior: 'smooth' }); } }; return ( &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;a onClick={() =&gt; scrollToSection('section1')}&gt;Section 1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a onClick={() =&gt; scrollToSection('section2')}&gt;Section 2&lt;/a&gt; &lt;/li&gt; {/* 其他导航链接... */} &lt;/ul&gt; &lt;/nav&gt; &lt;section id="section1"&gt; &lt;h2&gt;Section 1&lt;/h2&gt; {/* 内容... */} &lt;/section&gt; &lt;section id="section2"&gt; &lt;h2&gt;Section 2&lt;/h2&gt; {/* 内容.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c723baec8abc373fea2407c104742f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aab372f05899da3251962105cc7a8ac/" rel="bookmark">
			酒店订房小程序源码系统：帮您打造类似美团的酒店模式的小程序 带完整的安装部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着移动互联网的快速发展，小程序已经成为一种新型的应用形态，为各大行业提供了更加便捷的服务。其中，酒店预订小程序作为一种方便快捷的预订方式，备受用户青睐。小编给大家分享一款酒店订房小程序源码系统，旨在帮助您快速打造类似美团的酒店预订模式的小程序，并附带完整的安装部署教程。
以下是部分代码示例：
系统特色功能一览：
1.多酒店选择：用户可以在小程序上浏览多个酒店的房型、价格、设施等信息，方便快捷地选择适合自己的酒店。
2.在线预订：用户可以直接在小程序上进行预订操作，无需跳转到其他平台。系统支持多种支付方式，方便用户完成支付。
3.优惠活动：酒店可以发布各种优惠活动，吸引用户预订。用户可以随时查看活动详情并参与。
4.评价与分享：用户可以对入住的酒店进行评价和分享，为其他用户提供参考。同时，系统支持用户将酒店信息分享给好友或社交媒体，提高酒店知名度。
5.客服支持：酒店为用户提供在线客服支持，解答用户疑问，处理预订问题。
6.数据统计与分析：系统提供完善的数据统计与分析功能，帮助酒店了解用户需求和市场趋势，优化 产品和服务。
7.安装部署教程：为了帮助您快速搭建小程序，我们提供了完整的安装部署教程。您只需按照教程操作，即可轻松搭建属于自己的酒店预订小程序。
页面展示：
源码下载地址：春哥技术博客或帮企商城获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffbf9119b2765f457d6ce708ab9a51d/" rel="bookmark">
			[Docker] Mac M1系列芯片上完美运行Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker pull qinchz/dm8-arm64 container_name: dm8 ports: - "5236:5236" mem_limit: 1g memswap_limit: 1g volumes: - /data/dm8:/home/dmdba/data 数据库实例参数已修改，接近oracle使用习惯
#字符集 utf-8 CHARSET=1 #VARCHAR 类型对象的长度以字符为单位 LENGTH_IN_CHAR=1 #标识符大小写不敏感 CASE_SENSITIVE=0 [可选]自定义数据库实例参数
1.启动容器
2.进入容器，删除脚本服务、删除数据实例。参考
3.进入容器目录/usr/local/bin，修改docker-entrypoint.sh文件第17行
${DM_PATH}/bin/dminit PATH=/home/dmdba/data PAGE_SIZE=16 CHARSET=1 LENGTH_IN_CHAR=1 CASE_SENSITIVE=0 4.重新启动容器（restart）
注：数据库实例参数表，可在/home/dmdba/dmdbms/bin目录下执行 ./dminit help 查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8208dbaece4eb506a17a45bf055bb3a/" rel="bookmark">
			Nginx安装http2和ssl模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx安装http2和ssl模块 Nginx在执行默认安装命令的时候，并不会编译启用ngx_http_v2_module模块。故在修改Nginx配置文件启用http2.0协议的时候会报错。
一.检查Nginx安装了哪些模块 #进入Nginx的安装目录 cd /usr/local/nginx #执行命令查看安装了哪些模块 ./sbin/nginx -V 如图就是没有安装ngx_http_v2_module模块
二.重新编译Nginx Nginx有两个目录，一个是安装目录，一个是源码目录，安装目录就是执行安装流程后的目录，一般默认位置是/usr/local/nginx
源码目录就是Nginx安装包解压的目录，也就是执行make和make install的文件目录
进入到nginx源码目录重新编译，通过–with-http_v2_module启用ngx_http_v2_module模块，然后make 。
注意这里不要执行make install，如果执行了install会覆盖之前的安装目录
#进入源码目录 cd /home/ngtl/nginx-1.22.0/ #配置编译文件，如果上一步有已经启用的模块则需要包括已启用的模块和ngx_http_v2_module模块 #这里一并安装了其余两个常用的模块，包括ssl和stub_status监视模块 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module 等待执行完毕
#然后make编译 make 等待编译完成
编译后的新生成的nginx文件在源码目录的objs目录下，如图所示：
三.替换原有的Nginx文件 #备份 cd /usr/local/nginx/sbin mv nginx nginx.bak #替换Nginx文件 cp /home/ngtl/nginx-1.22.0/objs/nginx /usr/local/nginx/sbin ls 然后检查模块是否安装成功
cd /usr/local/nginx/sbin ./nginx -V 至此Nginx新增模块就成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de3df113662d74ce6197fdb81d7abf3/" rel="bookmark">
			Intellij IDEA debug模式下项目启动慢/无法启动的事件解决过程记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是由于方法上加了断点导致的，用debug启动，找下断点，去掉断点再启动就正常了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6594cf29a7adf7ac43bb6333c3509e30/" rel="bookmark">
			test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓展阅读 开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息)
开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。)
test fuzz-01-模糊测试（Fuzz Testing）
test fuzz-02-模糊测试 JQF + Zest Semantic Fuzzing for Java
test fuzz-03-模糊测试 Atheris A Coverage-Guided, Native Python Fuzzer
test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM
test fuzz-05-模糊测试 kelinci AFL-based fuzzing for Java
test fuzz-06-模糊测试 AFL american fuzzy lop - a security-oriented fuzzer
test fuzz-07-模糊测试 libfuzzer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6594cf29a7adf7ac43bb6333c3509e30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aecc1d2c7664a3fb54eacd5aa2bbd646/" rel="bookmark">
			九大排序算法原理图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		九大排序算法图解 0、稳定性和复杂度1、直接插入排序（插入类）2、折半插入排序（插入类）3、冒泡排序（交换类）4、简单选择排序（选择类）5、希尔排序(插入类)6、快速排序（交换类）7、堆排序（选择类）8、2路归并排序9、基数排序 0、稳定性和复杂度 开始之前，先简单介绍一下排序算法的几个重要指标,这里，我尽量用自己理解的傻瓜式方法解读：
（1）稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中r1领先于r2,那么排序后r1如果仍旧领先r2的话，则是稳定的。（相等的元素排序后相对位置不变）
（2）不稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中r1领先于r2,那么排序后r1如果落后r2的话，则是不稳定的。（相等的元素排序后相对位置发生改变）
（3）时间复杂度：算法的时间开销是衡量其好坏的最重要的标志。高效率的算法应该具有更少的比较次数和记录移动次数。
（4）空间复杂度：即执行算法所需要的辅助存储的空间。
排序算法小结表
1、直接插入排序（插入类） 流程描述：遍历序列中的关键字，每次取一个待排序的关键字，从待排序关键字的前一个关键字逐次向前扫描，如果扫描到的关键字大于待排序关键字，则把扫描到的关键字往后移一个位置。最后找到插入位置，将待排序关键字插入。
void InsertSort(int R[],int n)
{
int i,j
int temp;
for(i=1;i&lt;n;++i)
{
temp=R[i]; //将待排关键字暂时存放在temp中
j=i-1; //待排关键字的前一个关键字序号
while(j&gt;=0&amp;&amp;temp&lt;R[j])
//从待排关键字的前一个关键字开始扫描，如果大于待排关键字，则往后移一个位置
{
R[j+1]=R[j];
–j;
}
R[j+1]=temp; //找到插入位置，将temp中暂存的待排关键字插入
}
}
最坏情况：整个序列是逆序的时候，则内层循环的条件temp&lt;R[j]始终成立，此时对于每一次外层循环，内层循环次数每次达到最大值（即内层循环位i次），外层循环i取值为1~i-1,所以总的执行次数为n(n-1)/2 。
最好情况：整个序列为正序的时候。内层循环条件始终不成立，所以内层循环始终不执行，始终执行语句R[j+1]=temp。所以时间复杂度为O(n)。
空间复杂度：算法所需的辅助存储空间不随待排序列的规模变化而变化，是个常量，所以为O(1)。
2、折半插入排序（插入类） 过程描述：过程同直接插入排序，只是不同于直接插入排序时用顺序查找，这里用的是折半查找。所以折半插入排序在查找过程上比直接插入排序节约不少时间。但是关键字移动次数和直接插入排序一样。
3、冒泡排序（交换类） 过程描述：通过一系列的交换动作实现排序。首先第一个关键字和第二个关键字比较，如果第一个关键字大，二者交换；然后第二个关键字和第三个关键字比较，如果第二个关键字大，二者交换，否则不交换。一直进行下去，知道最终最大的哪个关键字被交换到了最后，一趟冒泡排序完成。
void BubbleSort(int R[],int n)
{
int i,j,flag;
int temp;
for(i=n-1;i&gt;=1;–i)
{
flag=0; //flag用来标记本趟排序是否发生了交换
for(j=1;j&lt;=i;++j)
{
if(R[j-1]&gt;R[j])
{
temp=R[j];
R[j-1]=R[j];
R[j]=temp;
flag=1; //flag=1表示本次排序发生了交换
}
if(flag==0)//如果没有发生交换，说明序列有序，排序结束
return;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aecc1d2c7664a3fb54eacd5aa2bbd646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff59e848feef62643fb731a54fe7c12/" rel="bookmark">
			HTB | Codify vm2@3.9.16 中的沙箱逃逸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用nmap进行端口扫描
nmap -sV -sC -v -oN codify 10.10.11.239 # Nmap 7.93 scan initiated Mon Jan 8 16:36:49 2024 as: nmap -sV -sC -v -oN codify 10.10.11.239 Nmap scan report for 10.10.11.239 Host is up (1.2s latency). Not shown: 997 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 96071cc6773e07a0cc6f2419744d570b (ECDSA) |_ 256 0ba4c0cfe23b95aef6f5df7d0c88d6ce (ED25519) 80/tcp open http Apache httpd 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cff59e848feef62643fb731a54fe7c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21dbc49107df53f463e61636f632d32/" rel="bookmark">
			docsify 文章加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docsify 文章加密 什么是docsify？ 简单来说是一款便捷的文档网站
官网文档
docsify支持很多中部署方式，包括单独部署，Github部署，Gitee部署....对于没有前端能力固定样式非常友好
加密需求 对于部署上的文档在部分时候需要进行加密，加密方式有两种
文档整体加密
部分内容加密
探索加密 文档整体加密 搜索各大网站只有别人写的问题整体加密， 参考文章：docsify文档加密解密插件
需要文章整体加密的使用上面文档即可，写的很详细。
文档部分加密 针对文档部分加密并没有找到方案...实在忍不住只能自己写了。
思路开端：docsify会在加载md文件时会先转化为html，然后再加载到页面,思路来自于看到全文加密的源码中。
翻官方文档，在自定义插件中找到方法：
hook.afterEach(function(html, next) { // 解析成 html 后调用。 // beforeEach 和 afterEach 支持处理异步逻辑 // ... // 异步处理完成后调用 next(html) 返回结果 next(html); }); 思路 转换md文件到html后解析自定义标签，我这里使用的是标签，如果url上的pwd密码参数等于标签中的value属性则展示标签包含的加密内容，否则展示另一端提示的html。
代码 定义解析html方法
function parsePwd(content) { // Get the URL parameters let currentURL = window.location.href; const hashParams = currentURL.split('?')[1]; // 获取问号后面的部分 var urlParams = new URLSearchParams(hashParams); var pwdParam = urlParams.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c21dbc49107df53f463e61636f632d32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb578d52181a67cfcea13f158deefc56/" rel="bookmark">
			Docker实战08｜Docker管道及环境变量识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章中，讲解了如何通过Go语言实现对Docker Cgroup的资源限制
具体文章可见《Docker就应该这么学-07》
有需要的小伙伴可以回顾一下。
接下来本文会详细介绍一下Docker 管道及环境变量识别
管道及环境变量识别 获取代码
git clone https://gitee.com/mjreams/docker.git 当在Linux上创建两个进程时，进程之间的通信一般就会使用管道的机制。所谓管道，就是一个连接两个进程的通道，它是Linux支持IPC的其中一种方式。一般来说，管道都是半双工的，一端进行写操作，另外一端进行读操作。
常用的管道分为两种类型。一种类型是无名管道，它一般用于具有亲缘关系的进程之间；另外一种是有名管道，或者叫FIFO管道，它是一种存在于文件系统的管道，可以被两个没有任何亲缘关系的进程进行访问。有名管道一般可以通过mkfifo()函数来创建。
从本质上来说，管道也是文件的一种，但是它和文件通信的区别在于，管道有一个固定大小的缓冲区，大小一般是4KB。当管道被写满时，写进程就会被阻塞，直到有读进程把管道的内容读出来。同样地，当读进程从管道内拿数据的时候，如果这时管道的内容是空的，那么读进程同样会被阻塞，一直等到有写进程向管道内写数据。
首先增加了一个函数，使用Go提供的pipe方法生成一个匿名管道。这个函数返回两个变量，一个是读一个是写，其类型都是文件类型。
见container/container_process.go
这个方法的改动点己经表明，这里主要解决的问题是如何将创建的管道的一端传给子进程。这是一个文件类型，肯定不能通过字符参数的方式进行传递，因此使用了command的cmd.ExtraFiles方法。这个属性的意思是会外带着这个文件句柄去创建子进程。为什么叫“外带着”呢？因为1个进程默认会有3个文件描述符，分别是标准输入、标准输出、标准错误。这3个是子进程一创建的时候就会默认带着的，那么外带的这个文件描述符理所当然地就成为了第4个。
这里可以看到默认的文件描述符。通过这种方式，就把管道的一端传给子进程了。下面来看子进程的改动。
见container/init.go
这里得到父进程传递过来的管道一端后，就直接去读，由于此时父进程可能还没写入，所以此时的读操作就会停在这里等待输入。然后，看一下最终的init方法做了什么。
可以看到，init进程读取了父进程传递过来的参数后，在子进程内进行了执行，这样就完成了将用户指定命令传递给子进程的操作。
最后，来看一下父进程是在哪里发送的参数。
见run.go Run()
//发送用户命令 sendInitCommand(comArray, writePipe) 在父进程中，当进程start完毕后才发送参数，也就是说，子进程这时应该己经在读等待了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e6dc34245d5cd0534925348e9041bc/" rel="bookmark">
			MySQL总结__狂神说Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql命令大全 优质博客 1、初识MySQL 执行顺序：
JavaEE：企业级Java开发 Web
前端（页面：展示：数据）
后台 （连接点：连接数据库JDBC,连接前端（控制视图跳转，给前端传递数据））
数据库（存数据，Txt,Excel,Word）
只会写代码，学好数据库，基本混饭吃：
操作系统，数据结构与算法！当一个不错的程序猿！
离散数学，数字电路，体系结构，编译原理。+实战经验，优秀程序猿
1.1为什么学数据库 1、岗位需求
2、现在的世界，大数据时代，得数据者得天下
3、被迫需求：存数据
4、数据库是所有软件体系中最核心的存在 DBA
1.2 什么是数据库 数据库：(DB,DataBase)
概念:数据仓库，软件，安装在操作系统之（windows,Linux。mac）上的！SQL,可以存储大量的数据，500万!
作用:存储数据，管理数据 Excel
1.3 数据库分类 关系型数据库：(SQL)
MySQL, Oracle, sql Server, DB2, SQLite通过表和表之间，行和列之间的关系进行数据的存储 非关系型数据库：(NoSQL) Not Only SQL
Redis, MongDB非关系型数据库，对象存储，通过对象自身的属性来决定。 **DBMS(数据库管理系统) **
数据库的管理软件，科学有效的管理我们的数据，维护和获取MySQL ，数据管理系统！ 1.4 MySQL简介 MySQL是一个**关系型数据库管理系统**
前世： 瑞典MySQL AB 公司
今身： 属于 Oracle 旗下产品
MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。
开源的数据库软件
体积小，速度快，总体拥有成本低，招人成本比较低。
中小型网站，或者大型网站，集群
官网： https://www.mysql.com/
mysql自带4个默认数据库： information_schema performance_schema mysql test informance_schema： 保存了MySQl服务所有数据库的信息。 具体MySQL服务有多少个数据库，各个数据库有哪些表，各个表中的字段是什么数据类型，各个表中有哪些索引，各个数据库要什么权限才能访问。 mysql： 保存MySQL的权限、参数、对象和状态信息。 如哪些user可以访问这个数据、DB参数、插件、主从 performance_schema： 主要用于收集数据库服务器性能参数 提供进程等待的详细信息，包括锁、互斥变量、文件信息； 保存历史的事件汇总信息，为提供MySQL服务器性能做出详细的判断； 对于新增和删除监控事件点都非常容易，并可以随意改变mysql服务器的监控周期，例如（CYCLE、MICROSECOND） test： 没有东西 sakila：sakila数据集是MySQL官方提供的一个学习MySQL的很好的素材，作者是 Mike Hillyer，该数据集是用于替代之前的world数据集（Oracle也提供的有这个），world数据集比较简单，只包含3个表：国家，城市，语言。 world：示例数据库 sys：sys库所有的数据源来自：performance_schema。目标是把performance_schema的把复杂度降低，让DBA能更好的阅读这个库里的内容。让DBA更快的了解DB的运行情况。sys_开头是库里的配置表，sys_config用于sys schema库的配置。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e6dc34245d5cd0534925348e9041bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f015682bf132b588e13e27b78838da1/" rel="bookmark">
			Django全文搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django ORM允许你执行简单的匹配操作，例如contains过滤器（或者不区分大小写的icontains）。
比如查询正文中包含django的文章
from blog.models import Post Post.objects.filter(body__contains='framework') 但是如果希望执行复杂的搜索查询，通过相似度或加权项检索结果，则需要更强大的搜索功能。
📌虽然Django是一个与数据库无关的web框架，但它提供了一个模块，该模块支持PostgreSQL提供的部分丰富特性，不支持非PostgreSQL数据库。
Django.contrib.postgres模块提供了由PostgreSQL专享的功能。
简单查询 INSTALLED_APPS = [ #... "django.contrib.postgres", ] 对单个字段进行搜索
from blog.models import Post Post.objects.filter(body__search='django') 对多个字段进行查询 搜索Post模型的标题和正文字段
from django.contrib.postgres.search import SearchVector from blog.models import Post Post.objects.annotate( search=SearchVector('title', 'body'), ).filter(search='django') 使用annotate并使用两个字段定义SearchVector(文章标题和正文)。
构建查询视图 创建一个自定义视图，首先需要一个搜索表单
编辑form.py，新建SearchForm表单类
from django import forms from .models import Comment class EmailPostForm(forms.Form): name = forms.CharField(max_length=25) email = forms.EmailField() to = forms.EmailField() comments = forms.CharField(required=False,widget=forms.Textarea) class CommentForm(forms.ModelForm): class Meta: model = Comment fields = ('name','email','body') class SearchForm(forms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f015682bf132b588e13e27b78838da1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e274422d03f769f9eebdaac5644121b8/" rel="bookmark">
			MySQL 递归 CTE(公共表表达式) -___MySQL 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址 www.yiibai.com
最近在做项目管理的项目，其中有层级关联，多模块情况，感觉平时的树状数据库设计不太行，所以了解了一下，突然看到了关于MySQL在8.0上面迭代的更新，非常不错
在本教程中，您将了解 MySQL 递归 CTE(公共表表达式) 以及如何使用它来遍历分层数据。 自 MySQL 8.0 版以来简要介绍了公共表表达式或叫 CTE 的功能，因此需要 MySQL 8.0及以上版本
在本教程中，您将了解 MySQL 递归 CTE(公共表表达式) 以及如何使用它来遍历分层数据。
自 MySQL 8.0 版以来简要介绍了公共表表达式或叫 CTE 的功能，因此需要您在计算机上安装 MySQL 8.0，以便在本教程中练习本语句。
MySQL 递归 CTE 简介 递归公用表表达式 (CTE) 是一个具有引用 CTE 名称本身的子查询的 CTE。以下说明递归 CTE 的语法 -
WITH RECURSIVE cte_name AS ( initial_query -- anchor member UNION ALL recursive_query -- recursive member that references to the CTE name ) SELECT * FROM cte_name; 递归 CTE 由三个主要部分组成：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e274422d03f769f9eebdaac5644121b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2282fc590804ee6847aafed584725f/" rel="bookmark">
			高级RAG(五)：TruLens 评估-扩大和加速LLM应用程序评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前我们介绍了，RAGAs评估，今天我们再来介绍另外一款RAG的评估工具:TruLens , trulens是TruEra公司的一款开源软件工具，它可帮助您使用反馈功函数客观地评估基于 LLM 的应用程序的质量和有效性。反馈函数有助于以编程方式评估输入、输出和中间结果的质量，以便我们可以加快和扩大实验评估，并将其用于各种应用场景，包括问答、检索增强生成和基于代理的应用程序。
一、核心概念 1.1 反馈函数 反馈函数，类似于标记函数，提供了一种在应用程序运行时生成评估的编程方法。TruLens的反馈函数的实现包装了一个受支持的提供者模型，比如一个相关性模型或一个情感分类器，它被重新用于提供评估。通常，为了获得最大的灵活性，这个模型也可以是另一个LLM。
在两个维度上考虑评估范围是非常有用的：可扩展性(Scalable)和有意义(Meaningful)。
领域专家评估(Ground Truth Evals)
在早期开发阶段，我们建议从领域专家评估开始。这些评估通常是由开发人员自己完成的，代表了你的应用程序期望完成的核心用例。这让你能够更深入地了解应用的性能，但却缺乏规模性。
用户反馈（人工）评估(Human Evals)
在你完成了早期评估并对你的应用获得更多信心后，收集人们的反馈通常是有用的。这通常以用户提供的二元(上/下)反馈的形式出现。这比基本事实(Ground Truth)的可扩展性稍强，但与方差作斗争，并且收集起来仍然很昂贵。
传统 NLP 评估(Traditional NLP Evals)
传统的 NLP 指标进行评估是一种常见的做法，例如 BLEU 和 ROUGE。虽然这些评估具有极高的可扩展性，但它们通常过于语法化，并且无法提供有关应用程序性能的有意义的信息。
中等语言模型评估(MLM Evals)
中等语言模型(如BERT)是LLM应用评估的最佳选择。这种规模的模型运行起来相对便宜(可扩展)，还可以为你的应用提供细微的、有意义的反馈。在某些情况下，这些模型需要进行微调，以便为你的领域提供正确的反馈。
TruLens提供了许多开箱即用的反馈功能，这些功能依赖于这种模型风格，如基础NLI、情感、语言匹配、适度等。
大型语言模型评估(LLM Evals)
大型语言模型也可以为LLM应用程序的性能提供有意义和灵活的反馈。通常通过简单的提示，基于LLM的评估可以提供与人类非常一致的有意义的评估。此外，它们可以很容易地用LLM提供的推理来扩展，以证明对调试有用的高或低评估分数。
根据LLM的规模和性质，这些评估在规模上可能相当昂贵。
1.2 RAG三元组 为了避免LLM产生幻觉，RAG已经成为为LLM提供上下文(Context)的标准架构。然而，即使是RAG也会产生幻觉，因为当检索器无法检索到足够的上下文，甚至检索到不相关的上下文，然后将其传送给LLM后,LLM也可能产生幻觉。
TruEra创新的使用了RAG三元组来评估RAG架构的每条边的幻觉，如下所示:
RAG 三元组由 3 个评估组件组成：上下文相关性(Context Relevance)、基础性(Groundedness)和答案相关性(Answer Relevance)。 上下文相关性(Context Relevance)
任何 RAG 应用程序的第一步都是检索；为了验证检索的质量，我们希望确保每个检索到的上下文文档块(Context)都与输入查询(question)相关。这一点至关重要，因为LLM将使用此Context来形成答案(answer)，因此Context中任何不相关的信息都可能会被编织成幻觉。TruLens 使您能够使用序列化记录的结构来评估上下文相关性。
基础性(Groundedness)
在检索上下文之后，然后由LLM将其形成答案。LLM往往倾向于偏离所提供的事实，夸大或扩展到一个听起来正确的答案。为了验证我们的应用程序的基础性(groundedness)，我们可以将LLM产生的答案(answer)分成单独的主张(claims)，并在检索的上下文(Context)中独立地搜索支持每个主张的证据。
答案相关性(Answer Relevance)
最后，我们的答案(answer)仍然需要有助于回答最初的问题。我们可以通过评估最终答案与用户输入(question)的相关性来验证这一点。
将它们组合在一起
如果我们对这个三元组进行评估后获得了满意的结果， 我们可以明确的说我们的应用程序经验证在其知识库的限制范围内不会出现幻觉。 换句话说，如果向量数据库包含的信息时准确的，那么RAG提供的答案也是准确的。
二、基本的RAG管道 2.1 基本的RAG管道介绍 在进行TruLens评估之前，我们首先回顾一下基本的RAG架构：
在基本RAG架构中包含了文档数据的处理，文档内容检索、LLM应答等环节，其中文档数据处理包含了文档的分割，向量化处理，向量数据库存储等步骤，而文档内容检索又包含了对向量数据库内容的相似度搜索，获取top_k个相关文档等步骤，然后将相关文档(context)和用户问题传送给LLM并产生最终的答案(answer), 如果对这些过程和步骤还不熟悉的朋友可以看一下我之前写的使用langchain与你自己的数据对话系列博客。接下来我们要使用llamaIndex开发一个基本RAG应用程序，并使用TruLens的RAG三元组对其进行评估。
2.2 环境配置 我们首先需要安装如下python包：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2282fc590804ee6847aafed584725f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138e06e081948ee1951e07dbd7661b1a/" rel="bookmark">
			系统存储架构升级分享 | 京东云技术团队
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、业务背景 系统业务功能：系统内部进行数据处理及整合, 对外部系统提供结果数据的初始化(写)及查询数据结果服务。
系统网络架构:
部署架构对切量上线的影响 - 内部管理系统上线对其他系统的读业务无影响分布式缓存可进行单独扩容, 与存储及查询功能升级无关通过缓存层的隔离, 系统扩展期间外部系统可保持不变, 只对内部管理系统升级内部系统上线/验证时, 除了业务场景1相关的初始化操作, 仍可提供读服务，降低上线影响 二、本次升级整体实施方案: 整体实施方案图例:
（一）、设立目标 商品全量渠道化-切量计划: (总量为当前10倍):
目前：
当前数据库常用表均已超过5000W, 其中部分结果表达6000W, 已达到MYSQL数据库表容量峰值, 对于全切量无法支持;
目标:
最高支持9亿: 根据切量计划, 全切量后系统约为6.7亿, 保留1/4的冗余, 取8.375亿; 向上取整9亿, 此值冗余量较大, 可满足未来5年数据支持
时间目标: 8月初方案设定, 8月17~8.22上线及验证, 8.24切量计划开始
（二）、当前系统现状 1、资源使用 •当前部署结构
——机房分布，Mysql: 1主4从(机房A 1主, 3从; 机房B只读从)
——机房分布，Doris: 32C, 63个节点, 3副本
•当前应用容器（docker）数量，db最大连接数
——应用容器数量: 62 (Web分组: 25, Worker分组: 31, MQ分组: 6)
——db最大连接数100 (每个容器配置)
•当前业务是否读写分离，读写比例情况
——无读写分离
•各业务场景下，是否可容忍主从延迟？可容忍的延迟时长是多少
——目前业务人员修改操作多数为同步操作, 修改完成后返回操作结果到前端, 从业务方操作+查询结果来说, 无法空忍延迟
——后台任务场景, 对于中间数据处理, 可以容忍主从延迟
•产品层面，系统出现瓶颈压力时，是否接受限流？是否接受数据延迟展示？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/138e06e081948ee1951e07dbd7661b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbbcd6f2b0d31be1b349c8747efd8517/" rel="bookmark">
			CNN和RNN的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNN（卷积神经网络）和RNN（循环神经网络）是深度学习中的两种主要神经网络类型，它们在结构、功能和应用领域上有显著的区别：
核心结构与工作原理: CNN: CNN主要用于处理具有网格状拓扑结构的数据，如图像（2D网格）和视频（3D网格）。它通过卷积层来提取局部特征，这些卷积层可以捕捉空间上的相关性，如形状、纹理等。CNN通常还包括池化层（用于降低特征维度和增加网络深度）和全连接层。
RNN: RNN专门用于处理序列数据，如文本、时间序列数据等。它的特点是在时间步之间有循环连接，这意味着当前时间步的输出依赖于前一时间步的输出。这种结构使RNN能够记忆之前的信息，并在当前上下文中使用这些信息。
2.应用领域:
CNN: CNN在图像和视频处理领域表现出色，如图像分类、对象检测、面部识别等。它们也被用于一些复杂的任务，如风格迁移、图像生成等。
RNN: RNN常用于自然语言处理任务，如文本生成、机器翻译、语音识别等。它们也用于其他序列数据的分析，如股票价格预测、天气预报等。
记忆和上下文处理能力: CNN: CNN不具备内在的序列处理能力，它主要关注于局部特征的提取。CNN对于空间上下文（如图像中的像素之间的关系）处理非常有效，但不适用于时间序列数据。
RNN: RNN的设计使其能够处理和记忆长期的序列信息，这对于理解语言和其他连续数据至关重要。
时间依赖性: CNN: CNN处理每个输入独立于其他输入（除了在图像中的局部区域）。它们不具备处理时间序列中步骤之间依赖关系的能力。
RNN: RNN可以处理时间序列数据中不同时间步之间的依赖关系。
训练和计算效率: CNN: 由于其并行处理能力，CNN通常比RNN更易于训练和更高效。
RNN: RNN由于其序列依赖性，通常更难训练（如梯度消失问题），并且在计算上不如CNN高效。
综上所述，CNN和RNN分别针对不同类型的数据和任务进行了优化。CNN擅长处理空间数据（如图像），而RNN擅长处理时间序列或顺序数据（如文本）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada3fd431c40ba2836609857a28283b3/" rel="bookmark">
			2401d,ddip1027如何支持sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文
以下是DIP1036的SQL支持方式:
这里
auto execi(Args...)(Sqlite db, InterpolationHeader header, Args args, InterpolationFooter footer) { import arsd.sqlite; //`SQLite`允许你执行`?1,?2`等操作 enum string query = () { string sql; int number; import std.conv; foreach(idx, arg; Args) static if(is(arg == InterpolatedLiteral!str, string str)) sql ~= str; else static if(is(arg == InterpolationHeader) || is(arg == InterpolationFooter)) throw new Exception("Nested interpolation not supported"); else static if(is(arg == InterpolatedExpression!code, string code)) { } //只需跳过它 else sql ~= " "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada3fd431c40ba2836609857a28283b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c897cef3ed4bcad4f91d880fe4f00a/" rel="bookmark">
			vulhub中的Apache SSI 远程命令执行漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Apache SSI 远程命令执行漏洞 1.cd到ssi-rce cd /opt/vulhub/httpd/ssi-rce/
2.执行docker-compose up -d docker-compose up -d
3.查看靶场是否开启成功 dooker ps
拉取成功了
4.访问url 这里已经执行成功了，注意这里需要加入/upload.php
5.写入一句话木马 &lt;!--#exec cmd="echo '&lt;?php phpinfo(); ?&gt;' &gt; /var/www/html/this.php" --&gt;
6.提交查询 7.点击shell.shtml 8.查看是否写入成功 docker exec -it ssi-rce_apache_1 /bin/bash
9.获取phpinfo 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3658221806b66ceded47e1bef0d1bc/" rel="bookmark">
			window mysql5.7 搭建主从同步环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window 搭建mysql5.7数据库 主从同步
主节点 配置文件my3308.cnf
[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] server-id=8 #server-uuid=bc701be9-ac71-11ee-9e35-b06ebf511956 log-bin=D:\mysql_5.7.19\mysql-5.7.19-winx64\mysql-bin binlog-format=Row #设置需要同步的数据库名 binlog-do-db=yymdb #屏蔽数据库同步 binlog-ignore-db=mysql binlog-ignore-db=performance_schema binlog-ignore-db=information_schema binlog-ignore-db=sys # 设置3308端口 port=3308 # 设置mysql的安装目录 basedir=D:\mysql_5.7.19\mysql-5.7.19-winx64\mysql-5.7.19-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 datadir=D:\mysql_5.7.19\mysql-5.7.19-winx64\data3308 # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB explicit_defaults_for_timestamp=true log-error=D:\mysql_5.7.19\mysql-5.7.19-winx64\mysql3308.err pid-file=D:\mysql_5.7.19\mysql-5.7.19-winx64\mysqld3308.pid socket=D:\mysql_5.7.19\mysql-5.7.19-winx64\mysql3308.sock 从节点 配置文件my3309.cnf
[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] server-id=9 log-bin=D:\mysql_5.7.19\mysql-5.7.19-winx64\slave-bin binlog-format=Row # 设置3309端口 port=3309 # 设置mysql的安装目录 basedir=D:\mysql_5.7.19\mysql-5.7.19-winx64\mysql-5.7.19-winx64 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 datadir=D:\mysql_5.7.19\mysql-5.7.19-winx64\data3309 # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB explicit_defaults_for_timestamp=true log-error=D:\mysql_5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3658221806b66ceded47e1bef0d1bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28221b0cf8de73054512f85730ff3d0/" rel="bookmark">
			NSIS 安装windows 安装包（包括QT和MFC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装程序制作程序。它提供了安装、卸载、系统设置、文件解压缩等功能。
基本概念 区段
是对应某种安装/卸载选项的处理逻辑，该段代码仅当用户选择相应的选项才被执行。卸载程序的区段名用"un."作为前缀。
/o表示该区段默认不选上，-表示隐藏区段(匿名区段也是隐藏区段)，！表示需要粗体显示的区段。
Section "Installer Section"
SectionEnd Section "un.Uninstaller Section"
SectionEnd
函数
在nsi脚本中函数分为两种：用户自定义函数和回调函数。
用户自定义函数
Function &lt;函数名&gt; # some commands
FunctionEn
用户自定义函数仅当是Call指令调用时才被执行
回调函数
回调函数则是由在特定的时间点触发的程序段
安装逻辑定义以下回调函数
.onGUIInit、.onInit、.onInstFailed、.onInstSuccess、.onGUIEnd、.onMouseOverSection、.onRebootFailed、.onSelChange、.onUserAbort、.onVerifyInstDir
卸载逻辑回调函数
un.onGUIInit、un.onInit、un.onUninstFailed、un.onUninstSuccess、un.onGUIEnd、un.onRebootFailed、un.onUserAbort
变量
用var关键字来定义变量，使用$来引用变量
$INSTDIR
用户定义的解压路径。
$PROGRAMFILES
程序文件目录(通常为 C:Program Files 但是运行时会检测)。
0- 9, R0 -R9
脚本中定义了寄存器变量0- 9, R0 -R9用于参数传递，以及系统变量用于特定用途。使用这些参数应该通过Push和Pop的方式
$STARTMENU
开始菜单目录(常用于添加一个开始菜单项，使用 CreateShortCut)。该常量的内容(所有用户或当前用户)取决于SetShellVarContext 设置。默认为当前用户。
$SMPROGRAMS
开始菜单程序目录(当你想定位 $STARTMENU程序 时可以使用它)。该常量的内容(所有用户或当前用户)取决于SetShellVarContext 设置。默认为当前用户。
$SMSTARTUP
开始菜单程序/启动 目录。该常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。
常用指令 File
作用：释放文件到当前输出路径。
如果使用了 /r 开关，匹配的文件将会在子目录里被递归的搜索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28221b0cf8de73054512f85730ff3d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d7278f9e47a6ec2c8c27b2c58424b7/" rel="bookmark">
			GE1501 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Ploy of the Jailer Summary:
You have been captured and thrown in jail! Your jailer, a gambler and a hobby dragon breeder, is bored with his job, so he makes you an offer; Beat him at his own game and you go free. If you lose, you will be dragon food. Since you are a first-time offender, he is willing to stack the game in your favor – what a nice jailer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87d7278f9e47a6ec2c8c27b2c58424b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05a691fcd7762479a1c5a2d6fa9f1f3/" rel="bookmark">
			MySQL笔记：B站康师傅天花板教程(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ✅作者简介：大家好，我是Leo，热爱Java后端开发者，一个想要与大家共同进步的男人😉😉
🍎个人主页：Leo的博客
💞当前专栏： MySQL学习
✨特色专栏： MySQL学习
🥭本文内容：MySQL笔记：B站康师傅天花板教程(持续更新)
📚个人知识库： Leo知识库，欢迎大家访问
配套视频参考：MySQL数据库天花板–康师傅
B站康师傅MySQL天花板教程笔记： 最详细，最全面，最硬核！！！
下面是对章节与视频的对应关系和学习建议
【MySQL上篇：基础篇】
【第1子篇：数据库概述与MySQL安装篇】
p01-p11
学习建议：零基础同学必看，涉及理解和Windows系统下MySQL安装
【第2子篇：SQL之SELECT使用篇】
p12-p48
学习建议：学习SQL的重点，必须重点掌握，建议课后练习多写
【第3子篇：SQL之DDL、DML、DCL使用篇】
p49-p73
学习建议：学习SQL的重点，难度较SELECT低，练习写写就能掌握
【第4子篇：其它数据库对象篇】
p74-p93
学习建议：对于希望早点学完MySQL基础，开始后续内容的同学，这个子篇可以略过。
在工作中，根据公司需要进行学习即可。
【第5子篇：MySQL8新特性篇】
p94-p95
学习建议：对于希望早点学完MySQL基础，开始后续内容的同学，这个子篇可以略过。
在工作中，根据公司需要进行学习即可。
【MySQL下篇：高级篇】
【第1子篇：MySQL架构篇】
p96-p114
学习建议：涉及Linux平台安装及一些基本问题，基础不牢固同学需要学习
【第2子篇：索引及调优篇】
p115-p160
学习建议：面试和开发的重点，也是重灾区，需要全面细致的学习和掌握
【第3子篇：事务篇】
p161-p186
学习建议：面试和开发的重点，需要全面细致的学习和掌握
【第4子篇：日志与备份篇】
p187-p199
学习建议：根据实际开发需要，进行相应内容的学习
祝你早日学成，成为MySQL大牛！
基础篇 ❤️MySQL基础篇详解地址❤️第01章_数据库概述https://blog.csdn.net/qq_58608526/article/details/129860471?spm=1001.2014.3001.5501❤️第02章_MySQL环境搭建https://blog.csdn.net/qq_58608526/article/details/129860490?spm=1001.2014.3001.5501❤️第03章_基本的SELECT语句https://blog.csdn.net/qq_58608526/article/details/129860516?spm=1001.2014.3001.5501❤️第04章_运算符https://blog.csdn.net/qq_58608526/article/details/129860538?spm=1001.2014.3001.5501❤️第05章_排序与分页https://blog.csdn.net/qq_58608526/article/details/129860557?spm=1001.2014.3001.5501❤️第06章_多表查询https://blog.csdn.net/qq_58608526/article/details/129860580?spm=1001.2014.3001.5501❤️第07章_单行函数https://blog.csdn.net/qq_58608526/article/details/129861630?spm=1001.2014.3001.5501❤️第08章_聚合函数https://blog.csdn.net/qq_58608526/article/details/129861650?spm=1001.2014.3001.5501❤️第09章_子查询https://blog.csdn.net/qq_58608526/article/details/129861667?spm=1001.2014.3001.5501❤️第10章_创建和管理表https://blog.csdn.net/qq_58608526/article/details/129861682?spm=1001.2014.3001.5501❤️第11章_数据处理之增删改https://blog.csdn.net/qq_58608526/article/details/129861699?spm=1001.2014.3001.5501❤️第12章_MySQL数据类型精讲https://blog.csdn.net/qq_58608526/article/details/129861711?spm=1001.2014.3001.5501❤️第13章_约束https://blog.csdn.net/qq_58608526/article/details/129861721?spm=1001.2014.3001.5501❤️第14章_视图https://blog.csdn.net/qq_58608526/article/details/129861735?spm=1001.2014.3001.5501❤️第15章_存储过程与函数https://blog.csdn.net/qq_58608526/article/details/129861753?spm=1001.2014.3001.5501❤️第16章_变量、流程控制与游标https://blog.csdn.net/qq_58608526/article/details/129861767?spm=1001.2014.3001.5501❤️第17章_触发器https://blog.csdn.net/qq_58608526/article/details/129861783?spm=1001.2014.3001.5501❤️第18章_MySQL8其它新特性https://blog.csdn.net/qq_58608526/article/details/129861807?spm=1001.2014.3001.5501 高级篇 ❤️MySQL高级篇详解地址❤️第01章 Linux下MySQL的安装与使用https://blog.csdn.net/qq_58608526/article/details/129894736?spm=1001.2014.3001.5501❤️第02章 MySQL的数据目录https://blog.csdn.net/qq_58608526/article/details/129894747?spm=1001.2014.3001.5501❤️第03章 用户与权限管理https://blog.csdn.net/qq_58608526/article/details/129894755?spm=1001.2014.3001.5501❤️第04章_逻辑架构https://blog.csdn.net/qq_58608526/article/details/129894774?spm=1001.2014.3001.5501❤️第05章_存储引擎https://blog.csdn.net/qq_58608526/article/details/129894969?spm=1001.2014.3001.5501❤️第06章_索引的数据结构https://blog.csdn.net/qq_58608526/article/details/129894978?spm=1001.2014.3001.5501❤️第07章_InnoDB数据存储结构https://blog.csdn.net/qq_58608526/article/details/129894991?spm=1001.2014.3001.5501❤️第08章_索引的创建与设计原则https://blog.csdn.net/qq_58608526/article/details/129895036?spm=1001.2014.3001.5501❤️第09章_性能分析工具的使用https://blog.csdn.net/qq_58608526/article/details/129895047?spm=1001.2014.3001.5501❤️第10章_索引优化与查询优化https://blog.csdn.net/qq_58608526/article/details/129895053?spm=1001.2014.3001.5501❤️第11章_数据库的设计规范https://blog.csdn.net/qq_58608526/article/details/129895071?spm=1001.2014.3001.5501❤️第12章_数据库其它调优策略https://blog.csdn.net/qq_58608526/article/details/129895092?spm=1001.2014.3001.5501❤️第13章_事务基础知识https://blog.csdn.net/qq_58608526/article/details/129895096?spm=1001.2014.3001.5501❤️第14章_MySQL事务日志https://blog.csdn.net/qq_58608526/article/details/129895108?spm=1001.2014.3001.5501❤️第15章_锁https://blog.csdn.net/qq_58608526/article/details/129895236?spm=1001.2014.3001.5501❤️第16章_多版本并发控制https://blog.csdn.net/qq_58608526/article/details/129895259?spm=1001.2014.3001.5501❤️第17章_其他数据库日志https://blog.csdn.net/qq_58608526/article/details/129895481?spm=1001.2014.3001.5501❤️第18章_主从复制https://blog.csdn.net/qq_58608526/article/details/129895483?spm=1001.2014.3001.5501❤️第19章_数据库备份与恢复https://blog.csdn.net/qq_58608526/article/details/129895491?spm=1001.2014.3001.5501 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238ca5fcaadd73a704081d960125b213/" rel="bookmark">
			快慢指针判断环起点的数学解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析：
如图所示，快慢指针从起点出发，可以同时到达相遇点。
刚出发时，慢指针每次走1个节点，快指针每次走两个节点，假设慢指针速度为v，则快指针速度为2v
相遇时，两个指针经历的时间都为t, 慢指针移动距离为（m+n）,快指针移动距离比慢指针多了环周距离，所以为（m+n+r）
因此根据速度时间距离公式得到两个公式
慢指针：v * t = m + n
快指针：2 * v * t = m + n + r
两个公式可以得到： m + n = r
m = n - r
此时使得两个指针速度相同，一个从起点开始移动，一个从相遇点开始移动。当第一个指针移动了m的距离，到达环首节点；另一个则移动了相同的距离（n - r），从图中看，n - r也刚好是环首位置。则两者相遇的位置就是环首的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ba714a2f03c4e9b6a507ca118aaf5a8/" rel="bookmark">
			QT上位机开发（内嵌虚拟机的软件开发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
不知道大家有没有玩过plc设备。plc设备从本质上来说，就是一个单片机设备，只不过它的电源、输入、输出做了很多的加强措施。但是从功能说，plc又不是一个简单的io设置，好像只需要设置一个高低电平就可以了。所以使用plc的人，要想把plc用的好，让plc用在更多的场景上面，仅仅会接线是不够的，他还要知道怎么编写梯形图，或者知道怎么编写脚本。
这就我们一个启示。如果我们的上位机只是简单的应用，那么功能就不需要设置地很复杂。但是一旦大家希望把自己的上位机部署到更多的场景当中，那么不管怎么开发，都不一定能满足特定场景的需要。这个时候就有必要在上位机当中嵌入一个虚拟机脚本软件，这一点就非常重要了。某种意义上来说，这相当于给你的上位机赋予了第二次生命，软件本身有了更广阔的发展舞台，而不仅仅是我们提供什么，客户就只能做什么。今天呢，我们正好借助于lua语言，看看怎么在上位机当中嵌入一个虚拟机。
1、创建一个基础widget工程 创建这个widget工程的目的仅仅是为了演示，其实纯console工程也是可以的。
2、下载lua 既然vs支持nuget下载，那么除了c# wpf之外，我们也可以用nuget下载一下lua第三方包。输入lua，寻找到第一个选项即可，十分方便。目前下载的版本是5.4.6，还算是比较新的版本。
3、增加lua调用c的函数 如果是lua调用c，那么需要利用lua_register注册一个函数。这个函数最好用extern "C"包起来，这样保证链接没有问题。当然，我们为了方便测试，直接把lua_State虚拟机变量放在了外面。
#include &lt;iostream&gt; using namespace std; #include &lt;QtWidgets/QApplication&gt; #include &lt;QDebug&gt; #include "lua.hpp" #include "QtWidgetsApplication.h" // static variable static lua_State* L = NULL; // lua call c extern "C" int exampleFunction() { const char* arg = lua_tostring(L, 1); qDebug()&lt;&lt; "C++ function called with argument: " &lt;&lt; arg ; return 0; } void registerFunction(const QString&amp; functionName, lua_CFunction function) { lua_register(L, functionName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ba714a2f03c4e9b6a507ca118aaf5a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe1293e01b60e195d2458817e49040f/" rel="bookmark">
			【深度解析】MyBatis体系结构与工作原理，让你一次掌握！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis的工作流程 首先在MyBatis启动的时候我们需要去解析配置文件，包括全局配置文件(Mybatis-config.xml)以及映射器配置文件， 这里面包含了我们怎么控制MyBatis的行为和我们要对数据库下达的指令，也就是我们的SQL的信息，我们会把这些信息解析成一个Configuration对象。
接下来就是我们操作数据库的接口，它在应用程序和数据库中间，代表我们和数据库之间的一次连接，这个就是SqlSession对象。
我们要获得一个会话，必须有一个会话工厂SqlSessionFactory，SqlSessionFactory中又必须包含我们所有的配置信息，所以MyBatis通过一个builder来创建SqlSessionFactory。
我们知道MyBatis是对JDBC的封装，也就意味着底层一定会出现JDBC的一些核心对象，比如执行SQL的Statement，结果集ResultSet。在MyBatis里面，SqlSession只是提供给应用的一个接口，还不是SQL的真正执行对象。
通过代码中可以看到，SqlSession中持有一个Executor对象，用来封装对数据库的操作。在执行器Executor执行query或者update操作的时候，我们会创建一系列的对象来处理参数，执行SQL，处理结果集。我们可以简化成一个StatementHandler对象，下面是MyBatis的主要流程图：
在MyBatis的主要工作流程里面，不同的功能是由很多不同的类协作完成的，它们分布在MyBatis Jar的不同的packagel里面。
和Spring一样，MyBatis按照功能职责的不同，所有的package可以分成不同的工作层次：
接口层： 接口层是我们打交道最多的，核心对象是SqlSession，它是上层应用和MyBatis打交道的桥梁，SqlSession上定义了很多对数据库操作的方法，接口层在接收到调用请求的时候，会调用核心处理层的相应模块来完成具体的数据库操作。
核心处理层： 跟数据库操作相关的动作都是在这一层完成的。核心处理层主要做了下面几件事：
把接口中传入的参数解析并映射成JDBC类型解析xml文件中的SQL语句，包括插入参数和动态SQL的生成执行SQL语句处理结果集，并映射成Java对象
插件也属于核心处理层，这是由它的工作方式和拦截的对象决定的。
**基础支持层：**主要是由一些抽取出来的通用功能，用来支持核心处理层的功能。b比如数据源、缓存、日志等这些功能。 彩蛋
点击下方链接，可以免费获取大量电子书资源
免费获取资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1569bcbf5e6aa412bf83d4a0312c55d7/" rel="bookmark">
			Github 星标 9.3K，又一款超实用的开源手机自动跳过广告软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号关注 「奇妙的 Linux 世界」
设为「星标」，每天带你玩转 Linux ！
今天推荐的这个项目是「GKD」，基于无障碍 + 高级选择器 + 订阅规则 的自定义屏幕点击 App。
基于高级选择器、订阅规则和快照审查，实现了如下功能：
点击跳过任意开屏广告、点击关闭应用内部任意弹窗广告，如关闭百度贴吧帖子广告卡片、知乎回答底部推荐广告卡片；
一些快捷操作，如微信电脑登录自动同意、微信扫描登录自动同意、微信自动领取红包；
GKD 的首页是授权引导页面，因为自动点击需要获取屏幕信息，以及需要在其他应用之上显示悬浮窗，所以使用之前需要授予无障碍权限和悬浮窗权限。
GKD 的另一个特色是订阅，懒人专属，默认订阅已支持市面上大多数应用的广告跳过规则。
比如，微信的规则如下，包括跳过朋友圈广告、电脑自动登录、自动抢红包等功能。
下面看看一些实际效果：
1、微信自动领取红包
2、关闭微信朋友圈广告
3、关闭酷安字节 SDK 广告
4、关闭贴吧开屏广告及内部广告
开源项目地址：https://github.com/gkd-kit/gkd
开源项目作者：gkd-kit
本文转载自：「GitHub黑板报」，原文：https://url.hi-linux.com/Vi5ot，版权归原作者所有。欢迎投稿，投稿邮箱: editor@hi-linux.com。
最近，我们建立了一个技术交流微信群。目前群里已加入了不少行业内的大神，有兴趣的同学可以加入和我们一起交流技术，在 「奇妙的 Linux 世界」 公众号直接回复 「加群」 邀请你入群。
你可能还喜欢
点击下方图片即可阅读
推荐两款超实用的在线工具：IP 工具箱和 IT-Tools
点击上方图片，『美团|饿了么』外卖红包天天免费领
更多有趣的互联网新鲜事，关注「奇妙的互联网」视频号全了解！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f583ffbb4bc7a9341a4259bbd33feb/" rel="bookmark">
			Github 2024-01-09Python开源项目日报 Top10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2024-01-09统计)共有10个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量Python项目10Jupyter Notebook项目1 Payloads All The Things - 有用的Web应用程序安全负载和绕过列表 创建周期：2639 天开发语言：Python协议类型：MIT LicenseStar数量：54334 个Fork数量：13822 次关注人数：54334 人贡献人数：261 人Open Issues数量：11 个Github地址：https://github.com/swisskyrepo/PayloadsAllTheThings.git项目首页: https://swisskyrepo.github.io/PayloadsAllTheThings/ Payloads All The Things是一个开源项目，提供了一份全面的有用的Web应用程序安全负载和绕过列表，旨在进行渗透测试和CTF挑战。该项目鼓励贡献，并为每个部分提供了文档，包括漏洞描述、利用技术和相关文件。此外，它还包括一个方法论和资源文件夹，涵盖了诸如Active Directory Attack、云渗透测试、Cobalt Strike、Linux和Windows安全、Metasploit、网络枢纽、反向Shell、子域枚举等各种主题。该项目还承认了公司的贡献和赞助。
Open Interpreter: 一种自然语言接口 创建周期：179 天开发语言：Python协议类型：GNU Affero General Public License v3.0Star数量：36253 个Fork数量：3170 次关注人数：36253 人贡献人数：69 人Open Issues数量：163 个Github地址：https://github.com/KillianLucas/open-interpreter.git项目首页: http://openinterpreter.com/ Open Interpreter 是一种自然语言接口，允许LLMs在本地运行代码，使用户能够通过终端中类似于ChatGPT的界面与计算机的通用功能进行交互。它提供了创建和编辑各种类型文件、控制Chrome浏览器进行研究以及分析大型数据集的能力。在执行代码之前，用户需要批准该代码。
使用RAG框架开发Sadhguru AI应用程序 创建周期：203 天开发语言：Python协议类型：Apache License 2.0Star数量：6827 个Fork数量：1195 次关注人数：6827 人贡献人数：74 人Open Issues数量：147 个Github地址：https://github.com/embedchain/embedchain.git项目首页: https://docs.embedchain.ai 开源的RAG框架被用于开发最新的Sadhguru AI应用程序，使用Embedchain。
vits2骨干网络与多语言bert项目 创建周期：164 天开发语言：Python协议类型：GNU Affero General Public License v3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5f583ffbb4bc7a9341a4259bbd33feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec5db2ca35e52824d73cb96d39b38b0/" rel="bookmark">
			宇宙最强破译器！！！HASHCAT（哈斯猫）--入门深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hashcat 是一款密码爆破神器，信息安全必备工具之一，特此写篇文章记录总结之，以备不时之需，同时也可能帮助到看到本本文的网友。
简介 Hashcat 是世界上最快的密码破解程序，是一个支持多平台、多算法的开源的分布式工具。
官方：hashcat - advanced password recovery
Github：GitHub - hashcat/hashcat: World's fastest and most advanced password recovery utility
安装 macOS BASH
# 安装hashcat brew install hashcat # 查看版本 hashcat --version Linux Kali Linux 内置 Hashcat，在 Deepin Linux 和 Ubuntu Linux 下可以直接使用 APT 来安装:
BASH
apt update &amp;&amp; apt install hashcat # 查看版本 hashcat --version 也可以手动解压运行二进制文件 Releases · hashcat/hashcat · GitHub 下载最新版压缩包：
BASH
# 解压 tar zxvf hashcat-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ec5db2ca35e52824d73cb96d39b38b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca79f1882f438db6ed56877261b605d/" rel="bookmark">
			【AI】AI和点云（2/2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
五、点云的压缩
六、点云的体素化序列
七、点云增强
八、深度学习和点云
（接上回）
【AI】AI和点云（1/2）-CSDN博客
五、点云的压缩 点云压缩是点云处理中的一项重要技术，主要用于减少点云数据的存储空间和传输带宽需求，同时尽可能保留点云数据的结构和特征信息。
点云压缩可以分为三个主要步骤：数据预处理、数据压缩和数据编码。
数据预处理包括数据清洗、坐标转换、数据分块等操作，目的是去除噪声、统一坐标系、减小数据规模，以便于后续的压缩处理。
数据压缩是压缩技术的核心，主要采用空间预测、变换编码、概率模型等方法，通过去除空间冗余、量化冗余和信息冗余等方式，实现数据压缩。
数据编码则是将压缩后的数据转换为可存储或传输的格式，常用编码方式包括Huffman编码、游程编码、算术编码等。
目前，点云压缩标准主要包括ISO/IEC 21090国际标准、IEEE 1857.4标准等，其中最为广泛采用的是PCL（Point Cloud Library）中提出的基于八叉树结构的PVR（Point-Based Visualization Representation）格式，以及基于k-d树和四叉树的LAS格式等。这些格式都具有较高的压缩比和压缩效率，同时保留了点云数据的结构和特征信息，方便后续处理和分析。
六、点云的体素化序列 体素化点云序列是指利用体素来近似表示场景或物体的空间结构和几何形状的过程，以及生成的点云数据。点云数据是杂乱、无组织结构的，但是通过体素化处理后，在体素空间内存在三种拓扑结构：6邻接、18邻接以及26邻接。其中6邻接的两个体素具有6个公共面，18邻接的体素具有12条公共边和6个公共面，26邻接体素在此基础上还具有8个公共点。
体素化点云序列的存储空间大小取决于多个因素，包括点云密度、点云数量、体素分辨率等。一般来说，点云密度越高、点云数量越多、体素分辨率越高，所需的存储空间就越大。
此外，体素化点云序列的存储空间大小还与点云数据的表示方式和压缩技术等因素有关。如果采用简单的表示方式或低效的压缩技术，存储空间需求可能会增加。因此，在处理点云数据时，需要根据实际情况选择合适的表示方式和压缩技术，以减小存储空间需求并提高处理效率。
具体而言，典型的体素化点云序列(30秒，每秒60帧，10位深度和每帧 500.000 个点)的几何信息在没有任何压缩的情况下花费大约 3.14GB 的存储空间。如果考虑属性信息，比如8位深度的颜色信息，数据量将达到 5.66GB 左右。
七、点云增强 点云增强是一种技术，旨在提高点云数据的精度、质量和可用性。它通过应用各种算法和技术来处理点云数据，以减少噪声、改进分辨率、增强特征等。
点云增强包括多种方法，如滤波、平滑、重采样、特征提取等。这些方法可以帮助减少点云数据中的噪声和异常值，提高数据的平滑度和精度。同时，它们还可以突出点云数据中的重要特征，提供更多的信息和细节，以便于后续的分析和处理。
例如，通过对点云数据进行平滑处理，可以减少数据中的噪声和起伏，提高数据的连续性和一致性。通过重采样技术，可以将点云数据转换为更高分辨率的表示，以便于细节分析和模型重建。此外，特征提取技术可以帮助识别点云数据中的边缘、角点等重要特征，为形状识别、分类和匹配等应用提供支持。
总之，点云增强是一种重要的技术，可以帮助提高点云数据的精度和质量，提供更多的细节和信息，以便于后续的分析和处理。在实际应用中，可以根据具体需求选择合适的方法和技术进行点云增强处理。
八、深度学习和点云 深度学习（DL，Deep Learning）是机器学习（ML，Machine Learning）领域中一个新的研究方向，被引入机器学习使其更接近于最初的目标——人工智能（AI，Artificial Intelligence）。深度学习是学习样本数据的内在规律和表示层次，这些学习过程中获得的信息对诸如文字、图像和声音等数据的解释有很大的帮助。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。
点云是一个数据集，数据集中的每个点代表一组X、Y、Z几何坐标和一个强度值，这个强度值根据物体表面反射率记录返回信号的强度。当这些点组合在一起时，就会形成一个点云，即空间中代表3D形状或对象的数据点集合。点云也可以自动上色，以实现更真实的可视化。
深度学习在点云的应用主要表现在处理和分析点云数据上。例如，深度学习可以通过卷积神经网络将点云数据编码为隐藏表示，再量化隐藏特征，基于学习熵模型和熵编码将上下文输入的情况下每个符号出现的概率压缩并产生比特流，因而需要训练大量的点云数据样本以获得编码器端和解码器端非线性变换。基于深度学习的点云压缩方法可以更好地适应局部结构复杂性，因此具有作为未来基准编码工具的潜力。
此外，深度学习还可以用于点云的分类、识别和重建等任务。例如，利用深度学习的图像识别技术，可以将点云数据中的物体进行分类和识别，从而实现自动化监控、智能识别等功能。同时，深度学习也可以用于点云的表面重建任务，通过深度学习的表面重建算法，可以将点云数据转换为三维模型，为虚拟现实、游戏开发等领域提供支持。
总之，深度学习和点云之间的关系主要体现在深度学习在处理和分析点云数据上的应用。通过深度学习的方法和技术，可以对点云数据进行压缩、分类、识别和重建等任务，从而为相关领域提供更高效、准确和智能化的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edcff9091e46f1bd0353b0445ed66b1e/" rel="bookmark">
			【Linux Shell】12. 文件包含
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 和其他语言一样，Shell 也可以包含外部脚本，这样可以很方便的封装一些公用的代码作为一个独立的文件。可以理解为在第2个文件中包含第1个文件，执行第1个文件的代码。 被包含的文件 不需要可执行权限 。Shell 文件包含的语法格式如下： . filename # 注意点号(.)和文件名中间有一空格 或 source filename 实例1：:创建两个 shell 脚本文件。
test1.sh 代码如下： #!/bin/bash value="You are great" test2.sh 代码如下：
#!/bin/bash #使用 . 号来引用test1.sh 文件 . ./test1.sh # 或者使用以下包含文件代码 # source ./test1.sh echo "value is $value" 接下来，为 test2.sh 添加可执行权限并执行：
chmod +x test2.sh ./test2.sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c48e24a755a0c9ff297d780192a074/" rel="bookmark">
			【Linux Shell】11. 输入/输出 重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【 1. 重定向简介 】【 2. 输出重定向 】【 3. 输入重定向 】【 4. Here Document 】【 5. /dev/null 文件 】 【 1. 重定向简介 】 大多数 UNIX 系统命令从终端接受输入并将所产生的输出发送回​​到原来输入的终端。一个命令通常从标准输入的地方读取输入，默认情况下，这恰好是你的终端，同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。重定向命令列表如下： 命令作用command &gt; file默认情况下，将 stdout输出 重定向到 file。command &lt; file默认情况下，将 stdin输入 重定向到 file。command &gt;&gt; file将输出以追加的方式重定向到 file。n &gt; file将文件描述符为 n 的文件重定向到 file。n &gt;&gt; file将文件描述符为 n 的文件以追加的方式重定向到 file。n &gt;&amp; m将输出文件 m 和 n 合并。n &lt;&amp; m将输入文件 m 和 n 合并。&lt;&lt; tag将开始标记 tag 和结束标记 tag 之间的内容作为输入。 文件描述符 为 0 通常是标准输入（STDIN），为1 是标准输出（STDOUT），为2 是标准错误输出（STDERR）。一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，程序默认从stdin读取数据。标准输出文件(stdout)：stdout 的文件描述符为1，程序默认向stdout输出数据。标准错误文件(stderr)：stderr的文件描述符为2，程序会向stderr流中写入错误信息。 作用语法stderr 重定向到 filecommand 2&gt;file 这里的 2 和 &gt; 之间不可以有空格，2&gt; 是一体的时候才表示错误输出。stderr 追加到 file 文件末尾bashcommand 2&gt;&gt;file将 stdout 和 stderr 合并后重定向到 filebashcommand &gt; file 2&gt;&amp;1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c48e24a755a0c9ff297d780192a074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24050447de8ba0f7923ccca0038e102d/" rel="bookmark">
			增加索引 &#43; 异步 &#43; 不落地后，从 12h 优化到 15 min
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、一般我会这样做：二、谁写的？赶紧加班优化，会追责吗？优化1：数据库中添加对应的索引，提高查询速度优化2：采用 异步 + 多线程 的方式进行导出优化3：不解密 + 图片不落地，直接通过FTP传给第三方4、异步线程池工具类@Async的作用就是异步处理任务。默认线程池的默认配置如下：也可以通过yml重新配置： 三、告别劣质代码，优化从何入手？1、业务优化2、代码优化 四、数据库优化五、复用优化1、连接池2、长连接3、缓存4、缓冲 六、并行优化1、异步编程2、异步编程的特点3、并行编程4、并行编程的特点5、并行编程如何实现？6、代码示例7、Java 8 parallel（1）parallel()是什么（2）举一个简单的demo（3）parallel()的优缺点（4）何时使用parallel()？ 七、算法优化1、循环和递归2、内存管理3、字符串4、IO操作5、数据结构的选择 大家好，我是哪吒。
在开发中，我们经常会遇到这样的需求，将数据库中的图片导出到本地，再传给别人。
一、一般我会这样做： 通过接口或者定时任务的形式读取Oracle或者MySQL数据库通过FileOutputStream将Base64解密后的byte[]存储到本地遍历本地文件夹，将图片通过FTP上传到第三方服务器 现场炸锅了！
实际的数据量非常大，据统计差不多有400G的图片需要导出。
现场人员的反馈是，已经跑了12个小时了，还在继续，不知道啥时候能导完。
停下来呢？之前的白导了，不停呢？不知道要等到啥时候才能导完。
这不行啊，速度太慢了，一个简单的任务，不能被这东西耗死吧？
@Value("${months}") private String months; @Value("${imgDir}") private String imgDir; @Resource private UserDao userDao; @Override public void getUserInfoImg() { try { // 获取需要导出的月表 String[] monthArr = months.split(","); for (int i = 0; i &lt; monthArr.length; i++) { // 获取月表中的图片 Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); String tableName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24050447de8ba0f7923ccca0038e102d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8da02b341702c2c3e5e8c87956a5d9a/" rel="bookmark">
			python 怎么检查镜像源，并修改镜像源 https://pypi.tuna.tsinghua.edu.cn/simple
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 Python 中，更改镜像源以使用例如清华大学的 PyPI 镜像，通常涉及修改 pip 的配置。这可以通过两种主要方式来实现：
方法 1: 修改 pip 配置文件 定位 pip 配置文件:
pip 配置文件通常位于以下位置之一： 在 Unix 和 macOS 上：~/.pip/pip.conf在 Windows 上：%APPDATA%\pip\pip.ini 如果文件不存在，您可能需要手动创建它。 编辑配置文件:
打开配置文件并添加或修改以下内容：
[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 保存并关闭文件:
保存更改并关闭编辑器。 方法 2: 使用环境变量 设置环境变量: 您可以临时设置 PIP_INDEX_URL 环境变量来指定镜像源。
在 Unix 和 macOS 上使用命令行：
export PIP_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simple 在 Windows 上使用命令提示符：
set PIP_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simple 这种方式只在当前的终端会话中有效。
验证更改 要验证更改是否成功，您可以运行 pip 命令并检查输出中是否使用了新的镜像源。例如，使用 pip install 命令安装一个包，并观察输出中的下载 URL。 注意事项 更改 pip 的镜像源可能会影响安装包的速度和可用性。确保所选的镜像源是可信赖且更新及时的。如果您在 Docker 容器中进行此更改，请确保将修改后的配置文件复制到容器中，或者在构建 Docker 镜像时设置相应的环境变量。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2869bac56989d25d7b8e2ddfe905effc/" rel="bookmark">
			斯坦福大学Python机器学习教程，200&#43;PDF的精华总结和学习思路，完整版开放下载，附学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能，它是人工智能的核心，是是计算机具有智能的根本途径
该笔记分为十六个模块，循序渐进地深入了解机器学习，手打不易，希望各位读者一键三连
目录 一.机器学习的概念
1.1 引言
1.2 机器学习是什么？
1.3 监督学习
1.4 无监督学习
二.单变量线性回归
2.1 模型表示
2.2 代价函数
2.3 代价函数的直观理解1
2.4 代价函数的直观理解2
2.5 梯度下降
2.6 梯度下降的直观理解
2.7 梯度下降的线性回归
2.8 接下来的内容
三.线性代数回顾
3.1 矩阵和向量
3.2 加法和标量乘法
3.3 矩阵向量乘法
3.4 矩阵乘法
3.5 矩阵乘法的性质
3.6 逆，转置
四.多变量线性回归
4.1 多维特征
4.2 多变量梯度下降
4.3 梯度下降法实践—特征缩放
4.4 梯度下降法实践—学习率
4.5 特征和多项式回归
4.6 正规方程
4.7 正规方程及不可逆性
五.Octave 教程
5.1 基本操作
5.2 移动数据
5.3 计算数据
5.4 绘图数据
5.5 控制语句：for，while，if语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2869bac56989d25d7b8e2ddfe905effc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67f98e404a8761c4c2a38a9ffdce6951/" rel="bookmark">
			基于 InternLM 和 Langchain 搭建你的知识库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理论 1 大模型开发范式 LLM 的局限性
﻿﻿知识时效性受限：如何让LLM能够获取最新的知识专业能力有限：如何打造垂域大模型定制化成本高：如何打造个人专属的LLM应用 RAG（检索、增强生成）
核心思想：大模型外挂一个知识库（对于用户的提问会首先从知识库中匹配到提问对应回答的相关文档，然后将文档和提问一起交给大模型来生成回答，从而提高大模型的知识储备。）
﻿﻿低成本可实时更新﻿﻿受基座模型影响大﻿﻿单次回答知识有限 RAG其核心优势在于成本低且可实时更新。RAG范式的应用无需对大模型进行重新训练，不需要GPU算力。对于新的知识只需组织加入到外挂知识库中即可。加入新知识成本极低，可以实时更新，但其能力受基座模型影响大。基座模型的能力上限极大程度决定了RAG应用的能力天花板。
Finetune（延承传统自然语言处理算法的微调）
核心思想：在一个新的较小的训练集上进行轻量级的训练微调，从而提升模型在这个新数据集上的能力。
﻿﻿可个性化微调﻿﻿知识覆盖面广﻿﻿成本高昂﻿﻿无法实时更新 核心优势在于可个性化微调，且知识覆盖面广。应用将在个性化数据上微调
2 LangChain LangChain 框架是一个开源工具，通过为各种LLM 提供通用接口来简化应用程序的开发流程，帮助开发者自由构建 LLM应用。
LangChain 的核心组成模块：
﻿﻿链（Chains）：将组件组合实现端到端应用，通过一个对象封装实现一系列LLM 操作Eg.检索问答链，覆盖实现了RAG（检索增强生成）的全部流程 3 构建向量数据库 向量数据库是一种特殊的数据库，专门用于存储和管理向量数据。与传统的关系型数据库或文档数据库不同，向量数据库的主要目标是高效地处理和查询向量数据，以支持各种复杂的相似度搜索和机器学习任务。
向量数据库的设计和优化主要基于以下几个核心原则：
向量索引：向量数据库会使用特殊的索引结构来加速向量的相似度搜索。常见的索引结构包括k-d 树、LSH（局部敏感哈希）、球树等。这些索引结构可以在高维空间中快速定位与查询向量相似的数据点。
向量存储：向量数据库通常会采用高效的向量压缩和存储技术，以节省存储空间并提高查询性能。例如，可以使用量化（Quantization）方法将高维向量映射到低维度的离散码表示，从而减少存储需求。
高效查询：向量数据库会提供各种高效的查询算法和接口，以支持精确的相似度搜索和近邻查询。一些数据库还支持范围搜索、多条件组合查询等功能，以满足不同应用场景的需求。
扩展性和分布式计算：随着数据规模的增长，向量数据库需要具备良好的扩展性和分布式计算能力。一些向量数据库可以在多节点上进行数据分区和并行计算，以提高整体的查询性能和吞吐量。
支持多种数据类型：除了标准的向量数据，一些向量数据库还支持处理其他类型的数据，如文本、图像、音频等。这样可以在数据库内部进行特征提取和表示学习，从而更好地支持复杂的数据分析和机器学习任务。
向量数据库在许多领域都有广泛应用，包括相似图片搜索、推荐系统、聚类和分类任务、嵌入式表示学习等。它们可以提供高效的查询性能和灵活的数据处理能力，帮助用户快速发现和分析大规模的向量数据。
首先需要基于个人数据构建向量数据库。向量数据库的构建主要有加载原文档、文档分块和文档向量化三个部分。由于我们的个人数据可能有多种数据类型，例如TXT、markdown或者PDF等。我们首先需要确定原文档的类型，针对不同的类型的源文件选用不同的加载器。这些加载器的核心功能都是带格式的文本转化为无格式的字符串。我们后续构造向量数据库的操作中，输入都是无格式的纯文本。
然后由于大模型的输入上下文往往都是有限的，单个文档的长度往往会超过模型上下文的上限。我们需要对加载的文本进行切分。
最后为了使用向量数据库来支持语义检索。
4 搭建知识库助手 将 InternLM 接入 LangChain
﻿﻿LangChain 支持自定义LLM，可以直接接入到框架中﻿﻿我们只需将 InternLM 部署在本地，并封装一个自定义 LLM类，调用本地 InternLM 即可 构建检索问答链
﻿﻿LangChain 提供了检索问答链模版，可以自动实现知识检索、Prompt 嵌入、LLM问答的全部流程﻿﻿将基于InternLM的自定义LLM 和已构建的向量数据库接入到检索问答链的上游﻿﻿调用检索问答链，即可实现知识库助手的核心功能 RAG方案优化建议
﻿﻿基于RAG的问答系统性能核心受限于：﻿﻿检索精度 o Prompt性能
一些可能的优化点：
﻿﻿检索方面：
﻿﻿基于语义进行分割，保证每一个chunk的语义完整﻿﻿给每一个chunk生成概括性索引，检索时匹配索引 ﻿﻿Prompt方面：
﻿﻿迭代优化Prompt策略 实战 1 环境配置 1.1 InternLM 模型部署 在 InternStudio 平台中选择 A100(1/4) 的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67f98e404a8761c4c2a38a9ffdce6951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0107e13c65607506b535eb7109ad87/" rel="bookmark">
			大数据技术之 Kettle（PDI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kettle 第一章 Kettle概述1.1、ETL简介1.2、Kettle简介1.3、作业 和 转换 概念1.4、核心组件1.5、下载安装 第二章 控件使用2.1、初体验：csv 转换 excel 示例2.2、转换2.2.1、输入控件2.2.1.1、表输入 2.2.2、输出控件2.2.2.1、表输出2.2.2.2、更新&amp;插入/更新2.2.2.3、删除2.2.2.4、JSON 输出 2.2.3、转换控件2.2.3.1、Concat fields拼接字段2.2.3.2、Value mapper 值映射2.2.3.3、增加常量&amp;增加序列2.2.3.4、字段选择2.2.3.5、计算机2.2.3.6、字符串剪切&amp;替换&amp;操作2.2.3.7、排序记录&amp;去除重复记录2.2.3.8、其他常用构件 2.2.4、应用控件2.2.4.1、If field value is null 替换null值2.2.4.2、写日志 2.2.5、流程控件2.2.5.1、Switch/case2.2.5.2、过滤记录（if else）2.2.5.3、空操作2.2.5.4、中止 2.2.6、查询控件2.2.6.1、Database lookup 数据库查询2.2.6.2、流查询 2.2.7、连接控件2.2.7.1、合并记录2.2.7.2、Merge join记录集连接 2.2.8、统计控件2.2.8.1、分组 2.2.9、脚本控件2.2.9.1、执行SQL脚本 2.2.10、作业控件2.2.10.1、Set Variables 设置变量2.2.10.2、Get Variables 获取变量2.2.10.3、复制记录到结果 / 从结果获取记录 2.3、作业2.3.1、作业项2.3.2、作业跳2.3.3、控件 第三章 资源库3.1 数据库资源库 第四章 示例（持续更新）1、循环分页抽取数据（适用大数据一次抽不完，分页多次抽取）2、获取当前时间、昨天、前几天时间，并设置变量3、根据动态表名查询，插入到动态表里（一天一张表，表名按日期） 第一章 Kettle概述 1.1、ETL简介 Extract-Transform-Load（ETL）是一种常见的数据集成过程，用于从一个或多个数据源中提取数据，对数据进行转换和清洗，然后加载到目标数据存储中。
ETL 过程通常包括以下三个步骤：
提取（Extract）：从一个或多个数据源中提取数据。数据源可以是关系型数据库、文件、API、日志文件等。在提取阶段，需要确定要提取的数据范围和数据格式。
转换（Transform）：对提取的数据进行转换和清洗。这包括数据格式转换、数据清洗、数据合并、数据计算等操作。转换的目的是将数据转换为目标数据存储的结构和格式，并确保数据的准确性和一致性。
加载（Load）：将转换后的数据加载到目标数据存储中。目标数据存储可以是关系型数据库、数据仓库、数据湖等。在加载阶段，需要确定数据的存储位置和加载方式，例如全量加载或增量加载。
ETL 过程的目标是将数据从源系统中提取出来，并经过转换和清洗后加载到目标系统中，以支持数据分析、报表生成、业务决策等需求。ETL 过程通常由专门的ETL工具或编程语言来实现，例如Talend、Informatica、Apache Spark等。
ETL 过程在数据集成和数据处理中起着重要的作用，可以帮助组织将分散的数据整合起来，并提供高质量、一致性的数据供业务使用。
1.2、Kettle简介 Kettle（也称为Pentaho Data Integration (简称：PDI)）是一种开源的ETL（Extract-Transform-Load）工具，用于数据集成和数据处理。它是Pentaho Suite的一部分，由Pentaho公司开发和维护。
Kettle提供了一个可视化的图形化界面，使用户能够通过拖放和连接组件来设计和配置ETL流程。它支持多种数据源和目标，包括关系型数据库、文件、API、Hadoop等。Kettle提供了丰富的转换和清洗功能，可以对数据进行格式转换、数据过滤、数据合并、数据计算等操作。它还支持数据质量检查、错误处理和数据校验等功能。
Kettle具有以下特点和优势：
简单易用：Kettle提供了直观的图形化界面，使用户能够轻松地设计和配置ETL流程，无需编写复杂的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0107e13c65607506b535eb7109ad87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f3531a84f0eefad9fbaa78ac801e62/" rel="bookmark">
			docker compose 搭建ES集群的详细步骤，并去掉验证，使用http访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要使用 Docker Compose 搭建一个 Elasticsearch 集群，并配置为不使用验证，同时使用 HTTP 访问，你可以遵循以下步骤：
步骤 1: 安装 Docker 和 Docker Compose 确保你的系统上已安装 Docker 和 Docker Compose。如果尚未安装，请访问 Docker 的官方网站进行安装。
步骤 2: 创建 Docker Compose 配置文件 创建一个名为 docker-compose.yml 的文件，其中包含 Elasticsearch 集群的配置。以下是一个示例配置：
version: '3' services: es01: image: docker.elastic.co/elasticsearch/elasticsearch:8.11.3 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - xpack.security.enabled=false - "ES_JAVA_OPTS=-Xms512m -Xmx512m" volumes: - /home/sunyuhua/dockercom/es/es01/data:/usr/share/elasticsearch/data - /home/sunyuhua/dockercom/es/es01/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml ulimits: memlock: soft: -1 hard: -1 ports: - 9200:9200 networks: - esnet es02: image: docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f3531a84f0eefad9fbaa78ac801e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43192a7e1ed558362710b8c7d0defc6e/" rel="bookmark">
			redis.conf 默认出厂内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# Redis configuration file example. # # Note that in order to read the configuration file, Redis must be # started with the file path as first argument: # # ./redis-server /path/to/redis.conf # Note on units: when memory size is needed, it is possible to specify # it in the usual form of 1k 5GB 4M and so forth: # # 1k =&gt; 1000 bytes # 1kb =&gt; 1024 bytes # 1m =&gt; 1000000 bytes # 1mb =&gt; 1024*1024 bytes # 1g =&gt; 1000000000 bytes # 1gb =&gt; 1024*1024*1024 bytes # # units are case insensitive so 1GB 1Gb 1gB are all the same.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43192a7e1ed558362710b8c7d0defc6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74b11cdeb27a00c83836413c53bc128e/" rel="bookmark">
			[足式机器人]Part2 Dr. CAN学习笔记 - Ch03 傅里叶级数与变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文参考：
B站：DR_CAN
Dr. CAN学习笔记-Ch03 傅里叶级数与变换 1. 三角函数的正交性2. 周期为 2 π 2\pi 2π的函数展开为傅里叶级数3. 周期为 2 L 2L 2L的函数展开4. 傅里叶级数的复数形式5. 从傅里叶级数推导傅里叶变换FT6. 总结 1. 三角函数的正交性 三角函数系 ： 集合 { sin ⁡ n x , cos ⁡ n x } n = 0 , 1 , 2 , ⋯ \left\{ \sin nx,\cos nx \right\} n=0,1,2,\cdots {sinnx,cosnx}n=0,1,2,⋯
正交：
∫ − π π sin ⁡ n x sin ⁡ m x d x = 0 , n ≠ m ∫ − π π sin ⁡ n x cos ⁡ m x d x = 0 , n ≠ m ∫ − π π cos ⁡ n x sin ⁡ m x d x = 0 , n ≠ m \int_{-\pi}^{\pi}{\sin nx\sin mx}\mathrm{d}x=0,n\ne m \\ \int_{-\pi}^{\pi}{\sin nx\cos mx}\mathrm{d}x=0,n\ne m \\ \int_{-\pi}^{\pi}{\cos nx\sin mx}\mathrm{d}x=0,n\ne m ∫−ππ​sinnxsinmxdx=0,n=m∫−ππ​sinnxcosmxdx=0,n=m∫−ππ​cosnxsinmxdx=0,n=m
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74b11cdeb27a00c83836413c53bc128e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d501fe49fd3f8c76cd4950bdc3752ac3/" rel="bookmark">
			【docker】centos7安装harbor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 零、前提一、下载离线包二、安装三、访问四、开机自启 零、前提 1.前提是已经安装了docker和docker-compose 一、下载离线包 1. csdn资源：harbor-offline-installer-v2.10.0.tgz 2. 百度云盘（提取码：ap3t）：harbor-offline-installer-v2.10.0.tgz 3. github官方地址：harbor-offline-installer-v2.10.0.tgz 4. github下载速度太慢，建议翻墙 二、安装 1. 创建目录/opt/harbor # 创建目录 sudo mkdir /opt/harbor 2. 将离线包上传到目录/opt/harbor
3. 在该目录下解压离线包
sudo tar xf harbor-offline-installer-v2.10.0.tgz 4. 复制一个harbor.yml sudo scp -r harbor.yml.tmpl harbor.yml 5. 编辑文件harbor.yml sudo vim harbor.yml 6. 修改内容 # The IP address or hostname to access admin UI and registry service. # ip地址或主机名去访问管理界面和注册服务 # DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d501fe49fd3f8c76cd4950bdc3752ac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a15222ad67d833154e3e8d291720640/" rel="bookmark">
			什么是Modbus协议？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus协议是一种在工业自动化领域广泛应用的通信协议，它允许不同设备之间进行可靠的数据交换和控制。该协议最初由Modicon公司于1979年创建，旨在提供一种简单而有效的方法，使PLC（可编程逻辑控制器）和其他自动化设备能够相互通信。
一，设计架构和通信模式 Modbus协议采用主从架构，其中一个设备充当主站（Master），而其他设备则充当从站（Slave）。主站是负责发起通信和提出请求的设备，而从站是响应请求并执行相应操作的设备。主站可以与多个从站通信，通过设备地址来唯一标识每个从站。
通信主要通过请求--响应的模式进行。主站向从站发送请求，请求中包含了功能码，指示从站应该执行的具体操作。从站收到请求后，执行相应操作并将结果返回给主站。这种模式适用于读取和写入寄存器、线圈状态等不同类型的数据。
二，Modbus RTU 和 Modbus ASCII Modbus RTU和Modbus ASCII是两种常见的物理层和数据帧格式，用于串行通信。它们的帧结构有一些差异，但基本概念相似。
Modbus RTU：
使用二进制编码进行数据传输。
帧起始于一个静默线路的时间，设备地址和功能码后是数据字段和CRC校验码。
CRC校验用于验证数据的完整性。
Modbus ASCII：
使用ASCII字符编码进行数据传输。
帧起始于一个冒号字符（":"），设备地址和功能码后是数据字段和LRC校验码。
LRC校验用于验证数据的完整性。
三，Modbus TCP Modbus TCP是基于TCP/IP的变种，用于在以太网上进行通信。与串行通信不同，Modbus TCP帧不包含物理层帧结构，而是通过TCP连接传输。
Modbus TCP：
采用标准的TCP/IP协议进行通信。
帧包括事务标识、协议标识、长度字段、设备地址、功能码和数据字段。
数据字段的长度和内容取决于执行的具体操作。
不需要像RTU和ASCII那样的物理层帧结构。
四，寄存器和功能码 Modbus协议定义了多种类型的寄存器，用于存储和传输数据。其中包括输入寄存器（只读）、保持寄存器（读写）、线圈（开关状态）等。功能码指定了具体的操作类型，如读取寄存器、写入寄存器、读取线圈状态等。
五，错误处理和安全性 Modbus协议提供了基本的错误检测和处理机制，例如在Modbus RTU中使用CRC校验来验证数据完整性。然而，它相对简单，没有内建的加密和安全特性。在实际应用中，如果安全性是关键问题，通常需要在网络层面或应用层面采取额外的安全措施。
六，应用领域 Modbus协议在工业自动化中应用广泛，用于PLC、传感器、执行器、仪表等设备之间的通信。其开放性使得不同厂商的设备能够互联，实现设备间的集成与协作。Modbus协议的简单性和可靠性使其成为许多自动化系统的首选通信协议。
==========
往期回顾：
蓝桥杯付费视频更新进度通知
GD32F1硬件开发指南之复位电路
STM32 SysTick的总结
解决printf无法打印输出的问题
SHT3x-DIS驱动及应用详解
==========
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f83953eab72d4dac854d2fa9ef761e/" rel="bookmark">
			通过eXtplorer&#43;cpolar，搭建个人云存储并实现访问内网服务器数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. eXtplorer网站搭建2.1 eXtplorer下载和安装2.2 eXtplorer网页测试2.3 cpolar的安装和注册 3.本地网页发布3.1.Cpolar云端设置3.2.Cpolar本地设置 4.公网访问测试5.结语 1. 前言 在数字时代，互联网传输文件已成为我们日常生活和工作的核心部分。从观看在线视频到协同办公，所有这些都依赖于有效且安全的文件传输。尽管云存储在数据存储和传输方面起着关键作用，但最近一些公共云服务的安全事故引发了对其可靠性的担忧。
在这篇文章中，将展示如何使用Cpolar内网穿透和eXtplorer搭建一个安全、便捷的私人云存储服务器。这不仅可以提高数据安全性，还能让您随时随地访问自己的文件，无论是个人照片、重要文档还是其他媒体文件。接下来，让我们一起探索如何轻松实现这一目标，打造属于自己的私人云空间。
2. eXtplorer网站搭建 eXtplorer是一款基于php应用的文件管理器，通过web页面进行操作，操作方式与本地电脑上的资源管理器很像，其主要作用是在本地电脑与服务器之间传送文件，并且能和本地电脑的资源管理器一样，对文件和目录进行编辑、复制、移动和删除等操作，甚至还能修改文件的权限属性。
与此同时，eXtplorer的安装非常简单，有效降低了我们自己搭建文件服务器的难度。现在，就让我们开始吧。
2.1 eXtplorer下载和安装 首先，我们需要在本地电脑上部署一个eXtplorer。我们可以在eXtplorer的官网页面，轻松找到eXtplorer网页程序的下载位置。
下载完成后，我们将eXtplorer的压缩包解压备用。由于eXtplorer是网页程序，因此我们需要将其部署到本地电脑的web环境中。在这里，笔者使用的是phpstudy（小皮面板）来构建网页环境。因此将eXtplorer的网页安装文件，粘贴到phpstudy的www文件夹下。
接着我们打开phpstudy（小皮面板），在“网站”页面，点击左上的“创建网站”按钮，对打算建立的eXtplorer网页进行设置。设置的内容并不复杂，主要包括
1. 域名 – 这里的域名是指本地电脑访问eXtplorer网页时的域名；
2. 端口 – 即eXtplorer网页的输出端口；
3. 根目录 – 也就是eXtplorer网页程序存放在本地电脑的位置
4. 创建环境 – 即使用哪些支持程序，如FTP传输、SQL数据库等
5. PHP版本 – 也就是使用哪个版本的PHP运行eXtplorer网页（这里需要注意，eXtplorer必须使用低版本的php程序，笔者使用了php5.4版本，否则网页会报错）
完成以上内容的设置后，就可以点击页面下方的确认按钮，创建一个eXtplorer网页的运行环境。接着我们点击该网页条目右侧的管理按钮，点选打开网页，测试是否能正常访问eXtplorer网页。
需要注意的是，eXtplorer必须使用低版本的php程序，笔者使用了php5.4版本，同时要在“php扩展”选项中，勾选“tcp”功能。否则两者都会导致eXtplorer运行报错。
2.2 eXtplorer网页测试 创建好eXtplorer网页后，我们就可以从phpstudy中打开网页（也可以在浏览器地址栏中，输入之前设置好的域名：端口号访问）。只要网页设置正确，我们就能打开eXtplorer的登录页面。
只要输入默认的登录名和密码（登录名“admin”，密码“admin”），就能进入eXtplorer的主界面。不过默认登录名和密码并不安全，因此登录eXtplorer后，网页会提示我们立即修改登录名和密码。
2.3 cpolar的安装和注册 完成eXtplorer测试并能正确登录后，我们就可以转入cpolar的安装。与eXtplorer一样，cpolar的安装注册同样简单易行，甚至还要更简单。我们可以直接在cpolar的官网页面（www.cpolar.com）找到“下载”按钮。
笔者使用的是Windows操作系统，因此选择Windows版本进行下载。
Cpolar下载完成后，解压下载好的压缩文件，双击.msi文件，即可自动执行安装程序。接着只要一路“Next”就能完成安装。
由于cpolar会为每个用户创建独立的数据隧道，并辅以用户密码和token码保证数据安全，因此我们在使用cpolar之前，需要进行用户注册。注册过程非常简单，只要在cpolar主页右上角点击“用户注册”，在注册页面填入必要信息，就能完成注册。
3.本地网页发布 到这里，我们完成了本地eXtplorer网页的搭建，并安装了cpolar内网穿透程序，接下来我们就可以使用cpolar，创建一个能够连接本地测试页面的公共互联网地址，让我们能在公共互联网下访问到本电脑的eXtplorer网页。
3.1.Cpolar云端设置 由于私人云盘服务器有可能随时随地需要访问，但cpolar免费版的数据隧道会每24小时重置一次。为避免每天重连设置的麻烦，我们可以选择升级cpolar至vip版，获得能长期稳定存在的内网穿透数据隧道。
接下来，我们继续进行穿透内网工作，要达到内网穿透的目的，需要先登录cpolar的官网，并在用户主页面左侧找到“预留”按钮，并点击进入cpolar的数据隧道预留页面。
Cpolar会根据我们在cpolar云端设置的信息，生成一个公共互联网地址（可看做数据隧道的入口），由于此时这个地址没有连接本地的软件输出端口，因此也可以看做是空白的数据隧道。
在预留页面，可以看到很多种可保留的数据隧道，这里我们选择“保留二级子域名”栏位（eXtplorer是以web网页形式运行）。
在“保留二级子域名”栏位，要进行几项信息的简单设置，即：
“地区”（服务器所在区域，就近选择即可）
“二级域名”（会最终出现在生成的公共互联网地址中，作为网络地址的标识之一）
“描述”（可以看做这条数据隧道的描述，能够与其他隧道区分开即可）。
完成这几项设置后，就可以点击右侧的“保留”按钮，将这条数据隧道保留下来。
当然，如果这条数据隧道不打算再使用，还可以点击右侧的“x”将其轻松删除，节约宝贵的隧道名额。
3.2.Cpolar本地设置 完成cpolar云端的设置，并保留了空白数据隧道后，我们回到本地的cpolar客户端，将云端生成的空白数据隧道与本地的测试页面连接起来，让我们能在公共互联网上访问到本地的测试页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3f83953eab72d4dac854d2fa9ef761e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07df4aac2fe0eb1ec3729b1a4eda4b0c/" rel="bookmark">
			详解学习python的十一个步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学好python最重要的是坚持，只有坚持可以是王道，下面介绍了一些对于python初学者真正坚持学习的新概念：
技巧1：每天的代码
当你学习一门新语言时，一致性是非常重要的。我们建议每天都致力于编写代码。这很难相信，但是肌肉记忆在编程中起着很大的作用。每天进行编码将有助于发展肌肉记忆。虽然乍看起来可能令人畏惧，但还是要考虑每天从25分钟做起，然后从那里做起。
用Python指南查看第一个步骤，了解安装程序的信息以及启动的练习。
技巧2：写出来
当你作为一个新的程序员在你的旅程中进步时，你可能会怀疑你是否应该做笔记。是的，你应该！事实上，研究表明，用手记笔记最有利于长期保持。这对于那些致力于成为全职开发者的人来说是特别有益的，因为许多采访将涉及在白板上编写代码。
一旦开始处理小项目和程序，手工编写也可以帮助您在移动到计算机之前规划代码。如果你写出你需要的函数和类，以及它们将如何交互，你可以节省很多时间。
提示3：去互动！
无论您是第一次学习基本的Python数据结构（字符串、列表、字典等），还是在调试应用程序，交互Python shell都将是您最好的学习工具之一。我们也在这个网站上使用了很多！
要使用交互式Python外壳（有时也称为Python RePL），首先要确保Python安装在您的计算机上。我们有一个循序渐进的教程来帮助你做到这一点。若要激活交互式Python外壳，只需打开终端并根据您的安装运行Python或Python 3。你可以在这里找到更具体的方向。
既然你知道如何启动shell，这里有几个例子，说明你在学习时如何使用shell。
了解使用元素（）可以在元素上执行什么操作：
python：
&gt;&gt;&gt; my_string = 'I am a string'
&gt;&gt;&gt; dir(my_string)
['__add__', ..., 'upper', 'zfill'] # Truncated for readability
从DIR（）返回的元素是可以应用于元素的所有方法（即动作）。例如：
python： &gt;&gt;&gt; my_string.upper() &gt;&gt;&gt; 'I AM A STRING' 注意，我们调用了上（）方法。你能看到它做什么吗？它使字符串中的所有字母大写！在本教程的“操纵字符串”下，了解这些内置方法的更多内容。
学习元素的类型：
python：
&gt;&gt;&gt; type(my_string)
&gt;&gt;&gt; str
使用内置的帮助系统获取完整的文档：
python
&gt;&gt;&gt; help(str)
导入图片文件夹并与之互动：
python
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dir(datetime)
['__add__', ..., 'weekday', 'year'] # Truncated for readability
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07df4aac2fe0eb1ec3729b1a4eda4b0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e9dd7876f68842176c58985514a52b/" rel="bookmark">
			Spring Cloud配置中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务意味着要将单体应用中的业务拆分成一个个子服务 , 每个服务的粒度相对较小 ,因此系统中会出现大量的服务。 由于每个服务都需要必要的配置信息才能运行 , 所以一套集中式的 , 动态的配置管理设施是必不可少的。 Spring Cloud 提供了 ConfigServer 来解决这个问题 . Spring Cloud Config 为微服务架构中的微服务提供集中化的外部配置支持 ,配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。 SpringCloud Config 分为服务端和客户端两部分。 服务端也称为分布式配置中心 , 他是一个独立的微服务应用 ,用来连接配置服务器并为客户端提供获取配置信息 , 加密 / 解密信息等访问接口。 客户端则是通过制定的配置中心来管理应用资源 , 以及与业务相关的配置内容 ,并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用 git 来存储配置信息 , 这样就有助于对环境配置进行版本管理 ,并且可以通过 git 客户端工具来方便的管理和访问配置内容。 一个使用微服务架构的应用系统可能会包括成百上千个微服务,配置各部相同,需求各不相同： 不同环境不同配置：例如数据源在不同的环境（开发 , 测试 , 生产）是不同的 , 可以通过配置中心 运行期间可以动态调整。例如根据各个微服务的负载状况 , 动态调整数据源连接池大小或者熔断阀 值 , 并且调整时不停止微服务（配置修改后可以自动更新） 导入nacos-config依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; Spring Cloud Alibaba Nacos Config Nacos 提供用于存储配置和其他元数据的 key/value 存储 ,为分布式系统中的外部化配置提供服务器端和客户端支持。 使用 Spring Cloud Alibaba Nacos Config, 您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置。 Spring Cloud Alibaba Nacos Config 是 Config Server 和 Client 的替代方案 ,客户端和服务器上的概念与Spring Environment 和 PropertySource有着一致的抽象 在特殊的 bootstrap 阶段 , 配置被加载到 Spring 环境中。当应用程序通过部署管道从开发到测试再到生产时 , 您可以管理这些环境之间的配置 , 并确保应用程序具有迁移时需要运行的所有内容。 bootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35e9dd7876f68842176c58985514a52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1ba116d3cb816c9a3d7e42c03d1dfe/" rel="bookmark">
			软件测试|SQL中的UNION和UNION ALL详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在SQL（结构化查询语言）中，UNION和UNION ALL是用于合并查询结果集的两个关键字。它们在数据库查询中非常常用，但它们之间有一些重要的区别。在本文中，我们将深入探讨UNION和UNION ALL的含义、用法以及它们之间的区别。
UNION操作 UNION用于合并两个或多个查询的结果集，并返回一个唯一的结果集，即去重后的结果。它的语法如下：
SELECT column1, column2, ... FROM table1 UNION SELECT column1, column2, ... FROM table2; 注意事项：
每个 SELECT 语句都必须拥有相同数量的字段；不同 SELECT 语句的对应字段必须拥有相似的类型。 使用示例：
假设我们有两个表employees和contractors，它们分别包含员工和合同工的数据。现在我们想要获取所有员工和合同工的唯一记录。
SELECT employee_id, first_name, last_name FROM employees UNION SELECT contractor_id, first_name, last_name FROM contractors; 注：UNION操作默认会去除重复的记录，因此如果两个查询的结果有重复的记录，只会返回一条。
UNION ALL操作 UNION ALL也用于合并查询结果集，但不会去除重复的记录，它会返回所有符合条件的记录。它的语法如下：
SELECT column1, column2, ... FROM table1 UNION ALL SELECT column1, column2, ... FROM table2; 使用示例：
我们使用上述的employees和contractors表进行示例：
SELECT employee_id, first_name, last_name FROM employees UNION ALL SELECT contractor_id, first_name, last_name FROM contractors; 注： UNION ALL不会去重，如果两个查询的结果有重复的记录，它会全部返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1ba116d3cb816c9a3d7e42c03d1dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c91681bb7147d25952f04b9701c113/" rel="bookmark">
			JS输出为[object object]取值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：页面跳转传参 传参前数据能打印出来，传参后显示[object object]且无法取值
解决 传递 接收后端返回的json对象通常是一个字符串类型的object
所以
通过 JSON.stringify() 把 JavaScript 对象转换为字符串。
my.navigateTo({ url: `/pages/component/receive?clickItem=${JSON.stringify(e.currentTarget.dataset.clickItem)}` }); 接收 在从 web 服务器接收数据时，数据永远是字符串。
通过 JSON.parse() 解析数据，这些数据会成为 JavaScript 对象。
onLoad(e) { console.log(e); this.setData({ clickItem: JSON.parse(e.clickItem) }); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7110427ffd2695b452ab24ee17bf5f76/" rel="bookmark">
			【Linux进程】查看进程&amp;&amp;fork创建进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1. 查看进程
2. 通过系统调用创建进程-fork初识
总结
前言 你有没有想过在使用Linux操作系统时，后台运行的程序是如何管理的？在Linux中，进程是一个非常重要的概念。本文将介绍如何查看当前运行的进程，并且讨论如何使用fork创建新的进程。通过了解这些内容，你将更好地理解Linux系统中的进程管理。
1. 查看进程 在理解进程状态之前，我们要先学会查看进程，进程的信息可以通过 /proc 系统文件夹查看 ls /proc 可以看到有很多以数字命名的文件夹，这些数字其实就是进程的PID：
进行实验的代码：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include&lt;sys/types.h&gt; int main() { pid_t id = getpid(); pid_t fid = getppid(); while(1) { printf("Hello world! pid: %d ppid: %d\n",id,fid); sleep(1); } return 0; } 指令：
ls /proc/【PID】 -ld 进一步查看进程详细信息：
ls /proc/【PID】 -l 里边的文件都是进程的属性，这里有两个显眼的属性cwd和exe
exe：进程可执行程序在磁盘中对应的位置 cwd（current working directory）：进程的当前工作目录 进程在运行时，它的可执行程序会被加载到内存当中，在进程运行的情况下我们依然可以删除它的可执行程序。删除之后再次查看运行中进程属性就会发现exe属性被标红且高亮闪烁
在C语言中我们对文件进行操作：
fopen("file.txt" , " w"); 这里也解释了，在没有这个文件时为什么会默认在程序的当前目录下创建。因为那是进程的工作目录；我们也可以通过修改进程工作目录的方式，改变创建文件的默认路径。
我们可以调用chdir这个系统调用接口来改变进程的工作目录，以下时chdir的相关说明文档：
使用时直接指定新路径即可，成功返回0，失败返回-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7110427ffd2695b452ab24ee17bf5f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ea893df162d01a77d76500e5b0184c/" rel="bookmark">
			Java基础 : BlockingQueue浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言1. 简介2. 分类3. 关键方法 二、源码分析1. SynchronousQueue1.1 介绍1.2 使用场景举例 2. PriorityBlockingQueue2.1 入队2.2 出队 3. LinkedBlockingDeque3.1 入队3.2 出队 4. DelayQueue4.1 PriorityQueue4.2 关键方法 一、前言 本文仅仅是对 BlockingQueue 的种类和方法进行简单介绍，对于部分实现进行了简单的代码分析。
1. 简介 BlockingQueue 即阻塞队列，关于阻塞队列的介绍已经有很多文章，因此这里直接借用 Java阻塞队列 一文中的介绍。如下：
阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：
当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。当阻塞队列是满时，往队列里添加元素的操作将会被阻塞。 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程从列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增。 2. 分类 BlockingQueue 的类结构如下：
BlockingQueue 只是一个接口，Jdk 提供了多种实现类，如下：
实现类特性ArrayBlockingQueue由数组结构组成的有界阻塞队列LinkedBlockingQueue由链表结构组成的有界(但大小默认值为Integer.MAX_VALUE)阻塞队列SynchronousQueue不存储元素的阻塞队列，也即单个元素的队列PriorityBlockingQueue支持优先级排序的无界阻塞队列DelayQueue使用优先级队列实现的延迟无界阻塞队列LinkedTransferQueue由链表结构组成的无界阻塞队列LikedBlockingDeque由链表结构组成的双向阻塞队列 3. 关键方法 关键方法如下：
方法类型方法名释义入队操作add(e)入队成功返回 true，若队列已满则抛出异常入队操作offer(e)入队成功返回 true ，否则false入队操作put(e)队列满时入队则会一直阻塞线程，直至入队成功入队操作offer(e, time, unit)将指定元素插入此队列，如果队列已满，则等待指定的等待时间。出队操作remove()出队操作，返回出队元素，如果队列为空则抛出异常出队操作poll()出队操作，如果队列为空则返回 null，否则返回出队元素出队操作take()出队操作，如果队列为空则阻塞线程，直至出队成功出队操作poll(time, unit)检索并删除此队列的头部，如果有必要等待指定的等待时间以使元素可用。检查操作element()检索但不删除此队列的头部。此方法与peek的不同之处仅在于如果此队列为空，它将引发异常。检查操作peek()检索但不删除此队列的头部，如果此队列为空，则返回null 。 二、源码分析 BlockingQueue 的使用我们这里就不再赘述，这里来简单看看其中部分代码实现。我们调其中几个实现来简单看一下：
1. SynchronousQueue 1.1 介绍 SynchronousQueue 是不存储元素的阻塞队列，也即单个元素的队列。
简单来说 ：当我们调用 入队方法（put、add、 offer） 时并不会立刻返回，而是阻塞等待，直到有其他操作（一般是其他线程）调用了该队列的出队方法 (remove、poll、take) 后，入队方法才会返回结果。同理当我们调用出队方法时如果之前没有其他操作调用了入队方法则会挂起等待，直至其他操作调用入队方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65ea893df162d01a77d76500e5b0184c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5020ad35180091b766f6f4ffc4e5b5/" rel="bookmark">
			用webstorm学习Vue的时候提示未解析的变量或类型怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用webstorm学习Vue的时候，很多同学是不是对以下这种提示看着不舒服
这种提示因为webstorm在解析代码进行提示的时候会把html文件中css选择器进行缓存，如果你在同一个文件夹下面写很多个html，并且多个html中都有同样的&lt;div id="root"&gt;一模一样的，那么webstorm会认为这是同一个文件，在他寻找目标定义的时候，会去第一次缓存的文件中找，找不到就会提示这个错误。
其实很多同学刚开始都喜欢在一个工程里面，写一堆项目-。-！这基本就是导致这个问题的罪魁祸首了
解决办法：
1.你在不同的html文件中，一个叫&lt;div id="root"&gt;，另一个叫&lt;div id="root2"&gt;就解决了。实际开发中很少出现同名这种情况。
提示.如果是专门学习Vue的话，建议同学们一定要单独新建一个项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdc908c80436aa452ffb3326fe5bba95/" rel="bookmark">
			Arcgis像元统计数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 单幅影像统计多幅影像统计 单幅影像统计 现有一幅NDVI影像，如何知道影像中NDVI的分布情况呢？
先栅格转点，然后在属性表中查看汇总情况
还有一种方法就是在ENVI中打开，
-0.3-0.338占据了99%
多幅影像统计 现有多幅NDVI影像，如何知道这几个时间上，某个像元NDVI的平均值、最大最小值等统计情况呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbeb502d90ffa38bd616a4039c08ec8/" rel="bookmark">
			Python的for循环怎么不停止？Python无限循环的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在python的流程控制语句之中for循环是用来迭代可变序列和可以被按顺序迭代的数据结构的语法，它的作用是每次都会取出可迭代对象中的没取出来的元素。那么想要让for循环不停止实现无限循环的话可以用下面这个一个方法，往下看看吧。
一般来说如果for循环不停的话就会在内存空间里一直占用资源，这对程序和设备都会造成很大的运行效率影响，但是有时为了测试某个功能的运行速度和执行时间也会去让for循环进行无限循环。
for循环它不是对条件进行循环而是迭代，那么如果想要在一个for循环之中让他不停止实现无限循环的话可以让其去迭代一个列表。然后在每一次去迭代这个列表的时候都让这个列表的元素又加上1，这样每次迭代都能够有没有用过的元素可一取出来。这样就实现了无限循环，具体实例如下：
# 声明迭代的对象 lis = [1] # for循环在每一次迭代中都去向lis这个迭代对象中添加它本身的元素 for i in lis: lis.append(i) print(lis) 在上面的这个示例中迭代对象lis列表只有一个元素1，在每次循环时都将这个1又添加到列表中，这样就又有元素可以迭代了。
以上就是关于“Python的for循环怎么不停止？Python无限循环的方法”的全部内容了
关于Python技术储备
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
三、Python视频合集
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
四、实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、Python练习题
检查学习结果。
六、面试资料
我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
最后祝大家天天进步！！
上面这份完整版的Python全套学习资料已经上传至CSDN官方，朋友如果需要可以直接微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804003646c035a7627a37540c959b9b5/" rel="bookmark">
			十一、工具盒类(MyQQ)（Qt5 GUI系列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
一、设计需求
二、实现代码
三、代码解析
四、总结
一、设计需求 抽屉效果是软件界面设计中的一种常用形式，可以以一种动态直观的方式在有限大小的界面上扩展出更多的功能。本例要求实现类似 QQ 抽屉效果。
二、实现代码 #include "dialog.h" #include &lt;QApplication&gt; #include "drawer.h" int main(int argc, char *argv[]) { QApplication a(argc, argv); Drawer drawer; drawer.show(); return a.exec(); } #include &lt;QToolBox&gt; #include &lt;QToolButton&gt; class Drawer : public QToolBox { Q_OBJECT public: Drawer(QWidget *parent=0,Qt::WindowFlags f=0); private: QToolButton *toolBtn1_1; QToolButton *toolBtn1_2; QToolButton *toolBtn1_3; QToolButton *toolBtn1_4; QToolButton *toolBtn1_5; QToolButton *toolBtn2_1; QToolButton *toolBtn2_2; QToolButton *toolBtn3_1; QToolButton *toolBtn3_2; }; #include "drawer.h" #include &lt;QGroupBox&gt; #include &lt;QVBoxLayout&gt; Drawer::Drawer(QWidget *parent, Qt::WindowFlags f) :QToolBox(parent,f) { setWindowTitle(tr("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804003646c035a7627a37540c959b9b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3aa49815942aa716849582132b3105c/" rel="bookmark">
			Spring Cloud远程消费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导入依赖 其他依赖见Spring Cloud-CSDN博客
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; 2.集群+负载均衡 使用Feign(开启负载均衡)
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 步骤一 生产者提供接口 可以使用以下几个注解接收远程调用的参数值 @PathVariable @RequestParam @RequestBody @RestController @RequestMapping("/user") @Slf4j public class UserController { @RequestMapping("/{account}") public String getByPath(@PathVariable("account") String account) { log.info("account:{}",account); return "🍗"; } @RequestMapping("/param") public String getByParam(@RequestParam("account") String account,@RequestParam("password") String password) { log.info("account:{},password:{}",account,password); return "🍗"; } @RequestMapping("/pojo") public String getByPojo(@RequestBody UserDto dto) { //将dto中与User相关的属性拿出来给到User对象 User user=new User(); BeanUtils.copyProperties(dto,user); log.info("user:{}",user); return "🍗"; } } 只要参数是复杂对象，即使指定了是 GET 方法， feign 依然会以 POST方法进行发送请求，同时生产者必须支持 POST 请求并给参数添加 @RequestBody 注解 步骤二 消费者需要开启 Feign 功能 @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class ConsumerApplication { } 创建 Server, 并使用 Feign 表示其需要远程对接的服务名称 , 并使用 @RequestMapping 表示其映射的 路径 @FeignClient("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3aa49815942aa716849582132b3105c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d3073dbff8ef2ec2170261a39229cc/" rel="bookmark">
			C&#43;&#43;之优先队列（priority_queue）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		priority_queue 是 C++ 标准模板库（STL）中的一种容器适配器，它提供了一个基于优先级的队列。这意味着它存储的元素是按照一定的优先级进行排序的，每次访问队头元素都是当前队列中优先级最高的元素。
在 C++ 中，priority_queue 通常使用堆（heap）来实现，堆是一种特殊的二叉树结构，满足堆的性质。C++ 中的 priority_queue 默认使用大顶堆，也就是队头元素是最大的元素。你可以通过提供比较函数来使用小顶堆。
以下是一个简单的示例，演示了如何使用 priority_queue：
#include &lt;iostream&gt; #include &lt;queue&gt; int main() { // 创建一个大顶堆的 priority_queue std::priority_queue&lt;int&gt; maxHeap; // 插入元素 maxHeap.push(10); maxHeap.push(30); maxHeap.push(20); // 访问队头元素 std::cout &lt;&lt; "Top element: " &lt;&lt; maxHeap.top() &lt;&lt; std::endl; // 弹出队头元素 maxHeap.pop(); // 访问新的队头元素 std::cout &lt;&lt; "Top element after pop: " &lt;&lt; maxHeap.top() &lt;&lt; std::endl; return 0; } 在这个示例中，std::priority_queue 被创建为大顶堆，默认情况下，元素的比较使用 &lt; 操作符。你可以通过提供自定义的比较函数来创建小顶堆。
例如，如果要创建一个小顶堆，可以这样做：
#include &lt;iostream&gt; #include &lt;queue&gt; // 自定义比较函数，使得小的元素优先级高 struct Compare { bool operator()(int a, int b) { return a &gt; b; } }; int main() { // 创建一个小顶堆的 priority_queue std::priority_queue&lt;int, std::vector&lt;int&gt;, Compare&gt; minHeap; // 插入元素 minHeap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d3073dbff8ef2ec2170261a39229cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a51efcf2dfec7f73b53bf47eab7225b/" rel="bookmark">
			Qt在linux系统上使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路径表示
Windows操作系统可用"\"或"/"表示路径，Unix操作系统用"/"表示路径。综合，qt最好用“/”表示路径。
第三方静态库和动态库
lib文件：（依据编译器） MSVC编译器是生成.lib 文件。 mingw编译器生成.a 文件。linux平台无lib文件。
dll文件：(依据平台) windows平台是.dll 文件，unix平台是.so
对于windows的msvc系统，有.lib和.dll文件。配置LIBS+= 就是配置.lib文件。
对于windows的mingw系统，有.a和.dll文件。配置LIBS+= 就是配置.a文件。
对于linux系统，只有.so文件。配置LIBS+= 就是配置.so文件。
第三方配置LIBS目录做法
LIBS += somepath 这个可以多行写，也可以用“\”隔行
第一种办法：
可以用-L指定目录，-l指定库的名称（无需后缀，.lib，.a, .so都适用，这样就不用区分到底是哪种）
优点：windows和linux平台通用
如在windows msvc环境下，有bin目录下有log4qt.lib、log4qt.dll。
Pro配置文件写： LIBS += -L$$PWD/../bin -llog4qt
实际上就是配置log4qt.lib。
如在linux 环境下有bin目录下只有liblog4qt.so
Pro配置文件写： LIBS += -L$$PWD/../bin -llog4qt
实际上就是配置liblog4qt.so。
第二种办法：
直接通过绝对路径和相对路径指定库的完整path（需后缀，.lib，.a, .so都适用），相对路径用$$pwd前缀，路径不允许空格。
缺点是：在windows和linux平台不通用，各自平台需要单独配置。
如在windows msvc环境下，有bin目录下有log4qt.lib、log4qt.dll。
Pro配置文件写： LIBS += $$PWD/../bin/log4qt.lib
实际上就是配置log4qt.lib。
如在linux 环境下有bin目录下只有liblog4qt.so
Pro配置文件写： LIBS += $$PWD/../bin/liblog4qt.so
实际上就是配置liblog4qt.so。
Linux下QT生成的（.so）、（.so.1）、（.so.1.0）、（.so.1.0.0）之间的区别
.so 即 linux 下的共享库（Shared library）,或称动态库
QT在生成动态库时，会默认生成（.so）、（.so.1）、（.so.1.0）、（.so.1.0.0）四个文件。其中，（.so.1.0.0）为实际的动态库文件，（.so）、（.so.1）、（.so.1.0）均为软链接，都是指向（.so.1.0.0）的链接文件，为了版本控制。
只生成一个.so文件的办法：在pro文件加上 CONFIG += plugin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a51efcf2dfec7f73b53bf47eab7225b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a404104323f2397caec81c157f66cf/" rel="bookmark">
			vue中短时间内多次点击同一个按钮会向后端发送多个请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue中，我们可能会遇到以下问题：
我们有两种方法解决：
（1）可以通过设置一个标志位来防止用户在短时间内多次点击同一个按钮导致向后端发送多个请求。具体实现方式如下： 定义一个 isFetching变量来表示当前是否正在向后端发送请求。
在按钮点击事件中，首先检查 isFetching的值。如果为 true，说明当前正在发送请求，不做任何处理；如果为 false，则将 isFetching的值设为 true，然后执行后续的操作。
当后端请求完成后，无论是成功还是失败，都需要将 isFetching 的值设为 false，以便下一次请求可以正常进行。
以下是一个示例代码：
&lt;template&gt; &lt;div&gt; &lt;button @click="handleButtonClick" :disabled="isFetching"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { isFetching: false, }; }, methods: { handleButtonClick() { if (this.isFetching) { // 正在发送请求，不做处理 return; } // 设置isFetching为true this.isFetching = true; // 向后端发送请求 axios.post("/api/your-api-url").then((response) =&gt; { // 请求成功处理 }).catch((error) =&gt; { // 请求失败处理 }).finally(() =&gt; { // 请求结束后，设置isFetching为false this.isFetching = false; }); }, }, }; &lt;/script&gt; 上述代码中，我们首先定义了一个isFetching变量，并将其初始值设为false。在按钮点击事件中，我们首先检查isFetching的值，如果为true则不做处理，否则将其设为true，然后执行向后端发送请求的代码。当请求结束后，无论成功还是失败，都会将isFetching的值设为false。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a404104323f2397caec81c157f66cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e371134ef99e8880e98bacbac994b9/" rel="bookmark">
			linux下无法登陆github官网解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行 sudo vi /etc/hosts
修改文件内容：
# GitHub Start 140.82.113.3 github.com 140.82.114.20 gist.github.com 151.101.184.133 assets-cdn.github.com 151.101.184.133 raw.githubusercontent.com 151.101.184.133 gist.githubusercontent.com 151.101.184.133 cloud.githubusercontent.com 151.101.184.133 camo.githubusercontent.com 151.101.184.133 avatars0.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com 199.232.28.133 avatars1.githubusercontent.com 151.101.184.133 avatars1.githubusercontent.com 151.101.184.133 avatars2.githubusercontent.com 199.232.28.133 avatars2.githubusercontent.com 151.101.184.133 avatars3.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 151.101.184.133 avatars4.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 151.101.184.133 avatars5.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 151.101.184.133 avatars6.githubusercontent.com 199.232.68.133 avatars6.githubusercontent.com 151.101.184.133 avatars7.githubusercontent.com 199.232.68.133 avatars7.githubusercontent.com 151.101.184.133 avatars8.githubusercontent.com 199.232.68.133 avatars8.githubusercontent.com # GitHub End 按下 esc键, 然后输入 :wq
会出现如下错误 E45: ‘readonly’ option is set (add !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8e371134ef99e8880e98bacbac994b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e54e12f0b8e57a4b3ce8af92ce899b4/" rel="bookmark">
			win10查看网络连接详细信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.进入网络和共享中心方法一方法二 2.查看详细信息3.例子-根据需要可获取如下信息 1.进入网络和共享中心 方法一 我的电脑输入：控制面板\所有控制面板项\网络和共享中心
方法二 右键右下角网络图标
打开”状态“中“网络和internet设置”，点击“网络和共享中心"
2.查看详细信息 点击如下图红线处的网络连接
进入WLAN状态，点击“详细信息”
网络详细信息如下：
3.例子-根据需要可获取如下信息 物理机IP地址：192.168.95.67
物理机子网掩码：255.255.255.0
物理机默认网关：192.168.95.210
物理机DNS服务器：192.168.95.210
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55501e78e24bb7cc6c33c82bfc4d141/" rel="bookmark">
			学习css样式之【rem/vw兼容方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发移动端项目的时候，我们都会碰到一个隐性的问题：如何兼容样式？
虽然我已经习惯把H5demo项目直接copy过来，复用里面的css单位换算方案，但奈何最近钉钉更新，导致部分安卓机型第一次进入页面时样式错乱，人还是得明白px、rem、vw之间的区别，以及单位之间如何换算。
一、px px，也就是像素pixel，从设计图的角度来说属于基本单位。
前端在开发时都是直接使用UI提供的设计图数值来写样式，比如按钮高度等。但设计图是死的，用户手机机型是随机的，哪怕我按iPhone SE的375x667来开发，客户也不会都用SE。
这个时候就需要引入换算的概念：
不能按375px的宽度，但是可以先通过clientWidth拿到真实宽度，再用真实宽度和375的比值同比放大/缩小，不就行了？
二、rem rem，中文理解为相对单位，相对HTML根元素。
引入rem，将会根据根元素的font-size大小定义1rem，做到目标元素依赖根元素成比例保持大小关系。
举个例子：在375px宽度的图纸上，btn按钮的宽度是328px，也就是说btn的宽度应该占手机宽度的 328 ÷ 375 ≈ 0.8747份。这个比值可以适配其他机型的宽度，例如iPhone12是395px，btn的宽度相应就是395 × 0.8747 ≈ 345.49（单位：px）
rem的意义就是将这个运算过程通用成概念：
三、rem适配方案 3.1 main.js+config.less 首次加载时，计算1rem = ? px
/* 第一次加载设置font-size */ window.onresize = setHtmlFontSize function setHtmlFontSize () { const htmlWidth = document.documentElement.clientWidth || document.body.clientWidth const htmlDom = document.getElementsByTagName('html')[0] htmlDom.style.fontSize = htmlWidth / 10 + 'px' } 750px宽度的设计图同样按10份划分。
那么原先的px单位换算为新单位@px: 75rem。
往后开发就可以直接使用设计图里给的数值，/@px 将会自动换算为真实数值。例如图中的1.8133rem，也就是68px。
//750设计稿等js计算基础样式 分成10份 @px: 75rem; img { height: 136/@px; width: 136/@px; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55501e78e24bb7cc6c33c82bfc4d141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459dc1d32e3558d4f49f8ff20a9859fe/" rel="bookmark">
			【设计模式之美】 SOLID 原则之五：依赖反转原则：将代码执行流程交给框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 控制反转（IOC）二. 依赖注入（DI）三. 依赖注入框架（DI Framework）四. 依赖反转原则（DIP） 一. 控制反转（IOC） 通过一个例子来看一下，什么是控制反转。
public class UserServiceTest { public static boolean doTest() { // ... } public static void main(String[] args) {//这部分逻辑可以放到框架中 if (doTest()) { System.out.println("Test succeed."); } else { System.out.println("Test failed."); } } } 改造为框架来实现同样的功能，如下：
// 将流程控制逻辑放到testcase类中，形成一个小的流程框架 //1. 所有的逻辑类都继承这个类，抽象：以便将创建流程框架 public abstract class TestCase { public void run() { if (doTest()) { System.out.println("Test succeed."); } else { System.out.println("Test failed."); } } //可以按需实现不同被测试逻辑 public abstract boolean doTest(); } public class JunitApplication { //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/459dc1d32e3558d4f49f8ff20a9859fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9daab6ed0a97122499d88cb001475ce8/" rel="bookmark">
			Elasticsearch安装分词插件[ES系列] - 第499篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		历史文章（文章累计490+）
《国内最全的Spring Boot系列之一》
《国内最全的Spring Boot系列之二》
《国内最全的Spring Boot系列之三》
《国内最全的Spring Boot系列之四》
《国内最全的Spring Boot系列之五》
《国内最全的Spring Boot系列之六》
ElasticSearch应用场景以及技术选型[ES系列] - 第496篇
ElasticSearch详细搭建以及常见错误high disk watermark [ES系列] - 第497篇
Elasticsearch可视化平台Kibana [ES系列] - 第498篇
悟纤：师傅，我发现我在解决问题时总是很慢，怎么办呢？
师傅：不要着急。首先你要明白，解决问题需要时间和耐心。你可以尝试将问题分解成更小的部分，然后一步一步地去解决。
悟纤：分解问题？能具体说说怎么做吗？
师傅：当然。比如说，你可以将一个大问题拆分成几个小问题，然后逐一解决。或者，你可以将问题按照紧急程度和重要性进行分类，优先解决重要的问题。
悟纤：这样确实有帮助。那么，还有其他方法可以提升我的问题解决速度吗？
师傅：当然。你可以通过练习来提高你的问题解决速度。你可以找一些类似的问题进行练习，这样可以帮助你更好地掌握解决问题的方法和技巧。
悟纤：我明白了，师傅。我会尝试这些方法的。
师傅：很好，徒儿。记住，解决问题的关键在于思考和行动。只要你不断地思考和尝试，你一定能够提高你的问题解决速度。
导读
Hi，大家好，我是悟纤。我就是我，不一样的烟火。我就是我，与众不同的小苹果。
分词器接受一个字符串作为输入，将 这个字符串拆分成独立的词或 语汇单元（token） （可能会丢弃一些标点符号等字符），然后输出一个 语汇单元流（token stream）
一、ES内置分词器
事实上，ElasticSearch中有一些内置分词器：
l Standard 分词器：默认分词器，会将词汇单元转成小写形式并且去除停用词和标点符号，支持中文采用的方法为单字切分。
l Simple 分词器：首先会通过非字母字符来分割文本信息，然后将词汇单元统一为小写形式。该分词器会去除掉数字类型的字符。
l Whitespace 分词器：仅仅是去除空格，对字符没有lowcase化，不支持中文；并且不对生成的词汇单元进行其他标准化处理。
l Stop 分词器：相比Simple Analyzer多了去除请用词处理，停用词指语气助词等修饰性词语，如the, an, 的， 这等
l Keyword 分词器：不分词，直接将输入作为一个单词输出
l Pattern 分词器：通过正则表达式自定义分隔符，默认是\W+，即非字词的符号作为分隔符
l Language 分词器：特定语言的分词器，不支持中文。如 english 、french 和 spanish 分析器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9daab6ed0a97122499d88cb001475ce8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3477c3f2e971910b38261c44e50e0eee/" rel="bookmark">
			DRF-源码解析-1.1-drf的request对象：drf的request对象有何不同，drf的request多了哪些功能，drf的request比django的request好在哪里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DRF的request对象，不是原生Django的request对象了，是新创建的。
一、介绍两个魔法方法 __getattr__
当对象.成员，不存在时，就会触发__getattr__ 方法 __getattribute__
当对象.成员，（无论成员是否存在），都会触发__getattribute__方法 二、源码解析request对象创建 1、在视图执行过程中，drf的Request的对象实例化
def initialize_request(self, request, *args, **kwargs): #解析器 parser_context = self.get_parser_context(request) #返回drf的Request的实例对象 return Request( request,#原生django的request对象 parsers=self.get_parsers(), authenticators=self.get_authenticators(),#[认证对象1,...] negotiator=self.get_content_negotiator(), parser_context=parser_context ) 2、Request：简化的源码
from rest_framework.request import Request class Request: @property def data(self): #获取请求体中的数据：不管是form-data 还是json，都统一在data中获取数据 if not _hasattr(self, '_full_data'): self._load_data_and_files() return self._full_data def __getattr__(self, attr): # self._request 是原生django的request对象 # 当drf的request.GET，drf的requets没有，就去原生django的request中调用 try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) @property def FILES(self): #获取文件数据 if not _hasattr(self, '_files'): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3477c3f2e971910b38261c44e50e0eee/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/25/">«</a>
	<span class="pagination__item pagination__item--current">26/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/27/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>