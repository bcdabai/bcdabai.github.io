<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0508b926fb176433f4691e37e16bbfc6/" rel="bookmark">
			Java语言写入Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：在pom文件里面导入jar包
com.alibaba org.apache.poi
easyexcel poi-ooxml
2.1.7 第二步：构建实体类 ，实现Get Set 方法
第三步：构建方法体：javaClass 类：Demo
public class Demo {
public static void main(String[] args) {
// 写入存放路径
String fileName=“D://writer8.xls”;
// 创建excel对象参数一：路径，参数二：实体类对象。sheet：表sheet名，doWrite：存放的对象集合
EasyExcel.write(fileName,DemoData.class).sheet(“菜品分类”).doWrite(studentData());
}
// 这里我们创建一个方法，里面负责往集合里面存放数据（这里改成对于的业务逻辑即可）
public static List studentData(){
ArrayList demoData = new ArrayList&lt;&gt;(10);
for (int i = 0; i &lt; 100; i++) {
DemoData demoData1 = new DemoData();
demoData1.setName(“麻辣烫”);
demoData1.setFenlei(“测试分类”);
demoData1.setJiage(“0.01”);
demoData1.setMiaoshu(“这道菜品经济实惠”);
demoData1.setCanfeihe(“0.01”);
demoData1.setLeixing(“1”);
demoData1.setShuxing(“冷饮”);
demoData1.setShangjia(“1”);
demoData.add(demoData1);
}
return demoData;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0508b926fb176433f4691e37e16bbfc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3890fe96e5ae3f26cc290ef29b121698/" rel="bookmark">
			达梦数据库-linux环境下断网后连接卡住问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 应用：x86 centos7
数据库：1-2-128-22.08.12-166927-20005-ENT
测试数据库有两个相互隔离的IP，应用可通过两个IP连接数据库，当断开正在连接的一个网卡后，不能立即切换，程序卡住时间过长问题。应用部署于windows时正常。
如上图所示客户端初始连接ip为192.168.44.130 当关闭改网卡后程序卡住12分钟。
问题原因分析 通过设置连接超时等参数均未解决，通过咨询专家提供TCP/IP连接排查方向。通过程序跟踪，确定确为与TCP连接相关，测试修改TCP相关内核参数，最终确定与linux tcp 断网重连net.ipv4.tcp_retries2参数相关
具体分析过程 创建测试用户和表 CREATE USER "USER01" IDENTIFIED BY "Dameng88."; CREATE TABLE "USER01"."TAB02" ( "C1" INT, "C2" VARCHAR(50)); 配置服务名连接 vim /etc/dm_svc.config TIME_ZONE=(480) LANGUAGE=(cn) DMTEST=(192.168.183.128:5236,192.168.44.128:5236) [DMTEST] AUTO_RECONNECT=(1) CONNECT_TIMEOUT=(500) 编写DCI测试用例 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;malloc.h&gt; #include &lt;unistd.h&gt; #include "DCI.h" /* 声明句柄 */ OCIEnv* envhp; /* 环境句柄 */ OCISvcCtx* svchp; /* 服务环境句柄 */ OCIServer* srvhp; /* 服务器句柄 */ OCISession* authp; /* 会话句柄 */ OCIStmt* stmthp; /* 语句句柄 */ OCIDescribe* dschp; /* 描述句柄 */ OCIError* errhp; /* 错误句柄 */ OCIDefine* defhp[3]; /* 定义句柄 */ OCIBind* bidhp[4]; /* 绑定句柄 */ sb2 ind[3]; /* 指示符变量 */ /* 绑定select结果集的参数 */ int szc1; /* 存储personid列 */ text szc2[30]; /* 存储sex列 */ char sql[256]; /* 存储执行的sql语句*/ void connDB(){ char strServerName[50]; char strUserName[50]; char strPassword[50]; int ret; text errbuf[100]; /* 设置服务器，用户名和密码 */ strcpy(strServerName, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3890fe96e5ae3f26cc290ef29b121698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2655e88c2d576b479a3794f0914576b/" rel="bookmark">
			python使用numpy进行排序后返回相应的索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中原生的sort()方法直接对列表进行排序，并不返回索引，例如：
a = [9, 3, 6, 0] a.sort() print(a) 输出：
[0, 3, 6, 9]
如果想返回索引可以使用numpy.argsort()方法
import numpy as np x = np.array([3, 1, 2]) idx = np.argsort(x) print(idx) # get data by sort index a = x[np.argsort(x)] print(a) 输出：
array([1, 2, 0])
array([1, 2, 3])
这个方法也可以用于高维数组，例如二维
x = np.array([[0, 3], [2, 2]]) x np.argsort(x, axis=0) #按列排序 np.argsort(x, axis=1) #按行排序 输出：
array([[0, 3],
[2, 2]])
array([[0, 1],
[1, 0]])
array([[0, 1],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2655e88c2d576b479a3794f0914576b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ca280c926716e1fe9a9c4e497276f5/" rel="bookmark">
			Java生成由时间组成的订单号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现订单号的方式有很多种，如使用UUID、Random或者时间戳等方式都能实现，下面讲解使用SimpleDateFormat的方式实现，长度可随意增加。
参考代码：
public static void main(String args[]) { String strNumber = StringVerifyUtil.customFormatDate("yyyyMMddHHmmssSSSSSSS"); System.out.println("编号：" + strNumber); } public static String customFormatDate(String dateFormat) { SimpleDateFormat simpleDateFormat; simpleDateFormat = new SimpleDateFormat(dateFormat); Date date = new Date(); String str = simpleDateFormat.format(date); return str; } 输出结果：
编号：202206211546350000989 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39413193edbe44e082fe7f63567b2757/" rel="bookmark">
			布隆过滤器（Bloom Filter）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言 通常我们会遇到很多要判断一个元素是否在某个集合中的业务场景，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间也会呈现线性增长，最终达到瓶颈。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为O(n)，O(logn)，O(1)。这种时候，布隆过滤器就是一种比较好的解决方案了。
2.什么是布隆过滤器 布隆过滤器（Bloom Filter）其实是基于bitmap的一种应用， 1970 年由布隆提出。它由一个很长的二进制比特数组和一系列哈希函数构成，用于高效地检索数据是否存在。通俗的说可以把布隆过滤器理解为一个集合，我们可以往里面添加值，并且能判断某个值是否在里面。当布隆过滤器告诉我们某个值存在时，其实这个值只是有可能存在；可是它说某个值不存在时，那这个值就真的不存在。
3.工作机制 如图1 所示，初始化比特数组的值全为0，长度m=23，并假设有k=3个能把数据均匀映射到值域为 [0,m) 的哈希函数，经过一系列添值操作后，数组的值会散乱地被赋为1。我们先将数据a、b、c放入布隆过滤器，对a、b、c各自分别使用三个哈希函数得到映射值（即比特数组索引下标）。再根据下标将比特数组对应的值置为1，从而表示这三个数据已经存在。
然后我们用两个不曾被布隆过滤器标记的数据d、e模拟布隆过滤器的筛选过程。同样要使用前文设定的3个哈希函数，经散列得到比特数组索引下标，然后按下标查询得到对应的数组值。如果说3个索引值里出现了至少一个值为0，那么可以肯定的说这个数据肯定不存在，比如d。但是也会出现e这种情况，查得的值均为1，但是e明明不存在。其实出现这种情况的原因很好理解：那些被置为 1 的位置也可能是由于其他元素的操作而改变的。所以布隆过滤器存在假正率（False Positive）。
4.时间复杂度 空间复杂度 时间复杂度：在查找过程里，取值过程是直接查找，但是取值的次数等于哈希函数的个数成，所以时间复杂度为O(k),k为哈希函数的个数。另外哈希计算可以使用硬件加速，故查找效率很高。
空间复杂度：存储上，假设比特数组长度为m=10000000，则申请的内存大小为10000000bit=1250000B=1220.703125KB≈1.20MB≈0.001164GB。这在动辄内存8G起步的设备上，其实占用很小。
5.正确率和容错 首先对False positive概率进行推导：
假设 Hash 函数以等概率条件选择并设置比特数组中的某一位，m 是该位数组的大小，k 是 Hash 函数的个数，那么位数组中某一特定的位在进行元素插入时的 Hash 操作中没有被置位的概率是：
那么在所有 k 次 Hash 操作后该位都没有被置 "1" 的概率是：
如果我们插入了 n 个元素，那么某一位仍然为 "0" 的概率是：
因而该位为 "1"的概率是：
现在检测某一元素是否在该集合中。标明某个元素是否在集合中所需的 k 个位置都按照如上的方法设置为 "1"，但是该方法可能会使算法错误的认为某一原本不在集合中的元素却被检测为在该集合中（False Positive），该概率由以下公式确定：
其实上述结果是在假定由每个 Hash 计算出需要设置的位（bit） 的位置是相互独立为前提计算出来的，不难看出，随着 m （比特数组大小）的增加，False Positive的概率会下降，同时随着插入元素个数 n 的增加，False Positive的概率又会上升，对于给定的m，n，如何选择Hash函数个数 k 由以下公式确定：
此时False Positive的概率为：
而对于给定的False Positive概率 p，如何选择最优的位数组大小 m 呢，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39413193edbe44e082fe7f63567b2757/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc09073bb77552a79a8a50ee4ce4180a/" rel="bookmark">
			vue中本地储存实时监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目情况：比如 在同一个页面里边 不同位置 两个变量的呈现都是使用的本地储存且一个变量修改，第二个变量也要实时变化 在正常情况下 修改一个的值后储存起来 在不刷新页面的情况下 另一个是不会变化的，所以就要用到本地储存的实时刷新
顺便说一下 localStorage也实用
1. 现在main.js中注册全局方法，比如要监听的本地储存key值为‘changeData’
Vue.prototype.resetSetItem = function (key, newVal) { if (key === 'changeData') { // 创建一个StorageEvent事件 var newStorageEvent = document.createEvent('StorageEvent'); const storage = { setItem: function (k, val) { sessionStorage.setItem(k, val); // 初始化创建的事件 newStorageEvent.initStorageEvent('setItem', false, false, k, null, val, null, null); // 派发对象 window.dispatchEvent(newStorageEvent) } } return storage.setItem(key, newVal); } } 2 如何触发
在一个路由(比如路由A)存储值得时候，使用下面的方法：
this.resetSetItem('changeData', this.value); 3、如何监听
如果在另外一个路由(比如路由B)中，我们想根据changeData的变化来请求接口刷新页面数据的时候，可以在这个路由中created钩子函数中监听
window.addEventListener('setItem', ()=&gt; { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc09073bb77552a79a8a50ee4ce4180a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d20ff3b3ae5f8543142103145111776/" rel="bookmark">
			(附源码)计算机毕业设计SSM中学教务管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 需求分析 中学教务管理系统主要是为了提高工作人员的工作效率和更方便快捷的满足用户，更好存储所有数据信息及快速方便的检索功能，对系统的各个模块是通过许多今天的发达系统做出合理的分析来确定考虑用户的可操作性，遵循开发的系统优化的原则，经过全面的调查和研究。
系统所要实现的功能分析，对于现在网络方便的管理，系统要实现用户可以直接在平台上进行查看所有数据信息，根据需求可以进行在线添加，删除或修改中学教务管理系统信息，这样既能节省时间，不用再像传统的方式耽误时间，真的很难去满足用户的各种需求。所以中学教务管理系统的开发不仅仅是能满足用户的需求，还能提高管理员的工作效率，减少原有不必要的工作量。
3.2 系统可行性分析 3.2.1技术可行性：技术背景 本企业网站在Windows操作系统中进行开发，并且目前PC机的性能已经可以胜任普通网站的web服务器。系统开发所使用的技术也都是自身所具有的，也是当下广泛应用的技术之一。
系统的开发环境和配置都是可以自行安装的，系统使用SSM开发工具，使用比较成熟的Mysql数据库进行对系统前台及后台的数据交互，根据技术语言对数据库，结合需求进行修改维护，可以使得网站运行更具有稳定性和安全性，从而完成实现网站的开发。
硬件可行性分析：中学教务管理系统及信息分析的设计对于所使用的计算机没有什么硬性的要求，计算机只要可以正常的使用进行代码的编写及页面设计就可行，主要是对于服务器有些要求，对于平台搭建完成要上传的服务器是有一定的要求的，服务器必须选择安全性比较高的，然后就是在打开网站必须顺畅，不能停顿太长时间；性价比高；安全性高。
因此，我们从两个方面进行了可行性研究，可以看出系统的开发没有问题。
3.2.2经济可行性 在中学教务管理系统开发之前所做的市场调研及其他相关的管理系统，都是没有任何费用的，都是通过开发者自己的努力，所有的工作的都是自己亲力亲为，在碰到自己比较难以解决的问题，大多是通过同学和指导老师的帮助进行相关信息的解决，所以对于中学教务管理系统的开发在经济上是完全可行的，没有任何费用支出的。
使用比较成熟的技术，系统是基于SSM的开发，采用Mysql数据库。所以系统在开发人力、财力要求不高，具有经济可行性。
3.2.3操作可行性 可操作性主要是对中学教务管理系统设计完成后，用户的使用体验度，以及管理员可以通过系统随时管理相关的数据信息，并且对于管理员、学生、老师、家长四个用户角色，都可以简单明了的进入到自己的系统界面，通过界面导航菜单可以简单明了地操作功能模块，方便用户信息的操作需求和管理员管理数据信息，对于系统的操作，不需要专业人员都可以直接进行功能模块的操作管理，所以在系统的可操作性是完全可以的。本系统的操作使用的也是界面窗口进行登录，所以操作人员只要会简单的电脑操作就完全可以的。
3.3 项目设计目标与原则 1、关于中学教务管理系统的基本要求
（1）功能要求：可以管理首页、个人中心、学生管理、老师管理、家长管理、学生成绩管理、作业信息管理、作业提交管理、作业答案管理、视频课程管理、通知信息管理、校园新闻管理、师生辅导管理、辅导预约管理、温度上报管理、校园卡充值管理、友情链接管理等功能模块。
（2）性能：在不同操作系统上均能无差错实现在不同类型的用户登入相应界面后能不出差错、方便地进行预期操作。
（3）安全与保密要求：用户都必须通过身份验证才能进入系统，并且用户的权限也需要根据用户的类型进行限定。
（4）环境要求：支持多种平台，可在Windows系列、Vista系统等多种操作系统下使用。
2、开发目标
中学教务管理系统的主要开发目标如下：
（1）实现管理系统信息关系的系统化、规范化和自动化；
（2）减少维护人员的工作量以及实现用户对信息的控制和管理。
（3）方便查询信息及管理信息等；
（4）通过网络操作，改善处理问题的效率，提高操作人员利用率；
（5）考虑到用户多样性特点，要求界面简单，操作简便。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d20ff3b3ae5f8543142103145111776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef105da45bab6f15aaca35bf5d53473/" rel="bookmark">
			skynet入门笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入门观看博客笔记：
博客笔记：
第五篇 关于服务别名
别名注册与查询接口： 在skynet中，服务别名可以分为两种：
一种是本地别名，本地别名只能在当前skynet节点使用，本地别名必须使用. 开头，例如：.testalias一种是全局别名，全局别名可以在所有skynet中使用，全局别名不能以. 开头， 例如：testalias 取别名：
1、给当前服务定一个别名 可以是全局别名 也可以是本地别名
skynet.register(aliasname)
2、给指定的服务定一个别名，可以是全局可以是本地
skynet.name(aliasname,servicehandler)
查询别名：
1、查询本地名为aliasname的服务 返回servicehandler 不存在就是返回nil
skynet.localname(aliasname)
2、查询别名为aliasname的服务，可以是全局别名也可以是本地的
a、当查询本地别名时，返回servicehandler，不存在就返回nil
b、当查询全局别名时，返回servicehandler，不存在就阻塞等待到该服务初始化完成
local skynet = require “skynet.harbor”
Harbor.queryname(aliasname)
注意：本地别名跟全局别名可以同时存在
skynet的全局别名服务是在cslave里面实现的，现在不允许二次修改全局别名绑定关系，所以全局别名一般用来给一个永远不会退出的服务来启用。
​但是有些情况下，我们确实需要二次修改全局别名绑定关系，那么这个时候，我们可以尝试去修改一下cslave.lua文件
全局唯一服名与这里的全局别名是两个概念的名词。
​ 全局唯一服名称: 是用来标识服务是唯一的，服务名称一般就是脚本名称，无法更改。
​ 全局别名: 是用来给服务起别名的，既可以给普通服起别名，也可以给全局唯一服起别名。
​ 他们两种名字是在不同的体系中的，有各种的起名字的方式，以及查询的方式。
​ 所以不要尝试用skynet.queryservice查询一个全局别名，也不要尝试使用harbor.queryname去查询一个全局唯一服。
第六篇 关于服务调度相关内容
服务调度： 1、skynet.sleep(time)
让当前的任务等待time * 0.01s
2、skynet.fork(func,…)
启动一个新的任务去执行函数func，其实就是开了一个协程 函数调用完成将返回线程句柄
虽然可以使用原生的coroutine.create来创建协程，但是会打乱skynet的工作流程
3、skynet.yield()
让出当前的任务执行流程，使本服务内其他任务有机会执行，随后会继续运行
4、skynet.wait()
让出当前任务执行流程 直到用wakeup唤醒
5、skynet.wakeup()
唤醒用wait或者sleep后处于等待状态的任务
6、skynet.timeout(time, func)
设定一个定时触发函数func，在time * 0.01秒后触发
7、skynet.starttime()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fef105da45bab6f15aaca35bf5d53473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a256a6878759eced1c7ef741e026d522/" rel="bookmark">
			事件循环机制 (EventLoop)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己总结的 事件循环机制 (EventLoop)：是js的一个底层运行原理,js是单线程的，但是也有一些耗时任务，会影响执行效率,代码都在主线程中执行,当遇见你像ajax请求.setTimeout 定时器时候,会 单独开启异步线程.异步线程耗时之后会推入异步队列中等待执行.然后当主线程执行完毕之后.会到异步队列中取出到主线程中执行.然后再去异步队列中取第二个.这个来回取的过 程就是您所说的事件循环(eventLoop) lE.
官方一点的 Event Loop ( 事件循环 ) 浏览器的事件循环分为同步任务和异步任务；所有同步任务都在主线程上执行，形成一个函数调用栈（执行栈），而异步则先放到任务队列（task queue）里，任务队列又分为宏任务（macro-task）与微任务（micro-task）。下面的整个执行过程就是事件循环
宏任务大概包括：：script（整块代码）、setTimeout、setInterval、I/O、UI交互事件、setImmediate（node环境）
微任务大概包括：：new promise().then(回调)、MutationObserver(html5新特新)、Object.observe(已废弃)、process.nextTick（node环境）
若同时存在promise和nextTick，则先执行nextTick
执行过程 先从script(整块代码)开始第一次循环执行，接着对同步任务进行执行，直到调用栈被清空，然后去执行所有的微任务，当所有微任务执行完毕之后。再次从宏任务开始循环执行，直到执行完毕，然后再执行所有的微任务，就这样一直循环下去。如果在执行微队列任务的过程中，又产生了微任务，那么会加入整个队列的队尾，也会在当前的周期中执行。
下面展示一个简单的参考例子。
setTimeout(function() { console.log('timeout1'); }) new Promise(function(resolve) { console.log('promise1'); for(var i = 0; i &lt; 1000; i++) { i == 99 &amp;&amp; resolve(); } console.log('promise2'); }).then(function() { console.log('then1'); }) console.log('global1'); 首先，事件循环从宏任务队列开始，这时宏任务队列中只有一个script(整体代码)任务。每一个任务的执行顺序，都依靠函数调用栈来完成，而当遇到任务源时，则会先分发任务到对应的队列中去，所以，上面例子的第一步执行如下图所示。
第二步：script任务执行时首先遇到了setTimeout，setTimeout为一个宏任务源，那么他的作用就是将任务分发到它对应的队列中。
第三步：script执行时遇到Promise实例。Promise构造函数中的第一个参数，是在new的时候执行，因此不会进入任何其他的队列，而是直接在当前任务直接执行了，而后续的.then则会被分发到micro-task的Promise队列中去。
因此，构造函数执行时，里面的参数进入函数调用栈执行。for循环不会进入任何队列，因此代码会依次执行，所以这里的promise1和promise2会依次输出
script任务继续往下执行，最后只有一句输出了globa1，然后，全局任务就执行完毕了。
第四步：第一个宏任务script执行完毕之后，就开始执行所有的可执行的微任务。这个时候，微任务中，只有Promise队列中的一个任务then1，因此直接执行就行了，执行结果输出then1，当然，他的执行，也是进入函数调用栈中执行的
第五步：当所有的micro-tast执行完毕之后，表示第一轮的循环就结束了。这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务macro-task开始
这个时候，我们发现宏任务中，只有在setTimeout队列中还要一个timeout1的任务等待执行。因此就直接执行即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e36654634dc99f060c4bb770d1b7796/" rel="bookmark">
			在Visual C&#43;&#43;下简易OpenGL环境搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGl环境搭建容易劝退新手，那就找一条最简单的路
msvc里面有管理NuGet程序包
打开后搜索nupengl，安装下面两个库，在后续编程中就可以直接使用opengl的一些库，而不用配置其他额外的东西
在源文件中创建一个新的Cpp文件
粘贴如下代码，该代码实现了一个小块在屏幕上面的移动，按方向键操控，注释我尽量已经写的详细：
​ #include&lt;Gl/glut.h&gt; GLfloat xoffset = 0.0f, yoffset = 0.0f; void display() { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glColor3f(0, 0, 1); glViewport(xoffset, yoffset, 400, 400); //前面两个变量为偏移量，后面的位置是在窗体的坐标 glRectf(200,200,240,240); glutSwapBuffers(); //交换缓冲区指针或者地址 } void SpecialKey(GLint key, GLint x, GLint y) //GLint的原定义为int { if(key==GLUT_KEY_UP) { yoffset += 10; } if (key == GLUT_KEY_DOWN) { yoffset -= 10; } if (key == GLUT_KEY_LEFT) { xoffset -= 10; } if (key == GLUT_KEY_RIGHT) { xoffset += 10; } display(); } //glClear函数的使用 //GL_COLOR_BUFFER_BIT:当前可写的颜色缓冲 //GL_DEPTH_BUFFER_BIT:深度缓冲 //GL_ACCUM_BUFFER_BIT:累计缓冲 //GL_STENCIL_BUFFER_BIT:模板缓冲 int main(int argc,char** argv) { glutInit(&amp;argc,argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH); //第一个参数为双缓冲窗口，第二个参数为颜色模式，GLUT_SINGLE是开启单缓冲模式 //单缓冲直接在屏幕上面绘图较慢，双缓冲开到缓冲区比较快，最后开启深度缓存，被遮挡像素也在缓存中渲染 glutCreateWindow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e36654634dc99f060c4bb770d1b7796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277bacffd409e237665af6179be4a38a/" rel="bookmark">
			go build 交叉编译各系统下的可执行文件（windows，linux，macOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法 假设所需的输出文件名称为name，而当前目录的主函数为main.go
Mac下编译Linux, Windows平台的64位可执行程序
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o name main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o name main.go Linux下编译Mac, Windows平台的64位可执行程序
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -o name main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o name main.go Windows下编译Mac, Linux平台的64位可执行程序
SET CGO_ENABLED=0 SET GOOS=darwin3 SET GOARCH=amd64 go build -o name main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build -o name main.go 参数的名字分别对应的是：
GOOS：目标可执行程序运行操作系统，支持 darwin，freebsd，linux，windows
GOARCH：目标可执行程序操作系统构架，包括386，amd64，arm
Tips 在windows下，如果需要生成.exe文件。可以直接在name后面加上后缀.exe
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/277bacffd409e237665af6179be4a38a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f2acff924c55ea5ded92e16687ea4b6/" rel="bookmark">
			PID参数调节总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P：比列
I：积分
D：微分
以下调节的是Kp、Ki、Kd
1. 先将Ki和Kd设置为0，Kp值慢慢调大，Kp设置的越大输出量就越大，当输出接近目标值即可；纯P控制一定存在稳态误差。
2. 再将Ki慢慢调大，该值作用是减少稳态误差；
3. 最后调节Kd，该值调大后会减少超调，但是也不能调的太大，如果调的太大会大大延长系统到达稳定的时间。通常情况只有在系统出现超超调是才调Kd。Kd适用于抑制输出的。
注意：
① Kp越大，P值越小；
Ki越大，I值越小；
Kd越大，D值越大；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9fc2c62ba44253cd9f853e960770bd/" rel="bookmark">
			华为分布式块存储Fusion Storage知识总结（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、华为分布式存储Fusion Storage介绍
二、Fusion Storage优势（特点）
1、高弹性和扩展性
2、高性能
3、高可靠性
4、高安全性
5、数据保护
6、高易用性
FusionStorage块存储支持网络拓扑统一管理，管理维护高效集中，简洁易用；并且支持精简配置、QoS\Cach缓存等存储高级特性
7、开放兼容
三、部署方式&amp;软件架构
1、部署方式
2、软件架构
四、Fusion Storage组件介绍
五、应用场景
1、资源池场景
2、数据库场景
六、Fusion Storage高级特性
1、HyperSnap特性
ROW（Redirect On Write）
源卷
快照卷
一致性快照
克隆
2、HyperMetro特性
3、HyperReplication特性
4、SmartQoS
5、其它概念
快照原理
本端卷、远端卷
双写
复制集群
双活域
双活Pair
双活一致性组
同步
暂停
强制启动
优先站点切换
FastWrite
乐观锁机制
一、华为分布式存储Fusion Storage介绍 FusionStorage是一款可大规模横向扩展的存储产品，通过存储系统软件将服务器的本地存储资源组织起来，构建全分布式存储池，通过SCSI和iSCSI接口向上层应用提供块存储服务，满足云资源池及数据库等场景的存储需求。
二、Fusion Storage优势（特点） 1、高弹性和扩展性 Fusion Storage块存储采用DHT（Distributed Hash Table，分布式哈希表）架构，保证了Fusion Storage块存储具备大规模的线性扩展能力
2、高性能 FusionStorage块存储通过动态智能分区、静态选盘算法以及自研EC算法，采用小IO聚合、大IO直通等技术，在实现了业务均衡分布和保证了存储高可靠的同时，也保证了存储的高性能。在使用HDD作为主存时，采用分布式SSD Cache加速方案，将各个存储节点上的SSD组建成为一个共享的分布式Cache资源池，供所有的业务共同所用，实现HDD主存的性能加速。
3、高可靠性 FusionStorage块存储采用分布式集群管理方式，系统全冗余部署，无单点故障。支持多副本和EC（Erasure Coding）两种数据冗余保护机制，支持设置灵活的数据可靠性策略，支持DIF、后台数据一致性校验等数据完整性校验功能。
4、高安全性 自研Fusion Storage OS系统，支持操作系统进行安全加固
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a9fc2c62ba44253cd9f853e960770bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55cc12e4e8ac30364c89219bc4c76e78/" rel="bookmark">
			python爬虫 xpath使用问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. module 'lxml' has no attribute 'html' 代码：
import requests import lxml web = requests.get('https://www.xxx.com/paihang.html', timeout=7) selector = lxml.html.fromstring(web) print(selector) 解决：
import lxml 改为 import lxml.html 2.ValueError: can only parse strings 代码：
web = requests.get('https://www.xxx.com/paihang.html', timeout=7) selector = lxml.html.fromstring(web) print(selector) 解决：
selector = lxml.html.fromstring(web) 改为 selector = lxml.html.fromstring(web.text) 3.AttributeError: 'NoneType' object has no attribute 'xpath' 代码：
import requests from lxml import etree web = requests.get('https://www.xxx.com/top250/') web.encoding = 'utf-8' selector = etree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55cc12e4e8ac30364c89219bc4c76e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45293b806ba8999ff3e6e5f009602db3/" rel="bookmark">
			【春秋云境】CVE-2022-32991靶场wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【春秋云境】CVE-2022-32991 前期准备靶场介绍本期题目题目简介CVE-2022-32991简介环境准备工具准备 渗透测试1、已知提示2、开启靶场3、注册账户4、登录账户进入到主页查找目标抓包记录Sqlmap攻击所需的HTTP头部请求参数Sqlmap攻击爆库爆表爆列爆字段 做题答疑总结 前期准备 靶场介绍 10月10日10时24分，基于多年来在网络靶场领域的深厚技术及场景积累，永信至诚i春秋正式发布春秋云境.com社区，以春秋云底层能力为基础，以平行仿真技术为支撑，以高仿真内容场景为核心，打造网络安全实战“元宇宙”，通过更加多元、开放、创新的线上技术交流空间，为更广泛的用户群体提供更轻量的靶场体验，助力攻防两端的实战技能提升。
春秋云境.com是依托春秋云技术打造的国内首家云上靶场社区，集演、训、学、测为一体，广泛支撑个人、企业、学校、科研院所等社会各类群体和组织在线进行网络安全学习、能力认证、漏洞研究、综合渗透、案例复现、竞赛演练等。
本期题目 主页→漏洞靶标→免费空间→CVE-2022-32991
题目简介 CVE-2022-32991简介 明确漏洞类型为：OWASP TOP 10 A03 注入
环境准备 1、Java 1.8 或 Java 17（适用于对应Burpsuite版本）
2、Python 2 或Python 3（适用于对应Sqlmap版本）
工具准备 1、Burpsuite
2、Sqlmap
3、FireFox
渗透测试 1、已知提示 该CMS的welcome.php中存在SQL注入攻击。
2、开启靶场 3、注册账户 REGISTER→任意注册一个
4、登录账户 进入到主页 查找目标 根据CVE官方：
在welcome.php，发现基于 Web 的测验系统 v1.0 通过 eid 参数包含一个 SQL 注入漏洞。
观察该页面URL，发现虽然为welcome.php，但参数并不是eid
继续查找其他页面，点击第一栏Start进行跳转：
发现存在welcome.php和eid参数
抓包 1、开启FireFox的FoxyProxy的Burpsuite代理
2、开启Burpsuite代理
3、开启Burpsuite抓包
记录Sqlmap攻击所需的HTTP头部请求参数 --cookie="PHPSESSID=k5854nfic1qngm5ul1vmb8pbma" --user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0" 其中，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45293b806ba8999ff3e6e5f009602db3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc7ecd4cb8a5a191581da5644e4239b/" rel="bookmark">
			(附源码)计算机毕业设计SSM智能超市导购系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 需求分析 开发系统的过程中，去调查用户的功能诉求，对需要存在的功能进行需求分析是特别重要的，且对于系统的开发有着实际的意义，设计智能超市导购系统通过对用户的需求进行分析，结合实际情况进行开发研究，对用户的所有需求做出一个完整的基本的框架，然后一步一步的完成、实现。需求分析可以为系统的开发提供一个目标，只有按照这个目标进行开发设计，才能进行完整的开发，这样设计出的系统才有使用的意义，才能在竞争激烈的软件市场中生存，才能真正的帮助人们解决问题，提高实际的效率。
3.2 系统可行性分析 3.2.1 技术可行性
本系统采取的是目前应用最广泛的程序进行技术的支持，主要的技术支持是java语言，他作为一个相当成熟的语言程序，在众多的软件开发中起着很大作用。而且用java语言编辑出来程序可以直接运行，不需要借助其他的翻译器进行翻译。所以在技术方面是完全可以行的。
3.2.2 经济可行性
本项目开发的初衷就是为了节约，因为系统开发的所有过程都是我自己开发的我，而且在开发过程使用到的技术也都是市面上常见的容易操作的，所以不需要请专业的人士花资金来进行系统的开发，而且在项目开发的过程中我也学到了更多的知识。开发的这个软件可以在网络中进行免费的下载，对计算机的软硬件没有很高的要求，因此这个项目是非常实惠的，在经济方面是完全可性的。
3.2.3 操作可行性
操作可行性也就是系统的可用性，一个系统的操作是否容易决定着这个系统的使用度，在系统的操作方面的设计我都是采取简洁易懂的方式，操作的整个菜单界面整齐有序，所有的功能都有序的排列，不会出现重叠或者需要转换的现象，用户想要哪方面的操作都可以直接进行操作，所以该系统任何人都可以进行操作，不需要有相关专业的技术这样用户在操作起来就容易很多。
3.3 项目设计目标与原则 1、关于智能超市导购系统的基本要求
（1）功能要求：管理员可以对所有的商品进行查看管理，可以对商品进行管理，可以及时的查看管理的情况，还可以对留言进行查看和管理等功能模块。
（2）性能：因为超市管理中有很多的信息需要存储，因此对于系统的存储量有很大的要求，需要有一个强大的数据库的支持才能确保所有的信息都能安全稳定的进行存储。
（3）安全与保密要求：用户都必须通过管理员审核才能进入系统。
（4）环境要求：支持Windows系列、Vista系统等多种操作系统使用。
2、开发目标
智能超市导购系统的主要开发目标如下：
（1）用户可以实时查看最新的商品信息，以及相关资讯；
（2）用户可以对比各大商品的信息，选择自己较为满意的商品；
（3）用户可以通过留言互相交流购买商品心得；
（4）管理员可以在后台方便管理前台网页的各种信息；
3、设计原则
本智能超市导购系统采用SSM技术，Mysql数据库开发，充分保证了系统稳定性、完整性。
（1）系统响应效率：由于是智能超市导购系统，因此就需要系统的响应效率是非常高的，并且可以支持很多人同时进行系统的使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abc7ecd4cb8a5a191581da5644e4239b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e2b20909f621842cab597fa988f157/" rel="bookmark">
			接口测试初认知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口测试初认知 一、概念 根据分层自动化测试中的定义，最底层由开发人员编写的单元测试保证代码质量，最上层由功能测试人员手工+UI自动化进行大量的自动化功能测试保证功能的可用，则中间层的接口测试是什么作用呢？接下里我们就学习接口测试。
那说到接口测试，那什么是接口呢？
语法接口：编程语言语法上定义的接口，具体到程序中的一般就是提供了输入输出的类、方法或函数。对于接口的测试，一般需要使用与开发程序接口相同的编程语言，通过不同的传入不同的参数，来验证程序接口的功能。
协议接口：一般指系统通过不同的协议来提供的接口，例如http/soap协议等。这种类型接口对底层代码做了封装，会写好接口路径和接口方法名的映射，然后前端通过接口路径来调用方法。我们接口测试，就是测试协议接口。
二、接口测试的意义 1、更早的发现问题 测试左移提倡测试应该更早的介入到项目开发中，因为越早的发现bug，修复的成本越低。然而功能测试必须要等到系统提供可测试的界面才能对系统进行测试。系统接口是上层功能的基础，接口测试可以更早更低成本的发现和解决问题。
而且，在我们实际工作经历中，你会发现，由于时间、资源和其他原因，开发人员大部分是不会编写单元测试，所以接口测试就更为重要。
2、缩短产品研发周期 对于产品研发周期来说，如果将所有的测试工作都集中在功能测试阶段，那么测试的问题和修复周期就会变长。因为测试可以更早的介入产品开发中，所以可以有效的控制功能阶段的bug数量，从而有效的缩短产品开发周期。
结合实际来说，有一个查询功能，后端接口已经做好了，但是前端页面还没设计好。如果是功能测试，那你只能是等待前端页面做好才能进行。如果有接口测试，就直接通过输入参数进行接口测试。更早介入测试，再等前端页面开发，能减少功能测试阶段的bug，就可以缩短产品开发周期。我认为，接口测试可以看成是简单的部分并行工作流程。
3、发现更底层的问题： 系统的有些底层逻辑是在UI功能测试中不太容易触发的，那么这些逻辑可能会存在问题，接口测试可以更容易更全面的测试到这些底层逻辑。
eg：在工作中，有一个优惠检验功能，分别由两个参数控制，一个A是控制是否使用，一个B是具体的优惠详情。在正常的功能测试中，前端传入的参数是正确且对应关系是一致。但是异常情况下，前端由于某种原因，缓存清理B出现问题，还是保留了B，但是A是0，后端的校验机制竟然通过了，并且使用了B优惠。这种情况就是底层逻辑的校验没有做好，并且这种异常情况，功能测试下是无法去手动实现异常场景的。
4、检查服务器的异常处理能力 我们通常将前端的验证成为弱验证，因为它很容易被绕过，这个时候如果只站在功能的层面进行测试，进很难发现一些安全的问题。不以功能为入口的接口测试就会容易的验证这些异常情况。
5、个人经历 在工作中，公司某一项目：平台的代码是二期的，但是客户端是一期的。实现的支付接口，平台在二期有改动，使用二期客户端没有问题。但是在只上平台代码，客户端还是一期的版本，就会出现一期中控调用二期平台的场景，接口没有向下兼容，所以测试左移是很重要的。
三、接口测试用例设计 接口测试用例设计有三个模块：前端测试、后端测试、接口文档
前端测试，进行响应数据的改写，验证不同的响应下前端的展示效果
后端测试，依据“输入–处理–输出”这样的模式，检查输出结果跟期望是否一致
接口文档，需要检查实际开发和接口文档是否统一
测试用例设计思路 从输入参数进行考虑设计 优先级-针对所有的接口： 1、暴露给其他系统、第三方调用的接口
2、系统内部调用的核心功能接口
3、系统内部调用的非核心功能接口
优先级-针对单个接口 1、正向测试用例优先，逆向测试用例次之（一般情况）2、是否需要满足前提条件（token）&gt; 是否携带默认值参数 &gt; 参数是否必填 &gt; 参数之间是否存在关联 &gt; 参数数据类型限制校验 &gt; 参数数据类型自身的数据范围值限制校验 用例设计分析 从接口后端业务逻辑出发，设计接口测试用例需要考虑以下几个方面：
1、是否满足前提条件
有些接口是需要满足一定条件，才可以成功获取数据。最常见的就是需要用户登录信息的接口（token）
逆向用例：设计不满足前置条件的用例
2、是否携带默认值参数
正向测试用例：
存在默认值的参数都不填写、不传参，必填参数都填写正确并且存在正确的常规值
3、业务逻辑、功能需求
这个环节需要根据具体的业务需求，结合接口定义文档，可设计出多条正向用例和逆向用例 4、参数是否必填
针对每个必填参数，设计一条或多条参数值为空的逆向测试用例 5、参数之间是否有关联
可根据参数之间的相互关联关系设计一条或多条用例 6、参数数据类型限制
针对每个参数类型设计与定义的类型不符的逆向测试用例 7、参数自身的数据范围值限制校验
针对所有的参数，设计每个参数在数据范围内为最大或最小的正向测试用例 总结：如果以上几个方面考虑全面，基本可以覆盖三个点：
a、主流程测试用例：正常的主流程业务需求校验
b、分支流程测试用例：正常的分支流程需求校验
c、异常流程测试用例：异常业务场景的容错校验
从输出参数进行考虑设计 1、输出结构是否与接口文档定义的一致
2、输出的各个字段类型是否与接口文档定义的一致
3、输出的各个字段的值是否符合逻辑且值正确
测试方式 手工测试 手工测试就是借助浏览器或部分测试工具（postman、jemter等）手动执行测试用例的过程。针对新开发接口，建议首先进行全面的手工测试后再将部分可重复执行用例加入自动化测试。开源的：postman、jmeter、meterSphere、SoapUI等，商业的有LoadRunner等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6e2b20909f621842cab597fa988f157/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67e7493b5a95b5b7a2173bf679c51b1/" rel="bookmark">
			进程/线程/多线程/Task/Async/Await/EFcore/IQueryable/IEnumerable/AsEnumerable/AsQueryable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.进程/线程/多线程 进程：
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本 单位，是操作系统结构的基础。 在早期面向进程设计的计算机结构中，进程是程序的基本执行实体； 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的 实体。
线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运 作单位。
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但
同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程
本地存储（thread-local storage）。
一个进程可以有很多线程，每条线程并行执行不同的任务。
//1. 进程/线程/多线程
//2. 同步异步
//3. 异步的三大特点
//4. C#中的多线程
//一、进程：计算机概念，虚拟的记录，描述一个应用程序在计算机上运行的时候，所消耗的各种资源的集合---Cpu+内容+磁盘IO+网络资源； //---类似于某一个公司---公司正常运作； //二、线程：（计算机资源）一个程序的进程中，所执行的具体的某一个动作的最小执行流；小到点击某个按钮，大到通过网络发送一句话出去； //具体到某一个人： //进程必然是包含了多个线程；线程是依附于进程存在的；如果进程不在了，线程也随之消失了； //三、句柄：是一个long了类型的数字，对应这计算机程序中的某一个小部件；要操作程序，对应的最小的单位； //公司中的任何一个物件--编号--计算机---会给计算机坐个编号---（部门---座位号） //四、为什么计算机可以多线程？跟计算机的CPU的核数有关； //6核12线程：把六个核心进行逻辑切分：如果有动作需要计算机响应，操作系统就会去申请CPU来处理；CPU在执行动作的时候，CPU是分片执行： //分片：把每一个核每一毫秒可以执行的动作，切分成10000份；操作系统在调度的时候，执行动作，切分后去执行的多个动作的时候；开始动作A,使用的是分片后的某一份； 结束的时候，可能使用的是另外的某一份； //计算机在不断的调度过程中； //1.从宏观角度来说：多个动作，就可以做到在某一段时间内；看似同时执行完毕了； //2.从微观的角度来说：某一时刻，同意时刻只能处理一件事儿--串行执行； //五、C#中的多线程：Thread/ThreadPool/Task 都是C#语言在操作计算机的资源（线程）时；封装的一个帮助类库； //线程：---同步异步： //单线程执行代码命令：同步执行； //同步方法： //1.线性执行，从上往下依次执行--很符合我们人类的思维逻辑，线程ID为01 (主线程/UI线程) // 请人吃饭：真心的请人吃饭；Richard老师请Vn吃饭；说：Vn，晚上一起去吃饭；Vn:我还要忙一会儿，Richard:那好，我等你；等你忙完，我们一起去吃饭； //2.同步方法执行慢；卡顿界面--只有一个线程参与计算---CPU太忙，根本无暇他顾；只有一个线程执行动作； 消耗的计算机资源少（工钱少） //3.同步方法：有序执行； //多线程执行代码命令：异步执行： //异步方法： //1.开启了一个新的线程（多线程--子线程）（有一个新的线程Id）;且不再是线型执行了； UI线程不等待子线程执行完毕；主线程直接往后执行； 子线程延迟执行 //请人吃饭：客气一下请人吃饭：Richard老师客气一下请人Vn吃饭，说：Vn，晚上一起吃饭，Vn：我还要忙一会儿，Richard:那你先忙吧，我就先去吃饭了，你忙完自己去吃饭吧！ //2.异步方法执行快：不卡顿界面；开启了一个新的线程去执行去了；开启了五个线程去执行动作：消耗的计算机资源多（工钱多） // 异步方法--多线程方法--以资源换时间； 使用大量的资源，降低时间成本； //3.无序执行：线程开启无法控制谁先谁后；线程执行计算结束也无法控制谁先谁后；---多线程异步执行：无序执行； Task开启线程的多种方式，子线程，单线程等待Delay和Sleep的区别，和使用场景Waitall/WaitAny/TaskFactory:ContinueWhenAny/TaskFactory：ContinueWhenAll 1.C#中的多线程Task
2.父子级线程
3.Task：Waitall WaitAny Delay
4.TaskFactory:ContinueWhenAny
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b67e7493b5a95b5b7a2173bf679c51b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146fa4dbe23d7a852c1afc18cfa0ade7/" rel="bookmark">
			消息连发代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 On Error Resume Next Dim xda,ye set xda=createobject("wscript.shell") for i =1 to 200 wscript.sleep 520 xda.AppActivate xda.sendKeys "^v" xda.sendKeys "%s" next wscript.quit 参数说明：
for i =1 to 200 代表消息发送条数
wscript.sleep 520 代表间隔520毫秒发送一次
使用方法：
先把这些代码放到记事本中，将记事本后缀改为vbs。复制（ctrl+c）要连发的内容。双击刚刚编辑好的vbs文件。点击消息编辑框实现消息连发。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f711bca92b480c26dfe26ceca2681b26/" rel="bookmark">
			Phantun: 一款突破运营商 QoS 封锁的高性能 UDP 流量伪装工具，支持 WireGuard 协议...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号关注 「奇妙的 Linux 世界」
设为「星标」，每天带你玩转 Linux ！
原文链接🔗：https://icloudnative.io/posts/wireguard-over-tcp-using-phantun/
👉WireGuard 作为一个更先进、更现代的 VPN 协议，比起传统的 IPSec、OpenVPN 等实现，效率更高，配置更简单，并且已经合并入 Linux 内核，使用起来更加方便，简直就是 VPN 中的战斗机。越来越多的高人利用 WireGuard 实现很多奇奇怪怪的需求。例如国内与国外机器通过 WireGuard 打通隧道，变成伪 IPLC 专线；或者打通本地与 Kubernetes 集群的网络。
但是 WireGuard 在国内网络环境下会遇到一个致命的问题：UDP 封锁/限速。虽然通过 WireGuard 可以在隧道内传输任何基于 IP 的协议（TCP、UDP、ICMP、SCTP、IPIP、GRE 等），但 WireGuard 隧道本身是通过 UDP 协议进行通信的，而国内运营商根本没有能力和精力根据 TCP 和 UDP 的不同去深度定制不同的 QoS 策略，几乎全部采取一刀切的手段：对 UDP 进行限速甚至封锁。
鲁迅先生说过：羊毛出在羊身上！突破口还是在运营商身上：虽然对 UDP 不友好，但却无力深度检测 TCP 连接的真实性。
这就好办了，既然你对 TCP 连接睁一只眼闭一只眼，那我将 UDP 连接伪装成 TCP 连接不就蒙混过关了。目前支持将 UDP 流量伪装成 TCP 流量的主流工具是 udp2raw[1]，相信很多小伙伴对这个工具都轻车熟路了，但是很遗憾，今天的主角不是它，而是另一款比它更强大的新工具：Phantun[2]。
Phantun 介绍 Phantun 整个项目完全使用 Rust 实现，性能吊打 udp2raw。它的初衷和 udp2raw 类似，都是为了实现一种简单的用户态 TCP 状态机来对 UDP 流量做伪装。主要的目的是希望能让 UDP 流量看起来像是 TCP，又不希望受到 TCP retransmission 或者 congestion control 的影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f711bca92b480c26dfe26ceca2681b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f871714079f67f500074f2df0063e67/" rel="bookmark">
			arcgis pro3.0安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载软件 一共有11个文件，常用的就是前5个
配置安装环境 关闭防火墙
关闭病毒扫描
4. 安装.net sdk
安装arcgis pro 解压2ArcGISPro_30_zh_CN_182227
等待安装完成
点击完成之后会自动安装中文语言包
解压破解文件3ESRI_ArcGIS_Pro_3.0_Crack_DanPack.zip
找到Arcgis Pro的安装路径
替换AfCore.dll
执行lic注册表
找到当前用户下面的Local文件夹
C:\Users\用户名\AppData\Local将ESRI_Licensing复制进去
安装4ArcGIS_Pro_patch_301_182232
更新即可
启动ArcGis Pro查看效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9fda56f4319e6a779613e57027fd45/" rel="bookmark">
			什么是AQS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AQS ( Abstract Queued Synchronizer ）是一个抽象的队列同步器，通过维护一个共享资源状态（ Volatile Int State ）和一个先进先出（ FIFO ）的线程等待队列来实现一个多线程访问共享资源的同步框架。
一、AQS原理 AQS 为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度，具体的流程如图 -14所示。许多同步类的实现都依赖于AQS ，例如常用的 ReentrantLock、Semaphore、CountDownLatch。
二、state：状态 Abstract Queued Synchronizer 维护了 volatile int 类型的变量，用于表示当前的同步状态。volatile虽然不能保证操作的原子性，但是能保证当前变量state的可见性。
state的访问方式有三种： getState()、setState()和 compareAndSetState()，均是原子操作，其中，compareAndSetState的实现依赖于 Unsafe的compareAndSwaplnt() 具体的。JDK 码实现如下：
三、AQS共享资源的方式：独占式和共享式 AQS 定义了两种资源共享方式 ：独占式 (Exclusive)和共享式(Share)
独占式:只有一个线程能执行，具体的 Java 实现有 ReentrantLock。共享式：多个线程可同时执行，具体的 Java 实现有 Semaphore和CountDownLatch。 AQS只是一个框架 ，只定义了一个接口，具体资源的获取、释放都 由自定义同步器去实现。不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护，如获取资源失败入队、唤醒出队等， AQS 已经在顶层实现好，不需要具体的同步器再做处理。自定义同步器的主要方法如表 3-4 所示:
同步器的实现是 AQS的核心内存。 ReentrantLock对AQS的独占方式实现为：ReentrantLock中的state初始值为0表示无锁状态。在线程执行 tryAcquire()获取该锁后ReentrantLock中的state+1，这时该线程独占ReentrantLock锁，其他线程在通过tryAcquire() 获取锁时均会失败，直到该线程释放锁后state再次为0，其他线程才有机会获取该锁。该线程在释放锁之前可以重复获取此锁，每获取一次便会执行一次state+1, 因此ReentrantLock也属于可重入锁。 但获取多少次锁就要释放多少次锁，这样才能保证state最终为0。如果获取锁的次数多于释放锁的次数，则会出现该线程一直持有该锁的情况；如果获取锁的次数少于释放锁的次数，则运行中的程序会报锁异常。
CountDownLatch对AQS的共享方式实现为：CountDownLatch 将任务分为N个子线程去执行，将 state 初始化为 N, N与线程的个数一致，N个子线程是井行执行的，每个子线程都在执行完成后 countDown()1次， state 执行 CAS 操作并减1。在所有子线程都执行完成( state=O)时会unpark()主线程，然后主线程会从 await()返回，继续执行后续的动作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c9fda56f4319e6a779613e57027fd45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d61c4b201f80f88f38b20883b77395b/" rel="bookmark">
			解决“产品运行所需的信息检索失败。请重新安装xshell”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XShell6破解版下载路径： 链接：https://pan.baidu.com/s/1eh423lGDXnf6bf9wbBiBTQ
提取码：lwjh
安装方式： 使用管理员身份运行里面的绿化bat文件。
后记： 不能直接运行XShell.exe文件，否则会报错：
使用管理员身份运行里面的绿化bat文件就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84b31855e9d35c9e3e092591b992abc/" rel="bookmark">
			笔记本电脑没有外放声音，但是插上耳机有声音的问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开笔记本本想播放视频，却发现笔记本没有声音，但是右下角的喇叭图标是正常显示的，而且检查了声卡驱动都是好的，插上耳机也可以正常播放声音。
在网上查了很久的资料都没有解决这个问题，最后一个帖子的方法解决了这个问题。
步骤如下：
1. 打开控制面板，找到“声音”图标，双击打开
2.在打开的窗口中选择“播放”选项卡
3.双击“扬声器”，弹出“扬声器属性”窗口
4.在“扬声器属性”窗口选择“高级”选项卡
5.调整“测试”按钮前的下拉选项，点击“测试”按钮
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25cb1f05010e0f7698bb0a3909b1116/" rel="bookmark">
			爬虫基础-requests库的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文章为学习过程中对知识点的记录，供自己复习使用，也给大家做个参考，如有错误，麻烦指出，大家共同探讨，互相进步。
借鉴出处：
该文章的路线和主要内容：崔庆才（第2版）python3网络爬虫开发实战
Requests中文文档：https://www.w3cschool.cn/requests2/
requests库是在urllib的基础上进行的进行的封装，比urllib使用更加便捷，企业中多数用requests，所以与urllib对照学习，加深记忆！
1、安装requests库
pip install requests
2、requests.get() 对比 urllib.request.urlopen()
输入：
import requests res = requests.get('https://www.baidu.com/') print(type(res)) //输出响应的类型 print(res.status_code) //状态码 print(type(res.text)) //响应体类型 print(res.text[:100]) //响应体内容（显示一部分，要不然太多了） print(res.headers) //响应头 print(res.history) //请求历史记录 print(res.cookies) //Cookie print(res.url) // 输出：
&lt;class 'requests.models.Response'&gt; 200 &lt;class 'str'&gt; &lt;!DOCTYPE html&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charse {'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Connection': 'keep-alive', 'Content-Encoding': 'gzip', 'Content-Type': 'text/html', 'Date': 'Tue, 04 Oct 2022 02:40:51 GMT', 'Last-Modified': 'Mon, 23 Jan 2017 13:24:33 GMT', 'Pragma': 'no-cache', 'Server': 'bfe/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25cb1f05010e0f7698bb0a3909b1116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/614a0df2e7a3f453d5c62d9e3d49a9f1/" rel="bookmark">
			python代码提取图片文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤一：安装两个库 需要安装pytesseract和PIL两个库，然后还要安装tesseract-ocr识别引擎
问题一：安装两个库失败 这个博主讲的很详细参考链接lpython3安装pil报错
使用pip命令安装这两个库（pip命令无法使用的参考我的这篇文章将python中的.py文件打包成.exe）
pip install pillow pip install pillow-pil 安装好了之后我的是这样
步骤二：安装tesseract-ocr 参考链接Tesseract-OCR 下载安装和使用
用命令提示符提取图片文字 ①先将路径换到图片路径下（直接输入盘符D:可以切换到D盘下，然后输入cd picture
cd 后面跟D盘下文件的名字 ）（或者直接在图片路径直接输入cmd打开命令提示符）
②然后输入tesseract test.png 1 -l chi_sim
tesseract test.png 1 -l chi_sim 【语法】: tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile…]
imagename为目标图片文件名，需加格式后缀；
outputbase是转换结果文件名；
lang是语言名称（在Tesseract-OCR中tessdata文件夹可看到以eng开头的语言文件eng.traineddata），如不标-l eng则默认为eng。
其中eng为英语chi_sim和chi_sim_vert为简体中文（暂时不知它俩什么区别）
③会在同目录下得到名为1.txt的文件, 里面就是提取到的文字
用python输出图片文字 以下是提取汉字的代码
import pytesseract from PIL import Image def demo(): # 打开要识别的图片 image = Image.open('../selfLesson/test.png') # 使用pytesseract调用image_to_string方法进行识别，传入要识别的图片，lang='chi_sim'是设置为中文识别， text = pytesseract.image_to_string(image, lang='chi_sim') # 输入所识别的文字 print(text) if __name__ == '__main__': demo() # tesseract test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/614a0df2e7a3f453d5c62d9e3d49a9f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905c697775d8629351d6b4b00caa5693/" rel="bookmark">
			【干货】10个高质量的java自学网站推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常有人留言问我，“想学习Java编程，有没有学习资源推荐，有哪些网站可以关注”。好些同学是去网盘搜索，或者去某宝购买，搜集一堆资料，但是又不清楚哪些是重复的内容，哪些内容是不是版本已经过时，哪些内容是只讲解了入门……
1、learnjava 官网地址：
Learn Java - Free Interactive Java Tutorial
是一个交互式学习 java 的网站，所谓的交互式，就是你只需要从第一个步骤开始，按照人家的提示进行操作即可，也可以说是傻瓜式学习，你看：
首先给你讲解理论知识，然后让你实际操作代码：
可以直接写代码直接输出打印。是一个非常不错的 Java 自学网站！
2、LeetCode/力扣 官网地址：
力扣(LeetCode)
这是一个相当重要的网站，建议每个程序员都需要去使用这个网站，Java 程序员那更是必备网站，你看看：
一个核心“算法”，程序员的核心竞争力，你值得拥有！
3、Java 官方文档 官网地址：
The Java™ Tutorials
个人觉得这个应该比较少人知道吧，你看看：
感兴趣的可以去看看哦
4、Java World 说实话，我很喜欢这个网站的名字，Java 的世界，哈哈，一看就是专门为学习 Java 的而打造的，界面是这样的：
这个上面主要就是介绍 Java 相关的文章，增长见识，提高知识，你绝对值得拥有，官网地址： Java information, news, and how-to advice | InfoWorld
/ 5、BeginnersBook / 这个网站上提供的都是一些适合 Java 初学者的免费教程，看下界面：
怎么样，看着是不是很不错呢？官网地址：
Java Tutorial for Beginners With Examples
/ 6、javaranch / 这个被称为 Java 牧场，为什么这么叫，大家看下它的页面就知道了：
看着是不是很有意思？
说句实话，内容真的很棒，需要你去好好挖掘了，官网地址：JavaRanch - A friendly Place for Java Greenhorns
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905c697775d8629351d6b4b00caa5693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50a56f183d99ed67455201c4bedec386/" rel="bookmark">
			go build 成不同环境的方法：mac、linux、windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改你的 go env环境变量，如下：
1、Mac下编译Linux, Windows平台的64位可执行程序：
$ go env -w CGO_ENABLED=0 GOOS=linux GOARCH=amd64 $ go env -w CGO_ENABLED=0 GOOS=windows GOARCH=amd64 2、Linux下编译Mac, Windows平台的64位可执行程序：
$ go env -w CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 $ go env -w CGO_ENABLED=0 GOOS=windows GOARCH=amd64 3、Windows下编译Mac, Linux平台的64位可执行程序：
$ go env -w CGO_ENABLED=0 GOOS=darwin3 GOARCH=amd64 $ go env -w CGO_ENABLED=0 GOOS=linux GOARCH=amd64 执行编译
go build -o "你要存储编译后的文件到哪里？" main.go 然后把编译后的文件放到对应的环境中就可以执行了。是不是很方便？就不用像传统那样，要整个项目都放上服务器那样了，例如php就是要整个项目都放到服务器中的。
日常开发中
mac编译linux
go env -w CGO_ENABLED=0 go env -w GOOS=linux go env -w GOARCH=amd64 切换回mac
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50a56f183d99ed67455201c4bedec386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d721b917da9bb02e1958d5f5743fce4/" rel="bookmark">
			File 类用法和 InputStream, OutputStream,Reader,Wirter 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 文件内容的读写File类streamInputStream使用字节流读文件使用Scanner读文件 OutputStream使用字节流写文件使用PrintWriter进行写操作 Reader使用字符流读文件 Wirter使用字符流写文件 close()总结 文件内容的读写 文件操作，是属于操作系统层面提供的一些API.
不同的操作系统，提供的API是不一样的~
Java作为一个跨平台的语言，为了统一代码，就在JVM中把不同系统的操作文件的的API进行了封装~ Java 就可以使用Java中的库的代码来操作文件了~~
Java 中通过 java.io.File 类来对一个文件（包括目录）进行抽象的描述。
💥注意:有 File 对象，并不代表真实存在该文件
IO:
I :input 输入O output 输出 输入输出的方向,就是以CPU/内存为中心 ~ File类 File类的属性:
修饰符及类型属性说明static StringpathSeparator依赖于系统的路径分隔符，String 类型的表示static charpathSeparator依赖于系统的路径分隔符，char 类型的表示 File类的构造方法:
签名说明File(File parent, String child)根据父目录 + 孩子文件路径，创建一个新的 File 实例File(String pathname)根据文件路径创建一个新的 File 实例，路径可以是绝对路径或者相对路径File(String parent, String child)根据父目录 + 孩子文件路径，创建一个新的 File 实例，父目录用路径表示 File类的方法:
1️⃣ 创建File对象
File(String pathname) 创建File对象的时候,就可以指定一个路径(绝对/相对均可)
File f = new File("./test.txt"); 2️⃣获取File对象父目录文件路径
f.getParent(); 3️⃣获取File对象的纯文件名字
f.getName(); 4️⃣获得File对象的相对路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d721b917da9bb02e1958d5f5743fce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544ba70e0a365272562282f6a5c797f0/" rel="bookmark">
			【Java】获取某年某月有多少天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【Java】获取某年某月有多少天 效果 代码 package com.cxl; import java.util.Calendar; import java.util.Scanner; //获取某年某月有多少天 public class Demo18_Date { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print("请输入年："); int year = sc.nextInt(); System.out.print("请输入月："); int month = sc.nextInt(); Calendar c = Calendar.getInstance(); c.set(year,month,1); //1为1日 //java月份从0开始，输入的月份比实际得到的月+1，即month值+1月1日 //如，输入的是3月，输出的为4月 c.add(Calendar.DATE,-1); //-1为减1天，即month值+1月1的前一天，此时可得到想要的正确的月份 int day = c.get(Calendar.DATE); System.out.println(year+"年"+month+"月"+"有"+day+"天"); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1fc25a2a26f09a92e8607e6693f907/" rel="bookmark">
			python：下载精美壁纸--学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人学习记录
一、效果展示
这里贴一个还不错的某壁纸网：Wallpaper Abyss - HD Wallpapers, Background Images
下载的结果展示：
下载进度展示：
二、完整代码
代码中给定了部分注释
import os import re import urllib.request from concurrent.futures import ThreadPoolExecutor import requests import tqdm as tqdm from bs4 import BeautifulSoup head = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36" } def getPage(url): # 获取通过BeautifulSoup美化过的网页 req = urllib.request.Request(url=url, headers=head) html = "" try: response = urllib.request.urlopen(req) html = response.read() page = BeautifulSoup(html, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1fc25a2a26f09a92e8607e6693f907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d4bc7b2ccfdff910d56bdae436974c/" rel="bookmark">
			MR-GMMapping:基于高斯混合模型的通信高效多机器人映射系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 论文III. 通过高斯混合模型建图（MAPPING VIA GAUSSIAN MIXTURE MODELS）IV. 多机器人GMM建图（MULTI-ROBOT GMM MAPPING）A. GMM子地图建立（GMM Submap Construction）B. 自适应模型选择（Adaptive Model Selection） V. GMM地图的应用（APPLICATIONS WITH GMM MAP）A. GMM位置识别（GMM Place Recognition）B. GMM地图注册（GMM Map Registration）C. 基于GMM的局部规划器（GMM-Based Local Planner） VI. 实验（EXPERIMENTS）A. 地点识别（Place Recognition）B. 地图注册（Map Registration）C. 基于GMM的局部规划（GMM-Based Local Planner）D. 多机器人系统中的数据传输（Data Transmission in Multi-Robot System） VII. 结论与未来工作（CONCLUSION AND FUTURE WORK） 工程配置依赖使用案例Single Robot Map BuildingMulti-robot Relative Pose Estimation 原文： 论文 III. 通过高斯混合模型建图（MAPPING VIA GAUSSIAN MIXTURE MODELS） GMM是一种使用不同加权高斯分布来表示某些概率分布的概率模型。GMM的概率密度函数定义为
p ( x ) = ∑ k = 1 N π k N ( x ∣ μ k , Σ k ) ( 1 ) p(x)=\sum_{k=1}^N \pi_k \mathcal{N}\left(x \mid \mu_k, \Sigma_k\right) \quad \quad(1) p(x)=k=1∑N​πk​N(x∣μk​,Σk​)(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d4bc7b2ccfdff910d56bdae436974c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/734de98f2f59984a94cc2d280233e275/" rel="bookmark">
			C&#43;&#43; 异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、异常的定义
二、异常的抛出和捕获
1.throw
2.try...catch
3.异常安全
4.异常规范
三、系统预定义异常
四、用户自定义异常
一、异常的定义 异常在C++用于错误处理，C语言中一般使用返回值表示错误，C++对错误处理进行了扩展，统一使用异常机制来处理程序中发生的错误。
C语言异常处理机制
①终止程序。缺陷：用户难以接受。如发生内存错误，除0错误时就会终止程序。
②返回错误码。缺陷：需要程序员自己去查找对应的错误。如系统的很多库的接口函数都是通过把错误码放到errno中，表示错误。
③C标准库中setjmp和longjmp组合
C++的异常处理包括两个部分：抛出异常和捕获异常，如果抛出的异常被捕获，处理完之后程序会继续运行，如果抛出的异常未被捕获，将导致程序终止。
二、异常的抛出和捕获 异常是面向对象语言常用的一种处理错误的方式，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数直接或间接的调用者处理这个错误。
throw：当程序出现问题时，可以通过throw关键字抛出一个异常。try：try块中放置的是可能抛出异常的代码，该代码块在执行时将进行异常错误检测，try块后面通常跟着一个或多个catch块。catch：如果try块中发生错误，则可以在catch块中定义对应要执行的代码块。 1.throw throw是用于抛出异常的关键字，用法如下：
throw 异常(对象);
在函数声明中应该指定可能抛出的异常，应该在函数声明指定。
void show(); //该函数可能抛出任何异常
void show()throw(); //该函数不抛出任何异常
void show()throw(char,int); //该函数可能抛出char和int型异常 2.try...catch 捕获异常使用try...catch关键字，用法如下：
try{ //可能抛出异常的代码 }catch(异常类型1 变量){//根据类型捕获异常 //处理异常类型1的代码 }catch(异常类型2 变量){//根据类型捕获异常 //处理异常类型2的代码 //throw 变量 ----- 继续向上一层抛出 }..... 异常被捕获后，执行对应的异常处理代码，然后继续执行try...catch之后的代码。若异常未被捕获，仍然导致程序终止。捕获异常后，如果当前无法处理，可以继续抛出。
异常的抛出和捕获的匹配原则：
①异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码，如果抛出的异常对象没有捕获，或是没有匹配类型的捕获，那么程序会终止报错。
②被选中的处理代码（catch块）是调用链中与该对象类型匹配且离抛出异常位置最近的那一个
③抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁
④catch(...)可以捕获任意类型的异常，但捕获后无法知道异常错误是什么。
⑤实际异常的抛出和捕获的匹配原则有个例外，捕获和抛出的异常类型并不一定要完全匹配，可以抛出派生类对象，使用基类进行捕获，这个在实际中非常有用
在函数调用链中异常栈展开的匹配原则：
①当异常被抛出后，首先检查throw本身是否在try块内部，如果在则查找匹配的catch语句，如果有匹配的，则跳到catch的地方进行处理。
②如果当前函数栈没有匹配的catch则退出当前函数栈，继续在上一个调用函数栈中进行查找匹配的catch。找到匹配的catch子句并处理以后，会沿着catch子句后面继续执行，而不会跳回到原来抛异常的地方。
③如果到达main函数的栈，依旧没有找到匹配的catch，则终止程序。
void func1() { throw string("这是一个异常"); } void func2() { func1(); } void func3() { func2(); } int main() { try { func3(); } catch (const string&amp; s) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/734de98f2f59984a94cc2d280233e275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a658c77164a7351b63a1b08db5c8f933/" rel="bookmark">
			[转]运放电流检测采样电路电压采样电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入输出电压检测 输入输出电压通过运放LMC6482采用差分电路将输出电压按比例缩小至ADC能够采样的范围，再使用ADC采样，软件解算出输出电压。输入电压采样是通过MCU内部运放按比例缩小在送到ADC进行采样的，具体电路如图3.5.1所示。输出电压检测电路如图3.4.1所示。
输出电流检测➢ 输出电流检测电路通过运放LMC6482采样差分放大电路实现；采样电阻放在低端，若采样电阻放在高端，会有较大的共模电压使采样电流不准确，采样电阻为10m𝛺，由于采样电阻较小，采样电阻上的压降较小，不利于直接采样，需要放大后再采样；输出电流检测电路如图3.4.2所示。
1、低端运放电流检测方法：
分析下原理：
运用运放的虚短特性，既得到了：
V+ = V-；
运用运放的虚断特性，既输入端和输出端没有电流流过。所以R3和R6流过电流相等。
(VOUT-V-)/R3 = V-/R6；
由上面两个式子即可得到
VOUT = V+ * (R3 + R6)/R6；
而又有：
V+ = I * R8；
所以有：
I =V+ / R8 = VOUT * R6/(R3 + R6)/R8；
电流就这样转换出来了，调整好几个电阻的阻值，Vout 用单片机的ADC采样即可。
2、高端电流检测电路
这个电路要检测电流最终的目的就是要得到图上VOUT和V1、V2的关系。
先来分析下输入端，虚断可知：
V+/R7 = （V2-V+)/R5；
虚短得到：
V+=V-；
输入负极的一条路电流是相等的:
（V--VOUT)/R1 = （V1-V-)/R2；
通常在使用该电路的时候有R1 = R7、R2 = R5。
综合上式有：
VOUT = (V2-V1)*R1/R2；
V2-V1 = I*R4;
所以 I = VOUT*R2/(R1*R4) ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a658c77164a7351b63a1b08db5c8f933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/575ba39cdec0cc65ad46a6bdc546b165/" rel="bookmark">
			Excel文件读取解析数据-sheetJs插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网：https://github.com/SheetJS/sheetjs#the-zen-of-sheetjs官网： 读取excel XLSX.read(data,{
type: "binary" // 申明data 格式
})
/* 示例 以file类型读取 */ const reader = new FileReader(); reader.readAsBinaryString(file); reader.onload = function(){ const excelFile = XLSX.read(this.result, { type: 'binary' //以二进制读取 }); } /* 得到的是文件流，而非file类型时 */ /* 转为file 类型 */ let fileName = "试验站环境数据.xlsx" let file = new File([data], fileName); 解析表格方法 1.XLSX.utils.sheet_to_json(excelFile.Sheets['Sheet1']) 解析为json格式
2.XLSX.utils.sheet_to_html(excelFile.Sheets['Sheet1']) 解析为html格式
3.
encode_row / decode_row 转化行号
encode_col / decode_col 转化列号
encode_cell / decode_cell 转化单元格号
encode_range / decode_range 转化表格范围
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/575ba39cdec0cc65ad46a6bdc546b165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6934197612c2f053d0e0b1c597c7888/" rel="bookmark">
			mybatis-plus的Page分页配置与操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用Page分页前需要对配置文件进行操作
例如创建配置类：MybatisPlusConfig，并添加配置类注解 @Configuration
写入分页插件配置：
public class MybatisPlusConfig{ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 2.在控制层进行分页设代码置
Page&lt;E&gt; page = new Page&lt;&gt;(current,size);
current：指最开始的页数，例如填写 1 ，那么之后会从分页后的第一页开始获取数据。
size：指每一页的数据条数，例如填写10，那么每一页的数据都会呈现10条。
3.进行分页数据配置
pageMapper.selectPage(page,queryWrapper)
pageMapper：dao层数据接口
page：分页代码设置对象
queryWrapper：实体对象封装操作类
4.有关page的方法
page.getRecord() //获取当前页记录
page.getPages() //获取总分页数
page.getTotal() //获取数据总记录数
page.getNext() //获取是否有下一页
page.getPrevious() //获取是否有上一页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b7808dacc94bcdc3839c33a6cdb75b/" rel="bookmark">
			centos8安装中文（zh_CN）语言包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看当前语言字符集
查看指令：locale
查看是否存在中文字符集：zh_CN
管道指令：locale -a |grep zh_CN
如果不存在输入安装：yum install -y langpacks-zh_CN
安装后查看配置并修改为中文字符集
vi /etc/locale.conf
LANG=zh_CN.UTF-8
修改后重启即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77fb04a86947a8065e91cfc03560d55/" rel="bookmark">
			解决浏览器 require is not defined 的报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因 在node环境中引入了一些包，用webpack打包后放在浏览器环境中，浏览器报错require is not defined。
这是因为require是node环境下的CommonJs，而import是浏览器环境下的ESModule。ESModule不认识require。
require是node的一个私有的全局方法。
解决方法 那就让打包出来的代码别有require，换句话说，webpack应该打包出一个适用于ES6环境下的代码。
只需在webpack.config.js中，将原来的target: 'node'改成target: 'web'即可。
热知识 export / export default + import ===》 ES6
module.exports / exports + require ===》CommonJS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cce0dafc68bd94b630d675d2c2862eb/" rel="bookmark">
			调整图片大小和像素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求限制上传文件的大小，有时候照片的大小太大，怎么调整大小呢？
windows用户来说，只需要利用Windows系统自带的工具就可以完成，当然，如果需要专业的高质量的图片，就需要专业的软件处理了。
1.右键单击图片，查看属性，图片大小
2.右键图片，选择编辑
3.打开一张图片，如图
4.选择重新调整大小
5.选择像素，保持纵横比对去掉（水平、垂直任意定义图片大小）
完成！ 检查！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d520313c87e2cad018965f904d722e0/" rel="bookmark">
			java里的Object
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Object对象 1.2 java创建对象的四种方式 java程序中对象的创建有四种方式：
● 调用new语句创建对象，最常见的一种
● 运用反射手段创建对象,调用java.lang.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法
● 调用对象的clone()方法
● 运用序列化手段,调用java.io.ObjectInputStream 对象的 readObject()方法,其实就是一种深拷贝
@see https://www.cnblogs.com/avivahe/p/5702132.html
二、hashcode与equals 2.1 hashcode定义 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。
这个哈希码的作用是确定该对象在哈希表中的索引位置。
hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有
hashCode() 函数。
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。
这其中就利用到了散列码！（可以快速找到所需要的对象）
让同一个类的对象按照自己不同的特征尽量的有不同的哈希码，但不表示不同的对象哈希码完全不同。在Java中，哈希码代表对象的特征。
注意：有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。
hashCode方法的作用：
增加查询速度。快速判断对象是否不相等。
2.2 equals方法实现原理 先比较两个对象的hashCode，然后比较两个对象所指向的值
可以对照散列表的数据结构理解，hashcode值相当于桶的索引值，equals方法主要是判断在相同索引值下，遍历链表的值是否相同。
Object.equals方法实质就是判断对象的存储地址。
源码如下：
public boolean equals(Object obj) { return (this == obj); } String中的equals方法其实重写了Object.equals方法
源码如下:
public boolean equals(Object anObject) { if (this == anObject) {//先进行地址比较 return true; } if (anObject instanceof String) {//接着判断是否为string类，下面为字符比较 String anotherString = (String)anObject; int n = value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d520313c87e2cad018965f904d722e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8047832f86aeb0753eab7b4787c6016/" rel="bookmark">
			(附源码)计算机毕业设计SSM-在线作业管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 系统设计目标 在线作业管理系统主要是为了用户方便对课程信息、课程作业、校园公告等信息进行查询，也是为了更好的让管理员进行更好存储所有数据信息及快速方便的检索功能，对系统的各个模块是通过许多今天的发达系统做出合理的分析来确定考虑用户的可操作性，遵循开发的系统优化的原则，经过全面的调查和研究。
系统所要实现的功能分析，对于现在网络方便的管理，根据自己的需求可以进行查看信息等，这样既能节省用户的时间，不用在像传统的方式，需要查询、由于很多用户时间的原因，没有办法去了解，真的很难去满足用户的各种需求。所以在线作业管理系统的开发不仅仅是能满足用户的需求，还能提高管理员的工作效率，减少原有不必要的工作量。
3.2 系统可行性分析 系统的开发环境和配置都是可以自行安装的，系统使用Java开发工具，使用比较成熟的Mysql数据库进行对系统前台及后台之间相关的数据交互，根据技术语言对数据库，结合需求进行修改维护，可以使得系统运行更具有稳定性和安全性，从而完成实现系统的开发。
（1）硬件可行性分析
在线作业管理系统及信息分析的设计对于所使用的计算机没有什么硬性的要求，计算机只要可以正常的使用进行代码的编写及页面设计就可行，主要是对于服务器有些要求，对于平台搭建完成要上传的服务器是有一定的要求的，服务器必须选择安全性比较高的，然后就是在打开系统必须顺畅，不能停顿太长时间；性价比高；安全性高。
（2）软件可行性分析
开发整个系统使用的是云计算，流量的可扩展性和基于流量的智能调整云计算的优点就是流量的可扩展性和基于流量的智能调整，保障系统的安全及数据信息的及时备份。
因此，我们从两个方面进行了可行性研究，可以看出系统的开发没有问题。
3.3 系统功能分析和描述 使用在线作业管理系统分为管理员和学生、教师三个角色的权限子模块。
管理员所能使用的功能主要有：首页、个人中心、课程管理、教师管理、学生管理、课程信息管理、课程作业管理、学生选课管理、学生作业管理、作业评分管理、管理员管理、系统管理等。
学生可以实现首页、个人中心、学生选课管理、学生作业管理、作业评分管理、我的收藏管理等。
教师可以实现首页、个人中心、课程信息管理、课程作业管理、学生选课管理、学生作业管理、作业评分管理等。
3.4系统UML用例分析 3.4.1管理员用例 管理员登录后可进行首页、个人中心、课程管理、教师管理、学生管理、课程信息管理、课程作业管理、学生选课管理、学生作业管理、作业评分管理、管理员管理、系统管理，管理员的用例如图3-1所示。
图3-1 管理员用例图
3.4.2学生用例 学生注册登录后可进行首页、个人中心、学生选课管理、学生作业管理、作业评分管理、我的收藏管理，学生用例如图3-2所示。
图3-2 学生用例图
3.5系统流程分析 3.5.1添加信息流程 添加信息,编号系统使用自动编号模式,没有用户填写,用户添加信息输入信息,系统将自动确认的信息和数据,验证的成功是有效的信息添加到数据库,信息无效,重新输入信息。添加信息流程如图3-4所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8047832f86aeb0753eab7b4787c6016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef713eeaf25b498df71bc023a204110/" rel="bookmark">
			【滤波器设计】FIR滤波器和IIR滤波器的高通、低通、带通滤波器的设计，以及频率响应附Matlab代码和报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器
信号处理 图像处理 路径规划 元胞自动机 无人机
⛄ 内容介绍 一、设计题目
应用Matlab对语音信号进行频谱分析及滤波。
二、设计目的
数字信号处理是一门以算法为核心，理论和实践性较强的学科。是电子信息工程、通信工程专业、电子信息科学与技术专业的一门重要的专业技术基础课。数字信号处理课程是在学习完数字信号处理的相关理论后，进行的综合性训练课程，其目的是：使学生进一步巩固数字信号处理的基本概念、理论、分析方法和实现方法；增强学生应用Matlab语言编写数字信号处理的应用程序及分析、解决实际问题的能力。
三、设计内容
1语音信号的采集
利用Windows下的录音机，录制一段自己的话音，时间在1 s内。然后在Matlab软件平台下，利用函数wavread对语音信号进行采样，记住采样频率和采样点数。通过wavread函数的使用，学生很快理解了采样频率、采样位数等概念。
2语音信号的频谱分析
首先画出语音信号的时域波形；然后对语音号进行快速傅里叶变换，得到信号的频谱特性，从而加深学生对频谱特性的理解。
3设计数字滤波器和画出其频率响应
给出各滤波器的性能指标：
(1)低通滤波器性能指标fb＝1 000 Hz，fc＝1 200 Hz，As＝100 dB，Ap＝1 dB。
(2)高通滤波器性能指标fc＝4 800 Hz，fb＝5 000 Hz As＝100 dB，Ap＝1 dB。
(3)带通滤波器性能指标fb1＝1 200 Hz，fb2＝3 000 Hz，fc1＝1 000 Hz，fc2＝3 200 Hz，As＝100 dB，Ap＝1 dB。
用窗函数法和双线性变换法设计上面要求的3种滤波器。在Matlab中，可以利用函数fir1设计FIR滤波器，可以利用函数butte，cheby1和ellip设计IIR滤波器；利用Matlab中的函数freqz画出各滤波器的频率响应。
4用滤波器对信号进行滤波
用自己设计的各滤波器分别对采集的信号进行滤波，在Matlab中，FIR滤波器利用函数fftfilt对信号进行滤波，IIR滤波器利用函数filter对信号进行滤波。
5比较滤波前后语音信号的波形及频谱
在一个窗口同时画出滤波前后的波形及频谱。
6回放语音信号
在Matlab中，函数sound可以对声音进行回放。其调用格式：sound(x，fs，bits)；可以感觉滤波前后的声音有变化。
7设计系统界面
为了使编制的程序操作方便，要求设计处理系统的用户界面。在所设计的系统界面上可以选择滤波器的类型，输入滤波器的参数，显示滤波器的频率响应，选择信号等。
⛄ 部分代码 fb=1000;fc=1200;As=100;Ap=1;fs=22050;
[x1,Fs]=audioread('D:\matlab\sound.wav');
wc=2*pi*fc/fs; %通带截止频率
wn=2*pi*(fc-fb)/fs; %过渡带宽
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fef713eeaf25b498df71bc023a204110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d343fc136b89ec1159d3005f31231844/" rel="bookmark">
			GlobalMapper小白学习日记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载链接 羽兔网https://www.yutu.cn/softhtml/showsoft_5131.html该链接是百度网盘存储，自行下载，较为安全，不用装乱起七八糟的下载器。
本人下载的是22.0版本，网站有傻瓜式安装教程可以参考。
2.创建选区 由于本人需要制作遥感图像数据集，需要大量图像，一张一张裁剪显然不现实。需要进行批量裁剪并导出。一顿百度也百度不到，甚至都要去找脚本了就是说，后来发现人家叫批量分幅我真的会谢。
首先需要加载图源，打开GlobalMapper，需要连接图源，这里图源来自工作中常用的这个软件可直接下载谷歌影像
（1）点击File，Download Online Images…如图
（2）选择Add New Source，并选择OSM，OK。
（3）添加谷歌卫星影像URL（2022年最新，不知道几月份的）然后OK：
http://gac-geo.googlecnapps.cn/maps/vt?lyrs=s&amp;x=%x&amp;y=%y&amp;z=%z
（4）随便起个名，我这里叫Google图源
（5）添加成功后这里会显示，选中后点击connect即可，添加成功后会在主界面显示谷歌影像
2.可以开始创建选区啦！这里需要注意的是，默认是红色框框的放大镜，点击某处即可直接将相应区域放大，绿色的手手是可以抓取移动的，滑动鼠标滚轮即可放大。
（1）选择创建选区的工具，从左至右依次是 点状区域，直线区域，曲线区域，多边形区域，矩形/方形区域，圆形区域。我这里选择的是矩形区域。
点击矩形区域工具这里会蹦出来一个对话框，无脑OK即可。
（2）随便创建选区，（默认创建矩形选区，若要创建方形选区，选择的同时按住shift键即可）这里需要给此选区和选区层起个名。OK即可。
（3）点击数字工具，需要选中选区才能下载指定选区
（4）此时点击选区中间，即可选中选区。若要同时选中多个选区，按住shift键即可。
3.选中完要下载的区域啦，下一步就是下载啦 1.点击顺序如图所示
2.这里可以选择导出格式，我这里先选择的是jpg文件，tif文件太大啦下载好慢的。
3.其它选项暂且默认，Tiling选择Use Selected Area Features for Tiles然后OK即可，需要稍等一会子哦。
若选择tif格式，这里最好换成24bit（目前为止我也不知道为什么好多教程都这么换了）
这里会蹦出来一个所选区域导出的命名格式，我默认选择的是如下选项。我理解的是一种命名格式，没试过这几个有何不同。
OK了的话这里会显示如下对话框，大意是是否要包含边界，（我理解的是当多边形或其它形状选择时，下载的图像是否要扩展为最大直径的矩形），我这里就是矩形选区应该没必要纠结这个
为文件命名导出即可
其它直接导出单张图像方法 可以选择在这里绘制选区，导出时默认导出这里画的选区。
选择这个选项导出的是当前整个背景板上显示的图像
别的没试过啦，就到这里啦 这里顺便提一下保存workspace，要不下次打开的时候就全没啦！ 选save workspace，给你的workspace选个储存地址，起个名完事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f9db7d4f19e7eb0672e18cc640c08b/" rel="bookmark">
			Spring工具类：FileCopyUtils、StreamUtils
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 FileCopyUtilsStreamUtils参考资料 Spring 在 org.springframework.util 包提供了很多实用的工具类。今天关心一下Copy 相关的两个：
FileCopyUtils FileCopyUtils就是对StreamUtils的copy方法进行了封装，在每次复制完毕后关闭流。（因为StreamUtils在复制完成后流都是保持打开的。）
修饰符返回值方法介绍staticvoidcopy(byte[] in, File out)将给定字节数组的内容复制到给定输出文件。staticvoidcopy(byte[] in, OutputStream out)将给定字节数组的内容复制到给定的OutputStream。staticintcopy(File in, File out)将给定输入File的内容复制到给定输出File。staticintcopy(InputStream in, OutputStream out)将给定的InputStream的内容复制到给定的OutputStream。staticintcopy(Reader in, Writer out)将给定Reade的内容复制到给定Writer。staticvoidcopy(String in, Writer out)将给定String的内容复制到给定Writer。staticbyte[]copyToByteArray(File in)将给定输入File的内容复制到一个新的字节数组中。staticbyte[]copyToByteArray(InputStream in)将给定的InputStream的内容复制到一个新的字节数组中。staticStringcopyToString(Reader in)将给定Reader的内容复制到String中。 StreamUtils import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.FilterInputStream; import java.io.FilterOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.UnsupportedEncodingException; import java.io.Writer; import java.nio.charset.Charset; import org.springframework.lang.Nullable; import org.springframework.util.Assert; import org.springframework.util.FileCopyUtils; /** * 处理流的简单实用方法。 此类中与 {@link FileCopyUtils} 的 copy 方法区别在于，不会关闭流。 * 所有 copy 方法的缓冲区大小都是 4096 字节。 * * &lt;p&gt;主要用于Spring框架, 但对于应用级别代码也很有用。 * @see FileCopyUtils */ public abstract class StreamUtils { /** * 用于 copy 的默认缓冲区大小.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f9db7d4f19e7eb0672e18cc640c08b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08b9bbb4f08521d336d0a18d126fa58/" rel="bookmark">
			风车im即时通讯源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.宝塔环境如下:
Nginx 1.20Tomcat 8
MySQL 8.0
Redis 7
2.放行端口如下：666660067007000（用作前端）7001（用作后端）
3.宝塔数据库添加数据库旁边有个root密码修改，然后导入数据库
数据库 用户名 fcim
密码 fcim
4.后端安装如下：后端文件server上传到opt目录5.启动命令如下：
server目录下终端命令nohup java -jar fcim.jar &gt; fcim.out 2&gt;&amp;1 &amp;
6.网页端安装如下：fcim上传到wwwroot下解压新建两个站点ip:7000和ip:7001ip:7000运行路径fcim/adminip:7001运行路径fcim/h57.nginx.conf文件配置如下：nginx前端 后端配置文件 分别复制到站点配置文件里配置文件里有两个地方填写自己的ip 8.安卓用mt管理器修改ip以及图标搜114.132.244.57这个ip替换掉 前端http://你自己ip:7000后端http://你自己ip:7001账号admin密码123456源码下载：https://pan.baidu.com/s/1Zx_KMwhwZqWvEM5xDWMTqw 提取码：0660
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc1b146ec7f02cffbc3a461ec1aa721/" rel="bookmark">
			【C】目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ch0 idech01 变量和数据结构ch02 格式化与流程控制ch03 数组ch04 函数ch05 指针ch06 关于C语言的内存布局ch07 复合结构ch08 文件处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41eaa7403f634713f3757dcaff3e9e1/" rel="bookmark">
			自用Linux电脑改装为自用小型服务器及使用入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我使用的Linux系统为Ubuntu，其它版本的Linux系统方法近似
1. 这样做有什么好处？ 首先我强调的是自用小型服务器，这表明自用的电脑性能有限。在日常的生活学习中使用linux有诸多不便，然而有些软件需求又必须在linux环境下才能实现，我们就会思考如果能在普通电脑上远程操作自己的linux那就比较理想了。
2.配置ssh 安装ssh服务端 sudo apt-get install ssh* 激活ssh服务 sudo service ssh start 查看ssh运行状态 sudo service ssh status 如下图Active: active (running) 表示运行正常
按q退出运行状态查看
打开ssh远程登陆root权限 sudo gedit /etc/ssh/sshd_config 将PermitRootLogin 权限改为yes
#LoginGraceTime 2m PermitRootLogin yes #PermitRootLogin prohibit-password #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 查看linux系统ip sudo apt install net-tools 安装好net-tools后输入ifconfig查看ip
ifconfig inet后面紧接的数字即为你的ip
3.在其它设备上通过ssh远程控制你的linux电脑 先打开终端 不需要调动应用程序图形界面的情况 ssh 用户名@ip //用户名为linux系统下/home下的用户，ip为上步操作查看的ip 需要调动应用程序图形界面的情况 ssh -X 用户名@ip //用户名为linux系统下/home下的用户，ip为上步操作查看的ip 要求输入的是对应linux账户的密码
4. 附 打开linux开机自启ssh服务
sudo systemctl enable ssh 关闭linux开机自启ssh服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41eaa7403f634713f3757dcaff3e9e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd11daf4d56c097c9726119a6fdde178/" rel="bookmark">
			网络编程（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络编程的概念网络模型OSI 七层模型七层模型释义通信特点 TCP/IP 五层模型区别 网络编程的目的网络编程中的两个要素 IP 地址IP 地址类型IP 地址 `Java Object` 端口号端口号分类使用规则IP 套接字 `Java Object` 通信协议TCP/IP 协议簇TCP 同 UDP 对比三次握手（TCP连接过程）四次挥手（TCP断开链接） TCP实现聊天服务端客户端 实现文件上传服务端客户端 UDP实现消息发送接收端发送端 多线程实现聊天发送方线程类接收方线程类单元测试类 URL基本构成下载资源 BS架构服务器案例BS结构服务器代码实现BS结构服务器代码实现(多线程版本) 网络编程的概念 地球村
随着广播、电视、互联网的出现，随着各种现代交通方式的飞速发展，人与人之间的时空距离骤然缩短，整个世界紧缩成一个“村落”。
地球村也译为世界村(global village)，对地球的一种比喻说法。现代科技的迅速发展，缩小了地球上的时空距离，国际交往日益频繁便利，因而整个地球就如同是茫茫宇宙中的一个小村落。
计算机网络
计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。
计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。
数据通信
是计算机网络的最主要的功能之一。数据通信是依照一定的通信协议，利用数据传输技术在两个终端之间传递数据信息的一种通信方式和通信业务。它可实现计算机和计算机、计算机和终端以及终端与终端之间的数据信息传递，是继电报、电话业务之后的第三种最大的通信业务。数据通信中传递的信息均以二进制数据形式来表现，数据通信的另一个特点是总是与远程信息处理相联系，是包括科学计算、过程控制、信息检索等内容的广义的信息处理。
网络编程从大的方面说就是对信息的发送到接收，中间传输为物理线路的作用。
网络编程最主要的工作就是在发送端把信息通过规定好的协议进行组装包，在接收端按照规定好的协议把包进行解析，从而提取出对应的信息，达到通信的目的。中间最主要的就是数据包的组装，数据包的过滤，数据包的捕获，数据包的分析，当然最后再做一些处理，代码、开发工具、数据库、服务器架设和网页设计这5部分你都要接触。
网络模型 https://blog.csdn.net/troubleshooter/article/details/122376824 网络是一个复杂的系统，不仅包括大量的应用程序、端系统、通信链路、分组交换机等，还有各种各样的协议组成。
为了给网络协议的设计提供一个结构，网络设计者以分层(layer)的方式组织协议，每个协议属于层次模型之一。每一层都是向它的上一层提供服务(service)，即所谓的服务模型(service model)。每个分层中所有的协议称为协议栈(protocol stack)。
OSI 七层模型 OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。
OSI 定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。
每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。
七层模型释义 OSI 参考模型功能定义设备协议数据单元应用层为应用程序提供服务应用程序HTTP，HTTPS，FTP，POP3、SMTP、Telnet、SSH、DHCP、DNS数据(Data)表示层数据格式转换和加密———会话层建立、管理和维护会话———传输层建立、管理和维护端到端的连接进程、端口TCP、UDP数据段(Segment)网络层IP地址及路由选择路由器、交换机、防火墙IP、ARP、ICMP、IGMP数据包(Packet)数据链路层提供介质访问和链路管理网桥、以太网交换机、网卡ARP、RARP、IEEE802.3、PPP、CSMA/CD数据帧(Frame)物理层传输介质中继器、集线器、双绞线FE自协商 Manchester MLT-3 4A PAM5数据位(bit) 应用层
OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。
实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。
表示层
表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。
由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。
会话层
会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd11daf4d56c097c9726119a6fdde178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251637af81c06e39d1d9604d6c27f4c9/" rel="bookmark">
			Mask Rcnn详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mask RCNN 算法详解 Mask RCNN介绍模型结构及数据变化推理backbone(FNP)RPNROI Align预测头（ box, class, mask）box, class分支mask分支 模型训练流程模型推理（测试）流程（补充）损失计算 Mask RCNN介绍 Mask R-CNN是何恺明在ICCV 2017上发表的实例分割模型（Instance segmentation），实例分割主要在目标检测的基础上获得每个目标的分割掩码。
模型结构及数据变化推理 模型基本结构由：backbone(FPN)+RPN+RoI Align+预测头（ box, class, mask）几部分组成，输入图像，输出预测的目标类别（class）、目标位置框(box)、基于目标框的掩码(mask)三部分，为便于理解模型使用中数据的变化，本文忽略batch这一维度，相当于直接输入一张图像进行数据推理。
backbone(FNP) backbone：骨干网络，通过一系列卷积池化+残差拼接，获得图像的深度特征信息（feature map）
FNP：特征金字塔，在骨干网络卷积过程中，其中间层会产生不同尺度的特征信息 ，大小分别为原图大小的1/4,1/8,1/16,1/32,1/64，这些尺度不同、深度不同的特征信息更利于全面获取图像的高低维度信息，将这些选择不同尺寸的特征信息共同称为特征金字塔，也就是后续要利用的feature map。
输入：图像 [3, image_height, image_weight]
最后输出：[channe, 1/4image_height, ,1/4image_weight]……[channe, 1/64image_height, ,1/64*image_weight] 代表5个尺度的特征量，其中channe代表特征通道数。
RPN RPN：Region Proposal Network，用于利用backbone产生的feature map 生成感兴趣区域候选框Proposal ，感兴趣区域就是可能有目标的区域
输入：back bone的输出，[channe, 1/4image_height, , 1/4*image_weight ] ……，
输出：卷积生成两束分支，分别是bbox,class 共同代表候选框信息，它们是成对出现的，个数是一系列候选框，这些候选框经过非极大值抑制等筛选才会形成真正的候选框，真正候选框才有id(ROI_id)
（1）bbox：now_height, now_weight, k, 4
（2）class：now_height, now_weight, k, 2
上述公式代表在输入图上每个像素点上产生K个候选框，now_heigh指的输入的特征的尺度宽高。K一般是3，代表3个锚框（anchor），数字4代表预测的anchor的放缩比例，数字2代表该候选框是否含有目标（0,1），即前景和背景的概率，该输出信息除了用于向后传递，还参与损失计算。
RPN处理后的输出bbox和class 和生成的所有anchor进行进一步处理：
用class输出进行得分排序筛选，获得6000个得分靠前的anchor
用bbox输出对筛选后的anchor进行回归纠正，得到更准确的anchor
删除不合理的anchor,如超出原图的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/251637af81c06e39d1d9604d6c27f4c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef194d754061e2db6a1ec246f705de4/" rel="bookmark">
			Git的配置、使用及常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置git 1.鼠标右键文件夹(准备提交至git仓库的文件所在文件夹)点击Git Bash Here 打开git
2.配置用户名和邮箱
$ git config --global user.email "你的邮箱" $ git config --global user.name "你的用户名" 2.上传至远程仓库 //在当前目录新建一个Git代码库 $ git init //添加当前目录的所有文件到暂存区 $ git add . //添加当前目录的update.sql文件到暂存区 $ git add update.sql //提交暂存区到仓库区 $ git commit -m “提交信息” //增加一个新的远程仓库，并命名 (URL是刚刚保存的URL） $ git remote add origin http://gitea.33cloudsoft.com:3000/chengguangxin/chengguangxin-repository.git //上传本地指定分支到远程仓库 $ git push origin master git查看结果
3.常用命令 //提交 $ git add update.sql $ git commit -m “提交信息” $ git push origin master //拉取 $ git pull origin master //查看记录 $ git log //回滚代码 $ git reset --hard [commit的编号] 注意：此时只是本地仓库回滚，根据情况判断是否提交至远程仓库，提交时需进行强制提交操作进行回滚
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ef194d754061e2db6a1ec246f705de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f883a14cda033e0f06b79bea67c165/" rel="bookmark">
			MinIO分布式储存简介以及整合SpringBoot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MinIO介绍以及springBoot整合什么是MinIO？应用场景特点 安装MinIO获取镜像启动镜像图形界面操作 Spring Boot 整合MinIO 上传文件获取accessKey和secretKey添加依赖添加配置新建上传文件接口测试 总结附录MinIO工具类 MinIO介绍以及springBoot整合 什么是MinIO？ Minio 是个基于 Golang 编写的开源对象存储套件，基于Apache License v2.0开源协议，虽然轻量，却拥有着不错的性能。它兼容亚马逊S3云存储服务接口。可以很简单的和其他应用结合使用，例如 NodeJS、Redis、MySQL等。
应用场景 MinIO 的应用场景除了可以作为私有云的对象存储服务来使用，也可以作为云对象存储的网关层，无缝对接 Amazon S3 或者 MicroSoft Azure 。
)]
特点 高性能：作为一款高性能存储，在标准硬件条件下，其读写速率分别可以达到 55Gb/s 和 35Gb/s。并且MinIO 支持一个对象文件可以是任意大小，从几kb到最大5T不等。
可扩展：不同MinIO集群可以组成联邦，并形成一个全局的命名空间，并且支持跨越多个数据中心。
云原生：容器化、基于K8S的编排、多租户支持。
Amazon S3兼容：使用 Amazon S3 v2 / v4 API。可以使用Minio SDK，Minio Client，AWS SDK 和 AWS CLI 访问Minio服务器。
SDK支持：
GO SDK：https://github.com/minio/minio-goJavaSDK：https://github.com/minio/minio-javaPythonSDK：https://github.com/minio/minio-py 图形化界面：有操作页面
支持纠删码：MinIO使用纠删码、Checksum来防止硬件错误和静默数据污染。在最高冗余度配置下，即使丢失1/2的磁盘也能恢复数据。
“
功能很强大，本文只是抛砖引玉，有兴趣的朋友自己去探索吧~
”
安装MinIO 安装非常简单，笔者这里使用docker安装，步骤如下：
获取镜像 执行命令如下：
docker pull minio/minio 启动镜像 执行命令如下：
docker run -p 9000:9000 -p 9001:9001 --name minio -d --restart=always -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f883a14cda033e0f06b79bea67c165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f72fd5a58e84215f0a437c2c057beda/" rel="bookmark">
			vuex中的this.$store.commit和dispatch()使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要用vuex？ 在vue的项目里常常会遇到父子组件间需要进行数据传递的情况，我们可以用熟悉的props 或者 $emit 等方式进行父子组件通信，但是，在项目稍微大一点的情况中，面对众多的不相关的平行组件，并且很多数据需要多个组件循环使用，这个时候在这些组件间传递数据，使用上述方法会比较麻烦，项目代码变得冗长，并且不利于组件的复用，提高了耦合度。
为了解决这一问题，我们需要使用Vue 的状态管理工具 Vuex
Vuex好处：
既使非父子组件间的数据共享也能变得简单明了让程序变得更加可维护（将数据抽离了出来）只要仓库里面的数据发生了变化，在其他组件里面数据被引用的地方也会自动更新 二、使用场景 平行组件之间传递数据，很多数据需要多个组件循环使用；如：用户的登录，注册；
有的时候我们只是需要动态的从一个组件中获取数据（官网称为“组件层级”：是个独立的控件，作用范围只在组件之内）然后想放到一个被官网称作“应用层级”（在项目的任意地方都可以随时获取和动态的修改，在修改之后，vue会为你的整个项目做更新）的地方。
三、环境配置与使用 1.安装vuex npm install vuex --save
2.新建文件夹store，在文件夹内新建index.js文件，用来组装模块并导出 store 的文件
index.js文件：
import Vue from 'vue' import Vuex from 'vuex' // 告诉 vue “使用” vuex Vue.use(Vuex) // 创建一个对象来保存应用启动时的初始状态 // 需要维护的状态 const store = new Vuex.Store({ state: { // 放置初始状态 app启动的时候的全局的初始值 login: false,//用户登录状态 } }) // 整合初始状态和变更函数，我们就得到了我们所需的 store // 至此，这个 store 就可以连接到我们的应用中 export default store 然后在main.js/main.ts 中注册store
import Vue from 'vue' import App from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f72fd5a58e84215f0a437c2c057beda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f4202872dd310207d03fb55728590d/" rel="bookmark">
			Nginx proxy_pass 转发规则配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Nginx proxy_pass 转发规则配置`/api1/` &gt;&gt; `http://ip:port``/api1/` &gt;&gt; `http://ip:port/``/api3` &gt;&gt; `http://ip:port``/api4` &gt;&gt; `http://ip:port/``/api5/` &gt;&gt; `http://ip:port/haha``/api6/` &gt;&gt; `http://ip:port/haha/``/api7` &gt;&gt; `http://ip:port/haha``/api8` &gt;&gt; `http://ip:port/haha/` Nginx proxy_pass 转发规则配置 /api1/ &gt;&gt; http://ip:port http://localhost/api1/xxx &gt;&gt; http://localhost:8080/api1/xxx
server { listen 80; location /api1/ { proxy_pass http://localhost:8080; } } /api1/ &gt;&gt; http://ip:port/ http://localhost/api2/xxx &gt;&gt; http://localhost:8080/xxx
server { &lt;!--listen 80;--&gt; location /api2/ { proxy_pass http://localhost:8080/; } } /api3 &gt;&gt; http://ip:port http://localhost/api3/xxx &gt;&gt; http://localhost:8080/api3/xxx
server { listen 80; location /api3 { proxy_pass http://localhost:8080; } } /api4 &gt;&gt; http://ip:port/ http://localhost/api4/xxx &gt;&gt; http://localhost:8080//xxx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2f4202872dd310207d03fb55728590d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4bf555f3cc4ba7afc32950e748eed1/" rel="bookmark">
			centos8用阿里云安装yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Centos8用阿里云装yum源 首先ping外网，ping baidu.com能通就可以开始做了
阿里云yum源设置官方文档：https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11Jpkdzb
阿里云跟我们虚拟机安装的8.4是有一部分不通需要修改地方，我下面就做出详细的教程
设置centos系统为静态IP地址 #注意修改自己的网卡配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens32 #重启网络服务 systemctl restart network #验证IP地址 ip addr #进yum源把本地的放在一个文件夹里 cd /etc/yum.repos.d/ mkdir 1 mv * 1/ #非阿里云ECS用户会出现 Couldn't resolve host 'mirrors.cloud.aliyuncs.com' 信息，不影响使用。用户也可自行修改相关配置: eg: sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Linux-BaseOS.repo curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo mv CentOS-Base.repo CentOS-Linux-BaseOS.repo #重建本地yum索引缓存 yum makecache 测试
yum -y install vim* #成功即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4bd079b215e1c97e3c6f282ab0acebc/" rel="bookmark">
			【采集项目-（5)将Kafka的数据采集到hdfs】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		topic_log的数据采集至hdfs 技术选型 flume KafkaSource (拦截器） -&gt; fileChannel -&gt; hdfsSink
Flume实操 1）创建Flume配置文件
[atguigu@hadoop104 flume]$ vim job/kafka_to_hdfs_log.conf 2）配置文件内容如下
## 组件 a1.sources=r1 a1.channels=c1 a1.sinks=k1 ## source1 a1.sources.r1.type = org.apache.flume.source.kafka.KafkaSource a1.sources.r1.batchSize = 5000 a1.sources.r1.batchDurationMillis = 2000 a1.sources.r1.kafka.bootstrap.servers = hadoop102:9092,hadoop103:9092,hadoop104:9092 a1.sources.r1.kafka.topics=topic_log a1.sources.r1.interceptors = i1 a1.sources.r1.interceptors.i1.type = com.atguigu.interceptor.TimestampInterceptor$Builder ## channel1 a1.channels.c1.type = file a1.channels.c1.checkpointDir = /opt/module/flume/checkpoint/behavior2 a1.channels.c1.dataDirs = /opt/module/flume/data/behavior2/ a1.channels.c1.maxFileSize = 2146435071 a1.channels.c1.capacity = 1000000 a1.channels.c1.keep-alive = 6 ## sink1 a1.sinks.k1.type = hdfs #HA高可用配置 a1.sinks.k1.hdfs.path = hdfs://mycluster/origin_data/edu/log/topic_log/%Y-%m-%d a1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4bd079b215e1c97e3c6f282ab0acebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f320f7620930b9b0fab6c6031ce5a15/" rel="bookmark">
			开发板串口终端shell中文或者其他国家语言显示乱码或者问号？的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、环境 平台：IMX6DL
内核版本：linux4.1.5
交叉编译器：arm-linux-gnueabihf-
开发环境：Ubuntu16.04
2、问题描述 从window端创建的文件名在window端显示正常，但是将文件拷入U盘，开发板通过U盘挂载的方式查看里面的文件名或者文件夹，显示都是？？？？或者乱码之类的；或者从开发板创建的文件名传入到window端，显示也是乱码。
3、问题解析 window端和linux端的编码不一样导致的这一现象。
4、问题解决 1、首先配置内核，新增
将配置好的内核重新编译一次，然后烧写到IMX6DL核心板上，重新上电。
2、文件系统的配置
查看文件系统是否有locale、localedef指令，如果没有这条指令，可以将交叉编译器中的指令locale移植进来。
使用locale -a指令查看当前系统之前几种配置
root@imx6dlsabresd:/udisk# locale -a C en_GB en_US POSIX 如果只支持C和POSIX的话，需要自己弄一个新的字符集，请查看第五点：
使用locale查看当前文件系统默认采用的字符集，系统默认为POSIX,LANG为空
root@imx6dlsabresd:~# locale LANG= LC_CTYPE="POSIX" LC_NUMERIC="POSIX" LC_TIME="POSIX" LC_COLLATE="POSIX" LC_MONETARY="POSIX" LC_MESSAGES="POSIX" LC_PAPER="POSIX" LC_NAME="POSIX" LC_ADDRESS="POSIX" LC_TELEPHONE="POSIX" LC_MEASUREMENT="POSIX" LC_IDENTIFICATION="POSIX" LC_ALL= 接下来重新设置环境变量：
root@imx6dlsabresd:/# export LANG=en_GB root@imx6dlsabresd:/# locale LANG=en_GB LC_CTYPE="en_GB" LC_NUMERIC="en_GB" LC_TIME="en_GB" LC_COLLATE="en_GB" LC_MONETARY="en_GB" LC_MESSAGES="en_GB" LC_PAPER="en_GB" LC_NAME="en_GB" LC_ADDRESS="en_GB" LC_TELEPHONE="en_GB" LC_MEASUREMENT="en_GB" LC_IDENTIFICATION="en_GB" LC_ALL= 如果成功环境都配置成功的话，重新查看ls，如下图所示，会显示中文或者其他国家语言文字了，而不是乱码。
5、新增新的字符集 首先需要查看文件系统是否有/usr/share/i18n/文件夹，没有的话，需要从交叉编译器中的软件包拷贝过来，如下图。
如果没有该路径/usr/lib/locale文件夹的话，需要自己手动创建。
执行以下指令：
root@imx6dlsabresd:~# localedef -f UTF-8 -i zh_CN $PWD/zh_CN.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f320f7620930b9b0fab6c6031ce5a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b460a0085507f284764d831592f3e5/" rel="bookmark">
			mybatis详解(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持久层技术解决方案有几种?
mybatis持久层框架
测试用例搭建
mybatis全局配置文件
mybatis映射文件
mybatis动态SQL
mybatis分页
mybatis逆向工程
持久层技术解决方案有几种?
1.JDBC技术–&gt;Connection、PreparedStatement、ResultSet
2.Spring的JdbcTemplate–&gt;Spring中对Jdbc的简单封装
3.Apache的DBUtils–&gt;它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装
以上这些都不是框架(JDBC是规范、Spring的JdbcTemplate和Apache的DBUtils都只是工具类)
mybatis持久层框架
mybatis是一个用Java编写的持久层框架，它使用ORM实现了结果集的封装。
跟hibernate一样，也是需要拥有两个配置文件，全局配置文件 和 映射文件，在编写这两个映射文件之前，必须创建mybatis环境(引入jar包或者maven工程导入坐标)
ORM是Object Relational Mapping 对象关系映射。简单来说，就是把数据库表和实体类及实体类的属性对应起来，让开发者操作实体类就实现操作数据库表。
它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等烦杂过程
测试用例搭建
搭建环境流程如下四点：
创建maven工程并导入坐标
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建实体类和Mapper的接口
public class User implements Serializable { private int id ; private String username; ...... } public interface IUserMapper { /** * 查询所有操作 * @return */ List&lt;User&gt; findAll(); } 创建mybatis的主配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b460a0085507f284764d831592f3e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1991252b1fa671ad4bf97f0528e7d0b1/" rel="bookmark">
			vue3&#43;vite项⽬搭建-配置环境变量env
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、env 文件说明 .env --- 全局默认配置文件，在所有的环境中被载入，当你指定了环境，它也会合并,并且优先级大于.env，没有指定环境时先找它 .env.development --- 指定开发环境的配置文件 .env.production --- 指定生产环境的配置文件，当 build 运行会触发此文件 2、根目录下新建文件 其中写环境变量和其它变量，必须要以VITE_开头 ( 若环境变量和其它变量不想以VITE_开头 如：以 APP_ 开头，则可以在 vite.config.ts 文件中添加 envPrefix: “APP_”) 全局环境 .env 文件 可以配置全局属性
# port 端口号 VITE_PORT = 8888 # open 运行 npm run dev 时自动打开浏览器 VITE_OPEN = false # public path 配置线上环境路径(打包)、本地通过 http-server 访问时，请置空即可 VITE_PUBLIC_PATH = /vue-next-admin-preview/ 开发环境 .env.dev 文件
# 开发环境
VITE_ENV = 'development'
# 开发环境接口地址
VITE_API_URL = 'https://development/vue-next-admin-preview/'
测试环境 .env.test 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1991252b1fa671ad4bf97f0528e7d0b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2360513e3322c2f03318a789c122e894/" rel="bookmark">
			vue .sync修饰符的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：子组件需要通过修改父组件传递过来的prop去改变父组件的状态的时候，即父子组件实现双向绑定。
原理：在父组件里监听到了update这个事件，并且更新了传递过来的prop的值。
父组件
&lt;template&gt; &lt;div&gt; {{text}} &lt;button @click="handleChange"&gt;点我改变内容&lt;/button&gt; &lt;SyncData :textData.sync="text"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import SyncData from './components/syncData.vue'; export default { components: { SyncData }, data () { return { text: "我是父组件" } }, methods: { handleChange() { this.text = '我还是父组件' } } } &lt;/script&gt; 子组件
&lt;template&gt; &lt;div&gt; &lt;button @click="changeText"&gt; 点我改变父组件的值 &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ["textData"], methods: { changeText() { this.$emit('update:textData', '我是子组件') } } }; &lt;/script&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2360513e3322c2f03318a789c122e894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c7a87a4aa58ddc3b80cc706cb3bc4a/" rel="bookmark">
			模型预测控制算法（MPC算法）底层逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MPC算法的基本原理
详细解析
预测模型中需要注意的点
滚动优化需要注意的点
构造目标函数约束部分
约束部分
举例说明
复盘总结
MPC算法的基本原理 MPC 的基本原理可以分为三个步骤：预测模型、滚动优化、反馈校正
（1）预测模型 ：根据历史信息 X(k)、当前输入 u(k) 来预测未来输出Y(k+1)~Y(k+Np)
（2）滚动优化 ：局部优化+在线滚动
局部优化：不是采用一个不变的全局优化目标，而是采用滚动式的有限时域优化策略；在每一个采样时刻，根据该时刻的优化性能指标，求解该时刻有限时段的最优控制率
在线滚动：计算得到的控制量信息序列只有当前值（即求解出来的第一组控制量）是实际执行的，在下一个采样时刻来临的时候又重新再求一遍又得到一组新的最优控制率
它将系统的性能需求以及约束分别转化为目标函数的值和该优化问题的解的取值范围，从而求得未来控制时域内的最优控制量序列。
MPC 与传统最优控制相比，最大的区别是：它的优化过程不是一次离线完成的，而是在有限时域内在线反复进行的，且MPC可以考虑状态空间变量的各种约束。
（3）反馈校正 ：虽然 MPC 只将计算得到的最优控制序列的第一个元素作用于系统，但是在目标函数的构造和优化求解过程中，我们使用到了未来预测时域内的参考输出（图中参考轨迹 1），并将参考输出量与实际输出量之间误差作为目标函数的一部分去优化求解该目标函数的最小值来保证我们的跟踪效果，将求解出来的第一个控制量返回来再作用于我们的系统，对下一步行动的进行产生影响。所以在这个过程中不仅有基于未来参考输入的前馈补偿，同时也有基于系统当前状态的反馈补偿。
前馈控制指通过观察未来的情况，掌握规律预测趋势，正确预计未来可能出现的问题，提前采取措施，将可能发生的偏差消除在萌芽状态中，为避免在未来不同发展阶段可能出现的问题而事先采取的措施，前馈控制发生在实际工作开始之前，是未来导向的。
反馈控制是指在某一行动和任务完成之后，将实际结果进行比较，从而对下一步行动的进行产生影响，起到控制的作用。
详细解析 预测模型中需要注意的点 根据历史信息、当前输入预测未来输出的过程中，我们就需要一个模型能够完成基于历史信息和当前状态，来预测未来输出这样一个作用。这就涉及到状态量的描述，非线性系统的线性化离散化等知识，从而确保预测输出最大限度接近期望值。
车辆模型具有多个自由度，运动姿态耦合强，受力复杂，可看做一个非线性多自由度运动刚体，我们希望问题简单化，那么我们就设法简化模型，把模型转化为线性模型。无论是车辆运动学模型，还是车辆动力学模型，皆为非线性系统，而线性模型预测控制较非线性模型预测控制有更好的实时性，且更易于分析和计算，而这对于智能驾驶都非常重要。
滚动优化需要注意的点 滚动优化就是基于我们所设置的约束在有限时段内求解目标函数的最优控制解，使得某一个或某些性能指标达到最优实现控制作用。那么设计合适的优化目标函数就是结果优越性的关键，目标函数的一般可表示为状态量和控制量的二次函数。
约束部分 设定了目标函数之后，车辆已经能够计算出可行的结果，但结果的可行性却还有待研究，这就需要约束条件来表现了。
约束条件有两个作用：
1. 确保结果的实际可行性，满足目标函数最小的最优解不一定车辆机构能够具体执行，而加上约束后，结果就一定是在车辆模型或机构限制范围内可执行的结果。
2. 约束条件缩小了状态空间范围，二次规划等最优化算法往往需要反复递归迭代得出结果，状态空间越小，计算时间也将缩减。
举例说明 假如说我们希望车辆按照我们的参考轨迹行驶，设定采样时间 Ts=0.1s，预测时域设定为10，那么根据预测模型，我们就可以预测车辆在未来1s的状态；要求解这样一个最优化问题，我们依据在最小的能量下使得跟踪误差最小来设计目标函数，把车辆横向位置偏差以及横摆角偏差等量以加权平方形式都考虑进来；此外还需要对这个最优化问题设置变量约束，比如车辆的控制量一定要满足机构的约束，预测出来的每一组输出量也要在合理的范围内，基于以上约束条件求解出最优的控制量序列。
需要系统性学习的朋友，请点击下方图片，加入会员全年无限制学习后台（MPC各矩阵的底层逻辑、MPC纵向控制、模型验证、MPC自适应巡航控制、非线性系统如何线性化及MPC动力学跟踪任何轨迹、约束添加及新求解器的求解、轨迹规划、纵向规划等80个系列）会员专享爆品课程及资源，同时获得分佣资格，可赚回自己的学费！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ead1f69787b1ef2f6775e36b509d8fb/" rel="bookmark">
			WPF入门0：WPF的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF入门0：WPF的基础知识 WPF 可创建动态的数据驱动的呈现系统。 系统的每一部分均可通过驱动行为的属性集来创建对象。 数据绑定是系统的基础部分，在每一层中均进行了集成。
传统的应用程序创建一个显示内容，然后绑定到某些数据。 在 WPF 中，控件的所有内容、显示内容的所有方面都是由某种类型的数据绑定生成的。 通过在按钮内部创建复合控件并将其显示内容绑定到按钮的内容属性，会显示按钮中的文本。
WPF体系结构图： PersentationFramework.dll包含WPF顶层的类型，包括哪些表示窗口、面板以及其他类型控件的类型。他还实现了高层编程抽象，如样式。开发人员直接使用的大部分类都来自这个程序集PresentationCore.dll包含了基础类型，如UIElement类和Visual类，所有形状类和控件类都继承自这两个类。如果不需要窗口和控件抽象层的全部特征，可以使用这一层，并且仍能用WPF的渲染引擎。WindowsBase.dll包含了更多基本要素，这些要素具有在WPF之外重用的潜能。milcore.dll是WPF渲染系统的核心，也是媒体集成层的基础。WindowsCodes.dll是一套提供图像支持的低级API(例如，处理、显示以及缩放位图与JPEG图像)Direct3D是一套地基API，WPF应用程序中的所有图形都是由它渲染User32用于决定哪些程序实际占有桌面的哪一部分。 WPF类层次结构图： 1.System.Threading.DispatcherObject类,通过继承此类，用户界面中的每个元素都可以检查代码是否在正确的线程上运行。
2.System.Windows.DependencyObject类，提供对依赖属性的支持。
在WPF中，主要通过属性与屏幕上的元素进行交往。在早期设计极阶段，wpf的设计者决定设计强大的属性模型，该模型支持许多特性，例如更改通知、默认值继承以及减少属性存储空间。最终结果就是依赖属性特性。
生成 WPF 时使用的主要体系结构原理之一是首选属性而不是方法或事件。 属性具有声明性，可更方便地指定用途而不是操作。 它还支持模型驱动或数据驱动的系统，以显示用户界面内容。 这种理念的预期效果是创建更多可以绑定到的属性，从而更好地控制应用程序的行为。
为了更加充分地利用由属性驱动的系统，需要一个比 CLR 提供的功能更丰富的属性系统。 这种丰富性的一个简单示例是更改通知。
若要实现双向绑定，需要绑定的双方支持更改通知。 若要使行为与属性值相关联，需要在属性值更改时收到通知。 Microsoft .NET Framework 具有一个 INotifyPropertyChange 接口，对象通过该接口可以发布更改通知，但该接口是可选的。
WPF 提供一个更丰富的属性系统，该属性系统从 DependencyObject 类型派生。
该属性系统实际是一个“依赖”属性系统，因为它会跟踪属性表达式之间的依赖关系，并在依赖关系更改时自动重新验证属性值。
例如，如果具有一个可继承的属性（如 FontSize），当继承该值的元素的父级发生属性更改时，系统会自动更新。
WPF 属性系统的基础是属性表达式的概念。 在 WPF 的第一个版本中，属性表达式系统是关闭的，表达式均作为框架的一部分提供。
表达式致使属性系统不具有数据绑定、样式调整或继承硬编码，而是由框架内后面的层来提供这些功能。
属性系统还提供属性值的稀疏存储。
因为对象可能有数十个（如果达不到上百个）属性，并且大部分值处于其默认状态（被继承、由样式设置等），所以并非对象的每个实例都需要具有在其上定义的每个属性的完全权重。
属性系统的最后一个新功能是附加属性的概念。 WPF 元素是基于组合和组件重用的原则生成的。 某些包含元素（如 Grid 布局元素）通常需要子元素上的其他数据才能控制其行为（如行/列信息）。
任何对象都可以为任何其他对象提供属性定义，而不是将所有这些属性与每个元素相关联。 这与 JavaScript 中的“expando”功能相似。
3.System.Windows.Media.Visual类，每个元素本质都是一个Visual对象，封闭绘图指令、绘画额外细节。
4.System.Windows.UIElement类，提供WPF本质特征的支持，如布局、输入、焦点、及事件。
UIElement 定义核心子系统，包括布局、输入和事件。
布局是 WPF 中的核心概念。 在许多系统中，可能有一组固定的布局模型（HTML 支持三种布局模型：流、绝对和表），也可能没有布局模型（User32 实际仅支持绝对定位）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ead1f69787b1ef2f6775e36b509d8fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b156f02fe7702d5d3d4ade70c71f8e1b/" rel="bookmark">
			Java经典面试题整理及答案详解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java在编程语言中，占据着重要的地位，随着技术的更新与发展，越来越多的人进入互联网行业、踏上Java编程之旅。本系列内容来源于阿里云大学Java面试技巧，面试真题+理论解析，主要针对Java编程应用领域就业的人群，找工作前看一看，希望该系列面试真题能助您一臂之力～
1.说一下java类集 类集是java实现的数据结构应用，如果只是使用，那么类集的操作非常简单，因为类集的核心接口有List，Set、Map、Iterator、Enumeration；List子接口：是可以根据索引号取得内容，而在list集合里最容易问到的问题：ArrayList（包装了数组的集合，比较常用，数组是可变的）、LinkedList（链表的实现，搜索数据的时间复杂度为：n） 区别；有需要Java课程及面试资料的可以私信博主直接拿走噢Set子接口：排序子类、HashSet与hashCode（）和equals的关系；
— Hashset：重复的判断依靠的是hashcode（）和equals（），但是它是无序的 — TreeSet：是有序的，依靠的是Comparable排序
— LinkedHashSet：继承了HashSet的特点，但是属于有序（增加顺序为保存顺序）
Map接口：Map.Entry、Iterator输出、HashMap、WeakHashMap（弱引用）。
如果只回答这一个问题，按以上几点说，这道题基本上就可以拿下，但也有可能追问其他的问题，例如：可能要求你现场编写一个链表，或者编写一个二叉树。这时候就要熟悉链表与二叉树的数据结构。 2、字符串哈西相等，equals相等吗?反过来呢？ 凡是这类问相不相等的，写个程序测试是比较方便的办法。
范例：首先观察直接赋值
*提到字符串，首先就要想到共享数据词，共享常量词
范例：采用构造法
范例：字符串
总结：从正常道理来讲，如果hashCode()相等，equals不一定相等。反过来equals相等，那么hashCode()一定相等。
3、Spring的工作原理，控制反转是怎么实现的？自己写过滤器过滤编码怎么实现？ Spring的核心组成：IOC&amp;DI(工厂设计)、AOP(代理设计、动态代理设计)；
-Spring之中针对于XML的解析处理采用的是DOM4J的实现； -Anntation的时候必须要求有一个容器；
对于编码过滤需要考虑两种情况：
-Struts1.x、SpringMVC、JSP+Servlet：都可以以直接通过过滤器完成； -Struts2.x：必须通过拦截器完成；
-实现：考虑到可扩展性的配置，所以在配置文件里面设置编码，在程序运行的时候动态取得设置的编码进行操作。但是需要设置两个操作：请求编码、回应编码。
4、框架的源码有没有看过？ 不要回答没有，即使你真的没有，你也别回答没有看过；框架的核心思想：反射+XML(Annotation)
-Struts2.X的设计：请求交由过滤器执行，而后过滤器交给控制器完成，后面由于将跳转路径等信息都写在了配置文件或知识Annoration里面，所以还需要进行这部分内容的加载； -SpringMVC：它是基于方法的请求处理，所有的参数都提交到方法上，本质上还是一个DispatcherServlet；
-Hibernate：就是反射和DOM4J解析处理流程。
5、动态代理是怎么实现的？ 直接使用Invocation Handler接口进行实现，同时利用Proxy类设置动态请求对象；使用CGLIB来避免对于“代理设计模式需要使用接口实现”的限制。 6、action是单实例还是多实例? Struts 2.x和Spring MVC中的Action都是多实例；Struts 1.x的Action是单实例；Struts 2.x和Spring MVC是否单实例可以控制，只要交由Spring管理的Action类，都可以通过“@scope=“prototype””来进行控制。 7、怎么配置bean？ 这样的配置主要是在Spring里面，重点只有xml和annotation的扫描负责：
xml中直接使用"bean"，这样在Spring容器启动的时候就可以通过容器进行初始化；annotation必须设置context命名空间，而后进行扫描包的配置。 8、修改单实例多实例. “@scope=“prototype””来进行控制。
9．Java的设计模式 工厂设计模式、代理设计模式、单例设计模式、合成设计模式、门面设计模式（JDBC）、装饰设计模式、模版设计模式。
10.事务的控制 MySQL数据库如果想要使用事务，必须使用“type=innodb”这个数据引擎；事务的核心控制：commit、rollback；在Spring里面，利用AspectJ可以设置AOP的切面，而后进行声明式事务控制。 11. 脏读、幻读、不可重复读 脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新的数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事务内两次读到的事务是不一样的，因此成为不可重复读。 12 .事务的传播属性 在Transaction Definition接口中定义了七个事务传播行为：
PROPAGATION REQUIRED：如果存在一个事务，则支持当前事务，如果没有事务则开启一个新的事务；PROPAGATION SUPPORTS：如果存在一个事务，支持当前事务，如果没有事务则非事务的执行，但是对于事务同步的事务管理器，PROPAGATION SUPPORTS与不使用事务有少许不同；PROPAGATION MANDATORY：如果已经存在一个事务，支持当前事务，如果没有一个活动的事务，则抛出异常；PROPAGATION REQUIRES NEW：总是开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起；PROPAGATION_NOT_SUPPORTED：总是非事务地执行，并挂起任何存在的事务；PROPAGATION_NEVER：总是非事务地执行，如果存在一个活动事务，则抛出异常；PROPAGATION NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按Transaction Definition.PROPAGATION_REQUIRED属性执行。 13.购物车是怎么实现的? 购物车的实现基于：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b156f02fe7702d5d3d4ade70c71f8e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08eb72c257c38833e83267ebdaabd15/" rel="bookmark">
			Java中的继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、继承 1.1继承的概念 继承是Java面向对象编程的基石，允许创建分等级层次的类继承就是子类继承父类的行为和特征，使得子类对象有父类的实例域或方法子类从父类继承方法，使子类具有父类相同的行为继承是从已有的类中派生出新的类，新的类能吸收已有的 举例：
兔子和山羊的父类是食草动物，老虎和狮子的父类是食肉动物食草动物和食肉动物的父类是动物所以继承要符合的条件是is-a父类比子类的概括性更强，子类比父类更加具体化虽然食草动物和食肉动物都属于动物的子类，但是两者的行为和特征都有所差别，所以子类会有父类的一般特征但也有自身的特征 1.2类的继承方式 在Java中可以使用extends关键字申明一个类是从另一个类继承下来的，格式如下
class 父类 {
}
class 子类 extends 父类 {
}
代码形式如下：
//子类Student继承父类People public class Student extends People Student称之为子类（派生类），People称之为父类（基类或者超类) 作用：当子类继承父类后，就可以使用父类的方法和属性了
举例一：子类继承了父类，就可以调用父类的方法 父类：
//父类 public class People { public void say(){ System.out.println("Hello World"); } } 子类：利用关键字“extends"进行继承
//子类 public class Men extends People { } 启动项：
public class DemoApplication { public static void main(String[] args) { //利用new关键字创建一个子类的对象 Men man = new Men(); //通过子类对象调用父类的方法 man.say(); } } 结论：子类man可以通过继承父类People从而调用父类中的方法say()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08eb72c257c38833e83267ebdaabd15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973358ea980440a5598e06a6a366de5c/" rel="bookmark">
			Python | 打包文件 | 打包 py 文件为可执行文件 .exe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文总结如何将 python 文件打包成可执行文件 .exe。
Updated: 2022 / 10 / 7
Python | 打包文件 | 打包 py 文件为可执行文件 .exe 总览Pyinstallerother 使用安装打包用法pyinstaller命令spec文件修改spec文件 pipenv 虚拟环境 应用简单的 .py 文件存在前提依赖的复杂项目问题、处理及注意事项 示例依赖资源文件Unix / Linux / MacOS仅打包 py 文件打包依赖资源文件先打包后修改spec先配置spec后打包 windows仅打包 py 文件 参考链接 总览 py 文件打包成 exe 文件的方式一共有三种：
py2exePyInstallercx_Freeze python 作为一门解释型脚本语言，它有三种发布方式 1：
py 文件
源码文件，运行需要使用者安装 Python 环境并且安装依赖的各种库；pyc 文件
pyc 文件是 Python 解释器可以识别的二进制码，可跨平台的，需要使用者安装相应版本的Python 和依赖库。可执行文件
不需要安装 python 环境和依赖库,可针对不同平台需要打包不同的可执行文件( Windows , Linux, Mac, …) Pyinstaller PyInstaller freezes (packages) Python applications into stand-alone executables, under Windows, GNU/Linux, Mac OS X, FreeBSD, Solaris and AIX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973358ea980440a5598e06a6a366de5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192b16ebd60760c6f4a0c55838d4afd4/" rel="bookmark">
			Oracle SQL语句进行新建用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽大家好，随着科技的发达，国家的强大，人类智慧的增长。我们的身边也越来越多所谓的人工智能，但是他们所谓的智能也是我们人类去进行编程代码，进行设定功能和各种精密的传感器来进行的。自然软件的开发也就成了不可缺少的重要部分。下面我们要讲的是oracle数据库的应用之一的如何给创建用户，因为呢orcale的原理是一个数据库，用户不能自己去建只能用开发者给的。所以需要我们给用户进行权限的设置。
文章目录 前言一、oracle是什么？二、使用步骤 1.新建用户2.设置密码3.设置权限总结 前言 哈喽大家好，随着科技的发达，国家的强大，人类智慧的增长。我们的身边也越来越多所谓的人工智能，但是他们所谓的智能也是我们人类去进行编程代码，进行设定功能和各种精密的传感器来进行的。自然软件的开发也就成了不可缺少的重要部分。下面我们要讲的是oracle数据库的应用之一的如何给创建用户，因为呢orcale的原理是一个数据库，用户不能自己去建只能用开发者给的。所以需要我们给用户进行权限的设置。
提示：以下是本篇文章正文内容，下面案例可供参考
一、oracle是什么？ Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小微机环境。它是一种高效率的、可靠性好的、适应高吞吐量的数据库方案。
ORACLE数据库系统是美国ORACLE公司（甲骨文）提供的以分布式数据库为核心的一组软件产品，是最流行的客户/服务器(CLIENT/SERVER)或B/S体系结构的数据库之一。比如SilverStream就是基于数据库的一种中间件。ORACLE数据库是世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库它实现了分布式处理功能。但它的所有知识，只要在一种机型上学习了ORACLE知识，便能在各种类型的机器上使用它。
Oracle数据库最新版本为Oracle Database 20c。Oracle数据库12c 引入了一个新的多承租方架构，使用该架构可轻松部署和管理数据库云。此外，一些创新特性可最大限度地提高资源使用率和灵活性，如Oracle Multitenant可快速整合多个数据库，而Automatic Data Optimization和Heat Map能以更高的密度压缩数据和对数据分层。这些独一无二的技术进步再加上在可用性、安全性和大数据支持方面的主要增强，使得Oracle数据库12c 成为私有云和公有云部署的理想平台。
二、使用步骤 1.新建用户 我们用代码来进行创建用户名和密码，下面先建用户名：create这个键想必大家都不陌生了就是创建的意思。
代码如下（示例）：
create user xm---用户名xm 2.设置用户登陆密码 下面我们给用户名进行设置密码利用 identified来设置登录的密码。
代码如下（示例）：
identified by "123"---密码 双引号 3.设置用户权限 下面来给它进行授权权限，关键字来进行设置。
---给普通用户授权：connect，resources 权限 grant connect, resource to xm 该处使用的oracle
总结 这里对文章进行总结：
例如：以上就是今天要讲的内容，本文仅仅简单介绍了oracle的使用。 Oracle数据库最新版本为Oracle Database 20c。Oracle数据库12c 引入了一个新的多承租方架构，使用该架构可轻松部署和管理数据库云。此外，一些创新特性可最大限度地提高资源使用率和灵活性，如Oracle Multitenant可快速整合多个数据库，而Automatic Data Optimization和Heat Map能以更高的密度压缩数据和对数据分层。这些独一无二的技术进步再加上在可用性、安全性和大数据支持方面的主要增强，使得Oracle数据库12c 成为私有云和公有云部署的理想平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d812c47bbef6df323f932ecfe6098f1e/" rel="bookmark">
			【Python&#43;C#】手把手搭建基于Hugging Face模型的离线翻译系统(如果你想，也可以在线)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：目前翻译都是在线的，要在C#开发的程序上做一个可以实时翻译的功能，好像不是那么好做(其实主要是第三方的都要AppID或者授权，太不友好了)。而且大多数处于局域网内，所以访问在线的api也显得比较尴尬。于是，就有了以下这篇文章，自己搭建一套简单的离线翻译系统（当然，你也可以部署到有外网的云服务器上，那就可以变成在线的翻译系统了）。以下内容采用python提供基础翻译服务+ C#访问服务的功能，欢迎围观。
小声哔哔：其实本来要写个WPF版本的翻译神器，对标某道词典或者某度翻译啥的。不过想了想，算了，不搞那么麻烦了，意思一下就行，能跑就可以，大家感兴趣可以自己拓展为自己需要的模样。
系统环境：WIN10 开发环境：VS2022 + VS CODE
开发语言环境：Python3.8 + .NET 6
以下正文：
1、由于本地环境没有python，所以先安装python有关环境先。
2、安装好以后，控制台下输入 python,进入如下终端内容，就代表安装成功了。建议安装时候，选择自动添加到环境变量里面，这样不需要自己配置了。
3、由于翻译功能，会使用到一些已有的模型进行计算，所以以下需要安装几个包。第一个是pytorch, 输入 pip install torch 即可安装。如果安装比较慢，在后面设置一个镜像，可以加速，例如此处我使用的清华的加速器：https://pypi.tuna.tsinghua.edu.cn/simple
4、然后安装flask: pip install flask
5、接着需要安装 gevent: pip install gevent
6、接着是 transformers
7、安装transformers时候，有的会自动安装sentencepiece包，有的时候不会。如果上面查找没有，就手动安装一下：
8、以上包安装完毕，打开VS CODE，创建一个python语言文件
9、此处文件命名为 MyTranslate.py 然后引入可能所需要的包
10、接着，上 https://huggingface.co/Helsinki-NLP 上面，查找需要的语言翻译模型。此处使用的离线翻译，使用的该项目下的。
11、Models里面有上千个语言模型，选择自己需要的名称，记住就行。
12、此处，我选了四个模型，分别是英汉/汉英 以及德汉/汉德的翻译模型。有关代码实现如下所示。
13、接着定义一个api接口，用于提供给外部访问（毕竟主业不是python，提供api就可以跨语言来访问该服务了）。有关代码如下所示。
14、VS CODE上运行程序，可以看到终端控制台上面打印出一些下载进度。这是因为本地现在还没有模型，我们选择的四个模型，会被下载到本地来，这样下次就不需要再下载模型了。
15、 模型加载完毕，启动服务。此处0.0.0.0代表本机ip都可以被访问，我们正常使用时候，本机就127.0.0.1即可；如果是局域网或者外网，那就提供真实IP即可。
16、下载的模型，会自动下载到当前用户文件夹下，具体效果如下图所示。所以如果某个服务器没有外网，也可以直接拷贝该.cache文件夹到指定服务器下面的某用户下，也可以被识别。
17、打开postman,做个简单的测试。可以看到，服务是可以被成功访问的，说明代码可以跑，问题不是很大。
18、换一种翻译模式再试一下：
19、再试一试另类点的，看看效果：
20、看不懂德文，把德文搞到百度在线翻译上面反翻译回来，看来语意好像差不多。
【中途插播，防止被恶意转载抹除个人出处使用】 该博客原创作者 Wesky，公众号：Dotnet Dancer 博客原地址：https://www.cnblogs.com/weskynet/p/16740041.html
21、程序这样运行不是事儿，所以我们可以把它打包为exe程序来运行，这样就可以在不安装python环境的电脑也可以跑了。安装 pyinstaller:
22、在MyTranslate.py同文件夹下，新建一个py文件，名称不能改：hook-ctypes.macholib.py 该文件用于提供虚拟环境使用。
23、该文件下，需要导入所有可能用到的依赖的包。不然打包可能出错；或者打包完毕以后，运行可能出错。
24、打包应用的内容，根据个人实际情况来选择，pip 下载时候，有一个 Collecting提示，提示后面就是安装的依赖包，不晓得哪些需要的，就全部搞进去，减少错误几率。
25、执行打包命名 pyinstaller -F xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d812c47bbef6df323f932ecfe6098f1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa6d93c99846a813463a018012f4b82/" rel="bookmark">
			Mysql 8.0.30版本数据库安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.0.30版本数据库安装包自行去下面网盘下载
也可自行到官网下载：官网地址：MySQL :: Download MySQL Installerhttps://dev.mysql.com/downloads/installer/
百度网盘链接：https://pan.baidu.com/s/1QCCgsvrhX29COL1p88toVw 提取码：8888
安装简单
借鉴Mysql数据库8.0.28版本安装教程
选择安装路径
默认用户名是root设置密码（也可以Add新建用户）
设置管理员密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76bb46b852aeb88fc195f0c1c2348ff6/" rel="bookmark">
			从零搭建Spring-Cloud-Alibaba（从构建到发布，更新至nacos）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、搭建父项目工程Spring-Cloud-Alibaba 打开idea，File -&gt;New-&gt;Project-&gt;Maven-&gt;next-&gt;Spring-Cloud-Alibaba（父工程名字）-&gt;Finish
二、添加Pom依赖 SpringBoot与SpringCloud之间存在版本依赖，版本不一致会导致版本冲突或者出现组件不支持的情况
依赖版本说明地址，参考文档使用对应的依赖版本
以下项目springboot版本使用2.3.2.RELEASE，springcloud版本使用Hoxton.SR9，springcloud-alibaba版本使用2.2.6.RELEASE
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Spring-Cloud-Alibaba&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;order&lt;/module&gt; &lt;module&gt;stock&lt;/module&gt; &lt;module&gt;order-ribbon&lt;/module&gt; &lt;module&gt;stock-nacos&lt;/module&gt; &lt;module&gt;nacos-config&lt;/module&gt; &lt;module&gt;sentinel-demo&lt;/module&gt; &lt;module&gt;sentinel-order&lt;/module&gt; &lt;/modules&gt; &lt;!--主项目不需要打成jar包 所以修改为pom方式--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--版本统一管理--&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;mysql.version&gt;8.0.22&lt;/mysql.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.18.12&lt;/lombok.version&gt; &lt;mysql.version&gt;8.0.22&lt;/mysql.version&gt; &lt;druid.verison&gt;1.2.11&lt;/druid.verison&gt; &lt;spring-boot.verison&gt;2.3.2.RELEASE&lt;/spring-boot.verison&gt; &lt;spring-cloud-alibaba.verison&gt;2.2.6.RELEASE&lt;/spring-cloud-alibaba.verison&gt; &lt;druid.verison&gt;1.2.11&lt;/druid.verison&gt; &lt;mybatis.spring.boot.version&gt;2.1.2&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;!-- springCloud alibaba的版本挂你，通过dependency完成继承 --&gt; &lt;!-- SpringCloudAlibaba(2.2.6.RELEASE) Spring Cloud(Hoxton.SR9) springBoot(2.3.2.RELEASE) --&gt; &lt;!--springBoot 2.3.12--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.verison}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76bb46b852aeb88fc195f0c1c2348ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e74e2fe05e0fa10e314394a10286e3d/" rel="bookmark">
			vue3拉取代码install 报错 npm ERR! code ERESOLVE npm ERR! ERESOLVE unable to resolve dependency tree npm E
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue3拉取代码install 报错 npm ERR! code ERESOLVE npm ERR! ERESOLVE unable to resolve dependency tree npm ERR! npm ERR! While resolving: npm ERR! Found: vue@3.2.31 报错如下：主要是因为 安装的包和现有的包已经冲突了版本不一致 需要重新安装包依赖： 第一个：npm install @vue/cli – force
第二个（用于降低版本）：npm install @vue/cli --legacy-peer-deps
如图所示： 这样就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d60857a5501f93ef2920431f9ea39f2/" rel="bookmark">
			【SpringBoot】Maven 版本管理与 flatten-maven-plugin 插件的使用及分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. flatten-maven-plugin 介绍 1.1 环境 IntelliJ IDEA 2021.3JDK 1.8.0_301Apache Maven 3.8.1org.codehaus.mojo：versions-maven-plugin 1.2.7https://www.mojohaus.org/flatten-maven-plugin/ 1.2 版本占位符 自 Maven 3.5.0-beta-1 开始，可以使用 ${revision}, ${sha1} and/or ${changelist} 这样的变量作为版本占位符。
像这样： &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt; &lt;artifactId&gt;ci-parent&lt;/artifactId&gt; &lt;name&gt;First CI Friendly&lt;/name&gt; &lt;version&gt;${revision}&lt;/version&gt; &lt;properties&gt; &lt;revision&gt;1.0&lt;/revision&gt; &lt;/properties&gt; ... &lt;/project&gt; 或者像这样： &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt; &lt;artifactId&gt;ci-parent&lt;/artifactId&gt; &lt;name&gt;First CI Friendly&lt;/name&gt; &lt;version&gt;${revision}${sha1}${changelist}&lt;/version&gt; ... &lt;properties&gt; &lt;revision&gt;1.0&lt;/revision&gt; &lt;changelist&gt;-SNAPSHOT&lt;/changelist&gt; &lt;sha1/&gt; &lt;/properties&gt; &lt;/project&gt; 可以使用这样的命令： mvn -Drevision=2.7.8 -Dchangelist=-RELEASE -Dsha1=ssbd clean package 缺点： Install / Deploy 时，版本占位符将不能被替换。这将导致 Install / Deploy 后， maven 不能识别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d60857a5501f93ef2920431f9ea39f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e0b86d5072c4395797039c096ffb2a/" rel="bookmark">
			RGMII以太网测试方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 方案框图 二 实现步骤 1.模组的MAC通过RGMII接口与PHY连接
2.MAC层数据经过RGMII到达PHY的PCS层
3.设置PHY的PCS层回环，使PCS层数据回到MAC层
4.判断MAC层TX与RX接收的数据。如果MAC能接收到数据，测试PASS，否则失败
三 测试代码 int main(int argc, char **argv) { int i, datalen, frame_length, sd, bytes; char *interface = "eth0"; uint8_t data[IP_MAXPACKET]; uint8_t src_mac[6]; uint8_t dst_mac[6]; uint8_t ether_frame[IP_MAXPACKET]; struct sockaddr_ll device; struct ifreq ifr; int recvlen=0; uint8_t buffer[IP_MAXPACKET]; int loopback_state=0; // Submit request for a socket descriptor to look up interface. if ((sd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; 0) { perror("socket() failed to get socket descriptor for using ioctl()"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e0b86d5072c4395797039c096ffb2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ad2c56f6f5fb6bf1cc0dcc045afdf5/" rel="bookmark">
			Axios使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Axios： Axios，是一个基于promise [5] 的网络请求库，作用于node.js和浏览器中，它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生node.js http模块, 而在客户端 (浏览端) 则使用XMLHttpRequest。 [2] 特性 从浏览器创建 XMLHttpRequests从 node.js 创建 http 请求支持 Promise API拦截请求和响应转换请求和响应数据取消请求自动转换JSON数据客户端支持防御XSRF 安装 使用 npm: npm install axios
使用 axios是基于Promise的，因此可以使用Promise API
axios的请求方式：
axios(config)axios.request(config)axios.get(url [,config])axios.post(url [,data [,config]])axios.put(url [,data [,config]])axios.delete(url [,config])axios.patch(url [,data [,config]])axios.head(url [,config]) &lt;script&gt; //发送GET查询请求 axios({ //请求类型 method:'GET', //URL url:'http//localhost:8080/xxx' }).then(response =&gt;{ console.log(response) },err=&gt;{ console.log(err); }); //发送添加POST请求 axios({ //请求类型 method:'POST', //URL url:'http//localhost:8080/xxx', //设置请求体 data:{ xx:xx, xxx:xxx } }).then(response =&gt;{ console.log(response) },err=&gt;{ console.log(err); }); //发送更新PUT请求 axios({ //请求类型 method:'PUT', //URL url:'http//localhost:8080/xxx/xxid', //设置请求体 data:{ xx:xx, xxx:xxx } }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ad2c56f6f5fb6bf1cc0dcc045afdf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c16ad912050752ab67c5d0d90ee195/" rel="bookmark">
			Unity基础操作-包与资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Unity2021.3打开菜单 窗口-&gt;资源商店 不再像以前一样,会在Unity编辑器内置的浏览器中来打开Unity的网站
并在提示窗口中有给出来解释,是说为了提升编辑器的性能.
并提供了直接到浏览器中访问资源商店的访问链接(Search Online)
翻译过来的提示参考如下 点击在线链接后访问的官网页面参考如下 百度翻译中英对照参考 因Unity3D编辑器中文包始终未全部完成翻译,具体百度翻译的中英对照情况如下
Unity Asset Store The Asset Store has moved You can visit the Asset Store website from 2020. 1 onwards, and also import your purchases from the Package Manager. Search online vAlways open in browser from menu Importing your assets from the Package Manager To download or view your purchased assets go to Window&gt; Package Manager and select My Assets or click the Open Package Manager button below.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c16ad912050752ab67c5d0d90ee195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbe7c11500e9787f19e757f8156d9cb4/" rel="bookmark">
			package.json的workspaces
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		workspaces
在项目过大的时候，最近越来越流行monorepo。提到monorepo就绕不看workspaces，早期我们会用yarn workspaces，现在npm官方也支持了workspaces. workspaces解决了本地文件系统中如何在一个顶层root package下管理多个子packages的问题，在workspaces声明目录下的package会软链到最上层root package的node_modules中。
直接以官网的例子来说明：
{ "name": "my-project", "workspaces": [ "packages/a" ] } 在一个npm包名为my-project的npm包中，存在workspaces配置的目录。
. +-- package.json +-- index.js `-- packages +-- a | `-- package.json 并且该最上层的名为my-project的root包，有packages/a子包。此时，我们如果npm install,那么在root package中node_modules中安装的npm包a，指向的是本地的package/a.
. +-- node_modules | `-- packages/a -&gt; ../packages/a +-- package-lock.json +-- package.json `-- packages +-- a | `-- package.json 上述的
-- packages/a -&gt; ../packages/a 指的就是从node_modules中a链接到本地npm包的软链
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0444c6a4a6dee7b0426d00e91a7a6041/" rel="bookmark">
			本地起node服务（用于脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建一个文件夹，在该文件下创建index.js子文件。 二、初始化node,构建package.json 在文件夹下cmd运行：
npm init -y 会在根目录下生成一个package.json文件。
三、如果需要安装插件 🌰：安装axios
在文件夹下cmd运行：
npm install axios 会在根目录下生成一个node_modules文件夹和package-lock.json文件。
在index.js中使用：
const axios = require('axios') return axios({ method: 'get', url: url, }) .then(() =&gt; {}) .catch() 四、启动项目 在文件夹下cmd运行：
node ./index.js 项目文件完整截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32fecdca9135286ba199c72c2c01c917/" rel="bookmark">
			Centos7部署LNMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建云服务器时可参考本文
一、准备环境
1、关闭防火墙和selinux。
systemctl stop firewalld sentenforce 0 二、安装nginx
1、需要将nginx的软件源添加到centos 7 系统中：
yum localinstall http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 2、安装nginx。
yum -y install nginx 3、启动nginx服务并加入开机启动项，nginx -v查看一下版本。访问一下本地ip，查看是否安装 成功。
systemctl start nginx &amp;&amp; systemctl enable nginx nginx -v 三、安装Mysql
1、运行以下命令更新YUM源。
rpm -Uvh http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 2、运行以下命令安装MySQL,并查看版本、状态
yum -y install mysql-community-server --nogpgcheck mysql -v systemctl start mysqld systemctl status mysqld systemctl enable mysqld 四、安装PHP
1、更新YUM源。运行以下命令添加EPEL源。
yum install \ https://repo.ius.io/ius-release-el7.rpm \ https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 2、 运行以下命令添加Webtatic源
rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 3、运行以下命令安装PHP。
yum -y install php70w-devel php70w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32fecdca9135286ba199c72c2c01c917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6a786cabbf43ad15854d11bb2e046d/" rel="bookmark">
			计算机网络基础知识--网络层协议IP、ARP、ICMP、RIP、OSPF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
IP协议
IP数据报格式
IP地址的编址方法
分类的IP地址
ARP
ICMP
ICMP 报文格式 ICMP报文的种类
路由选择协议
RIP
RIP协议特点
距离算法
RIP协议的报文格式
RIP 优点
RIP缺点
OSPF
OSPF 与 RIP 的区别
OSPF 分组首部
BGP 路由器的构成
IPv6
本地地址或专用地址（本地互联网或专用互联网）
IP协议 IP数据报格式 IP是无连接服务。
IP地址的编址方法 (1) 分类的IP地址。将IP地址分成若干个固定类，每一类地址都由两个固定长度的字段构成：分别是：网络号和主机号。
(2) 子网的划分
(3) 构成超网
分类的IP地址 CIDR 无分类域间路由选择
IP地址 := {&lt;网络前缀&gt;，&lt;主机号&gt;}
ARP ARP(Address Resolution Protocol) 地址解析协议，将IP地址解析成硬件地址，并且整个解析过程都是自动完成的。
需要注意的是，ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。
ICMP ICMP(Internet Control Message Protocol) 网络控制报文协议
ICMP 允许主机或路由器报告差错情况和提供异常情况的报告。ICMP报文是装在IP数据报中，作为数据部分,加上数据报的首部，组成IP数据报发出去。
ICMP 报文格式 ICMP报文的种类 以上协议之间的关系
IP 协议要使用ARP ，而ICMP和IGMP则使用IP协议。
路由选择协议 内部网关协议(IGP):在一个自制系统内部使用的路由选择协议。
RIP RIP(Routing Information Protocol) 路由信息协议，是一种分布式的基于距离向量的路由选择协议 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac6a786cabbf43ad15854d11bb2e046d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79cda8f6b0f85d453d0a4f737dc64328/" rel="bookmark">
			TCP，sqlite3,IO，进程的运用实例（超详解注释超多）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于TCP的在线词典
大致功能：注册账号，登录账号，查找单词，查询该账号的历史记录。
单词和解释保存在文件中，单词和解释只占一行,
一行最多300个字节，单词和解释之间至少有一个空格
实现TCP并发 --多进程
数据表在终端提前创建完成
服务器源码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sqlite3.h&gt; #include &lt;signal.h&gt; #include &lt;time.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;sys/wait.h&gt; #define N 16 #define R 1 // 注册标识 #define L 2 // 登录标识 #define Q 3 //	查询单词标识 #define H 4 // 历史记录标识	#define DATABASE "my.db" //数据库名称 typedef struct //传输数据载体，这里用结构体类型	{ int type; //用于给服务器识别操作选项 char name[N];	//存放用户名.数据库主键 char data[256]; // 错误信息或单词解释或单词 } MSG; void my_register(int connectfd, MSG *msg, sqlite3 *db); void my_login(int connectfd, MSG *msg, sqlite3 *db); void my_query(int connectfd, MSG *msg, sqlite3 *db); void my_history(int connectfd, MSG *msg, sqlite3 *db); void my_client(int connectfd, sqlite3 *db);	//第一步.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79cda8f6b0f85d453d0a4f737dc64328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60118d7c2b604c7870c63cf07e25610d/" rel="bookmark">
			1.WPF 布局，样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局 不论是QT，winform,Wpf各种IDE无论是手机还是pc桌面还是书籍都少不了布局。
布局要解决元素如何摆放的问题。目前WPF有以下几种布局的方式。
Grad：可以把界面切成田字格容器。（布局跨行或者列 RowSpan ColumnSpan）
StackPanel:在一个平面上从左到右或者从上到下来放置元素的容器。
DockPanel:可以让部件停留在最左边最右边上边或者最下边的容器。
WrapPanl:和StackPanel对比多了自动换行功能。
UnifromGrid:指定行和列，均分容器。
Canvas:固定设置元素的位置。
( * 或者auto 调整尺寸占比）
样式 Style 触发器 作用：重复使用各类控件元素的，字体，颜色，位置，边距等。
特性：继承(BasedOn)
触发器
1.普通触发器style.Traggers
2.Mulitigger
3.事件触发器
控件模板 ControlTemplate 样式中定义
ControlTemplate 单独定义
ItemContainerStyle -&gt; Style -&gt;Style.Value-&gt; ControlTemplate
数据模板 DateTemplate 1.CellTemplate (DataGrid)
2.ItemTemplate(ListBox，Combobox,TreeView)
3.ContenTemplate(UserControl)
控件 Content 绑定 ICommand INotifyPropertyChanged 依赖属性，附加属性 prodp
propa
propf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c6b56c0927b769abfd264274beeb09/" rel="bookmark">
			Linux如何检查目录大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看当前文件目录各个文件夹大小 du -h --max-depth=1
查看指定目录
du -h --max-depth=1 /path
2. 查看当前目录下所有目录及子目录大小 du -h - .
“.”代表当前目录下。也可以换成一个明确的路径
-h表示用K、M、G的人性化形式显示
3. du 命令参数详解 du [-abcDhHklmsSx] [-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;] [–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]
常用参数：
-a或-all 为每个指定文件显示磁盘使用情况，或者为目录中每个文件显示各自磁盘使用情况。
-b或-bytes 显示目录或文件大小时，以byte为单位。
-c或–total 除了显示目录或文件的大小外，同时也显示所有目录或文件的总和。
-D或–dereference-args 显示指定符号连接的源文件大小。
-h或–human-readable 以K，M，G为单位，提高信息的可读性。
-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位,而不是以1024为换算单位。
-k或–kilobytes 以1024 bytes为单位。
-l或–count-links 重复计算硬件连接的文件。
-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。
-m或–megabytes 以1MB为单位。 -s或–summarize 仅显示总计，即当前目录的大小。
-S或–separate-dirs 显示每个目录的大小时，并不含其子目录的大小。
-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。
–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。
–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。
–help 显示帮助。
–version 显示版本信息。
4.其他常用命令： 要显示一个目录树及其每个子树的磁盘使用情况 du /home/linux 这在/home/linux目录及其每个子目录中显示了磁盘块数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c6b56c0927b769abfd264274beeb09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1efbcd24fbb2a00d917dbf406244cd01/" rel="bookmark">
			C语言：折半查找递归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码
int BinSearch_Cur(SqList L, KeyType key, int low, int high) { if(low &gt; high) return 0; //查找不到时返回 0； if(low &lt;= high) { mid = (low+high)/2; if(L.elem[mid] == key) return mid; else if(key &lt; L.elem[mid]) return BinSearch_Cur(L, key, low, mid-1); //对左子表递归查找 else return BinSearch_Cur(L, key, mid+1, high); //对右子表递归查找 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4460f5efa4f03b050863928def707eb6/" rel="bookmark">
			【Java】运算符与表达式练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Java】运算符与表达式练习 要求 设 i = 13，ch = ‘E’，写出满足以下要求的表达式：
判断 i 是否为奇数判断 i 是否为3位的10进制数判断 ch 是否是10进制数字字符判断 ch 是否为16进制数字字符判断 ch 是否为英文字母 实现代码 package com.cxl; public class Demo1_1 { public static void main(String[] args) { int i = 13; char ch = 'E'; //1. i是否为奇数 if (i % 2 != 0){ System.out.println(i+"是奇数"); }else { System.out.println(i+"不是奇数"); } //2. i是否为3位的10进制数 if (i &gt;= 100 &amp;&amp; i &lt;= 999){ System.out.println(i+"是三位十进制数"); }else { System.out.println(i+"不是三位十进制数"); } //3. ch是否为10进制数字字符 if (ch &lt;= '9' &amp;&amp; ch &gt;= '0'){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4460f5efa4f03b050863928def707eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93658515306fc14055fdc794f375bfa5/" rel="bookmark">
			Objective-c入门-第一个自定义类（6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节我们要实现一个自定义的BNRPerson类。
BNRPersn.h称为头文件或接口文件，包含实例变量和方法的声明BNRPerson.m称为实现文件，包含所有方法的代码实现 目录
一、使用Xcode创建一个类
二、存取方法
三、存取方法的命名规范
四、self
五、类前缀
六、练习
一、使用Xcode创建一个类 我们可以鼠标右键项目名称，选择New File…
或者通过另一种方式：
以上方式任选一种，之后我们都会看到同一种弹框，如下所示：
点击Cocoa Class就可以创建类了。
输入类名就OK了。
我的长这样👀
打开BNRPerson.h，声明两个实例变量
@interface BNRPerson : NSObject { //BNRPerson类拥有两个实例变量 float _heightInMeters; //身高 int _weightInKilos; //体重 } @end 头文件是以@interface开始，以@end结束。
声明实例变量要在花括号里面，否则float你都打不出来滴！
接下来，在花括号外面声明5个实例方法：
@interface BNRPerson : NSObject { //BNRPerson类拥有两个实例变量 float _heightInMeters; //身高 int _weightInKilos; //体重 } //BNRPerson类声明实例方法 -(float) heightInMeters; -(void) setHeightInMeters:(float) h; -(int) weightInKilos; -(void) setWeightInKilos:(int) w; //BNRPerson类拥有计算Body Mass Index的方法 -(float) bodyMassIndex; @end 使用键盘快捷键 Ctrl + Command + ⬆️，可以返回BNRPerson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93658515306fc14055fdc794f375bfa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85bf231fce7df619cada5fcd1e34623c/" rel="bookmark">
			go 语言入门之环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载，window为例
Downloads - The Go Programming Language (google.cn)
2.解压后如图
3.根据以下图片依次打开
4.新建两个变量名，值为你解压文件后的路径：
变量1：GOPAGE 值：E:\appNew\GoSDK\go
变量2：GOROOT 值：E:\appNew\GoSDK\go
5.找到Path变量，双击进入编辑
6. 新建变量：%GOROOT%\bin
7.测试命令：go env
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2105b4302e290e84bc6c84caaba19e43/" rel="bookmark">
			我的第一个腾讯云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云服务器 我的第一个腾讯云服务器，购买的是限时秒杀的，新用户专享99元/年，1核2G，真的新手必备。
购买完服务器之后，我登录进入到控制台
这里你可以获得你的公网和内网的IP地址，以及设置密码，安全组等等
接下来，我就默默的打开了Xshell软件，输入账号密码进入Linux系统了，现在开始我的基本配置：
腾讯云服务器Linux系统之安装Tomcat 创建安装目录，下载tomcat ，用清华镜像比较快。
[root@VM_0_16_centos ~]# mkdir /usr/lib/tomcat [root@VM_0_16_centos ~]# cd /usr/lib/tomcat [root@VM_0_16_centos tomcat]# wget https://mirrors.cnnic.cn/apache/tomcat/tomcat-8/v8.5.45/bin/apache-tomcat-8.5.45.tar.gz 解压即安装，并建立软连接
[root@VM_0_16_centos tomcat]# tar -zxvf apache-tomcat-8.5.45.tar.gz [root@VM_0_16_centos tomcat]# ln -s /usr/lib/tomcat/apache-tomcat-8.5.45 /usr/tomcat 测试启动，和访问
[root@VM_0_16_centos tomcat]# ./bin/startup.sh 访问tomcat服务器
出处参考
腾讯云服务器Linux系统之安装MySql 通过下面命令行，检测服务器上是否安装过mysql
rpm -qa|grep mysql 如果安装过，可以通过下面命令卸载删除
rpm -e --nodeps mysql-libs 检查服务器是否已经安装过mysqlyum list installed mysql*出现下图所示，代表没有安装过
安装mysql源
sudo wget https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm
下载mysql rpm源
sudo rpm -ivh mysql80-community-release-el7-1.noarch.rpm
安装下载好的rpm包
sudo yum install mysql-server
安装mysql，发现提示，y到底
凡是让输入的地方，都输入y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2105b4302e290e84bc6c84caaba19e43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5a616c6a7829859e4ab2d67d9636ea/" rel="bookmark">
			RestTemplate使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发中有时候经常需要一些Http请求，请求数据，下载内容，也有一些简单的分布式应用直接使用Http请求作为跨应用的交互协议。
在Java中有不同的Http请求方式，主要就是HttpURLConnection或者ApacheHttpClient，但是这两个用起来都感觉有那么一点点的复杂；
好在Spring内置了RestTemplate作为Http请求的工具类，简化了很多操作，虽然Spring5推出了WebClient，但是整体感觉还是RestTemplate用起来更简单方便一些。
这里记录分享下RestTemplate的常见使用方式，RestTemplate作为Java中最简单好用的Http请求工具类一定要了解一下
常见用法 简单Get\Post请求 @Test public void testGetPost(){ RestTemplate restTemplate = new RestTemplate(); restTemplate.getMessageConverters().add(new FastJsonHttpMessageConverter()); String res = restTemplate.postForObject("http://test.aihe.space/", null, String.class); System.out.println(res); String res2 = restTemplate.getForObject("http://test.aihe.space/", String.class); System.out.println(res2); } Post提交常规表单 @Test public void testPostFrom(){ RestTemplate restTemplate = new RestTemplate(); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); MultiValueMap&lt;String, String&gt; map= new LinkedMultiValueMap&lt;&gt;(); map.add("id", "1"); HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers); String fooResourceUrl = "http://test.aihe.space/"; ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(fooResourceUrl, request, String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5a616c6a7829859e4ab2d67d9636ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90a84243e145ec82678af06ecf6958f/" rel="bookmark">
			sqlite3数据库的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlite3的使用 一：数据库相关命令 //sqlite3这个软件的使用方法。1. sqlite3 ：打开数据库软件，单独一个命令。2.退出数据库软件命令：.quit .q .e3.软件内部帮助文档.help4.查询sqlite3软件中有多少个数据库文件。5查询某个数据库中有多少记录表6.把文件中的数据导入到表格中： .import 文件名 表名 二：文件相关命令操作 都是以点开头 语句没有点 要有分号结束1.打开文件：.open2.保存文件：.save3.备份文件：.backup 数据库名 文件名（*.db） 三：表格相关命令 数据库文件中的表格。1.tables ：显示当前数据库中的表格有哪些 例如：.tables stu .table 也可以。2.schema 表名 ：查询某个表格的结构 例如： .schema stu .schema 查询所有表的结构3.dump 表名：把指定表的表结构显示出来 例如：.dump stu4.mode 模式名 设定查询是显示的格式 例如：.mode stu 四 ：退出相关命令1.创建表 create table 表名（列名1 类型，列名2 类型）； //加上分号。为结束语句。//.tables ：用来查询数据库文件中有多少个表格。drop table stu； //要加上分号才行。 drop是语句不用点，用分号。4.清屏命令 ctrl + l5.建表的约束：5种约束。约束就是数据的条件，必须满足条件。12.备份 .backup stu3.db 或者 .save stu3.db13.添加列数据14.插入数据15.DQL查询16.删除数据10. 查询命令： 常用API接口函数1、打开/创建一个数据库2、回调函数执行sql语句3、回调函数4、关闭5、释放6、 非回调来执行sql语句7、释放pazResult查询结果 //存储在外存中。
//数据库软件的使用方法。
数据库：大量数据的时候。数据库软件。
//数据库使用方法。
1.以记录的形式发生。
2.嵌入式数据库：关系数据路库。
3.数据类型：字符，整型，浮点型，日期，二进制数据。
//-------------------------------------------------------------------//
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90a84243e145ec82678af06ecf6958f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3a9e47e7f29a037bfd4bff29cc8cef/" rel="bookmark">
			Linux如何查看修改文件权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看权限：ll filename how to check linux file permissions
(两个小写L, filename是文件的名称，不输入filename的话就会显示当前目录下所有文件的权限)
2.修改权限: chmod [&lt;用户&gt;&lt;操作&gt;&lt;权限&gt;] filename 例如： chmod a+w hello.txt
（1）用户： （u、g、o、a） 4种类型，在使用时可以采用其中的任何一个，也可以组合使用。
u：表示user（文件主），就是文件或目录的所有者
g：表示group（组群），文件主所在组群的用户
o：表示other，其他用户
a：表示all，所有用户
（2）操作： 有 + - = 这三种操作。
+：表示增加权限
-：表示删除或取消权限
=：表示赋予给定的权限给文件使用者，并取消其他权限（如果有的话）
（3）权限类型有3种基本类型，分别是r、w、x，这些类型可以组合使用。
r：代表可读权限
w：代表可写权限
x：代表可执行权限
3. Linux权限怎么看 （x表示4，w表示2，r表示1, -表示0)
例如本图：第一个符号不看，从第二个符号开始看。
这个文件的权限为（rw- rw- rw-)也就是（3 3 3）
xwr加起来最大值为7,所以777也表示权限最大。
参考链接：
​​https://blog.51cto.com/u_15697129/5734197
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4983b49e8083f1f1d043bffe27bb25b9/" rel="bookmark">
			python与环境统计学之f检验例题解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
F检验：
1.f检验是什么？
2.F检验可以用来干什么
3.f检验的计算公式
4.相关例题
5.对应表格数据
1.f检验是什么：
‘F检验（F-test），最常用的别名叫做联合假设检验（英语：joint hypotheses test），此外也称方差比率检验、方差齐性检验。它是一种在零假设（null hypothesis, H0）之下，统计值服从F-分布的检验。其通常是用来分析用了超过一个参数的统计模型，以判断该模型中的全部或一部分参数是否适合用来估计母体。
F检验这名称是由美国数学家兼统计学家George W. Snedecor命名，为了纪念英国统计学家兼生物学家罗纳德·费雪（Ronald Aylmer Fisher）。Fisher在1920年代发明了这个检验和F分配，最初叫做方差比率（Variance Ratio）。’摘自百度百科
2.f检验用来做什么？
通常的F检验例子包括：
假设一系列服从正态分布的母体，都有相同的标准差。这是最典型的F检验，该检验在方差分析（ANOVA）中也非常重要。
假设一个回归模型很好地符合其数据集要求，检验多元线性回归模型中被解释变量与解释变量之间线性关系在总体上是否显著。
3.f检验的计算公式：
f检验又称方差比率检验，故需要用到的统计量是方差：将两组或两组以上的方差进行求比如：
方差为样本标准偏差的平方，即：
两组数据就能得到两个值
F1=
然后计算的F值与查表得到的F表值比较，如果
F &lt; F表 表明两组数据没有显著差异；
F ≥ F表 表明两组数据存在显著差异。
4.相关例题及代码展示：
例题：
2.8:某环境监测站对某地水稻田、小麦田和莱园田土壤中氰含量(mg/kg) 进行测定，结果如下表所示。试比较三种土壤含氰量有无显著差异(先方差分析，如有差异显著性，则进行多重比较)。
水稻田 小麦田菜园田 对应数据：
0.815
0.642
0.743
0.513
0.521
0.241
0.658
0.648
0.3680.975
0.549
0.639
0.570
0.456
0.599
0.916
0.508
0.7810.825
0.464
0.544
0.533
0.553
0.527
0.806
0.633
0.726 思路分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4983b49e8083f1f1d043bffe27bb25b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b1c8e60d05fac93705e9a5f18938c56/" rel="bookmark">
			【Python】京东自动下单抢购脚本——双十一购物小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近种草一款富士📷已久，但限于富士产能，一直都没有等到开放购买，在尝试几次定闹钟到点准时抢购后，果断放弃，于是花了一个周末时间写了一个简易脚本，终于成为一名合格的“富家子弟”。
文章目录 1 问题背景2 设计思路3 具体实现3.1 账号登录3.2 库存监听3.3 购物车操作3.4 订单操作 4 完整代码5 总结 1 问题背景 经过无数次抢购失败后，发现商家会不定时的放出少量货源，目测每次会有几台。如果我们编写一个脚本程序24小时不间断监听商品库存，一旦查询到货源便开始尝试自动下单，这样就可以极大提高我们的成功概率。
2 设计思路 京东对于商品的抢购主要分为两种：
预约抢购：到点开放购买，和普通商品下单流程一致；秒杀商品：单独的抢购接口和下单流程。 当然本次针对的预约抢购类或无货订购类，即整体下单流程和购买普通商品时一样：
登录账号 → 进入购物车 → 选择抢购商品 → 点击去结算 → 点击提交订单 → 选择付款方式并付款。
3 具体实现 由于笔者本人没有一个可以抓包的客户端，决定采用京东 WEB 端接口实现我们的脚本程序。
于是经过对京东网页下单流程的分析，将我们的脚本程序分为四个模块：账号登录模块、库存监听模块、购物车管理模块、订单管理模块。
3.1 账号登录 由于使用账号密码时有验证码限制，此处采用扫码登录方式绕过。
如对扫码登录不熟悉或感兴趣的同学可以查看周周之前的博文 扫码登录原理和实现。
本次只要针对京东登录页进行抓包分析，找到几个有用接口：
获取登录二维码 def getQRcode(self): url = 'https://qr.m.jd.com/show' payload = { 'appid': 133, 'size': 147, 't': str(int(time.time() * 1000)), } headers = { 'User-Agent': self.userAgent, 'Referer': 'https://passport.jd.com/new/login.aspx', } resp = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b1c8e60d05fac93705e9a5f18938c56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab7600ecbdf69d93bc567102fe09a86/" rel="bookmark">
			【Gitee】新建仓库，上传push
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.登录Gitee，点击右上角加号
2.填写名称，点击创建
3.在git bash中执行命令
4.然后 git init
5.git add .
6.git commit -m “234”
7.git push
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7287a4a4037b1eddf5da6654708225/" rel="bookmark">
			GEE开发之Modis_NDVI的数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GEE开发之Modis_NDVI的数据分析 前言1 基础知识介绍2 MYD13Q1的数据获取（分辨率：250m）2.1 遥感影像获取2.2 遥感数据获取2.2.1 代码一如下（以南京市为例）：2.2.2 代码二如下（以南京市为例）： 3 MOD09GA_006_NDVI的数据获取（分辨率：500m）3.1 遥感影像获取3.2 逐日遥感数据获取3.2.1 代码一如下（以南京市为例）：3.2.2 代码二如下（以南京市为例）： 3.3 逐月遥感数据获取 总结 前言 主要介绍MODIS中NDVI的逐日数据和逐月数据的获取。
1 基础知识介绍 MODIS：中分辨率成像光谱仪（Moderate-resolution Imaging Spectroradiometer，缩写MODIS）是美国宇航局研制大型空间遥感仪器，以了解全球气候的变化情况以及人类活动对气候的影响。
NDVI：归一化植被指数，归一化植被指数是反映农作物长势和营养信息的重要参数之一。植被指数(NDVI)是检测植被生长状态、植被覆盖度和消除部分辐射误差等。NDVI能反映出植物冠层的背景影响，如土壤、潮湿地面、雪、枯叶、粗糙度等，且与植被覆盖有关。多种卫星遥感数据反演植被指数(NDVI)产品是地理国情监测云平台推出的生态环境类系列数据产品之一。它被称为现有国家海洋和大气管理局高分辨率辐射计 (NOAA-AVHRR) 衍生的 NDVI 的连续性指数。
EVI：增强型植被指数 (EVI)，可最大限度地减少冠层背景变化并保持对茂密植被条件的敏感性。EVI 还使用蓝色波段去除由烟雾和亚像素薄云造成的残留大气污染。
2 MYD13Q1的数据获取（分辨率：250m） MYD13Q1 V6 产品以每个像素为基础提供植被指数 (VI) 值。有两个主要植被层。NDVI和EVI。
2.1 遥感影像获取 代码如下（以南京市为例）：
//以南京为例子 var geometry = ee.FeatureCollection('users/www1573979951/nanjingshi'); Map.centerObject(geometry,6); //选取影像集以及波段 NDVI var ndvi = ee.ImageCollection("MODIS/006/MYD13Q1").filterDate('2020-01-01', '2020-12-31').select("NDVI"); print(ndvi)// 查看一年有多少多少影像 //换算单位 var multiply = function(image){ var img = image.multiply(0.0001); return img.set('system:time_start',image.get('system:time_start')); }; ndvi = ndvi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c7287a4a4037b1eddf5da6654708225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da14377721b099438bdbb99c209e1fb/" rel="bookmark">
			Linux驱动函数总结：gpio_set_value()；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.gpio_set_value(unsigned gpio, int value)用来设置gpio寄存器的值
2.gpio_direction_output(unsigned gpio, int value)用来设置gpio为输出功能，同时设置gpio输出的值。
一般来说，设置一个GPIO口为输出，先执行一次gpio_direction_output，然后接下来只需执行gpio_set_value就行了。
3.gpio_direction_input(unsigned gpio)用来设置gpio为输入功能
4.gpio_get_value(unsigned gpio)用来获取gpio口的输入的值;
5.在使用gpio口之前，先用gpio_request（unsigned gpio, const char* label）申请gpio口的使用，若申请成功，则说明该gpio口未被使用。
6.在使用完gpio口之后，用gpio_free(unsigned gpio)释放gpio口。
7.如何获取gpio口呢，可以查看内核中对应版型的相关文件，也可以自己进行计算，比如GPIOA1的gpio为1，GPIOB2为34。
8.gpio口的通用函数接口定义在gpiolib.c文件中，声明则在gpio.h中。
.
.
.
linux内核驱动中通用GPIO函数使用
1. gpio_request(unsigned gpio, const char *label)：向内核申请指定gpio，所申请的IO口会被内核记录
参数：gpio：申请IO口编号 ，label：申请者的名字，随便。
返回：int值，成功：0；失败：负数
注：在使用gpio口之前，应先用gpio_request()申请gpio口。
若申请成功，则说明该gpio口未被使用。
若申请失败，则说明该gpio口不存在或未被释放。
2. gpio_set_value(unsigned gpio, int value)：设置gpio口的值
参数：gpio：要设置的IO口编号 ，value：要设置的值（0或1）
返回：无
3. gpio_get_value(unsigned gpio)：获取gpio口的值
参数：gpio：要获取的IO口编号
返回：int值，IO口状态
4. gpio_direction_input(unsigned gpio)：设置gpio为输入功能
参数：gpio：要设置的IO口编号
返回：int值
5. gpio_direction_output(unsigned gpio, int value)：设置gpio为输出功能，同时设置gpio输出的值
参数：gpio：要设置的IO口编号 ，value：要设置的值（0或1）
返回：int值
注：一般来说，设置一个GPIO口为输出，先执行一次gpio_direction_output，然后接下来只需执行gpio_set_value就行了。
6. gpio_free(unsigned gpio)：释放gpio口，释放的IO口会在内核记录消除
注：在使用完gpio口之后，应及时释放gpio口。释放的io，可以再次被申请。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8da14377721b099438bdbb99c209e1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2457ddbb55c4eafb571ae648ab614afa/" rel="bookmark">
			node 包管理nvm安装与使用 node版本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nvm 安装使用
https://github.com/coreybutler/nvm-windows/releases
1.下载nvm-setup 或者压缩包
2.运行
3.node工具包
4.nvm list
nvm install 12.14.1
nvm use 12.14.1
exit status 1: ��û���㹻��Ȩ��ִ�д˲�����
用管理员命令运行
!!! 注意 n nvm 对window兼容性不好,会有问题 window 使用nvmw 比较好
!!! window 可以使用 nvs nvmw
1.零时路径隔离
%path% 环境变量path 的声明 set path=C:\Users\Administrator\nvmw\nodejs\v10.16.0;%path% //设置零时变量,系统从前往后读取 2.永久配置
右键(此电脑) -&gt; 属性® -&gt; 高级系统设置 -&gt; 环境变量(N)…
1隔离环境做法
a.本地通过 nvm n(mac) nvmw nvs(window) 包管理工具进行切换
npm install nvmw -g nvmw -V nvmw install v8.11.1 nvmw ls 参考:https://github.com/nanjingboy/nvmw
b.通过.bin 文件进行就不管里
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2457ddbb55c4eafb571ae648ab614afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6ef5ef0cd78bd9441b6c44ee217dfc/" rel="bookmark">
			信息学奥赛一本通（C&#43;&#43;版）题解目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一本通提交平台 一、语言及算法基础篇 基础（一）C++语言 第一章 C++语言入门 1000 入门测试题目 题解
1001 Hello,World! 题解
2060【例1.1】计算机输出 题解
2061【例1.2】梯形面积 题解
持续更新
创作不易，白嫖不好，各位的支持和认可，就是我创作的最大动力，如果喜欢我的文章，给个关注吧！
冰焰狼 | 文
如果本篇博客有任何错误，请批评指教，不胜感激 ！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a27c566a670596fb65f036fdb7006360/" rel="bookmark">
			Java中的构造方法和方法重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、构造方法 定义：用来创建对象的方法（实例化对象的方法）
作用：创建对象过程中对成员变量进行初始化
分类：无参构造方法 &amp; 有参构造方法
格式：
public class 类名 {
修饰符 类名 (【参数列表】){
方法体
}
}
特点：
（1）方法名和类名相同，采用大驼峰命名法。
（2）无返回值（不用写void）
（3）每创建一个类，系统自动为这个类添加一个无参构造方法（默认存在）。
（4）通过无参构造方法创建对象，没有给对象的属性赋值，那么对象的属性值全部为默认值
（5）当你在类中添加了其它的构造方法后，默认的无参构造方法会被覆盖，如果你还想使用无参构造方法，需要手动添加
二、this关键字 语法知识：
（1）this修饰的变量用于指代成员变量
（2）方法被哪个对象调用，this就指代哪个对象
（3）this关键字调用方法时，this关键字调用方法的语句必须放在第一行
（4）方法的形参如果没有和成员变量重名，不带this关键字修饰的变量指的是成员变量
（5）方法的形参如果和成员变量重名，不带this关键字修饰的变量指的是形参而不是成员变量。
作用：
（1）this关键字可以调用成员方法。
（2）this关键字用于指代当前对象，所以this关键字可以调用属性。
（3）this关键字解决了成员变量和局部变量的名称冲突问题，防止成员变量名被局部变量名隐藏。
（4）this关键字可以调用构造方法：
1.在构造方法中使用this关键字调用其他构造方法时，不能在成员方法中使用。
2.在构造方法中使用this关键字调用其他构造方法，this关键字调用构造方法的语句必须是该方法的第一条执行语句，且只能出现一次。
注意： 不能在一个类的两个构造方法中使用this互调。
范例代码
package test; public class Person { public String name; public String gender; public int age; //无参构造方法 public Person() { System.out.println("我是无参构造方法"); } //有参构造方法 public Person(String name, String gender, int age) { //调用无参构造方法，必须放在第一行 this(); //调用属性 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a27c566a670596fb65f036fdb7006360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19273a4842a41f7fdbfd17a827cee81b/" rel="bookmark">
			ubuntu系统USB权限设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终端输入：
gedit /etc/udev/rules.d/50.myusb.rules，
追加如下内容:(如果不存在可自行添加)
KERNEL=="ttyUSB[0-9]",MODE="0666"
重启系统即可生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21fb9315edfa7514e61d72eac7079757/" rel="bookmark">
			Ubuntu不能访问U盘内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终端输入：
sudo apt-get install exfat-fuse
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a8d1dd9b391c60986954612f3549f8/" rel="bookmark">
			JavaWeb-Filter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 过滤器概述 oa项目还有什么缺陷？
目前oa项目的功能不多，Servlet也不多，但若功能很多，假如还有EmpServlet、OrderServlet等等，每一个Servlet都是处理自己相关的业务。但它们有相同的地方，在执行之前都要判断用户是否登录了，如果用户登录可以继续操作，如果没有需要登录。这段处理是固定的，大家都一样，怎么解决这个问题？？可以使用Filter过滤器。
Filter过滤器是什么，有什么用，执行原理是什么？
Filter是过滤器可以在Servlet这个目标程序执行之前添加代码，也可以在执行之后添加代码，之前之后都可以过滤一般情况下都是在过滤器当中编写公共代码。 一个过滤器怎么写？
第一步：编写一个Java类实现一个接口：jakarta.servlet.Filter。并且实现这个接口中的所有方法。
init方法：在Filter对象第一次被创建之后调用，并且只调用一次doFilter方法：只要用户发送一次请求，则执行一次，发送N此执行N次，在这个方法中编写过滤规则。destroy方法：在Filter对象被释放/销毁之前调用，并且只调用一次。 第二步：在web.xml文件对FIlter进行配置，和Servlet类似，或者使用注解进行配置。
注意：
Servlet对象默认情况下，在服务器启动的时候是不会创建对象的。Filter对象默认情况下，在服务器启动的时候会创建对象Servlet是单例的 小小演示一波：
随便写两个Servlet，然后写个Filter，Filter如下：
package com.itzw.javaweb.servlet; import jakarta.servlet.*; import jakarta.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter("*.do") public class Filter1 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println("init方法执行了。。"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println("doFilter执行了。。"); //执行下一个过滤器，如果下一个不是过滤器则执行目标程序servlet filterChain.doFilter(servletRequest,servletResponse); System.out.println("doFilter结束了。。"); } @Override public void destroy() { System.out.println("destroy方法执行了。。"); } } 注意要想执行Servlet，在doFilter方法中要写上chain.doFilter，它会接着执行下面的程序。而在注解中，可以进行模糊匹配比如在Servlet的注解可以在后面加个“.do”，就可以使用“*/”进行模糊匹配或者像之前一样“/dept/*”，或者可以匹配所有路径“/*”，根据需求来。
在web.xml文件中进行配置的时候，Filter的执行顺序是什么？
依靠filter-mapping标签的配置位置，越靠上优先级越高。过滤器的调用顺序遵循栈数据结构 使用注解@WebFilter的时候，执行顺序是怎样的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a8d1dd9b391c60986954612f3549f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e6558e5ee87977118a3bb2f7e5ea3e/" rel="bookmark">
			linux下安装git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：通过 yum 安装（不推荐） 在 Linux 上安装 git 仅需一行命令即可搞定，对于 Centos 系统来讲，直接执行如下命令即可安装
yum install git 不过通过这种方式安装的 git 可能不是较新版的 git，以环境 centos 7 来说，这种方式安装的 git 版本为1.8.3.1。所以不建议安装旧版本。
[root@xxx ~]# git --version git version 1.8.3.1 方法二：通过源码编译安装（推荐） 要安装新版本的 git，需要自行下载 git 源码来编译安装。
1、卸载旧版本 git
yum remove git 2、进入 Github 中的 git 版本页面 ，或者在镜像站，自行选择版本下载，我这里下载的是 git-2.30.2.tar.gz
3、将本地的安装包上传到 linux 服务器上，我这里放在 /home/software 目录下
4、解压压缩包，得到目录 git-2.30.2，位置在 /home/software/git-2.30.2
tar -zxvf git-2.30.2.tar.gz 5、提前安装可能需要的依赖
yum install curl-devel expat-devel openssl-devel zlib-devel gcc-c++ yum install perl-ExtUtils-MakeMaker automake autoconf libtool make 6、编译安装 Git
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e6558e5ee87977118a3bb2f7e5ea3e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/130/">«</a>
	<span class="pagination__item pagination__item--current">131/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/132/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>