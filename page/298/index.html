<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e17c2832903ab487c5881fae62962d81/" rel="bookmark">
			自己整理CRC16（表查询法）   笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看Modbus协议，对里面的CRC校验程序有点懵，经过在网上找资料，自己整理了一下，做个笔记，方便以后查阅。
CRC计算方法有一种是直接算法：
1．设置CRC寄存器，并给其赋值FFFF(hex)。
2．将数据的第一个8-bit字符（将此8位高位补0为16位）与16位CRC寄存器的值进行异或，并把结果存入CRC寄存器。
3．CRC寄存器向右移（即最低位方向）一位，MSB补零，移出并检查LSB。
4．如果LSB为0，重复第三步；若LSB为1，CRC寄存器与多项式码（0xA001）相异或。
注意：该步检查LSB应该是右移前的LSB，即第3步前的LSB。
5．重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。
6．重复第2至第5步直到所有数据全部处理完成。
7．最终CRC寄存器的内容即为CRC值。
另一种是查表法：
static const uint8_t s_CRCHi[] = {
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e17c2832903ab487c5881fae62962d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80780a652059f3ed4798c5f9142bc4a/" rel="bookmark">
			卸载Oracle11g的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 开始－＞设置－＞控制面板－＞管理工具－＞服务 停止所有Oracle服务。 2、 开始－＞程序－＞Oracle - OraHome81－＞Oracle Installation Products－＞ Universal Installer 卸装所有Oracle产品，但Universal Installer本身不能被删除 3、 运行regedit，选择HKEY_LOCAL_MACHINESOFTWAREORACLE，按del键删除这个入口。 4、 运行regedit，选择HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServices，滚动 这个列表，删除所有Oracle入口。 5、 运行regedit， HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServicesEventlogApplication， 删除所有Oracle入口。 6、 开始－＞设置－＞控制面板－＞系统－＞高级－＞环境变量 删除环境变量CLASSPATH和PATH中有关Oracle的设定 7、 从桌面上、STARTUP（启动）组、程序菜单中，删除所有有关Oracle的组和图标 8、 删除Program FilesOracle目录 9、 重新启动计算机，重起后才能完全删除Oracle所在目录 10、 删除与Oracle有关的文件，选择Oracle所在的缺省目录C:Oracle，删除这个入 口目录及所有子目录，并从Windows 2000目录（一般为C:WINNT）下删除以下文 件ORACLE.INI、oradim73.INI、oradim80.INI、oraodbc.ini等等。 11、 WIN.INI文件中若有[ORACLE]的标记段，删除该段 12、 如有必要，删除所有Oracle相关的ODBC的DSN 13、 到事件查看器中，删除Oracle相关的日志
这个方法对windows下不同版本oracle的卸载都是通用的，但实际没有这么复杂，我们所需要做的，也就是上面步
骤中提到的1、2、3、4、5、8、9就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3daf40562703151de104131f6828b56b/" rel="bookmark">
			ios 11 beta 描述文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://adcdownload.apple.com/WWDC_2017/iOS_11_beta_Configuration_Profile/iOS_11_beta_Profile.mobileconfig
请用safari打开 下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163c4ff577474216d29665c9534b6e16/" rel="bookmark">
			SDUT 3915 从零开始的异世界生活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SDUT 3915 从零开始的异世界生活 Time Limit: 2000MS Memory Limit: 65536KB
Problem Description
486 作为有史以来最悲惨的男主，我们知道他需要经历一些无限次的死亡和轮回才能进行下一个关卡。
现在给你 n 个连续的时间点，每个时间点 i 上都会有一个心理伤害值 hurt[i]，然后告诉你 m 个死亡时间点 deth[i]，以及当前死亡时间点会死亡的次数 num[i]，和死亡后 486 会返回的时间点（也就是最近的存档点 return[i]）。
其整个过程就是 486 从时间点 0 开始 (hurt[0] = 0)，不断向下一个时间点 1, 2, 3… 前进，当遇到死亡时间点的时候，486 会死亡一次，然后返回到最近的一个存档点，然后会继续从存档点向下一个时间点前进，当又遇到死亡时间点的时候，如果死亡次数还不够需要死亡的次数，那么当前不能过关，继续回到最近的存档点。达到需要死亡的次数之后，便不需要死亡，继续向下一个时间点前进。486 在每一个时间点 i 上都会遭受心理伤害 hurt[i]。为什么 486 的心理防线不会崩溃呢，当然因为有我们的蕾姆酱了，每次受到心理伤害的时候蕾姆酱都会治愈掉。第一季的目标便是走到时间点 n，现在需要你计算一下蕾姆酱的治愈总和（也就是 486 从时间点 0 到时间点 n 所遭受的心理攻击的总和）。
那么萌萌的蕾姆酱到底治愈了多少呢~她这么萌，你还不快告诉她么~
Input
输入数据有多组（数据组数不超过 30），到 EOF 结束。 对于每组数据： 第一行输入两个以空格分隔的整数 n 和 m n (1 &lt;= n &lt;= 100000) 表示 486 要到达的目标时间点（起始目标点 0，hurt[0] = 0，每次前进一个时间点） 接下来一行输入 n 个以空格分隔的整数，表示 hurt[i]。表示 486 在当前时间点会遭受到的伤害值 接下来输入 m (0 &lt;= m &lt;= n/2) 行，每行 3 个整数，分别是 deth[i]，return[i] 和 num[i]，表示 deth[i] 时间点需要死亡的次数以及会返回的最近的存档点 保证：0 &lt;= hurt[i] &lt;= 100,1 &lt;= deth[i-1] &lt; return[i] &lt; deth[i] &lt;= n, 0 &lt;= num[i] &lt;= 100。 当前时间点如果不需要死亡，那么486不会返回最近的存档点，会继续前进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/163c4ff577474216d29665c9534b6e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8343792ba7a72f70e10b3f6057e8ddb/" rel="bookmark">
			response.addHeader(&#34;Content-Disposition&#34;,
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 使用Servlet实现文件下载的时候，避免浏览器自动打开文件 response.addHeader(“Content-Disposition”, “attachment; filename=” + response.encodeURL(downloadfile)); 2解决Response.AddHeader(“Content-Disposition”, “attachment; filename=” + file.Name) 中文显示乱码 如果file.Name为中文则乱码。解决办法是 方法1： response.setHeader(“Content-Disposition”, “attachment; filename=” + java.net.URLEncoder.encode(fileName, “UTF-8”)); 下载的程序里有了上面一句，一般在IE6的下载提示框上将正确显示文件的名字，无论是简体中文，还是日文。但是文字只要超过17个字，就不能下载了。 一. 通过原来的方式，也就是先用URLEncoder编码，当中文文字超过17个时，IE6 无法下载文件。这是IE的bug，参见微软的知识库文章 KB816868 。原因可能是IE在处理 Response Header 的时候，对header的长度限制在150字节左右。而一个汉字编码成UTF-8是9个字节，那么17个字便是153个字节，所以会报错。而且不跟后缀也不对. 方法2： response.setHeader( “Content-Disposition”, “attachment;filename=” + new String( fileName.getBytes(“gb2312”), “ISO8859-1” ) ); 在确保附件文件名都是简 体中文字的情况下，那么这个办法确实是最有效的，不用让客户逐个的升级IE。如果台湾同胞用，把gb2312改成big5就行。但现在的系统通常都加入了 国际化的支持，普遍使用UTF-8。如果文件名中又有简体中文字，又有繁体中文，还有日文。那么乱码便产生了。另外，在上Firefox (v1.0-en)下载也是乱码。
3Content-disposition中Attachment和inline的区别 ava web中下载文件时,我们一般设置Content-Disposition告诉浏览器下载文件的名称,是否在浏览器中内嵌显示. Content-disposition: inline; filename=foobar.pdf 表示浏览器内嵌显示一个文件
Content-disposition: attachment; filename=foobar.pdf 表示会下载文件,如火狐浏览器中 spring mvc中 Java代码 收藏代码 @ResponseBody @RequestMapping(value = “/download”,produces=”application/octet-stream”) public byte[] downloadFile(HttpServletRequest request, HttpServletResponse response,String contentType2) throws IOException { byte[]bytes=FileUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8343792ba7a72f70e10b3f6057e8ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b020bfccbe7d619a6bd1d43ede282abd/" rel="bookmark">
			一阶段-sevenWork-定义一个名为Vehicles（交通工具）的基类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 定义一个名为Vehicles（交通工具）的基类，该类中应包含String类型的成员属性brand（商标）和color（颜色），还应包含成员方法run（行驶，在控制台显示“我已经开动了”）和showInfo（显示信息，在控制台显示商标和颜色），并编写构造方法初始化其成员属性。 编写Car（小汽车）类继承于Vehicles类，增加int型成员属性seats（座位），还应增加成员方法showCar（在控制台显示小汽车的信息），并编写构造方法。 编写Truck（卡车）类继承于Vehicles类，增加float型成员属性load（载重），还应增加成员方法showTruck（在控制台显示卡车的信息），并编写构造方法。 在main方法中测试以上各类。 */ package sevenWork; /** * * @author Administrator */ public class Vehicles { private String brand; private String color; public Vehicles() { // setBrand("宝马"); // setColor("黑色"); brand = "宝马"; color = "黑色"; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b020bfccbe7d619a6bd1d43ede282abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f4adff54811fff8793552a023ea579/" rel="bookmark">
			window系统安装es的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows系统上安装es（适用于32位和64位系统）
1、 下载
下载地址：https://www.elastic.co/downloads/elasticsearch
下载截图：
2、 解压
下载后，解压zip文件并放置在安装目录下。
3、 运行
双击bin目录下的bat文件运行es
4.访问es
访问地址：http://localhost:9200/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb9d4ed2a64e65f33cb73316e425525/" rel="bookmark">
			（32）快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本思想：首先将待排序记录序列中的所有记录作为当前待排序区域，从中任选一个记录（通常可选取第一个记录），以它的关键字作为枢轴，凡其关键字小于枢轴的记录均移至该记录之前，反之，凡关键字大于枢轴的记录均移动至该记录之后，这样一趟排序之后，记录将无序序列分割成两部分，再在这两部分中分别重复上述操作。
代码：
#include&lt;iostream&gt; using namespace std; void quickSort(int num[],int low,int high) { if (low &gt;= high) return; int first = low; int last = high; int key = num[first]; while (first &lt; last) { while (first &lt; last &amp;&amp; num[last]&gt;=key) { //小元素前移 --last; } num[first] = num[last]; while (first &lt; last &amp;&amp; num[first] &lt;= key) { //大元素后移 ++first; } num[last] = num[first]; } num[last] = key; quickSort(num, low, first - 1); quickSort(num, first + 1, high); } void main() { int num[12] = { 10,6,2,33,15,12,23,76,1,54,22,9 }; quickSort(num,0,11); for (auto x : num) { cout &lt;&lt; x &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb9d4ed2a64e65f33cb73316e425525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768b243aede64c08c72f4110242b3378/" rel="bookmark">
			java中Blob数据存入数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BLOB (binary large object)，二进制大对象，是一个可以存储二进制文件的容器。
在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。
BLOB是一个大文件，典型的BLOB是一张图片或一个声音文件，由于它们的尺寸，必须使用特殊的方式来处理（例如：上传、下载或者存放到一个数据库）。
根据Eric Raymond的说法，处理BLOB的主要思想就是让文件处理器（如数据库管理器）不去理会文件是什么，而是关心如何去处理它。
但也有专家强调，这种处理大数据对象的方法是把双刃剑，它有可能引发一些问题，如存储的二进制文件过大，会使数据库的性能下降。在数据库中存放体积较大的多媒体对象就是应用程序处理BLOB的典型例子。（以上摘自百度）
blob字段出库请点这里
1.首先说存入Blob，也就是上传文件并把文件存入数据库Blob字段
首先创建一个字符串存储上传的文件路径和名称：
String filePath = ""; 上传文件的页面和普通上传文件写法一样，利用form表单提交servlet处理，注意设置form表单的enctype为multipart/form-data，然后提交到后台servlet中，然后重点来了，通过form表单提交的文件，要得到这个文件需要使用
DiskFileItemFactory factory = new DiskFileItemFactory();
这个东西 ，他的作用是：实例化一个硬盘文件工厂，用来配置文件组建ServletFileUpload，
然后创建一个文件上传解析器：
ServletFileUpload fileUpload = new ServletFileUpload(factory);
接下来解决乱码问题：
fileUpload.setHeaderEncoding("UTF-8");
之后判断拿到的数据是不是通过form提交上来的数据：
if(!fileUpload.isMultipartContent(request)){ return;//如果进了if，那说明有问题，直接return，当然根据实际情况不同处理 } 然后创建一个临时路径，用来存放临时上传的文件，用于存入blob
String path = this.getServletContext().getRealPath("/WEB-INF/upload"); File file = new File(path);//放在WEB-INF文件夹下，是因为比较安全 //判断上传文件的保存目录是否存在 if (!file.exists() &amp;&amp; !file.isDirectory()) { System.out.println(savePath+"目录不存在，需要创建"); //创建目录 file.mkdir(); } 接下来就是获取提交的文件数据了，这里我们写List&lt;FileItem&gt;，因为如果一次提交多个文件，那么就需要接收多个文件:
List&lt;FileItem&gt; fiList = fileUpload.parseRequest(request);//使用ServletFileUpload解析器解析上传文件的数据，解析的结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入内容 for (int i = 0;i &lt; fiList.size(); i++) { FileItem item = fiList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/768b243aede64c08c72f4110242b3378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f59a6fd4f4a0c34a603404f5cd8a30/" rel="bookmark">
			Spring中BeanFactory和ApplicationContext的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 两者的大概背景 BeanFactory： BeanFactory是spring中比较原始，比较古老的Factory。因为比较古老，所以BeanFactory无法支持spring插件，例如：AOP、Web应用等功能。
ApplicationContext ApplicationContext是BeanFactory的子类，因为古老的BeanFactory无法满足不断更新的spring的需求，于是ApplicationContext就基本上代替了BeanFactory的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展： &lt;1&gt;MessageSource, 提供国际化的消息访问 &lt;2&gt;资源访问（如URL和文件） &lt;3&gt;事件传递 &lt;4&gt;Bean的自动装配 &lt;5&gt;各种不同应用层的Context实现
2. 利用BeanFactory获取bean
//XmlBeanFactory是典型的BeanFactory。 BeanFactory factory = new XmlBeanFactory("XXX.xml"); //获取一个叫做mdzz的bean。在这个时候进行实例化。 factory.getBean("mdzz"); 重点：当我们使用BeanFactory去获取Bean的时候，我们只是实例化了该容器，而该容器中的bean并没有被实例化。当我们getBean的时候，才会实时实例化该bean对象。
3. 利用ApplicationContext获取bean
//当我们实例化XXX.xml的时候，该文件中配置的bean都会被实例化。（该bean scope是singleton） ApplicationContext appContext = new ClassPathXmlApplicationContext("XXX.xml"); 重点：当我们使用ApplicationContext去获取bean的时候，在加载XXX.xml的时候，会创建所有的配置bean。
4. 三种获取ApplicationContext对象引用的方法
/第一种加载方法，加载的是classpath下的配置文件。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); //第二种加载方法，加载的是磁盘路径下的文件。 ApplicationContext applicationContext = new FileSystemXmlApplicationContext("applicationContext.xml"); //第三种加载方法，XmlWebApplicationContext，从web系统中加载。 //得到配置文件后，就能拿到想要的对象。例如： HelloService helloService = (HelloService) applicationContext.getBean("userService"); //在这当中getBean中的参数为你在配置文件下，这个对象的id，一个标识。 5. 区别总结 &lt;1&gt;如果使用ApplicationContext，如果配置的bean是singleton，那么不管你有没有或想不想用它，它都会被实例化。好处是可以预先加载，坏处是浪费内存。 &lt;2&gt;BeanFactory，当使用BeanFactory实例化对象时，配置的bean不会马上被实例化，而是等到你使用该bean的时候（getBean）才会被实例化。好处是节约内存，坏处是速度比较慢。多用于移动设备的开发。 &lt;3&gt;没有特殊要求的情况下，应该使用ApplicationContext完成。因为BeanFactory能完成的事情，ApplicationContext都能完成，并且提供了更多接近现在开发的功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d53d12fe094504356698976eaef8261e/" rel="bookmark">
			Android 模拟器的本地ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google模拟器 emulator-5554 开发机地址: [net.eth0.gw]: [10.0.2.2] 模拟器本机地址: [net.gprs.local-ip]: [10.0.2.15]
夜神模拟器 127.0.0.1:62001 开发机地址ip: [dhcp.eth1.gateway]: 172.17.100.2 模拟器本机地址: [dhcp.eth1.ipaddress]: [172.17.100.15]
逍遥模拟器 127.0.0.1:21503 模拟器连接本机ip: [dhcp.eth1.gateway]: [10.0.3.2] 模拟器本机地址: [dhcp.eth1.ipaddress]: [10.0.3.15]
查看模拟器配置命令 获得设备名: adb devices 进入shell命令: adb -s 设备名称 shell 获取模拟器配置: getprop
1.将手机端服务器应用打开，并查询其端口号 2.adb连接模拟器 3.使用adb forward tcp:本机端口 tcp:模拟器端口 使用示例adb forward tcp:8088 tcp:8088 4.telnet 127.0.0.1 8088 5.打印出连接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e4a0391c2bde40c66eb64ce738ee5f/" rel="bookmark">
			flask之jinja2中使用字典、列表、方法等变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在jinja2模板中使用{{name}}结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取 test.py
# -*- coding:utf-8 -*- __author__ = 'guoqianqian' from flask import Flask from flask_script import Manager from flask import render_template app = Flask(__name__) manager = Manager(app) class MyClass: def func(self): return "func" def ord_func(): return "Ordinary function" @app.route("/") def index(): mydict = {} mydict["type"]= "dict" mylist = [] mylist.append("list") myclass = MyClass() return render_template("index.html", mydict=mydict, mylist=mylist, myclass=myclass, myfunc = ord_func) if __name__ == "__main__": manager.run() index.py
&lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98e4a0391c2bde40c66eb64ce738ee5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f784432a9adc63ceb366839ca574928/" rel="bookmark">
			gcc 编译选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自http://blog.csdn.net/liuchao1986105/article/details/6674822
版本] -0.13 [声明] 这篇文档是我的关于gcc参数的笔记,我很怀念dos年代我用小本子,纪录任何的dos 命令的参数.哈哈,下面的东西可能也不是很全面,我参考了很多的书,和gcc的帮助.不全的原因是,有可能我还没有看到这个参数,另一种原因是,我可能还不会用他 但是,我会慢慢的补齐的.哈哈 假如您要转在本文章请保留我email(pianopan@beeship.com)和文章的全面性. [介绍] gcc and g++分别是gnu的c &amp; c++编译器 gcc/g++在执行编译工作的时候，总共需要4步 1.预处理,生成.i的文档[预处理器cpp] 2.将预处理后的文档不转换成汇编语言,生成文档.s[编译器egcs] 3.有汇编变为目标代码(机器代码)生成.o的文档[汇编器as] 4.连接目标代码,生成可执行程式[链接器ld] [参数详解] -x language filename 设定文档所使用的语言,使后缀名无效,对以后的多个有效.也就是根据约定C语言的后缀名称是.c的，而C++的后缀名是.C或.cpp,假如您很个性，决定您的C代码文档的后缀名是.pig 哈哈，那您就要用这个参数,这个参数对他后面的文档名都起作用，除非到了下一个参数的使用。 能够使用的参数吗有下面的这些 `c', `objective-c', `c-header', `c++', `cpp-output', `assembler', and `assembler-with-cpp'. 看到英文，应该能够理解的。 例子用法: gcc -x c hello.pig -x none filename 关掉上一个选项，也就是让gcc根据文档名后缀，自动识别文档类型 例子用法: gcc -x c hello.pig -x none hello2.c -c 只激活预处理,编译,和汇编,也就是他只把程式做成obj文档 例子用法: gcc -c hello.c 他将生成.o的obj文档 -S 只激活预处理和编译，就是指把文档编译成为汇编代码。 例子用法 gcc -S hello.c 他将生成.s的汇编代码，您能够用文本编辑器察看 -E 只激活预处理,这个不生成文档,您需要把他重定向到一个输出文档里面. 例子用法: gcc -E hello.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f784432a9adc63ceb366839ca574928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc2f3e134e915d656edea42fb386b318/" rel="bookmark">
			jQuery使用ajaxSubmit()提交表单示例（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了jQuery使用ajaxSubmit()提交表单示例,使用延第三方插件jquery.form实现,需要的朋友可以参考下：
准备工作： ajaxSubmit(obj)方法是jQuery的一个插件jquery.form.js里面的方法，所以使用此方法需要先引入这个插件。 如下所示： &lt;!--jquery需要引入的文件--&gt; &lt;script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.2.1.js"&gt;&lt;/script&gt; &lt;!--ajax提交表单需要引入jquery.form.js--&gt; &lt;script type="text/javascript" src="http://malsup.github.io/jquery.form.js"&gt;&lt;/script&gt; 创建页面： 那么，如何通过ajaxSubmit(obj)提交数据呢？首先我们需要一个form： &lt;form&gt; 标题：&lt;input type="text" name="title" /&gt;&lt;br /&gt; 内容：&lt;textarea name="content"&gt;&lt;textarea/&gt;&lt;br /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; jQuery脚本 这里写代码片上面是一个需要提交内容的form，通常情况下，我们直接通过form提交的话， 提交后当前页面跳转到form的action所指向的页面。然而，很多时候我们比不希望提交表 单后页面跳转，那么，我们就可以使用ajaxSubmit(obj)来提交数据。使用方法如下所示： $('button').on('click', function() { $('form').on('submit', function() { var title = $('inpur[name=title]').val(), content = $('textarea').val(); $(this).ajaxSubmit({ type: 'post', // 提交方式 get/post url: 'your url', // 需要提交的 url data: { 'title': title, 'content': content }, success: function(data) { // data 保存提交后返回的数据，一般为 json 数据 // 此处可对 data 作相关处理 alert('提交成功！'); } $(this).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc2f3e134e915d656edea42fb386b318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1585aed9a487c90ee1e2165a683f9bf2/" rel="bookmark">
			Js高级---递归（一看就会）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Js高级------递归
在看递归之前，你首先要明白"栈"的知识，知道的太多不好，你只需记住 栈---“后进先出”，就能了。 递归的概念（递归的意思就是函数自己调用自己本身，或者在自己函数调用的下级函数中调用自己。） 在程序中函数直接或间接调用自己 1. 直接调用自己
2. 间接调用自己
· 跳出结构,有了跳出才有结果
递归的思想 · 递归的调用,最终还是要转换为自己这个函数 1. 如果有个函数foo,如果他是递归函数,到最后问题还是转换为函数foo的形式
2. 递归的思想就是将一个未知问题转换为一个已解决的问题来实现
简单的理解：递归就是程序运行到某个点的时候，调用自身，这个时候，之前没运行完的程序会暂时不运行，等到下一层调用完了之后再运行。这个正是符合栈的先进后出。这个时候就会有个进栈，等到下一层调用完运行了，之后就可以出栈继续运行 function foo(){
...foo(...)...
}
递归的步骤(技巧) 1. 假设递归函数已经写好
2. 寻找递推关系
3. 将递推关系的结构转换为递归体
4. 将临界条件加入到递归体中
1.求 1,3,5,7,9,...第n项的结果和前n项和,序号从0开始 function foo(n){ if(n == 1){ Return 1; }else{ return foo(n) = sum(n-1)+2; } } 2. 求8的阶乘
1.求 1,3,5,7,9,...第n项的结果和前n项和,序号从0开始 function foo(n){ if(n == 1){ return 1; }else{ return foo(n) = sum(n-1)+2; } } 例2：递归实现字符串逆序 比如：s=“abcdef”，逆序后变为“fedcba”
例3. 汉诺塔问题 深拷贝,使用递归方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1585aed9a487c90ee1e2165a683f9bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc058896f40e33bd86c509f43ca0c17/" rel="bookmark">
			Oracle-Spatial空间数据库基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为爱好各种版本hello world，就把两个空间数据库oracle-spatial，mysql版本的hello world 整理一下。
一、简介 oracle spatial是oracle公司推出的空间数据库组件，使oracle具备处理空间数据的能力。从9i开始对空间数据提供了比较完备的支持。Oracle Spatial主要通过元数据表、空间属性字段（SDO_GEOMETRY）和空间索引（R-tree和四叉树索引）来管理空间数据，并在此基础上提供一系列空间查询和空间分析的函数。
二、以上没啥用，意思就是： 1.建好表（多了一个SDO_GEOMETRY类型的字段）、插入数据后、插入个元数据视图， 2.空间属性字段就是空间表区别于其他表的标志，字段类型SDO_GEOMETRY（可以自定义） 3.空间索引可以理解为从普通表的B树索引演化来的，用来提高查询速度，四叉树索（原理我理解为切豆腐），但是对空间对象分布不均匀时，就会因不均衡速度变慢，所以主要用R-树索引，对于这两种索引有空再整理。 4.函数，部分依赖空间索引主要用来做查询，部分是不依赖索引的，所以当数据量大的时候就要先用依赖索引的函数快速缩小计算范围，然后再用空间分析函数计算想要的结果（刚开始用oracle-spatial的时候，用网上那些复制粘贴大神的方法，数据量大后就有问题了，后来受到上学时专业书内容的启发，想到一种办法，解决了查询不规则多边形内point的速度问题）
三、Oracle Spatial定义的SDO_GEOMETRY类型为：
CREATE TYPE SDO_GEOMETRY AS OBJECT ( SDO_GTYPE NUMBER, //前面字符串为字段名；后面字符串为字段类型 SDO_SRID NUMBER, SDO_POINT SDO_POINT_TYPE, SDO_ELEM_INFO SDO_ELEM_INFO_ARRAY, SDO_ORDINATES SDO_ORDINATE_ARRAY); 其中SDO_GEOMETRY AS OBJECT ，标识该类型为对象类型。开始我们可以理解它为ArcObjects中的Geometry对象（本来要素的shape字段中的对象就是Geometry），而不要理解他是怎么样组织的。至于该类型中的SDO_POINT_TYPE、SDO_ELEM_INFO_ARRAY、SDO_ORDINATE_ARRAY也是Oracle Spatial自定义的类型和 sdo_geometry 是一样的。
现在对sdo_geometry 类型中的各个参数简单的介绍： 1、SDO_GTYPE ：表示要存储的几何类型，如点线面。它是通过 NUMBER类型来表达的； 2、SDO_SRID ：几何的空间参考坐标系，类型也为 NUMBER； 3、SDO_POINT ：如果几何类型点类型的话，就是存储点坐标，否则为空。oracle自定义的SDO_POINT_TYPE类型； 4、SDO_ELEM_INFO ：定义要如何理解SDO_ORDINATES中的坐标串的； 5、SDO_ORDINATES ：存储实际坐标的，以X、Y以及不同点之间都是逗号隔开； 四、学习的时候看网上的不是复制粘贴，就是翻译翻译官网的例子，实际用还很不方便，下面直接说实际操作： –0.查看是否安装了oracle-spatial
SQL&gt; desc sdo_georaster; Element Type RASTERTYPE NUMBER SPATIALEXTENT MDSYS.SDO_GEOMETRY RASTERDATATABLE VARCHAR2(32) RASTERID NUMBER METADATA SYS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfc058896f40e33bd86c509f43ca0c17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ca46b6fe0920768ed2deb8dc54df88/" rel="bookmark">
			JS时间戳如何转换为时间格式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js时间戳怎么转成日期格式呢？这个方法有很多种，小晴在这里推荐几种！
第一种格式为：2017年05月17日 10:11
&lt;script&gt; function getLocalTime(nS) { return new Date(parseInt(nS) * 1000).toLocaleString().replace(/:\d{1,2}$/,' '); } console.log(getLocalTime(1494987099)); &lt;/script&gt; 第二种格式为：2017/5/17 上午10:11
function getLocalTime(nS) { return new Date(parseInt(nS) * 1000).toLocaleString().substr(0,17)} console.log(getLocalTime(1494987099)); 第三种格式为：2017/5/17 上午10:11:39
function getLocalTime(nS) { return new Date(parseInt(nS) * 1000).toLocaleString().replace(/年|月/g, "-").replace(/日/g, " "); } console.log(getLocalTime(1494987099)); 第四种格式为：2017.05.26 16:23:22 当然我们如果想要其他格式，比如2017-05-26 16:23:22、2017-05-26、05-06 16:23这样子，我们只需要更改下面这句话即可。
var time = year+"."+month+"."+date+" "+hour+":"+minutes+":"+second;
这种格式我们需要先将时间戳转换为日期格式
var time=1494987099; var times=dateToStr(new Date(time*1000));//或者var times=formatDateTime(new Date(time*1000)); //转换日期 function dateToStr(datetime){ var year = datetime.getFullYear(); var month = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ca46b6fe0920768ed2deb8dc54df88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50fe1f8a15a5a78075cc778524dccaf/" rel="bookmark">
			视频信号vsync hsync dotclock 的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文为博主原创文章，未经博主允许不得转载。
在图像里面的参数如图所示： Dotclk = Htotal × Vtotal × framerate Htotal = Hactive + Hsync + HfrontPorch + HbackPorch Vtotal = Vactive + Vsync + VfrontPorch + VbackPorch 出现滚屏由以下现象： 何滚屏的原因都是输入输出的行数多或者少的问题： 行数多，下滚屏 行数少，上滚屏 因此要调整时序的参数实现时序要求，当然上升沿和下降沿采样可能影响图像的颜色。不管ISP还是后端的接收端都需要匹配起来来能够在后端显示。Htotal = Hactive + Hsync + HfrontPorch + HbackPorch Vtotal = Vactive + Vsync + VfrontPorch + VbackPorch 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a678a71909254c561b01b6ea498ac1bd/" rel="bookmark">
			java.lang.ClassNotFoundException: org.apache.struts.action.ActionServlet Struts1项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天帮人改一下毕业设计，老早的项目，用的struts1,从网上找齐了Struts1需要的jar包添加到build Path。执行的时候报错java.lang.ClassNotFoundException: org.apache.struts.action.ActionServlet 试着import了一下，是有这个类的。最后找到原因是tomcat的lib文件夹下并没有刚才添加的jar包
用的是MyEclipse Tomcat8，可能是项目太老了无法兼容什么的原因。
最后把jar包，手动拷贝到tomcat的lib文件夹下，成功跑起来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5d3f3de6b2f3bf48c6095bdbbfc091/" rel="bookmark">
			Android WebView userAgent 设置为桌面UA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一个大屏项目中使用到支付宝扫码支付，但是webview加载扫码支付链接时会自动跳转到移动版页面，网上查找怎么设置，没找到解决方案。于是自己随便试了下
webview.getSettings().setUserAgentString("PC")； 或
webview.getSettings().setUserAgentString("电脑")； 竟然真的可以。
userAgent可以设置浏览器标识，Android/iphone/ipod/ipad/PC等，这个应该有做类似模糊搜索一样，传相近的值就可以；它就会自动加载桌面版页面或移动版页面。前提是这些页面要有桌面版页面和移动版页面，并且做了ua判断跳转相应页面。如果传的ua识别不出来将自动加载桌面版页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/023089f5db1b3885aa2f9b98c243c65d/" rel="bookmark">
			了解BFF架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章： - http://samnewman.io/patterns/architectural/bff/ - https://os.alipayobjects.com/rmsportal/WtUmBLJSmqtDHkvJzuzM.pdf - http://www.ouchangjian.com/article/58c5f48c887279691018ec66 - http://coolhfei.blog.163.com/blog/static/221440652016931101647644/ - https://www.thoughtworks.com/insights/blog/bff-soundcloud BFF全称是Backends For Frontends(服务于前端的后端)，Sam Newman曾在他的博客中写了一篇相关的文章——Pattern: Backends For Frontends，在文章中Sam Newman详细地说明了BFF。本文参考了几篇不同博客和文章，简单阐述一下自己对BFF的认识。
简而言之，BFF就是服务器设计API时会考虑到不同设备的需求，也就是为不同的设备提供不同的API接口，虽然它们可能是实现相同的功能，但因为不同设备的特殊性，它们对服务端的API访问也各有其特点，需要区别处理。因此出现了类似下图一种设计方式。
以上两张图有相似点，也有不同之处。客户端都不是直接访问服务器的公共接口，而是调用BFF层提供的接口，BFF层再调用基层的公共服务，不同的客户端拥有不同的BFF层，它们定制客户端需要的API。图一和图二的不同之处在于是否需要为相似的设备人，如IOS和android分别提供一个BFF，这个需要根据现实情况决定，不同的项目环境解决手段不一样。
那么采用BFF架构与多端公用、单一的API有什么优点了？最重要的一点在上文中已经提到了，它能够满足因不同客户端特殊的交互引起的对新接口的要求，所以一开始就会针对相应的设备设计好对应的接口。如果使用单一、通用的API，我们一开始并没有考虑到特殊需求，那么有新的请求需要出现时，可能会出现以下问题：
(1)如果添加新的接口，这样容易造成接口的不稳定； (2)如果考虑在原有的接口上进行修改，可能需要会产生一些的耦合，破坏单一职责。 考虑这样一个简单例子，因为移动APP的屏幕限制，在某一个列表页我们只需要展示一些关键的信息，但是由于调用的是服务端提供统一的API，服务端在设计的时候只考虑到了web端，返回所有的字段信息，但这些对于移动端而言都是无用的。在优化性能时处理这样的问题时，服务器端就需要新增接口或者通过引入相关耦合来解决这样的问题。而使用BFF在很大程度能避免这样的问题。 使用BFF的另一个优点就是当由于某一客户端需要调用调用多个不同的服务端接口来实现某一功能时，可以直接在对应的BFF层编写相应的API，而不会影响到基层的公共服务，且客户端不用直接向多个后台发起调用，可以优化性能。
当然，凡事有利有弊，BFF带来便利好处的同时也会引起一些问题，如代码重复，加大开发工作量等。所以在使用时需要结合现实情况仔细斟酌，符合项目的应用开发背景。例如蚂蚁财富使用BFF的场景如下。(没有具体分析，有兴趣的可以通过上面提供的链接和查阅相关资料进行研究)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89de664fbfcea5b8960258d3a9a37892/" rel="bookmark">
			jquery 操作iframe的几种方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jquery 操作iframe的几种方法总结 iframe在复合文档中经常用到，利用jquery操作iframe可以大幅提高效率，这里收集一些基本操作
DOM方法：
父窗口操作IFRAME：window.frames["iframeSon"].document
IFRAME操作父窗口: window.parent.document
jquery方法:
在父窗口中操作 选中IFRAME中的所有输入框： $(window.frames["iframeSon"].document).find(":text");
在IFRAME中操作 选中父窗口中的所有输入框：$(window.parent.document).find(":text");
iframe框架的HTML：&lt;iframe src="test.html" id="iframeSon" width="700″ height="300″ frameborder="0″ scrolling="auto"&gt;&lt;/iframe&gt;
1.在父窗口中操作 选中IFRAME中的所有单选钮
$(window.frames["iframe1"].document).find("input[@type='radio']").attr("checked","true");
2.在IFRAME中操作 选中父窗口中的所有单选钮
$(window.parent.document).find("input[@type='radio']").attr("checked","true");
iframe框架的：
&lt;iframe src="test.html" id="iframe1″ width="700″ height="300″ frameborder="0″ scrolling="auto"&gt;&lt;/iframe&gt;
复制代码 代码如下: &lt;HTML xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;HEAD&gt; &lt;MCE:SCRIPT mce_src="js/jquery-1.2.6.js" src="../js/jquery-1.2.6.js" type="text/ecmascript"&gt;&lt;/MCE:SCRIPT&gt; &lt;MCE:SCRIPT type="text/javascript"&gt;&lt;!-- $(function(){ $("#t1").hover(function(){alert('');}); //$("iframe").contents().find("body").append("I'm in an iframe!"); //$(window.frames["iframe1"].document).find("input[@type='text']").attr("size","30px"); //$("#iframe1").contents().find("#d1").css('color','red'); //$(window.frames["iframe1"].document).find("input[@name='t1']").css({background:"#369"}); //$("#iframe1").src("test.html"); }); // --&gt;&lt;/MCE:SCRIPT&gt; &lt;DIV&gt; &lt;INPUT id=t1&gt; &lt;IFRAME id=iframe1 src="child.htm" mce_src="child.htm"&gt;&lt;/IFRAME&gt; &lt;IFRAME height=100 src="child.htm" width=300 mce_src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89de664fbfcea5b8960258d3a9a37892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/897e59d684b99efe2702878285a538e2/" rel="bookmark">
			读书笔记三：《运营之光》互联网运营方法论与自白（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网三个时代：概念驱动时代，有想法就是no1；产品驱动时代，有好的体验no1，这个阶段产品经理成为时代的新宠；接下来，很可能就是已经慢慢道来的运营驱动时代。对于一个运营来说，要是认知和思维都没跟上，直接奔着方法和技巧去，那么很快就会game over!!!所以本文主要总结运营的认知和运营该有的思维部分，作为门外汉小白，看完书中后续的核心技巧工作方法并不是特别理解，希望以后有机会进入运营岗能有更深的体会。
书中金句： 唯有爱与用户不可辜负。 要带着宏观的视角去理解运营，同事更要带着微观和落地的心态去做好运营。
&lt;认知运营&gt; 1. 怎么理解“运营”这件大事？ 运营的具体工作划分，无非就是两方面，一时拉新、引流和转化，二就是用户维系。所谓运营，其实就是为了帮助产品与用户之间更好地建立起来关系，which所需要的一切干预手段。运营要做的，就是想尽办法来实现这个目的。所以，各大公司运营平常做的可能都是比较琐碎的工作，比如文案、策划、用户维系等。刚上线的产品，其产品价值只有功能和体验，通过良性的运营，我们能够不断的提升产品的用户参与价值。
2.理解“产品”和“运营”之间的关系 产品与运营一直相爱相杀，又爱又恨。也许运营经常面对这样的问题“产品烂的像坨屎，我们也要逼着用户吃下去嘛”~~文中对产品和运营关系的定义：产品负责界定和提供长期用户价值，运营负责创造短期用户价值+协助产品完善长期价值！
很多产品的长期价值不是一蹴而就的，但是并不是所有用户都能看到产品的长期价值，绝大多数用户的心理是，目前用这个产品能解决什么问题，如果用户得不到产品及时的价值反馈，这个产品就很轻易被弃了。所以，这个时候，就需要运营先去创造出来一些及时的短期价值，来刺激用户体验继续去尝试使用。
如果早期上线的产品真的很烂，运营肿么办？首先，心理上接收这个“烂”得像坨屎的产品，没有不烂的早期产品！！！其次，逻辑上说，运营离客户更近，要做好感用户之所感，想用户之所想，自然而然就能从用户的角度发现问题，用数据向产品和Boss证明这个地方有问题。最后，自然就是寻求解决方案。产品烂不可怕，可怕的是产品烂还完全不自知，或者压根没想怎么解决和优化！！！
书中提到了几点，无论是产品还是运营都应该有的认知： 有坑是常态，人人皆会造坑 埋了坑不可怕，填坑能力是关键 尽力做到——每次都要让自己埋的坑比之前小一点点 每次造坑坑了队友，记得弥补！
&lt;运营思维&gt; 一般来讲，所有的工作分为：纯粹的职能支持类工作和目标导向类工作。 前者，创造的价值很低，但后者的价值感会逐步提升。这里，说几句题外话，光线传媒副总裁，刚进入光线的时候，他只是一名默默无闻的记者，每天重复着列问题、采访和整理的工作，一段时间后发现每天做的都是同样的事情，做得好也是一天，做得坏也是一天，仿佛能看到自己10年后的样子，这种状态就是前者纯粹的职能支持类工作。后来，同哥开始反思，尽量做到每天都比昨天进步一点点，虽然也不知道自己长远的目标是什么，同样是做采访，他想着怎么样能把今天的采访做得比昨天更好，就做好这件事情，慢慢积累引来的质变，此时便是向目标导向类工作转变了。单纯依靠出卖劳动力和时间来达成的工作，价值感很低，非常容易被取代。
“效率”意识，作为一个运营，所有的时间以及在做的工作，可能都是成本，要尽量让自己的产出变得更大。有着“投入产出比”和“效率”意识的运营，在面对怎么提高流量这个问题时，可能会首先拆分问题：我们是不是要先弄明白网站当前的流量都是从哪来的？来源于老客户的流量构成和来源于新用户的流量构成个各自是多少？老用户这边，还有多大空间去拉升流量？书中总结得很好，往往初级选手和中高级选手们的显著差别，就是初级选手只会拍脑袋去行动，要提升流量，放广告呗……而中高级选手，总是会先把事情想清楚，找到目标和更容易有所产出的地方，才会开始do it
&lt;运营信仰&gt; 这里解释了，想要成为一个真的可以连接好产品和用户的“好运营”，需要相信的东西，相信回报后置。在互联网的世界里，有时候抱着一种更加开放的心态，秉持一种“先不论我可能会得到什么回报，让我先来基于我的理解把事情做到极致”的心态，才有可能做到很多有趣的事情。
书中举了个反例，做运营，不要只是单纯关注为了关注业绩、结果和转化去做那种“竭泽而渔”的运营。好比你想强推个东西，就满世界各种群里去发，且老是这么干，就是典型的竭泽而渔。这是典型的“只有……才……”式的逻辑，而另一种“既然……那么……”的回报后置式的逻辑，更适用于运营。它更强调我们专注于给用户创造价值，并相信，当你创造的价值足够多的时候，用户一定会愿意给予你无条件的认可和回报。所以，唯有创造的用户价值足够多了之后，才有资格消耗一点点。比如说，你的相信，你和你的用户都是可以成为朋友的，你则可以通过一系列“价值创造”式的努力，先建立起你和你的朋友们之间的默契。犹如人与人之间的关系，唯有关系到位，才有可能真心帮忙！
运营其实是一件很有层次感的事情，很多时候，你都需要先做好一些小事，然后再以此为杠杆，去撬动更多大事的发生。其实，借由创造出足够的短期价值，以更好撬动用户去体验你的长期价值，甚至是在体验完之后帮你满世界去宣传分享，这也未尝不是一种“杠杆原理”。作者提到了3个底层工作方法：
对新鲜事物的高度敏感：追热点，借势 对于用户的洞察：把自己变成一个真正的典型用户 学会更具有打动力和说服力的表达
运营的核心，书中用的是意识和思考，但是我觉得此处直接用“信仰”这个词会更贴切，它之所以能成为作者的核心竞争力，就在于可能90%的运营，身上都缺乏这样的“信仰”。此处可能说的会有点虚，也可能会感觉说的很作把人格放大，关于运营，此时我只是感兴趣的小白，在运营的修仙打怪升级道路上，希望自己能不忘初心能成为那10%有信仰的运营。像内功心法这种更贴近于底层思维、工作习惯和价值导向的东西，作者称之为运营的“光”之所在。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6e73f61897027a571a5eb13485f698/" rel="bookmark">
			夜神模拟器与Android studio连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用夜神模拟器自带的nox_adb.exe在Android Studio中连接夜神模拟器。 1. 在夜神模拟器的安装路径下，在bin文件夹下有个nox_adb.exe文件，在这里为了方便使用，我们把nox_adb.exe重新更名为adb.exe文件，如图： 2. 接下来我们在系统的环境变量path中添加adb.exe文件的路径，我的路径为：D:\Program Files(x86)\nox\Nox\bin; 3. 接下来使用命令提示符窗口，输入adb即可出现adb的使用详情。 4. 接下来我们要使用adb命令来连接模拟器，在命令提示符窗口使用adb connect 127.0.0.1:62001 命令来连接模拟器。如果出现 则说明adb与夜神模拟器已经连接成功。 5. 如果每次觉得每次连接都要输入命令比较麻烦，我们可以使用脚本文件来运行它，这样每次双击就会自动连接。在桌面创建文件nox.bat文件，使用记事本打开，并输入adb connect 127.0.0.1:62001.如图： 尽可能不要有多余的字符，如果有可能会出现问题。 6. 这样每次在启动模拟器之后，双击nox.bat文件即可连接。如果出现闪退的问题，说明已经连接成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fc02d600628f3f97c2bb422ee17644/" rel="bookmark">
			解决：由于目标计算机积极拒绝 无法连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在进行Linux系统中文化的时候重启了Linux服务器，然后本地上传项目到svn的时候显示“由于目标计算机积极拒绝 无法连接”，网上看了很多帖子都是满嘴跑火车，后来就看了一下之前自己的关于建SVN库的帖子，结果发现出现这个错误的原因是服务器上svn服务未开启。
解决方法：
svnserve -d -r /data/svn/trunk（SVN路径） 另外关于SVN版本库的创建可以看这篇帖子： Linux服务器中SVN版本库的创建与配置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1629713091db1563a0b23d7846d6c93/" rel="bookmark">
			关于ajax已经成功了，却报404的错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到了一个很离奇的场景，使用ajax请求后台结果 后台处理成功了页面还报了404错误。
上代码：
JS：
var save = function(){ $.ajax({ url: urlMap.saveOrUpdateGroupInfo, type: 'post', async: false, dataType: 'json', data: $("#groupInfo").serialize() }).done(function(res) { console.log(res); if(res.success) { }else{ bootbox.alert(res.msg); } }); } @RequestMapping(value = "/saveOrUpdate", method = RequestMethod.POST) public ResponseVo saveOrUpdate(String id, String name, String parentId, String parentName, String operate){ ResponseVo result = new ResponseVo(); GroupInfo info = new GroupInfo(); Date now =new Date(); info.setUpdateTime(now); try{ if(operate.equals("add")){ info.setParentId(Integer.parseInt(parentId)); info.setName(name); info.setCreateTime(now); groupInfoService.addGroup(info); }else if (operate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1629713091db1563a0b23d7846d6c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b3f56615d1e5f2608d2f1130a7ef54/" rel="bookmark">
			override
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#中的overload,overwrite,override的语义区别 C#.NET中new, override, virtual abstract关键字的区别 很多朋友对c#中的new与override并不陌生，都知道new是隐藏,override是重写,都是针对虚方法virtual的，但是具体怎样执行以及效果，我们下面一起看下 …… 我们可以总结出如下几点
1.把子类实例化的对象赋值给基类的定义，如果子类方法使用的是new，调用的是基类的方法，如果子类方法使用的是override,调用的是子类的方法。
2.如果基类中的方法没有使用virtual进行声明，子类中仍然可以使用new,但不能使用 override
3.如果基类中方法没有virtual进行声明，子类方法也没有使用new和override, 方法名称都一样，此时编译器会给出警告，可以加上new对子类方法进行声明
转自：http://blog.csdn.net/zx13525079024/article/details/51285265
一般是实现虚方法的时候需要的关键字 [虚方法声明关键字virtual] 要扩展或修改继承的方法、属性、索引器或事件的抽象实现或虚实现，必须使用 override 修饰符 比如：
class TestOverride { public class Employee { public string name; // Basepay is defined as protected, so that it may be // accessed only by this class and derrived classes. protected decimal basepay; // Constructor to set the name and basepay values. public Employee(string name, decimal basepay) { this.name = name; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b3f56615d1e5f2608d2f1130a7ef54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2528ab091e36542181e05e134926d368/" rel="bookmark">
			阿里云端口无法访问解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先检查阿里云的安全组规则是否开启，或者允许访问该端口，未被允许则添加规则，位置如下图
2.如果阿里云安全组开启，则先查询端口是否被firewall禁止
3.如果firewall允许，则检查监听该端口的程序是否允许外网访问
举mysql3306端口为例子
1.首先mysql一开始是默认只监听127.0.0.1(本地)访问。需要在配置里面修改
2.到安全组规则里面检查是否允许3306端口访问
3.firewall开启3306端口访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087001188c884fca375a15a02fbc0d13/" rel="bookmark">
			Mac版R语言（五）使用正则表达式（Regular Expressions）提取数据信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下，我们收集到的数据可能是混合字段或非标准化的数据集。这些数据往往需要我们通过一定的方式，提取出其中特定维度或字段的信息，并以此创建新的数据集。
在低维数据中，可以使用剔除行列的方式选取特定字段的信息；或者直接进行行列选取的方法（具体实现方式，详见（三）数据的导入点击打开链接），但是当数据库是高维度数据库、空间数据库、非标准化数据库时，如HDF5，普通的删除行列方式提取信息的效率非常低下。本节内容，是通过正则表达式（Regular Expressions）实现信息的精确提取，本章内容的关键名词将全部实现中英文双标，涵盖以下几个要点：
指定信息提取／指定数据类型提取混乱数据集的特定信息提取非标准化数据集的特定信息提取 以上实现方式全部基于Regular Expression。 一. 指定信息提取／指定数据类型提取 &gt; setwd("~/Desktop")
&gt; getwd()
[1] "/Users/Apple/Desktop"
&gt; library(stringr) #需提前安装 stringr 包，具体安装方法，请见第一篇博客内容点击打开链接
&gt; strings &lt;- c(
+ "apple",
+ "219 733 8965",
+ "329-293-8753",
+ "Work:579-499-752;Home:543.355.3679"
+ )
&gt; phone &lt;- "([1-9][0-9]{2}[- .][0-9]{3}[- .][0-9]{4})" #phone的Pattern matching，第一个数2～9，第二个数0～9有两个，分隔符为-空格.
&gt; str_detect(strings,phone) #strings中哪些项符合phone的regular expression匹配，返回相应位置逻辑值
[1] FALSE TRUE TRUE TRUE
&gt; str_subset(strings,phone) #str_subset() returns the elements of a character vector that match a regular expression [1] "219 733 8965"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/087001188c884fca375a15a02fbc0d13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28a3896507eeb221c43a63261efcb7a/" rel="bookmark">
			JS中window.onload事件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 window.onload出现的原因？ 我们都知道页面的代码顺序是从上往下进行加载，很多时候我们要对页面中的某一个模块进行操作，这时候我们常常使用javascript代码来进行操作。为了能够保证操作的模块或对象在js代码之前就加载了，我们不得不把js代码放在页面的底端。但是我们在设计页面的时候，为了把js代码放在一起，或者一个让页面更加简洁的位置，那就有可能出现代码中操作的对象未被加载的情况，那么我们该如何去解决呢？这时候window.onload就被有了存在的意义了。
window.onload是什么？ window.onload是一个事件，在文档加载完成后能立即触发，并且能够为该事件注册事件处理函数。将要对对象或者模块进行操作的代码存放在处理函数中。即：window.onload =function (){这里写操作的代码};
发生要对对象进行，而对象还未被加载，导致相当于无操作的实例：
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;操作对象未被加载&lt;/title&gt; &lt;script type="text/javascript"&gt; document.getElementById("s").style.color="green"; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span id="s"&gt;要坚强，当然是选择原谅他啊！！！&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 结果： 使用window.onload()方法处理的情况的实例： &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;使用window.onload()，操作对象 已被加载&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function(){ document.getElementById("s").style.color="green"; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span id="s"&gt;要坚强，当然是选择原谅他啊！！！&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 使用window.onload（）方法事件的结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab6e4483b40834b9646bd53964c52c2/" rel="bookmark">
			矩估计法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文摘自《概率论与数理统计》 陈希孺著 中国科学技术大学出版社 相关链接 参数的点估计问题 极大似然估计
前言 矩估计法是点估计方法的一种，点估计法还有极大似然估计法和贝叶斯估计法。详情请参考上面的链接。
矩估计法 矩估计法是皮尔逊在19世纪末到20世纪初的一系列文章中引进的。这个方法的思想很简单：设总体分布为 f(x;θ1,⋯,θk) ，则它的矩（原点矩和中心矩都可以，此处以原点矩为例） 连续型： αm=∫∞−∞xmf(x;θ1,⋯,θk)dx 离散型： αm=∑i=1nxif(xi;θ1,⋯,θk) 依赖于 θ1,⋯,θk 。另一方面，至少在样本 n 较大时，αm又应接近于样本原点矩 am 。于是 αm=αm(θ1,⋯,θk)≈am=∑i=1nXmin 取 m=1,⋯,k ，并将上面的近似式改成等式，就得到一个方程组： αm(θ1,⋯,θk)=am,(m=1,⋯,k) 解此方程组，得其根 θi^=θi^(X1,⋯,Xn) (i=1,⋯,k) ，就以 θi^ 作为 θi 的估计 (i=1,⋯,k) 。如果要估计的是 θ1,⋯,θk 的某个函数 g(θ1,⋯,θk) ，则用 ĝ (X1,⋯,Xn)=g(θ1^,⋯,θk^) 去估计它。这样定出的估计量就叫矩估计。
矩估计在各种分布中的应用 正态分布 设 X1,⋯,Xn 是从正态总体 N(μ,σ2) 中抽出的样本，要估计 μ 和 σ2 。 μ 是总体的一阶原点矩，按矩估计，用样本的一阶原点矩即样本的均值 X⎯⎯⎯ 去估计。 σ2 是总体方差，即总体的二阶中心距，可用样本的二阶的二阶中心矩 m2 去估计。一般地，在估计方差时候常用样本方差 S2 而不用 m2 ，即对矩估计做了一定的修正。 如果要估计的是标准差 σ2 ，则由 σ=σ2‾‾‾√ ，按矩估计法，它可以用 m2‾‾‾√ 去估计，一般用 S2‾‾‾√=S 去估计，或者还做点修正。又当 μ≠0 时，（特别在 μ&gt;0 时，在有些问题中， μ 虽然未知，但事先可知道 μ&gt;0 。比如某个班级的平均成绩，它必然会大于0，因为没有人会考负分，全班也不太可能考0分）， σ/μ 称为总体的变异系数，变异系数是以均值为单位去衡量总体的标准差。在有些问题中，反映变异程度的标准差意义如何，要看总体均值 μ 而定。比如一大群人收入的标准差为50元，若其平均工资只有70元，则这个变异系数可算很大了；但若平均工资为850元，则这个变异程度就不算大了。所以，变异系数 σ/μ 不过是一定意义上的“相对误差”，按矩估计法，为估计 σ/μ 可用 m2‾‾‾√/X⎯⎯⎯ ,一般用 S/X⎯⎯⎯ 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cab6e4483b40834b9646bd53964c52c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ced29cf2a00278be10c3424859eb39/" rel="bookmark">
			参数的点估计问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文摘自 《概率论与数理统计》 陈希孺著 中国科学技术大学出版社 相关链接： 极大似然估计法 矩估计法
参数的点估计问题 设有一个总体统计，以 f(x;θ1,⋯,θn) 记其概率密度函数（若总体分布为连续型的）或其概率函数（如总体分布为离散型的）。我们约定称 f(x;θ1,⋯,θn) 为“总体分布”，其具体含义视其为连续型或离散型而定。这个分布包含 k 个未知数θ1,⋯,θk。例如，对正态总体 N(μ,σ2) ，有 θ1=μ,θ2=σ2 ，而 f(x;θ1,θ2)=(2πθ2‾‾‾‾‾√)−1exp−12θ2(x−θ1)2(−∞&lt;x&lt;∞) 若总体有二项分布 B(n,p) ，则 θ1=p ，而 f(x;θ1)=(nx)θx1(1−θ1)n−x(x=0,1,⋯,n) 当 k=1 时，也就是只有一个参数时，我们用 θ 取代 θ1 。
参数估计问题的一般提法是：设有了从总体中抽出的样本 X1,⋯,\Xn （这样样本是独立随机样本，即 X1,⋯,Xn 独立同分布，其公共分布就是总体分布），要依据这些样本去对参数 θ1,⋯,θk 中的一部分，或者估计它们某个已知函数 g(θ1,⋯,θk) 。例如，为了要估计 θ1 ，我们要构造出适当的统计量 θ1^=θ1^(X1,⋯,Xk) 。每当有了样本 X1,⋯,Xn ，就带入函数 θ1^(X1,⋯,Xk) 中算出一个值，用来作为 θ1 的估计值。为着这样的特定目的而够着统计量 θ̂ 叫做 θ1 的估计量。由于未知参数 θ1 是数轴上的一点，用 θ1 去估计 θ ，等于用一个点去估计另一个点，所以这样的估计叫做点估计。 点估计包含三种方法，包括矩估计法、极大似然估计法和贝叶斯估计法。我们将会在下面的博客一一介绍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5a26ba7a964ae0ec0e56f068205231/" rel="bookmark">
			反转字符串的所有方法-Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章转自： http://blog.csdn.NET/caroline_wendy/article/details/23438739
大神总结的很好，分享给大家。
Python实现字符串反转一共包含5种方法, 其中第一种最简单, 即步长为-1, 输出字符串，这个也叫作“分片法”;
方法如下
5种方法的比较:
1. 简单的步长为-1, 即字符串的翻转(常用);
2. 交换前后字母的位置;
3. 递归的方式, 每次输出一个字符;
4. 双端队列, 使用extendleft()函数;
5. 使用for循环, 从左至右输出;
代码:
# -*- coding: utf-8 -*- #eclipse pydev, python 3.3 #by C.L.Wang #time: 2014. 4. 11 string = 'abcdef' def string_reverse1(string): return string[::-1] def string_reverse2(string): t = list(string) l = len(t) for i,j in zip(range(l-1, 0, -1), range(l//2)): t[i], t[j] = t[j], t[i] return "".join(t) def string_reverse3(string): if len(string) &lt;= 1: return string return string_reverse3(string[1:]) + string[0] from collections import deque def string_reverse4(string): d = deque() d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5a26ba7a964ae0ec0e56f068205231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec72a6bf7179fd6008121a61fca96ae/" rel="bookmark">
			UNITY 学习笔记（三）——UGUI使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不确定内容或涉及到其他方面内容被标记为（？）或者（待补充） 改善了一下文章结构，引用官方视频的截图尽量减少
UI: Canvas是用来控制一组UI元素渲染方式的组件 场景中可以创建多个canvas Render mode： Overlay:UI覆盖整个Scene，屏幕变化时自动调整大小，Transform自动调整，不能编辑 Camera：指定Camara渲染，根据Camera自动调整 Event camera用来检测在哪种摄像头下接受时间 Component：Rectransform：UI为2D矩形 Anchors（锚点）：调整锚点可以确定UI和区域的关系
Button:需要Image Script 和Button Script(text可删除) Interactable False：Button会变成Disable True：接受输入 Transition mode：不按、选择、按下、锁定 模式：无、颜色改变、Sprites过渡、动画过渡 Fade Duration：两个状态的过渡时间 动画过渡：需要在Button上加一个animator Nevigation：描述使用键盘或者Contrpller（？）控制时UI元素的处理方式（Nevigation部分待补充）
当Eventsystem检测到同一个button上出现 press和release时，会处理一次点击，同时调用（call）一次Onclick事件 被Onclick调用的函数必须为public void，至多一个入参 处理Button其他行为需要增加一个额外的component（？） Event Trigger组件（待补充）
ImageType Sinple：Sprite会拉伸来满足Rect transform的大小 Preserve Aspect：图像会在边界范围内尽可能放大，保持宽高比 Sliced：图片变为九分格，只有中心被拉伸，保证边界部分不失真，这些分区的texture可以在sprite editor的Border设置 Tiled： Filed：只显示图片的一部分（血条、汽车速度盘）
Text浮动文本（比如Score显示）： 可选字体（必须放在Assets中）可更改大小、行间距 Rich text true：可使用文字颜色、表情（=-= Horizontal/Vertical Overflow：Warp：超出界限部分到下一行 Overflow：溢出
实例： Event System：至少含有一个EventSystem和一个Input组件，用来监控场景中的UI First Selected：UI元素被默认选中 Submit button 确定键 Cancel button 取消键 Input Actions Per Second：过1/n s延迟接受下一次输入 Force Module Active：允许在移动设备上的单机设备输入（？）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6716d2d49559fe62dc5241cd74015f92/" rel="bookmark">
			聚类算法——python实现SOM算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法简介 SOM网络是一种竞争学习型的无监督神经网络，将高维空间中相似的样本点映射到网络输出层中的邻近神经元。
训练过程简述：在接收到训练样本后，每个输出层神经元会计算该样本与自身携带的权向量之间的距离，距离最近的神经元成为竞争获胜者，称为最佳匹配单元。然后最佳匹配单元及其邻近的神经元的权向量将被调整，以使得这些权向量与当前输入样本的距离缩小。这个过程不断迭代，直至收敛。
网络结构：输入层和输出层（或竞争层），如下图所示。 输入层：假设一个输入样本为X=[x1,x2,x3,…,xn]，是一个n维向量，则输入层神经元个数为n个。 输出层（竞争层）：通常输出层的神经元以矩阵方式排列在二维空间中，每个神经元都有一个权值向量。 假设输出层有m个神经元，则有m个权值向量，Wi = [wi1,wi2,....,win], 1&lt;=i&lt;=m。 算法流程： 1. 初始化:权值使用较小的随机值进行初始化，并对输入向量和权值做归一化处理 X’ = X/||X|| ω’i= ωi/||ωi||， 1&lt;=i&lt;=m ||X||和||ωi||分别为输入的样本向量和权值向量的欧几里得范数。 2.将样本输入网络:样本与权值向量做点积，点积值最大的输出神经元赢得竞争， （或者计算样本与权值向量的欧几里得距离，距离最小的神经元赢得竞争）记为获胜神经元。 3.更新权值:对获胜的神经元拓扑邻域内的神经元进行更新,并对学习后的权值重新归一化。 ω(t+1)= ω(t)+ η(t，n) * (x-ω(t)) η(t，n):η为学习率是关于训练时间t和与获胜神经元的拓扑距离n的函数。 η(t，n)=η(t)e^(-n) η(t)的几种函数图像如下图所示。 4.更新学习速率η及拓扑邻域N,N随时间增大距离变小，如下图所示。 5.判断是否收敛。如果学习率η&lt;=ηmin或达到预设的迭代次数，结束算法。 python代码实现SOM import numpy as np import pylab as pl class SOM(object): def __init__(self, X, output, iteration, batch_size): """ :param X: 形状是N*D， 输入样本有N个,每个D维 :param output: (n,m)一个元组，为输出层的形状是一个n*m的二维矩阵 :param iteration:迭代次数 :param batch_size:每次迭代时的样本数量 初始化一个权值矩阵，形状为D*(n*m)，即有n*m权值向量，每个D维 """ self.X = X self.output = output self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6716d2d49559fe62dc5241cd74015f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25423efebaea8b30249ff96f91796f16/" rel="bookmark">
			java 汉字与UTF-8十六进制编码 间相互转换方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决了困扰了很久的问题。才疏学浅，留个记忆。
从jni收到char[]类型数据，中文乱码
char[] obj.data String str = String.copyValueOf(obj.data) ;
String[] _Info = str.split(",");
for（int i=0，i&lt;_Info .length , i++）
alias=alias+Integer.toHexString((int)_Info [1].charAt(i));
接下去用下面的方法就行
原文：http://blog.csdn.net/top_code/article/details/8450423
最近项目中需要把中文转换为UTF-8编码，并且还能将转换后的UTF-8编码转换为原来的中文，比如 上海 转换为UTF-8编码为 E4B88AE6B5B7，
Google了不少时间，然后参考 JDK源码 实现了上述功能
代码如下：
[java] view plain copy /** * UTF-8编码 转换为对应的 汉字 * * URLEncoder.encode("上海", "UTF-8") ---&gt; %E4%B8%8A%E6%B5%B7 * URLDecoder.decode("%E4%B8%8A%E6%B5%B7", "UTF-8") --&gt; 上 海 * * convertUTF8ToString("E4B88AE6B5B7") * E4B88AE6B5B7 --&gt; 上海 * * @param s * @return */ public static String convertUTF8ToString(String s) { if (s == null || s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25423efebaea8b30249ff96f91796f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c9aec07a3212c1a14f0b30e31a1901/" rel="bookmark">
			Oracle的并发控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并发访问带来的问题
丢失更新：一个事务修改某行数据时，另一个事务同时修改了该行数据，使第一个事务对数据的修改丢失。
脏读：一个事务读取了另一个事务未提交的数据。
不可重复读：一个事务再次读取之前曾读取过的数据时，发现该数据已经被另一个已提交的事务修改。
幻读：一个事务根据相同的查询条件，重新执行查询，返回的记录中包含与前一次执行查询返回的记录不同的行。
锁基本概念
锁：用来共享资源控制并发访问的一种机制。
①、锁由Oracle自动管理，锁持续的时间等于被提交事务处理的时间。
②、单用户数据库不需要锁机制。
Oracle锁的分类：
▲锁的类型：
①、共享锁（share locks）也称读锁，s锁
②、排它锁（exclusive locks）也称写锁，x锁
▲按锁保护的内容分类
①、DML锁（DML lock）：用来保护数据的完整性和一致性。
TX锁（事务锁或行级锁）
事务发起第一个修改数据的语句时会自动得到TX锁，而且会一直持有这个锁，直到事务执行提交或回滚。TX锁用作一种排队机制，使得其他会话可以等待这个事务执行。事务中修改或通过悲观锁定选择的每一行都会指向该事务的一个相关TX锁。 TM锁（表级锁）
TM锁用于确保在修改表的内容时，表的结构不会改变当一个会话开始更新一个表时，会自动获得这个表的TM锁，这样能够防止另一个会话在该表上执行DROP或者ALTER语句删除该表或更改该表的结构。 ②、DDL锁（DDL lock）：用来保护数据对象结构定义。
DDL操作会自动为数据库对象加DDL锁。 注意：在Oracle中，DDL语句包装在隐式提交（回滚）中来执行操作。
DDL语句执行伪代码
③、内部锁和闩（internal locks and latchs）：用来保护数据库内部数据结构。
内部锁有Oracle来管理，以保护内部数据库的结构。 闩就是一种锁，设计为只保持极短的时间，用于保护某些内存结构。 ▲锁的机制问题
○死锁：两个事务（会话）都进入了彼此等候对方锁定的资源时的一种停止状态。
①、会话1
UPDATE A SET X=X+1; UPDATE B SETX=X+1;
②、会话2 语句
UPDATE B SET X=X+1; UPDATE A SET X=X+1;
解决死锁：“牺牲”一个会话，回滚一个会话的事务，是另一个会话事务继续执行。
在发生死锁时Oracle数据库会在服务器上创建一个跟踪文件记录死锁。
注意：不要在开发过程中人为的“提供条件”使Oracle产生死锁。
○阻塞：如果一个会话持有某个资源的锁，而另一个会话在请求这个资源，就造成了阻塞。
【阻塞是可以避免的，最常出现在交互式应用中，这些应用程序会在数据库中读取一些数据，并且让用户在屏幕上修改这些数据。但对于多用户系统来说，此时另一个用户可能正在修改这些数据，他已经锁定了这些数据，要修改数据的用户就处于阻塞状态。如果
在交互应用中存在阻塞，说明可能同时存在丢失更新。
如果真的发现会话在一个交互应用中被阻塞，就说明很有可能同时存在另一个BUG，丢失更新】
○悲观锁定：是指在读取数据后马上锁定相关资源。
语法：select … for update[of column_list] [waitn|nowait]
Of 子句用于指定即将更新的列，即锁定行上的特定列。 Wait子句指定等待其他用户释放锁的秒数，防止无限期的等待，nowait表示不等待。 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20c9aec07a3212c1a14f0b30e31a1901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6edc3549be58035dbe683f085e75c6c5/" rel="bookmark">
			php&#43;mysql&#43;apache 环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache2.2+php5.3+mysql5.1.73 配置 安装Apache2.2
下载Apache软件 双击安装 注意端口占用 如果80端口被占用 在填写服务器信息的时候 要选择第二项这里选择__自定义__安装，用户也可以默认安装单机“Build Headers and libraries”，选择“This feature will be installed on local dirive.”用户可以修改安装路径 这里使用默认的路径安装完成后 右下角出现apache的图标
windows 中 双击Apache图标出现了 没有服务可用的情况 就需要 执行 【以管理员身份运行 命令行 -&gt; 进入Apache的bin目录 输入
httpd.exe -k install
在重新启动apache服务就ok
在浏览器的地址栏中输入 127.0.0.1:8080 显示成功。 如果为默认安装则不需要输入8080 Mysql安装
选择安装类型 本例选择__自定义安装__安装路径默认安装完成后开始配置mysql 选中选项 密码设置长度不能小于6位 命令窗口为 win-&gt;所有程序-&gt; MySQL-&gt;MySQL Server 安装PHP 版本：5.3.4
php.ini-development 开发用的 php.ini-produciton 生产机用的将文件夹中的php.ini-development 复制一份修改为 php.ini 在放回文件夹将php.ini 文件中 ; extension_dir = "./" 修改为 extension_dir = "C:\Users\superking\Desktop\php\ext" 后面跟的是你的PHP 所在文件夹的路径 ;default_charset = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6edc3549be58035dbe683f085e75c6c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f22bf44baab0e152ba3ed10570a83d7/" rel="bookmark">
			亲手创建一台Ubuntu&#43;PHP5&#43;MySQL5&#43;Nginx&#43;openSSL&#43;sshFtp(sftp)的微信小程序云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲手创建一台Ubuntu+PHP5+MySQL5+Nginx+openSSL+sshFtp的微信小程序云服务器 小程序要求Request必须SSL连接，一般虚拟主机不支持SSL，自己有云服务器最佳。
系统可以选Ubuntu14 64位 //更新apt-get
sudo apt-get update //安装nginx
sudo apt-get install nginx //选择Y安装 //安装PHP5-fpm
sudo apt-get install php5-fpm //安装MySQL5
sudo apt-get install mysql-server mysql-client //过程中输入两次root的密码。 //安装php的各种模块支持
apt-get install php5-mysql php5-curl php5-gd php5-intl php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-ming php5-ps php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl //直接Y，全安装 //设置 php.ini
sudo vi /etc/php5/fpm/php.ini //使用VI，按i进入insert插入模式。 //找到 #cgi.fix_pathinfo=1 //改成 cgi.fix_pathinfo=0 //记得去掉前面的注释。 //按大写的Q，输入w保存，输入q退出。 //接下来修改nginx配置。直接添加一个配置即可。
sudo vi /etc/nginx/conf.d/my.conf //生成一个 xxxx.conf ，无所谓文件名，扩展名是conf就会被引用。 //输入下面的内容：
server { listen 80; listen 443 ssl; root /我的www目录; ssl on; ssl_certificate /etc/ssl/private/1_api.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f22bf44baab0e152ba3ed10570a83d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f835be02df68314f6c03c76e7e3db0ec/" rel="bookmark">
			Jenkins执行shell脚本，提示“未找到命令”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 如题，在Jenkins上使用 ng build 命令对一个angular2项目进行构建，控制台输出如下信息：
/tmp/hudson3008133988036917430.sh:行3: ng: 未找到命令
我们来分析一下出现此问题可能的原因：
Linux主机环境变量设置失败，登录Linux主机执行此命令仍会提示“命令未找到”
Jenkins配置原因，登录Linux主机可以正常执行此命令
解决方案 先在Linux主机上进行验证，可以正常执行，环境变量配置没问题。 Jenkins下执行 ng build 命令会提示“命令未找到”，但是执行如 ls 等原生命令没有任何问题。在Linux主机是通过修改 /etc/profile 文件来配置环境变量，则问题可能是Jenkins在执行shell脚本时没有加载 /etc/profile 文件，因此找不到 ng 命令，会提示“命令未找到”。
Jenkins默认情况下执行shell脚本是使用非登录方式，然而非登录方式不会加载 /etc/profile 文件，在 Execute shell 中 添加如 #!/bin/sh -l 命令修改为登录方式即可解决问题。
#!/bin/sh -l cnpm install ng build rm -rfv /root/apache-tomcat-7.0.47/webapps/ROOT/dist mv dist /root/apache-tomcat-7.0.47/webapps/ROOT 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1043c263d8fd9743234b19e37124035/" rel="bookmark">
			Netty 学习方法及记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChannelPipeline 源码ChannelPipeline的开头描述部分对于netty很有帮助，他解释了 channelHandler，addLast方法，事件传播，以及io线程和业务线程分离等等，推荐各位认真看看。
不管我们上传发送什么数据格式给底层（也就netty层）都要转化为ByteBuf进行传输，也就是最进行io的一定是二进制，其他String或者POJO都要转化为ByteBuf后才可以用。这也是Decoder和Encoder的作用。
而负责分包的LineBasedFrameDecoder，一定是最接近IO，为什么呢？如果先进行对象的转换，那么用多少字节进行对象的构造呢？是不确定的。所以只有先分包，然后用分好的包进行对象的构造。另外，由于分包是接近IO的，所以不管是字符串String分包，还是别的（换行）分包，都会转换为字节码的形式进行匹配。应用如下：
ch.pipeline().addLast(new LineBasedFrameDecoder(1024));// 根据 分隔符（换行符）分割，分割后还是 ByteBuf ch.pipeline().addLast(new StringDecoder());// 用于inbound 的解析，也就是read(), 从ByteBuf 转换到了String. ch.pipeline().addLast(new StringEncoder());// 用户outbould ，也就是write() , 从String 转换到了ByteBuf. ch.pipeline().addLast( new EchoClientHander()); 经过上面的设置后，server的read方法就可以直接读了。
class EchoClientHander extends ChannelInboundHandlerAdapter { Logger logger=Logger.getLogger(EchoClientHander.class.getName()); @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { logger.info(msg.toString()); } } 怎样快速的找到函数调用关系。根据
ChannelPipeline.fireChannelRead() 这是一个触发方法，然后在idea中 ctrl+alt+h ,就可以显示类函数调用关系图。 那么然后就是一点点进行每个步骤的分析。整体流程已经清楚了。 其他
在基类AbstractBootstrap有handler方法，目的是添加一个handler，监听Bootstrap的动作，客户端的Bootstrap中，继承了这一点。
在服务端的ServerBootstrap中增加了一个方法childHandler，它的目的是添加handler，用来监听已经连接的客户端的Channel的动作和状态。
handler在初始化时就会执行，而childHandler会在客户端成功connect后才执行，这是两者的区别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d211cb16cd56228784af5aaa572d9e6/" rel="bookmark">
			ajax无刷新加载数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做了一个手机端的需求，里面有一个需要使用到ajax无刷新加载数据这样的功能
老样子先展示所需要实现的功能，
里面的数据是我的测试数据，随意了一点，但是能解决问题就行了，不要在意
正题来了：
首页就是当第一次访问的数据的时候，页面会加载出一部分数据，当你点击查看更多的时候会加载出另外一部分数据
如下图所示：
这时2数据有七条，仔细看一下第一张图的数据只有5条
当再次点击的时候按钮就会变成没有更多的信息了，因为我总共添加了七条数据
、
具体的实现手法很简单就是利用ajax的刷新加载数据
上代码:
1.以为页面比较简答，我就只贴一部分比比较重要的了
按钮的代码：&lt;a href="javascript:void(0);" title="查看更多" id="imore" class="imore"&gt;查看更多&lt;/a&gt;
请记好这个id值 下面还会用到，到时候别说不知道
3.开始js代码
注意：在这里我使用的jquery的ajax，别忘了在文件中引入jqery文件
代码如下：
&lt;script&gt;
// 首先定义一下page 为 1 因为当也面第一次加载的时候默认加载的数据就是第一页的数据
var page = 1;
function getlist(page) {
$.ajax({
type : 'GET',
// cateid 这个参数根据自己项目的需求传参
ur : '__CONTROLLER__/getlist/' +page+ '/cateid/'+&lt;?php echo I(get.cateid) ?&gt;',
dataType 'json',
success : function(data){
// data 为请求返回的数据 对data 进行遍历
var hrtml = "";
$(data).each(function(k,v) {
// 测试使用
html += '111&lt;br/&gt;'; });
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d211cb16cd56228784af5aaa572d9e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde5aeb602dbc104ffffa23327e643bf/" rel="bookmark">
			[人工智能]深度学习卷积神经网络的秒懂各种操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者:深度学习思考者
###来给大家总结一下卷积神经网络的各种操作 ,大家能够秒懂!
先来几个静态图:
卷积算法的一些神奇GIF动画，包括不同的padding和strides。
上述是四种不同的卷积方式，大家都知道是哪种卷积吧？欢迎评论区给出答案！
#搞懂卷积神经网络流程
#揭示输入的图像的真面目
#结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c45ba7ca14dd4111044c7a0e12c30ae/" rel="bookmark">
			Python解析IP地址CIDR的形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：使用IPy库
&gt;&gt;&gt; from IPy import IP &gt;&gt;&gt; ip = IP('127.0.0.0/30') &gt;&gt;&gt; for x in ip: ... print(x) ##print前需要有tab空格 ... ##此处回车即可 127.0.0.0 127.0.0.1 127.0.0.2 127.0.0.3 方法二：使用netaddr库
CIDR也能直接转成IP地址段 &gt;&gt;&gt; from netaddr import * &gt;&gt;&gt; ip = IPNetwork('192.0.2.16/29') &gt;&gt;&gt; ip_list = list(ip) &gt;&gt;&gt; print(ip_list) [IPAddress('192.0.2.16'), IPAddress('192.0.2.17'), IPAddress('192.0.2.18'), IPAddress('192.0.2.19'), IPAddress('192.0.2.20'), IPAddress('192.0.2.21'), IPAddress('192.0.2.22'), IPAddress('192.0.2.23')] IP段208.130.29.30-35转换成CIDR格式 &gt;&gt;&gt; from netaddr import * &gt;&gt;&gt; startip = '208.130.29.30' &gt;&gt;&gt; endip = '208.130.29.35' &gt;&gt;&gt; cidrs = netaddr.iprange_to_cidrs(startip, endip) &gt;&gt;&gt; for k, v in enumerate(cidrs): .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c45ba7ca14dd4111044c7a0e12c30ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf3dda70c76cf85aa0519317613c7c1/" rel="bookmark">
			去除c代码里面的宏定义代码块的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash find . -name "*.c" &gt; dstfile while read line do del_macro.py USING_SMUX_MODULE $line done &lt;dstfile
#!/usr/bin/python
import linecache
import os
import re
import sys
macro=sys.argv[1]
macro="#ifdef " + macro
dstfile=sys.argv[2]
#
def macro_delete(macro, dstfile):
fp = open(dstfile,'r+');
i=0;
flag=0;
str=fp.readlines();
for line in str:
#if (line.rstrip() == "#endif" &amp;&amp; flag==1):
if (re.match('#endif', line) != None and flag==1):
line="";
flag=0;
#if (line.rstrip() == macro):
if (re.match(macro, line) != None):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf3dda70c76cf85aa0519317613c7c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb0729de8783faa4cae3d9b46ea32f2/" rel="bookmark">
			springboot&#43;shiro&#43;mybatis实现角色权限控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 spring+spirngmvc+shiro的整合已经有很多了，之前的项目中也用过，但是最近想在springboot中使用shiro这样，其他项目需要的时候只需要把它依赖进来就可以直接使用，至于shiro的原理其他的blog都有很多介绍。这里只讲几个重点在项目中注意的地方。 shiro官网 http://shiro.apache.org/
shiro配置中重要的几个文件 其实最重要的就是shiro配置文件 ShiroConfiguration.java：shiro启动时候的初始化工作，比如哪些是需要认证，哪些不需要认证；缓存配置设置；shiro权限数据在页面展示时整合需要的模板套件配置，等等。
ShiroRealm.java：shiro权限认证的具体实现代码，因为shiro本身只提供拦截路由，而具体如何数据源则由用户自己提供，不同的项目不同的要求，要不要加缓存登陆验证次数，要不要密码加密设置其他具体方式，这些都由用户自己决定，而shiro只提供给用户权限验证的格式接口，通过用户提供的数据源shrio判断要不要给具体用户授权请求路径的判断。 ShiroRealm 涉及到以下点： principal:主体，就是登陆的当前用户类型的数据实体 credentials：凭证，用户的密码，具体加密方式用户自己实现，什么都不做就是原文
Roles：用户拥有的角色标识（角色名称，admin,account,customer_service），字符串格式列表:用户拥有多个角色的可能Permissions：用户拥有的权限标识（每个权限唯一标识，比如主键或者权限唯一标识编码），字符串格式列表：用户拥有多个权限的可能 pom 在springboot+mybatis基础上加入shiro依赖
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xm.shiro&lt;/groupId&gt; &lt;artifactId&gt;springboot-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot-shiro&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;repositories&gt;&lt;!--ali 代码库 --&gt; &lt;repository&gt; &lt;id&gt;maven-ali&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- Spring Boot 启动父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;mybatis-spring-boot&gt;1.2.0&lt;/mybatis-spring-boot&gt; &lt;mysql-connector&gt;5.1.39&lt;/mysql-connector&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Test 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb0729de8783faa4cae3d9b46ea32f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec48303f4ad4cf16b7336f629335b6b/" rel="bookmark">
			Java用队列优化递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归的优点 递归代码写起来比较方便简洁，结构层次清晰，可读性比较好。递归的缺点 递归需要调用函数，递归需要系统堆栈，递归空间和时间消耗都比较大，并且如果递归太深，会发生 堆栈溢出，系统会奔溃。如何解决递归太深的问题？ 当使用递归遍历的目录可能存在递归太深的时候，我们可以选择用队列来优化递归。遍历文件例子： public void getFile(File file){ if(file.isDirectory()){//如果是目录 File[] files = file.listFiles(); for(int i=0;i&lt;files.length;i++) getFile(files[i]);//递归 } else if(file.isFile()){ //如果是文件，就输出。 System.out.println(file.getName()); } } 5 . 使用队列优化。
//创建一个队列 Queen&lt;File&gt; queue = new LinkedList&lt;File&gt;(); queue.offer(file); while(!queue.isEmpty()){//如果队列不为空 File file = queue.poll(); if(file.isDirectory()){ //从队列中获取一个File File[] files = file.listFiles(); //是目录,将目录下所有文件遍历出来，存储到队列中 for(int i =0;i&lt;files.length;i++) queue.offer(files[i]); }else{ //是文件，进行输出。 System.out.println(file.getName()); } } 6 . 总结 如果递归的是深而不广的树时，应该使用队列来优化递归；如果递归是广而不深的树的时候，就应该用递归来优化队列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666b9732538787c34461c0671e6d3a5a/" rel="bookmark">
			汉字转换拼音函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉字转换为拼音 调用ConvertPinyin()函数, 参数为你要转换的汉字
返回值就是转换后的拼音
可以只返回首字母或者首字母大写的全拼拼音
var phoneticTranscriptionObj = { "a": "\u554a\u963f\u9515", "ai": "\u57c3\u6328\u54ce\u5509\u54c0\u7691\u764c\u853c\u77ee\u827e\u788d\u7231\u9698\u8bf6\u6371\u55f3\u55cc\u5ad2\u7477\u66a7\u7839\u953f\u972d", "an": "\u978d\u6c28\u5b89\u4ffa\u6309\u6697\u5cb8\u80fa\u6848\u8c19\u57ef\u63de\u72b4\u5eb5\u6849\u94f5\u9e4c\u9878\u9eef", "ang": "\u80ae\u6602\u76ce", "ao": "\u51f9\u6556\u71ac\u7ff1\u8884\u50b2\u5965\u61ca\u6fb3\u5773\u62d7\u55f7\u5662\u5c99\u5ed2\u9068\u5aaa\u9a9c\u8071\u87af\u93ca\u9ccc\u93d6", "ba": "\u82ad\u634c\u6252\u53ed\u5427\u7b06\u516b\u75a4\u5df4\u62d4\u8dcb\u9776\u628a\u8019\u575d\u9738\u7f62\u7238\u8307\u83dd\u8406\u636d\u5c9c\u705e\u6777\u94af\u7c91\u9c85\u9b43", "bai": "\u767d\u67cf\u767e\u6446\u4f70\u8d25\u62dc\u7a17\u859c\u63b0\u97b4", "ban": "\u6591\u73ed\u642c\u6273\u822c\u9881\u677f\u7248\u626e\u62cc\u4f34\u74e3\u534a\u529e\u7eca\u962a\u5742\u8c73\u94a3\u7622\u764d\u8228", "bang": "\u90a6\u5e2e\u6886\u699c\u8180\u7ed1\u68d2\u78c5\u868c\u9551\u508d\u8c24\u84a1\u8783", "bao": "\u82de\u80de\u5305\u8912\u96f9\u4fdd\u5821\u9971\u5b9d\u62b1\u62a5\u66b4\u8c79\u9c8d\u7206\u52f9\u8446\u5b80\u5b62\u7172\u9e28\u8913\u8db5\u9f85", "bo": "\u5265\u8584\u73bb\u83e0\u64ad\u62e8\u94b5\u6ce2\u535a\u52c3\u640f\u94c2\u7b94\u4f2f\u5e1b\u8236\u8116\u818a\u6e24\u6cca\u9a73\u4eb3\u8543\u5575\u997d\u6a97\u64d8\u7934\u94b9\u9e41\u7c38\u8ddb", "bei": "\u676f\u7891\u60b2\u5351\u5317\u8f88\u80cc\u8d1d\u94a1\u500d\u72c8\u5907\u60eb\u7119\u88ab\u5b5b\u9642\u90b6\u57e4\u84d3\u5457\u602b\u6096\u789a\u9e4e\u8919\u943e", "ben": "\u5954\u82ef\u672c\u7b28\u755a\u574c\u951b", "beng": "\u5d29\u7ef7\u752d\u6cf5\u8e66\u8ff8\u552a\u5623\u750f", "bi": "\u903c\u9f3b\u6bd4\u9119\u7b14\u5f7c\u78a7\u84d6\u853d\u6bd5\u6bd9\u6bd6\u5e01\u5e87\u75f9\u95ed\u655d\u5f0a\u5fc5\u8f9f\u58c1\u81c2\u907f\u965b\u5315\u4ef3\u4ffe\u8298\u835c\u8378\u5421\u54d4\u72f4\u5eb3\u610e\u6ed7\u6fde\u5f3c\u59a3\u5a62\u5b16\u74a7\u8d32\u7540\u94cb\u79d5\u88e8\u7b5a\u7b85\u7be6\u822d\u895e\u8df8\u9ac0", "bian": "\u97ad\u8fb9\u7f16\u8d2c\u6241\u4fbf\u53d8\u535e\u8fa8\u8fa9\u8fab\u904d\u533e\u5f01\u82c4\u5fed\u6c74\u7f0f\u7178\u782d\u78a5\u7a39\u7a86\u8759\u7b3e\u9cca", "biao": "\u6807\u5f6a\u8198\u8868\u5a4a\u9aa0\u98d1\u98d9\u98da\u706c\u9556\u9573\u762d\u88f1\u9cd4", "bie": "\u9cd6\u618b\u522b\u762a\u8e69\u9cd8", "bin": "\u5f6c\u658c\u6fd2\u6ee8\u5bbe\u6448\u50a7\u6d5c\u7f24\u73a2\u6ba1\u8191\u9554\u9acc\u9b13", "bing": "\u5175\u51b0\u67c4\u4e19\u79c9\u997c\u70b3\u75c5\u5e76\u7980\u90b4\u6452\u7ee0\u678b\u69df\u71f9", "bu": "\u6355\u535c\u54fa\u8865\u57e0\u4e0d\u5e03\u6b65\u7c3f\u90e8\u6016\u62ca\u535f\u900b\u74ff\u6661\u949a\u91ad", "ca": "\u64e6\u5693\u7924", "cai": "\u731c\u88c1\u6750\u624d\u8d22\u776c\u8e29\u91c7\u5f69\u83dc\u8521", "can": "\u9910\u53c2\u8695\u6b8b\u60ed\u60e8\u707f\u9a96\u74a8\u7cb2\u9eea", "cang": "\u82cd\u8231\u4ed3\u6ca7\u85cf\u4f27", "cao": "\u64cd\u7cd9\u69fd\u66f9\u8349\u8279\u5608\u6f15\u87ac\u825a", "ce": "\u5395\u7b56\u4fa7\u518c\u6d4b\u5202\u5e3b\u607b", "ceng": "\u5c42\u8e6d\u564c", "cha": "\u63d2\u53c9\u832c\u8336\u67e5\u78b4\u643d\u5bdf\u5c94\u5dee\u8be7\u7339\u9987\u6c4a\u59f9\u6748\u6942\u69ce\u6aab\u9497\u9538\u9572\u8869", "chai": "\u62c6\u67f4\u8c7a\u4faa\u8308\u7625\u867f\u9f87", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/666b9732538787c34461c0671e6d3a5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4073f201c52ab8fa22593ccb3ad5118f/" rel="bookmark">
			kibana visualize添加自定义查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在分析nginx日志的时候的，我想统计时间范围内那些访问地址最高并且过滤掉jpg之类的请求。
1.进入Visualize-&gt;点击添加，选择Pie chart饼状图
选择之前配置的logstash-*,如果没有可以选择的，请先导入一份数据到elasticsearch,可参考http://blog.csdn.net/xr568897472/article/details/71216971进入数据导入
我解析出来的request.keyword就是对应的是nginx的请求日志路径，如下所示，展示了排名前五访问次数最多的
现在我想排除掉路径中含有ajax字符的路径，不想统计这些。实现方法如下
点击修改标识，覆盖填写的脚本，然后点击Done，然后就可以看到自己想要的结果。上一步骤如果你点了减号，统计的结果与写的脚本内容表达的是相反的意思
{ "query": { "bool": { "must_not": [ {"match": { "request": "ajax" }} ] } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda42ef53f1fb44e5ee51065787bb82d/" rel="bookmark">
			在一个字符串中删除在另一个字符串中出现的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：两个字符串A、B，从A中剔除存在于B中的字符。比如A=“hello world”,B=”er”,那么剔除之后A变为”hllowold”。空间复杂度要求是O(1),时间复杂度越优越好。
思路：hash+双指针。 对需要剔除的字符串做hash处理，查询复杂度为O(1), 字符总数为128， 所以空间复杂度为O(1). 双指针用于对对初始串的替换，在O(n)时间内完成替换，方法是设置两个指针: fast 和 slow。当碰到不是需要剔除的字符时，将fast指针指向的内容赋给slow，fast和slow都向前走一步；当碰到的是需要剔除的字符是，就fast指针向前走一步。这样就把那个需要删除的字符给隔过去了
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; void hash1(const string &amp;str, int arr[]) { if (str.empty()) { return; } for (int i = 0; i &lt; str.length(); i++) { arr[str[i]] = 1; } } void delectstr(string &amp;str,const int arr[]) { if (str.empty()) { return; } char *first = &amp;str[0];//创建两个指向数组头部的指针 char *last = &amp;str[0];//last作用是存储不被删除的，而first起到一个探路的作用，找到不被删除的字符将其地址给first while (*first!='\0')//直到循环完毕 { if (arr[*first]==0)//如果这个不是要删除的字符 { *last = *first;//换地址 last++;//last向后继续 } first++;//first向后继续 } *last = '\0';//已经遍历完毕，所以将结束 字符放在*last的位置上，这样所有不被删除的字符就放在了前面 } int main() { int hasharr[128]; memset(hasharr,0,sizeof(hasharr)); string str1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda42ef53f1fb44e5ee51065787bb82d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fc7ff098e62c79113fac02d9f56edb8/" rel="bookmark">
			菜单ListView联动内容RecyclerView（带吸顶效果）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天测试发的bug修得差不多了，有点属于自己的时间，写了个仿美团/京东的ListView联动Demo，现供大家参考参考，如有bug或更好的实现方式，望大家多多指出。 先来看看效果 一、首先我们来看看MainActivity.java 这里有data和view的处理。data为测试用的，view为左边一个ListView以及适配器AdapterLeft和右边RecyclerView和适配器AdapterRight，提醒下RecyclerView别忘了setLayoutManager（）。
package com.zyf.linkagelistview; import android.app.Activity; import android.os.Bundle; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.util.Log; import android.view.View; import android.widget.AdapterView; import android.widget.ListView; import com.zyf.linkagelistview.adapter.AdapterLeft; import com.zyf.linkagelistview.adapter.AdapterRight; import com.zyf.linkagelistview.bean.Bean; import java.util.ArrayList; public class MainActivity extends Activity { private static final String TAG = MainActivity.class.getSimpleName(); private ListView mListViewLeft; private AdapterLeft mAdapterLeft; private RecyclerView mListViewRight; private AdapterRight mAdapterRight; private ArrayList&lt;Bean&gt; dataList = new ArrayList&lt;&gt;(); private ArrayList&lt;String&gt; titleList = new ArrayList&lt;&gt;(); private ArrayList&lt;Integer&gt; titlePosList = new ArrayList&lt;&gt;(); private String mCurTitle = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fc7ff098e62c79113fac02d9f56edb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313b8c5265ce66541d2ed1162b71ebb5/" rel="bookmark">
			Error:Could not run build action using Gradle installation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误内容： Error:Could not run build action using Gradle installation ‘D:\AndroidStudio\AS2.x\gradle\gradle-3.3’.
解决方案：
方式一：文件夹下手动清理
找到存储本地的gradle全局配置文件 .gradle文件夹，一般在C盘用户目录下，将里面的缓存文件清空，重启AS就OK了。(一般不建议使用这种方式，知道有这种方式就行，如果不清楚该文件下文件配置的新手，很容易删错文件)
方式二：利用AndroidStudio内置的清理工具清理
具体步骤如下： 1) File -&gt; Invalidate caches / Restart 2)Invalidate and Restart
点击后会自动清理并且重启studio。
注意：一定要保持gradle-wrapper.properties下distributionUrl=https://services.gradle.org/distributions/gradle-3.3-all.zip和本地gradle版本一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b5af22b64c3c9688c3ffa26abfcb67/" rel="bookmark">
			CTF---图片隐写相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTF—图片隐写相关 0 前言 CTF中，有一类题和图片相关，各种转换，这里记一些图片的玩法
1 jpg图片属性 正常的jpg图片，选中右键查看属性，在详细信息一栏会发现有很多属性可以修改，简单的题目可以在这里隐藏信息
2 图种 图种就是图片后面再放点信息进去，压缩包、txt文档、或者再来一张图片，要隐藏的信息完全没有限制，cmd举例如下：
:: /b表示二进制方式 copy a.jpg/b+b.zip/b c.jpg copy a.jpg/b+b.txt/b c.jpg copy a.jpg/b+b.jpg/b c.jpg 得到的c.jpg就是图种了
还原也比较简单，整理几种方法：
使用工具分离，比较好用的工具有binwalk和foremost，binwalk建议使用这样的命令: binwalk -eM &lt;file_path&gt;，foremost直接跟文件路径就好了，一般foremost效果要好一些，可以都试一下在16进制编辑器打开然后手动分离，这种方式比较考验对文件格式的熟悉程度，需要对常见的文件类型开头结尾比较熟悉，16进制编辑器选择自己熟悉的就好，010Editor、WinHex、HxD都是比较成熟的软件，我会用rehex针对压缩文件的技巧，如果隐藏的信息是zip之类的压缩文件，可以直接把文件用压缩软件打开，就能提取压缩包里的文件了 注：有些图片后隐藏图片的情况，可能会把第二张图片头给去掉，然后把两张图片合在一起，由于特征没了，提取工具就没用了，使用手动分离的方法：16进制编辑器打开，找第一张图片的尾部，然后把第二张图片的头给加一下，这样就正常了
3 图层里的秘密 LSB LSB, Least Significant Bit, 最低有效位，指图片像素的低位数据，因为低位对图片显示影响不大，所以可以用来隐藏数据
stegsolve是一个比较有名的查看图片LSB隐写的工具，一般有2种使用方法：
把图片打开，点下面的箭头切换图层，可能会显示一些隐藏信息，如二维码图片提取低位数据：Analyse-&gt;Data Extract，可以先勾选 Red Green Blue的0位，点击 Preview试试看，一般都藏在0,1,2这些低位里面，只能试着观察了 有一个隐藏，检测，恢复的网站：http://incoherency.co.uk/image-steganography/
4 图片头损坏 有些图片会被故意修改前几个字节，导致无法显示
还原很简单，找一个类型相同的文件，在16进制编辑器里照着改回来就能正常打开了
pdf或其它有很明显固定文件头的文件也可以这么做
5 图片的高度 用16进制编辑器更改png图片的高度，会只显示图片的上面一部分，下面的部分就被隐藏了，是个藏东西的好办法
找表示宽度和高度的位置的话，010Editor比较方便，也可以先看看图片的属性，得到宽高值，转成16进制，搜索16进制值就找到了
注：
png图片的保存恢复效果比较好，jpg貌似有点问题试过改宽度，效果不好，高度很好掌握 6 图片隐写工具 图片隐写工具很多，慢慢补充，先写几个，以后再补
oursecret 这工具很强大，什么文件都能用来隐藏，完全没有限制
本来下载地址应该是: http://www.securekit.net/oursecret.htm, 但已经404了，随便搜一个在虚拟机里临时用一下吧
Outguess 支持3种用来隐藏信息的文件格式: PPM(Portable Pixel Map)、PNM(Portable Any Map)、jpg，需要密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31b5af22b64c3c9688c3ffa26abfcb67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981a90b089ed0d62b1d1732e56080674/" rel="bookmark">
			23种设计模式之Builder模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Builder定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 Builder使用场景：
相同的方法，不同的执行顺序，产生不同的事件结果时多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适当初始化一个对象特别复杂，如参数多，且很多参数都具备默认值时 Builder的简单应用 大家考虑一下这种场景，假如有一个类(Computer)，里面有很多属性，就像下面的代码： //计算机的抽象类，即Product角色 public class Computer { private String mModel; //型号 （必传参数） private int mMemory; //内存 （必传参数） private int mGraphics; //显卡 （不必传参数） private String mBoard; //主机 （不必传参数） private String mDisplay; //显示器 （不必传参数） private String mProcessor; //处理器 （不必传参数） } 在这个类中，有些参数是必要的，而有些参数是非必要的。就好比在买电脑的时候，只需要知道型号，内存等些重要的信息，其他的信息可以关注也可以不关注的时候，那么问题就来了，如何创建这个类的对象呢？
一种可行的方案就是实用构造方法。第一个构造方法只包含两个必需的参数，第二个构造方法中，增加一个可选参数，第三个构造方法中再增加一个可选参数，依次类推，直到构造方法中包含了所有的参数，也就是构造方法的重构：
public Computer(String mModel, int mMemory) { this.mModel = mModel; this.mMemory = mMemory; } public Computer(String mModel, int mMemory, int mGraphics) { this.mModel = mModel; this.mMemory = mMemory; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/981a90b089ed0d62b1d1732e56080674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d37fb656f533cd8e3f8a414abc7f28/" rel="bookmark">
			公有云还是私有云？269给你算笔账！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业基于公有云进行信息化转型，业务规模决定所需存储，那么应用在公有云存储上的成本将更有效率，同时无需专业人员运维，从企业人力资源投入上来看，成本也较少。但一个企业在追求低成本投入和高效率办公的同时，持续长足的发展力也尤为重要，如果基于企业长远发展考虑，不妨在重新算一笔账。
基于公有云，企业信息化投入主要来自于托管成本+软件成本+运维服务成本等，其中服务器的托管成本大概为3000-6000元/台/年，企业办公所需的办公软件，主要包括CRM、ERP、OA、HR、进销存、企业邮箱等，而现今市面上的绝大部分办公软件都是按照企业员工人数收费，且费用不菲，随着企业规模和人数的不断扩大，这势必是一项巨大的成本投入。除此之外，为了防止各种因素导致服务提供商处的存储数据丢失后，仍需要投入购买本地存储介质备份数据，同时还有支持公有云存储数据交互时的宽带成本。
而如果使用私有云，虽然一开始需要支付相对高额的软硬件购买和部署成本，但从企业长远的发展来看，私有云的可控性、专属性和拓展性才是真正的大幅降低成本。中国首台私有云服务器——269私有云服务器，就是致力帮助中小企业解决信息化转型升级投入贵、部署难和耗时长等难题。
在硬件方面，269私有云服务器体积迷你轻巧，性能卓越便捷，办公安全智能，傻瓜式操作，无需专门人员运维，节省了大笔的网管费用；而在软件方面，269私有云服务器集成七大办公系统和近百办公应用，一站式为企业提供办公管理平台，把办公成本最小化。
269私有云服务器，应“云”而生，助力中小企业“云”享效益。
转载于:https://my.oschina.net/duqiu/blog/895002
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61576388099fa2942d052c842239052/" rel="bookmark">
			vs2017离线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、
vs_Enterprise.exe ^
--layout D:\vs2017offline ^
--lang zh-CN ^
--add Microsoft.VisualStudio.Workload.NativeDesktop ^
--add Microsoft.VisualStudio.Workload.NativeCrossPlat ^
--add Microsoft.VisualStudio.Workload.VisualStudioExtension
2、https://docs.microsoft.com/zh-cn/visualstudio/install/workload-component-id-vs-enterprise
3、导入证书
4、KEY NJVYC-BMHX2-G77MM-4XJMR-6Q8QF
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d798ebb5ad019147f3261624f63d982/" rel="bookmark">
			vue-cli开发环境跨域问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前后端分离开发中必要会遇到的问题—跨域。在使用vue开发的时候，开始为了解决跨域问题。采用的是CORS（Cross-origin resource sharing）。后台在响应头中添加Access-Control-Allow-Origin。这样就可以跨域调后台接口了。 在前几天无意中看到了config的index.js文件中有一个proxyTable属性，通过配置可以解决开发环境的跨域 开发期间的API代理
当将此样板与现有后端集成时，通常需要在使用dev服务器时访问后端API。为了实现这一点，我们可以并行（或远程）运行dev服务器和API后端，并让dev服务器将所有API请求代理到实际的后端。
要配置代理规则，请在其中编辑dev.proxyTable选项config/index.js。dev服务器正在使用http代理中间件进行代理，因此您应参考其文档以获取详细的用法。但这是一个简单的例子：
// config/index.js module.exports = { // ... dev: { proxyTable: { // proxy all requests starting with /api to jsonplaceholder '/api': { target: 'http://jsonplaceholder.typicode.com', changeOrigin: true, pathRewrite: { //需要rewrite重写的, 如果在服务器端做了处理则可以不要这段 '^/api': '' } } } } } 上面的示例将代理请求/api/posts/1到http://jsonplaceholder.typicode.com/posts/1。
如果 pathRewrite: { ‘^/api’: ‘api’ }, 则将代理请求/api/posts/1到http://jsonplaceholder.typicode.com/api/posts/1。
网址匹配
除了静态网址之外，您还可以使用glob模式来匹配URL，例如/api/**。有关详细信息，请参阅上下文匹配。此外，您可以提供一个filter可以是自定义函数的选项，以确定请求是否应被代理：
proxyTable: { '*': { target: 'http://jsonplaceholder.typicode.com', filter: function (pathname, req) { return pathname.match('^/api') &amp;&amp; req.method === 'GET' } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce46c543accf66a3fa68ef4f4d60394/" rel="bookmark">
			编译原理_算符优先分析方法_语法分析器_java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本帖完全原创
若要查看 编译原理_简单优先分析方法_语法分析器_java ，请移步http://blog.csdn.net/qq_24065713/article/details/70664835
根据《编译原理》何炎祥第三版第六章语法分析器实现
原理：算符优先分析算法
语言：Java
效果图：（丢失，类似于效果图：http://blog.csdn.net/qq_24065713/article/details/70664835）
package 算符优先算法; public class Test { public static void main(String[] args) { new Version(); } } package 算符优先算法; public class MainMethond { public String jieguo =""; public String inputStream =""; public String relation =""; public String outputStremm =""; public String left =""; public String s=""; public int i=1; public boolean accept(StringBuffer s1,StringBuffer s2) { boolean result; outer: while (true) { char c1=findEndVn(s1);//S栈中最后一位终结符 char c2=findLBOVn(s1);//S栈中倒数第二位终结符 char c3=s2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ce46c543accf66a3fa68ef4f4d60394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec1859d29a8f31bd6cfe662205ebf9f8/" rel="bookmark">
			C语言里面获取字符串长度sizeof和strlen的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、我们先来看一下这两者的概念。strlen是一个函数，求的是字符串的实际长度，它求得方法是从开始到遇到第一个'\0',如果你只定义没有给它赋初值，这个结果是不定的，它会从arr首地址一直找下去，直到遇到'\0'停止。 而sizeof()返回的是变量声明后所占的内存数，不是实际长度，此外sizeof不是函数，仅仅是一个操作符，strlen是函数。
2、分别用strlen和sizeof计算数组arr【10】的长度，看运行的结果。
int main() { char arr[10]; printf(" strlen(arr)=%d sizeof(arr)=%d\n",strlen(arr),sizeof(arr)); return 0; }运行结果如下： 你会发现，用strlen获取的结果是不定的 ，而sizeof()返回的是变量声明后所占的内存数，不是实际长度。
2、这一次我们对数组arr[10]进行部分的初始化，再来看结果。
int main() { char arr[10]={'1','2','3'}; printf(" strlen(arr)=%d sizeof(arr)=%d\n",strlen(arr),sizeof(arr)); return 0; } 这一次strlen获取到是字符串的实际长度3。
3、我们来看一下指针，注意的是后面对字符串的某个值进行初始化后，strlen的结果是有变化的。。
int main() { char *t; t=(char *)malloc(sizeof(char)*10); printf("no1 strlen(t)=%d sizeof(t)=%d \n\n\n",strlen(t),sizeof(t)); *(t+3)='\0'; printf("no2 strlen(t)=%d sizeof(t)=%d \n",strlen(t),sizeof(t));return 0; }运行结果如下： 你会发现用sizeof是获取不到指针字符串的长度，返回的是4，t是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是 长整型的，所以是4 。注意的是后面对字符串的某个值进行初始化后，strlen的结果是有变化的。
4、 最后来看一下char arr[10]="12345678";char *t="12345678";这样的定义结果会如何呢。
int main() { char arr[10]="12345678"; char *t="12345678"; printf("no2 strlen(t)=%d sizeof(t)=%d \n",strlen(t),sizeof(t)); printf(" strlen(arr)=%d sizeof(arr)=%d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec1859d29a8f31bd6cfe662205ebf9f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811834ab69b0aec9c7aedfad80aac427/" rel="bookmark">
			xapp585使用注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.时钟规则
MMCM可以驱动BUFIO, BUFR, BUFH, and BUFG时钟网络；PLL只能驱动BUFH and BUFG时钟网络
7系列FPGA速度等级个时钟网络支持最大频率如下表格
XAPP585一般用于低成本方案，常见选型为-1 -2 速度等级芯片，单lane测试通过支持最高速率为 1,200 Mb/s
速度等级-1芯片各种时钟资源组合如下table-2， table-3：
SDR模式需要两种时钟资源，DDR模式需要三种时钟资源
SDR（Single or Multiple Interfaces in one Bank）只有一个bank使用串化解串接口支持四种时钟资源模式1.BUFG + BUFG 2.BUFIO + BUFR 3.BUFH + BUFH 4.BUFR + BUFR
SDR（Single or Multiple Interfaces in More Than one Bank）多个bank使用串化解串接口支持一种时钟资源模式1.BUFG + BUFG DDR（Single or Multiple Interfaces in one Bank）只有一个bank使用串化解串接口支持伍种时钟资源模式
1.BUFG + BUFG + BUFG 2.BUFIO + BUFR + BUFG 3.BUFH + BUFH + BUFG 4.BUFIO + BUFR + BUFR 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811834ab69b0aec9c7aedfad80aac427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc818c34d1a472ec3430d7cc83d85905/" rel="bookmark">
			webpack超详细配置, 使用教程(图文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主在这里就不详细介绍webpack来源以及作用了, 本篇博文面向新手主要说明如何配置webpack, 以及webpack的使用方法, 直到创建出一个合理的属于自己webpack项目;
注: 此篇博客适用于webpack2.x, 对于4.x版本变化还挺大的, 过一阵子会再写一篇, 点关注不走丢哦
流程 webpack安装 Step 1: 首先安装Node.js, 可以去Node.js官网下载.
Step 2: 在Git或者cmd中输入下面这段代码, 通过全局先将webpack指令安装进电脑中
npm install webpack -g Step 3: 使用Git Bash here 或者 cmd cd命令使当前目录转到当前项目的目录下, 然后输入下面这段命令
npm init
接下来会弹出一些信息, 就是一些项目名和一些参数的描述, 可以全部按回车使用默认信息, 完成之后项目文件夹下会生成一个package.json的文件
这样webpack就安装完成了. webpack配置 Step1: 创建项目文件夹, 名字自起, 但路径名不要包含中文, 以及项目名也不要叫"webpack", 并且不要包含大写字母.
例:
Step2: 接下来创建并编写配置文件. 首先我们先介绍几个配置文件的参数.
entry： 是 页面入口文件配置 （html文件引入唯一的js 文件）output：对应输出项配置 path ：入口文件最终要输出到哪里，filename：输出文件的名称publicPath：公共资源路径
Step3: 在你的项目目录下创建webpack.config.js配置文件, 通过这个文件进行webpack的配置, 并且还要创建一些路径保存基本文件. 例如: src文件夹
Step4: 在src的js下创建一个入口文件, 我创建的叫做entry.js, 在项目目录再创建一个index.html用来调试使用. 编写webpack.config.js文件,
//webpack.config.js module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc818c34d1a472ec3430d7cc83d85905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f31b4010e539cb5f3570bf3bb7c6bb/" rel="bookmark">
			Python 3基础教程22-单个列表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文来介绍列表的操作，先看看单个列表的操作，列表有多个方法。以下多行代码，建议你写一个方法，测试运行一个方法，不然看起来很乱。
# 元组操作 x = [5,6,2,1,6,7,2,7,9] # append()方法，就是在列表尾部添加元素 x.append(2) print(x) # insert(开始位置，插入的值),插入一个元素到指定位置 x.insert(2,99) # 2是索引,表示这个元素要放什么位置，99是插入的元 print(x) # 删除元素 remove() x.remove(2) # 这个2是指一个元素不是索引，如果多个，默认移除第一个 print(x) x.remove(x[2]) # 根据索引，直接移除索引对应的元素 print(x) # pop(),移除列表尾部最后一个元素 x.pop() print(x) # 列表引用 print(x[0:5]) # 相当于一个范围，从左边索引到右边索引，但是不包括右边索引 # -1 索引代表最后一个元素，-2代表倒数第二个 # 此时x= [5, 6, 1, 6, 7, 2, 7, 9] print(x[-1]) print(x[-2]) # 查找某一个元素的索引值，一下1的索引应该是2 print(x.index(1)) # 计算某一个元素出现的次数 print(x.count(6)) #元素6出现了2次 # 排序,默认从小到大 x.sort() print(x) # 字母排序 y = ['Janet','Jessy','Anthony','Tom','Alice','Bob'] y.sort() print(y) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/188878489071e666da184ebfca7336ff/" rel="bookmark">
			什么叫方法重载？构造方法可以重载吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同一个类中的2个或2个以上的方法可以一同一个名字，只是它们的参数声明不同即可，在这种情况下，该方法就被称为重载，这个过程称为方法重载。
构造方法可以重载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3e3909c013be49085ab0f3c8f514978/" rel="bookmark">
			什么叫伪代码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近找工作，面试时面试官提问时让我用伪代码回答他所提的问题，当时笔者就蒙了，满脑子就是问号，相信有部分童鞋和笔者差不多，当然大多数童鞋都是好孩子，应该都知道，于是笔者赶紧回来查了一下官方解释如下：
伪代码（Pseudocode）是一种算法描述语言。是用介于自然语言和计算机语言之间的文字和符号（包括数学符号）来描述算法。使用伪代码的目的是使被描述的算法可以容易地以任何一种编程语言（Pascal，C，Java等）实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言。 介于自然语言与编程语言之间。以编程语言的书写形式指明算法职能。使用伪代码， 不用拘泥于具体实现。
【简单示例】输入3个数，打印输出其中最大的数。可用如下的伪代码表示： Begin 输入 A，B，C IF A&gt;B 则 A→Max 否则 B→Max IF C&gt;Max 则 C→Max Print Max End 。 笔者理解为简单的计算机语言，人类语言以及逻辑符号来表示的流程说明。当然朋友们有更好的理解也可以指出来！ 转载于:https://www.cnblogs.com/lidelin/p/6815236.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36738c6ce70bcf3214fca92b4f033a58/" rel="bookmark">
			spring boot 整合redis对查询数据做缓存（ 利用spring的AOP技术）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇主要介绍spring boot 整合redis做数据缓存，利用的是spring aop切面编程技术，利用注解标识切面。
这里不再介绍spring boot操作数据库，有兴趣的话，我最后会给出源码链接
一，引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; &lt;version&gt;1.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 二，配置redis连接
配置文件我里这用的是yml格式的，tab缩进，如果是properties格式的，请自己改造 redis 安装请参考 Redis安装 windows管理工具可以用RedisDesktopManager，测试的时候，可以直接删除缓存。
spring: redis: database: 0 ## Redis服务器地址 host: 192.168.50.128 ## Redis服务器连接端口 port: 6379 ## Redis服务器连接密码（默认为空） password: ## 连接超时时间（毫秒） timeout: 0 ## 连接池最大连接数（使用负值表示没有限制） pool: max-active: 8 ## 连接池最大阻塞等待时间（使用负值表示没有限制） max-wait: -1 ## 连接池中的最大空闲连接 max-idle: 8 ## 连接池中的最小空闲连接 min-idle: 0 三，注解
注解 QueryCache 用来标识查询数据库的方法，参数nameSpace用来区分应用的，后面会用来添加到缓存的key中。比如，登陆应用缓存的数据key值全部都是sso开头。
package com.example.common.annotation; import com.example.common.CacheNameSpace; import java.lang.annotation.*; /** * Created by mazhenhua on 2017/5/3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36738c6ce70bcf3214fca92b4f033a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca1b7b44de6af799d35542b6d90b9e3/" rel="bookmark">
			SDUT 1269 走迷宫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SDUT 1269 走迷宫 Time Limit: 1000MS Memory Limit: 65536KB
Problem Description
有一个m*n格的迷宫（表示有m行、n列），其中有可走的也有不可走的，如果用1表示可以走，0表示不可以走，输入这m*n个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用-1表示无路）。
Input
第一行是两个数m，n（1&lt; m, n&lt; 15)，接下来是m行n列由1和0组成的数据，最后两行是起始点和结束点。
Output
所有可行的路径，输出时按照左上右下的顺序。描述一个点时用（x，y）的形式，除开始点外，其他的都要用“-&gt;”表示。如果没有一条可行的路则输出-1。
Example Input
5 4 1 1 0 0 1 1 1 1 0 1 1 0 1 1 0 1 1 1 1 1 1 1 5 4
Example Output
(1,1)-&gt;(1,2)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(3,2)-&gt;(4,2)-&gt;(4,1)-&gt;(5,1)-&gt;(5,2)-&gt;(5,3)-&gt;(5,4) (1,1)-&gt;(1,2)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(3,2)-&gt;(4,2)-&gt;(5,2)-&gt;(5,3)-&gt;(5,4) (1,1)-&gt;(1,2)-&gt;(2,2)-&gt;(3,2)-&gt;(4,2)-&gt;(4,1)-&gt;(5,1)-&gt;(5,2)-&gt;(5,3)-&gt;(5,4) (1,1)-&gt;(1,2)-&gt;(2,2)-&gt;(3,2)-&gt;(4,2)-&gt;(5,2)-&gt;(5,3)-&gt;(5,4) (1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(3,2)-&gt;(4,2)-&gt;(4,1)-&gt;(5,1)-&gt;(5,2)-&gt;(5,3)-&gt;(5,4) (1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)-&gt;(3,3)-&gt;(3,2)-&gt;(4,2)-&gt;(5,2)-&gt;(5,3)-&gt;(5,4) (1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(3,2)-&gt;(4,2)-&gt;(4,1)-&gt;(5,1)-&gt;(5,2)-&gt;(5,3)-&gt;(5,4) (1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(3,2)-&gt;(4,2)-&gt;(5,2)-&gt;(5,3)-&gt;(5,4)
Submit
#include &lt;bits/stdc++.h&gt; using namespace std; int N, M; int mp[20][20]; int a1, a2, b1, b2, tr; int s[300][2]; void print(int t) { int i; for(i = 0; i &lt; t; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bca1b7b44de6af799d35542b6d90b9e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ec3af794d6958143c6b3e1c0aa975b/" rel="bookmark">
			利用PCL处理Realsense点云数据-在vs2015里用PCL获取Realsense点云数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浪费了一个月时间，查了很多资料，然后各种用ubuntu编译，最后结果还是不行，尝试到最后，终于发现一个东西，就是realsense_grabber，但是不是PCL里面自带那个，是独立的。利用这个，我终于可以获取点云数据了。
接下来我说一下需要的东西以及步骤：
首先我们需要的软件有：PCL1.8.0-all-in-one，具体版本自己选择，我的是vs2015-win64版本。然后是RSSDK，就是realsense官方的SDK。这个是必须的，所以即便PCL有了grabber在ubuntu下还是不可以获取点云数据，最后就是单独的grabber也就是rs-master，这几个东西我会一起上传上来，大家直接下载就好了。https://download.csdn.net/download/wi162yyxq/11262771
关于PCL和RSSDK的安装方法，我前面的博客里有写，就不多说了。
最重要的就是这个rs-master，它的安装很简单，首先需要下载一个cmake，去官网下最新版就好。
然后和常规的cmake一样，在源文件夹下新建build文件夹/
然后configure接着generate，最后到build里面找rs.sln,在release和debug下分别生成项目就好了。
注意一点，在最后添加属性之前，首先把源文件夹下的src中的文件拷贝到include中。
然后我们打开vs的项目，加入rs-master源文件夹下的include，然后添加build文件夹下debug文件夹里的lib。
为了防止编译失败，我们把PCL里的bin文件夹下的dll文件全考到项目文件夹中，最后我们编译re-master/src下的real_sense_viewer.cpp就可以看到效果了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b65da26cd0f61dfd43626603b1485ae/" rel="bookmark">
			java_高级_网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网络编程 套接字编程 Socket编程 协议的概念 TCP/IP协议 --&gt; HTTP HTTPS --&gt; JavaWeb编程 通过IP地址定位计算机在网路的位置 工作模式： 请求-响应 模式 计算机A（简称A）向计算机B（简称B）发起某个请求，计算机B向A产生回应 A不能连续发起请求，B不能连续产生响应 A -&gt; B B -&gt; A A -&gt; B B -&gt; A 请求和响应必须是成对出现的 要求：A去访问B，A必须明确的知道B的主机名或IP地址 http://www.baidu.com DNS服务器（将域名转换成IP地址） UDP协议 工作模式： 广播模式 计算机A向计算机B发送了一段内容，B无需给A任何回应 A可以连续向B发送内容 存在隐患：A发送内容之后无法得知内容是否发送成功 比较TCP和UDP两者：两者不存在孰优孰劣，两者有不同的适应场合 比如网站服务器，比如游戏的服务器适合TCP协议 比如通信软件的上线通知功能，适合UDP协议 Socket类的使用 -- 实现TCP协议的计算机之间的通信 ip： IP地址 port： 端口号 1-65535 为了避免端口冲突，建议自定义程序使用的20000以后的端口 20000之前的端口大部分被操作系统和知名软件使用了 Oracle数据库：1521 MySQL数据库：3306 Tomcat服务器：8080 系统默认端口：80 A -&gt; B 10.25.48.111:1521 10.25.48.111 -&gt; 10.25.48.111:80 Oracle程序： C/S结构的程序 Client(客户端)/Server(服务器) 默认端口：1521 IP地址和端口号来区分不同的使用网络的应用程序 门户网站: B/S结构的程序 Browser(浏览器)/Server(服务器) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b14984bfe8978b65ea91b494826170/" rel="bookmark">
			java_高级_多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 进程：一个系统中可以“同时”运行多个程序，一个程序就是一个进程 线程：一个程序中可以“同时”运行多个功能，一个功能就是一个线程 一个线程中可以“同时”运行多个其他线程 单核CPU 同一时间只能执行一个程序（一个进程中某个一个线程） 轮转时间片 多线程的创建方式（重要） 2种方式 类的对象就是一个多线程的对象 (1)某个类继承Thread类 (2)某个类实现Runnable接口，并实现其中的run方法 线程的生命周期 多线程的启动不能调用run方法，如果通过调用run方法来执行多线程，这个就是普通方法 启动多线程需要调用Thread类中start方法，start方法会以多线程的方式启动run方法 参照图片理解 多线程的控制 线程的休眠 -- 属于一种阻塞事件，让某个线程休眠一段时间 Thread.sleep(1000);让代码所属方法休眠1000ms 利用Runnable创建线程对象时的问题 如何启动线程？ Runnable r1 = new Runnable(); Thread t1 = new Thread(r1); t1.start(); -- 相当于启动了r1 使用Thread类还是Runnable接口创建多线程类，哪一种方式更好？ Thread类的优势：提供了操作线程的方法，可以直接使用（比如start和stop） Runnable接口的优势： 由于Java是单继承，Runnable不占据父类的位置，可以提供更好扩展性 个人认为Runnable更好，对系统来说提供了更好的扩展性 同步与异步 线程不安全的产生原因 多个线程操作同一个资源时，操作过程中让出CPU执行权，此时数据处于修改不完善的状态， 下一个线程在进行操作时读取了没有修改完善的数据，造成了数据的错误 解决线程安全的主要方法是通过 同步关键字（也被称为锁） -- synchronized synchronized可以修饰 方法和代码块，这样的方法或代码块中的代码，只允许一个线程完整访问后才可以交给下一个线程 同步方法：不明确锁定资源，锁定了整个方法的代码 同步块：可以明确指定锁定的资源，只同步需要同步的部分代码而不是整个方法 推荐使用同步块解决线程不安全的问题 使用了synchronized的代码被称为同步方式 -- 同一时间内某方法只能被一个对象使用 没有使用synchronized的多线程代码被称为异步方式 -- 同一时间内某方法可能被多个对象同时使用 在懒汉式单例中getInstance方法应该是一个线程安全的方法，否则多线程的环境中有可能单例对象被不同线程初始化多次 在Java中对比两种单例模式，个人推荐使用饿汉式单例 死锁 共享资源 A B A+B资源都获得以后才能完成目标 线程1 获得了A资源， 需求B 线程2 获得了B资源， 需求A 程序出现相持局面 -- 死锁 解决死锁：将资源A和B作为一个整体C，将C加锁相当于直接锁定了A和B，不会出现死锁问题了 尽可能的避免出现synchronized代码块嵌套，就有出现死锁的风险 wait和notify wait与sleep的区别？（重要） wait是让访问某个共享资源处于等待状态，wait方法必须在同步块或同步方法中使用 wait方法是继承自Object类 某个线程中，调用了共享资源的wait方法时，该线程会让出CPU的执行权和共享资源的锁 sleep是Thread类中的方法，让调用了该方法的线程处于休眠状态（占着CPU睡觉），不会释放其占有的锁 wait与notify wait和notify都必须在同步块或同步方法中使用，如果不是程序会报异常 wait让调用某个共享资源的线程处于等待状态 notify对调用某个共享资源的线程进行唤醒，等待-&gt;就绪 nofifyAll 对所有等待共享资源的线程同时进行唤醒 多个线程进入就绪 -&gt; 竞争 生产者与消费者模式（了解） 有n个生产线程负责生产某类产品，存入到一个空间中 有n个消费线程负责消费某类产品，从上述空间中取得 空间 -- 共享资源 生产者 -- 负责向共享资源存放内容的线程 消费者 -- 负责从共享资源取出内容的线程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410ff9b413c3a846abb080095119c742/" rel="bookmark">
			饭卡 01背包 &#43; 贪心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		饭卡 电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。 某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。
多组数据。对于每组数据： 第一行为正整数n，表示菜的数量。n&lt;=1000。 第二行包括n个正整数，表示每种菜的价格。价格不超过50。 第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。 n=0表示数据结束。
1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0 分析：因为钱大于5块就可以任意买东西 所以可以先对物品排序 然后把最大的第n件物品先取了 然后想象成一个容量为m-5的背包 使其在n-1件物品中取得最大值 本题01背包的费用和价值都是 “菜的价格” 就是用多少费用就能获得多少价值。#include&lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int N,C,m; int w[1010]; int dp[1010][1010]; int main() { int n; while(~scanf("%d", &amp;n) &amp;&amp; n != 0) { for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]); scanf("%d", &amp;m); if(m &lt; 5) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410ff9b413c3a846abb080095119c742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f5c7b75291c5e939562cd57c6d04c3/" rel="bookmark">
			java_高级_文件与流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件类 java.io包下都是与文件和流相关的类 i - input输入 o - output输出 java.io.File类 文件类 可以操作计算机的文件（文件自身的属性，而不包含文件的内容） 构造方法 File f = new File("完整路径"); File f = new File("c:/haha/1.txt"); File f = new File(File f, String s); 在目录（文件夹）f中，创建文件s File f = new File(String f, String s); 在目录（文件夹）f中，创建文件s API方法 f.createNewFile(); 创建一个新文件 如果f指定的某级路径不存在，文件无法创建会抛出IOException 不会覆盖原有文件 f.delete(); 删除文件 f.exist(); 判断文件f是否存在 存在true 不存在false f.mkdir(); 创建一个文件夹 （如果存在多级文件夹则无法创建） f.mkdirs(); 创建文件夹 (如果存在多级文件夹，都会进行创建) -- 推荐使用 canExecute(); 测试文件是否为可执行文件 canRead(); 是否可读 canWrite(); 是否可写 判读只读 返回false -- 只读 返回true -- 可写 f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38f5c7b75291c5e939562cd57c6d04c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/510a996804d4fa0760197eca5e31e999/" rel="bookmark">
			sqlserver如何把查询的某个字段的列表转换为字符串输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码如下：
declare @test varchar(max) set @test='' IF EXISTS(SELECT iid FROM sort WHERE Parent=0) begin select @test=@test+','+CAST(iid AS VARCHAR) from sort WHERE Parent=0 ORDER BY iid IF(LEN(@test)&gt;0) begin SET @test=RIGHT(@test,LEN(@test)-1) END END select @test 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad3b9b852be3ad24c1ead37aac792ff/" rel="bookmark">
			python脚本处理代码注释规范化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python脚本 实现注释的规范化处理：
示例：
1.
源代码：
int speed = 4;//设置速度为4
处理后：
//设置速度为4
int speed = 4;
2.
源代码：
else{//否则
处理后：
//否则
else{
3.
源代码：
}else{//否则
处理后：
//否则
}else{
4.
源代码：
if(condition == true){//如果为真
处理后：
//如果为真
if(condition == true){
5.
源代码：
json处理：（js)
var testJson = {
name:”lmn”,//名字
age:”25”//年龄
}
处理后：
不进行处理。
说多无益，直接上代码：
#encoding:utf-8 ''' 可能性如下： 1.单独一行注释： 2.有代码有注释 3 }else{// 4.多行注释 /** * //获取所有配件重量总和 * @param index 将要装备的第几个配件槽 * @param unitId 将要装备配件ID */ 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad3b9b852be3ad24c1ead37aac792ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d024abbe5497c9571a8c79f810215bd/" rel="bookmark">
			poj1631(最长上升子序列 nlogn)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目见http://poj.org/problem?id=1631
最长上升子序列（LIS）裸题（这么说相信题目看看也懂了吧）
多数据，由于每个数据p&lt;40000，最多可以有上万个数，这个时候用O(n^2)算法显然就不可行了
然后就要利用O(nlogn)算法去做
点击打开链接 这个博客讲的还是不错的，比较好懂
然后不多说，照样子写个模板实现实现，代码如下
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.StringTokenizer; class Reader { static BufferedReader reader; static StringTokenizer tokenizer; static void init(InputStream input) { reader = new BufferedReader(new InputStreamReader(input)); tokenizer = new StringTokenizer(""); } static String next() throws IOException { while (!tokenizer.hasMoreTokens()) { tokenizer = new StringTokenizer(reader.readLine()); } return tokenizer.nextToken(); } static int nextInt() throws IOException { return Integer.parseInt(next()); } } public class Main { /** * @param args */ static int t, n, len, l, r, k, mid; static int arr[], g[]; private static int find(int num) { l = 0; r = len; while (r - l &gt; 1) { mid = (l + r) / 2; if (g[mid] &gt;= num) r = mid; else l = mid; } return l; } public static void main(String[] args) throws IOException { // TODO Auto-generated method stub Reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d024abbe5497c9571a8c79f810215bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cd1f9a4880de7065b1589d84139f2a/" rel="bookmark">
			关于IDE选择的一些思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没有写博客了，倒不是因为博主变懒了，而是我对这个网站开始比较失望了。所以，基本上在这里的博客更新就逐渐变得缓慢了。我想，以后也会更加如此，说不定什么时候就把这里的所有博客都搬了家也未可知。
今天写这一篇博客的主要目的是近些年自己编程使用的各类IDE的一些思考。
先说到底需不需要IDE。答案是肯定的，绝大多数的程序员是非常需要的，如果你说大神级别的话。我觉得没有可比性，就相当于理论上来讲，你拿着最基本的工具也可以造出一辆车，但是公司肯定不乐意这么干。
如何选择IDE？我认为，首选就是要选择一个成熟的IDE，我们不要去盲目追循新出来的IDE，或许它确实看起来很酷炫，但是它不够稳定。出现了问题，你无法知道是你的程序造成的，还是你的IDE造成的。这样的成本也不是工程师应该承担的。而且，这种代价也太大了。
其次，尽量选择使用人数多的IDE，你工作肯定要与其他人发生协同合作，而由于你的另类选择，无疑会造成你的协作效率下降。即使你这个时候开始学新的工具的使用，你的学习成本也在增加，而这些都不是一个好的选择。所以，需要选择通用性大一点的工具。
再次，不要使用破解版，或者说不要去经常破解这些专业版的IDE来使用。因为这些商业公司会定期更新他们的加密机制，而你则需要定期去重新破解，而这种频繁的修改配置，代价是否也太大了一点。而且，在工作中，你的着一种手法是不被允许的。也就是你辛辛苦苦的破解了一个很牛逼的IDE商业版，而实际上工作中用到的并不多。无形之中，浪费了大量的时间。如果一定想要尝鲜，不如直接使用免费版。
综上所述，IDE是为了提高我们的编程效率而被创造出来的，我们不应该沉迷于工具的酷炫而浪费了大量的尽力，用的顺手，开源，免费而通用的工具就是好的。其他的，即使再怎么酷炫，我们也应该清楚背后的代价。这也就是我为什么终于全部卸载了jbrain的一系列的IDE而重新选择eclipse。因为，我无法保证一直都有精力去各种破解，寻找各种序列号。同时，工作中这是不允许这么干的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d3a667b410605b8dfa4ff6f2b65fdda/" rel="bookmark">
			MySQL各种时间取数函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、取一个月之前的时间：
1）mysql&gt; select date_sub(curdate(), interval 1 month); #当前日期一个月之前的日期
+---------------------------------------+
| date_sub(curdate(), interval 1 month) |
+---------------------------------------+
| 2017-03-28 |
+---------------------------------------+
2）mysql&gt; select date_sub(now(), interval 1 month); #当前日期一个月之前的时间
+-----------------------------------+
| date_sub(now(), interval 1 month) |
+-----------------------------------+
| 2017-03-28 16:00:04 |
+-----------------------------------+
2、指定获取时间格式：
1）mysql&gt; select date_format(date_sub(now(), interval 1 month), '%y-%m-%d'); #当前日期一个月之前是多少年月日
+------------------------------------------------------------+
| date_format(date_sub(now(), interval 1 month), '%y-%m-%d') |
+------------------------------------------------------------+
| 17-03-28 |
+------------------------------------------------------------+
2）mysql&gt; select date_format(date_sub(now(), interval 1 month), '%Y-%M-%D'); #当前日期一个月之前是多少年月日
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d3a667b410605b8dfa4ff6f2b65fdda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b5eb4d5ab1936784941b1578ebc1d7/" rel="bookmark">
			c&#43;&#43; 使用WinHTTP实现文件下载功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为要项目中要想要实现一个软件自动更新的功能，之前是使用socket直接下载。但切换下载源的时候很麻烦。所以换用http方式。 网上找了很多资料，基本上就是下面几种： 1.curllib //功能强大太但太麻烦而且没必要 2.MFC自带的功能 // 项目不是使用的MFC所以舍 3.IE控件下载 // 没办法获取到进度，而且因为不能获取到总大小所以很容易下载的资源不完整。
思来想去，最后还是使用WinHTTP，比较简单快捷，而且功能上基本上都能够满足。
#include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;Winhttp.h&gt; #pragma comment(lib,"Winhttp.lib") typedef void(*DownLoadCallback)(int ContentSize, int CUR_LEN); typedef struct _URL_INFO { WCHAR szScheme[512]; WCHAR szHostName[512]; WCHAR szUserName[512]; WCHAR szPassword[512]; WCHAR szUrlPath[512]; WCHAR szExtraInfo[512]; }URL_INFO, *PURL_INFO; void dcallback(int ContentSize, int file_size) { printf("count:%d,size:%d\n", ContentSize, file_size); } void download(const wchar_t *Url, const wchar_t *FileName, DownLoadCallback Func) { URL_INFO url_info = { 0 }; URL_COMPONENTSW lpUrlComponents = { 0 }; lpUrlComponents.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53b5eb4d5ab1936784941b1578ebc1d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fddf2724d4acf3755a93540bc8d4f51/" rel="bookmark">
			漫画网站爬虫详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面对 http://www.svmhz.com/shaonvmanhua/进行爬取，对大神的博客（ http://www.jianshu.com/p/8b4a589f7980）进行详解： 根据网页图片查看响应代码，选中√的地方 查看源代码的方法，浏览器页面按下F12，然后鼠标移动到某个图片时，下面的代码就会变暗 如下，选中网页上的图片时，下面的响应代码就会变暗 鼠标挪动到图片上就出现了 下面对爬虫的代码进行逐行解释 ------------------------------ 下面解释get_index_page(offset)函数----------------------------- url = 'http://www.svmhz.com/shaonvmanhua/list_4_%s.html' % offset 解释： 以上两张图的3是对应的 该图中的3是对漫画列表提供索引 offset相当于形参，把数据传给s，所以两者前面都有%s 该代码大意比较清楚，如果等待时间比较长，则响应异常，输出相关异常信息 ------------------------------get_index_page(offset)函数------------------------- ######## 下面解释parser_index_page(html)函数----------- 入口参数html代表的是网页源代码 listcon_tag = soup.find('ul', class_='listcon')#属性为listcon的列表 列表中的元素&lt;li&gt;........&lt;/li&gt;是每本漫画书的入口 随便打开列表中的一个元素，会发现以下内容 url_list = listcon_tag.find_all('a', attrs={'href': True}) 这句话是对网页源代码中 包含的所有漫画书连接 进行提取，得到满足需要的部分网页源代码 urls = ['http://www.svmhz.com' + url['href'] for url in url_list]#遍历子网页的子网页，遍历干净为止。 上述代码也就是说，从url_list集合（当前网页的部分源代码）中提取出对链接修饰的部分，拼接到当前网址： http://www.svmhz.com 拼接后的结果传给urls集合 该函数的目的是为了获取每本漫画的入口地址，也就是漫画的第一页的地址 函数解释结束 ########parser_index_page(html)函数解释结束######### ##############get_image_page(url, total)函数讲解############ 入口参数url举例： http://www.svmhz.com/shaonvmanhua/9894.html total举例(纯数字) ：89 list_url = [ ] 解释： 创建一个列表 list_url.append(url) 在列表中加入每一本漫画入口地址 url = url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fddf2724d4acf3755a93540bc8d4f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8041aae807052358cee759468a1df8a0/" rel="bookmark">
			android组件GridView简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GridView与ListView的用法基本一致，不同的只是布局。当我们打开手机，应用会以宫格显示，那就是GridView。 以代码形式展示给大家，适配器使用SimpleAdapter，熟悉了适配器的用法，就只需要注意几个GridView的属性即可。
Activity类 public class MainActivity extends Activity { private GridView gridView; private List&lt;Map&lt;String, Object&gt;&gt; dataList; private SimpleAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); gridView = (GridView) findViewById(R.id.gridview); //初始化数据 initData(); String[] from={"img","text"}; int[] to={R.id.img,R.id.text}; adapter=new SimpleAdapter(this, dataList, R.layout.gridview_item, from, to); gridView.setAdapter(adapter); gridView.setOnItemClickListener(new OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) { AlertDialog.Builder builder= new AlertDialog.Builder(MainActivity.this); builder.setTitle("提示").setMessage(dataList.get(arg2).get("text").toString()).create().show(); } }); } void initData() { //图标 int icno[] = { R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8041aae807052358cee759468a1df8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/818abbc13650a57fff4568c4b7a3bee5/" rel="bookmark">
			微信小程序—数据缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个微信小程序都可以有自己的本地缓存，可以通过 wx.setStorag（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。本地缓存最大为10MB。 注意： localStorage 是永久存储的，但是我们不建议将关键信息全部存在 localStorage，以防用户换设备的情况。
wx.setStorage(OBJECT)将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。
代码示例
wx.setStorage({ key:"key" data:"value" }) wx.setStorageSync(KEY,DATA) 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。
try { wx.setStorageSync('key', 'value') } catch (e) { } wx.getStorageInfo(OBJECT) 异步获取当前storage的相关信息
wx.getStorageInfo({ success: function(res) { console.log(res.keys) console.log(res.currentSize) console.log(res.limitSize) } }) wx.getStorageInfoSync 同步获取当前storage的相关信息
try { var res = wx.getStorageInfoSync() console.log(res.keys) console.log(res.currentSize) console.log(res.limitSize) } catch (e) { // Do something when catch error } wx.removeStorage(OBJECT) 从本地缓存中异步移除指定 key 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/818abbc13650a57fff4568c4b7a3bee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79509ccc0f60f187649bdd13439bd338/" rel="bookmark">
			H5和原生app哪个好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于H5 和原生app的优缺点回答： 我现在项目现在用的就是：Andriod和IOS相当于容器， 主要复杂的业务逻辑还采用原生，已经有的子模块 需要快速集成进来，或者需要快速上线的模块，原生组没有人力，所有选择了集成H5，只要写一套代码就可以实现在Andriod、ios甚至微信里运行。不过我觉得，H5比较适合活动页，交互少的页面。含有复杂的逻辑的话，特别是需要跟壳交互很多（恶心的后退逻辑，判断版本号，隐藏头部），我建议后期还是要替换成原生。 所以：H5的优点显而易见。上的快，成本低，发布版本也不需要走审核。就这个成本问题和很快就能上问题就吸引项目老大了，再加上每次需求宣讲，产品要快点上，原生组推锅，我们只能当接盘侠了，毕竟这个模块本来就在我们这。 H5的缺点很多，最主要是性能问题， 第一：肯定做不到原生那么流畅。动画这块，没有原生流畅，效果很难模拟，然后动画的优化（translate3d开启GPU渲染等） 本地缓存这快，不优化的话，js、css、img每次打开都要重新获取，体验差且耗流量。所以图片多的话建议缓存到本地 第二：网络问题 ，一断网就呵呵了，只能依靠壳检测网络，如果页面打开后断网，h5不知道已经断网了 第三：功能问题，很多系统的功能无法调用，必须app壳给我们提供调用的接口 ，比如硬件摄像头、陀螺仪、麦克风等硬件支持较差，频繁调用这些硬件 爽了原生开发者，给H5开发的困难：第一：调试困难，不像web里调试那么方便，调试工具可选fiddler。我曾经使用新特性localstorage，无奈壳不支持啊，然后各种和原生那边人联调，恶心的一笔。 最坑的是兼容性问题。各种想不到，那次最后已经调成功了，发现个缺陷坑爹，登录某个账号就会出现问题，甚至页面打不开换手机也不行，就那个账号异常，最后发现兼容性问题，页面里使用了iframe。是这样的，作文列表很长使用下拉分页，然后点击某一条进入作文全文页面，这个是iframe嵌入的，为什么选择使用iframe呢，因为壳不支持缓存页面信息，比如列表我滑到第100页，然后跳转作文全文页面，后退回来还要在这个位置，如果web端很简单，浏览器会帮你记住。但在这个H5里不行，所以我只能用iframe模拟，每次点击后请求数据再渲染iframe。问题在这，为啥有的账号就是异常呢，其它都好的，原来还要先清空再填充。按理不会存在问题的。继续说兼容性，andriod和ios很多表现不同，ios可坑了，比如事件委托。还做过h5里一个按钮的拖拽，性能差不说，在ios里位置也有问题。再比如fixed支持不好，再比如有时候一个头部莫名其妙不出现。 我看微信和支付宝、美团里用了好多H5页面，没接触这个概念之前你可能都不知道它不是原生，因为优化的确实很棒，比如左右滑动等，在一个应用里可以集成那么多子应用。所以我建议：太复杂的用原生，活动页等用H5. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94537543210f3d760746575b68ca5cc/" rel="bookmark">
			关于submit与异步提交的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1使用表单的submit提交表单时，是没有返回值的
2使用ajax异步提交，可以使用回调函数获取到返回信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b817bed874dd5b418f4ef4472c5d12d/" rel="bookmark">
			iOS把url中含有的中文字符转化为UTF8编码方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接：http://blog.csdn.net/litong19930321/article/details/44179399
今天做项目的时候遇到，需要把汉字放进url，例如http://lolbox.duowan.com/phone/apiCheckUser.php?action=getPlayersInfo&amp;serverName=电信十四&amp;target=蛋壳儿 但是直接这样请求的话，提示url是不符合要求的，无法获得数据。这就需要把url转化为utf8编码的格式
//预留参数的网址 NSString *baseUrlString = @"http://lolbox.duowan.com/phone/apiCheckUser.php?action=getPlayersInfo&amp;serverName=%@&amp;target=%@"; NSString *paramServer = @"电信十四"; NSString *paramName = @"蛋壳儿"; //合成新的网址 NSString *urlString = [NSString stringWithFormat:baseUrlString,paramServer,paramName]; //将网址转化为UTF8编码 NSString *urlStringUTF8 = [urlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 这样的url就可以请求数据啦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbb19956b47f08e67f8d90ae9d91eb5/" rel="bookmark">
			软考证到底有多大个鸟用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软考证到底有多大个鸟用？
小虎以信息系统项目管理师高级证书为例，来说说这个证，到底有什么用？
1.求职简历上，可以浓彩重抹一笔，好好吹嘘下自己，是IT高级人才，毕竟有了信息系统项目管理师，这是国家工信部、人力资源部认可的。
就相当于自己在大学是混了个大学文凭，哪怕在大学校园里天天打游戏，泡妞、喝酒聊天、四处打工积攒商业经验或者睡觉呢！这个大学文凭，又没偷没抢，合法通过考试得到的。
2..做研发管理、IT管理，或者其他各种各样的管理，都可以用得到，可以说包治百病，包括以后自己创业、开公司,呵呵；
3.研发岁数大了，还可以转岗，不做工程师了，去做项目管理，项目总监；
4.在北上广深，拿着这个证书，混个绿卡，工作居住证；
软考证书是一项大的积分落户筹码。正常情况下，北京可以加5分。高级证书，妥妥滴！
5.在国有企业和事业单位，是加薪升职必备武器之一，就相当于你拥有个博士学位，那是倍儿呗吃香啊；
6.如果您服务的企业是系统集成类，或者给政府机关、企事业单位提供服务的，那恭喜您，这个证书派上大用场了，您就等着好机会吧！
7.信息系统项目管理师这个高级证书，可以和大学文凭一样管到老；
8.给自己小孩也可以吹一吹牛，说你老爸可是国家级的高工，就像你说自己是个大学生，脸不红，心不跳一样滴。
说得通俗易懂，就类似大学毕业证一样，您说他有用，就特别有用，您说没用，一文不值，因为现在满大街都是大学生。
....
结论：一言以蔽之，一本万利。
有诗为证：
【小虎更多精彩文章】（真的这么精彩，小虎您吹牛的吧！您点击看看，再评论不迟）
1. 人工智能来抢饭碗啦!（上了CSDN百家争鸣头条了） 2. 2017跟着小虎玩着去软考--项目管理师上午考试试题之一(解析2016下半年项目管理师上午试题1-5题)
3. 小虎软考视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3336f02f57ca3874843366a23238190/" rel="bookmark">
			Centos7 忘记密码的情况下，修改root或其他用户密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景 linux管理员忘记root密码，需要进行找回操作。 注意事项：本文基于centos7环境进行操作，由于centos的版本是有差异的，继续之前请确定好版本。
操作步骤 一、重启系统，在开机过程中，快速按下键盘上的方向键↑和↓。目的是告知引导程序，我们需要在引导页面选择不同的操作，以便让引导程序暂停。 以下是暂停后的界面，可以查看下方的英文可知↑和↓的作用。 二、使用↑和↓将选择行设置为第一行（背景高亮即为选中），按下键盘上的e，进入编辑模式
三、将光标一直移动到 LANG=en_US.UTF-8 后面，空格，再追加init=/bin/sh。这里特别注意，需要写在UTF-8后，保持在同一行，并注意空格。由于屏幕太小，会自动添加\换行，这个是正常的。
四、按下CTRL+X进行引导启动，成功后进入该界面
五、输入以下命令
1、挂载根目录 mount -o remount, rw /
2、选择要修改密码的用户名，这里选择root用户进行修改，可以更换为你要修改的用户 passwd root
3、输入2次一样的新密码，注意输入密码的时候屏幕上不会有字符出现。 如果输入的密码太简单，会提示警告（BAD PASSWORD：The password fails the dictionary check - it is too simplistic/systematic），可以无视它，继续输入密码，不过建议还是设置比较复杂一些的密码，以保证安全性
4、如果已经开启了SElinux，则需要输入以下命令 touch /.autorelabel
5、最后输入以下命令重启系统即可
exec /sbin/init 或 exec /sbin/reboot
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b327d18707676c883f00dfd40b1626e1/" rel="bookmark">
			【Java】IO进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO IO： 输入输出 — 写/读
文件 （1）java里IO操作最多的对象 （2）java.io.File类封装了文件对象
File类
File对象代表一个路径下的文件或文件夹File类创建 绝对路基 File f1 =new File("C:\qin.txt");相对路径 File f2 =new File("qin.txt");拼接路径 File f3 =new File("C:\","qin.txt"); \\文件 c:\qin.txtFile对象常用方法
和文件名相关
String getName() String getPath() String getAbsolutePath() String getParent() boolean renameTo(File newName)文件检测
boolean exists() boolean canWrite() boolean canRead() boolean isFile() boolean isDirectory() boolean isAbsolute()获取常规文件信息
long lastModified() long length() boolean delete()目录操作
boolean mkdir() String[] list()IO流
java的IO都是通过流来实现的。流：一种有顺序的，有起点和终点的字节或字符集合。 本质：流就是数据管道
流的分类
按照输入输出分类
输入流 ：从文件里读取数据，写入管道输出流 ：从管道里读取数据，写入文件按照操作单位
字节流： 按照字节为单位，传输 — 所有文件通吃字符流： 按照字符为单位，传输 — 只能对字符文件有效，更有效的发挥缓存区的作用字节流：InputStream类 和 OutputStream类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b327d18707676c883f00dfd40b1626e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9ef29e6fcb9a19c59082ce3df17eb1/" rel="bookmark">
			MyBatis-动态SQL、关联映射、MyBatis整合Spring
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：环境使用上篇MyBatis搭建环境
输入输出映射 1、parameterType输入类型 传递POJO包装对象作为查询条件，可以避免更改源代码。 public class UserVo { // 包含其他的POJO private User user; public User getUser() { return user; } public void setUser(User user) { this.user = user; } }在映射文件xml中，配置： &lt;!-- 使用包装类型查询 --&gt; &lt;select id="findUserByUsername" parameterType="cn.demo.pojo.vo.UserVo" resultType="cn.demo.pojo.User"&gt; select * from user where username like "%"#{user.username}"%" &lt;/select&gt;接口中添加相应方法： /** * 根据用户名查询id */ public List&lt;User&gt; findUserByUsername(UserVo uservo); 2、resultType输出类型 如：查询用户总记录数 ( 输出简单类型 ) &lt;!-- 查询用户总记录数 --&gt; &lt;select id="findUserCount" resultType="Integer"&gt; select count(*) from user &lt;/select&gt;Mapper接口中添加相应方法 3、resultMap resultMap可以将查询结果映射为复杂类型的POJO。 如：查询订单表orders的所有数据 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a9ef29e6fcb9a19c59082ce3df17eb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fe9108156b4d807dd91a2c8e85a832/" rel="bookmark">
			Linux LTP安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Introduction
1. Purposeof this document
LinuxTest Project (LTP) is an open source project with a goal to deliver test suitesto the open source community that validate the reliability, robustness, andstability of Linux. The LTP test suite is a collection of automated andsemi-automated tests for testing various aspects of the Linux operating system.The dominant programming language in LTP is ANSI-C (94%) followed by Bash (5%)and Perl (0.62%).
Thisdocument has several goals.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85fe9108156b4d807dd91a2c8e85a832/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b8603039c102eec586c1675cb793b3/" rel="bookmark">
			CCF NOI1031 等腰三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题链接：CCF NOI1031 等腰三角形。
时间限制: 1000 ms 空间限制: 262144 KB
题目描述
输入一个正整数n，输出高为n的由*组成的等腰三角形。
输入
输入一个正整数。
输出
输出高为n的由*组成的等腰三角形。
样例输入
3
样例输出
* *** ***** 数据范围限制 1&lt;=n&lt;=20
问题分析 打印等腰三角形，关键是循环控制。程序中需要控制好总行数和每一行的字符。
每一行的字符从左到右包括空格（可能是0个）、*号字符（若干个）和换行符。
程序说明
将打印功能封装在函数delta()中，可以使得主程序变得更加简洁。
要点详解 循环变量与空格数，*符号数量的函数关系。 参考链接：I00006 打印等腰三角形字符图案（底边在下） 。 100分通过的C语言程序：
/* 打印等腰三角形字符图案（底边在下） */ #include &lt;stdio.h&gt; void delta(int n) { int i; for(i=1; i&lt;=n; i++){ int j; for(j=1; j&lt;=n-i; j++) printf(" "); for(j=1; j&lt;=2*i-1; j++) printf("*"); printf("\n"); } } int main(void) { int n; scanf("%d", &amp;n); delta(n); return 0; } 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4b8603039c102eec586c1675cb793b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a798d6d482335b57080e8855bb158fc7/" rel="bookmark">
			Java和php时间戳转换问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下Java 时间戳和PHP时间戳 的转换问题： 由于精度不同，导致长度不一致，直接转换错误。 JAVA时间戳长度是13位，如：1294890876859 PHP时间戳长度是10位， 如：1294890859 主要最后三位的不同，JAVA时间戳在PHP中使用，去掉后三位，如：1294890876859-&gt; 1294890876 结果:2011-01-13 11:54:36 echo date(‘Y-m-d H:i:s’,’1294890876’); 复制代码PHP时间戳在JAVA中使用，最后加三位，用000补充,如：1294890859-&gt;1294890859000 结果:2011-01-13 11:54:19 SimpleDateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); String dateTime = df.format(1294890859000L); System.out.println(df); 复制代码总结一下java时间戳和PHP时间戳 的转换问题： 由于精度不同，导致长度不一致，直接转换错误。 JAVA时间戳长度是13位，如：1294890876859 PHP时间戳长度是10位， 如：1294890859 主要最后三位的不同，JAVA时间戳在PHP中使用，去掉后三位，如：1294890876859-&gt; 1294890876 结果:2011-01-13 11:54:36 echo date(‘Y-m-d H:i:s’,’1294890876’); PHP时间戳在JAVA中使用，最后加三位，用000补充,如：1294890859-&gt;1294890859000 结果:2011-01-13 11:54:19 SimpleDateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); String dateTime = df.format(1294890859000L); System.out.println(df);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac425fad74125f493d23b31cdbe2930b/" rel="bookmark">
			有向图的无权图最短路径算法与带权图的Dijkstra算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最短路径算法是图论中的常见问题，在实际中有着较为广泛的应用，比如查找从一个地方到另一个地方的最快方式。问题可以概括为，对于某个输入顶点s，给出s到所有其它顶点的最短路径。水平有限，暂时先对这个问题的求解做简单记录。
无权图是有权最短路径的特例，即边的权重均是1。算法类似于BFS（宽度优先搜索），在实现时需要一个宽度优先搜索的队列。全局变量Distance用来保存所有点到输入顶点的距离。以邻接表表示图，无权图最短路径算法：
//无权图的最短路径算法 static void UnweightedShortestPath(Graph g, int start){ Queue&lt;Integer&gt; Q = new LinkedList&lt;Integer&gt;(); int v,w; Q.offer(start); g.getVertics().get(start).setVivited(true); //输入顶点被标记为已访问 for(int i=0;i&lt;g.getVertexCount();i++) Distance[i] = -1; //初始化Distance，都为-1 Distance[start] = 0; while(!Q.isEmpty()){ v = Q.remove(); //v是队首的整数，记录了图中顶点的序号 while(g.getAdjUnvisitedVertex(v)!=-1){ //寻找顶点v指向的所有的点 w = g.getAdjUnvisitedVertex(v); g.getVertics().get(w).setVivited(true); //图的对应部分标记为已访问,每个顶点只能被访问一次 if(Distance[w] == -1){ Distance[w] = Distance[v]+1; Path[w] = v; Q.offer(w); } }//while }//while } Dijkstra算法是解决最短路径问题的常见算法，过程需要使用优先队列来代替无权图最短路径算法。源点到某个顶点的距离为从源点到该顶点的路径上的所有边权值之和，当新计算得到的距离小于原有的距离时，更新距离。 //Dijkstra算法 static void Dijkstra(Graph g, int start){ MinHeap PQ = new MinHeap(10, 0); //最小堆实现优先队列 int v,w; PQ.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac425fad74125f493d23b31cdbe2930b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42a8f1f6c790d3d5d1a35f9ac94642d/" rel="bookmark">
			Mac admin用户sudo权限失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用sudo安装文件的时候，出现如下错误提示：
sudo: /etc/sudoers is world writable
sudo: no valid sudoers sources found, quitting
sudo: unable to initialize policy plugin
1、首先想到修改/etc/suders来修改用户权限，但是很遗憾的是问题依旧。
2、考虑到suders是文件，还是去修改下suders文件的权限吧，使用shift+command+g命令打开：
找到suders文件
修改用户权限(修改前可以看到用户不在权限范围内)，改成下面这样子就完美了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b01e2217777f5864427707373a8621/" rel="bookmark">
			DOM里常见的三种节点类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.nodeName比tagName注意二者返回的是大写!大写!大写!
从DOM层次来看，nodeName是node 接口上的property，而tagName是element 接口上的property，所有的节点（元素节点，属性节点，文本节点等12种）都继承了node接口，而只有元素节点才继承了element节点，因此nodeName比tagName具有更大的使用范围。
一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。
总结：tagName只能用在元素节点上，而nodeName可以用在任何节点上，可以说nodeName涵盖了tagName，并且具有更多的功能，因此建议总是使用nodeName。
nodeType
nodeType属性返回节点类型的常数值。不同的类型对应不同的常数值，12种类型分别对应1到12的常数值
元素节点 Node.ELEMENT_NODE(1)
属性节点 Node.ATTRIBUTE_NODE(2)
文本节点 Node.TEXT_NODE(3)
CDATA节点 Node.CDATA_SECTION_NODE(4)
实体引用名称节点 Node.ENTRY_REFERENCE_NODE(5)
实体名称节点 Node.ENTITY_NODE(6)
处理指令节点 Node.PROCESSING_INSTRUCTION_NODE(7)
注释节点 Node.COMMENT_NODE(8)
文档节点 Node.DOCUMENT_NODE(9)
文档类型节点 Node.DOCUMENT_TYPE_NODE(10)
文档片段节点 Node.DOCUMENT_FRAGMENT_NODE(11)
DTD声明节点 Node.NOTATION_NODE(12)
2.获得元素属性的集合：
document.getElementsByTagName("BUTTON")[0].attributes; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6419a5babe8d49dbf4a16d3d2f2a0c06/" rel="bookmark">
			初识STM32-思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重新深入学习STM32，写写博客作点记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb2d3d95b287b2f9692b5e037270699/" rel="bookmark">
			Unity3D：获取GameObject的size
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Renderer：渲染尺寸，受缩放影响，受旋转影响。3D图像投影在2D平面上的尺寸
2.MeshFilter：原始尺寸，不受缩放影响
计算真实的size：需要乘以localScale
如：gameObject.GetComponent&lt;MeshFilter&gt;().mesh.bounds.size.x*gameObject.transform.localScale.x
3.Collider：碰撞体尺寸，受缩放影响，受旋转影响。3D图像投影在2D平面上的尺寸
void onClick_scale_percent(){ // stlObjects [0].clingToBottom (); GameObject cube = GameObject.CreatePrimitive (PrimitiveType.Cube); Debug.LogError ("cube Renderer size:"+cube.GetComponent&lt;Renderer&gt;().bounds.size);//default:1,1,1 Debug.LogError ("cube MeshFilter size:"+cube.GetComponent&lt;MeshFilter&gt;().mesh.bounds.size); Debug.LogError ("cube collider size:"+cube.GetComponent&lt;Collider&gt;().bounds.size); cube.transform.parent = go_printCuber.transform; cube.transform.localPosition = new Vector3 (0, 0, 0); cube.transform.localScale = new Vector3 (0.5f, 0.5f, 0.5f); cube.transform.Rotate (0, 45, 0); Debug.LogError ("-------------------"); Debug.LogError ("cube Renderer size:"+cube.GetComponent&lt;Renderer&gt;().bounds.size); Debug.LogError ("cube MeshFilter size:"+cube.GetComponent&lt;MeshFilter&gt;().mesh.bounds.size); Debug.LogError ("cube collider size:"+cube.GetComponent&lt;Collider&gt;().bounds.size); Debug.LogError ("cube localScale:"+cube.transform.localScale);//default:1,1,1 } 转载于:https://www.cnblogs.com/makebetter/p/6734763.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcbfe71ab4d8eea55300db93f4094cc8/" rel="bookmark">
			SMOTE算法(人工合成数据)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SMOTE全称是Synthetic Minority Oversampling Technique即合成少数类过采样技术，它是基于随机过采样算法的一种改进方案，由于随机过采样采取简单复制样本的策略来增加少数类样本，这样容易产生模型过拟合的问题，即使得模型学习到的信息过于特别(Specific)而不够泛化(General)，SMOTE算法的基本思想是对少数类样本进行分析并根据少数类样本人工合成新样本添加到数据集中，具体如图2所示，算法流程如下。
对于少数类中每一个样本 x x x，以欧氏距离为标准计算它到少数类样本集 S m i n S_{min} Smin​中所有样本的距离，得到其k近邻。根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本 x x x，从其k近邻中随机选择若干个样本，假设选择的近邻为 x n xn xn。对于每一个随机选出的近邻 x n xn xn，分别与原样本按照如下的公式构建新的样本
x n e w = x + r a n d ( 0 , 1 ) ∗ ∣ x − x n ∣ x_{new}=x+rand(0,1)*|x-xn| xnew​=x+rand(0,1)∗∣x−xn∣ #SMOTE算法及其python实现 import random from sklearn.neighbors import NearestNeighbors import numpy as np class Smote: def __init__(self,samples,N=10,k=5): self.n_samples,self.n_attrs=samples.shape self.N=N self.k=k self.samples=samples self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcbfe71ab4d8eea55300db93f4094cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a557e91ee7fbbcbbca5497394324f83/" rel="bookmark">
			最小生成树（MST）的性质及算法 [转】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：
chensohg的博客 http://blog.sina.com.cn/u/1182060252 最小生成树性质1：设G=(V，E)是一个连通网络，U是顶点集V的一个真子集。若(u，v)是G中所有的一个端点在U(u∈U)里、另一个端点不在U(即v∈V-U)里的边中，具有最小权值的一条边，则一定存在G的一棵最小生成树包括此边(u，v)。
证明：
为方便说明，先作以下约定：
①将集合U中的顶点看作是红色顶点，②而V-U中的顶点看作是蓝色顶点，③连接红点和蓝点的边看作是紫色边，④权最小的紫边称为轻边(即权重最"轻"的边)。于是，MST性质中所述的边(u，v)就可简称为轻边。
用反证法证明MST性质：
假设G中任何一棵MST都不含轻边(u，v)。则若T是G的一棵MST，则它不含此轻边。
由于T是包含了G中所有顶点的连通图，所以T中必有一条从红点u到蓝点v的路径P，且P上必有一条紫边(u'，v')连接红点集和蓝点集，否则u和v不连通。当把轻边(u，v)加入树T时，该轻边和P必构成了一个回路。删去紫边(u'，v')后回路亦消除，由此可得另一生成树T'。
T'和T的差别仅在于T'用轻边(u，v)取代了T中权重可能更大的紫边(u'，v')。因为w(u，v)≤w(u'，v')，所以 w(T')=w(T)+w(u，v)-w(u'，v')≤w(T)
故T'亦是G的MST，它包含边(u，v)，这与假设矛盾。
所以，MST性质成立。
最小生成树性质2：其最大边权为生成树中最大边权最小的。
证明
反证法：假设Ta为一棵最小生成树，Tb为一棵非最小生成树且其最大边权小于Ta的最大边权。
e是最小生成树Ta的最大边，e将最小生成树Ta分为连通的2个部分A-&gt;B，Tb的连接A-&gt;B的边权为e1，e1&lt;=eb(Tb上最大边权）&lt;e,即A-&gt;B之间存在一条权值比e更小的连通A和B的边，故Ta不是最小生成树，矛盾，故假设不成立。
==========================================================================
Prim算法与Kruskal算法是寻找最小生成树的经典方法，两者皆为贪心法，一次“生成”一条“安全边”，如下所示：
GENERIC-MST-FUNCTION (G,w)
1 T := 空集合
2 while T 还不是生成树
3 do 找出对 T 来说是不会形成cycle，且权重最低的边 (u, v)
4 T := T U {(u, v)}
5 return T
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7f6ae9d9055d14c209504fb18753eb/" rel="bookmark">
			Simulink中Simscape—Fluids模块（原Simhydraulics）学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习来源：http://cn.mathworks.com/help/physmod/hydro/getting-started-with-simhydraulics.html
主要学习内容如下图：
详细内容：
1、组件来源
SIMULINK浏览器中的模块：Simscape_Foundation 和 Simscape_Fluids。
2、Simscape下包括多个子模块，有机械、电气、液压等。在Fluids中，不同子模块中也有不同的颜色划分。
注意：不同的domain（域/类型）不能之间连接。需要转换模块过度，当然一些组件具有多domain属性比如液压缸。
3、新建文件
在matlab命令行中输入：ssc_new。
新建一个simulink文件，里面包含有必要的几个组件：Solver Configuration，PS→S等。
下面介绍几个必备的组件：
4、
Simcsape是SIMULINK中一个特殊的模块，是一种物理连接。如果想和simulink的信号连接比如信号源或者示波器，需要两个组件。即PS→S和S→PS。（S即SIMULINK）。
5、求解器Solver Configuration
simscape的运算根据求解器设定的方法求解，具体见参考文档。
一般使用的有：ode15s，ode23t，ode14x。其中，ode14x是定步长，剩下两个是变步长。
6、参考点（额。。具体不知道怎么叫，反正就是需要一个参考基准一样）
不同的物理域需要不同的参考点，且必须有参考点。
比如液压缸活塞杆带动的负载部分是机械组件，需要一个机械参考点。而进出油口需要一个液压部分的参考点。
7、记录仿真数据到workspace
此法可以省略一些传感器的设置。
点设置（齿轮）——Sinscape——Log siluiation data ，改为ALL——不勾选limit data points——设置变量名如simlog。
查看方法：命令行输入 sscexplore(simlog)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77eddbfc2a682d6e1bf38d49f9c77834/" rel="bookmark">
			android中圆角矩形的绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：Android系统中为我们提供了多种形状可供选择，比如长方形（rectangle）等，我们可以在此基础上绘制出我们想要的形状，比如以下的圆角矩形。该形状可以应用在点击按钮，按钮背景图片发生改变的情境下。
步骤：1.在res目录下新建drawable文件夹，右击drawable，new——&gt;Android XML File，输入文件名称，在这里叫做roundrect.xml，根节点选择shape
2.完整的绘制圆角矩形的代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt; &lt;gradient android:angle="45" android:endColor="#dddddd" android:startColor="#dddddd" /&gt; &lt;padding android:bottom="7dp" android:left="7dp" android:right="7dp" android:top="7dp" /&gt; &lt;corners android:radius="5dp" /&gt; &lt;/shape&gt; 3. 设置圆角矩形四个角的半径如下： &lt;corners android:radius="5dp" /&gt; 以下代码可以使得圆角矩形具有颜色渐变的效果：
android:endColor="" android:startColor="" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52aedf95ea4d748ccd9d9527fb75816/" rel="bookmark">
			c# 播放 mp3格式文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static uint SND_ASYNC = 0x0001; public static uint SND_FILENAME = 0x00020000; [DllImport("winmm.dll")] public static extern uint mciSendString(string lpstrCommand, string lpstrReturnString, uint uReturnLength, uint hWndCallback); public static void SoundText(string paratext) { string temp = System.Environment.GetEnvironmentVariable("TEMP"); DirectoryInfo info = new DirectoryInfo(temp); UserDefined.WebDownLoad("http://tts.baidu.com/text2audio?idx=1&amp;tex=" + System.Web.HttpUtility.UrlEncode(paratext, System.Text.Encoding.GetEncoding("utf-8")) + "&amp;cuid=baidu_speech_demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=6&amp;per=0&amp;vol=9&amp;pit=5", info.FullName + "\\" + paratext + ".mp3"); mciSendString(@"close temp_alias", null, 0, 0); mciSendString("open " + info.FullName + "\\" + paratext + ".mp3" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52aedf95ea4d748ccd9d9527fb75816/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/297/">«</a>
	<span class="pagination__item pagination__item--current">298/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/299/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>