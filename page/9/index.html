<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f16ece233757485b688032ce3be701b7/" rel="bookmark">
			如何正确利用点对点传输工具来传输文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P2P技术作为一种创新的数据交换机制，近年来已经获得了广泛的关注和应用。这种技术通过直接在用户之间建立连接，绕过了传统的中心服务器架构，从而在数据传输效率和速度上实现了显著提升。然而，正如硬币有两面，P2P技术同样伴随着其独特的优势与挑战。本文将深入分析P2P技术的优势与劣势，并以镭速传输工具为例，探讨其在实际应用中的表现。
P2P技术的优势 高效传输：P2P技术允许数据在用户间直接传输，省去了中间环节，这不仅加快了数据传输速度，还降低了延迟。
安全保障：在P2P网络中，数据传输过程中的安全性得到了加强，因为数据不再集中存储于单一服务器，减少了被监听或篡改的风险。
灵活性：P2P技术提供了多样化的传输模式，包括本地与服务器的上传下载、点对点直接传输以及双向同步等，以适应不同用户的需求。
易于集成：P2P工具能够快速与现有企业系统集成，支持SDK、HTTP API、命令行和网络代理等多种集成方式。
P2P技术的劣势 设备限制：P2P技术要求设备间直接通信，这在设备距离较远或存在信号障碍时可能会影响传输质量。
连接稳定性：设备间的直接通信易受距离和环境干扰影响，可能导致连接不稳定，影响数据传输的连续性。
成本问题：构建和维护P2P网络可能需要较高的成本，尤其是在需要跨区域或跨国传输时，可能需要额外的资源投入。
P2P技术的价值P2P技术的核心价值在于它提供了一种高效、安全且灵活的数据传输解决方案，能够适应多样化的应用场景，增强用户的工作效率和协作效能。
镭速传输工具简介 镭速（私有化部署方案，也可接入公有云，企业、社会组织用户可申请免费试用）是一款专为大文件传输设计的P2P工具，它不仅采用了P2P技术，还通过自主研发的Raysync传输协议，突破了传统网络和硬件的限制，实现了极速传输。镭速的主要优势包括：
传输速度：镭速的Raysync协议能够充分利用网络带宽，显著提升传输速率，轻松应对大规模文件传输。
数据安全：镭速采用高级加密和认证技术，确保文件在传输过程中的安全，同时支持全面的日志审计，符合法规要求。
总结P2P技术以其高效、安全和灵活的特性，为用户提供了一种全新的数据传输方式。尽管存在一些挑战，如设备限制和成本问题，但通过工具如镭速的优化，这些问题得到了有效缓解。镭速作为一款专业的企业级传输工具，以其卓越的性能和安全性，成为用户在数据传输领域的理想选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99abe7e837a0eb0c1cffa1a092538629/" rel="bookmark">
			必须收藏的python兼职网站大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 当下python需求量还是挺大的，对于想要做兼职的程序员还是挺友好的：起码不用愁找不到；目前来看，其兼职方向大致有三：开发、爬虫、数据分析。
就开发来说，目前python的轮子在Github上一抓一大把，开发成本和开发周期相比于其他语言会更低；
爬虫同理，但是一定要遵守robots协议，放慢访问频率，做友好的爬虫，千万别碰涉及个人隐私的东西就ok；
数据分析的兼职我见的还不是特别多，毕竟当下公司自己的数据就是财富，除非是特别信任你，基本上很难遇到。
鄙人整理了一份比较适合python兼职接单的网站，对以上技能有自信的可以去试试哦~
—————————
干货满满，希望大家点赞收藏哦
———————————
1、程序员客栈
这是一个国内成立时间比较久，机制相对完善平台，人才数量和质量相当惊人，很多开发者都有大公司的工作经验；而且这个网站依托着其独有的匹配机制、筛选手段和合作流程一路发展到了现在，还是很不错的。
用户群体也一直在增长，也说明这个平台的认可度和安全性；而且平台有一套比较成熟的机制可以保护开发者的收入，起码不用担心甲方带钱跑路的问题。
看了一下网站中python的单子，难度基本适中，没有那种十分大的项目，对应的薪资也在行业内处于中等水平：
平台在开发者之间的知名度和口碑都还不错，对于开发者比较友好，有兴趣的朋友可以去试试。
2、开源众包
开源中国的众包平台，也是个比较老牌的平台了，而且上面的项目主要是众包项目。
据说其接包质量较好，而且它的协助开发工具比较完善。
但是这段时间python的单子好像比较少，可以先观望下。
3、英选
这是个外包平台，它的项目管理是特色，项目阶段推进和信息反馈做的比较好。
4、猪八戒
这个网站上面的python兼职比较简单，相对的薪资也会比较低，比较适合新手练练手。
5、智城外包
这也是一个接外包的网站，是按照竞标的方式来做项目，看来一下平台的python项目，最近的一单在八月中旬，兼职相对比较少
以上，是一些比较适合python兼职接单的网站，如果大家觉得有用，不要忘记点赞收藏关注哦~
一、Python入门 下面这些内容是Python各个应用方向都必备的基础知识，想做爬虫、数据分析或者人工智能，都得先学会他们。任何高大上的东西，都是建立在原始的基础之上。打好基础，未来的路会走得更稳重。所有资料文末免费领取！！！
包含：
计算机基础
python基础
Python入门视频600集：
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
二、Python爬虫 爬虫作为一个热门的方向，不管是在自己兼职还是当成辅助技能提高工作效率，都是很不错的选择。
通过爬虫技术可以将相关的内容收集起来，分析删选后得到我们真正需要的信息。
这个信息收集分析整合的工作，可应用的范畴非常的广泛，无论是生活服务、出行旅行、金融投资、各类制造业的产品市场需求等等，都能够借助爬虫技术获取更精准有效的信息加以利用。
Python爬虫视频资料
三、数据分析 清华大学经管学院发布的《中国经济的数字化转型：人才与就业》报告显示，2025年，数据分析人才缺口预计将达230万。
这么大的人才缺口，数据分析俨然是一片广阔的蓝海！起薪10K真的是家常便饭。
四、数据库与ETL数仓 企业需要定期将冷数据从业务数据库中转移出来存储到一个专门存放历史数据的仓库里面，各部门可以根据自身业务特性对外提供统一的数据服务，这个仓库就是数据仓库。
传统的数据仓库集成处理架构是ETL，利用ETL平台的能力，E=从源数据库抽取数据，L=将数据清洗（不符合规则的数据）、转化（对表按照业务需求进行不同维度、不同颗粒度、不同业务规则计算进行统计），T=将加工好的表以增量、全量、不同时间加载到数据仓库。
五、机器学习 机器学习就是对计算机一部分数据进行学习，然后对另外一些数据进行预测与判断。
机器学习的核心是“使用算法解析数据，从中学习，然后对新数据做出决定或预测”。也就是说计算机利用以获取的数据得出某一模型，然后利用此模型进行预测的一种方法，这个过程跟人的学习过程有些类似，比如人获取一定的经验，可以对新问题进行预测。
机器学习资料：
六、Python高级进阶 从基础的语法内容，到非常多深入的进阶知识点，了解编程语言设计，学完这里基本就了解了python入门到进阶的所有的知识点。
到这就基本就可以达到企业的用人要求了，如果大家还不知道去去哪找面试资料和简历模板，我这里也为大家整理了一份，真的可以说是保姆及的系统学习路线了。
但学习编程并不是一蹴而就，而是需要长期的坚持和训练。整理这份学习路线，是希望和大家共同进步，我自己也能去回顾一些技术点。不管是编程新手，还是需要进阶的有一定经验的程序员，我相信都可以从中有所收获。
一蹴而就，而是需要长期的坚持和训练。整理这份学习路线，是希望和大家共同进步，我自己也能去回顾一些技术点。不管是编程新手，还是需要进阶的有一定经验的程序员，我相信都可以从中有所收获。
资料领取 这份完整版的Python全套学习资料已为大家备好，朋友们如果需要可以微信扫描下方二维码添加，输入"领取资料" 可免费领取全套资料【有什么需要协作的还可以随时联系我】朋友圈也会不定时的更新最前言python知识。↓↓↓
或者
【点此链接】领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052981137e58ce67e0800342c20b4403/" rel="bookmark">
			【oracle】oracle客户端及oracle连接工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于oracle客户端 1.1 Oracle Client 完整客户端 包含完整的客户端连接工具。
包很大，需要安装
1.2 instantclient 即时客户端 是 Oracle(R) 发布的轻量级数据库客户端，减少甚至只包含几个文件，您无需安装标准的客户端，就可以通过它来运行 OCI、OCCI、Pro*C、ODBC 和 JDBC 程序。
适用于那些仅需要连接远程 oracle 数据库，本地不需要安装服务端的用户。例如Toad,PL/SQL/Lab128等Oracle连接工具，虽然依赖Oracle客户端环境，单Instant Client也可以满足要求。
直接下载、解压即可；没有安装程序；
二、客户端下载 2.1 Oracle Client 下载 下载地址：Oracle Client for Microsoft Tools
2.2 instantclient 下载 下载地址：Instant Client for Microsoft Windows (x64) 64-bitOracle Instant Client DownloadsInstant Client for Microsoft Windows (x64) 64-bit
三、基于instantclient连接oracle数据库 3.1 instantclient 版本 使用instantclient 及时客户端连接数据库
instantclient 版本要和 oracle数据库版本对应
数据库服务端是 oracle11g 的，所以用instantclient 11 版本的即时客户端
3.2 instantclient环境变量配置 3.3 navicat工具连接数据库 需要instantclient即时客户端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/052981137e58ce67e0800342c20b4403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bf1eff7dd1783c052d334b97da4364d/" rel="bookmark">
			【日常聊聊】程序员裁员潮：技术变革下的职业危机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎个人博客：个人主页
🏆个人专栏： 日常聊聊
⛳️ 功不唐捐，玉汝于成
目录
前言
正文
一：技术变革
二：裁员的影响
三：程序员如何应对裁员潮危机
结语
我的其他博客
前言 近期，一对来自中国的工程师夫妻在美身亡，引发了对于裁员潮中程序员职业危机的深刻思考。在迅猛的技术变革中，程序员们面临着前所未有的挑战和机遇。本文将探讨当前技术变革的方向，裁员对程序员的影响，以及如何应对这场职业危机。
正文 一：技术变革 技术的日新月异不仅是行业的动力，也是程序员们职业生涯中必须不断适应的现实。当前的技术变革主要体现在：
人工智能与机器学习的崛起： 智能化技术的快速发展，对传统编程模式和职业需求提出了新的挑战。云计算和大数据： 数据处理的巨大需求和云服务的兴起，改变了系统架构和开发模式。区块链技术： 在金融和安全领域等方面崭露头角，给程序员提供了新的发展方向。持续集成与DevOps： 开发、测试和部署的集成，要求程序员具备更全面的技能。 这些技术变革既是挑战，也是机遇，需要程序员具备更广泛的知识和技能，不断学习适应新的工作环境。
二：裁员的影响 裁员对程序员而言可能带来多重冲击：
技能匹配不足： 当前工作技能与市场需求脱节，容易成为裁员的对象。心理压力： 失业可能带来的心理负担，尤其是在竞争激烈的行业中。职业转型问题： 需要面对职业重新定位和转型的挑战。 亲身经历的分享将更具有现实感，让读者更好地理解裁员潮对程序员的实际影响。
三：程序员如何应对裁员潮危机 在这个面临职业危机的时刻，程序员可以采取一些策略来更好地应对：
不断学习： 提升自己的技术水平，适应行业变革的需求。拓宽技能栈： 学习新的技能，增加市场竞争力，可以考虑跨领域拓展。建立人脉关系： 良好的人际关系可以为失业后的职业转型提供支持和资源。规划职业生涯： 对未来的职业规划要有清晰的认识，灵活调整自己的职业目标。 通过这些应对策略，程序员们可以更加从容地应对裁员潮带来的职业危机，寻找到新的职业机会。
结语 程序员裁员潮下，技术变革是必然趋势，但也为程序员们提供了不少机遇。在职业危机中，灵活应对、不断学习、积极适应新技术将成为保持竞争力的关键。让我们共同面对这场职业危机，共创更加光明的职业未来。
我的其他博客 【MySQL】数据库规范化的三大法则 — 一探范式设计原则-CSDN博客
【JAVA】线程的run()和start()有什么区别？-CSDN博客
【日常聊聊】程序员必备的面试技巧：如何在面试战场上脱颖而出-CSDN博客
【JAVA】Java8开始ConcurrentHashMap,为什么舍弃分段锁-CSDN博客
【JAVA】怎么确保一个集合不能被修改-CSDN博客
【Web开发】会话管理与无 Cookie 环境下的实现策略-CSDN博客
【Mybatis】Mybatis如何防止sql注入-CSDN博客
【软件工程】航行敏捷之路：深度解析Scrum框架的精髓-CSDN博客
【Spring】理解IoC与AOP：构建灵活而模块化的软件架构-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07af9356ff2c7c361dff65133a6ec8da/" rel="bookmark">
			浪花 - 添加队伍业务开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、接口设计 1. 请求参数：封装添加队伍参数 TeamAddRequest
package com.example.usercenter.model.request; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableLogic; import lombok.Data; import java.io.Serializable; import java.util.Date; /** * 用户登录请求参数 * @author Ghost * @version 1.0 */ @Data public class TeamAddRequest implements Serializable{ private static final long serialVersionUID = 6993746803531411917L; /** * id */ @TableId(type = IdType.AUTO) private Long id; /** * 队伍名称 */ private String name; /** * 描述 */ private String description; /** * 最大人数 */ private Integer maxNum; /** * 过期时间 */ private Date expireTime; /** * 用户id */ private Long userId; /** * 0 - 公开，1 - 私有，2 - 加密 */ private Integer status; /** * 密码 */ private String password; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07af9356ff2c7c361dff65133a6ec8da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90189dd9d2474bd7328a971f3b3d8dbc/" rel="bookmark">
			【JAVA】Java并发编程中的锁升级机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎个人博客：个人主页
🏆个人专栏：JAVA
⛳️ 功不唐捐，玉汝于成
目录
前言
正文
四个级别锁
锁升级的过程：
偏向锁升级为轻量级锁：
轻量级锁升级为重量级锁：
结语
我的其他博客
前言 在多线程环境下，保障数据的安全性是至关重要的任务之一。Java提供了丰富的并发编程工具，其中锁机制是保障共享资源同步访问的关键。本文将深入探讨Java中锁的升级过程，从无锁状态到偏向锁、轻量级锁，再到重量级锁，揭示了其背后的原理与实现。
正文 四个级别锁 在Java并发编程中，锁升级是指锁的状态从低级别到高级别的转变过程。Java中的锁可以分为四个级别，从低到高分别是：
无锁状态（Unlocked）： 最初状态，表示没有线程持有锁。
偏向锁（Biased Locking）： 当只有一个线程访问临界区时，会偏向于这个线程。偏向锁的目标是提高单线程访问同步块的性能。在偏向锁的情况下，CAS操作不会被使用，从而减少了锁的开销。当有其他线程尝试获取锁时，偏向锁会升级为轻量级锁。
轻量级锁（Lightweight Locking）： 当有多个线程尝试获取同一个锁时，锁会升级为轻量级锁。轻量级锁使用CAS操作来尝试获取锁，如果成功则表示获取锁，否则升级为重量级锁。
重量级锁（Heavyweight Locking）： 当轻量级锁尝试获取锁失败时，锁会升级为重量级锁。重量级锁使用操作系统提供的互斥量（Mutex）来实现，确保在同一时刻只有一个线程能够获取锁。
锁升级的过程： 偏向锁升级为轻量级锁： 当第一个线程进入同步块时，对象头中的Mark Word会记录这个线程的ID，表示偏向于这个线程。当其他线程尝试获取锁时，会发现偏向锁存在，此时会检查记录的线程ID是否是当前线程，如果是，则直接获取锁。如果不是，则升级为轻量级锁。 轻量级锁升级为重量级锁： 如果一个线程获取了轻量级锁，而此时有其他线程尝试获取同一个锁，则会升级为重量级锁。轻量级锁使用CAS操作尝试获取锁，如果CAS失败，表示有竞争，锁会升级为重量级锁。 总体而言，锁升级的过程是为了在不同的并发场景中提供合适的性能表现，根据实际情况选择适当的锁级别，以平衡性能和并发安全。
结语 通过深入理解Java中的锁升级机制，我们能够更好地设计并发安全的程序，提高系统的性能和可伸缩性。在实际开发中，根据不同的并发场景选择合适的锁策略变得至关重要。锁升级机制的背后蕴含着对性能和安全的权衡，而我们的理解和运用将直接影响到多线程程序的稳定性与效率。
我的其他博客 【MySQL】数据库规范化的三大法则 — 一探范式设计原则-CSDN博客
【JAVA】线程的run()和start()有什么区别？-CSDN博客
【日常聊聊】程序员必备的面试技巧：如何在面试战场上脱颖而出-CSDN博客
【JAVA】Java8开始ConcurrentHashMap,为什么舍弃分段锁-CSDN博客
【JAVA】怎么确保一个集合不能被修改-CSDN博客
【Web开发】会话管理与无 Cookie 环境下的实现策略-CSDN博客
【Mybatis】Mybatis如何防止sql注入-CSDN博客
【软件工程】航行敏捷之路：深度解析Scrum框架的精髓-CSDN博客
【Spring】理解IoC与AOP：构建灵活而模块化的软件架构-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d647a1a8572f33b410a6b2b71f0e36f3/" rel="bookmark">
			Unity3D 游戏转场时如何保留节点信息详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Unity3D是一款非常强大的游戏开发引擎，它提供了丰富的功能和工具，使开发者能够轻松创建各种类型的游戏。在游戏开发过程中，转场是一个非常常见的需求，它可以使游戏过程更加流畅和连贯。然而，在转场过程中，如何保留节点信息是一个需要解决的问题。本文将详细介绍Unity3D游戏转场时如何保留节点信息的技术和代码实现。
对惹，这里有一个游戏开发交流小组，希望大家可以点击进来一起交流一下开发经验呀
在Unity3D中，场景是由一系列的游戏对象（GameObject）组成的。每个游戏对象可以包含各种组件（Component），如渲染组件（Renderer）、碰撞组件（Collider）等。在转场过程中，我们需要保留每个游戏对象的节点信息，以便在新的场景中重新创建它们。
首先，我们需要定义一个类来保存节点信息。这个类可以包含游戏对象的名称、位置、旋转和缩放等属性。代码如下：
[System.Serializable] public class NodeInfo { public string name; public Vector3 position; public Quaternion rotation; public Vector3 scale; } 接下来，我们需要在转场前将所有需要保留的节点信息保存起来。可以使用以下代码来实现：
public static List&lt;NodeInfo&gt; SaveNodeInfo() { List&lt;NodeInfo&gt; nodeInfos = new List&lt;NodeInfo&gt;(); GameObject[] gameObjects = GameObject.FindObjectsOfType&lt;GameObject&gt;(); foreach (GameObject gameObject in gameObjects) { NodeInfo nodeInfo = new NodeInfo(); nodeInfo.name = gameObject.name; nodeInfo.position = gameObject.transform.position; nodeInfo.rotation = gameObject.transform.rotation; nodeInfo.scale = gameObject.transform.localScale; nodeInfos.Add(nodeInfo); } return nodeInfos; } 在转场后，我们可以使用保存的节点信息来重新创建游戏对象。可以使用以下代码来实现：
public static void RestoreNodeInfo(List&lt;NodeInfo&gt; nodeInfos) { foreach (NodeInfo nodeInfo in nodeInfos) { GameObject gameObject = new GameObject(nodeInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d647a1a8572f33b410a6b2b71f0e36f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d491ccabfd4cd1981c55f88e232bfbc/" rel="bookmark">
			httpclient5使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		httpclient5使用 httpclientUtil public class HttpClientUtil { private CloseableHttpClient client; private PoolCleaner pc; private static HttpClientUtil util = new HttpClientUtil(); private HttpClientUtil() { PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(); connManager.setMaxTotal(6000); connManager.setDefaultMaxPerRoute(500); RequestConfig.Builder custom = RequestConfig.custom(); //连接超时 custom.setConnectTimeout(Timeout.of(30, TimeUnit.SECONDS)); //请求超时 custom.setConnectionRequestTimeout(Timeout.of(7, TimeUnit.SECONDS)); //设置响应超时 custom.setResponseTimeout(5,TimeUnit.SECONDS); RequestConfig config = custom.build(); client = HttpClients.custom() .setRetryStrategy(new ToHttpRequestRetryStrategy()) .setDefaultRequestConfig(config) .setConnectionManager(connManager) .build(); pc = new PoolCleaner(connManager); //启动失效连接清理 new Thread(pc,"pc-cleaner").start(); } public static HttpClientUtil getInstance() { return util; } public void close() { pc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d491ccabfd4cd1981c55f88e232bfbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f5b3a4df71907f3ff602fa43bddba1a/" rel="bookmark">
			【JavaEE &amp; Spring】MyBatis 操作数据库(基础操作)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis 操作数据库 本节目标前⾔JDBC 操作⽰例回顾1. 什么是MyBatis?2. MyBatis⼊⻔2.1 准备⼯作2.1.1 创建⼯程2.1.2 数据准备 2.2 配置数据库连接字符串2.3 写持久层代码2.4 单元测试 3. MyBatis的基础操作3.1 打印⽇志3.2 参数传递3.3 增(Insert)3.4 删(Delete)3.5 改(Update)3.6 查(Select)3.6.1 起别名3.6.2 结果映射3.6.3 开启驼峰命名(推荐) 4. MyBatis XML配置⽂件4.1 配置连接字符串和MyBatis4.2 写持久层代码4.2.1 添加 mapper 接⼝4.2.2 添加 UserInfoXMLMapper.xml4.2.3 单元测试 4.3 增删改查操作4.3.1 增(Insert)4.3.2 删(Delete)4.3.3 改(Update)4.3.4 查(Select) 5. 其他查询操作5.1 多表查询5.1.1 准备⼯作5.1.2 数据查询 5.2 #{} 和 ${}5.3 排序功能5.4 like 查询 本节目标 使⽤MyBatis完成简单的增删改查操作, 参数传递.掌握MyBatis的两种写法: 注解 和 XML⽅式掌握MyBatis 相关的⽇志配置 前⾔ 在应⽤分层学习时, 我们了解到web应⽤程序⼀般分为三层，即：Controller、Service、Dao .
之前的案例中，请求流程如下: 浏览器发起请求, 先请求Controller, Controller接收到请求之后, 调⽤Service进⾏业务逻辑处理, Service再调⽤Dao, 但是Dao层的数据是Mock的, 真实的数据应该从数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f5b3a4df71907f3ff602fa43bddba1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97074a7773fd04cc1df8432d700c6969/" rel="bookmark">
			电影数据可视化综合分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据可视化&amp;分析实战 1.1 沈腾参演电影数据获取
1.2 电影数据可视化分析
目录 数据可视化&amp;分析实战前言1. 数据认知2. 数据可视化2.1 解决matplotlib不能绘制中文字符的问题2.2 折线图2.3 柱状图绘制2.4 箱线图绘制2.5 饼图 3. Na值处理及相关性分析3.1 相关性分析3.2 Na值处理 4. 图（graph）可视化分析总结 前言 大家好✨，这里是bio🦖。点赞+关注不迷路。数据可视化在数据科学和数据分析中非常重要，例如论文中配色精美的结果图、PPT汇报中突出数据差异数据分析图等。通过可视化，我们可以直观地观察和理解数据的分布、趋势、异常值等特征。通过图表和图形，我们可以更轻松地发现数据中的模式和关联。
本文是对上一篇博客中获取的数据利用python进行可视化分析（沈腾参演电影数据获取），看完本文你将学会：
解决matplotlib不能绘制中文的问题如何使用matplotlib包绘制柱状图、折线图、箱线图、饼图等填充na的方法衡量变量之间的关系以及建模图（graph）可视化分析 本文所用的所有代码都在Github仓库，你可以下载在本地运行（提前安装好相关包~）。感兴趣的话可以star我的主页。
1. 数据认知 在可视化开始之前，我们先对数据有一个基础的认识，了解我们的数据能做什么样的可视化分析，分析之后能得到什么样的结果。本文所用数据来源于博客沈腾参演电影数据获取，也可以使用积分从CSDN资源库下载下载链接。本文所用的全部代码已notebook的格式存储在Github，建议下载使用。
首先读入文件，读入时记得使用gbk编码方式，因为我们的数据中具有中文字符。而后将Rating_value转换为浮点数，Year转换为字符，便于后续绘图。
# time: 2023.07.27 # author: bio大恐龙 import pandas as pd film_details_df = pd.read_csv('/mnt/c/Users/bio_dinosaur/Desktop/films_info.csv', encoding='gbk') film_details_df['Rating_value'] = [float(i) for i in film_details_df['Rating_value']] film_details_df['Year'] = [str(i) for i in film_details_df['Year']] film_details_df.head() 然后看一下数据包含的变量，思考如何进行可视化展示~
Film_name	URL	Year	Director	Actors	Genre	Rating_count	Rating_value	IMDb	Description	Interesting_count	Watched_count 0	超能一家人	https://movie.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97074a7773fd04cc1df8432d700c6969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc32c01e41de6be7c6ce9cef5fe4e27/" rel="bookmark">
			Flink中的时间和窗口（时间语义，水位线，窗口，迟到数据的处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Flink中的时间和窗口
1时间语义
1.1Flink中的时间语义
1.1.1处理时间
1.1.2事件时间
1.2那种时间语义更重要
2 水位线
2.1 事件时间和窗口
2.2 什么是水位线
2.3 如何生成水位线
2.3.1使用WatermarkGenerator
2.3.2使用SourceFunction
2.4 水位线的传递
2.5 水位线的总结
2.5.1水位线的作用如下
2.5.2水位线的特性包括
3 窗口
3.1 窗口的概念
3.2 窗口的分类
①时间窗口
②计数窗口
③会话窗口
④全局窗口
3.3 窗口API概述
3.4 窗口分配器
3.5 窗口函数
3.6 测试水位线和窗口的使用
3.7 其他API
3.8 窗口的生命周期
①创建阶段
②加载阶段
③显示阶段
④激活阶段
⑤失去焦点阶段
⑥关闭阶段
⑦销毁阶段
4 迟到数据的处理
4.1 设置水位线延迟时间
①基于时间窗口的水位线延迟
②基于数据量的水位线延迟
③动态调整水位线延迟
4.2 允许窗口处理迟到数据
Flink中的时间和窗口 1时间语义 1.1Flink中的时间语义 我们重新梳理一下流式数据处理的过程。在事件发生之后，生成的数据被收集起来，首先进入分布式消息队列，然后被Flink系统中的Source算子读取消费，进而向下游的转换算子（窗口算子）传递，最终由窗口算子进行计算处理。
1.1.1处理时间： 处理时间是指执行相应操作的机器的系统时间。当流程序在处理 时间上运行时，所有基于时间的操作（如时间窗口）将使用运行各自
操作符的机器 的系统时间。处理时间是最简单的时间概念，不需要在流和机器之间进行协调。它 提供了最佳的性能和最低的延迟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc32c01e41de6be7c6ce9cef5fe4e27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ace0456a27b28610c9fcd29e647b370/" rel="bookmark">
			多流转换 （分流，合流，基于时间的合流——双流联结 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，分流
1.实现分流
2.使用侧输出流 二，合流
1，联合 2，连接 三，基于时间的合流——双流联结 1，窗口联结
1.1 窗口联结的调用
1.2 窗口联结的处理流程 2，间隔联结
2.1 间隔联结的原理
2.2 间隔联结的调用
在数据处理中，多流转换是一个重要的概念。它主要涉及分流和合流两种操作。分流通常通过侧输出流实现，有助于将数据流拆分成多个子流进行独立处理。合流则提供了多种算子，如union()、connect()和join()，根据实际需求合并不同数据流。
一，分流 分流操作是指将一条数据流拆分为多个完全独立的数据流。基于一个DataStream，我们可以获得多个等价的子DataStream。为了实现这一过程，通常会定义特定的筛选条件，以确保符合特定标准的数据被正确地分配到相应的流中。通过这种方式，我们可以对数据进行更细致的处理和分析，同时确保每个子流中的数据都是独特的，避免重复。
1.实现分流 根据条件筛选数据的需求确实可以通过多次独立调用filter()方法来实现。这种方法允许我们针对同一条数据流进行多次筛选，从而将数据拆分成多个子流。通过这种方式，我们可以根据不同的筛选条件对数据进行分类和分离，以满足不同的处理和分析需求。这种分流操作在数据处理中非常常见，它有助于提高数据处理的灵活性和效率。 import org.apache.flink.api.scala._ object SplitStreamExample { def main(args: Array[String]): Unit = { // 创建执行环境 val env = StreamExecutionEnvironment.getExecutionEnvironment // 定义数据源 val dataStream = env.fromElements(1, 2, 3, 4, 5) // 定义筛选条件 val condition1: (Int) =&gt; Boolean = (x: Int) =&gt; x % 2 == 0 val condition2: (Int) =&gt; Boolean = (x: Int) =&gt; x &gt; 3 // 对DataStream进行分流操作，得到两个子DataStream val stream1 = dataStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ace0456a27b28610c9fcd29e647b370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28084b3408b764502ec33cdae32492ed/" rel="bookmark">
			《设计模式的艺术》笔记 - 迭代器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 迭代器模式提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标（Cursor）。迭代器模式是一种对象行为型模式。
实现 myclass.h
// // Created by yuwp on 2024/1/12. // #ifndef DESIGNPATTERNS_MYCLASS_H #define DESIGNPATTERNS_MYCLASS_H #include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;atomic&gt; #include &lt;vector&gt; #include &lt;memory&gt; #include &lt;list&gt; class Object { public: Object(int id); int getId(); private: int m_id; }; class Iterator { public: virtual void first() = 0; virtual void next() = 0; virtual bool hasNext() = 0; virtual Object *currentItem() = 0; }; class Aggregate { public: virtual Iterator *createIterator() = 0; }; class ConcreteAggregate : public Aggregate { public: ~ConcreteAggregate(); Iterator *createIterator() override; uint32_t size(); Object *getObject(int index); void pushBack(Object *obj); private: std::vector&lt;Object *&gt; m_objects; }; class ConcreteIterator : public Iterator { public: ConcreteIterator(ConcreteAggregate *mObjects); void first() override; void next() override; bool hasNext() override; Object *currentItem() override; private: ConcreteAggregate *m_objects; int m_cursor; }; #endif //DESIGNPATTERNS_MYCLASS_H myclass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28084b3408b764502ec33cdae32492ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22df46c9ea9b568fa19f5c775af8ed94/" rel="bookmark">
			【射影几何11】完全四边形和交比研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 对于交比的灵活应用，尚有许多情况需要讨论，首先引出完全四边形的例子，该关键词的应用非常普遍；其次，我们尝试用交比证明一些事实；随后我们又引出交比射影案例的特殊情况。
二、完全四边形 2.1 完全四边形定义 【定义】完全四边形，就是存在四条线，其中不允许出现三条线共点，那么四条线围成的区域，即是完全四边形。
讨论：什么不是完全四边形？
上图，退化成三边形，不是完全四边形
上图为梯形，是完全四边形。只是作图中常常不用梯形，因为平行线相交无穷远无法做出。
2.2 完全四边形的对角线 完全四边形的对角线及其重要，这里专门强调一下。
上图中AC、DB、EF是完全四边形的对角线，对角线三条，不要搞错，EF也是对角线！。
2.3 完全四边形的对角线上的调和点列 如图，直线AE、BE、AF、BI构成一个完全四边形EIGF，直线AB、IF、EG为对角线。记A、B、C、D的交比为(ABCD)，则(ABCD)=-1。
根据交比的不变性，由E点的投影，有 x = ( A B C D ) = ( I F H D ) x=(ABCD)=(IFHD) x=(ABCD)=(IFHD)
由G点的投影，有 ( B A C D ) = ( I F H D ) (BACD)=(IFHD) (BACD)=(IFHD)
根据定义，有 ( B A C D ) = 1 ( A B C D ) = 1 x (BACD)={\frac {1}{(ABCD)}}={\frac {1}{x}} (BACD)=(ABCD)1​=x1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22df46c9ea9b568fa19f5c775af8ed94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5410db5892b0eae4089af79f28a498c0/" rel="bookmark">
			Web3:B站chainlink课程：wsl连接装好的虚拟机并换源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		照顾一下可能真的没接触过linux的选手，决定还是记录一下。
打开vscode，点击左下角
点这个东西，然后应该会弹出来这样的。
我估计上面那个就是连接Wsl默认的那个虚拟机，下面的那个就是自选。
第一次连接会自动装一个什么server的，我也没细看。
估计装好之后都试过启动了吧，应该都设置好了用户名和密码。
2.换源
https://blog.csdn.net/u012308586/article/details/102953882
按这个来就好。
不过这个不怎么符合我的习惯。
来个我的强迫症版本示例。
cd /etc/apt 进入apt文件夹之后
ls -all 看到了sources.list，然后搞个备份
sudo cp sources.list sources.list.bak 然后再看一眼
ls -all 看到了sources.list 和 sources.list.bak
接下来是改文件部分
gedit不好用的话
sudo vim sources.list 进文件，然后在命令行模式下（vim基础，如果不懂百度一下）
:dd 把文件删干净。
然后在那个教程里复制对应你安装的ubuntu版本的源。
回到命令行，在vscode里头直接右键好像就粘贴了，如果是直接cmd打开或者powershell打开的话，自己搜一下怎么粘贴。
粘贴完成之后，Esc，然后输入
:wq 此时强迫症患者会
vim sources.list 检查之后确认无误。
:q 回到文件夹，剩下的按教程来就好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9ca0ca98768dba7e39d5b8b6a7c1dc/" rel="bookmark">
			剧本杀小程序开发：探索游戏与科技的完美结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的飞速发展，越来越多的人开始寻求数字化娱乐方式。剧本杀小程序正是这种需求下的产物，它将传统的剧本杀游戏与现代科技相结合，为玩家提供了全新的游戏体验。本文将探讨剧本杀小程序开发的各个方面，包括市场需求、功能设计、技术实现和未来发展。
一、市场需求
剧本杀是一种深受年轻人喜爱的角色扮演游戏，它需要玩家运用推理、观察和团队协作来解决谜题。随着游戏市场的不断扩大，越来越多的玩家开始寻求更加便捷、丰富的游戏体验。因此，剧本杀小程序应运而生，满足了玩家在移动端进行游戏的需求。
二、功能设计
剧本杀小程序的功能设计需要充分考虑玩家的需求和游戏的特点。以下是一些重要的功能点：
1. 角色扮演：玩家可以选择不同的角色，每个角色都有独特的技能和背景故事。
2. 剧情推进：游戏剧本由多个剧情线组成，玩家需要通过完成任务、推理和解谜来推动剧情发展。
3. 互动交流：玩家可以在游戏中与其他玩家互动，共同解决问题或进行辩论。
4. 数据分析：小程序应提供详细的游戏数据统计和分析功能，帮助玩家了解自己的游戏表现。
5. 社交分享：玩家可以将游戏结果分享到社交媒体，增加游戏的社交性和互动性。
三、技术实现
剧本杀小程序的技术实现需要综合考虑前端和后端的设计。前端方面，可以采用微信小程序框架进行开发，利用其强大的开发工具和丰富的API接口，实现流畅的用户体验。后端方面，可以采用云服务器进行部署，保证游戏的稳定性和安全性。此外，为了实现跨平台游戏功能，可以使用Unity等跨平台游戏引擎进行开发。
四、未来发展
随着科技的不断进步和玩家需求的不断变化，剧本杀小程序还有很大的发展空间。未来可以考虑的方向包括：
1. AI辅助：引入人工智能技术，为玩家提供更加智能的NPC交互体验，提升游戏的趣味性和挑战性。
2. 社区化：建立游戏社区，让玩家可以分享游戏心得、交流游戏技巧，增强游戏的社交属性。
3. 个性化：提供更加个性化的游戏设置选项，满足不同玩家的需求和口味。例如，玩家可以选择自己喜欢的角色、剧情线和难度等级等。
4. 跨平台合作：与其他平台或游戏进行合作，拓展玩家的选择范围和游戏的可玩性。例如，可以与知名IP合作推出特色剧本，或者与其他推理解谜类游戏进行联动活动等。
5. 数据驱动：通过收集和分析玩家的游戏数据，不断优化游戏设计和功能，提高玩家的满意度和忠诚度。例如，根据玩家的游戏表现和喜好推荐适合他们的剧本和角色等。
6. 虚拟现实（VR）/增强现实（AR）技术：将VR/AR技术引入剧本杀小程序中，为玩家提供更加沉浸式的游戏体验。通过虚拟的环境和道具，让玩家仿佛置身于真实的游戏中，提升游戏的刺激感和互动性。
7. 商业模式创新：探索更多的商业模式，如道具收费、会员制度等，为玩家提供更多的付费选择和增值服务。同时，也可以通过与其他产业的合作，如与旅游景点、电影院等进行联合活动或优惠活动等，提高玩家的参与度和黏性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e504aa0d241fcb35efa8615c5ffcd39/" rel="bookmark">
			完全背包问题简单思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01背包简单理解
问题描述： 给你一个体积为10的背包，要求将下列物品中的一个或多个装入背包，使背包能有最大价值（每个物品有无限个） 物品1：体积2，价值1 物品2：体积3，价值3 物品3：体积4，价值5 物品4：体积7，价值9 文章目录 代码 且看下面表格理解：
物品编号\体积01234567891000000000000010a2030b40 说明： - 编号为0的物品价值也为0，所以第一行全为0 - 当背包体积为0时，一个物品也装不下，所以第一列全为0 - a点表示当背包体积为2时，只有物品0和物品1（当前物品）可装入背包，此时背包的最大价值 - b点表示当背包体积为7时，有物品0、物品1、物品2、物品3（当前物品）可装入背包，此时背包的最大价值 完全背包求最大价值步骤规则： - 每一个格子都默认继承该列的上一行的那个格子的值，例如，a点（1，2）的值就默认继承（0，2）的值 - 判断当前物品（相当于每个格子对应的行，对应的行又代表物品编号，所以也就叫做当前物品了）是否能装入背包中： - 若不能装入，就继承 - 若能装入，比较“继承的值”和“当前物品的价值+背包体积减去当前物品体积所剩余的体积的最大价值” - 与01背包不同的是，找剩余背包体积的最大价值时，是去该行寻找（因为完全背包中，每个物品有无限个， 而01背包中，每个物品有且仅有一个） 下面来一步一步找出每个格子的值
初始化表格（物品编号右边数字分别表示物品的体积和价值）：
物品编号\体积0123456789100000000000001（2，1）02（3，3）03（4，5）04（7，9）0 判断（1，1）点：
背包体积为1，当前物品体积为2，不能装入，继承（0，1）
物品编号\体积0123456789100000000000001（2，1）002（3，3）03（4，5）04（7，9）0 判断（1，2）点：
背包体积为2，当前物品体积为2，能装入
装入后背包剩余体积为0，剩余背包体积最大价值应去找（1，0）
比较继承的值和当前物品价值+剩余背包体积最大价值：0 &lt; 1 + 0
物品编号\体积0123456789100000000000001（2，1）0012（3，3）03（4，5）04（7，9）0 判断（1，3）点：
背包体积为3，当前物品体积为2，能装入
装入后背包剩余体积为1，剩余背包体积最大价值应去找（1，1）
比较继承的值和当前物品价值+剩余背包体积最大价值：0 &lt; 1 + 0
物品编号\体积0123456789100000000000001（2，1）00112（3，3）03（4，5）04（7，9）0 判断（1，4）点：
背包体积为4，当前物品体积为2，能装入
装入后背包剩余体积为2，剩余背包体积最大价值应去找（1，2）
比较继承的值和当前物品价值+剩余背包体积最大价值：0 &lt; 1 + 1
此时背包就装了两个物品1了 物品编号\体积0123456789100000000000001（2，1）001122（3，3）03（4，5）04（7，9）0 第一行就按照这样的规则来判断…下面直接给出
物品编号\体积0123456789100000000000001（2，1）001122334452（3，3）03（4，5）04（7，9）0 判断（2，1）点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e504aa0d241fcb35efa8615c5ffcd39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8429eab5d99a2b64b083f9b56e1fd39/" rel="bookmark">
			Microsoft Visual Studio 2022的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 软件介绍 Microsoft Visual Studio 2022是Microsoft Visual Studio软件的一个高版本，能够编写和执行C/C++代码，具有强大的功能，是开发C/C++程序的主流软件。
Microsoft Visual Studio 2022有三个版本，分别是社区版（Community）、专业版（Professional）和企业版（Enterprise），选择社区版就能满足日常C/C++软件开发需要。
图1 Microsoft Visual Studio 2022版本 2 软件安装 Microsoft Visual Studio软件由于体积大，所以安装时间较长。对于工作负荷，只选择“使用C++的桌面开发”即可；对于安装位置，保持默认位置C盘即可，也可以选择D盘。
图2 Microsoft Visual Studio 2022安装界面 3 软件使用 这一部分介绍使用Microsoft Visual Studio2022软件编写C/C++代码的操作。
3.1 创建新项目 打开Microsoft Visual Studio2022后，点击创建新项目，选择空项目，进入下一步。
图3 Microsoft Visual Studio2022创建空项目 在配置新项目中，可以更改项目名称。点击创建，即可完成新项目的创建。
图4 Microsoft Visual Studio2022配置新项目 在项目Project1Hello中，对于源文件，可以新建项，添加新项Project1Hello.c，即可编写并执行C语言程序，若想编写并执行C++语言程序，可将源文件Project1Hello.c重命名为Project1Hello.cpp。
图5 源文件添加新项 3.2 在解决方案中新建项目 在一个解决方案中，可以存在多个项目，这多个项目之间互不影响，每个项目中均可以有一个main函数。
图6 在解决方案中新建项目 对于新的项目，将其设为启动项目之后，这个项目的项目名加粗，这时可以执行这个项目中的代码。
图7 设置启动项目 3.3 调试代码 调试是程序设计人员必须掌握的技能，下文根据此处给出的代码，说明调试的基本操作。
#include &lt;iostream&gt; using namespace std; int abc() { int k = 0; k += 5; return k; } int main() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8429eab5d99a2b64b083f9b56e1fd39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5fd151bb1f1272ba746e2622a32672/" rel="bookmark">
			遍历子网所有ip地址，寻找空闲ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在cmd窗口下输入如下代码：
for /l %i in (1,1,255) do ping -n 1 -w 60 10.183.27.%i | find "Reply" &gt;&gt; d:\pingall27.log 得到如下结果
上图中，有reply的代表该IP已经被占用。但是观察红框中 22--&gt;25之间缺少23 24 则说明23/24 是空闲IP地址；同理29--&gt;40之间也是空闲地址。
需要注意的是：没有reply的并不代表一定是空闲地址，也有可能是该IP地址所属的主机开启了防火墙，导致你ping不通该地址。
以下是代码解释：
这段命令是一个Windows批处理命令，用于批量ping一系列IP地址并将结果保存到日志文件中。我将为你详细解释每部分的功能： for /l %i in (1,1,255)：这是一个for循环，/l参数表示对一个数字序列进行迭代。这里，数字序列从1开始，每次增加1，直到255。%i是循环变量的表示。 do ping -n 1 -w 60 10.183.27.%i：这是在每次循环中要执行的操作。ping命令用于发送ICMP回应请求到目标主机。 -n 1：表示只发送一个ping请求。 -w 60：表示等待每个回应的超时时间为60毫秒。 10.183.27.%i：这是目标IP地址的格式。它表示从10.183.27.1到10.183.27.255的所有IP地址。通过使用%i，我们可以为每个循环迭代生成一个不同的IP地址。 |：这是一个管道符号，用于将前一个命令的输出传递给后一个命令作为输入。 find "Reply"：这是一个find命令，用于搜索特定的字符串。在这里，它搜索字符串"Reply"，这通常表示ping请求成功地得到了回应。 &gt;&gt; d:\pingall27.log：这将上述find命令的输出追加到名为"pingall27.log"的文件中。如果文件不存在，它将被创建。如果文件已存在，新的输出将被追加到文件的末尾，而不是覆盖现有内容。 综上所述，这个命令将ping从10.183.27.1到10.183.27.255的所有IP地址，并将每个成功回应的IP地址及其对应的ping时间追加到一个日志文件中。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b9345cc16efe2b5012ba1472dfe8a2/" rel="bookmark">
			flutter 中使用flutter_slidable 实现左滑显示删除、修改菜单，仿微信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter pub add flutter_slidable 导入 import 'package:flutter_slidable/flutter_slidable.dart'; 使用 import 'package:flutter/material.dart'; import 'package:flutter_slidable/flutter_slidable.dart'; void main() =&gt; runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({ Key? key, }) : super(key: key); @override Widget build(BuildContext context) { return MaterialApp( title: 'Slidable Example', home: Scaffold( body: ListView( children: [ Slidable( // Specify a key if the Slidable is dismissible. key: const ValueKey(0), // The start action pane is the one at the left or the top side.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0b9345cc16efe2b5012ba1472dfe8a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73bf7199df03bc13fcfb3da7dfb37e3/" rel="bookmark">
			yolov8 opencv dnn部署自己的模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码地址 本人使用的opencv c++ github代码,代码作者非本人 使用github源码结合自己导出的onnx模型推理自己的视频 推理条件 windows 10
Visual Studio 2019
Nvidia GeForce GTX 1070
opencv4.7.0 (opencv4.5.5在别的地方看到不支持yolov8的推理，所以只使用opencv4.7.0)
导出yolov8模型 yolov8版本: version = ‘8.0.110’
首先将default.yaml中的一些配置修改以下，将只修改的部分贴上去，注意下面的batch一定要设置为1
task: detect # YOLO task, i.e. detect, segment, classify, pose mode: export # YOLO mode, i.e. train, val, predict, export, track, benchmark # Train settings ------------------------------------------------------------------------------------------------------- # model: C:\Users\HUST\Desktop\yolov8_ultralytics\ultralytics\models\v8\yolov8.yaml # path to model file, i.e. yolov8n.pt, yolov8n.yaml model: C:\Users\Administrator\Desktop\yolov8_ultralytics\runs\detect\yolov8n\weights\best.pt # path to model file, i.e. yolov8n.pt, yolov8n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73bf7199df03bc13fcfb3da7dfb37e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3931b0e7f1db3f4311803d36b8303399/" rel="bookmark">
			WEB前端递归数组模块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function fn(n){ for(let i = 0; i&lt; n; i++){ for(let j = 0; j &lt; n; j++){ console.log(i) } } } //递归函数：简单说就是自己调用自己的函数,一定要有种终止条件 //定义函数 // function fn(num){ // console.log(num) // num += 1 // if(num &gt;=100){ // console.log(num) // return num // } // fn(num) // } // //调用 // let num = 0 // fn(num) function sum(n) { if (n == 1) { return 1 } return sum(n - 1) + n } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3931b0e7f1db3f4311803d36b8303399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2a96ef4bf0f55bad9afb9d0b625c2a/" rel="bookmark">
			第一节——单片机概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MCD-51单片机 与8051（80C51） 兼容的主要产品
ATMEL公司生产的兼容51单片机的具体型号
2.AVR系列单片机 AVR系列是1997年ATMEL公司挪威设计中心的A先生与V先生共同研发出的精简指令集(RISC—Reduced Instruction Set Computer)的高速8位单片机，简称AVR。
AVR单片机系列全，3个档次，适于各种不同要求：
（1）低档Tiny系列: Tiny11/12/13/15/26/28等；
（2）中档AT90S系列: AT90S1200/2313/8515/8535等；
（3）高档ATmega系列: 有ATmega8/16/32/64/128（ 存储容量为8/16/32/64/128 KB）以及ATmega8515/8535等。
3.PIC系列单片机 美国Microchip公司。
特性如下：
（1）最大特点是从实际出发，重视性价比，已开发出多种型号来满足应用需求。例如，一个摩托车的点火器需要一个I/O较少、RAM及程序存储空间不大、可靠性较高的小型单片机，若用40脚单片机，投资大，使用也不方便。
（2）精简指令集（RISC）使执行效率大为提高。 数据总线和指令总线分离的哈佛结构，指令单字长，且允许指令代码的位数可多于8位的数据位数，这与传统的采用复杂指令结构（CISC）结构的8位单片机相比，可达到2:1的代码压缩，速度提高4倍。
（3）优越的开发环境。8051的开发系统大都采用高档型仿真低档型，实时性不理想。PIC推出一款新型号单片机的同时推出相应的仿真芯片，所有的开发系统由专用的仿真芯片支持，实时性非常好。
（4）其引脚具有防瞬态能力，通过限流电阻可以接至220V交流电源，可直接与继电器控制电路相连，无须光电耦合器隔离，给应用带来极大方便。
（5）保密性好。PIC以保密熔丝来保护代码，用户在烧入代码后熔断熔丝，别人再也无法读出，除非恢复熔丝。目前，PIC采用熔丝深埋工艺，恢复熔丝的可能性极小。
（6）片内集成看门狗定时器，可用来提高运行可靠性。
（7）设有休眠和省电工作方式。可大大降低系统功耗并可采用电池供电。
世界最小的单片机PIC10F322 —6脚单片机 PIC单片机分低档型、中档型和高档型：
（1）低档8位单片机 PIC12C5XXX／16C5X系列。PIC16C5X系列最早在市场上得到发展，价格低，有较完善的开发手段，因此在国内应用最为广泛；而PIC12C5XX是世界第一个8脚低价位单片机可用于简单的智能控制等要求体积小的场合，前景广阔。
（2）中档8位单片机 PIC12C6XX/PIC16CXXX系列。PIC中档产品是Microchip公司近年来重点发展的系列产品，品种最为丰富，其性能比低档产品有所提高，增加了中断功能，指令周期可达到200ns，带A／D，内部E2PROM数据存储器，双时钟工作，比较输出，捕捉输入，PWM输出，I2C和SPI接口，异步串行接口（UART），模拟电压比较器及LCD驱动等等，其封装从8脚到68脚，可用于高、中、低档的电子产品设计中，价格适中，广泛应用在各类电子产品中。
（3）高档8位单片机 PIC18系列PIC18F452。 片内程序存储器最大可达64KB，片内RAM最大可达4KB； 有8位和16位定时器，比较器；8级硬件堆栈，10位A/D转换器，捕捉输入，PWM输出；配置了I2C、SPI，UART串口，CAN、USB接口，模拟电压比较器及LCD驱动电路等，其封装从14脚到64脚，价格适中，性价比高。已得到广泛应用。
4.各类嵌入式处理器简介 体系结构分为几类：
（1）嵌入式微处理器（microprocessor unit，MPU）：其诞生和基本原理与计算机的 CPU 有很大的关系，支持 32 位精简指令集。正是微处理器的诞生，使得嵌入式系统发生了巨大变化。其中以 ARM 嵌入式处理器为代表，被广泛应用在各个电子领域。它的优势是更能适应系统，更能稳定、高效的控制和运行嵌入式系统，并且抗干扰能力以及其他方面的性能都得到了提升。
（2）嵌入式微控制器（microcontroller unit，MCU）：又名单片机，它是一种集成了 CPU、存储器等计算机系统上硬件单元的微处理器集成芯片。其与嵌入式微处理器相比具有单片化、小型化、成本低、功耗低等优点。其中最具代表的就是 8051系列单片机。因为微控制器的这些特点使得其能够充当独立的嵌入式设备，也能作为辅助嵌入式系统的一个模块，并且因其具有良好的数据处理能力和成本低廉的特点使得其被广泛应用在工业领域。
（3）嵌入式数字信号处理器（digital signal processor，DSP）：就是用于处理数字信号的处理器，换言之，是一种利用基础算术进行运算的处理器，运算效率高，能够准确的提取或转换数字信号。DSP 的优势是数据处理能力强和运行速度快。与微处理器相比，前者在数字信号处理部分有着一定的优势，与微控制器类似的是，DSP 能够作为独立的核心处理器，也能够成为辅助嵌入式系统的一个子系统与其他处理器共同运行。
（4）嵌入式片上系统（system on chip，SoC）：这是一种高集成化的嵌入式系统，其最大的特点是高集成性、综合性，并且能够替代集成电路成为一种更优的方案。随着技术的发展，SoC 将发挥它的优势使得嵌入式系统能够实现更高、更复杂的集成性。但是开发难度以及成本也会随之升高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5335ae32a7bb24aeb5b6f364ec914821/" rel="bookmark">
			〖大前端 - ES6篇①〗- ES6简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：该文属于 大前端全栈架构白宝书专栏，目前阶段免费，如需要项目实战或者是体系化资源，文末名片加V！作者：哈哥撩编程，十余年工作经验, 从事过全栈研发、产品经理等工作，目前在公司担任研发部门CTO。荣誉：2022年度博客之星Top4、2023年度超级个体得主、谷歌与亚马逊开发者大会特约speaker、全栈领域优质创作者。 🏆 白宝书系列 🏅 启示录 - 攻城狮的自我修养🏅 Python全栈白宝书🏅 ChatGPT实践指南白宝书🏅 产品思维训练白宝书🏅 全域运营实战白宝书🏅 大前端全栈架构白宝书 文章目录 ⭐ ES6简介⭐ ES与JavaScript的关系⭐ ES的版本🌟 ES的版本命名方式🌟 ES6的历史版本🌟 ES6的兼容性 ⭐ ES6简介 ES6即ECMAScript 6的简写，那么什么是ECMAScript 6呢？
ECMAScript就是由ECMA这个标准化组织制定的一个语言标准，具体来说就是ECMA这个标准化组织规定了我们的语法和api
那么什么是语法？什么是api？我们在学习JavaScript的时候已经对语法有了一定的了解，语法就是编写脚本语言时需要遵循的基本的方法和规则，比如如何声明变量，如何声明常量，基本的数据类型有那些等等。api可以简单理解为方法或函数。比如规定了数组的方法有push()、pop()等，所以ECMAScript可以看作语法和API的集合
⭐ ES与JavaScript的关系 JavaScript(浏览器端) = ECMAScript(语法+API) + DOM + BOM
⭐ ES的版本 🌟 ES的版本命名方式 ES的版本命名方式有两种：按照版本号命名（比如ES6、ES7、ES8等）、按照推出年份命名（比如ES2015、ES2016、ES2017），我们只需要了解哪个版本和哪个推出年份对应就行了，比如ES6推出年份时2015年，所以ES6和ES2015指的是一个版本。
大家要注意，ES6是ES6+的基础，而ES7、ES8、ES9相当于在ES6的基础上扩展的语法或API，我们学习的重点还是要放在ES6上。
🌟 ES6的历史版本 在ES6(ECMAScript 6)之前，有4个版本，分别是ES1~3和ES5。
关于ES4:
为什么历史版本没有ES4呢？因为ES4被废弃了，之所以被废弃，是因为ES4是一次特别大的改革，太激进了，导致ES4和ES3看起来像两种截然不通的语言，跨度太大。ES4中不太激进的部分被吸收到了ES5，有点激进的部分被吸收到了ES6，还有些更激进的部分等待后续的版本吸收
在ES6的历史版本功能里，ES1和ES2还不太成型，我们用的最多的是ES3里的内容，比如do…while、switch、正则表达式等。ES5由于兼容性不太好，所以ES5推出的例如forEach、map、filter、Object.create、Object.defineProperty等用的就不太多。
🌟 ES6的兼容性 主流浏览器的最新版本几乎全部支持ES6
IE老版本等不支持的浏览器可以用Babel转码
所以，放心大胆的使用ES6吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0404736fcd9fa9b027dc6234c5e5fad/" rel="bookmark">
			2024年预制菜行业市场发展趋势分析（2021-2023年预制菜行业数据分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，老干妈被称为预制菜、预制菜国标报送稿出炉等事件再次引起大众对于预制菜市场的讨论。随着国家对预制菜审核标准的严格化，预制菜市场未来走向将会如何？鲸参谋带大家从数据角度来了解。
首先来看下预制菜市场的行业发展情况。
根据鲸参谋的数据显示，2021年不完全统计，京东平台预制菜销售额为300多万元（仅在商品标题中含“预制菜”关键词）；
*数据源于鲸参谋
根据2022年不完全统计，京东平台预制菜的销售额达到1500多万元（统计维度同上）；
*数据源于鲸参谋
根据2023年不完全统计，京东平台预制菜销售额在4200多万元（统计维度同上）。
*数据源于鲸参谋
综合2021年至2023年的年度数据结果，我们可以发现2022年是预制菜的增长巅峰时期，销售额较2021年翻了4倍；到了23年，市场增速明显放缓，整体增长仅2倍不到。从这个走势来看，不论市场监管是否强化，未来预制菜市场并不会继续保持势如破竹的状态，风口正在缩小。
其次，了解一下市场格局的变化情况。
2021年和2022年，头部品牌市占比均达到85%以上，头部品牌包括家乐、屯河、饭乎、自嗨锅等。
*数据源于鲸参谋
2023年，头部品牌集中度降低，除了饭乎、屯河以外，其余品牌基本经历了市场的洗牌，头部品牌化发展的优势也尚未凸显。从某种角度来看，也反映了预制菜的需求量较前两年并无较快的增长。
*数据源于鲸参谋
因此，对于预制菜企业来说，一方面需要严格按照国家标准执行，把控产品品质；另一方面，深入了解消费者的高热度需求，从口味（辣、咸等）、形式（炒、汤等）、菜品（羊肉、牛肉等）方面进行产品升级与改良。
如鲸参谋统计的2023年度爆款预制菜商品，消费者对于“番茄”的需求量有所提升，如TOP1、TOP5、TOP7均是番茄相关预制菜品；其次，对于火锅类预制菜需求量更大，如TOP4和TOP8的羊蝎子火锅、TOP9的牛蹄筋火锅、TOP5的黄柿子火锅底料等。
*数据源于鲸参谋
2024年预制菜市场将会有何变化？我们会持续关注。
鲸参谋数据来源于公开渠道，数据获取与统计可能存在不完整，仅供参考。
如想要查看京东（淘宝/天猫）全品类的销售数据（行业/品牌/店铺/商品/监控），欢迎搜索“鲸参谋电商数据”，或者直接评论留言和私信（也可接口对接）~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a513353c3218523a468bdc547d49f284/" rel="bookmark">
			MySQL修炼手册14：用户权限管理：安全保障与数据隔离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 写在开头1 用户与权限的关系1.1 用户的创建与删除1.1.1 创建新用户1.1.2 批量创建用户1.1.3 安全删除用户 1.2 授予与撤销权限1.2.1 授予权限1.2.2 批量授予权限1.2.3 撤销权限 2 角色的应用2.1 创建与管理角色2.1.1 创建角色2.1.2 管理角色 2.2 将权限赋予角色2.2.1 将权限赋予角色2.2.2 用户与角色关联 2.3 示例演示2.3.1 创建角色和分配权限2.3.2 创建用户并关联角色 2.4 角色的优势与最佳实践 3 数据库层面的权限控制3.1 数据库级权限管理3.1.1 数据库创建与删除3.1.2 数据库用户权限3.1.3 安全性考虑与最佳实践 3.2 数据表级权限管理3.2.1 数据表的创建与删除3.2.2 数据表的权限设置3.2.3 视图与权限 写在最后 写在开头 欢迎来到MySQL修炼手册的第14篇，本篇将深入探讨MySQL中用户权限管理的重要性以及如何通过合理的权限控制实现安全保障与数据隔离。在数据库管理中，用户权限的设置至关重要，不仅可以有效保护数据的安全，还能够合理分配数据访问权限，确保数据库的正常运作。让我们一起深入了解用户、权限、角色以及数据库层面的权限控制。
1 用户与权限的关系 在MySQL数据库中，用户与权限的关系是确保数据库安全性和数据隔离的关键。让我们详细展开用户的创建与删除，以及授予与撤销权限这两个重要方面。
1.1 用户的创建与删除 1.1.1 创建新用户 在MySQL中，创建新用户涉及到用户名、主机以及密码的设置。以下是一个详细的创建新用户的例子：
-- 创建新用户 'new_user'，允许其从本地主机访问，并设置密码为 'password' CREATE USER 'new_user'@'localhost' IDENTIFIED BY 'password'; 这一步创建了一个名为 ‘new_user’ 的用户，@‘localhost’ 表示该用户只能从本地主机访问数据库。密码通过 IDENTIFIED BY 设置。密码的选择应考虑到安全性，可以使用强密码策略。
1.1.2 批量创建用户 在某些情况下，需要批量创建用户，可以使用 CREATE USER 语句的多值形式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a513353c3218523a468bdc547d49f284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6282d0e64899769dc631b643887360d/" rel="bookmark">
			C Primer Plus（第六版）13.11 编程练习 第12题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX 41
/*
13.11-12.txt
0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 5 2 0 0 0 0 0 0 0 0 0 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6282d0e64899769dc631b643887360d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c717e86f2d9cf40ac0eff143c7c108bf/" rel="bookmark">
			联想智能美颜（联想视觉）软件使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代社会，智能美颜软件已经成为了我们生活中不可或缺的一部分。联想作为一家知名的科技公司，也为我们带来了其智能美颜软件——联想视觉。这款软件以其强大的美颜功能和便捷的操作体验，成为了许多用户自拍、修图的首选工具。本文将为你详细介绍联想智能美颜（联想视觉）软件的使用说明，帮助你轻松拍出自然美感，展现最美的自己。无论你是自拍达人还是修图新手，都能在这里找到适合自己的美颜技巧。让我们一起探索联想视觉的魅力吧！
联想知识库https://iknow.lenovo.com.cn/detail/198410
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef07fa6be1d84c02be19eaa5fbf983e7/" rel="bookmark">
			ThinkPad 电脑 XP、Windows 7系统下右下角不显示无线图标如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于ThinkPad电脑用户来说，在XP和Windows 7系统下遇到右下角不显示无线图标的问题，可能会让人感到困扰。这不仅影响了网络的正常使用，还可能让人担心电脑是否存在其他问题。本文将为你提供解决这一问题的几种方法，帮助你快速找回无线图标，恢复正常的网络连接。无论你是XP还是Windows 7系统的用户，都可以通过这些方法解决这个问题。让我们一起来看看吧！
联想知识库https://iknow.lenovo.com.cn/detail/083000
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0f5ae5ee30cc44119c010eacc49715/" rel="bookmark">
			如何在BIOS设置集成显卡输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着电脑的普及，显卡作为电脑中的重要组件，其性能的好坏直接影响到我们的工作和娱乐体验。然而，在某些情况下，我们可能会遇到显卡输出设置不当的问题，导致显示效果不佳或者出现其他问题。这时，进入BIOS设置集成显卡输出就显得尤为重要。本文将通过具体的步骤和案例，为大家详细解析如何在BIOS中设置集成显卡输出，以解决显卡相关的问题，提升电脑的性能和显示效果。
联想知识库https://iknow.lenovo.com.cn/detail/145258
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/335646b44bc8c5b47a7dd81027bf2939/" rel="bookmark">
			理想架构的Doherty功率放大器理论与仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Doherty理论—理想架构的Doherty功率放大器理论与仿真 参考：
三路Doherty设计
01 射频基础知识–基础概念
ADS仿真工程文件链接：理想架构的Doherty功率放大器理论与仿真
目录 Doherty理论---理想架构的Doherty功率放大器理论与仿真0、Doherty架构的作用1、经典Doherty架构1.1、经典Doherty结构1.2、经典Doherty效率曲线1.3、经典Doherty的输出电压、电流1.4、经典Doherty的输出阻抗关系 2、经典Doherty架构的理论推导过程2.1、低功率状态2.2、高功率状态2.3、理论输出阻抗计算 0、Doherty架构的作用 Doherty功放是一种利用负载调制技术提高回退效率的功放，其应用背景是为了解决通信系统中调制信号峰均比越来越大，而传统放大器在功率回退点效率低的问题。
为了提高通讯系统的频谱利用率，为用户提供快速的数据传输和多媒体数据业务以及全球漫游功能，现在的通讯系统采用宽带的数字调制技术，如BPSK、QPSK和QAM等，其峰均比（PAPR）都较高。
峰均比是啥意思呢，就是峰值功率和平均功率的比值，比如下面这个OFDM的时域信号，由于信号高低不平，峰值功率和平均功率差异较大。假如峰值功率是40dbm，而平均功率是32.5dbm，那么这个信号的峰均比就是40-32.5=7.5dbm。
高峰均比对功率放大器的设计提出了更高的要求，我们都知道功放在饱和时效率较高，B类最高可到78.5%的效率。假设有一个B类功放饱和时输出功率40dbm，效率78.5%，那么如果使用PAPR是7.5dB的调制信号，为了同时保证峰值不失真，这个功放在大部分时间的输出功率就是32.5dBm，那么其在32.5dBm输出时的效率是多少呢？我们使用ADS仿真得到结果（仿真文件在最上方链接）：
由此可见，为了同时保证峰值和均值的不失真，功率放大器大部分时间都工作在回退状态，但是普通单管功放在回退状态下效率下降快，效率低，由此能耗大不实用。
Doherty技术、Cherix技术（Outphasing异相）、EER（envelope elimination and restoration）和包络跟踪技术ER都是为了解决这一问题。
其中Doherty技术在基站功放运用最广；EER和ER效率高，但是受制于对电源带宽的要求，往往运用在手机等小功率的功放中。
1、经典Doherty架构 1.1、经典Doherty结构 咋参考Switchmode RF and Microwave Power Amplifiers里面的图片，Z2的阻抗为Ropt（B类最佳基波阻抗），Z1是四分之一波长阻抗变换器，将Ropt/2的阻抗变换为50欧姆，因此其阻抗为(Ropt/2*50)^0.5欧姆。至于峰值功放前的四分之一波长线，那个是相位延迟的，因为载波功放那边有一个四分之一波长线了，为了让合路的相位一致，必须也要在峰值功放加上一个。
直接讲理论可能比较难，先在ADS中仿真一下：
1.2、经典Doherty效率曲线 对上面结构进行仿真，可以看到，在6dB回退的时候效率再次达到最高78.5%，在7.5dB回退的时候，效率高达65.3%，非常的yes了：
1.3、经典Doherty的输出电压、电流 观察峰值功放和载波功放的电压电流，由于是1：1等分的，在饱和时峰值功放和载波功放的输出功率相同，输出电压、电流也一致，如下所示：
1.4、经典Doherty的输出阻抗关系 观察峰值功放和载波功放的输出阻抗变化，由此可见峰值功放的输出阻抗从无穷大逐渐下降到Ropt，而载波功放的输出阻抗在峰值功放关闭时为2Ropt，在峰值功放打开后逐渐降为Ropt：
2、经典Doherty架构的理论推导过程 参考：应用于5G通信系统高效率射频功率放大器的研究
Doherty功放原理图如下，由功率分配器、工作模式为B类（或AB类）的载波功放、工作模式为C类的峰值功放以及功率合成网络组成，输出负载阻抗为Ropt/2（1.1的架构输出阻抗是50欧姆，因此多了四分之一波长微带线进行阻抗变换，把Ropt/2变换到50欧姆）
2.1、低功率状态 下图为Doherty功放在低功率工作状态的电路拓扑图，经功率分配器流入峰值功放的射频信号功率未能将其开启，仅载波功放启动工作（峰值功放不工作，那边是断开的）：
载波功放的负载阻抗为（ZL通过四分之一波长线进行变换，得到2Ropt）：
Z C = Z T Z L = 2 R o p t Z_{\mathrm{C}}=\frac{Z_{\mathrm{T}}}{Z_{\mathrm{L}}}=2R_{\mathrm{opt}} ZC​=ZL​ZT​​=2Ropt​
此时载波功放为高阻抗状态，电压提前饱和达到Vmax。为什么负载阻抗2Ropt会使得电压提前饱和呢？我初学时也考虑过这个问题，这是因为GAN晶体管实际上是压控电流源，在固定栅极输入情况下，其输出电流是恒定的，此时增加负载阻抗从Ropt到2Ropt，那么根据欧姆定律V=IR，R=2Ropt，那么I会在峰值电流一半的时候电压就饱和了， 1.3小节的仿真图像中也能看出这一点。
由于电流仅达到饱和值的一半，因此该未饱和功率值为：
P O B O − 2 R o p t = 1 2 I 1 ⋅ V 1 = 1 8 I m a x V d c = 1 4 P m a x P_{\mathrm{OBO}_{-}2R_{\mathrm{opt}}}=\frac{1}{2}I_{1}\cdot V_{1}=\frac{1}{8}I_{\mathrm{max}}V_{\mathrm{dc}}=\frac{1}{4}P_{\mathrm{max}} POBO−​2Ropt​​=21​I1​⋅V1​=81​Imax​Vdc​=41​Pmax​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/335646b44bc8c5b47a7dd81027bf2939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fbe776e028c851e64329729faf812a9/" rel="bookmark">
			ESLint格式化程序消失，怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESLint格式化程序消失，怎么解决 今天发现vscode的ESLint格式化程序出不来，格式化没效果，一开始以为是哪里同步了setting.json被改了，做了处理。查网上资料也没有相关的，自行测试。仅适用于原本有，目前没有的。不会安装使用的看其他文档。
消失原因 今天ESLint更新了，大概率是bug
解决方法 安装上一次版本即可解决问题
如果有用，请给我点赞收藏，我会很开心，谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2590fd10f29826cd2fd65b5345364009/" rel="bookmark">
			sudo 授权问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo 表示 “superuser do”，它允许已验证的用户以其他用户的身份来运行命令。其他用户可以是普通用户或者超级用户。然而，大部分时候我们用它来提权运行命令，以替代直接使用 root 用户的操作。
sudo 命令与安全策略配合使用，安全策略可以通过文件 /etc/sudoers 来配置。其安全策略具有高度可拓展性，支持插件扩展。默认情况下 /etc/sudoers 是不能被任何人直接编辑的，因为它的权限是 440，虽然也可以对其赋予写权限后再编辑，但推荐使用 visudo 命令编辑该文件。
sudo 命令的工作流程 使用sudo 命令时，sudo程序会读取和解析 /etc/sudoers 文件，查找调用sudo命令的用户（比如test用户）及其权限。然后提示调用该命令的用户（test用户）输入密码，或者也可以通过 NOPASSWD 标志来跳过密码验证。之后，sudo 创建一个子进程，调用 setuid() 来切换到目标用户（可能是root，也可能是其他用户）。最后，它会在上述子进程中执行参数给定的 shell 或命令。 sudo 命令授权配置 USER/GROUP HOST=(USER[:GROUP]) [NOPASSWD:] COMMANDSUSER/GROUP: 表示需要被授权的用户或者组（谁有权限调用sudo命令，比如test）；如果是组则需要以 % 开头HOST: 表示允许从哪些主机登录的用户可以运行 sudo 命令；ALL 表示允许从任何终端、机器访问(USER[:GROUP]): 表示使用 sudo 可切换的用户或者组（可以使用谁的权限，比如root），组可以不指定；ALL 表示可以切换到系统的所有用户NOPASSWD: 如果指定，则该用户或组（比如test）使用 sudo 时不必输入密码COMMANDS: 表示运行指定的命令；ALL 表示允许执行所有命令 # 允许 sudo 组执行所有命令 %sudo ALL=(ALL:ALL) ALL # 允许用户escape执行所有命令，且无需输入密码 escape ALL =(ALL) NOPASSWD: ALL # 仅允许用户escape执行 echo, ls 命令 escape ALL =(ALL) NOPASSWD: /bin/echo /bin/ls # 运行本机的用户escape执行关机命令 escape localhost=/sbin/shutdown -h now # 允许 users 用户组中的用户像 root 用户一样使用 mount、unmount、chrom 命令 %users ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom 配置 Defaults 选项 # 指定用户尝试输入密码的次数，默认值为3 Defaults passwd_tries=5 # 设置密码超时时间，默认为 5 分钟 Defaults passwd_timeout=2 默认 sudo 询问用户自己的密码，添加 targetpw 或 rootpw 配置可以让 sudo 询问 root 密码 Defaults targetpw # 指定自定义日志文件 Defaults logfile="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2590fd10f29826cd2fd65b5345364009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f406b0b964024d50132f0c92b9babeba/" rel="bookmark">
			EMNLP&#39;23 京东：深度语义召回中的超参自适应调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 李国趸 整理 | NewBeeNLP https://zhuanlan.zhihu.com/p/675751178
后台留言『交流』，加入 NewBee讨论组
大家好，这里是 NewBeeNLP。京东搞了一种在召回阶段简单的自适应调整温度系数和 margin 的方法。
参考论文：Adaptive Hyper-parameter Learning for Deep Semantic Retrieval
公司：京东
链接：https://aclanthology.org/2023.emnlp-industry.72.pdf
会议：EMNLP2023
省流版 京东搜索搞了一种在召回阶段简单的自适应调整温度系数和margin的方法，比WWW那篇论文更简单。主要看两个大盘指标：UV值（每个独立访客的收入）和UCVR（订单数/UV）和一个中间指标：过了相关性模块后参与排名阶段(prank)的item数量（笔者注：怀疑prank是粗排）。2023年的10天的线上AB实验显示，效果还是蛮好的，p值也比较低。
动机 召回或者说检索中，最常用的就是sampled softmax loss或者margin loss，其中利用margin和温度系数来去显式控制正负例之间的“分辨率“。
之前的工作都是手拍的超参，很明显，更合理的方式是针对不同query，不同user实现一个自适应的温度或者margin。最近也有一篇www论文（Adap-τ : Adaptively modulating embedding magnitude for recommendation）在探讨温度系数怎么自适应调整，但是作者认为该论文方法比较复杂，且在搜索系统中是不可用的。文中提到的原因是因为现实中query是不可知的，而不像推荐系统中user是给定的。
作者也通过一系列实验表明两种loss的超参对batch recall@k的结果是比较敏感的：
因此，作者就设计了一种更简单而且可以自适应调整温度系数和margin的方法，并且在京东线上AB实验上取得了收益。
双塔模型上常用的两个loss 双塔召回模型主要是通过负采样或batch内负样本进行训练。给定一个样本列表，其中包含一个正样本和n个负样本，即。目标是将负样本表征远离query并将正样本表征靠近query，即：
为了达到上述目标，有两种loss可以用来优化：
margin loss ：旨在通过固定的超参数margin来区分正负例，控制度量空间中的决策边界。
softmax loss ：softmax损失函数能够实现良好的训练稳定性，并与ranking metric相匹配。通常比其他方法表现更好，因此在检索中受到广泛关注。其中温度系数用于平滑训练数据的整体拟合分布。更小值意味模型完全适应监督信号并更专注难负例，反之亦然。
原文翻译，看看就好：上述损失函数取决于超参数，这在性能方面起着重要作用。具体实验将在下一节中讨论。不幸的是，传统方法在自适应选择超参数方面存在问题。此外，在个性化场景中，每对需要特定的边界和温度值，使得学习或选择适当的值更加具有挑战性。虽然其他领域，如推荐系统，已通过双层或统计学习解决了这个问题，但我们认为这些方法不适用于检索场景。检索场景涉及到来自在线系统的不同于推荐的输入查询，因为输入查询是丰富和不可知的。因此，需要一种无参数的方法来生成特定的值。为此，我们首先提出了一种通过内积计算值的启发式方法，然后提出了一种对称度量学习方法来缓解训练过程中的崩溃问题。
方法 在度量空间中，最难的负样本的位置非常接近正样本，而容易或随机的负样本则远离正样本。我们需要细分负样本。给定一对，如果是最难的负样本，则查询和正样本v的相似度应该更高，换句话说，边缘损失应该更小。同样，对于最难的负样本，温度在softmax损失中也应该更小。
所以，给定一个pair对，作者针对这个pair对定义了一个动态的，即：
其实呢，这个动态，是指的根据正负item之间的内积来动态决定，依然需要一个全局的参数和。这两个参数可以是trainable的。
虽然启发式方法很简单，但作者觉得它在训练过程中会遭受模型崩溃的问题，导致所有item在度量空间中聚集在一起。从梯度的角度来看，可以知道自适应的margin将影响正负item的更新方向。
为了避免表征崩塌，最简单的方法就是停梯度：
所以最后的loss就变成：
除此以外，作者还觉得，糟糕的初始化方式还是有崩溃风险，比如。这种情况下，q和v的距离会大于v和的距离。为了避免这种情况，搞了一个对称的loss来约束，即将v作为锚点，q作为正样本项，旨在将负样本项远离正样本项:
总的loss就是：
softmax loss也是一样：
效果 batch recall@k作为指标
列一下牛逼的基线：
DSSM：经典的不说了，Learning deep structured semantic models for web search using clickthrough data
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f406b0b964024d50132f0c92b9babeba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e0b6551a48b09c6926b0d8f0fd738c/" rel="bookmark">
			我的文档不见了怎么恢复？3个方法快速恢复！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我刚刚在电脑上保存了一些文档，但不知道为什么我的文档突然就不见了，有什么方法可以让我快速恢复这些文档吗？” 很多用户在使用电脑时都需要用到文档，这大大提升了人们的工作效率。如果文档丢失了怎么办？我的文档不见了怎么恢复？实用的文件恢复方法已经总结好啦，有需要的用户可以继续往下看了！
方法一：从备份中恢复文档 我的文档找不到了怎么办？如果你有备份的习惯，那么恢复文档就变得相对简单。常见的备份方式包括外部硬盘、云存储和外部存储设备。
第1步：将备份设备连接到电脑；
第2步：在电脑上打开文件管理器，找到备份设备，并找到存【我的文档】文件的文件夹；
第3步：将所需的文件或文件夹从备份中复制到剪贴板；
第4步：将复制的文件或文件夹粘贴到电脑中。
方法二：使用专业软件恢复文档 有些很重要的文档如果丢失，会让用户感觉很不安。我的文档不见了怎么恢复？比较建议大家尝试使用专业的软件来对数据进行恢复操作。数 据 蛙 恢 复 专 家 作为一款专业的软件，成功帮助很多用户找回了重要的数据。
并且软件支持多种类型数据的扫描和恢复，同时也支持免费试用，如果需要使用软件，可以尝试下载软件后按下方步骤进行操作。
操作环境： 演示机型：华硕无畏1414s 系统版本：Windows 10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 第1步：安装软件后，先使用【免费试用】功能，进入软件，先勾选【文档】（新用户首次使用软件建议全选），并勾选上文档删除之前所在的磁盘，点击【扫描】；
第2步：快速扫描完成，用户可以先对初次扫描到的结果进行查看，如果没有找到需要恢复的文件，可以点击【深度扫描】以查看更多的数据；
第3步：等待深度扫描完成，建议用户直接在【筛选器】中对文件定位，找到需要恢复的文件后，将其【导出】。
方法三：借助回收站恢复文档 电脑文件凭空消失了怎么恢复？如果想快速找回文件，回收站是个不错的选择。通过回收站，用户有机会快速找回文件。
第1步：在电脑的桌面或操作系统界面上找到回收站的图标，并双击打开；
第2步：回收站会显示所有被删除的文件和文件夹的列表，选中要恢复的文件或文件夹，然后右键单击并选择【还原】。
电脑文档不见了有时候会给用户带来各种各样的麻烦。我的文档不见了怎么恢复？上文的几个方法都是比较有效的。如果需要找回丢失的文档，建议根据个人的实际情况，在上文中选择合适的方法完成文档恢复。当然！在平时使用文档时，建议大家及时对比较重要的文件做好备份！
往期推荐：
电脑文件丢失怎么恢复？这4个方法不可错过！https://blog.csdn.net/datarecover/article/details/135742990?spm=1001.2014.3001.5501
Excel乱码？教你3个简单解决方法！https://blog.csdn.net/datarecover/article/details/135741875?spm=1001.2014.3001.5501
电脑本地连接不见了怎么恢复？5个方法轻松解决问题！https://blog.csdn.net/datarecover/article/details/135642505?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92ddb1c245c4e2fffcf5cb17fc92161/" rel="bookmark">
			js判断一个数所在的区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景：在图表上使用警戒线时，后端返回来的x轴数据，与警戒线值不一致，即警戒线与x轴的值一致，才会在x轴上显示一条竖线。这里后端返回来的警戒线值是数值不是区间，所以要自己去找值所在在的区间。
上代码：
data:{ return { chart0: { title: { text: '', textStyle: { fontSize: 12, fontWeight: '500', color: '#000000', fonfontFamily: 'Microsoft YaHei', }, backgroundColor: 'transparent', show: true, top: '10', left: 'center', }, grid: { bottom: 20, }, lengend: { show: true, // icon: "pin", itemWidth: 10, // 图例标记的图形宽度。 itemHeight: 10, // 图例标记的图形高度。 top: '92%', data: [ ], }, data: [ { name: '误差统计与分布', type: 'line', data: [], smooth: true, // true 为平滑曲线，false为直线 symbolSize: 0, // 圆圈宽度 // color: '#36c1a8', lineStyle: { color: '#53efd7', // 设置线的颜色为红色 }, itemStyle: { normal: { color: '#4cedd4', }, }, }, { name: '分布区间', // data: [], type: 'line', markLine: { symbol: 'none', data: [ { xAxis: '', }, ], label: { position: 'end', // 将警示值放在哪个位置，三个值“start”,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92ddb1c245c4e2fffcf5cb17fc92161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33aff04a0800378dbf5f01ed8e5750cf/" rel="bookmark">
			阿里云优惠券领取入口及使用方法，赶快！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云优惠代金券领取入口，阿里云服务器优惠代金券、域名代金券，在领券中心可以领取当前最新可用的满减代金券，阿里云百科aliyunbaike.com分享阿里云服务器代金券、领券中心、域名代金券领取、代金券查询及使用方法：
阿里云优惠券领取入口 打开阿里云活动中心：aliyunbaike.com/go/activity 打开后，可以看到“领券中心”，如下图：
阿里云领取中心
在领券中心，可以领取当前最新有效可用的代金券。这个领券中心会自动汇总阿里云当前有效的代金券，代金券有云服务器代金券、对象存储COS代金券、云数据库代金券等，以及企业上云补贴，也会在这个页面显示，无脑领取即可。
域名代金券 阿里云com域名和cn域名注册可以领取代金券，com域名68元代金券和cn域名26.2元代金券，如下图：
阿里云域名代金券
领取链接：aliyunbaike.com/go/com
目前阿里云域名注册代金券已经下架了，目前只有优惠口令和批量优惠。
云服务器优惠活动大全 官方精准报价：https://t.aliyun.com/U/bLynLC免费试用：aliyunbaike.com/go/free学生服务器：aliyunbaike.com/go/student云服务器精选特惠：aliyunbaike.com/go/activity_selection爆款特惠：aliyunbaike.com/go/bestoffer活动大全：aliyunbaike.com/go/activity 以上是阿里云服务器网分享的阿里云优惠代金券领取入口、域名代金券领取以及云服务器优惠活动大全。
阿里云代金券查看及使用方法 代金券领取后在哪查看？阿里云代金券查询管理地址：阿里云用户中心--卡券管理--代金券管理
阿里云代金券管理
查询地址：阿里云代金券管理一键查询链接
代金券使用方法 阿里云代金券领取后，使用很简单，只需要一步步提交订单，在支付页面会有代金券选项，如下图：
阿里云代金券使用方法
如上图所示，正常流程提交订单，在支付页面会有“代金券”模块，选择阿里云账号下的代金券，然后点支付即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca2bae0da55e014411f5bcc4f2301dc/" rel="bookmark">
			C语言中实现顺序表的插入、删除和更新操作（附带源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中，顺序表是一种线性表的存储结构，可以通过数组来实现。以下是顺序表的插入、删除和更新操作的基本示例：
#include &lt;stdio.h&gt; #define MAX_SIZE 100 // 定义顺序表结构 typedef struct { int data[MAX_SIZE]; int length; } SeqList; // 插入操作 int insert(SeqList *list, int position, int value) { // 判断插入位置是否合法 if (position &lt; 1 || position &gt; list-&gt;length + 1) { printf("插入位置不合法\n"); return 0; // 插入失败 } // 判断顺序表是否已满 if (list-&gt;length &gt;= MAX_SIZE) { printf("顺序表已满，无法插入\n"); return 0; // 插入失败 } // 将插入位置之后的元素依次后移 for (int i = list-&gt;length; i &gt;= position; i--) { list-&gt;data[i] = list-&gt;data[i - 1]; } // 插入新元素 list-&gt;data[position - 1] = value; // 长度加1 list-&gt;length++; return 1; // 插入成功 } int main() { SeqList myList = {{1, 2, 3, 4, 5}, 5}; // 在第3个位置插入元素6 insert(&amp;myList, 3, 6); // 打印插入后的顺序表 for (int i = 0; i &lt; myList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bca2bae0da55e014411f5bcc4f2301dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5430375d1b493c0d5fd4073756f3c18/" rel="bookmark">
			企业用户怎么领取阿里云优惠券?在领券中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业用户怎么领取阿里云优惠券?在领券中心可以领取企业专享优惠券。阿里云优惠代金券领取入口，阿里云服务器优惠代金券、域名代金券，在领券中心可以领取当前最新可用的满减代金券，阿里云百科aliyunbaike.com分享阿里云服务器代金券、领券中心、域名代金券领取、代金券查询及使用方法：
阿里云优惠券领取入口 打开阿里云活动中心 aliyunbaike.com/go/activity 打开后，可以看到“领券中心”，如下图：
阿里云领取中心
在领券中心，可以领取当前最新有效可用的代金券。这个领券中心会自动汇总阿里云当前有效的代金券，代金券有云服务器代金券、对象存储COS代金券、云数据库代金券等，以及企业上云补贴，也会在这个页面显示，无脑领取即可。
域名代金券 阿里云com域名和cn域名注册可以领取代金券，com域名68元代金券和cn域名26.2元代金券，如下图：
阿里云域名代金券
领取链接：aliyunbaike.com/go/com
目前阿里云域名注册代金券已经下架了，目前只有优惠口令和批量优惠。
云服务器优惠活动大全 官方精准报价：https://t.aliyun.com/U/bLynLC免费试用：aliyunbaike.com/go/free学生服务器：aliyunbaike.com/go/student云服务器精选特惠：aliyunbaike.com/go/activity_selection爆款特惠：aliyunbaike.com/go/bestoffer活动大全：aliyunbaike.com/go/activity 以上是阿里云服务器网分享的阿里云优惠代金券领取入口、域名代金券领取以及云服务器优惠活动大全。
阿里云代金券查看及使用方法 代金券领取后在哪查看？阿里云代金券查询管理地址：阿里云用户中心--卡券管理--代金券管理
阿里云代金券管理
查询地址：阿里云代金券管理一键查询链接
代金券使用方法 阿里云代金券领取后，使用很简单，只需要一步步提交订单，在支付页面会有代金券选项，如下图：
阿里云代金券使用方法
如上图所示，正常流程提交订单，在支付页面会有“代金券”模块，选择阿里云账号下的代金券，然后点支付即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bea398ce12a3f7707331728d6ec0b70/" rel="bookmark">
			Linux中解决普通用户无法进行sudo授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般未设置过的普通用户无法进行sudo提权。
因此，我们需要去在/etc/sudoers路径中去增加普通用户。
注意：该操作必须在root用户中去实现。
首先：输入指令vim /etc/sudoers
然后，找到
这是因为我已经添加过一个普通用户，一般是只有root。
这时候你就可以复制（即命令模式下yy） root ALL=(ALL) ALL ，然后复制到光标为止的下一行（即命令模式下p），把root改为你需要sudo提权的用户即可。
最后，你只需要shift+；（即：）进入底行模式，输入wq！即可保存退出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52aec1ccb66621a8c185bec941bbe518/" rel="bookmark">
			阿里云优惠券官网领取地址和使用教程分享，2024最新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云优惠代金券领取入口，阿里云服务器优惠代金券、域名代金券，在领券中心可以领取当前最新可用的满减代金券，阿里云百科aliyunbaike.com分享阿里云服务器代金券、领券中心、域名代金券领取、代金券查询及使用方法：
阿里云优惠券领取入口 打开阿里云活动中心：aliyunbaike.com/go/activity 打开后，可以看到“领券中心”，如下图：
阿里云领取中心
在领券中心，可以领取当前最新有效可用的代金券。这个领券中心会自动汇总阿里云当前有效的代金券，代金券有云服务器代金券、对象存储COS代金券、云数据库代金券等，以及企业上云补贴，也会在这个页面显示，无脑领取即可。
域名代金券 阿里云com域名和cn域名注册可以领取代金券，com域名68元代金券和cn域名26.2元代金券，如下图：
阿里云域名代金券
领取链接：aliyunbaike.com/go/com
目前阿里云域名注册代金券已经下架了，目前只有优惠口令和批量优惠。
云服务器优惠活动大全 官方精准报价：https://t.aliyun.com/U/bLynLC免费试用：aliyunbaike.com/go/free学生服务器：aliyunbaike.com/go/student云服务器精选特惠：aliyunbaike.com/go/activity_selection爆款特惠：aliyunbaike.com/go/bestoffer活动大全：aliyunbaike.com/go/activity 以上是阿里云服务器网分享的阿里云优惠代金券领取入口、域名代金券领取以及云服务器优惠活动大全。
阿里云代金券查看及使用方法 代金券领取后在哪查看？阿里云代金券查询管理地址：阿里云用户中心--卡券管理--代金券管理
阿里云代金券管理
查询地址：阿里云代金券管理一键查询链接
代金券使用方法 阿里云代金券领取后，使用很简单，只需要一步步提交订单，在支付页面会有代金券选项，如下图：
阿里云代金券使用方法
如上图所示，正常流程提交订单，在支付页面会有“代金券”模块，选择阿里云账号下的代金券，然后点支付即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ffd11410cd7d2b373aaa22bd204c6c/" rel="bookmark">
			centos安装：node.js、npm及pm2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型，让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。
NPM的全称是Node Package Manager，是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。
PM2 是开源的基于 Nodejs 的应用进程管理器,包括守护进程,监控,日志的一整套完整的功能 PM2 是一个带有负载均衡功能的 Node 应用进程管理器。
本文章中，我将介绍centos下node.js、npm及pm2的安装（含指定版本安装），并附带安装坑点。
下载与安装 1、下载node.js版本 Node.js — Download
你可以通过上面的官网进行下载当前最新的稳定版本，如下图红框所示
当然，你也可以使用wget指定目标版本进行下载
wget https://nodejs.org/dist/v20.11.0/node-v20.11.0-linux-x64.tar.xz 甚至，你可以使用yum直接解决，这样也省去了安装步骤（新手图方便可以这样弄，但这里不推荐）
sudo yum install epel-release sudo yum install nodejs 2、安装node.js及npm # 我这里将其安装在了/usr/local里，所以这里的路径你可能需要变更 cd /usr/local # 解压及换名字 tar -xvf node-v20.11.0-linux-x64.tar.xz mv node-v20.11.0-linux-x64 nodejs # 建立软连接，变为全局变量 ln -s /usr/local/nodejs/bin/npm /usr/local/bin/ ln -s /usr/local/nodejs/bin/node /usr/local/bin/ # 测试一下node和npm环境变量是否正常 node -v npm -v 3、安装pm2 pm2使用npm一键下载安装，所以使用一条指令就行了
# 默认最高版本安装 # 这条命令会全局地（-g标志）通过npm（node package manager）下载并且自动完成pm2 的配置与部署。 npm install pm2 -g # 指定pm2版本安装 # npm install pm2@版本号 -g 坑点介绍和解决
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ffd11410cd7d2b373aaa22bd204c6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0814702326d57b507beffda2147650/" rel="bookmark">
			[BUG] Authentication Error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 给服务器安装了一个todesk，但是远程一直就是，点击用户，进入输入密码界面，还没等输入就自动返回了
解决 服务器是无桌面版本，或者桌面程序死掉了，重新安装就好
sudo apt install xorg
sudo apt install kubuntu-desktop
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb18b5c3705dd13358fa44a2c1c573ed/" rel="bookmark">
			Java实现考研专业课程管理系统 JAVA&#43;Vue&#43;SpringBoot&#43;MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 考研高校模块2.3 高校教师管理模块2.4 考研专业模块2.5 考研政策模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 考研高校表3.2.2 高校教师表3.2.3 考研专业表3.2.4 考研政策表 四、系统展示五、核心代码5.1 查询考研课程5.2 新增考研专业5.3 新增考研政策5.4 查询考研学校5.5 新增高校教师 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL 的考研专业课程管理系统，包含了考研课程、考研专业、考研注册、考研院校和高校教师模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，考研专业课程管理系统基于角色的访问控制，给学生、高校管理员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 为了能让开发出来的考研专业课程管理系统真正投入使用，所以需要对系统的需求加以分析设计，以下分别对功能性需求和可行性两方面分别对考研专业课程管理系统进行需求分析。
本文设计的考研专业课程管理系统的包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了考研高校模块、高校教师管理模块、考研专业模块、考研政策模块这四大模块，用于存放系统的核心业务逻辑。
2.1 数据中心模块 数据中心模块包含了对考研专业课程管理系统的基础模块，比如管理谁可以登录这套系统，记录这些人登录系统做了什么，不同的人拥有不同权限的管理。
2.2 考研高校模块 考研高校模块用于对考研高校的数据进行管理，其中包括高校名称、所属省份、介绍、办学性质、高校等级、师资力量、学科建设、学术科研等，可以通过此模块对考研高校数据进行添加、编辑更新、删除、查询操作。
2.3 高校教师管理模块 高校教师管理模块是对高校的教师信息进行管理，高校教师是高校教学的参与者，高校教师字段包括教师姓名、性别、教师介绍、联系电话、学历、毕业院校、所属高校、备注等，管理员可以新增高校教师的数据，学生可以查询管理员发布的高校教师信息。
2.4 考研专业模块 考研专业模块是为了管理各大高校开设的考研专业，有了考研高校后后，学生可以查询每个高校的考研专业，其中考研专业的字段包括专业名称、专业介绍、就业去向、所属高校ID、所属高校、创建人、创建时间、备注等，管理员可以增加、删除、编辑和条件查询考研专业，学生可以查询指定高校开设的考研专业。
2.5 考研政策模块 考研政策模块是维护关于考研的相关政策，如奖学金补助、考研政策图解等。考研政策模块是为了帮助考研学生备考，避免错过各类优待政策，其中考研政策包括政策名称、政策内容、适用群体、状态、排序值、发布日期、创建人、创建时间等，管理员可以增加、删除、编辑和条件查询考研政策内容，学生可以按需查询适配的考研政策。
三、系统设计 3.1 用例设计 UML是面向对象的图形化建模语言，具有表示容易，定义友好，适用范畴广泛，功能强大。用例图是用例模型的一种，需求分析人员可采用用例图表示用户操作行为。考研专业课程管理系统的用例图设计主要包括学生用户用例图设计、考研管理员用例设计。
3.2 数据库设计 3.2.1 考研高校表 3.2.2 高校教师表 3.2.3 考研专业表 3.2.4 考研政策表 四、系统展示 五、核心代码 5.1 查询考研课程 @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb18b5c3705dd13358fa44a2c1c573ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910fb6e4bdb8e4b679840bb8bf9d9377/" rel="bookmark">
			Linux中的编辑器vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. vim的基本概念
2.vim的基本操作
3. vim正常模式命令集
1. vim的基本概念 vim的三种模式(其实有好多模式，掌握这3种即可进行基础学习),分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：
1.正常/普通/命令模式(Normal mode)
控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode
2.插入模式(Insert mode)
只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。
3.末行模式(last line mode)
文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，shift+； 即可进入该模式。
若要查看你的所有模式：打开vim，底行模式直接输入：
help vim-modes
2.vim的基本操作 1.进入vim,在系统提示符号输入vim及文件名称后，就进入vim全屏幕编辑画面:
指令：vim test.c
不过有一点要特别注意，就是你进入vim之后，是处于[正常模式]，你要切换到[插入模式]才能够输入文字。
2.[正常模式]切换至[插入模式]
输入a，i，o都可进入
3.[插入模式]切换至[正常模式]
目前处于[插入模式]，就只能一直输入文字，如果发现输错了字,想用光标键往回移动，将该字删除，可以先按一下「ESC」键转到[正常模式]再删除文字。当然，也可以直接删除。
4.[正常模式]切换至[末行模式]
「shift + ；」, 其实就是输入「：」
5.退出vim及保存文件,在[正常模式]下，按一下「:」冒号键进入「Last line mode」,例如:
1. w （保存当前文件）
2. wq (输入「wq」,存盘并退出vim)
3. q! (输入q!,不存盘强制退出vim)
3. vim正常模式命令集 插入模式：
1.按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；
2.按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；
3.按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。
命令模式（英文模式下输入指令）（常用指令）：
n+yy：复制当前行 n：复制连续的n行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/910fb6e4bdb8e4b679840bb8bf9d9377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f85ad8de986c6528cc8066b94c6044b/" rel="bookmark">
			基于easyswoole开发的聊天室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于easyswoole开发的聊天室 ####基础运行环境
- PHP 版本 7.1.33
- Swoole 拓展版本 4.5.3
- pcntl 拓展的任意版本
- Centos 7
- Composer 作为依赖管理工具
安装 - 首先准备两个端口8001 8088 注意防火墙开发端口 - 克隆代码 `https://gitee.com/ormcc/chat.git` 将项目克隆到本地 - 执行 `composer update` 此步骤可以省略已生成vendor - 数据库 chat数据库，将chat.sql数据导入数据库 - 配置文件 `dev.php`，配置MYSQL，REDIS配置,修改MAIN_SERVER/PORT端口 - Nginx代理，配置文件nginx.conf，包括https配置 location / { root /usr/local/www/chat/; proxy_http_version 1.1; proxy_set_header Connection "keep-alive"; proxy_set_header X-Real-IP $remote_addr; if (!-e $request_filename) { proxy_pass http://127.0.0.1:8088; } if (!-f $request_filename) { proxy_pass http://127.0.0.1:8088; } } ``` - 修改`App\HttpController\index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f85ad8de986c6528cc8066b94c6044b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011453a3d5ea885daabc461e0e8222b2/" rel="bookmark">
			使用Flink的所有pom文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink中所有的pom文件中的索引 &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;untitled&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;flink.version&gt;1.14.0&lt;/flink.version&gt; &lt;scala.version&gt;2.12&lt;/scala.version&gt; &lt;hive.version&gt;3.1.2&lt;/hive.version&gt; &lt;mysqlconnect.version&gt;5.1.47&lt;/mysqlconnect.version&gt; &lt;clickhouse.version&gt;0.3.2&lt;/clickhouse.version&gt; &lt;hdfs.version&gt;3.1.3&lt;/hdfs.version&gt; &lt;spark.version&gt;3.1.1&lt;/spark.version&gt; &lt;hbase.version&gt;2.2.3&lt;/hbase.version&gt; &lt;kafka.version&gt;2.4.1&lt;/kafka.version&gt; &lt;lang3.version&gt;3.9&lt;/lang3.version&gt; &lt;flink-connector-redis.verion&gt;1.1.5&lt;/flink-connector-redis.verion&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;${lang3.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接器 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysqlconnect.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spark处理离线 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_${scala.version}&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_${scala.version}&lt;/artifactId&gt; &lt;version&gt;${spark.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;27.0-jre&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt;--&gt; &lt;!-- &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;hive-exec&lt;/artifactId&gt;--&gt; &lt;!-- &lt;version&gt;2.3.4&lt;/version&gt;--&gt; &lt;!-- &lt;/dependency&gt;--&gt; &lt;!-- kafka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011453a3d5ea885daabc461e0e8222b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177aafed99a9d1fb6062ba714f93ff1e/" rel="bookmark">
			Flink项目（看了就会）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink基本项目WordCount 一， Flink批处理WordCount 使用maven先配置好pom文件
然后在项目目录上创建input包
然后在input包中创建word文件word.txt
并在文件中添加一下内容
hello woed hello linux hello mysql 然后在src的运行目录下创建一个目录，然后创建scala文件命名为BatcWordCount
具体代码为
package flink import org.apache.flink.api.scala.{ExecutionEnvironment, createTypeInformation} object BatchWordCount { def main(args: Array[String]): Unit = { // 1 创建一个执行环境 val env=ExecutionEnvironment.getExecutionEnvironment // 2 读取文本文件数据 val lineDataSet = env.readTextFile("input/word.txt") // 3 对数据集进行转换处理 val wordAndOne = lineDataSet.flatMap( _.split(" ") ).map(word =&gt; (word , 1)) // 4 按照单词进行分组 val wordAndOneGroup = wordAndOne.groupBy(0) // 5 对分组数据进行sum聚合统计 val sum = wordAndOneGroup.sum(1) //6 打印输出 sum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177aafed99a9d1fb6062ba714f93ff1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1fab481ac2f0532403e859deb15d04/" rel="bookmark">
			电脑摄像头设置在哪里？这3种打开方式要记好！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我需要开一个视频会议，因此可能需要用到电脑的摄像头。但是我不知道我电脑的摄像头设置在哪里，有没有朋友可以告诉我一下呀？” 在日常办公时，我们可能经常要用到电脑摄像头。这不仅为用户提供了实时沟通的机会，还帮助人们更好的实现了远程社交。如果遇到电脑摄像头打不开的情况怎么办呢？
电脑摄像头设置在哪里？别着急！下文都将一一为大家解答！希望能对大家有所帮助！
电脑摄像头无法打开的常见原因 在使用电脑时，有些用户可能会遇到笔记本前置摄像头打不开的情况，这是由于你的电脑出现了各种问题，以下是较常见的原因。
1.驱动程序问题：摄像头驱动程序可能未正确安装或过时。这可能导致摄像头无法正常工作或被操作系统识别；
2.硬件问题：摄像头可能存在物理损坏、连接不良或与电脑不兼容等问题；
3.权限问题：摄像头可能受到操作系统或应用程序的访问限制，导致无法正常打开；
4.防火墙或安全软件阻止：某些安全软件或防火墙可能会阻止摄像头正常工作；
5.应用程序问题：使用的应用程序可能存在兼容性问题或错误，导致无法正常打开摄像头。
如何打开电脑摄像头 在日常的工作中，很多用户可能都需要用到电脑摄像头。电脑摄像头设置在哪里呢？可以通过以下方法来打开电脑摄像头。
方法一：通过设置打开摄像头 在Windows系统中，电脑摄像头怎么打开呢？一般在电脑的设置里可以找到。用户可以通过设置来确保摄像头正常运行。
步骤1：点击电脑左下角的【开始】菜单；
步骤2：点击【隐私】选项，找到【相机】或【摄像头】，确已开启对应应用程序的访问权限。
方法二：通过资源管理器打开摄像头 如何打开电脑摄像头？很多用户或许会选择通过资源管理器来打开电脑摄像头。
步骤1：进入电脑的文件资源管理器窗口，找到【此电脑】；
步骤2：单击右键选择【属性】，在弹出的窗口中选择【设备管理器】，查看是否有【照相机】下是否有图像设备，若有，则已经成功打开了摄像头。
方法三：直接在软件中打开摄像头 在使用摄像头时，很多用户都会直接使用某个软件，以方便视频和对话。那么，如何在电脑上开启摄像头呢？直接在软件中打开摄像头是更为方便的。
步骤1：点击进入软件中，选择要进行视频的好友或群组；
步骤2：点击【视频】或【摄像头】图标，即可进入摄像头中。
当遇到摄像头无法打开的问题时，了解常见原因并采取相应的解决措施是关键。电脑摄像头设置在哪里？相信通过上文的介绍大家已经知道了。如果需要使用摄像头，现在就可以尝试使用啦！
往期推荐：
磁盘初始化会丢失文件吗？答案揭晓！https://blog.csdn.net/datarecover/article/details/135740646?spm=1001.2014.3001.5501
电脑文件丢失怎么恢复？这4个方法不可错过！https://blog.csdn.net/datarecover/article/details/135742990?spm=1001.2014.3001.5501
Excel乱码？教你3个简单解决方法！https://blog.csdn.net/datarecover/article/details/135741875?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/373572ae30aaa65df87342ae98048962/" rel="bookmark">
			本地服务器能下载文件，但是服务器不能下载的解决方法（IIS服务器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作的时候遇到过一个问题，就是本地可以正常的下载存放在文件夹的文件，但是IIS服务器却不可以，点击下载按钮直接报404错误，找不到文件。
后面设置了一下，原来是服务器配置的问题。
首先点击IIS管理员，点进去看IIS的配置，里面有个MIME的按钮，点进去即可配置文件类型即可。
百度信息
什么是MIME类型：
MIME类型是IIS的插件统称，实际上IIS默认支持很多插件，但是需要一个媒介去开启，所以有了MIME，不管是IIS6还是II7又或者你开通了虚拟主机，一般虚拟主机的控制面板都有MIME类型添加，例如空间不支持SHTML我们只需要在MIME上添加一个.SHTML的后缀，然后添加类型：text/html *.htm *.html *.shtml -Dateien便可以支持SHTML的后缀文件，不然打开SHTML的文件是提示找不到该文件的，添加后，可以默认打开该后缀的文件。
也就是说，你配置什么信息，网站就能打开什么内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85accb784c9b243e496b5eaa9318f59c/" rel="bookmark">
			开发GPT的智能客服应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发基于GPT的智能客服应用程序涉及到创建一个能够理解用户输入并提供有用响应的系统。以下是开发智能客服应用程序的一般步骤，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1.明确目标和用例： 定义您的智能客服应用程序的目标和主要用例。确定您希望应用程序能够处理的类型的查询和问题。
2.选择GPT模型： 选择适合您应用的GPT模型。考虑模型的性能、预训练质量和可用的计算资源。
3.获取GPT API访问： 如果您选择使用GPT API，注册并获取相应的API密钥。了解API的使用方式和限制。
4.设计用户界面： 创建用户友好的界面，用户可以通过该界面与智能客服系统进行交互。这可以是网页应用、移动应用或其他形式的用户界面。
5.用户身份验证： 如果有必要，实施用户身份验证机制，以确保只有授权用户可以访问客服服务。
6.集成GPT API： 将GPT API集成到您的应用程序中。处理用户输入，调用GPT API，并将生成的文本作为响应提供给用户。
7.处理特定领域问题： 如果您的智能客服应用程序在特定领域提供服务（例如金融、医疗等），确保系统能够处理该领域的特殊问题和术语。
8.对话管理： 开发对话管理系统，以便跟踪和理解多轮对话。确保上下文的正确传递，使对话更自然流畅。
9.监控和分析： 实施监控机制以跟踪系统的性能，分析用户输入和模型生成的响应。这有助于改进系统和提供更好的服务。
10.反馈机制： 提供用户反馈机制，使用户能够评估系统的响应，并提供修正或额外的信息。
11.安全性和合规性： 实施安全性措施，确保用户数据的隐私和安全。遵循数据保护法规和合规性要求。
12.测试和优化： 在不同的场景和用户情境下进行全面的测试，优化系统以提供更好的性能和用户体验。
13.部署和发布： 将应用程序部署到生产环境，并发布给用户。确保应用程序的稳定性和可用性。
14.维护和更新： 定期维护应用程序，处理用户反馈，并根据需要更新系统以适应新的问题和场景。
注意，开发智能客服应用程序时，要特别注意用户数据的隐私和安全性，以及确保系统提供准确、有用的响应。此外，对于敏感领域的应用，可能需要遵循特定行业的法规和标准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc363285f97dec98487e9269e036957/" rel="bookmark">
			因作者遭受恶意攻击，知名安卓框架宣布停更
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构师大咖 架构师大咖，打造有价值的架构师交流平台。分享架构师干货、教程、课程、资讯。架构师大咖，每日推送。
公众号
该公众号已被封禁
Android 平台 Xposed Framework 的替代实现版本 LSPosed 宣布停止维护，目前 LSPosed 的 GitHub 仓库已经设置为只读状态。
LSPosed 是一个 Magisk 模块，尝试提供一个 ART hooking 框架，该框架提供与 OG Xposed 一致的 API，其利用 LSPlant hooking 框架。
https://github.com/LSPosed/LSPosed
对于停止开发的原因，开发者在其订阅频道中表示停止维护的主要原因是出现许多谣言、诽谤、种族主义和咒骂等。同时开发者也受到 Magisk 社区的一些咒骂，因此开发者决定休息，停止开发和维护。
Python入门到精通 Python入门到精通：人生苦短，我用Python！Python每日推送、Python教程、Python资料、Python视频、Python项目、Python学习等。
公众号
该公众号已被封禁
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5342e947bf5c1256f2c3b3480a06572/" rel="bookmark">
			ES7.6先分组，在求多个字段的sum和count
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public void statByUserIdByDay(String userId){ try { SearchRequest searchRequest = new SearchRequest("article_info"); SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().size(0); searchSourceBuilder.query(QueryBuilders.termQuery("user_id", userId)); DateHistogramAggregationBuilder dateAggregation = AggregationBuilders .dateHistogram("agg_pubtime") .field("pubtime") .fixedInterval(DateHistogramInterval.DAY) .format("yyyy-MM-dd") .minDocCount(0); SumAggregationBuilder likesAggregation = AggregationBuilders.sum("likes_sum").field("like_count"); SumAggregationBuilder retweetsAggregation = AggregationBuilders.sum("rtt_sum").field("rtt_count"); SumAggregationBuilder commentsAggregation = AggregationBuilders.sum("comments_sum").field("comment_count"); ValueCountAggregationBuilder countAggregation = AggregationBuilders.count("count").field("user_id"); dateAggregation.subAggregation(likesAggregation) .subAggregation(retweetsAggregation) .subAggregation(commentsAggregation) .subAggregation(countAggregation); searchSourceBuilder.aggregation(dateAggregation); searchRequest.source(searchSourceBuilder); SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT); Histogram agg_pubtime = searchResponse.getAggregations().get("agg_pubtime"); for (Histogram.Bucket bucket : agg_pubtime.getBuckets()) { String pubtime = bucket.getKeyAsString(); Aggregations aggregations = bucket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5342e947bf5c1256f2c3b3480a06572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d59214d64850f2d6cacc5bfde7416b7/" rel="bookmark">
			【计算机毕业设计】校园兼职管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当下，正处于信息化的时代，许多行业顺应时代的变化，结合使用计算机技术向数字化、信息化建设迈进。传统的校园兼职信息管理模式，采用人工登记的方式保存相关数据，这种以人力为主的管理模式已然落后。本人结合使用主流的程序开发技术，设计了一款基于SSM的校园兼职管理系统，可以较大地减少人力、财力的损耗，方便相关人员及时更新和保存信息。本系统主要使用B/S开发模式，在idea集成开发环境下，采用Java语言编码设计系统功能，MySQL数据库管理相关的系统数据信息，SSM框架设计和开发系统功能架构，最后通过使用Tomcat服务器，在浏览器中发布设计的系统，并且完成系统与数据库的交互工作。本文对系统的需求分析、可行性分析、技术支持、功能设计、数据库设计、功能测试等内容做了较为详细的介绍，并且在本文中也展示了系统主要的功能模块设计界面和操作界面，并对其做出了必要的解释说明，方便用户对系统进行操作和使用，以及后期的相关人员对系统进行更新和维护。通过设计基于SSM的校园兼职管理系统，可以极大地提高校园兼职的工作效率，提升用户的使用体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3eed0adb38ddce8795777d436d6340f/" rel="bookmark">
			Vue.js动画库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、vue2-animate https://animate.style/
地址：https://www.npmjs.com/package/vue2-animate一个可以在你的网站中即用型跨浏览器动画库，非常适合主页、滑块和动画引导提示。这是Animate.css 的一个端口，用于 Vue.js 2.0/3.0 和Alpines.js 中的转换。尽管文档不符合标准，但具有前端开发经验的开发人员会发现使用它也很容易。
便于使用响应式 安装：
npm i vue2-animate import 'vue2-animate/dist/vue2-animate.min.css' 使用方法： 针对单个标签 (name属性为运动形式) &lt;transition name="fade"&gt; 需要运动的元素标签 &lt;/transition&gt; 针对一组标签 (可以通过tag定义父元素标签，name定义运动形式) &lt;transition-group name="bounce" tag="渲染的父元素标签"&gt; 循环的元素 key值不能为index &lt;/transition-group&gt; 注意循环的元素 key值不能为index 否则报错： Do not use v-for index as key on &lt;transition-group&gt; children, this is the same as not using keys. 运动的时间，通过css去设置 例： animation-duration:0.3s; 原理 类名是通过数据变化（新增、删除）+ transition（或transition-group）的name属性 = 最终样式 例如： name="bounce" 数据项目新增 则 入场元素动画类名为 bounce-enter-active bounce-enter-to 数据项目删除 则 出场元素动画类名为 bounce-leave-active bounce-leave-to 2、vue-kinesis 地址：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3eed0adb38ddce8795777d436d6340f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78eb566445857f3a7ef90491670f3ad9/" rel="bookmark">
			SG-8506CA 可编程晶体振荡器 (SPXO)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出
: LV-PECL频率范围
: 50MHz ~ 800MHz电源电压
: 2.5V to 3.3V外部尺寸规格
: 7.0 × 5.0 × 1.5mm (8引脚)特性
:用户指定一个起始频率, 7-bit I2C 地址
:用户可编程: I2C 接口
:基频的高频晶体
:低抖动PLL技术应用
:OTN, BTS, 测试设备
规格（特征） *1 这包括初始频率公差、温度变化、电源电压变化、回流焊接漂移和10年老化 (+25 °C，10 年)
外部尺寸规格 推荐焊盘尺寸 (単位: mm)
为了完成适合的jitter性能，电容推荐(0.1 μF + 10 μF)在Vcc和GND引脚，放置位置应该尽可能接近Vcc引脚。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93b741f7ca7f66b7dab88bf3be6c646/" rel="bookmark">
			内网信息收集总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本机信息查询 常用信息 本机服务列表 wmic service list brief 本机进程列表 Tasklist /v 浏览器代理信息 reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings" RDP端口号（16进制） reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-TCP" /V portNumber 用户列表 net user 本地管理员 net localgroup administrators 在线用户 query user || qwinsta 提权相关补丁信息查询和流程 http://uuzdaisuki.com/2021/04/12/windows%E6%8F%90%E6%9D%83%E9%80%9F%E6%9F%A5%E6%B5%81%E7%A8%8B/
本机3389开启 1.通用开3389：
wmic RDTOGGLE WHERE ServerName='%COMPUTERNAME%' call SetAllowTSConnections 1 2.Win2003:
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 3.Win2008:
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c93b741f7ca7f66b7dab88bf3be6c646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec220def536ad6dd7f55963a13bde95c/" rel="bookmark">
			【计算机毕业设计】穿戴搭配系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息数据从传统到当代，是一直在变革当中，突如其来的互联网让传统的信息管理看到了革命性的曙光，因为传统信息管理从时效性，还是安全性，还是可操作性等各个方面来讲，遇到了互联网时代才发现能补上自古以来的短板，有效的提升管理的效率和业务水平。传统的管理模式，时间越久管理的内容越多，也需要更多的人来对数据进行整理，并且数据的汇总查询方面效率也是极其的低下，并且数据安全方面永远不会保证安全性能。结合数据内容管理的种种缺点，在互联网时代都可以得到有效的补充。结合先进的互联网技术，开发符合需求的软件，让数据内容管理不管是从录入的及时性，查看的及时性还是汇总分析的及时性，都能让正确率达到最高，管理更加的科学和便捷。本次开发的穿戴搭配系统实现了收货地址管理、购物车管理、穿搭管理、穿搭收藏管理、穿搭评价管理、穿搭订单管理、穿搭讲堂管理、穿搭讲堂收藏管理、穿搭讲堂留言管理、字典管理、论坛管理、用户管理、管理员管理等功能。系统用到了关系型数据库中王者MySql作为系统的数据库，有效的对数据进行安全的存储，有效的备份，对数据可靠性方面得到了保证。并且程序也具备程序需求的所有功能，使得操作性还是安全性都大大提高，让穿戴搭配系统更能从理念走到现实，确确实实的让人们提升信息处理效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b60fe68e2419d5ef2e96d3ef6d418d4/" rel="bookmark">
			回收站删除的照片怎么恢复？恢复文件，3个方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我刚刚在恢复回收站误删照片的时候不小心把回收站清空了。这可怎么办呢？有什么方法可以恢复回收站删除的照片吗？希望大家帮我出出主意。” 回收站能保存电脑上误删的文件，对电脑来说是一个比较重要的功能。那么，如果回收站被清空了，回收站删除的照片怎么恢复？可能还有很多用户不知道。
本文小编将给大家分享几个恢复回收站删除照片的简单方法，请继续往下看吧！
方法一：借助快捷键恢复回收站删除的照片 回收站的照片怎么恢复？如果用户是在对回收站进行清理的过程中，突然意识到误删了重要的图片，比较直接有效的恢复方法是借助快捷键来恢复文件。但是使用快捷键的前提是用户在删除文件后没有进行其他操作。
步骤1：在文件删除后，及时按下【Ctrl＋z】，可撤销删除操作；
步骤2：检查回收站误删的文件是否完整找回。
方法二：借助备份恢复回收站删除的照片 如果你养成了备份照片的好习惯，那么在回收站清空后，回收站删除的照片怎么恢复
呢？尝试从备份中恢复是个不错的选择。
步骤1：找到被删除文件的备份文件；
步骤2：将备份文件直接保存在电脑上，并检查文件是否可以正常查看。
方法三：借助专业软件恢复回收站删除的照片 电脑回收站清空了怎么找回？如果采用正确的操作方法，文件找回的概率还是比较大的。建议大家尝试使用 数 据 蛙 恢 复 专 家 。这款软件操作起来是比较简单的，并且保密性也比较好。
无论你对电脑熟悉与否，都有机会通过简单的操作恢复重要的数据。软件是支持免费试用的。如果想要恢复重要的数据，可以下载软件后按步骤进行操作。
操作环境： 演示机型：华硕无畏1414s 系统版本：Windows 10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 步骤1：双击运行软件后可进入选择界面，先勾选上【图片】，再勾选【回收站】，点击【扫描】；
步骤2：在软件进行完首次扫描后，用户可以按照不同的路径或类型对扫描的结果进行查看，如果只找到少部分需要恢复的文件，点击【深度扫描】；
步骤3：完成深度扫描后。所呈现的数据会比较多，建议用户直接在【筛选器】中输入相关的文件条件，定位到需要恢复的文件后，图片可以方法浏览，确认是需要恢复的文件后，将其勾选上，并选择【导出】。
提示：图片文件导出后，所选保存磁盘应该与原保存磁盘不一样。 回收站可以为我们保存部分误删数据，但如果遇到回收站被清空的情况，数据恢复也是有一定难度的。回收站删除的照片怎么恢复？上文给大家简单总结了几个实用方法。每一种方法都有其适用场景和优缺点。为了确保重要数据的完整性，我们应该养成备份的好习惯，并采取多种措施来防止数据丢失！
往期推荐：
电脑文件丢失怎么恢复？这4个方法不可错过！https://blog.csdn.net/datarecover/article/details/135742990?spm=1001.2014.3001.5501
磁盘初始化会丢失文件吗？答案揭晓！https://blog.csdn.net/datarecover/article/details/135740646?spm=1001.2014.3001.5501
Excel乱码？教你3个简单解决方法！https://blog.csdn.net/datarecover/article/details/135741875?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f7574a45c088e8dc6be377190fc7d7/" rel="bookmark">
			【计算机毕业设计】私人定制旅游系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统信息的管理大部分依赖于管理人员的手工登记与管理，然而，随着近些年信息技术的迅猛发展，让许多比较老套的信息管理模式进行了更新迭代，旅游路线信息因为其管理内容繁杂，管理数量繁多导致手工进行处理不能满足广大用户的需求，因此就应运而生出相应的私人定制旅游系统。
本私人定制旅游系统分为管理员还有用户两个权限，管理员可以管理用户的基本信息内容，可以管理公告信息以及公告的租赁信息，能够与用户进行相互交流等操作，用户可以查看旅游路线信息，可以查看公告以及查看管理员回复信息等操作。
该私人定制旅游系统采用的是WEB应用程序开发中最受欢迎的B/S三层结构模式，使用占用空间小但功能齐全的MySQL数据库进行数据的存储操作，系统开发技术使用到了JSP技术。该私人定制旅游系统能够解决许多传统手工操作的难题，比如数据查询耽误时间长，数据管理步骤繁琐等问题。总的来说，私人定制旅游系统性能稳定，功能较全，投入运行使用性价比很高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1ef976660b049f571483ca46f9ff58/" rel="bookmark">
			生命在于学习——HTTPS验证方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、HTTPS的验证过程分为单向验证和双向验证。 1. 单向验证： 客户端验证服务器的身份，确保连接的安全性。客户端验证服务器的证书，包括检查证书是否过期、是否被吊销、是否可信以及验证域名是否一致。服务器不对客户端进行身份验证。 2. 双向验证： 除了客户端验证服务器的身份，服务器也验证客户端的身份。客户端需要生成私钥和证书，并将证书发给服务器。服务器验证客户端的证书和身份。 二、HTTPS的验证过程涉及到TCP的三次握手和四次挥手。 1. 三次握手： 客户端向服务器发送SYN（同步）请求。服务器回应ACK（确认）和SYN。客户端回应ACK，完成连接的建立。 2. 四次挥手： 客户端发送FIN（结束）请求，表示要关闭连接。服务器回应ACK，确认收到关闭请求。服务器发送FIN，表示准备关闭连接。客户端回应ACK，确认收到关闭请求，连接关闭。 三、HTTPS的单向验证过程： 客户端发起ClientHello消息，包含支持的加密算法和随机数。服务器回应SeverHello消息，选择加密算法和生成随机数。客户端验证服务器的证书，包括检查证书是否过期、是否被吊销、是否可信以及验证域名是否一致。服务器验证客户端的证书，如果客户端没有提供证书，则验证通过。双方生成相同的对称加密密钥，用于后续数据传输的加密。 四、HTTPS的双向验证过程： 客户端发起ClientHello消息。服务器回应SeverHello消息，并要求客户端提供证书。客户端回应中包含客户端的证书和证书验证消息。服务器验证客户端的证书和身份。双方生成相同的对称加密密钥，用于后续数据传输的加密。 五、HTTPS的验证过程确保了数据传输的安全性。 验证过程中包括证书的验证和密钥的生成。数据传输时使用的对称加密密钥只在连接断开前有效，保证数据传输的安全性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994b07aab4f266178a1edaee76432bfd/" rel="bookmark">
			java网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.网络编程入门 1.1 网络编程概述【理解】 计算机网络
是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统
网络编程
在网络通信协议下，不同计算机上运行的程序，可以进行数据传输
1.2 网络编程三要素【理解】 IP地址
要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识
端口
网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识
协议
通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议
1.3 IP地址【理解】 IP地址：是网络中设备的唯一标识
IP地址分为两大类
IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多
IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题
DOS常用命令：
ipconfig：查看本机IP地址
ping IP地址：检查网络是否连通
特殊IP地址：
127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用
1.4 InetAddress【应用】 InetAddress：此类表示Internet协议（IP）地址
相关方法
方法名说明static InetAddress getByName(String host)确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址String getHostName()获取此IP地址的主机名String getHostAddress()返回文本显示中的IP地址字符串 代码演示
public class InetAddressDemo { public static void main(String[] args) throws UnknownHostException { //InetAddress address = InetAddress.getByName("itheima"); InetAddress address = InetAddress.getByName("192.168.1.66"); ​ //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/994b07aab4f266178a1edaee76432bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8cdca57043a05e2f9031f22cf402bf6/" rel="bookmark">
			YOLOV5单目测距&#43;车辆检测&#43;车道线检测&#43;行人检测（教程-代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv5是一种高效的目标检测算法，结合其在单目测距、车辆检测、车道线检测和行人检测等领域的应用，可以实现多个重要任务的精确识别和定位。 首先，YOLOv5可以用于单目测距。 通过分析图像中的目标位置和尺寸信息，结合相机参数和几何关系，可以推断出目标与相机之间的距离。这对于智能驾驶、机器人导航等领域至关重要，可以帮助车辆或机器人感知周围环境的远近，并做出相应的决策。
其次，YOLOv5可以用于车辆检测。 它可以快速而准确地检测图像中的车辆，并给出其边界框和类别信息。这对于交通监控、智能交通管理等应用非常有用，可以帮助实时监测道路上的车辆情况，并进行车辆计数、违规检测等任务。
此外，YOLOv5还可以用于车道线检测。 通过分析道路图像中的特征，如边缘、颜色等，结合YOLOv5的目标检测能力，可以有效地检测出车道线的位置和形状。这对于自动驾驶、车道保持等任务至关重要，可以帮助车辆实时判断自己在道路上的位置，并做出相应的控制动作。
最后，YOLOv5还可以用于行人检测。 它可以准确地检测图像中的行人，并给出其边界框和类别信息。这对于行人安全、城市规划等领域非常有用，可以帮助监测行人的数量和分布情况，并进行行人流量统计、行人路径规划等任务。
总之，YOLOv5作为一种高效的目标检测算法，在单目测距、车辆检测、车道线检测和行人检测等领域具有重要的应用价值。它的快速和精确性能使其成为实时场景中的首选算法，并在智能交通、自动驾驶等领域发挥着重要的作用。 1、论文流程的简介 项目的主题框架使用为yolo和opencv的形式实现，而模型的选择为基于深度学习的YOLO V5模型，权重为基于COCO2014训练的数据集，而车道线的检测是基于OpenCV的传统方法实现的。
2、论文主体部分 2.1、YOLO V5模型 YoloV2的结构是比较简单的，这里要注意的地方有两个：
1.输出的是batchsize x （5+20）*5 x W x H的feature map； 2.这里为了提取细节，加了一个 Fine-Grained connection layer，将前面的细节信息汇聚到了后面的层当中。 YOLOv2结构示意图
2.1.1、DarkNet19模型
YOLOv2采用了一个新的基础模型（特征提取器），称为Darknet-19，包括19个卷积层和5个maxpooling层；Darknet-19与VGG16模型设计原则是一致的，主要采用33卷积，采用 22的maxpooling层之后，特征图维度降低2倍，而同时将特征图的channles增加两倍。
与NIN(Network in Network)类似，Darknet-19最终采用global avgpooling做预测，并且在33卷积之间使用11卷积来压缩特征图channles以降低模型计算量和参数。
Darknet-19每个卷积层后面同样使用了batch norm层以加快收敛速度，降低模型过拟合。在ImageNet分类数据集上，Darknet-19的top-1准确度为72.9%，top-5准确度为91.2%，但是模型参数相对小一些。使用Darknet-19之后，YOLOv2的mAP值没有显著提升，但是计算量却可以减少约33%。
"""Darknet19 Model Defined in Keras.""" import functools from functools import partial from keras.layers import Conv2D, MaxPooling2D from keras.layers.advanced_activations import LeakyReLU from keras.layers.normalization import BatchNormalization from keras.models import Model from keras.regularizers import l2 from .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8cdca57043a05e2f9031f22cf402bf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2571cc5197fba506d533b9e6499be62d/" rel="bookmark">
			3分钟快速了解Java泛型的extends通配符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3分钟快速了解Java泛型的extends通配符 1. Java泛型基础知识回顾 1.1 什么是Java泛型 Java泛型，或者说是"参数化类型"，是Java SE 5.0引入的一个新特性。它允许你在定义类、接口、方法时使用类型参数，这种参数在实例化或调用时将被具体的类型所替代。这就像是我们在编写代码时，为某些部分留下了一个占位符，稍后再来填充具体的类型。
List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 在这个例子中，String就是类型参数，而List&lt;String&gt;则是参数化的类型。
1.2 Java泛型的设计目的和使用场景 Java泛型的设计初衷是提供类型安全和消除类型强制转换的麻烦。在没有泛型之前，我们可以将任何类型的对象添加到集合中，然后在取出时进行类型转换。但是，这种方式存在类型安全问题，一旦类型转换错误，就会在运行时抛出ClassCastException。
List list = new ArrayList(); list.add("hello"); Integer num = (Integer) list.get(0); // 运行时抛出ClassCastException 有了泛型，我们可以在编译时就检查类型，从而避免运行时的类型转换错误。
List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("hello"); String str = list.get(0); // 正确，无需类型转换 1.3 Java泛型的基本语法和规则 Java泛型的基本语法是在类、接口、方法的定义中使用尖括号&lt;&gt;来定义类型参数。这个类型参数可以是任何非基本类型，如T、E、K、V等。
public class Box&lt;T&gt; { private T t; public void set(T t) { this.t = t; } public T get() { return t; } } 在这个Box类的定义中，T就是类型参数，它代表了某种具体的类型。当我们创建Box的实例时，就可以为T指定具体的类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2571cc5197fba506d533b9e6499be62d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3579ae26e3cf7e6b230d2e868730e1bc/" rel="bookmark">
			cool node.js 后端接口实现账号密码登录和注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实现H5 的账号密码 登录和注册功能
2.登录和注册代码
controller
@Post('/h5Login', { summary: 'H5登录' }) async LoginByH5(@Body() body) { const res: any = await this.businessLoginService.H5Login(body); return this.ok(res); } @Post('/h5Register', { summary: 'H5注册' }) async RegisterByH5(@Body() body) { const res: any = await this.businessLoginService.H5Register(body); return this.ok(res); } service
// H5 登录 async H5Login(login) { if (!login.password || !login.phone) { throw new CoolCommException('参数不能为空~'); } const user = await this.businessStudentEntity.findOneBy({ phone: login?.phone, password: md5(login?.password), }); if (!user) { // if (user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3579ae26e3cf7e6b230d2e868730e1bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cd0edc2fd7b3ef2736fd4e05be059d/" rel="bookmark">
			cool框架 Node.js 后端接口实现微信公众号重定向授权登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求 做一个获取微信公众号H5 公众号重定向登录授权的接口 2.代码
controller
/** * H5 g公众号 * @param login */ @Post('/wxCode', { summary: '获取code授权' }) async getOpenAndatoken(@Body() body) { const res: any = await this.businessLoginService.getAccessTokenByWx(body); await this.cacheManager.set( 'access_token', JSON.parse(res)['access_token'] ); // // 缓存10秒 // await this.cacheManager.set('a', 1, { // ttl: 10, // }); return this.ok(JSON.parse(res)['openid']); } @Post('/wxLogin', { summary: '公众号用户登录' }) async weChatLogin(@Body() body) { body['access_token'] = await this.cacheManager.get('access_token'); console.log(body['access_token'], body); const res: any = await this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8cd0edc2fd7b3ef2736fd4e05be059d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1137fea458e80734b760106a0c0c124/" rel="bookmark">
			MybatisPlus按时间段进行查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 String beginTime = "2024-01-23"; String endTime = "2024-01-23"; QueryWrapper&lt;IotDevice&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select().apply(StrUtil.isNotBlank(beginTime), "date_format(create_date,'%Y-%m-%d') &gt;= date_format('" + beginTime+ "','%Y-%m-%d')") .apply(StrUtil.isNotBlank(endTime), "date_format(create_date,'%Y-%m-%d') &lt;= date_format('" + endTime+ "','%Y-%m-%d')"); List&lt;IotDevice&gt; iotDeviceList= iotDeviceService.list(queryWrapper); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b39f49265a0385c28a7112d8f24aeb/" rel="bookmark">
			[C&#43;&#43;]使用yolov8的onnx模型仅用opencv和bytetrack实现目标追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【官方框架地址】
yolov8:
https://github.com/ultralytics/ultralytics
bytetrack:
https://github.com/ifzhang/ByteTrack
【算法介绍】
随着人工智能技术的不断发展，目标追踪已成为计算机视觉领域的重要研究方向。Yolov8和ByTetrack作为当前先进的算法，当它们结合使用时，能够显著提升目标追踪的准确性和实时性。
Yolov8，源于“You Only Look Once”的简称，是一款强大且高效的目标检测算法。它继承了Yolov3和Yolov4的优点，并在其基础上进行了改进，使得检测精度和速度都得到了显著提升。Yolov8特别适合于处理视频流中的目标追踪任务，因为它能够实时地、准确地检测出视频中的目标。
ByTetrack，全称为Background and Tracklet-based Object Tracking，是一种基于背景减除和轨迹匹配的目标追踪方法。它利用背景减除技术初步确定目标的运动轨迹，再结合轨迹匹配算法，对目标进行精确追踪。ByTetrack的优势在于，即使在复杂场景下，如目标遮挡、运动模糊等，它仍能保持较高的追踪精度。
当Yolov8与ByTetrack结合使用时，首先，Yolov8快速并准确地检测出视频中的目标；然后，ByTetrack利用Yolov8提供的信息，对目标进行精确追踪。这种结合方式既发挥了Yolov8的高检测精度，又利用了ByTetrack的高追踪精度，使得整体目标追踪效果更上一层楼。
综上所述，Yolov8与ByTetrack的结合为解决复杂场景下的目标追踪问题提供了新的思路和方法。在未来的人工智能技术发展中，这种结合方式有望成为目标追踪领域的研究热点。
【效果展示】
【实现部分代码】
#include &lt;iostream&gt; #include&lt;opencv2/opencv.hpp&gt; #include&lt;math.h&gt; #include "yolov8.h" #include&lt;time.h&gt; #include &lt;math.h&gt; #include &lt;time.h&gt; #include &lt;vector&gt; #include &lt;chrono&gt; #include &lt;float.h&gt; #include &lt;stdio.h&gt; #include "BYTETracker.h" using namespace std; using namespace cv; using namespace dnn; int main() { string detect_model_path = "./models/yolov8n.onnx"; Yolov8 detector; detector.ReadModel(detect_model_path,"labels.txt",false); vector&lt;Object&gt; objects; cv::VideoCapture cap("D:\\car.mp4"); int img_w = cap.get(CAP_PROP_FRAME_WIDTH); int img_h = cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0b39f49265a0385c28a7112d8f24aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5782aae86975358b626fb4fc3238113c/" rel="bookmark">
			Python编程的终极十大工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Python一直以来都是程序员们的首选编程语言之一，其灵活性和功能强大的库使其成为解决各种问题的理想选择。在本文中，我们将介绍Python编程的终极十大工具，这些工具可以帮助您在各种领域取得成功，无论您是初学者还是经验丰富的开发者。
1. Jupyter Notebook：编程明星 Jupyter Notebook是数据科学家和研究人员的最爱，但它同样适用于程序员。您可以在一个交互式环境中编写和运行代码，同时添加注释、图表和文档，使得代码更易于理解和分享。无论您是在进行数据分析、机器学习建模还是原型设计，Jupyter Notebook都是无可替代的工具。
2. PyCharm：专业的集成开发环境 PyCharm是一款功能强大的集成开发环境（IDE），专为Python开发而设计。它提供了代码自动完成、调试、版本控制等一系列功能，使得开发更加高效。PyCharm的社区版免费提供，是Python编程的绝佳选择。
3. Requests：轻松处理HTTP请求 如果您需要与网络交互，Requests库是不可或缺的。它简化了与网站的通信，使您能够轻松发送HTTP请求并处理响应。无论您是在进行网络爬虫、API调用还是测试网站，Requests都能够让这些任务变得轻而易举。
4. Pandas：数据处理的瑞士军刀 Pandas是一个用于数据处理和分析的库，它提供了灵活的数据结构和数据操作工具。无论您需要进行数据清洗、转换还是统计分析，Pandas都可以帮助您快速达成目标。
5. Matplotlib：绘制精美的图表 Matplotlib是Python中用于绘制图表和可视化数据的库。无论您是在制作科学图表、数据可视化还是报告，Matplotlib提供了丰富的绘图选项，可以让您的数据以最吸引人的方式呈现。
6. Numpy：数值计算的基石 Numpy是Python中用于数值计算的库，提供了强大的数组操作功能。如果您需要进行线性代数运算、数组操作或者数值模拟，Numpy是您的得力工具。
7. Beautiful Soup：解析HTML Beautiful Soup是一个用于解析HTML和XML文档的库，非常适用于网页爬虫和数据抓取。它可以帮助您轻松提取所需信息，无需手动分析网页源代码。
8. Django：构建强大的Web应用 Django是一个高效且功能强大的Python Web框架，可帮助您快速构建各种类型的Web应用程序。它提供了一系列强大的工具和库，使得开发过程变得更加轻松。
9. Scikit-learn：机器学习的利器 Scikit-learn是一个用于机器学习和数据挖掘的库，提供了各种机器学习算法的实现。无论您是在进行分类、回归还是聚类，Scikit-learn都是您的好帮手。
10. Pygame：游戏开发的有趣选择 如果您对游戏开发感兴趣，Pygame是一个有趣的选择。它是一个用于2D游戏开发的库，提供了游戏开发所需的各种功能，让您能够轻松创建自己的游戏。
Python是一个功能强大且多才多艺的编程语言，这些工具只是冰山一角。不论您是进行数据分析、Web开发、机器学习还是其他任何领域的编程，Python都有相应的工具可以帮助您取得成功。让这些工具成为您的伙伴，让Python编程之旅变得更加有趣和高效！
一、Python入门 下面这些内容是Python各个应用方向都必备的基础知识，想做爬虫、数据分析或者人工智能，都得先学会他们。任何高大上的东西，都是建立在原始的基础之上。打好基础，未来的路会走得更稳重。所有资料文末免费领取！！！
包含：
计算机基础
python基础
Python入门视频600集：
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
二、Python爬虫 爬虫作为一个热门的方向，不管是在自己兼职还是当成辅助技能提高工作效率，都是很不错的选择。
通过爬虫技术可以将相关的内容收集起来，分析删选后得到我们真正需要的信息。
这个信息收集分析整合的工作，可应用的范畴非常的广泛，无论是生活服务、出行旅行、金融投资、各类制造业的产品市场需求等等，都能够借助爬虫技术获取更精准有效的信息加以利用。
Python爬虫视频资料
三、数据分析 清华大学经管学院发布的《中国经济的数字化转型：人才与就业》报告显示，2025年，数据分析人才缺口预计将达230万。
这么大的人才缺口，数据分析俨然是一片广阔的蓝海！起薪10K真的是家常便饭。
四、数据库与ETL数仓 企业需要定期将冷数据从业务数据库中转移出来存储到一个专门存放历史数据的仓库里面，各部门可以根据自身业务特性对外提供统一的数据服务，这个仓库就是数据仓库。
传统的数据仓库集成处理架构是ETL，利用ETL平台的能力，E=从源数据库抽取数据，L=将数据清洗（不符合规则的数据）、转化（对表按照业务需求进行不同维度、不同颗粒度、不同业务规则计算进行统计），T=将加工好的表以增量、全量、不同时间加载到数据仓库。
五、机器学习 机器学习就是对计算机一部分数据进行学习，然后对另外一些数据进行预测与判断。
机器学习的核心是“使用算法解析数据，从中学习，然后对新数据做出决定或预测”。也就是说计算机利用以获取的数据得出某一模型，然后利用此模型进行预测的一种方法，这个过程跟人的学习过程有些类似，比如人获取一定的经验，可以对新问题进行预测。
机器学习资料：
六、Python高级进阶 从基础的语法内容，到非常多深入的进阶知识点，了解编程语言设计，学完这里基本就了解了python入门到进阶的所有的知识点。
到这就基本就可以达到企业的用人要求了，如果大家还不知道去去哪找面试资料和简历模板，我这里也为大家整理了一份，真的可以说是保姆及的系统学习路线了。
但学习编程并不是一蹴而就，而是需要长期的坚持和训练。整理这份学习路线，是希望和大家共同进步，我自己也能去回顾一些技术点。不管是编程新手，还是需要进阶的有一定经验的程序员，我相信都可以从中有所收获。
一蹴而就，而是需要长期的坚持和训练。整理这份学习路线，是希望和大家共同进步，我自己也能去回顾一些技术点。不管是编程新手，还是需要进阶的有一定经验的程序员，我相信都可以从中有所收获。
资料领取 这份完整版的Python全套学习资料已经上传网盘，朋友们如果需要可以点击下方微信卡片免费领取 ↓↓↓【保证100%免费】 或者
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5782aae86975358b626fb4fc3238113c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d73392889a2d51bdb48bc72a349f21/" rel="bookmark">
			大A啥时候是个底？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）场内资本
昨天大A交易量在7200多亿，和前几天相比还算是放量。不过指数下跌，属于大家常说的：放量下跌。至于放量下跌意味着什么，嘿嘿嘿，大家各自都有各自的解读。
昨天的牌家还是两方：
1、游资
2、主力
北上、散户这两个牌家，还是失语。
游资呢，还是2023年的游龙戏凤的玩法，昨天玩的是”华“字。
主力呢，分为两大类：
一大类是国家队，保主干-权重：上证50和沪深300。
另一大类呢，是金融产业主力，自己保自己的金融体系。
所以两大牌家各玩各的，井水不犯河水：
游资，继续玩自己能撼得动的小盘股微盘股
主力，继续玩自己份内的权重股
（2）外围资本
很多人问中国A股啥时候是个底、啥时候是个头啊？
其实A股只是资本的关联影响方，核心是房地产出清：房地产-地方债、房地产-城投、房地产-地方商业银行、城投-地方商业银行、房地产-基金/信托/保险。你看看：地方债、城投、地方商业银行、基金/信托/保险、巨型企业财务公司，这些哪个不是资本类型。这些资本都受影响，自然没钱给股市了。
又叠加了国际金融影响：美元加息-日元潜在加息-美中汇率。很多人叫着让央妈降息。唉，央妈各种SLF、MLF、PSL、降准、逆回购都做了，存款利率也都降了，房地产的定向贷款利率也都降了，大家还想让央妈干啥？
我们回头想想，2016年底，中央提出了房住不炒，所以：
2017-2018-2019：房住不炒
2020-2021-2022：三道红线
2023-2024-2025：三年出清
所以这三年出清再企稳，重点是富人财富洗牌，当然中产因地方资产下跌而造成房贷倒挂，这也算中产财富洗牌。
所以，中国A股啥时候是个底、啥时候是个头，我用逻辑（不用经验）给大家暗示了。但其实我多次说：经验靠不住、逻辑靠不住，还得看数据。有人问看啥数据？当然是房地产数据了啊。
其实大家也不用太心慌，你看：
2007年下半年开始大跌，到了2008年下半年，一年时间从6124点到1664点，下跌幅度70%。
从2021年小阳春最高3731点，到现在2800点附近，这才跌下25%。
你再看这几年（2021-2022-2023）的港股，恒生指数也是从31183最高点跌到了如今的14961点，跌幅达50%，至于后续是否还会下跌，不知道。
（3）主力资本
上述我说A股只是资本的关联影响方，那A股自己的主因方是谁？
我过去讲过一个西游记故事：说真假美猴王到阴曹地府让地藏王菩萨去辨认真假，地藏王请来了谛听神兽来辨认。
那兽奉地藏钧旨，就于森罗庭院之中，俯伏在地，须臾抬起头来，对地藏道：“怪名虽有，但不可当面说破，又不能助力擒他。”地藏道：“当面说出便怎么？”谛听道：“当面说出，恐妖精恶发，搔扰宝殿，致令阴府不安。”又问：“何为不能助力擒拿？”谛听道：“妖精神通，与孙大圣无二。幽冥之神，能有多少法力？故此不能擒拿。”地藏道：“似这般怎生祛除？”谛听言：“佛法无边。”地藏早已省悟。
所以，证监会也很无奈啊：
禁止限售解禁股通过融券卖出。只能公开谴责。
禁止融资买入证券用于偿还融券负债。只能公开谴责。
企业财务报表造假。自罚三杯。
还有400多家企业在排队等着2024年上市。没办法啊，必须上啊。从2014-2024这十年，地方队投了那么多企业，必须上市退出才能做到国有资产保值增值。又面临着一级市场二级市场这十年来倒挂，必须另设通道退出啊。
所以，A股市场现在这样，大家应该知道哪个资本方才是主因。至于做保荐做承销的证券公司，只是执行者-帮手-喝汤者。
不过，我对所谓的严惩不严惩没有洁癖，大A这十年，没有严惩，这不照样有2014-2015年的大牛市，以及2020-2021的小阳春么？所以说，管控不能保证发展，只有激励某一方牌家才能发展。
（4）标的企业
我还没统计2023年有多少家企业进行实控人变更，不过我去年平日留意，应该不少。
中国作为一个明面做多市场、暗面做空市场，做空方式也很多，比如：
融券卖出
股指期货
大宗交易-变更实控人
质押
都是资本机构企业对资本机构企业的玩法，咱们俗称B to B。
我看到一个数据：大A 60多万亿市值，企业的大股东质押有3-4万亿。达到平仓线的有28.31%，还有6.52%在预警线。即使是这样，2024年一开年，质押仍然在加速增长。
真是应了那句话：我本想赚市值波动的钱，你却想把企业卖给我。
咱们再说一个事，都是2023年出台的新规：
1、鼓励分红：不分红就不能减持
2、鼓励回购
真是应了那句话：我本想赚市值波动的钱，你却想让我赚经营利润分红的钱。
有时候吧，大家被错综复杂迷了眼，反而不回归到第一性原理去看事。
股市，说穿了和商品交易市场一样，只不过交易物是股票。交易就是：买和卖。有买必然有卖，有卖的，才能买到。
所以说啊：拿了好多股票的牌家都在降价割肉在市场上抛售股票，那到底是谁买走了这些低廉的股票呢？你想啊，如果没有人接盘买，那就交易无法完成啊。必然是有人低价买了这些股票，才有人割肉抛掉退出。
证监会环顾了一下桌面上这些牌家，看来看去都不敢动，只能希望标的企业来回购接盘。但企业回购的动力是什么呢？是道德是责任是梦想？
所以到底是谁接盘买走了这些低廉的股票呢？这个问题其实是个好问题。大家你们猜，呵呵呵。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff60c1736212074e83537868ab20a70/" rel="bookmark">
			（附源码）springboot美食系统 毕业设计44017
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
摘要 1 绪论 1.1开发意义 1.2研究方法 1.3springboot框架介绍 1.3论文结构与章节安排 2 美食系统系统分析 2.1 可行性分析 2.2 系统流程分析 2.2.1 数据流程 3.3.2 业务流程 2.3 系统功能分析 2.3.1 功能性分析 2.3.2 非功能性分析 2.4 系统用例分析 2.5本章小结 3 美食系统总体设计 3.1 系统架构设计 3.2 系统功能模块设计 3.2.1整体功能模块设计 3.2.2用户模块设计 3.2.3 评论管理模块设计 3.2.4美食信息管理模块设计 3.3 数据库设计 3.3.1 数据库概念结构设计 3.3.2 数据库逻辑结构设计 3.4本章小结 4 美食系统详细设计与实现 4.1用户功能模块 4.1.1 前台首页界面 4.1.2 用户注册界面 4.1.3 用户登录界面 4.1.4我的账户界面 4.1.5公告栏界面 4.1.6美食信息界面 4.1.7评分界面 4.2管理员功能模块 4.2.1系统公告管理界面 4.2.2系统用户管理界面 4.2.3美食类型管理界面 4.2.4 美食信息管理界面 4.2.5 美食评分管理界面 5系统测试 5.1系统测试的目的 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff60c1736212074e83537868ab20a70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8815050dc12e07994f3284eda107cd3/" rel="bookmark">
			一个PDF处理利器的.Net开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目开发中，处理PDF文件是一个非常常见的需求，之前也推荐几个，今天继续给大家推荐一个强大且易于使用的开源库，专门用于处理PDF文件，它提供了一系列功能强大的工具，帮助开发人员轻松地解析、修改和创建PDF文件。
01
项目简介
PdfPig是一个基于.NET开发的开源项目，是一个强大PDF处理库，核心功能有：
1、支持提取PDF文档的文字的位置和大小，从而能够获取文档的文本；
2、支持从PDF文档搜索图片；
3、支持读取PDF注释、PDF表单、嵌入的文档和超链接；
4、支持对PDF文档元数据的访问；
5、支持PDF文件创建，以及PDF写入；
6、支持通过密码访问加密文件的内容；
7、文档布局分析：还提供了文档布局分析工具，如Recursive XY Cut、Document Spectrum和Nearest Neighbour算法等。它还支持将页面内容导出为Alto、PageXML和hOcr格式；
8、不直接支持表格，但可以使用Tabula Sharp或Camelot Sharp进行操作。
02
使用方法
1、写入PDF
using UglyToad.PdfPig.Content; using UglyToad.PdfPig.Core; using UglyToad.PdfPig.Writer; PdfDocumentBuilder builder = new PdfDocumentBuilder(); PdfPageBuilder page = builder.AddPage(PageSize.A4); // 读取宋体字体文件到字节数组 byte[] simSunFontBytes; using (FileStream fontFileStream = File.OpenRead("C:\\Windows\\Fonts\\STSONG.TTF")) { simSunFontBytes = new byte[fontFileStream.Length]; fontFileStream.Read(simSunFontBytes, 0, simSunFontBytes.Length); } // 添加支持中文的字体 PdfDocumentBuilder.AddedFont font = builder.AddTrueTypeFont(simSunFontBytes); //写入 page.AddText("你好，这是一个PDF文档。", 12, new PdfPoint(25, 520), font); byte[] b = builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8815050dc12e07994f3284eda107cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2fa4db103c9d39105c76586c5ba599/" rel="bookmark">
			深入浅出LLamaSharp：打造智能.NET应用，不需GPU也能玩转LLaMA模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今的.NET社区中，机器学习和人工智能的应用越来越普遍。今天我要给大家推荐一个名叫LLamaSharp的开源项目。这是llama.cpp的C#/.NET绑定，提供了高级的API，使得我们能在本地设备上使用C#/.NET 推理LLaMA模型，并且部署它。
LLamaSharp支持在Windows、Linux和Mac上运行，无需自己编译llama.cpp。即便在没有GPU或者GPU内存不足的情况下，也能够使用LLaMA模型，这是非常让人兴奋的一点!
此外，LLamaSharp还提供了与其他项目如semantic-kernel、kernel-memory和BotSharp的集成，以提供更高层次的应用程序。
安装步骤 首先，在NuGet中安装LLamaSharp包：
PM&gt; Install-Package LLamaSharp 然后，根据您的需要安装以下后端之一：
LLamaSharp.Backend.Cpu：适用于Windows和Linux的纯CPU，以及适用于Mac的Metal。
LLamaSharp.Backend.Cuda11：适用于Windows和Linux的CUDA11。
LLamaSharp.Backend.Cuda12：适用于Windows和Linux的CUDA12。
如果这些后端都不适合您的需求，您可以自己编译llama.cpp。在这种情况下，请不要安装后端包！而是将您编译的DLL添加到您的项目中，并确保在编译项目时能够将其复制到输出目录。如果要这样做，您必须使用正确的llama.cpp提交版本，请参考下方的版本表格。
（可选）对于Microsoft semantic-kernel集成，请安装LLamaSharp.semantic-kernel包。
PM&gt; Install-Package LLamaSharp.semantic-kernel （可选）对于Microsoft kernel-memory集成，请安装LLamaSharp.kernel-memory包（这个包当前只支持net6.0）。
PM&gt; Install-Package LLamaSharp.kernel-memory 选择版本的建议 由于llama.cpp是一个变动频繁并且常有重大变更的项目，因此LLamaSharp也经常会有突破性的更改。LLamaSharp遵循语义化版本控制，并且不会在补丁版本中引入API的重大变更。
建议尽快更新到最新的补丁版本，同时也尽快更新到新的主版本。
快速开始-模型推理和聊天会话 LLamaSharp提供了两种运行推理的方式：LLamaExecutor和ChatSession。ChatSession是对executor和模型的更高级别的封装。下面是一个使用chat session的简单示例。
using LLama.Common; using LLama; string modelPath = "&lt;Your model path&gt;"; // 请更改为您自己的模型路径 var prompt = "Transcript of a dialog, where the User interacts with an Assistant named Bob. Bob is helpful, kind, honest, good at writing, and never fails to answer the User's requests immediately and with precision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b2fa4db103c9d39105c76586c5ba599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310c9b7d16c2066b0962a707ef971d16/" rel="bookmark">
			私有镜像仓库 Harbor 安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 我们如果需要部署一个私有镜像仓库来使用，最简单的就是 registry ，一行命令就可以运行在 Docker 中，但功能也比较弱，如果想要私有镜像仓库功能更丰富些，可以使用 Harbor 。
本文简单介绍下 Harbor 的安装和使用。
环境 服务器：CentOS 7 ，Harbor 部署在内网，通过 nginx 反向代理发布到外网使用
Harbor：2.9.1
docker：23.0.5
安装 1、如果没有安装 wget ，先执行下面命令安装：
yum install -y wget 2、下载包：
wget https://github.com/goharbor/harbor/releases/download/v2.9.1/harbor-offline-installer-v2.9.1.tgz 如果无法通过 wget 进行下载，可以直接到 Github 网站：https://github.com/goharbor/harbor/releases/ 进行下载，然后拷贝到服务器中：
3、执行下面命令进行解压：
tar -xvf harbor-offline-installer-v2.9.1.tgz 4、执行下面命令新建目录，并将程序文件复制到目录中：
mkdir /opt/harbor mv harbor/* /opt/harbor cd /opt/harbor 5、修改 Harbor 配置文件：
cp -ar harbor.yml.tmpl harbor.yml vi harbor.yml hostname：如果只是内网访问，设置为内网 IP，如果需要外网访问，就必须设置为外网域名或 IP
port：Web 访问的端口
6、编辑完配置文件，接下来在 harbor 目录下安装 Harbor。先进行预处理：
./prepare 7、执行下面命令进行安装：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310c9b7d16c2066b0962a707ef971d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d486ae4af355635eace78714b349b5e/" rel="bookmark">
			Spring Boot3整合Druid(监控功能)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前置条件
2.导依赖
错误依赖：
正确依赖：
3.配置
1.前置条件 已经初始化好一个spring boot项目且版本为3X，项目可正常启动。
作者版本为3.2.2最新版
2.导依赖 错误依赖： 这个依赖对于spring boot 3的支持不够，会带来诸多问题，比如yml配置项失效(用配置类可以解决)，监控后台访问不到（未找到解决办法）等。这个依赖比较适用于spring boot 2x。
正确依赖： &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.20&lt;/version&gt; &lt;/dependency&gt; 注意版本一定不要低于1.2.19!不然你连项目都启动不起来。
3.配置 无需写配置类
约定大于配置，无需写繁琐的配置项，写几个常用的，其他默认即可。
application.yml：
datasource: #druid数据源配置 druid: url: jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 # 初始化连接池大小 initialSize: 5 # 最小连接数 minIdle: 5 # 最大连接数 maxActive: 40 #配置过滤器，过滤掉静态文件 web-stat-filter: enabled: true url-pattern: /* exclusions: /druid/*,*.js,*.css,*.gif,*.jpg,*.bmp,*.png,*.ico #配置可视化控制台页面 stat-view-servlet: enabled: true #访问德鲁伊监控页面的地址 url-pattern: /druid/* #IP白名单 没有配置或者为空 则允许所有访问 allow: #IP黑名单 若白名单也存在 则优先使用 deny: #禁用重置按钮 reset-enable: true #登录所用的用户名与密码 login-username: admin login-password: 123456 写个测试看看配置生效没
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d486ae4af355635eace78714b349b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e223b6218e43444ebfd2fc36524ef954/" rel="bookmark">
			深度学习算法应用实战 | DINOv2 图像相似度实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特征提取简介 什么是特征提取 特征提取器负责为音频或视觉模型准备输入特征。包括从序列中提取特征，例如，对音频文件进行预处理以生成对数梅尔频谱图特征。以及从图像中提取特征，例如裁剪图像文件，还包括填充、归一化以及转换为NumPy、PyTorch和TensorFlow张量。
通俗一点解释 特征提取器就像是一个准备工人，它的工作是帮助计算机“理解”音频和图像。想象一下，当我们人类看图片或听声音时，我们可以轻松识别出里面的物体或声音。但对于计算机来说，它需要一种特殊的“翻译”，将这些音频和图像转换成它能理解的格式。这就是特征提取器的作用。
例如，对于音频文件，特征提取器可能会将声音转换成一种叫做“对数梅尔频谱图”的形式。这就像是把声音转换成一张包含不同音调和强度信息的图表，这样计算机就能更好地处理和分析声音了。
对于图像，特征提取器可能会做一些像裁剪图片（切掉不需要的部分），调整图片大小，使其更统一，或者改变图片的亮度和颜色，让计算机更容易识别图片中的内容。
最后，特征提取器还会把这些处理过的音频和图像转换成一种特殊的数据格式（我们称之为张量），这样不同的计算机程序，比如用于图像识别的PyTorch或用于语音识别的TensorFlow，就可以使用这些数据了。
总的来说，特征提取器就是帮助计算机“看懂”和“听懂”我们的世界的翻译工具。
图像相似度应用场景 图像检索： 通过计算图像相似度，可以建立一个图像数据库，并实现图像检索功能。用户可以通过输入一张图像找到相似的图片或相关产品。
人脸识别： 可以用于计算人脸图像之间的相似度，从而进行身份验证或者识别特定的个体。
内容过滤和版权保护： 图像相似度计算可用于检测和过滤不良内容，也可以帮助保护知识产权，防止未经授权的图像使用。
医学图像分析： 在医学领域，可以用于计算医学图像（如X射线、MRI等）之间的相似度，以辅助医生进行疾病诊断和治疗规划。
艺术品鉴别： 用于鉴别艺术品真伪或者确定不同版本的艺术品。
工业质检： 在制造业中，通过比较产品图像与标准图像的相似度，可以进行自动化的质量检查。
那这篇博客， 我就教大家使用 Meta AI 团队的 DINOv2 搭建一个图像相似度判别模型！
教程使用 huggingface 的 transformers 库来完成，这样方便我对整个专栏的代码教程进行维护，也方便我为大家分发模型（这种多模态的模型一般都很大，自己下载一次很麻烦）。
环境配置 conda create --name huggingface-env python==3.8 -y conda activate huggingface-env pip install transformers 如果你之前按照我的教程安装了这个环境，那么你就不需要再次安装了。
算法核心原理 2304.07193.pdf (arxiv.org)
最近在自然语言处理领域的突破性进展，特别是在大量数据上进行模型预训练，为计算机视觉领域类似的基础模型铺平了道路。这些模型可以通过生成通用视觉特征（即在不同图像分布和任务中均有效，无需微调的特征）来大大简化任何系统中图像的使用。我们的工作表明，如果在来自多样化来源的足够数量的精选数据上进行训练，现有的预训练方法，特别是自监督方法，可以产生这样的特征。我们重新审视了现有的方法，并结合不同的技术来扩大我们的预训练在数据和模型规模方面的应用。大部分技术贡献旨在加速和稳定大规模训练。在数据方面，我们提出了一个自动化流程来构建一个专用的、多样化的、精选的图像数据集，而不是像自监督文献中通常做的那样使用未经筛选的数据。在模型方面，我们训练了一个具有10亿参数的ViT模型并将其蒸馏到一系列更小的模型中，这些模型在大多数图像和像素级别的基准测试中超越了最佳的通用特征，OpenCLIP。
我们数据处理流程的概览。来自精选和非精选数据源的图像首先被映射到嵌入空间。之后，对非精选的图像进行去重处理，然后将其与精选图像进行匹配。通过这种方式，最终得到的组合通过一个自监督检索系统来增强初始数据集。
图1：第一主成分的可视化。我们计算同一列图像的补丁之间的主成分分析（a、b、c和d），并显示它们的前3个成分。每个成分与不同的颜色通道相匹配。尽管姿势、风格甚至物体发生变化，但相关图像之间的相同部分仍然匹配。通过对第一主成分进行阈值处理，可以去除背景。
代码实战 本次实战我们选择 openai 团队开源的 dinov2-base 版本。借助 transformers 库 ，我们可以通过几行代码就完成一个视觉任务。
下载好我提供的模型后，修改以下两处就可以顺利运行代码。
将model路径和processor路径指定到你下载下来文件的位置。image1和image2路径换成本地图片路径。 返回的结果就代表两张图片的余弦相似度。
import torch from transformers import AutoImageProcessor, AutoModel from PIL import Image import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e223b6218e43444ebfd2fc36524ef954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfda4207839cd699bc197099537b790a/" rel="bookmark">
			SpringCloud中服务间通信(应用间通信)-亲测有效-源码下载-连载2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、微服务概述 本案例主要解决微服务之间的相互调用问题
如果已经理解什么是微服务，可以直接跳到实战。
本案例采用springBoot3.1.7+springCloud2022.0.4版本测试
本案例使用springboot2.7.x版本测试代码相同
1、微服务是分布式架构，那么为什么要需要使用分布式架构？
因为单体服务是将所有的模块都放在一个项目中，这种架构部署简单，维护方便，但是随着功能的增加各个模块之间的边界会越来越模糊(即使各个模块的融合会越来越密切)，这就造成了一个问题如当修改订单服务的时候，可能会影响到商品系统、短信系统等，使程序的维护性降低等。且单体服务有性能瓶颈，越来越无法满足当今的互联网工程，这就出现了微服务。
2、微服务和springCloud之间的关系？
如果说springCloud就是微服务这是不正确的，springCloud其实是一个工具集，将解决微服务中出现的各种问题的插件集成到一起，形成了一个整套的解决方案，这些解决方案偏向于服务治理等。
除此之外还有很多的其他工具如springCloudAlibaba等，都是很好的解决微服务问题的工具。
3、什么是微服务？
微服务就是一种分布式架构，本质就是将单体服务拆分中一个一个的独立运行的小工程，这些小的工程如订单系统、商品系统等运行在不同的服务器中，这些独立运行的小工程就是微服务。
使用了微服务之后我们需要解决一些列的问题？
问题1：微服务之间怎么知道彼此的存在，我们可以通过注册中心将每个微服务的信息注册到注册中心，注册中心可以使用Eureka或Nacos等。
问题2：各个独立运行的微服务之间如何进行通信，我们可以使用RestTemplate或openfeign
问题3：当微服务特别多的时候，各个微服务都有配置文件，如何统一管理这些配置文件，我们可以使用配置中心，将配置都放置在同一个地方如git中，通过配置中心统一加载。
问题4：使用了微服务之后，就会出现在分布式系统下的一些问题，如分布式的id,分布式锁，分布式事务等问题，我们需要使用到分布式相关的技术。
问题5：使用了微服务之后，一个项目会出现很多的微服务，这个时候项目的部署是一个非常麻烦的事情，为了方便，我们可以使用Jekins等实现自动化部署等。
问题6：使用了微服务之后，我们的服务部署在不同的服务上，不同的IP和不同的端口会为我们的方位带来一定的困扰，这个时候我们可以使用网关服务如zuul,gateway等技术解决这些问题。
2、案例中的微服务结构 重点1：我们创建二个微服务，一个订单系统，一个商品系统，并将这两个系统注册到注册中心EurekaServer中。这个时候我们需要解决OrderServer订单系统与GoodsServer商品系统的通信问题，我们可以通过二中方式解决通信问题，第一：RestTemplate,第二：OpenFeign。
重点2：我们在GoodsServer商品系统中创建deductStock方法模拟减库存，在OrderServer订单系统中创建createOrder方法模拟创建订单。然后在createOrder中调用deductStock方法。
3、创建EurekaServer 3.1、创建工程并导入包信息 核心包：
spring-cloud-starter-netflix-eureka-server
spring-boot-starter-web
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.1.7&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.txc&lt;/groupId&gt; &lt;artifactId&gt;eurekaserver0828&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eurekaserver0828&lt;/name&gt; &lt;description&gt;eurekaserver0828&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;spring-cloud.version&gt;2022.0.4&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfda4207839cd699bc197099537b790a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e326404d183be69e8f15f87ab10dd663/" rel="bookmark">
			springboot(ssm社区疫情管理系统 疫情防控管理系统Java系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot(ssm美食网站 网上点餐系统 外卖点餐Java系统
开发语言：Java
框架：ssm/springboot + vue
JDK版本：JDK1.8（或11）
服务器：tomcat
数据库：mysql 5.7（或8.0）
数据库工具：Navicat
开发软件：eclipse//idea
依赖管理包：Maven
如需了解更多代码细节或修改代码功能界面，本人都能提供技术支持。（声音嘎嘎好听喔！）
祝你早日找到合适的代码哦～
注：主页千套源码&amp;文档，文章最下方获取源码哦
package com.controller; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import com.annotation.IgnoreAuth; import com.baomidou.mybatisplus.mapper.EntityWrapper; import com.entity.TokenEntity; import com.entity.UserEntity; import com.service.TokenService; import com.service.UserService; import com.utils.CommonUtil; import com.utils.MPUtil; import com.utils.PageUtils; import com.utils.R; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e326404d183be69e8f15f87ab10dd663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18651383e1606546ee545b79a691354b/" rel="bookmark">
			探索设计模式的魅力：一次设计，多次利用，深入理解原型模式的设计艺术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原型模式是一种设计模式，属于创建型模式的一种，它用于创建重复的对象，同时又能保持性能。在原型模式中，通过复制现有对象的原型来创建新对象，而不是通过实例化类来创建对象。这样做可以避免耗费过多的资源开销，特别是在对象的创建过程比较复杂或耗时的情况下。
在原型模式中，原型对象实现一个克隆方法（Clone）用于复制自身，当需要创建新对象时，就可以通过克隆原型对象来得到一个新的对象副本。原型模式通常包括浅拷贝和深拷贝两种形式，浅拷贝只复制对象本身，而深拷贝则会连同对象引用的其他对象一起复制，因此能够得到完全独立的新对象。
原型模式可以在需要大量创建相似对象的场景中发挥作用，它能够提高对象的创建效率，同时也能够减少对类的直接依赖，使系统结构更灵活。
关键角色有两个：
原型（Prototype）：定义用于复制现有对象的接口，通常包含一个克隆方法，用于返回一个克隆对象。具体原型（Concrete Prototype）：实现原型接口，实现克隆方法来复制自身。 优点：
减少对象创建时间：原型模式通过复制现有对象来创建新对象，避免了昂贵的对象创建过程，特别是在需要频繁创建相似对象时，可以大大减少对象创建的时间和开销。简化对象创建过程：原型模式封装了对象的创建过程，客户端无需关心具体的创建细节，使得对象创建变得更加简单，提高了系统的可维护性和扩展性。动态增加或减少原型：原型模式允许动态地添加或删除原型，使得系统更加灵活，能够根据需求动态创建新的原型对象。 缺点：
需要理解原型对象：在使用原型模式时，需要确保原型对象的克隆方法能够正确地复制对象的状态，有时需要深度复制而不是浅复制，这需要额外的处理和理解。难以保持一致性：原型模式可能会造成系统中的一些对象克隆出来之后状态难以保持一致，特别是涉及到对象之间的引用关系时，需要特别小心处理。 本质体现了两个关键点：
原型：具备复制能力的对象，它是创建新对象的模板。原型可以是一个接口、抽象类或具体类，关键是它需要提供克隆自身的方法。克隆：根据原型对象复制出来的新对象。克隆过程可以是浅复制（只复制对象本身）或者深复制（复制对象和其引用的对象）。 原型模式的本质是通过复制现有对象来创建新对象，从而封装了对象的创建过程，提供了一种灵活、高效的对象创建方式。
目录
一、案例
1.1 不用模式来实现
1.2 有何问题
1.3 原型模式重构代码
1.4 完美实现 三、模式讲解
3.1 功能
3.2 原型模式的结构和说明
3.3 几种工厂模式总结
一、案例 场景：前段时间有一个考试，发现在一个教室里考试的试卷有ABCDEFG卷，座位上前后左右人的卷子跟我的都不一样。考完后听老师说，ABCDEFG卷的题目是一样的，意思就是题目是一样的，题目的顺序是打乱的甚至同一个题的选项的顺序也是打乱的。
下面我们从无到有来感受原型模式的设计艺术。
1.1 不用模式来实现 选择题类：
@Data public class ChoiceQuestion { /** * 选择题题目 */ private String title; /** * 选项 */ private Map&lt;String, String&gt; options; /** * 答案 */ private String key; public ChoiceQuestion(){} public ChoiceQuestion(String title, Map&lt;String, String&gt; options, String key) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18651383e1606546ee545b79a691354b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ab4ff7a2621d7088ce72c2ea04188f/" rel="bookmark">
			WPF行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：实现按钮鼠标移动到上方有点交互效果或变一下有阴影。这样使用触发器就行了，但是如果是每个控件都有效果的话使用行为更加合适
1、下载NuGet包：Microsoft.xaml.behavior.wpf
2、创建行为类EffectBehavior，对Behavior进行重写
public class EffectBehavior : Behavior&lt;FrameworkElement&gt; { protected override void OnAttached() { base.OnAttached(); // 这个时候的AssociatedObject就是FrameworkElement，因为泛型传过去了 AssociatedObject.MouseMove += AssociatedObject_MouseMove; // 鼠标进入 AssociatedObject.MouseLeave += AssociatedObject_MouseLeave; } private void AssociatedObject_MouseLeave(object sender, System.Windows.Input.MouseEventArgs e) { var element = sender as FrameworkElement; // 设置效果 element.Effect = (Effect)new DropShadowEffect() { Color = Colors.Transparent, ShadowDepth = 0 }; } private void AssociatedObject_MouseMove(object sender, System.Windows.Input.MouseEventArgs e) { var element = sender as FrameworkElement; element.Effect = (Effect)new DropShadowEffect() { Color = Colors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ab4ff7a2621d7088ce72c2ea04188f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb30bece4d0f79f22748613f46700fa/" rel="bookmark">
			腾讯云香港云主机cn2网路线路说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云香港轻量线路国际中国电信cn2高速网络。腾讯云轻量服务器电信移动联通三网测速（腾讯云中国大陆地域是多线BGP高速线路，所以访问速度不用担心），如果是香港地域的轻量服务器，国内访问会不会绕路呢？阿腾云atengyun.com测试了一下，国内电信移动联通三网直连，网络延迟可以参考下表：
腾讯云香港30M、20M峰值带宽配置，特价 https://curl.qcloud.com/oRMoSucP
线路最快节点最慢节点平均响应电信9ms100ms40.2ms多线11ms215ms69.3ms联通20ms114ms66.8ms移动32ms53ms40ms海外2ms230ms50.7ms 阿腾云atengyun.com之前测试过某云的轻量应用服务器，国内联通和移动是直连的，电信绕路ntt，腾讯云的轻量应用服务器香港节点表现很不错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8114569d5460857c5f75a8a75b55cfcf/" rel="bookmark">
			web项目功能案例总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Common模块 Utils org.springframework.util.StringUtils;
登录 基于口令 outh2.0 QQ、微信、github等登录微软
分布式单点登录 mall: 客户端保留用户token，通过请求发送回来，当前用户信息保存在Redis中
redis中
设置REDIS_DATABASE + ":" + REDIS_KEY_AUTH_CODE + ":" + telephone为authKey的key(验证码)
设置REDIS_DATABASE + ":" + REDIS_KEY_MEMBER + ":" + member.getId()为member对象的key
需要获取当前用户的时候，从前端传来的token转换成userDto对象，用userDto.getId()得到memberId，然后拼接成Redis中的key获取到member
管理/授权 绪论 主流的权限模型主要分为以下五种：
ACL模型：访问控制列表DAC模型：自主访问控制MAC模型：强制访问控制ABAC模型：基于属性的访问控制RBAC模型：基于角色的权限访问控制 主体：用户
客体：对象
Access Control List，ACL是最早的、最基本的一种访问控制机制，是基于客体进行控制的模型，在其他模型中也有ACL的身影。为了解决相同权限的用户挨个配置的问题，后来也采用了用户组的方式。
原理：每一个客体都有一个列表，列表中记录的是哪些主体可以对这个客体做哪些行为，非常简单。
缺点：当主体的数量较多时，配置和维护工作就会成本大、易出错。
Discretionary Access Control，DAC是ACL的一种拓展。
原理：在ACL模型的基础上，允许主体可以将自己拥有的权限自主地授予其他主体，所以权限可以任意传递。
例如：常见于文件系统，LINUX，UNIX、WindowsNT版本的操作系统都提供DAC的支持。
缺点：对权限控制比较分散，例如无法简单地将一组文件设置统一的权限开放给指定的一群用户。主体的权限太大，无意间就可能泄露信息。
Mandatory Access Control，MAC模型中主要的是双向验证机制。常见于机密机构或者其他等级观念强烈的行业，如军用和市政安全领域的软件。
原理：主体有一个权限标识，客体也有一个权限标识，而主体能否对该客体进行操作取决于双方的权限标识的关系。
例如：将军分为上将&gt;中将&gt;少将，军事文件保密等级分为绝密&gt;机密&gt;秘密，规定不同军衔仅能访问不同保密等级的文件，如少将只能访问秘密文件；当某一账号访问某一文件时，系统会验证账号的军衔，也验证文件的保密等级，当军衔和保密等级相对应时才可以访问。
缺点：控制太严格，实现工作量大，缺乏灵活性。
Attribute-Based Access Control，能很好地解决RBAC的缺点，在新增资源时容易维护。
原理：通过动态计算一个或一组属性是否满足某种机制来授权，是一种很灵活的权限模型，可以按需实现不同颗粒度的权限控制。
属性通常有四类：
主体属性，如用户年龄、性别等；客体属性，如一篇文章等；环境属性，即空间限制、时间限制、频度限制；操作属性，即行为类型，如读写、只读等。 Role-Based Access Control，核心在于用户只和角色关联，而角色代表对了权限，是一系列权限的集合。
RBAC三要素：
用户：系统中所有的账户角色：一系列权限的集合（如：管理员，开发者，审计管理员等）权限：菜单，按钮，数据的增删改查等详细权限。 在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。
优点：便于角色划分，更灵活的授权管理；最小颗粒度授权；
RBAC模型可以分为：RBAC0、RBAC1、RBAC2、RBAC3 四个阶段，一般公司使用RBAC0的模型就可以。另外，RBAC0相当于底层逻辑，后三者都是在RBAC0模型上的拔高。
RBAC0模型 用户和角色、角色和权限多对多关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8114569d5460857c5f75a8a75b55cfcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d689c3ea39e77131d760b1c9a11e6b/" rel="bookmark">
			Maven应用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没加载出来就reimport，这个时候clean和install没用，那是编译安装项目的。
reimport干了什么？ 结合idea的maven教程
父子模块 子模块不需要groupId
ruoyi中父模块还添加了子模块的依赖，，， 先安装父再是子？dubbo官网案例：
为了成功编译服务端、消费端模块，需要先在本地打包安装 dubbo-samples-spring-boot-interface 模块。
./mvnw clean install -pl 1-basic/dubbo-samples-spring-boot ./mvnw clean install -pl 1-basic/dubbo-samples-spring-boot/dubbo-samples-spring-boot-interface Maven多模块开发 曾经我们在一个应用（一个war or jar）中划分出包(层是以包的层次结构划分的)。随着项目体积的逐渐增大，项目结构逐渐横向扩张变得臃肿（短粗）：
单个java文件逐渐变得很长，同一包下的文件变得很多，但项目结构已定，改变结构很费功夫；pom.xml中的依赖列表也越来越长，到后来你根本就不清楚哪个依赖是谁需要的，渐渐的，很多不必要的依赖被引入。甚至出现了一个依赖有多个版本存在。这个应用可能需要有一个前台和一个后台管理端，你发现大部分dao，一些service，和大部分util在其他应用中可以用； 如果其他项目不能引用这些代码，则不得不重写一遍； build整个项目的时间越来越长，尽管你只是一直在web层工作，但你不得不build整个项目。某个模块，比如util，你只想让一些经验丰富的人来维护，可是，现在这种情况，每个开发者都能修改，这导致关键模块的代码质量不能达到你的要求。你不得不新建一个项目依赖这个WAR，这变得非常的恶心，因为在Maven中配置对WAR的依赖远不如依赖JAR那样简单明了，而且你根本不需要org.myorg.app.web。
项目发展到如此庞大的水平，老一套结构已经不符合高内聚、低耦合的标准了。为了给项目“减肥”，同时进一步粒化拆分模块，我们需要“增高”，即经典的“加一层”思想。现在是以包的形式分层，再加一层就是应用之间能够互相引用（或者说依赖），也就是jar包级别之间的依赖。同时，由于传统的jar包引入方式不利于维护，pom.xml文件太长也需要拆分，我们使用maven进行分模块开发，顺便还解决了编写部分代买需要编译全部项目的问题。
一个简单的Maven模块结构是这样的： ---- app-parent |-- pom.xml (pom) | |-- app-util | |-- pom.xml (jar) | |-- app-dao | |-- pom.xml (jar) | |-- app-service | |-- pom.xml (jar) | |-- app-web |-- pom.xml (war) 较好的描述
配置文件随意，会在作用域内按优先级生效。我猜是就近原则
变量的就近原则和编译原理有关系吗？是在内存中顺序寻找最近的么？但内存是可以随即存取的把。 springboot多模块简单来说，就是把按包分模块的模式，借助maven升级到jar的方式，抽象性更加强了，假如jar再升级到到war或者多个集合jar，就成微服务了，在多模块jar模式下可以将某个jar拿出来对外共用，能大大提高代码复用率与开发效率。
https://zhuanlan.zhihu.com/p/345682526
父模块 创建时选择：
maven pom
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d689c3ea39e77131d760b1c9a11e6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1b48961654b5ddaf85901f6d239a1d/" rel="bookmark">
			基于springboot的福泰轴承股份有限公司进销存系统论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路，源码文章末
文章目录 一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 一、项目介绍 使用旧方法对福泰轴承股份有限公司进销存系统的信息进行系统化管理已经不再让人们信赖了，把现在的网络信息技术运用在福泰轴承股份有限公司进销存系统的管理上面可以解决许多信息管理上面的难题，比如处理数据时间很长，数据存在错误不能及时纠正等问题。这次开发的福泰轴承股份有限公司进销存系统对仓库人员管理、字典管理、公告管理、供应商信息管理、客户管理、商品管理、商品出入库管理、商品销售管理、销售人员管理、商品退货管理、管理员管理等进行集中化处理。经过前面自己查阅的网络知识，加上自己在学校课堂上学习的知识，决定开发系统选择小程序模式这种高效率的模式完成系统功能开发。这种模式让操作员基于浏览器的方式进行网站访问，采用的主流的Java语言这种面向对象的语言进行福泰轴承股份有限公司进销存系统程序的开发，在数据库的选择上面，选择功能强大的Mysql数据库进行数据的存放操作。福泰轴承股份有限公司进销存系统的开发让用户查看商品信息变得容易，让管理员高效管理商品信息。
关键词：福泰轴承股份有限公司进销存系统；商品信息；公告；自助资讯
二、开发环境 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 福泰轴承股份有限公司进销存系统具有管理员角色，用户角色，这几个操作权限。
福泰轴承股份有限公司进销存系统针对管理员设置的功能有：添加并管理各种类型信息，管理用户账户信息，管理商品信息，管理公告信息等内容。
福泰轴承股份有限公司进销存系统针对用户设置的功能有：查看并修改个人信息，查看商品信息，查看公告信息等内容。
福泰轴承股份有限公司进销存系统针对管理员设置的功能有：添加并管理各种类型信息，管理用户账户信息，管理商品信息，管理公告信息等内容。
福泰轴承股份有限公司进销存系统针对用户设置的功能有：查看并修改个人信息，查看商品信息，查看公告信息等内容。
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @RequestMapping(value = "/caiwu") public class CaiwuController { @Resource private CaiwuService caiwuService; @PostMapping public Result&lt;Caiwu&gt; add(@RequestBody CaiwuVo caiwu) { caiwuService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1b48961654b5ddaf85901f6d239a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ffa4ef439ed25f79fe12fb29b5b5e5/" rel="bookmark">
			基于springboot的房屋租赁管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路，源码文章末
文章目录 一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 一、项目介绍 房屋租赁管理系统管理系统按照操作主体分为管理员和用户。管理员的功能包括报修管理、字典管理、租房房源管理、租房评价管理、房源租赁管理、租房预约管理、论坛管理、公告管理、投诉建议管理、用户管理、租房合同管理、管理员管理。用户的功能等。该系统采用了Mysql数据库，Java语言，Spring Boot框架等技术进行编程实现。
房屋租赁管理系统管理系统可以提高房屋租赁管理系统信息管理问题的解决效率，优化房屋租赁管理系统信息处理流程，保证房屋租赁管理系统信息数据的安全，它是一个非常可靠，非常安全的应用程序。
关键词：房屋租赁管理系统管理系统；Mysql数据库；Java语言
二、开发环境 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 房屋租赁管理系统管理系统根据使用权限的角度进行功能分析，并运用用例图来展示各个权限需要操作的功能。
图4.1即为设计的管理员功能结构，管理员权限操作的功能包括管理公告，管理房屋租赁管理系统信息，包括房源管理，报修管理，报修管理，公告管理等，可以管理投诉建议。
图4.1 管理员功能结构
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @RequestMapping(value = "/caiwu") public class CaiwuController { @Resource private CaiwuService caiwuService; @PostMapping public Result&lt;Caiwu&gt; add(@RequestBody CaiwuVo caiwu) { caiwuService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ffa4ef439ed25f79fe12fb29b5b5e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11482ec3d5a200f4e54007e7b157e67f/" rel="bookmark">
			开始学习vue2基础篇（指令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 内容渲染指令
&gt; {{}} 模板渲染（模板引擎）
1. {{数据绑定}}
2. {{简单计算}}
3. {{简单逻辑运算}}（三元运算）
4. {{做简单 js 判断}}
注意：不能写语句、不能解析 html 渲染、不能放在在属性身上
&gt; v-text
设置标签的内容，元素的 innerText 必须是双标签
默认会替换标签内原来的全部内容，使用｛｛｝ ｝可替换指
定内容
支持内部写表达式
代码：
v-html
设置标签的内容，元素的 innerText 必须是双标签
会解析 HTML 标签
代码：
解析文本要使用 v-text,解析带有 html 标签的使用
二、属性绑定指令
&gt; v-bind
² 语法：V-bind:属性名=“挂载的数据 ”
² 简写 ：属性名= ”挂载的数据 ”
² 解析属性,单向的数据绑定
代码：
&lt;div id="box"&gt;
&lt;img v-bind:src="imgSrc" alt=""&gt;
&lt;img :src="imgSrc" :title="imgTitle+'！！！'"alt=""&gt; &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script src="vue.js"&gt;&lt;/script&gt;
&lt;script&gt;
new Vue({
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11482ec3d5a200f4e54007e7b157e67f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a6df69b6074980ca4da0944c5c8a36/" rel="bookmark">
			mysql进阶-执行计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 概念
2. 使用
3. 具体相关字段含义
3.1 id
3.2 select_type
3.3 table
3.4 partition
3.5 type
3.6 possible_key
3.7 key
3.8 key_len
3.9 ref
3.10 row
3.11 filtered
3.12 extra
1. 概念 一条语句通过优化器之后，会生成具体的执行计划用于执行器执行sql。执行计划就是一条sql是如何在数据库执行的。我们可以通过执行计划查看一条查询sql的执行信息，例如：
1.是否使用索引
2..多表查询时查询表的顺序等等。
本文仅分享一下查询语句的执行计划。
2. 使用 方法1：可以在查询语句前添加关键字：explain,然后执行语句，示例如下：
explain select * from t_good where good_name = '香蕉' and age = 2 ; 方法2：
在navicat中选中sql语句，直接在窗口栏中点击【解释】按钮，示例：
建议使用方法2。
3. 具体相关字段含义 执行explain之后会得到如下结果：
具体的含义如下：
3.1 id 是一个查询序列号,也代表着语句的执行顺序。
执行顺序：id不同，从大到小，id相同，从上到下。
3.2 select_type 主要有 4 种取值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a6df69b6074980ca4da0944c5c8a36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c8f1fe34b4907e7fc74d5ed446492c/" rel="bookmark">
			【ASP.NET Core 基础知识】--依赖注入（DI）--什么是依赖注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖注入（Dependency Injection，简称DI）是一种设计模式，用于解耦和管理类之间的依赖关系。它的核心思想是将原本需要在代码中显式创建的依赖关系，交给外部容器进行控制和管理。
具体来说，依赖注入的实现方式是通过将依赖对象的创建和维护责任转移到外部容器中，使得类不需要自己实例化，而是通过外部容器进行注入。这样，类之间的依赖关系就被解耦了，代码的可维护性和可测试性也得到了提高。
依赖注入的优点包括：降低类之间的耦合度，提高代码的可读性和可维护性，方便进行单元测试，以及支持运行时的动态配置。
依赖注入是一种重要的软件设计模式，可以帮助我们更好地组织和管理代码，提高程序的可扩展性和可维护性。
一、依赖注入的原理 依赖注入（Dependency Injection，简称DI）的原理是将依赖关系从代码中抽离出来，交给外部容器进行管理，并通过容器向对象提供所需的其他对象。具体来说，依赖注入的实现原理是通过以下步骤实现的：
声明依赖： 在代码中声明需要哪些依赖对象。这通常是通过注解、XML配置文件或编程方式来完成的。**创建对象： **容器负责创建对象和依赖关系。当需要创建一个对象时，容器会检查该对象是否已经创建，如果没有创建，则创建该对象并注入所需的依赖。提供依赖： 容器将所需的依赖注入到需要依赖的对象中。这通常是通过调用对象的方法或将依赖对象设置为对象的属性来完成的。使用依赖： 对象可以使用注入的依赖对象。在对象的方法中，可以使用注入的依赖对象来完成所需的操作。 通过依赖注入，对象不需要知道依赖对象的具体实现，只需要知道依赖对象的接口即可。这样，对象之间的依赖关系就被解耦了，代码的可维护性和可测试性也得到了提高。
依赖注入的原理是将依赖关系的创建和管理从代码中抽离出来，交给外部容器进行控制和管理，从而实现对象之间的解耦和依赖关系的管理。
二、依赖注入的优点 依赖注入（Dependency Injection，简称DI）的优点主要包括以下几个方面：
降低耦合度： 依赖注入可以将类之间的依赖关系解耦，使得类之间的依赖关系更加灵活，便于维护和扩展。提高可测试性： 依赖注入使得类之间的依赖关系更加清晰，可以方便地进行单元测试，提高了代码的可测试性。增加代码复用性： 通过依赖注入，可以使得不同的类使用同一接口，从而实现代码的复用和灵活性。简化代码： 使用依赖注入可以减少代码中的冗余，使代码更加简洁、清晰。支持运行时动态配置： 依赖注入可以在运行时动态地改变依赖关系，使得应用程序更加灵活和可配置。提高了程序的可扩展性： 依赖注入的使用可以使程序更加容易扩展，因为每个组件都是可替换的，而且无需改动代码。 依赖注入的优点包括降低耦合度、提高可测试性、增加代码复用性、简化代码、支持运行时动态配置和提高程序的可扩展性等方面。使用依赖注入可以使程序更加灵活、可维护和可扩展。
三、依赖注入的实现方式 在C#中，依赖注入可以通过多种方式实现，以下是其中几种常见的实现方式：
构造函数注入（Constructor Injection）
构造函数注入是将依赖对象作为构造函数的参数传递给需要依赖的对象。这种方式可以确保依赖对象在对象创建时就被正确地初始化。例如： public class CustomerService { private readonly IEmailService _emailService; public CustomerService(IEmailService emailService) { _emailService = emailService; } // ... } 属性注入（Property Injection）
属性注入是将依赖对象通过属性的方式注入到需要依赖的对象中。这种方式可以在对象创建后动态地注入依赖对象。例如： public class CustomerService { private IEmailService _emailService; [Dependency] public void Configure(IEmailService emailService) { _emailService = emailService; } // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c8f1fe34b4907e7fc74d5ed446492c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5cec1af47ff77859362d0a03f51c519/" rel="bookmark">
			《WebKit 技术内幕》学习之四（3）： 资源加载和网络栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3. 网络栈
3.1 WebKit的网络设施
WebKit的资源加载其实是交由各个移植来实现的，所以WebCore其实并没有什么特别的基础设施，每个移植的网络实现是非常不一样的。
从WebKit的代码结构中可以看出，网络部分代码的确比较少的，它们都在目录“WebKit/Source/WebCore/platform/network”中。主要是一些HTTP消息头、MIME消息、状态码等信息的描述和处理，没有实质的网络连接和各种针对网络的优化。
3.2 Chromium网络栈
（1）“net“所包含的主要子目录，是chromium网络栈的主要模块。要实现一些基础的部分，如 HTTP 协议、DNS 解析等模块，还包括一些为了减少网络时间而引入的新技术（如 SPDY、QUIC 等）。
（2）网络栈结构
在“Net”目录下的子目录，包含了主要的子模块，如下图描述了从URLRequest类到Socket类之间的调用过程。以HTTP协议为例，图中列出了建立TCP的Socket连接过程中涉及的类。
URLRequest类被上层调用并启动请求的时候，它会根据URL的“scheme”来决定需要创建什么类型的请求，“scheme”也就是URL的协议类型，如：“http://"、“file://”·，也可以是自定义的scheme，例如Andriod系统的”file://andriod_asset/“。URLRequest对象创建的是一个URLRequestJob子类的一个对象，例如图形的中的URLRequestHttpJob类。为了支持自定义的scheme处理方式，Chromium使用工厂模式。URLRequestJob类和它的工厂类URLRequestJobFactory的管理工作都由URLRequestJobManager类负责。基本思路是，用户可以在该类中注册多个工厂，当有URLRequest请求时，先由工厂检查它是否需要处理该类“scheme”，如果没有，工厂管理类继续交给下一个工厂类来处理。最后，如果没有任何工厂能够处理，Chromium则交给内置的工厂来检查和处理是否为“http://”、“f'tp://”或者“file://”等。当URLRequestHttpJob对象被创建后，该对象首先从Cookie管理器中获取与该URL相关的信息。之后，它同样借助于HttpTransactionFactory对象创建一个HttpTransaction对象来表示开启一个HTTP连接的事务（当然这里的概念不同于数据库中的事务概念）。通常情况下，HttpTransactionFactory对象对应的是一个它的子类HttpCache对象。HttpCache类使用本地磁盘缓存机制，如果该请求对应的回复已经在磁盘缓存中，那么Chromium无需再建立HttpTransaction来发起连接，而是直接从磁盘中获取即可。如果磁盘中没有该URL的缓存，同时如果目前该URL请求对应的HttpTransaction已经建立，那么只要等待它的回复即可。当这些条件都不满足的时候，Chromium实际上才会真正创建HttpTransaction对象、HttpNetworkTransaction类使用HttpNetworkSession类来管理连接会话。HttpNetworkSession类通过它的成员HttpStreamFactory对象来建立TCPSocket连接，之后Chromium创建HttpStream对象。HttpStreamFactory对象将和网络之间的数据读写交给自己新创建的一个HttpStream子类的对象来处理。套接字的建立，Chromium中与服务器建立连接的套接字是StreamSocket类，它是一个抽象类，在POSIX系统和Windows系统上有着分别不同的实现。同时为了支持SSL机制，StreamSocket类还有一个子类----SSLSocket。 （3）代理
用户代理由以下几个类来处理：
Proxy Service：对于一个URL，HttpStreamFactory类使用ProxyService类来获取代理信息。ProxyService类首先会检查当前代理设置不是最新的。如果不是，它依赖ProxyConfigService来重新获取代理信息。该类不处理实际任务，而是使用ProxyReslover类来做实际代理工作。Proxy Config Service：获取代理信息的类，可获得平台上的代理设置，在Linux】Windows上有不同的实现。ProxyScriptFetcher：Chromium支持代理的JavaScript脚本，该类负责从代理的URL中获取该脚本。Proxy Resolver：实际负责代理的解释和执行，通常启用新的线程来处理，因为当前可能会被域名的解析所阻碍。ProxyResolverV8：ProxyResolver的子类，使用V8引擎来解析和执行脚本。 （4）域名解析（DNS）
通常情况下，用户都是使用域名来访问网络资源的，所以在建立TCP连接前需要解析域名。Chromium中使用HostResolverImpl类来解析域名，具体调用的函数时“getaddrinfo()”,该函数是一个阻塞式的函数，所以Chromium理所当然使用单独的线程来处理它，这是Chromium的原则之一。
为了保证效率，使用HostCache类来保存解析后的域名，最多时会有多达1000个域名和地址映射关系会被存储起来。
3,3 磁盘本地缓存
浏览器的缓存机制能够提高网页的加载速度。
（1）特性
虽然需要缓存的资源可能很多，但磁盘空间不是无限大的，所以必须要有相应的机制来移除合适的缓存资源，以便加入新的资源。能够保证在浏览器崩溃时不破坏磁盘文件，至少能够保护原先在磁盘中的数据。能够高效和快速地访问磁盘中现有的数据结构，支持同步和异步两种访问方式。能够避免同时存储两个相同的资源。能够很方便地从磁盘中删除一个项，同时可以在操作一个项的时候不受其他请求的影响。磁盘不支持多线程访问，所以需要把所有磁盘缓存的操作放入单独的一个线程。升级版本时，如果磁盘缓存的内部存储结构发生改变，Chromium仍然能够支持老版本的结构。 （2）结构
实现上主要有两个类，Backend（整个磁盘缓存） 和 Entry（表中的表项）。至少需要一个索引文件和四个数据文件。索引文件用来索引，数据文件又称块文件。缓存通常是一个表，对于整个表的操作作用在 Backend 类上，包括创建表中的一个个项，每个项由关键字来唯一个确定，这个关键字就是资源的 URL。对于项目内的操作包括读写都是由 Entry 类来处理。
Backend 类表示整个磁盘缓存，是所有磁盘缓存操作的主入口，表示一个缓存表。Entry 类指的是表中的表项，表项的结构分为两个部分。 表和表项如何组织和存储在磁盘上：至少有一个索引文件和四个数据文件（块文件），每个块文件的大小是固定的，当资源文件超过某个块的大小就会为其分配多个块来解决，但最多不能超过四个块，超过四个块能存储的时候会建立单独的文件来保存。如果一个表项需要分配四个块则这些块在文件中的索引位置是对齐的（起始块的位置是4 的倍数）
索引文件：用来检索存放在数据文件中的众多索引项，用来索引表项，包括一个索引头部和索引地址表。直接将文件映射到内存地址。头部用来表示该索引文件的信息，如索引文件版本号、索引项数量、文件大小等。索引地址表：保存各个表项对应的索引地址。该索引文件直接将文件映射到内存地址，这样可以快速地找到表项的索引地址。 struct NET_EXPORT_PRIVATEIndex Header{
uint32 magic；
uint32 version;
int32 num_entries; //nuimuber entries currently stored.
int32 num_bytes; //Total size of the stored data.
int32 last_file; //Last external file created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5cec1af47ff77859362d0a03f51c519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52f08a9ed4f0a785ce2b1318e386113f/" rel="bookmark">
			数据结构：堆与堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
堆的定义：
堆的实现：
堆的元素插入：
堆元素删除：
堆初始化与销毁：
堆排序：
堆的定义： 堆是一种完全二叉树，完全二叉树定义如下：
一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。
堆分为两类：小堆和大堆。小堆是指堆中任意一个节点都值小于它的孩子节点值。同理，大推指任意一个节点的值都大于它孩子节点的值。
堆的结构：
事实上，堆在逻辑结构上可以看作是一种完全二叉树，但在内存中是以数组的方式存储的。堆内节点的下标可以在计算机内如此计算出来：
左孩子节点的下标 = 父节点的下标*2+1
右孩子节点的下标 = 父节点的下标*2+2
父节点的下标 = （子节点下标 - 1)/2
我们可以很容易看出来，堆数据的插入在逻辑上是一层一层地插入，这一层存满后再到下一层存储。
堆的实现： Typedef 数据类型 DataType struct heap { DataType* t;//堆数组内数据类型，指向第一个元素的指针 int size; //堆内元素个数 int capacity; //堆内元素容量 }hp; 堆的元素插入： 由于堆的结构特性，即小堆的双亲节点比它的子节点都要大，大堆的父节点比他的子节点都要小。因此每在数组后插入一个数据都要将这个数据调整到它应该存储的位置，这种调整在逻辑结构中是从下至上的顺序，因此也称为向上调整。
每次都与自己的双亲节点对比，在小堆中，如果双亲节点的数据大于插入的新数据，那么两节点作数据交换，依次作交换直到双亲节点数据小于该新插入的数据为止。
首先我们实现一个向上调整的代码：
void AdjustUp(HpType* a, int child) { int parent = (child - 1)/2;//先计算出当前插入数据节点的父节点下标 while(child &gt; 0) { if(a[child] &lt; a[parent]) { HpType tmp = a[child]; a[child] = a[parent]; a[parent] = tmp; //交换两节点数据 parent = child; child = (parent - 1)/2; //更新父子节点的值，使其指向下一组父子节点 } else { break; } } } 实现完调整堆的代码后，我们可以实现插入数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52f08a9ed4f0a785ce2b1318e386113f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95491c696f7b7fa11d0fcd5f5de25da/" rel="bookmark">
			html 3D 倒计时爆炸特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML5 Canvas 3D 倒计时爆炸特效DEMO演示&lt;/title&gt; &lt;link rel="stylesheet" href="css/style.css" media="screen" type="text/css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="text-align:center;clear:both;"&gt; &lt;script src="/gg_bd_ad_720x90.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="/follow.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/div&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;script src='js/dat.gui.min.js'&gt;&lt;/script&gt; &lt;script src="js/index.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; style.css代码为：
body, html { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } canvas { position:absolute; } 有两个js代码 dat.gui.min.js为：
/** * dat-gui JavaScript Controller Library * http://code.google.com/p/dat-gui * * Copyright 2011 Data Arts Team, Google Creative Lab * * Licensed under the Apache License, Version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95491c696f7b7fa11d0fcd5f5de25da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77cfaecec28dc909a1098a76cb7d4ad9/" rel="bookmark">
			WPF多值转换器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：实现Slider拖动可以调整rgb
单转换器：WPF中数据绑定转换器Converter-CSDN博客
在View中：
&lt;StackPanel Orientation="Vertical"&gt; &lt;Slider x:Name="slider_R" Minimum="0" Maximum="255" Width="200" Margin="20"/&gt; &lt;Slider x:Name="slider_G" Minimum="0" Maximum="255" Width="200" Margin="20"/&gt; &lt;Slider x:Name="slider_B" Minimum="0" Maximum="255" Width="200" Margin="20"/&gt; &lt;Path VerticalAlignment="Center" HorizontalAlignment="Center"&gt; &lt;Path.Data&gt; &lt;EllipseGeometry Center="50, 50" RadiusX="50" RadiusY="50"/&gt; &lt;/Path.Data&gt; &lt;Path.Fill&gt; &lt;MultiBinding Converter="{StaticResource rmc}"&gt; &lt;Binding ElementName="slider_R" Path="Value"/&gt; &lt;Binding ElementName="slider_G" Path="Value"/&gt; &lt;Binding ElementName="slider_B" Path="Value"/&gt; &lt;/MultiBinding&gt; &lt;/Path.Fill&gt; &lt;/Path&gt; &lt;/StackPanel&gt; -- Fill中绑定的资源是Window.Resources中引入进来的转换器key
-- 转换器返回的是一个SolidBrush，其实就是相当于在这个地方写个SolidBrush
转换器中：
public class rgbMultiConventer : IMultiValueConverter { public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture) { if (values==null || values.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77cfaecec28dc909a1098a76cb7d4ad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba31d30db9d4c1549b8d9a885e52f2e/" rel="bookmark">
			erlang （Lists 操作模块）学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		all 1&gt; lists:all(fun(X)-&gt;X&lt;4 end,[1,2,3]). true 2&gt; lists:all(fun(X)-&gt;X&lt;4 end,[1,2,3,4]). false all（Pred， List）-&gt; boolean()
如果 Pred（Elem） 对 List 中的所有元素 Elem 返回 true，则返回 true，否则返回 false。Pred 函数必须返回布尔值。
any 3&gt;lists:any(fun(X)-&gt;X&lt;4 end,[1,2,3,4]). true 4&gt;lists:any(fun(X)-&gt;X&lt;4 end,[4,5]). false all（Pred， List）-&gt; boolean()
如果 Pred（Elem） 对列表中的至少一个元素 Elem 返回 true，则返回 true。Pred 函数必须返回一个 布尔。
append 5&gt; lists:append([[1, 2, 3], [a, b], [4, 5, 6]]). [1,2,3,a,b,4,5,6] 6&gt; lists:append("abc", "def"). "abcdef" append（ListOfLists） -&gt; List1
返回一个列表，其中追加了 ListOfLists 的所有子列表。
append（List1， List2） -&gt; List3
返回一个新列表 List3，该列表由 List1 的元素后跟 List2 的元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba31d30db9d4c1549b8d9a885e52f2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20cd8b2ecc82e0e43dab37d2bd6fd0a6/" rel="bookmark">
			FPGA之分布式RAM（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1) 128 X1 Single Port Distributed RAM 下图中可以看出来,通过2个LUT的组合使用可以串联实现更大深度的分布式RAM.下图中出现了F7BMUX的加入, F7BMUX可以用于LUT输出的选通.
原语调用：
RAM128XIS#(INIT(128'h00000000000000000000000000000000) // Initial contents of RAM)RAM128XIS_inst (
.O(O),// 1-bit data output
.A0(A0),
.Al(AI),// Address[1]
.A(A2),
.A3(A3),
.A4(A4),
.A5(A5),//
Α6(A6),// Address[6] input bit
D(D),//1-bit data input
.WCLK(WCLK), //Write clock input
.WE(WE)//Write enable input); 2) 128 X 1 Dual Port Distributed RAM 128x1的双口RAM需要4个LUT实现,正好是一个SLICEM,并且分别使用了F7BMUX和F7AMUX. 原语调用：
RAM128XID#(INIT(128'h000000))
RAM128XID_inst (
.DPO(DPO),// Read port 1-bit output
.SPO(SPO)// Read/write port I-bit output
.A(A).//Read/write port 7-bit address input
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20cd8b2ecc82e0e43dab37d2bd6fd0a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889fb1f6049d6831f9512edfc87e0506/" rel="bookmark">
			Flutter 滚动布局：sliver模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、滚动布局 Flutter中可滚动布局基本都来自Sliver模型，原理和安卓传统UI的ListView、RecyclerView类似，滚动布局里面的每个子组件的样式往往是相同的，由于组件占用内存较大，所以在内存上我们可以缓存有限个组件，滚动布局时仅仅刷新组件的数据，来达到滚动布局存放无限个子组件的目标。另一方面，内容被渲染到了lazy widget里，也就是SliverList and SliverGrid (以及它们的变种 SliverFixedExtentList 和 SliverAnimatedGrid）。这些组件确保只有列表中可见部分会被布局和渲染。ListView 和 GridView只是CustomScrollView 和 SliverList 或 SliverGrid组合在一起，方便我们使用的一个封装组件而已。它们允许我们直接使用box widget。而CustomScrollView的slivers属性明确要求我们使用sliver widget。但是sliver widget也只是box widget的包裹，后者才是真正用于渲染的。按照列表内容的差异，我们可以将scrolling widget分为以下三类：
sliver widget是可滚动列表中的一部分，它是面向viewport进行布局的。
二、ViewPort ViewPort 是一个显示窗口，它内部可包含多个 Sliver；ViewPort 的宽高是确定的，它内部 Slivers 的宽高之和是可以大于自身的宽高的；ViewPort 为了提高性能采用懒加载机制，它只会绘制可视区域内容 Widget。 ViewPort 有一些重要属性：
class Viewport extends MultiChildRenderObjectWidget { /// 主轴方向 final AxisDirection axisDirection; /// 纵轴方向 final AxisDirection crossAxisDirection; /// center 决定 viewport 的 zero 基准线，也就是 viewport 从哪个地方开始绘制，默认是第一个 sliver /// center 必须是 viewport slivers 中的一员的 key final Key center; /// 锚点，取值[0,1]，和 zero 的相对位置，比如 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889fb1f6049d6831f9512edfc87e0506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f36b44dd9b3cdd1757df6b228794e6/" rel="bookmark">
			【好用的AI工具Kimi Chat】帮助提高面试效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 年前裁员潮，不少人离职找工作，以及年后金三银四，也是求职高峰期。如何更高效的复习技术知识，以及特别是横纵向比对有总结性的问题。本文以面试【测试开发】的岗位为例，对面试题进行拓展，让AI帮助我们更快速地提高复习效率。 二、使用AI工具 Kimi Chat来帮助我们做归纳和参考，提高复习效率 2.1 问题1：PO设计模式 PO（Page Object）设计模式是一种在自动化测试中常用的设计模式，特别是在使用Selenium WebDriver进行Web应用测试时。PO模式的核心思想是将Web页面的元素和操作封装成对象，使得测试脚本更加清晰、易于维护和扩展。
PO模式的主要特点包括：
页面类：为每个Web页面创建一个对应的类，这个类包含了页面上所有可操作的元素（如按钮、输入框、链接等）以及与这些元素相关的操作（如点击、输入文本等）。
元素定位器：在页面类中，每个元素都通过其唯一的定位器（如ID、Name、CSS选择器、XPath等）进行标识。这些定位器通常作为类的属性存在。
操作方法：除了元素定位器，页面类还包含了一系列操作这些元素的方法。这些方法封装了与元素交互的逻辑，如点击按钮、输入文本、获取文本等。
数据驱动：PO模式支持数据驱动测试，可以通过外部数据源（如Excel文件、数据库等）来驱动测试，使得测试脚本更加灵活。
可维护性：当Web页面发生变化时，只需在对应的页面类中更新元素定位器，而不需要修改测试脚本，这大大提高了测试脚本的可维护性。
可重用性：页面类可以被多个测试用例重用，减少了代码重复。
下面是一个简单的PO模式示例：
public class LoginPage { private WebDriver driver; private By usernameInput = By.id("username"); private By passwordInput = By.id("password"); private By loginButton = By.id("login"); public LoginPage(WebDriver driver) { this.driver = driver; } public void login(String username, String password) { driver.findElement(usernameInput).sendKeys(username); driver.findElement(passwordInput).sendKeys(password); driver.findElement(loginButton).click(); } // 其他操作方法... } 在这个例子中，LoginPage类代表了登录页面，包含了用户名和密码输入框以及登录按钮的定位器。login方法封装了登录操作的逻辑。
使用PO模式的好处是，当Web页面的布局或元素发生变化时，只需要更新页面类中的元素定位器，而测试脚本本身不需要做任何修改。这使得自动化测试更加健壮，减少了维护成本。
2.2 问题2 :自动化测试中明等待和暗等待的区别 在自动化测试中，等待机制是确保测试脚本能够正确执行的关键部分，尤其是在处理异步操作或动态加载内容时。Selenium WebDriver提供了两种主要的等待机制：显式等待（Explicit Wait）和隐式等待（Implicit Wait）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f36b44dd9b3cdd1757df6b228794e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd218d9f06dc4c6318fea45809026f11/" rel="bookmark">
			【Linux】—— 共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期我将要带大家学习的是有关进程间通信的另一种方式——共享内存。共享内存是一种用于进程间通信的高效机制，允许多个进程访问和操作同一块内存区域。
目录
（一）深刻理解共享内存
1.1 概念解释
1.2 共享内存原理
1.3 共享内存数据结构
1.4 共享内存函数
（二） 代码实现
（一）深刻理解共享内存 1.1 概念解释 共享内存区是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，它允许不同的进程通过映射同一块物理内存区域来实现数据的直接读写，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据 1.2 共享内存原理
首先大家要明白要进入通信，前提是不是得有进程，而且对于共享内存它不像匿名管道那样必须得是父子进程；对于共享内存任意两个进程之间都可以创建，其中它的通信原理，我们在思考的时候一定要先想明白，只要此时存在一个进程它就有己的PCB、它就要有自己的地址空间、它就有自己的页表；同样的对于另一个进程，在被创建的时候也要有自己的PCB、也要有自己的地址空间、那么更要有自己的页表结构好。 【解释说明】 不管是进程a还是B，这两进程当中任一个进程，它对应的都要将自己的数据，要能够映射到物理内存当中的特定区域；最终它的地址空间当中，所有的代码和数据都会经过我们对应的页表映射到我们对应的物理内存当中，进而让我们找到该进程匹配的代码和数据；对于进程B来讲它也有自己的地址空间，它也有自己的页表，最终可以映射到我们对应的内存当中的某一些特定的区域来代表它的代码或者数据；那么同样的进程a也有自己的代码和数据，包括它自己的，还有动态库等等，最后也会映射到我们物理内存当中的特定的区域 【解释说明】
第一步：我们先有一段儿我们对应的物理内存的空间；第二步：对于进程A可以把一个库加载内存映射到他这个地址空间里，然后返回给用户，或者让对应的代码区的代码直接跳转到库里面去跑，而我们如果我创建了一块儿内存，然后想办法把对应的这块儿内存经过页表映射到我们对应的地址空间当中的某一个区域；然后我把这块儿地址空间对应的区域地址返回给用户。我们这里就相当于构建从共享内存到当前进程的地址空间内的映射，然后在这里将对应空间它的起始地址返回给用户；第三步：同样的进程B，它如果也做同样的工作也将对应的这部分地址空间映射到自己的那么共享区当中，将对应的代码和数据的那个虚拟起始地址，尤其是内存块儿的起始地址返回给用户，那么未来进程A和进程B只要使用对应的起始的虚拟地址就可以访问了。此时我们不就完成了让不同的进程A和进程B看到了同一份儿资源，这就叫做共享内存！！！ 1.3 共享内存数据结构 struct shmid_ds { struct ipc_perm shm_perm; /* operation perms */ int shm_segsz; /* size of segment (bytes) */ __kernel_time_t shm_atime; /* last attach time */ __kernel_time_t shm_dtime; /* last detach time */ __kernel_time_t shm_ctime; /* last change time */ __kernel_ipc_pid_t shm_cpid; /* pid of creator */ __kernel_ipc_pid_t shm_lpid; /* pid of last operator */ unsigned short shm_nattch; /* no.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd218d9f06dc4c6318fea45809026f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff391fb4a4e31cde5c37b6c0e956679/" rel="bookmark">
			HTTPS基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 与 HTTPS 有哪些区别？ HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 HTTPS 混合加密 保证信息的机密性，解决了窃听的风险。
在通信建立前 采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。
在通信过程中全部使用 对称加密的「会话秘钥」的方式加密明文数据。
采用「混合加密」的方式的原因： 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。
2. 摘要算法（计算出内容的哈希值） + 数字签名
保证传输的内容不被篡改
公钥加密，私钥解密。 这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
私钥加密，公钥解密。 这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。（数字签名-----确认消息的身份）
私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。
3. 数字证书（防止公钥是伪造的）
可以通过哈希算法来保证消息的完整性；
可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；
但是这还远远不够，还缺少身份验证的环节，万一公钥是被伪造的呢？
参考链接
https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839e2c2c8fb310707c2b14d68d25d7f3/" rel="bookmark">
			Chrome扩展之通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chrome扩展通信 chrome扩展的5种js js类型介绍popup单击插件图标后的弹窗中的js，由于单击图标打开popup，焦点离开又立即关闭，生命周期一般很短。content-script与页面共享DOM，但是不共享JS，可访问部分chrome扩展API。background权限最高，几乎可调用所有Chrome扩展API（除了devTools），且可以无限制跨域。生命周期最长，跟随浏览器开关。injected-script通过DOM操作的方式向页面注入的一种JS，和原始页面共享js（即可访问原始页面变量，方法等），无法访问Chrome扩展API。devtools每打开一个开发者工具窗口，都会创建devtools的页面的实例，F12窗口关闭，页面也随之关闭，故devtools的生命周期和devtools窗口是一致的。可访问一组特有的DevTools API（background都无权访问）：chrome.devtools.panels（面板相关）；chrome.devtools.inspectedWindow（获取被审查窗口的相关信息）；chrome.devtools.network（获取有关网络请求信息）。 Chrome插件提供的2种额外的通信方式 chrome.tabs.sendMessage和chrome.runtime.sendMessage 用于简单的一次性请求;chrome.tabs.connect和chrome.runtime.connect，用于长时效连接。 通信接口使用限制 inject-scriptcontent-scriptpopup-jsbackgroundinject-script-window.postMessage--content-scriptwindow.postMessage-chrome.runtime.sendMessage chrome.runtime.connectchrome.runtime.sendMessage chrome.runtime.connectpopup-js-chrome.tabs.sendMessage chrome.tabs.connect-chrome.runtime.sendMessage chrome.runtime.connectbackground-js-chrome.tabs.sendMessage chrome.tabs.connectchrome.tabs.sendMessage chrome.tabs.connect-devtools-jschrome.devtools.inspectedWindow.evalchrome.runtime.sendMessagechrome.runtime.sendMessage chrome.runtime.onMessageExternal 接口用于扩展间通信，与chrome.tabs.sendMessage 用法类似。
一次性请求 一次性请求类似于HTTP请求，包含一次请求和一次返回，且如果接收方不在线，就会出现请求失败；
扩展程序（popup、background）向content-script一次性通信 //popup.js发送 function sendToContentScript(message, callback){ chrome.tabs.query({active: true, currentWindow: true}, tabs =&gt; { chrome.tabs.sendMessage(tabs[0].id, message, callback); }); } sendToContentScript({cmd:'test', value:'popup_to_content'}, res =&gt; { console.log(res) *// {res:'content_to_popup'}* } ); // content_script.js接收 chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt; { console.log(request) *// {cmd:'test', value:'popup_to_content'}* if(request.cmd === 'content_to_bg'){ sendResponse({res:'content_to_popup'}) // 若异步使用sendResponse，需添加return true* } }) 双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）
content-script主动向扩展程序（background、popup）一次性通信 // content_script.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/839e2c2c8fb310707c2b14d68d25d7f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7061e3c0ed0aa178545bc5a0020fdeb7/" rel="bookmark">
			算法训练营Day43（动态规划5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1049. 最后一块石头的重量 II 力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 提醒 本题就和 昨天的 416. 分割等和子集 很像了，可以尝试自己思考做一做。 dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: # 遍历物品 for j in range(target, stone - 1, -1): # 遍历背包 dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target] 494. 目标和 力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 提醒 重点理解 递推公式：dp[j] += dp[j - nums[i]] ， 这个公式后面的提问还会用到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7061e3c0ed0aa178545bc5a0020fdeb7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/8/">«</a>
	<span class="pagination__item pagination__item--current">9/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/10/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>