<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90c353276a4c0d309867587c2a50cf1/" rel="bookmark">
			用华为模拟器ENSP写一个完整的校园网（第一节）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先在ENSP中布局初级的网络拓扑图：
这是我的网络初步拓扑图（后序会加上代码跟其他的拓扑）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91305035643e65211f7e0a7b50a272b3/" rel="bookmark">
			JS继承以及class类继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继承的概念： 在原有的基础之上我们要进行继承，可以直接从父方法或者父类中的属性和方法，达到不用重复定义即可直接使用，就是代码的复用
ES5继承的方式有哪些？ 原型链继承：将父方法的实例化对象赋给子方法的原型，子方法既可调用父方法自身的属性和方法，还可以使用父方法原型中的属性和方法，不足地地方就是无法传递参数。
function Nation() { this.name = '张飞' this.age = '男' } Nation.prototype.skills = '当阳桥喝退百万师' Nation.prototype.poem = function() { console.log('子承父之志'); } function Address() { this.name = '张星彩' this.age = '女' } Address.prototype = new Nation() let address = new Address() console.log(address); console.log(address.name, address.age, address.skills); address.poem(); 构造函数继承 定义一个父函数和子函数，子函数通过call方法或者allpy改变指向从而实现继承效果，
父方法.call(this,参数列表)，缺点是不能使用父方法原型中的属性，可以传递参数
function Car(brand, color) { this.brand = brand this.color = color } Car.prototype.skills = '直线之王' function Knsg() { this.speed = '每小时500公里' Car.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91305035643e65211f7e0a7b50a272b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c661299e47612009b9cfb155c332ee/" rel="bookmark">
			数据结构与算法：快速幂——求幂运算 O(logN)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：普通的求幂问题，相信大家已经屡见不鲜，无非就是 纯暴力 解法，或者直接调用公式：Math.Pow(底数, 指数) 一步得出。但这两种算法只能使得时间复杂度保持在 O(n)。而且公式一步的得往往对求模问题解决不了。对最大值得限制和对时间复杂度的限制，有必要让你学习一下快速幂算法。
题目：求 m 的 n 次方，对 998244353 求余。要求时间复杂度 O(logN)。
常见方法：
1.暴力求 时间复杂度 : O(n) 。
2.数学公式
Math.Pow(m, n)；(对于求模往往会出问题）。
时间复杂度 : O(n) 。
3.快速幂算法
时间复杂度为: O(log n)。
讲解：利用公式 ,可以直接用底数的平方，指数除以2的方式，这样指数降到0只需要 log(n) 次 ，因此 时间复杂度 仅需要 O(log n) 比朴素的模拟乘方法 O(n) 优秀的多。
测试代码（c#语言）：
递归方法：
static long Recursion(long m,long n,long p) { if (n == 0) return 1; if (n == 1) return m; long part = Recursion(m, n / 2, p); //递归到最小，然后以此扩大到原数。 if(n%2==0) //判断是否n为奇数 { return part * part % p; } else { return m * part * part % p; } } 对递归函数举例解释：例如 m = 3,n=5; 第一次进入函数： n = 5， 第二次进入函数： n = 2 ( 5/2 = 2) 第三次进入函数： n = 1 ( 2/2 = 1) 返回m ，即 返回 3， 使得第二次进入函数时 part 为 3， 此时 n = 2 为偶数 ，返回 part * part 即 3*3= 9； 使得第一次进入函数时 part 为 9， 此时 n = 5 为奇数，返回 m*part*part 即 3*9*9 得243 非递归方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c661299e47612009b9cfb155c332ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81deec8c472d05cb73d702f66b3ff86c/" rel="bookmark">
			LDPC编译码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LDPC编译码 文章目录 LDPC编译码前言一、码字1.校验矩阵a.适用于matlab的校验矩阵b.适用于 C的校验矩阵c.适用于python的校验矩阵 2.生成矩阵a.基于matlab的生成矩阵构造b.基于python的生成矩阵读取c.基于python的随机码字生成 前言 低密度奇偶校验（LDPC）码是目前5G通信常用的信道编码码字的一种，其具有接近香农极限的编译码性能。本文主要记录对LDPC码研究时常用的一些网站以及便捷的一些代码介绍，如有错误欢迎指出，大家一起学习。
PS：硕士期间有幸跟随导师了解这一领域，并进行了相关的研究，故借此进行记录。
一、码字 LDPC码的编码方式有很多种，本节主要介绍实验过程中常用的一些码字。
1.校验矩阵 详情可以从ldpc码校验矩阵获取。
a.适用于matlab的校验矩阵 使用matlab进行译码的校验矩阵要求是位置索引需要从1开始，或者为完整0，1矩阵。此处给出一份python的转换代码，将位置索引从0开始的转换为从1开的。注：从上面网址中下载的校验矩阵的位置索引是从1开始的。
def gen_m_mtx(file_path,dec_path): new_mtx = [] with open(file_path,'r') as fp: lines = tuple(line for line in fp if len(line.split()) &gt; 0) max_ind = max(tuple(max(map(int, line.split())) for line in lines)) min_ind = min(tuple(min(map(int, line.split())) for line in lines)) if min_ind not in [0, 1]: raise Exception('Minimum index is not 0 or 1.') mtx = np.zeros((len(lines), max_ind + (0 if min_ind == 1 or str(max_ind) in file_path else 1)), int) if max_ind+1 == mtx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81deec8c472d05cb73d702f66b3ff86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0de678fb80a425edbbdadd3c3d7c72a/" rel="bookmark">
			2的次方对照表（作为工具用电科）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2^0 = 1
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
2^5 = 32
2^6 = 64
2^7 = 128
2^8 = 256
2^9 = 512
2^10 = 1024
2^11 = 2048
2^12 = 4096
2^13 = 8192
2^14 = 16384
2^15 = 32768
2^16 = 65536
2^17 = 131072
2^18 = 262144
2^19 = 524288
2^20 = 1048576
2^21 = 2097152
2^22 = 4194304
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0de678fb80a425edbbdadd3c3d7c72a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f30c91b16ce88ffb6ca8c7201944b15/" rel="bookmark">
			网易云音乐的 song/media/outer/url audio 链接 chrome 上可以， edge不行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网易云音乐的这个链接
https://music.163.com/song/media/outer/url?id=29023577.mp3
&lt;audio ref="audio" :src="`https://music.163.com/song/media/outer/url?id=${playlist[playCurrentIndex].id}.mp3`"&gt;&lt;/audio&gt; chrome 上可以， edge不行，放了1秒钟就没了，不过我同学的edge也行的，总之是个莫名其妙的坑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17185db8218f3ae88a4fed98f84468b8/" rel="bookmark">
			java中final，finally,finalize的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.final是一个关键字，如果我们用final来修饰属性的话，属性不可以改变，所以被final修饰的属性必须在声明的时候设置一个初始值，在之后需要用到的地方只能读取该值，不能对该属性做出改变，final修饰方法的话，方法可以被使用，但是不能被重写，final修饰类的话，类不能被继承，也就是说该类不能有子类，所以我们不能final来修饰一个抽象类。
2.finally是java的异常处理机制，我们经常会将finally语句放在try...catch...语句后面作为一种补充，因为finally语句不管代码有没有异常都会执行，这样我们可以用finally语句维护对象内部状态，清理非内存操作，例如我们可以使用finally语句来关闭流或者数据库等操作。
3.finallize方法是java.lang.Object里面定义的，因为Object是所有类的基类，所以我们可以理解为每个对象都有finalize方法，finalize的主要目的是在不可撤销的丢弃对象之前执行清除操作，对于给定的任何对象，java虚拟机最多只调用一次finalize()方法，finalize()方法是垃圾回收器删除对象之前对这个对象调用的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de6ea6bbfd9f4e891665ed4aaf660cf8/" rel="bookmark">
			手把手从vue3从下载到创建项目(IDEA版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下来自一个后端er自学vue3的经验，有不对的欢迎斧正
基础前端页面教学----vue3+elementplus+ts
新手很友好 强推
目录
下载Vue3
创建vue3项目
下载Vue3 首先需要安装node.js Node 版本要求
Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本
下载地址：Node.js (nodejs.org)
安装步骤：(329条消息) Node.js最新最详细安装教程（2020）_蜡笔小柯南的博客-CSDN博客_node
安装vue3 安装 node之后自然会自带 npm，就可以使用 npm 来安装 vue3.0
npm install vue@next 安装vue脚手架 Vue提供了一个官方CLI，可用于快速搭建 Single Page Applications。它为现代的前端工作流提供构建设置。只需几分钟就可以启动并重新运行热保存，可用于生产的构建。有关更多详细信息，请参见Vue CLI文档
yarn global add @vue/cli # OR npm install -g @vue/cli 创建vue3项目 创建项目我比较喜欢用可视化的方式来创建
首先打开cmd输入
vue ui 点击创建项目
输入项目名称 包管理器我这里选择的是npm 然后点击下一步
选择手动配置项目
勾选如下选项 Router：Vue中的路由
Linter/Formatter：可以让你的代码写的更严谨一些，通常是用来做报错提醒的
使用配置文件：将插件的配置保存在各自的配置文件中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de6ea6bbfd9f4e891665ed4aaf660cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dff0cdface8154dc7dc9b168af24635/" rel="bookmark">
			Visual Studio 创建cmake项目——opencv环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：哎，长期不用vs创建cmake项目，配置opencv都生疏了，记录一下
前提：
首先保证已经下载了opencv，我的opencv版本是4.5.5,并将其解压到你可以记住的文件夹中，如图
我将opencv解压的目录为：E:\opencv，E盘的opencv文件夹中
第一步：
前提准备好之后，需要配置环境变量，我的电脑——》右键——》属性——》高级系统设置——》环境变量——》系统变量——》path
在path中新建，配置opencv的环境（找到解压的路径）：
E:\opencv\opencv\build\bin
E:\opencv\opencv\build\x64\vc15\bin
我是vs2022所以选择vc15，不同版本，选择不同的vc，见下表：
VS 版本VC 版本VS2003VC7VS2005VC8VS2008VC9VS2010VC10VS2012VC11VS2013VC12VS2015VC14VS2017VC15 环境变量配置好之后，接下来做的就是用vs创建一个cmake项目，修改cmaklist.txt中的内容。
在cmakelist.txt中，填写如下内容：
# CMakeList.txt: CMakeProject1 的 CMake 项目，在此处包括源代码并定义 # 项目特定的逻辑。 # cmake_minimum_required (VERSION 3.8) add_executable (CMakeProject1 "CMakeProject1.cpp" "CMakeProject1.h") # 将源代码添加到此项目的可执行文件。 set(OpenCV_DIR E:/opencv/opencv/build) find_package(OpenCV REQUIRED) include_directories(${OpenCV_INCLUDE_DIRS}) link_directories(${OpenCV_LIBRARY_DIRS}) target_link_libraries(CMakeProject1 ${OpenCV_LIBS}) # TODO: 如有需要，请添加测试并安装目标。 其中CMakeProject1是创建的项目名字（默认，我没有改名字）
到这里，就可以在vs中就可以调用opencv了。
测试一下：
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; int main() { cv::Mat img = cv::imread("E:/cmake_project/CMakeProject1/CMakeProject1/imgs/1305031102.175304.png"); cv::namedWindow("test"); cv::imshow("test", img); cv::waitKey(0); } 结束！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c07b51f85dcba96d4539db718900f27e/" rel="bookmark">
			深度学习从入门到精通——基于深度学习的地震数据去噪处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统机器学习 SVM,boosting,bagging,knn 深度学习 CNN（典型）,GAN 地震应用方向 叠前地震数据随机噪声去除，实现噪声分离
面波去噪
面波作为很强的干扰波出现在地震勘探中，大大降低了地震记录的分 辨率和信噪比。深度学习作为一种数据驱动类方法, 能够从大量数据样本中 学习得到有效信号与噪声的区别, 自适应建立深度神经网络来压制噪声。
地震数据去噪与重建
去噪流程、 去噪流程 - 深度学习常规流程
数据增强 利用数据增强方面，把地震波面波数据当作二维图像数据使用那么可采用数据增强方式，噪声类型添加仿射变换与透视变换，裁剪高级一点的：mixup，dropoutblock，mosaic,mask等等 模型设计 模型设计首先清晰自己需要什么，如果我们做的是噪声去除，那么针对性的模型如下：
①目标检测类CNN模型
首先清楚，地震波数据，无非是噪声数据与我想要的真实地震数据。
含有噪声的数据 = 真实地震波 + 噪声
那么模型的任务定义为目标侦测性，寻找里面的地震波或者是噪声。相对来说，真实地震波数据无论是在求取还是在标注性上，都更容易求取。因此让模型找出噪声数据，利用原始数据-噪声数据 = 真实地震波数据。
这里的标签设置方法： 含噪数据，真实地震波数据
②图像分割类
将地震波去噪任务分解为地震波+噪声，对含有噪声的地震波进行分类，对地震波数据进行提取，进而获取真实地震波。
③超分技术（GAN）
标签设置方法： 含噪数据，真实地震波数据
利用超分的思想来做去噪任务，针对性的求取去噪后的图像。利用生成器直接对图像进行去噪，比较典型的油SRGAN。
如果对地震波的噪声类型有判断，可以采用CGAN的思想，对噪声类型可控化。通过已知噪声类型的方式对地震波进行针对性的去噪。
③无监督去噪（VAE系类）
利用编解码模型，对原始数据进行压缩成向量，再通过向量解码成真实地震波。
以前常用，实际应用性还可以，但是可解释性需要进一步探讨。
编程实战 这里采用下面博主教程里面的进行解释。
bilibili参考
对地震波数据的处理注意使用道的数据就好，其他的按照数据增强的方式走数据采样原则 满足独立同分布的原理，可以的相同区块，但是不能的不同地方的数据。数据质量&gt; 数据数量，采样质量一定要保证，数量不是最重要的。采样的标签制作，可以是（含噪数据，真实地震波），也可以是（含噪数据，噪声）分布均匀，不同情况下的噪声尽可能的考虑齐全，这样模型的鲁棒性才会比较好。针对区块，地质概况，可以针对性的制作一下。 数据展示如下 干净数据与含噪数据的展示 模型的输入与输出
地震波数据，可以定义成单通道图像，图像格式为NCHW(pytorch，paddle),NHWC(tensorflow)
输出，如果是去噪任务，理论上输出与输入应该同型号，这里利用u2net修改了一下原up主的代码进行去噪任务。
mutiunet.py import torch import torch.nn as nn from torchvision import models import torch.nn.functional as F class REBNCONV(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c07b51f85dcba96d4539db718900f27e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c94ad15ffe79873b5f9a2754aae4ba/" rel="bookmark">
			CP Editor 编辑器（为竞赛而生的编辑器）的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CP Editor 编辑器（为竞赛而生的编辑器）的安装与配置 1. CP Editor 编辑器的下载2. 配置环境变量3. 配置个人化的 CP Editor4. 配置完成测试 1. CP Editor 编辑器的下载 CP Editor 编辑器官网
点击下载，选择自己的版本
个人推荐版本：cpeditor-6.9.4-windows-x64-setup-with-gcc-11.2.0-LLVM-12.0.1.exe (184 MB)
接下来就是傻瓜式安装了（next）
等待安装成功就可以了
2. 配置环境变量 找到自己安装目录下的 bin 目录
F:\CP Editor\cpeditor\mingw64\bin这是我的目录
在环境变量中添加
点开 PATH 环境变量，添加新的路径
添加成功
验证是否配置成功
在 cmd 中输入 g++ -v 查看 g++ 版本信息
3. 配置个人化的 CP Editor 点击选项中的设置按钮
代码格式化的设置
可以选择自己适合的缩进和光标格式，以及括号是否自动补全等
C++ 配置
c++ -Wall -std=c++14 -02：用于开启 c++14 和 O2 优化
设置模板
括号补全
个性化自己的整体界面
设置自己的快捷键
设置 C++ Server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1c94ad15ffe79873b5f9a2754aae4ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7980d68f05a6a44815621b8cf4baaa/" rel="bookmark">
			新魔百盒UNT413-905L3B-当贝桌面完美线刷包-各项正常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 固件特点及说明： 1、支持多屏互动功能；
2、支持蓝牙遥控器自动配对功能；
3、更新：固件支持最新产品搭载的无线网卡
4、适配蓝牙遥控器语音直播、点播功能；
5、固件默认开启ADB，关闭ROOT权限；
6、在413A-S905L3B测试正常，其他芯片勿刷；
7、默认无线正常；
8、线刷时请去掉默认双钩。
9、默认当贝桌面和当贝市场，其他文件无添加。
10、本固件只适合主控905L3B，刷机有风险，各位需谨慎；
刷机方法： 1、打开刷机软件； 2、导入烧录包，双沟不选； 3、短接点见刷机包图（拆机短接，附件有短接示意图）；或者按reset键5秒放开也可以；
固件地址： 链接: https://pan.baidu.com/s/19ciq1CmKI5DXTSMg5svF3Q
提取码: ajv9
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1067253b7c0c729409a3381d7f4008f9/" rel="bookmark">
			使用ubuntu18.04系统集成的环境，一键配置realsenseD455的ros-melodic环境，以及卸载已经安装的realsense-ros
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先记录一个安装reaslsense-ros时候编译的问题：
error: ‘find_if’ was not declared in this scope
texture_frame_itr = find_if(frameset.begin(), frameset.end(), [&amp;texture_source_id, &amp;available_formats] (rs2::frame f)
至今没有解决，重新下载了几个版本的realsense-ros，最终在3.2版本上成功编译
如果只是使用图片信息，不使用IMU信息可以使用这个，因为系统自动安装的realsense-ros东西都安装在usr/share下了，我自己不太喜欢在这里修改文件。 卸载realsense-ros命令使用：sudo apt-get remove ros-melodic-librealsense2 使用IMU 数据，参考链接: 1.前提是先安装好realsense的驱动，安装教程：https://blog.csdn.net/hltt3838/article/details/120691764
也就是终端输入：
realsense-viewer
可以打开相机的图像。
2.安装RGBD包：sudo apt-get install ros-melodic-rgbd-launch
3.之后输入apt search melodic-realsense2
然后将找到的3个库都安装了就好了
sudo aptitude install ros-melodic-realsense2-camera sudo aptitude install ros-melodic-realsense2-description sudo aptitude install ros-melodic-realsense2-camera-dbgsym 终端打开相机并查看图像：
roslaunch realsense2_camera rs_camera.launch rosrun rqt_image_view rqt_image_view 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9398dcd833db60fd76992ac1a804ee/" rel="bookmark">
			用Python制作简单的小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		朋友们大家好，相信大部分人都喜欢玩游戏，无论是在工作间隙还是下班回家的路上，可能都会拿起手机玩游戏打发时间，亦或是在游戏中寻找乐趣，放松自己。上
我跟大家分享的内容主要是用Python的Pygame Zero模块来制作小游戏，同时推荐编程环境：Thonny（开源跨平台）。Thonny是一个跨平台的开源开发环境，自带Python解释器，体积小巧、功能齐备。扫描如下二维码，会有老师手把手教你如何安装Thonny和运用Thonny。 Thonny安装好后，进行Pygame Zero模块的安装。首先打开Thonny，点击菜单“工具”-&gt;“管理模块”，输入“pgzero” 点击搜索，最后点击“install” ，安装成功！
我们制作一个小精灵，要求点击小精灵后，会发出声音并且精灵会摔倒。第一步创建游戏角色：
• 在源代码文件目录下新建两个目录：一个是images（名字可自定义），用来存放图片文件；另一个是sounds，用来存放声音文件。
• 用Actor类创建一个精灵对象：指定图片、位置
• 在draw中画出精灵：精灵图片将出现在指定的位置alien.pos
第二步更新update：改变精灵的位置，每秒会改变60次！
import pgzrun import time #创建一个精灵 alien = Actor('alien') alien.pos = 100,56 #绘制窗口大小 WIDTH = 500 HEIGHT = alien.height + 100 #每次需要刷新窗口的时候，会自动调用draw函数 def draw(): screen.clear() screen.fill((128, 0, 0)) alien.draw() 每一帧都会调用update函数 def update(): alien.left += 2 if alien.left &gt; WIDTH: alien.left = 0 第三步与精灵的交互：pos是鼠标的位置，当点击到精灵，精灵就会摔倒，并发出“呃”的声音，1s后恢复初始状态；如果没有点击到精灵，就会打印出“快闪”二字；如果无点击行为，精灵就将一直循环移动。
def on_mouse_down(pos): if alien.collidepoint(pos): set_alien_hurt() else: print("快闪") def set_alien_hurt(): sounds.eep.play() alien.image = 'alien_hurt' print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9398dcd833db60fd76992ac1a804ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39cbec4f520c914985e63a5ac433ce68/" rel="bookmark">
			LockSupport.park 和LockSupport.unpark基本使用和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本使用
// 暂停当前线程 LockSupport.park(); // 恢复某个线程的运行 LockSupport.unpark(暂停线程对象) 特点 与 Object 的 wait &amp; notify 相比
wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify 代码:
import com.example.demo.hmjuc.Sleep; import java.util.concurrent.locks.LockSupport; /** * LockSupport.park and LockSupport.unpark * * @author zhangqi * @date 2022/5/1 18:15 */ public class Test2 { public static void main(String[] args) { Thread thread = new Thread(() -&gt; { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39cbec4f520c914985e63a5ac433ce68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e99655411f698aec2f4c0e7c1440a069/" rel="bookmark">
			Linux 系统级程序设计-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件I/O
open() read() write() lseek() close() 1.1 open函数 #include &lt;fcntl.h&gt; int open(const char *pathname, int flags[, mode_t mode); open函数参数说明：
pathname：待打开文件的文件路径名；
flags：访问模式，常用的宏有：
– O_RDONLY：只读
– O_WRONLY: 只写
– O_RDWR: 读写
– O_CREAT: 创建一个文件并打开
– O_EXCL: 测试文件是否存在，不存在则创建
– O_TRUNC: 以只写或读写方式成功打开文件时，将文件长度截断为0
– O_APPEND: 以追加方式打开文件
只有第二个参数flags = O_CREAT，第三个参数才会被用于设置新文件的权限，取值如下：
S_IRWXU: 文件所有者，读、写、执行
S_IRUSR: 文件所有者，读
S_IWUSR: 文件所有者，写
S_IXUSR: 文件所有者，执行
S_IRWXG: 文件所属组，读、写、执行
S_IRGRP: 文件所属组，读
S_IWGRP: 文件所属组，写
S_IXGRP: 文件所属组，执行
S_IRWXO: 其他人，读、写、执行
S_IROTH: 其他人，读
S_IWOTH: 其他人，写
S_IXOTH: 其他人，执行
返回值说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e99655411f698aec2f4c0e7c1440a069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa73ee0041c2985c745e68a4b414186/" rel="bookmark">
			SpringBoot2：核心配置与注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心配置与注解 一、全局配置文件介绍1. application.properties配置文件1.1 编写实体类1.1.1引申：解决Spring Boot Configuration Annotation Processor not configured 未配置Spring引导配置注释处理器以及在配置时想出现代码提示 1.2 编写application.properties1.3 编写测试类：测试是否配置成功1.4 输出结果 2. application.yaml配置文件(推荐)介绍yaml配置属性时的写法2.1 编写application.yaml2.2 测试输出 二、配置文件中配置自定义的属性值介绍1. @ConfigurationProperties注入自定义属性2. @Value注入注入自定义属性对比：@ComponentProperties 和 @Value两个注解的选择 三、自定义配置文件介绍1. 使用@PropertySource加载自定义配置文件1.1 编写配置类1.2 编写自定义配置文件1.3 编写测试类1.4 测试输出 2. @ImportResource加载xml配置文件3. @Configuration编写自定义配置类3.1 @Configuration+@Bean编写自定义配置类3.2 编写测试方法3.3 测试输出3.4 总结 一、全局配置文件 介绍 全局配置文件 可以对一些默认配置值进行修改。spring boot使用application.properties 或者 application.yaml 作为全局配置文件。=&gt; 定义spring boot项目的相关属性，包括：系统属性、环境变量、命令参数等信息，也可以是自定义配置文件名称和位置。
1. application.properties配置文件 用spring initializr构建项目时，会在src/main/resources目录下自动生成application.properties，并在项目启动时自动加载该配置文件
1.1 编写实体类 在主程序启动类所在的包下，创建domain(装实体类的包)，里面创建两个实体类：Pet和Person
编写Pet类
package com.wpz.chapter02.domain; /** * @author 王胖子 * @version 1.0 * 普通实体类：为了给Person类使用 */ public class Pet { private String type; private String name; public String getType() { return type; } public void setType(String type) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa73ee0041c2985c745e68a4b414186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6fd381aa3aa07b9a5d3bf2df6cfa69/" rel="bookmark">
			使用蓝桥杯嵌入式旧板实现LCD显示波形和幅度谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写代码时，要注意各种类型的使用。
1.
int32_t adc_data[sam_nums];//存放adc数据 存储采样数据的变量是uint16类型的
2.
获取到采样数据后,构造fft函数输入数据,
因为是采样数据,所有只有实数.fft函数的数据的高16位是实数,低16位是虚数且都为int16_t类型.
adc_data[adc_idx] = ((int32_t)uiAdc_val) &lt;&lt; 16; 执行fft函数
cr4_fft_256_stm32(fft_out,adc_data,256); fft函数的输出类型为int32_t.且只有一般数据有用.因此定义数组fft_out
int32_t fft_out[sam_nums/2];//存放fft的结果,结果为复数 获取幅度谱, 因为官网的fft函数输出与输入没有n倍关系,所以使用下面函数后,就得到了时域正弦波的幅度
void GetPowerMag(void) { int16_t lX,lY; float X,Y,Mag; uint16_t i; for(i=0; i&lt;sam_nums/2; i++) { lX = (fft_out[i] &lt;&lt; 16) &gt;&gt; 16; //获取复数的虚部 lY = (fft_out[i] &gt;&gt; 16); //获取复数的实部 //除以32768再乘65536是为了符合浮点数计算规律 X = sam_nums * ((float)lX) / 32768; Y = sam_nums * ((float)lY) / 32768; Mag = sqrt(X * X + Y * Y)*1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6fd381aa3aa07b9a5d3bf2df6cfa69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efef30189c3a7713483a4443dfd032c9/" rel="bookmark">
			教你如何设计ASP网上考试系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教你如何设计ASP网上考试系统 为了运行这个应用程序，我们需要在global.asa文件里进行设置数据库的连接。
global.asa:　&lt; SCRIPT LANGUAGE=VBScript RUNAT=Server &gt;
Sub Application_OnStart
dbPath = “DBQ=” &amp; Server.Mappath(“onlinetest.mdb”)
dbConnectionString = "DRIVER={Microsoft Access Driver (*.mdb)}; " &amp; dbPath
Set Application(“Conn”) = Server.CreateObject (“ADODB.Connection”)
Application(“Conn”).Open dbConnectionString
End Sub
Sub Application_OnEnd
Application(“Conn”).Close
Set Application(“Conn”) = Nothing
End Sub
Sub Session_OnStart
End Sub
Sub Session_OnEnd
End Sub
&lt; /SCRIPT &gt;
注册页面index.asp。其中有两个输入域：用户名和口令，这两个输入域需要客户机端的JavaScript确认，以便不把它们作为空白域来传递。非考生要想参加考试必须先注册。这个页面还要显示一些错误信息，如“用户名或口令错误”、“请重新选择一个用户名”等。注册表单中还应包含考生一些个人的信息，如Emai、年龄、教育程度等。登录后，考生就可以参答考试站点的其它试卷了。
index.asp:
if (theForm.username.value == “”)
{
alert(“考生姓名"User Name”“);
theForm.username.focus();
return (false);
}
if (theForm.password.value == “”)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efef30189c3a7713483a4443dfd032c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934fc3e38b118944154ccfbb34442b85/" rel="bookmark">
			软件测试面试题：吞吐量大幅度波动有哪些原因？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		吞吐量大幅度波动有哪些原因？ 上下文切换的过快； gc次数过于频繁； 个人简介 我是一名测试兼开发工程师，目前25K，目前做的是无人驾驶，欢迎和大家一起交流测试技术，
起高薪就业，我们还有一起打妖怪的群哦，还有面试题小程序哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4163a9fec01178a1fa3cfcbf85bd10/" rel="bookmark">
			Kafka 中 topic、partition、offset、replica、ISR 等概念详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 消息的数据结构topic 和 partition位移（offset）replicaleader 和 followerISR 先说一个题外话，就是 Kafka 名字的由来： I thought that since Kafka was a system optimized for writing using a writer’s name would make sense. I had taken a lot of lit classes in college and liked Franz Kafka. Plus the name sounded cool for an open source project.
Kafka 三位原作者之一 Jay Kreps：因为Kafka 系统的写操作性能特别强，所以找个作家的名字来命名似乎是一个好主意。我在大学时上了很多文学课，非常喜欢 Franz Kafka。另外为开源项目起 Kafka 这个名字听上去很酷。
消息的数据结构 Kafka 中的消息格式由很多字段组成，其中的很多宇段都是用于管理消息的元数据字段，对用户来说是完全透明的。Kafka 消息格式共经历过 3 次变迁，它们被分别称为 VO、V1 和 V2 版本。V1 版本消息的完整格式如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e4163a9fec01178a1fa3cfcbf85bd10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544b30b633458008b52d09a262b49f90/" rel="bookmark">
			常见通用的join查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、join的五种连接：内连接(INNER JOIN)：左向外连接(LEFT JOIN/LEFT OUTER JOIN)：右向外连接(RIGHT JOIN/RIGHT OUTER JOIN)：完整外连接(FULL JOIN)：交叉连接(笛卡尔积)(CROSS JOIN): 二、七种Join理论1.常用Join韦恩图2.mysql的Join韦恩图 提示：以下是本篇文章正文内容，下面案例可供参考
一、join的五种连接： 内连接(INNER JOIN)： 显示两个表或多个表中共有的数据，只有在两个表中匹配的行才能在结果集中出现。 左向外连接(LEFT JOIN/LEFT OUTER JOIN)： 简称左连接，即以左表为基表，显示左表所有的数据，若左表中行的数据在右表中没有相应的匹配行的话，则结果表中右表中的列返回null值。 右向外连接(RIGHT JOIN/RIGHT OUTER JOIN)： 简称右连接，即以右表为基表，显示右表所有的数据，若右表中行的数据在左表中没有相应的匹配行的话，则结果表中左表中的列返回null值。 完整外连接(FULL JOIN)： 简称全连接，即将左表和右表的所有数据全都显示，当某行在另一张表中没有匹配行，则另一表中的列返回null。 交叉连接(笛卡尔积)(CROSS JOIN): (1)、CROSS JOIN(笛卡尔积)是两个表每一个字段相互匹配， 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。 (2)、CROSS JOIN(笛卡尔积)带条件查询， 查询结果跟等值连接(内连接)(INNER JOIN连接)、where连接的查询结果是一样，并且后面加条件只能用where,不能用on。 二、七种Join理论 1.常用Join韦恩图 # 1 SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key; # 2 SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544b30b633458008b52d09a262b49f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3c0b11b4c3155c91e24c26a99b0523f/" rel="bookmark">
			qt-事件循环系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt中，如果创建的console程序,使用的是QCoreApplication对象；如果创建的是GUI程序，使用的是QApplication对象，而QApplication 继承自 QGUIApplication ，最终继承QCoreApplication，GUI是对console的封装。
QEventDispatcherWin32（win32事件调度器），主要功能是执行程序运行期间所涉及到的过程事件以及创建windows的隐藏窗口。C:\Qt\5.9.8\Src\qtbase\src\corelib\kernel\qeventdispatcher_win.cpp 创建了一个隐藏窗口
static HWND qt_create_internal_window(const QEventDispatcherWin32 *eventDispatcher) { QWindowsMessageWindowClassContext *ctx = qWindowsMessageWindowClassContext(); if (!ctx-&gt;atom) return 0; HWND wnd = CreateWindow(ctx-&gt;className, // classname ctx-&gt;className, // window name 0, // style 0, 0, 0, 0, // geometry HWND_MESSAGE, // parent 0, // menu handle GetModuleHandle(0), // application 0); // windows creation data. if (!wnd) { qErrnoWarning("CreateWindow() for QEventDispatcherWin32 internal window failed"); return 0; } #ifdef GWLP_USERDATA SetWindowLongPtr(wnd, GWLP_USERDATA, (LONG_PTR)eventDispatcher); #else SetWindowLong(wnd, GWL_USERDATA, (LONG)eventDispatcher); #endif return wnd; } QEventDispatcherWin32Private（win32事件调度器私有），主要存储了qt与windows操作系统之间的事件交互队列（用户输入事件队列、用户套接字事件队列）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3c0b11b4c3155c91e24c26a99b0523f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67eeada89b284f1328253e81c8bd803/" rel="bookmark">
			Twaver-HTML5基础学习(33)自动布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动布局 拓扑应用有时需要一些常规的布局规则，TWaver Network组件支持布局模型和使用方法分别如下:
//创建Autolayouter并绑定DataBox var autoLayouter = new twaver.layout.AutoLayouter(box); //开始布局,参数分别为布局类型和回调函数 autoLayouter.doLayout(type,callback); type为类型，callback回调函数
类型分类：
var items = ['round', 'symmetry', 'topbottom', 'bottomtop', 'leftright', 'rightleft', 'hierarchic']; 例子： react代码：
/* * @Descripttion: * @version: * @Author: ZhangJunQing * @Date: 2022-04-18 14:44:05 * @LastEditors: ZhangJunQing * @LastEditTime: 2022-04-29 15:27:48 */ import React, { useEffect, useState } from 'react' import { returnElementBoxAndNetworkFun, returnNodeFun, returnLineFun, returnRegisterImage, returnGroupFun, returnAlarmFun, ALARM4 } from './utils' const twaver = require('twaver'); // const demo = require('demo'); const Demo = () =&gt; { // const [network, setnetwork] = useState({}) const init = () =&gt; { var box = new twaver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d67eeada89b284f1328253e81c8bd803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f5624b93999ccb44a22e94ea23a37f/" rel="bookmark">
			libcamera build errors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ninja error $ sudo ninja -C build install -j 1 limit the ninja threads to 1, so that the whole OS won’t get stuck during build process.
meson error $ meson build meson.build:136.33: ERROR: Expecting eol got not. if get_option('test') and 'vimc' not in pipelines ^ refer to the github repo of libcamera : https://github.com/kbingham/libcamera we can find that meson requires gcc-8 or higher complier. However, on ubuntu MATE 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f5624b93999ccb44a22e94ea23a37f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e12a1651bca1c98cc5aa71b342eb92/" rel="bookmark">
			2022年4月30日~2022年5月1日 复盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五一假期正式开始。放假了，放假了，这两天没有工作，所以把这周的计划给完成一遍。2022年5月2日就休息一天，反思上一周的情况。
先把放假的这两天总结一下。
工作总结 无，放假了。也反思了一下上周的工作问题。
周计划进度 查看线上环境的nginx配置。100%-下周继续看，复习一下。
完成kafka结合Spring Boot的遗留问题。100%-研究一下项目中的kafka是如何配置多个实例。
了解redis地理坐标&amp;bitmap。100%–研究一下使用的场景。
本周疑问 bitmap的使用场景是只有统计已经去重吗？假设要导出所有没有签到的用户，如果有10亿条数据，是不是还是得从数据库里面查找？生产环境使用MQ，到底是应该使用代码创建topic还是应该在服务器上创建topic？bitmap去重40亿个QQ号后，我如何获取去重后的数据？ 累了累了，休息一天继续开工！
警告 当你在放松的时候，比你优秀的人还在努力，不进步就活该被淘汰！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7177ea5cc65d9bd5d6d595efbdf8b0a6/" rel="bookmark">
			MySQL数据导入导出的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、使用Navicat Premium数据库可视化工具的企业管理器导入导出数据1.企业管理器导入步骤：2.企业管理器导出步骤： 二、cmd方式导入导出数据1.cmd导入步骤：2.cmd导出步骤： 总结 前言 本篇文章主要是写MySQL的数据导入导出的两种方式，分别是使用Navicat Premium数据库可视化工具的企业管理器导入导出数据和使用cmd方式导入导出数据。
提示：以下是本篇文章正文内容，下面案例可供参考
一、使用Navicat Premium数据库可视化工具的企业管理器导入导出数据 1.企业管理器导入步骤： (1)、找到对应的数据库，然后右键运行文件SQL，如下图。
(2)、鼠标点击三个点(…)的地方，如下图。
(3)、找到需要导入文件的绝对存储路径，选择并点击打开，如下图。
(4)、导入完成后，点击关闭，如下图。
2.企业管理器导出步骤： (1)、选择对应的表，然后右键点击转储SQL文件——&gt;结构和数据（如果只要表结构的话，就选择仅结构），如下图。
(2)、找到需要导出的文件的绝对存储路径，选择并点击保存，即可导出文件，如下图。
二、cmd方式导入导出数据 1.cmd导入步骤： (1)、打开cmd，输入下面这段代码：
mysqldump -hlocalhos t-uroot --default-character-set=utf8 -p 数据库名 &lt; 需要导入的文件绝对路径名，点击回车键(enter),如下图。
(2)、输入MySQL的密码，点击回车键(enter),如下图。
(3)、出现下图所类似的模样，即导入成功(这种导入方式存在失败的可能性，建议尽量不用)，导入后可使用sql语句查看是否有数据。
2.cmd导出步骤： (1)、打开cmd，输入下面这段代码：
mysqldump -hlocalhost -uroot --default-character-set=utf8 -p 数据库名 表名 &gt; 导出文件存储的绝对路径和文件名，点击回车键(enter),如下图。
(2)、输入MySQL的密码，点击回车键(enter)。
(3)、出现下图所类似的模样，即导出成功，导出文件后可去对应的存储路径查看文件是否导出成功。
总结 以上就是今天要讲的内容，本文仅仅简单介绍了MySQL的数据导入导出的两种方式的使用，希望对大家能有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827e6d0c6c0e4f5201c36b1af9dcf058/" rel="bookmark">
			YOLOv5网络详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 前言 YOLOv5项目的作者是Glenn Jocher并不是原Darknet项目的作者Joseph Redmon，并且这个项目至今都没有发表过正式的论文。
官方源码仓库，目前更新到v6.1：https://github.com/ultralytics/yolov5
如果对YOLO系列没有了解：
YOLO系列理论合集(YOLOv1~v3)
YOLOv4网络详解
1 YOLOv5网络模型 YOLOv5整体结构：
YOLOv5l网络结构：
2 网络结构改进 YOLOv5共给出了五个版本的目标检测网络:YOLOv5n、YOLOv5s、YOLOv5m、YOLOv5l、YOLOv5x
2.1 Backbone改进 YOLOv5所使用的特征提取网络仍为CSPDarknet
Focus网络结构 在之前的YOLO网络中并没有使用Focus网络结构
Focus模块在YOLOv5中是图片进入backbone前，每隔一个像素取一个值，可以获得4个独立的特征层，将这4个特征层进行堆叠，此时就将宽高维度上的信息转换到了通道维度，输入通道扩充了四倍，再通过进行特征的提取。
将每个2x2的相邻像素划分为一个patch，然后将每个patch中相同位置（同一颜色）像素给拼在一起就得到了4个feature map，然后在接上一个3x3大小的卷积层。
作者提到使用focus层可以减少参数计算，减少cuda的使用内存。
但是在v6.0版本后的YOLOv5没有并用Focus结构，把Backbone的第一层（原来是Focus模块）换成了一个6x6大小的卷积层，两个理论等价，但是对现有的一些GPU和优化算法，使用6x6的卷积层更加高效。
SiLU激活函数 SiLU 函数也称为 swish 函数，具有处处可导、连续光滑、非单调的特性，可以看作是平滑的ReLU激活函数。
f(x)=x⋅sigmoid(x)
SPPF结构 使用SPP结构，通过不同池化核大小的最大池化进行特征提取，提高网络的感受野。在YoloV4中，SPP是用在FPN里面的，在YoloV5中，SPP模块被用在了主干特征提取网络中。
SPPF结构是将输入串行通过多个5x5大小的MaxPool层，这里需要注意的是串行两个5x5大小的MaxPool层是和一个9x9大小的MaxPool层计算结果是一样的，串行三个5x5大小的MaxPool层是和一个13x13大小的MaxPool层计算结果是一样的。
SPPF结构与SPP结构作用一样，但SPPF结构效率更高、速度更快
2.2 Neck改进 在YOLOv5中的FPN特征金字塔结构中引入了CSP结构，在网络结构图中可以看到每个C3模块中都含有CSP结构。
在特征提取部分，YoloV5提取多特征层进行目标检测，一共提取三个特征层。
三个特征层位于主干部分CSPdarknet的不同位置，分别位于中间层，中下层，底层，当输入为(640,640,3)的时候，三个特征层的shape分别为feat1=(80,80,256)、feat2=(40,40,512)、feat3=(20,20,1024)。
在获得三个有效特征层后，利用这三个有效特征层进行FPN层的构建，构建方式为：
1.feat3=(20,20,1024)的特征层进行1次1X1卷积调整通道后获得P5，P5进行上采样UmSampling2d后与feat2=(40,40,512)特征层进行结合，然后使用CSPLayer进行特征提取获得P5_upsample，此时获得的特征层为(40,40,512)。
2.P5_upsample=(40,40,512)的特征层进行1次1X1卷积调整通道后获得P4，P4进行上采样UmSampling2d后与feat1=(80,80,256)特征层进行结合，然后使用CSPLayer进行特征提取P3_out，此时获得的特征层为(80,80,256)。
3.P3_out=(80,80,256)的特征层进行一次3x3卷积进行下采样，下采样后与P4堆叠，然后使用CSPLayer进行特征提取P4_out，此时获得的特征层为(40,40,512)。
4.P4_out=(40,40,512)的特征层进行一次3x3卷积进行下采样，下采样后与P5堆叠，然后使用CSPLayer进行特征提取P5_out，此时获得的特征层为(20,20,1024)。
特征金字塔可以将不同shape的特征层进行特征融合，有利于提取出更好的特征。
2.3 Head改进 Head部分，YOLOv3, v4, v5都是一样的。
还有一些损失计算、正负样本匹配的问题，后续在训练时候再看
参考文献：
YOLOv5网络详解
搭建自己的YoloV5目标检测平台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0e4b72491d487a41476d4655c89d6d/" rel="bookmark">
			nginx配置log转发到日审设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种方法
一、nginx在1.12版本包括之后可直接在nginx.conf配置syslog转发日志
（配置完之后需要重启nginx服务,此情况适用于业务部署期间，确保业务出现波动也不会造成影响） 适用于项目测试部署期间
二、直接syslog抓取nginx日志进行转发
（配置完后需要重启rsyslog服务，如果是web主机需要在尽量不动业务的情况下，尽量使用这一种方法） 适用于服务器提供者或者托管场景
1.nginx支持在nginx.conf配置syslog转发
这里参考 Linux服务器和Nginx配置syslog转发 - 吉小僧 - 博客园
// 将access_log记录到服务器本地文件 access_log /var/log/nginx/access.log main; // 新增将access_log输出到syslog server access_log syslog:server=111.1.1.1日审IP,facility=,tag=nginx,severity=info; //将error_log记录到服务器本地文件 error_log /var/log/nginx//error.log warn; // 新增将error_log输出到syslog server error_log syslog:server=111.1.1.1日审IP,facility=local7,tag=nginx,severity=warn; //重启nginx服务 # systemctl restart nginx.service 2.syslog配置转发nginx的log
这段引用
详细参数：​​​​​​手工配置rsyslog配置文件详解 - arun_yh - 博客园
毁尸灭迹！一次服务器被入侵的血泪教训 - 简书
ng配置：
超强干货！通过filebeat、logstash、rsyslog 几种方式采集 nginx 日志_民工哥博客的技术博客_51CTO博客
创建一个 mkdir -v -p /var/spool/rsyslog 用作传输队列缓存
为保证原来的syslog配置不产生变动，这里给他引入新的配置文件（有点类似于httpd的conf和conf.d的关系，不过这里并不能做到自动读取，需要在rsyslog.conf中声明引入外部配置文件）
vi /etc/rsyslog.conf $IncludeConfig /etc/rsyslog.d/*.conf #在配置中插入这段，其中后段外部配置文件路径可以根据自己喜好配置 vi /etc/rsyslog.d/nginx-log.conf #在rsyslog.d下面创建外挂配置文件 $ModLoad imfile #装载imfile模块 $InputFilePollInterval 1 #检查日志文件间隔（秒） $WorkDirectory /var/spool/rsyslog #这个目录进行缓存等临时存储 ##Nginx访问日志文件路径，根据实际情况修改: $InputFileName /usr/local/nginx/logs/access.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc0e4b72491d487a41476d4655c89d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0807dc9dec9bb18e3e1958d237d7f02b/" rel="bookmark">
			Chisel环境搭建教程（Ubuntu）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chisel环境搭建教程（Ubuntu） 0 前言1 安装java2 安装scala3 安装sbt4 A Chisel template5 Chisel教程参考资料 0 前言 chisel的依赖很多，而且很容易出现版本不兼容的情况，这里每一步我都会提供自己的安装版本OS版本：Ubuntu 21.04 64bit相关参考资料见底 1 安装java 版本：11.0.13 Chisel是基于scala开发的，而scala是基于java的，因此我们先安装java再安装scala。
java
sudo apt install openjdk-11-jre-headless
javac
sudo apt install openjdk-11-jdk-headless
完成后查看版本以检查是否成功安装：java --version javac --version
出现这样的版本号就说明java已经安装成功。
openjdk 11.0.13 2021-10-19 OpenJDK Runtime Environment (build 11.0.13+8-Ubuntu-0ubuntu1.21.04) OpenJDK 64-Bit Server VM (build 11.0.13+8-Ubuntu-0ubuntu1.21.04, mixed mode) javac 11.0.13 2 安装scala 版本2.12.12 到这个网址下载合适版本的scala，不建议使用scala3, 推荐2.12.x
下载.tgz文件，将其解压后移动到/usr/local/share目录下
添加环境变量，在家目录下.bashrc文件的最后添加：
export PATH="$PATH:/usr/local/share/scala-2.12.12/bin"
这句的含义是在PATH变量中加上你刚刚安装的scala内bin文件夹的目录，其中的scala-2.12.12取决于你下载的scala版本
最后source一下使其更新生效：
source ~/.bashrc
在任意目录下输入scala，若出现如下的prompt，则说明scala安装成功。
Welcome to Scala 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0807dc9dec9bb18e3e1958d237d7f02b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b2a3acd9462a8e22c0080a629a916e5/" rel="bookmark">
			4. Spring Bean 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeanDefinition 是 Spring Framework 中定义Bean 的配置元信息的接口，包含：
Bean 类名（全限定名）
Bean 行为配置元素（作用域、自动绑定模式、生命周期）
其他 Bean 引用，依赖
配置设置，属性
4.2 BeanDefinition 元信息 4.2.1 元信息说明
属性（Property）说明ClassBean 全类名，必须是具体类，不能用抽象类或接口NameBean 的名称或者 IDScopeBean 作用域（Singleton、prototype）Constructor argumentsBean 构造器参数（依赖注入）PropertiesBean 属性设置（依赖注入）AutoWiring modeBean 自动绑定模式（byType、byName等）Lazy initialization modeBean延迟初始化模式（延迟或者非延迟）Initialization methodBean 初始化回调方法Destruction methodBean 销毁回调方法名称 4.2.2 BeanDefinition构建
通过 BeanDefinitionBuilder
通过AbstractBeanDefinition 以及派生类
// 通过 BeanDefinitionBuilder 创建 BeanDefinition BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(User.class); AbstractBeanDefinition beanDefinition = builder.addPropertyValue("name", "foo") .addPropertyValue("age", 28).getBeanDefinition(); beanDefinition.addQualifier(new AutowireCandidateQualifier("user")); beanDefinition.setScope("singleton"); ​ // 通过 AbstractBeanDefinition 以及派生类创建 BeanDefinition GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition(); genericBeanDefinition.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b2a3acd9462a8e22c0080a629a916e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8a1414ac2bddf70e873378faf0463d/" rel="bookmark">
			C语言基础02——控制语句。二分查找、随机数讲解、求自幂数、整数逆序、X图案打印、猜数字、公约数公倍数、素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
分支语句(选择结构)
if语句
switch语句
循环语句
while循环
do…while循环
for循环
循环语句的练习
转向语句
goto语句
break语句
continue语句
return语句
什么是控制语句？
控制语句用于控制程序的执行流程，以实现程序的各种结构方式，他们由特定的语句定义符组成，C语言有九种控制语句。 可以分为以下三类： - 条件判断语句/分支语句：if语句、switch语句 - 循环执行语句：do while语句、while语句、for语句 - 转向语句：break语句、goto语句、continue语句、return语句 C语言中真假的表示
- 0表示假 - 非0表示真。 —— 那!0应该返回哪个数？ —— 返回1 分支语句(选择结构) if语句 if语句的结构语法
//第一种 if(表达式) { 语句; } //第二种 if(表达式) { 语句; } else { 语句; } //第三种 if(表达式) { 语句; } else if(表达式) { 语句; } else { 语句; } 对于if语句来说，只要有一个分支执行，整个if语句全部结束。
所有控制语句都是可以嵌套使用，但是嵌套要合理。嵌套时一定要注意缩进。
IF语句的分支只有一条语句时，大括号可以省略不写。（不推荐这种方式，但是别人这样写要可以看懂）
if(表达式) 语句; if(表达式) 语句; else 语句; 悬空else：如果没有加{}，else与离自己最近的那个if配对
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8a1414ac2bddf70e873378faf0463d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16dd88a29c4b3c993619a58a4f598d31/" rel="bookmark">
			Nmap 中的各种端口扫描技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nmap 中的各种端口扫描技术 1. SYN 扫描 SYN扫描是较为流行的一种扫描方式，同时它也是Nmap所采用的默认扫描方式。这种扫描方式速度极快，可以在一秒内扫描上千个端口，并且不容易被网络中的安全设备发现。
你也可以在扫描的时候，输入参数-sS。其实你只要以root或者administrator用户的权限工作，扫描方式都是SYN。Nmap会向目标设备的一个端口发送请求连接的SYN数据包，而且目标设备在接收到这个SYN数据包之后，扫描器在收到SYN+ACK数据包后，不是发送ACK数据包而是发送RST数据包请求断开连接。这样，3次握手就没有完成，无发建立正常的TCP连接，因此，这次扫描就不会被记录到系统日志里。这种扫描方式不会在目标设备上留下扫描痕迹。
我们在对一个端口进行SYN扫描时，端口的状态全是open \ close及filtered中的一个。下表中列出了目标设备的回应与目标设备的端口的状态。
​ 目标设备的回应与目标设备的端口的状态（TCP部分）
目标设备的回应目标设备的端口的状态如果目标设备给出了一个SYN+ACK回应open如果目标设备给出了一个RST回应closed如果目标设备没有给出回应filteredICMP端口无法抵达错误（类型3，代码1，2，3，4，10，13）filtered 使用SYN扫描端口的语法为“nmap -sS [目标设备IP地址]”。如我们对IP地址为192.168.68.191的设备端口进行扫描，命令如下所示：
┌──(rootkali)-[~] └─# nmap -sS 192.168.68.191 2. Connect 扫描 使用Connect扫描端口语法为“nmap -sT [目标设备IP地址]”。Connect扫描其实和SYN扫描很像，只是这种扫描方式完成了TCP的3次握手。如我们对IP地址为192.168.68.191的设备的端口进行扫描，命令如下所示：
┌──(rootkali)-[~] └─# nmap -sT 192.168.68.191 3. UDP 扫描 我们如果对一个端口进行UDP扫描时，端口的状态将会是open\close及filtered中的一个。下表列出了目标设备的回应与目标设备的端口状态。
​ 目标设备的回应与目标设备的端口状态（UDP部分）
目标设备的回应目标设备的端口状态从目标设备得到任意的UDP回应open如果目标设备没有给出回应open|filtered 要注意UDP扫描的速度是相当慢的。IP地址为192.168.68.191的设备的端口进行UDP扫描，命令如下所示：
┌──(rootkali)-[~] └─# nmap -sU 1500 192.168.68.191 在扫描过程中，可能会产生一些状态为filtered的端口，这些端口的真实状态有可能是open，也可能是closed。要从这些状态为filtered的端口中找到那些其实是open的端口，需要进一步进行测试。
4. 端口扫描范围的确定 对端口的扫描一般使用TCP，但是一台设备上有65536个端口，如果对全部端口都进行扫描，那么花费的时间会相当长，所以Nmap默认扫描的只是65536个端口中最为常用的1000个端口。如果我们不加任何参数的话，Nmap扫描的端口是1000个，而不是65536个。
1. 扫描全部端口 如果对65536个端口扫描，可以使用参数-p “*”。
语法：nmap -p “*” [目标设备IP地址]
如我们要对IP地址为192.168.68.191的目标设备的65536个端口进行扫描，可以使用如下命令：
┌──(rootkali)-[~] └─# nmap -p "*" 192.168.68.191 2. 扫描使用频率最高的n个端口 如果只想扫描使用频率最高的n个端口，可以使用参数–top-ports n。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16dd88a29c4b3c993619a58a4f598d31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6ae7ecb7cfdf27ac332902c39d9141/" rel="bookmark">
			Java-输入一整数n(n＞=1）,然后将随后输入的n个整数存入一整型数组；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 输入一整数n(n&gt;=1）,然后将随后输入的n个整数存入一整型数组；
显示该整型数组所有元素；
然后删除数组中多余的重复元素，重复数组元素中只保留第一个元素，
比如数组中存在3个整数5，下标分别为2,9和12，
则删掉下标为9和12的元素，后面元素顺次前移。
最后显示已删除多余的重复元素的整型数组所有元素。
package arr; import java.util.Scanner; /*	* 题目： * 输入一整数n(n&gt;=1）,然后将随后输入的n个整数存入一整型数组； 显示该整型数组所有元素； 然后删除数组中多余的重复元素，重复数组元素中只保留第一个元素， 比如数组中存在3个整数5，下标分别为2,9和12， 则删掉下标为9和12的元素，后面元素顺次前移。 最后显示已删除多余的重复元素的整型数组所有元素。 */ public class test { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println("请输入一个整数n："); int n = scanner.nextInt(); System.out.println("请输入n个整数："); int[] arr = new int[n]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = scanner.nextInt(); } //显示该整型数组所有元素 System.out.print("原数组："); for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6ae7ecb7cfdf27ac332902c39d9141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60165e93b7bb7c7ee36f516775e5fc46/" rel="bookmark">
			Java中值传递（值拷贝）和地址传递（地址拷贝）问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**Java中值传递（值拷贝）和地址传递（地址拷贝）问题 首先说结论：
值传递：基本数据类型。地址传递：引用数据类型。 Java中的数据总体来说可以分为两类：基本数据类型和引用数据类型。基本数据类型比如：int、long、float等四类八种。引用数据类型如：数组、字符串、对象等。而我们Java的jvm模型大概由三块内存结构组成。分为栈、堆、方法区。当然这些结构可以划分的更细，此处基于这三者完全可以将今天的问题阐述清楚，因而不做过多描述。基本数据类型存储在栈空间当中，传递也是在栈中进行操作，数据是存储在栈中。而引用数据的创建需要在堆中开辟一块新的空间，用于存储数据，生成对应的地址，栈中的变量指向这个堆中的地址，进而拿到数据，数据是存储在堆中。如下代码所示：
public static void main(String[] args) { int n1 = 10; int n2 = n1; n2 = 80; System.out.println("n1:"+n1);//n1:10 System.out.println("n2:"+n2);//n2:80 int [] arr1 = {10,20,30}; int [] arr2 = arr1; arr2[0] = 10; for (int i = 0; i &lt;arr1.length ; i++) { System.out.println("arr1:"+arr1[i]); } for (int i = 0; i &lt;arr2.length ; i++) { System.out.println("arr2:"+arr2[i]); } } 输出结果：
n1:10 n2:80 arr1:10 arr1:2 arr1:3 arr2:10 arr2:2 arr2:3 对，你没看错，数组arr2的值改变影响到了arr1数组的值。神奇不？惊讶不？是不是要怀疑人生了哈哈！莫急，稳住！！听小弟娓娓道来。为了说明其中缘由，结合以下结构图进行分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60165e93b7bb7c7ee36f516775e5fc46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcab33821c80e5a2011c9007ebd82319/" rel="bookmark">
			jsch sftp如何删除包含文件的文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sftp递归删除文件夹 背景：项目在做审计时，需要将任务运维过程中产生的审计信息上传到第三方平台，使用的工具是第三方库jsch,使用其中的ChannelSftp进行文件上传。
&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.55&lt;/version&gt; &lt;/dependency&gt; 在进行sftp上传时，需要在上传失败时删除已上传的部分，但是看了一下相关的现有方法，发现没有能够直接删除文件夹(文件夹中包含文件或者文件夹)的方法。然后就自己搞了一个，亲测可用。
/** * 递归删除远程服务器文件夹 * @param deleteDest * @throws SftpException */ public void deleteDirectory(String deleteDest) throws SftpException { if (sftp.stat(deleteDest).isDir()) { sftp.cd(deleteDest); Vector&lt;ChannelSftp.LsEntry&gt; entries = sftp.ls("."); for (ChannelSftp.LsEntry entry: entries) { String fileName = entry.getFilename(); if(fileName.equals(".") || fileName.equals("..")){ continue; } deleteDirectory(entry.getFilename()); } sftp.cd(".."); sftp.rmdir(deleteDest); } else { sftp.rm(deleteDest); } } 好了，以上就是使用jsch 删除远程服务器文件夹的方法，如果对你有帮助，就给个赞吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0252dec1df9b964b5dad1cabffdc2c8b/" rel="bookmark">
			十.全文检索ElasticSearch经典入门-自动补全功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天给大家讲述一下如何简单快速的基于SpringBoot整合ElasticSearch搜索补全功能，该功能是全文检索中很常见的功能，当我们输入关键字，ElasticSearch自动帮我们进行单词联想如下：
自动补全演示 这里ElasticSearch采用的6.8.6版本，ElasticSearch和Kibana的安装教程请见第一章《ElasticsSearch安装》, 在ES官方文档提供了Completion Suggester实现自动补全功能，需要自动补全的字段类型一定是completion，参与补全查询的字段必须是completion类型。字段的内容可以是用来补全的多个词条形成的数组。下面先使用kibana做一个演示：
第一步，创建索引
PUT goods #创建索引 第二步：创建映射 , 下面给title指定为completion类型，且使用ik_smart分词
PUT goods/_doc/_mapping { "properties": { "title": { "type": "completion", "analyzer" : "ik_smart" } } } 第三步：给索引添加文档 ,下面添加了2个文档，title 都是以笔记本开头的内容
PUT goods/_doc/1 { "title":"笔记本支架" } PUT goods/_doc/2 { "title":"笔记本电脑" } 第四步：执行搜索，通过 suggest 处理补全
GET /goods/_search { "suggest": { "title_suggest": { "text": "笔记本", "completion": { "field": "title", "skip_duplicates": true, "size": 10 } } } } title_suggest ：为 suggest取的一个名字而已text ：自动补全的文本前缀field：对哪个字段自动补全skip_duplicates ： 跳过重复size :取前10条结果 查询的结果如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0252dec1df9b964b5dad1cabffdc2c8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f468ea99c400acaa9e387537b3b28c33/" rel="bookmark">
			【Java】浅谈前缀和与差分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前缀和 思路及其实现 前缀和，顾名思义，就是求出一个序列中每个数的前面的数和自身相加。下面的s数组表示前缀和，a数组表示当前数
s[i] = a[1] + a[2] + ... + a[i - 1] + a[i]; s[i - 1] = a[1] + a[2] + ... + a[i - 2] + a[i - 1]; 由此可以得出： s[i] = s[i - 1] + a[i]; 现在对其边界进行判断，当i == 1的时候 s[1] = s[0] + a[1]; a[0] = 0； 所以可以判断等式成 作用：
例如： 2 1 3 6 4 求出2到4区间的和，我们有前面的s[4] - s[2 - 1]就可以求出其值。当然for循环从a[2]加到a[4]也是可以实现的，但未知的多组数据就不知道需要多少个for来实现了，所以求多组区间的和就需要用到前缀和 795. 前缀和 - AcWing题库 输入一个长度为 n 的整数序列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f468ea99c400acaa9e387537b3b28c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a821135e69988863dae049360fd2ea/" rel="bookmark">
			tensorflow之图(graph)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图，也就是tensorflow计算图。tensorflow程序需要先构图，再运行图。图由结点和边组成。
图的结点就是OP。而边连接OP的输出与另一个OP的输入。如下图，e1表示把OP1的输出连接到OP4的输入。 一个OP可以接受多个OP的输出作为输入。一个OP的输出也可以连接到多个OP的输入上。
分析图 需要保存图中有哪些结点(op)结点之间如何连接(edge)图需要序列化反序列化，以保存到磁盘上或者从磁盘加载图就是模式，也就是机器学习，深度学习中说的模型 tensorflow 图的proto表示 GraphDef // Represents the graph of operations message GraphDef { repeated NodeDef node = 1; //保存图中的结点 VersionDef versions = 4; int32 version = 3 [deprecated = true]; // node[i].op的名字如果是library里的一个函数的名字，则这个Node认为是函数调用 //函数调用者保证函数输入同时满足，用Tuple机制 //函数输入都ready后函数就立即启动运算 //函数输出的消费者也通过Tuple机制所有输出Ready才开始使用 FunctionDefLibrary library = 2; } NodeDef 在tesnsorflow/core/framework/node_def.proto中定义了Node中的表示。NodeDef中的Input字符，实际上保存了图中的边。Node的输出实际上就是OP的输出。tensorflow/core/framework/node_def_utils.h中有操作Node中attr, 输入输出的函数同样提供了NodeDefBuilder来创建Node: tensorflow/core/framework/node_def_builder.h message NodeDef { string name = 1; //实际OP string op = 2; //这里通过node_name:src_output来标识需要哪个Node的哪个输出作为当前Node的输入 repeated string input = 3; //指定设备名："/job:worker/replica:0/task:1/device:GPU:3" 不指定会在运行时分配 string device = 4; //op在构图时的配置，也就是OpDef里的属性，保存了属性名和值 map&lt;string, AttrValue&gt; attr = 5; message ExperimentalDebugInfo { repeated string original_node_names = 1; repeated string original_func_names = 2; } ExperimentalDebugInfo experimental_debug_info = 6; FullTypeDef experimental_type = 7; } Function Function可以看作是把多个Node打包起来当前一个结点，这多个Node的输入就是OpDef signature,其中就是每个Node的输入集合起来。函数就是个子图，因此可以把图转成函数，tensorflow提供了函数：tensorflow/core/framework/graph_to_function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a821135e69988863dae049360fd2ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99587d2bbde11ca11d9e15ce7ba89745/" rel="bookmark">
			Twaver-HTML5基础学习(30)监听事件_network绘制监听_network视图操作监听_鼠标事件的监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监听事件 addViewListener主要用于监听视图绘制的事件 /** *addViewListener主要用于监听视图绘制的事件 *network.addViewListener(function(e){console.log(e);}); * */ addViewListener: function (listener, scope, ahead) { this._viewDispatcher.add(listener, scope, ahead); }, removeViewListener: function (listener, scope) { this._viewDispatcher.remove(listener, scope); }, fireViewEvent: function (evt) { this._viewDispatcher.fire(evt); }, 在创建Network和刷新Network的时候会派发视图事件，可以监听到”invalidate”、”validateStart”、”validateEnd”等。
//addViewListener主要用于监听视图绘制的事件 const eFun = e =&gt; { console.log(e, 'ee') } // network.addViewListener(eFun) // 移除监听视图绘制事件 // network.removeViewListener(eFun) addInteractionListener主要用于监听视图操作的事件 /** *addInteractionListener主要用于监听视图操作的事件 *network.addInteractionListener(function(e){console.log(e);}); * */ addInteractionListener: function (listener, scope, ahead) { this._interactionDispatcher.add(listener, scope, ahead); }, removeInteractionListener: function (listener, scope) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99587d2bbde11ca11d9e15ce7ba89745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ef0d7ac45fea43e6f593f952624ad2/" rel="bookmark">
			RunTime.getRunTime().addShutdownHook的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RunTime.getRunTime().addShutdownHook的用法_常识的Blog的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7389d9b605813a8c7978fb7eb2637c1/" rel="bookmark">
			Attention Mechanisms in Computer Vision: A Survey(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上一篇博客：Attention Mechanisms in Computer Vision: A Survey(二)
我又回来了，这篇综述简直信息量巨大，这是我第三天消化这篇综述了，有兴趣的同学可以读一下原文。
一、Branch Attention 分支注意可以被看作是一种动态的分支选择机制：注意哪个分支，与多分支结构一起使用。
（一）、Highway networks 受长短期记忆网络的启发，Srivastava等人提出了Highway networks，该网络采用自适应选通机制，使信息能够跨层流动，以解决训练非常深层网络的问题。 假设一个普通的神经网络由L层组成，并且 H l （ X ） H_l（X） Hl​（X）表示第L层上的非线性变换，那么Highway networks可以表示为
T l （ X ） T_l（X） Tl​（X）表示调节第l层的信息流的变换门。 X l X_l Xl​和 Y l Y_l Yl​是第l层的输入和输出。
选通机制和跳接结构使得使用简单的梯度下降方法直接训练非常深的Highway networks成为可能。与固定跳过连接不同，选通机制适应输入，这有助于跨层路由信息。Highway networks可以并入任何CNN。
(二)SKNet 见博文
（三）、CondConv CNN中的一个基本假设是所有卷积核都是相同的。一般情况下增强网络表现力的典型方法是增加其深度或宽度，这会带来大量额外的计算成本。为了更有效地提高卷积神经网络的容量，Yang等人提出了一种新的多分支算子CondConv，可以定义一个普通的卷积 ：
∗ 表示卷积。所有样本的可学习参数W都相同。CondConv自适应地组合了多个卷积核，可以写成：
α是一个可学习的权重向量
这个过程相当于多个experts的集合，如下图所示：
CondConv充分利用了多分支结构的优点，采用了一种计算量小的分支注意方法。它提供了一种有效提高网络容量的新方法。
(四)、Dynamic Convolution 轻量级CNN极低的计算成本限制了网络的深度和宽度，进一步降低了其代表性。为了解决上述问题，Chen等人提出了动态卷积，这是一种新的算子设计，可以增加表征能力，但额外的计算成本可以忽略不计，并且不会与CondConv并行改变网络的宽度或深度。 动态卷积使用K个大小和输入/输出维度相同的并行卷积核，而不是每层一个核。与SE块一样，它采用挤压和激励机制为不同的卷积核生成注意权重。这些卷积核通过加权求和动态聚合，并应用于输入特征映射X：
卷积通过卷积核的权重和偏差之和进行组合。
与将卷积应用于特征映射相比，压缩、激励和加权求和的计算成本极低。因此，动态卷积提供了一种有效的操作来提高表示能力，并且可以轻松地用作任何卷积的替代品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab82f5f300897f8f703a961362f7697d/" rel="bookmark">
			从0到1的熟悉掌握——Kerberos协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kerberos协议简述 Kerberos 是 MIT 提出的一种网络身份验证协议，它通过密钥加密技术验证用户或主机的身份。Kerberos 默认使用 UDP 端口88。 ​ Kerberos，作为第三方网络认证协议，在客户端需要与服务端通信时，通过使用加密技术为客户端/服务端应用程序提供强大的认证服务。Kerberos协议在内网域渗透领域至关重要，白银票据、黄金票据、攻击域控等都离不开Kerberos协议。
​ Kerberos协议是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。其设计目标是通过密钥系统对客户端和服务器应用程序提供强大的认证服务。该协议的认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上的所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。
在Windows Domain（域）环境中：
DC（Domain Controller）域控充当KDC（Client和Server共同信任的第三方机构）
KDC维护存储着该Domin中所有账户的Account Database（由Active Directory维护），存储着所有每一个Account的名称和派生于该Account Password的Mater Key（Hash Code）
Kerberos词汇扩展 简称角色作用Client客户端，指用户Server服务端、服务器DCDomain Controller域控制器，一台计算机，实现用户和计算机的统一管理KDCKey Distribution Center密钥分发中心，默认按照在域控里，包括AS和TGSASAuthentication Service身份验证服务，用于KDC对Client认证TGSTicket Granting Service票据授予服务，用于KDC对Client和Server分发Session Key（临时密钥）ADActive Directory活动目录，用于存储用户、用户组、域相关的信息TGTTicket Granting Ticket认证票据：相当于入场卷，用来获取ST的临时凭证STService Ticket用来访问某种服务所必须使用的票据PACPrivilege Attribute Certificates特权访问证书，是微软为了访问控制而引进的一个扩展 Kerbros认证整体流程 AS_REQ &amp; AS_REP
-Client向KDC申请TGT（AS身份验证服务）
TGS_REQ &amp; TGS_REP
-Client通过获得的TGT向KDC申请用于访问Server的Ticket（TGS票据发放服务）
AP-REQ &amp; AP-REP
Client最终向Server提交Server为了验证自己身份的Ticket（通过认证的客户端和服务建立连接）
1、AS_REQ &amp; AS_REP ​ 该阶段为Client和AS的认证，通过认证的客户端获得TGT认购权证。
​ 当域内某个客户端用户试图访问域内的某个服务，于是输入账户密码，此时客户端本机Kerberos服务就会向KDC的AS认证服务发送一个AS_REQ认证请求。
​ AS接收到客户端信息后，并不是立即接受而是先在AD数据库中查找是否存在该用户记录。如果存在，则用该用户的密码HASH并对AS_REQ请求中加密的时间戳进行解密，如果解密成功，则证明客户端提供的密码正确，如果时间戳在五分钟之内，则预认证成功。然后AS会生成一个临时密钥 Session-Key AS（用于确保客户端和KGS之间的通信安全），并使用客户端用户的NTLM-Hash加密临时密钥作为响应的一部分内容。
​ 还有一部分是TGT：使用KDC的一个特定账户的Hash对临时密钥、时间戳、Client-info进行的加密。这个特定的账户是创建域控时自动生成的Krbtgt用户，然后将这俩部分以及PAC等信息回复给Client。
2、TGS_REQ &amp; TGS_REP ​ 该阶段是Client和TGS的认证，通过认证的客户端将获得ST服务票据。
​ Client收到AS回复的AS_REP后获得TGT和加密的Session-Key AS。首先用自己的Hash解密得到原始的临时密钥，然后在本地缓存TGT和原始的临时密钥。当需要访问某服务时，就凭借这张TGT认购凭证向KGS购买相关的ST服务票据（Ticket）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab82f5f300897f8f703a961362f7697d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911a5d349386a9901ba7e96a5ae50496/" rel="bookmark">
			Git仓库瘦身--清除项目git仓库大文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mark一下“清除A项目git仓库大文件”实操过程，由于公司保密政策，无法提供实操截图，这里提供下操作思路。
后来也搜到更加推荐的方法：用BFG去做git仓库的清理(最佳工具)
一、需求背景 最初A项目的部署配置，是从远程仓库获取项目打包文件进行部署，这需要在本地生成打包文件后提交到远程仓库。
而对打包大文件多次操作后导致git仓库过大（已达3G，正常为几十M），从而导致首次拉取项目速度过慢、同时也占用了大量存储空间。
为了解决“项目过大导致首次拉取速度过慢、占用大量存储空间”问题，急需对git仓库进行清理–从git记录中清除不需要的大文件。
Git 仓库随着 commit 次数的增加变得越来越大，尤其是当 push 了大文件之后，即使后面把该文件删除了，也会被 Git 记录下来，以便能够随时回滚到指定提交。
二、技术方案 用 filter-branch 去做git仓库的清理
filter-branch：让您通过重写 &lt;rev-list 选项 &gt; 中中提到的分支来重写 Git 修订历史记录，并在每个修订版上应用自定义过滤器。这些过滤器可以修改每个树（例如，删除文件或对所有文件运行 perl 重写）或每个提交的信息。简单来说：filter-branch剔除指定的类型文件，并重写commitId。
1、注意事项（***） ！！清理完之后,每个人一定要删掉之前拉取的项目, 重新从git上拉项目。不要使用之前的项目了！否则会不降反升。
2、方案步骤 Step1：找占用空间大的文件是哪些; git rev-list --objects --all | grep "$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk '{print$1}')" // 使用verify-pack命令查看, pack包里面的最大的10个文件对应的hash值 // 根据rev-list命令来查看, 最大的文件的文件名是什么 Step2：移除对该文件的引用; git filter-branch --force --index-filter "git rm -rf --cached --ignore-unmatch 文件/文件夹"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911a5d349386a9901ba7e96a5ae50496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f9ca9344d34447b189018099714925/" rel="bookmark">
			npm install -g http-server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Node.js轻量级HTTP服务器有很多种，我们将以http-server为例（GitHub - http-party/http-server: a simple zero-configuration command-line http server），一般提供server服务的工具建议全局安装。
npm install http-server -g
启动日志如下：
命令为：http-server （在浏览器中访问以下三个地址中的任意一个，就能看到src目录下的 index.html 咯，案例是在src目录下启动的服务）
命令为：http-server src (若命令行工具在 “ \响应式 ” 文件夹中打开，要想达到上述效果，运行命令时需要带上 [path] 参数 )
[options] 参数可以指定端口、地址等等，例如指定服务在8888端口启动，命令为：http-server src -p 8080
npm install -g http-server
http-server -p 8080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11000e0507c7897a5aa081ef7f4c5cc1/" rel="bookmark">
			2021-11-05 C&#43;&#43;结构体方面的知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 结构体方面的知识 1 基础语法 1.1 创建结构体变量，三种方法 #include&lt;iostream&gt; using namespace std; //1. 创建学生数据类型 //自定义数据类型，一些类型集合组成的一个类型 struct student { //学生类型 string name; int age; int score; }; int main() { //2. 通过学生类型创建具体学生 // 2.1 // struct 关键字可以在创建变量的时候省略 struct student s1; s1.age = 19; s1.name = "穆久涛"; s1.score = 100; cout &lt;&lt; "姓名" &lt;&lt; s1.name &lt;&lt; "年龄" &lt;&lt; s1.age &lt;&lt; "分数" &lt;&lt; s1.score&lt;&lt; endl; // 2,2 struct student s1 ={...} struct student s2 = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11000e0507c7897a5aa081ef7f4c5cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55a70a981cfd4586f6c2af2b5592b3f/" rel="bookmark">
			2021综述：计算机视觉中的注意力机制(续二）：空间注意力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3.3 Spatial Attention3.3.1 RAM3.3.2 Glimpse Network3.3.3 Hard and soft attention3.3.4 Attention Gate3.3.5 STN3.3.6 Deformable Convolutional Networks3.3.7 Self-attention and variants3.3.8 Vision T ransformers3.3.9 GENet3.3.10 PSANet 参考文献 3.3 Spatial Attention 空间注意力可以看作是一种自适应的空间区域选择机制：关注哪里。如图 4 所示，RAM [31]、STN [32]、GENet [61] 和 Non-Local [15] 代表了不同种类的空间注意方法。 RAM 代表基于 RNN 的方法。 STN 代表那些使用子网络来明确预测相关区域的人。 GENet 代表那些隐式使用子网络来预测软掩码以选择重要区域的方法。 Non-Local 表示自注意力相关的方法。
图 4. 视觉注意力的发展背景。
按类别和日期排序的代表性空间注意机制。应用领域包括：Cls = 分类，FGCls = 细粒度分类，Det = 检测，SSeg = 语义分割，ISeg = 实例分割，ST = 风格迁移，Action = 动作识别，ICap = 图像字幕。 Ranges 表示注意力图的范围。 S 或 H 表示软注意力或硬注意力。(A) 根据预测选择区域。 (B) 逐元素相乘，© 通过注意力图聚合信息。 (I) 将网络集中在判别区域，(II) 避免对大型输入图像进行过多计算，(III) 提供更多的变换不变性，(IV) 捕获远程依赖关系，(V) 去噪输入特征图 (VI) 自适应聚合邻域信息，（七）减少归纳偏差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55a70a981cfd4586f6c2af2b5592b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab7e1fdd48e04613ecd58a29be59618/" rel="bookmark">
			LeetCode 704 二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		704.二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
示例 1:
输入: nums= [-1,0,3,5,9,12], target= 9 输出: 4 解释: 9 出现在nums中并且下标为 4 示例 2：
输入: nums= [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 暴力：
class Solution { public int search(int[] nums, int target) { int flag=-1; for(int i=0;i&lt;nums.length;i++){ if(target==nums[i]) { flag=1; return i; } }if(flag==-1) return flag; return 0; } } 二分查找思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab7e1fdd48e04613ecd58a29be59618/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de69afe161926d1104ce1c713f1cad3/" rel="bookmark">
			ceres的错误(ps:cmake的学习)：/usr/bin/ld:xxx undefined reference to `ceres::Problem::~Problem()“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		令人头疼且费时的工程问题，错误的开始，不管我的函数是添加在哪个文件都有这个错误
我心想这肯定是cmakelist.txt没写好或者是ceres的版本问题。
在尝试过粘贴该错误搜索全网解决方法，然后尝试了还是有这个问题的可以试一试这个（ =V=）：
原本我的cmakelist的一部分：
add_executable(xxx src/xxx.cpp)#用来描述把哪个程序文件编译成可执行文件 target_link_libraries(xxx ${CERES_LIBRARIES} ${catkin_LIBRARIES} ${OpenCV_LIBS} xxx xxx ) 诶就是有错误，除非把ceres的函数写在src/xxx.cpp下，当然这是不可能的。
然后我觉得就是cmakelist有问题，于是我加上去，于是好了！！你说奇妙不奇妙！！
target_link_libraries(${PROJECT_NAME} ${CERES_LIBRARIES} ${EIGEN3_LIBS} ${catkin_LIBRARIES} ${xxx} ${xxx} ${xxx} ${xxx} )# add_executable(xxx src/xxx.cpp)#用来描述把哪个程序文件编译成可执行文件 target_link_libraries(xxx ${PROJECT_NAME} ) 理论分析（当个复习）：(参考官方网站，官方页面也有搜索栏，一搜就知道)CMake Reference Documentation — CMake 3.23.1 Documentationhttps://cmake.org/cmake/help/latest/index.htmlCMake Tutorial — CMake 3.23.1 Documentationhttps://cmake.org/cmake/help/latest/guide/tutorial/index.html看官网给出的steps：
得到简简单单的cmakelist.txt的步骤：
#---step1:添加cmake版本号、工程名字、c++ standard cmake_minimum_required(VERSION 3.10) # set the project name and version project(Tutorial) # specify the C++ standard c++11 # set(CMAKE_BUILD_TYPE Debug)#用于断点调试 默认是Release # set(CMAKE_CXX_FLAGS "-std=c++14 -O3") 用c++14的时候也可以这样 set(CMAKE_CXX_STANDARD 11) #---step2:构建链接库,比如说自己创建的一些h文件与c文件，是静态还是动态的 #a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2de69afe161926d1104ce1c713f1cad3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096d8050a80398a9c704ca137ed4062a/" rel="bookmark">
			Flutter开发之——getX-快速入门(01)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 GetX是Flutter的一个快速开发框架，借助GetX可以极大提高Flutter的开发速度和效率，它支持：
反应式状态管理OBS(之前通过setState设置)路由管理(之前通过Navigator跳转)依赖管理(设置过Get.put(Controller)可以获取到Controller实例化)实用工具箱(国际化、切换主题、网络连接设置、GetPage中间件、高级API、本地状态组件、状态混合、测试等) 后续将分章节进行讲解，本文为GetX快速入门，让你对GetX有个了解
二 GetX项目地址及项目集成 2.1 GetX项目地址 Github-getX：https://github.com/jonataslaw/getx#about-get
2.2 项目集成 1-将 Get 添加到您的 pubspec.yaml 文件中，并执行Pub get，查看Dark Packages下面的gex-xxx是否存在
dependencies: get: 2-在需要使用的地方导入下面的文件
import 'package:get/get.dart'; 三 GetX示例(重写默认项目) 重写后的项目结构如下图所示，重写之前为main.dart，重写之后分为下面3个部分：
1-getX-启动入口2-Views：视图View3-controller：控制器 3.1 getX-启动入口 import 'package:flutter/material.dart'; import 'package:get/get.dart'; import 'package:getx_sample/views/Home.dart'; void main() =&gt; runApp(GetMaterialApp(home: Home())); 说明：此处作为程序的入口文件，之前的MaterialApp被GetMaterialApp取代
3.2 Views：视图View Home.dart(启动页面) import 'package:flutter/material.dart'; import 'package:get/get.dart'; import '../controller/Controller.dart'; import 'Other.dart'; class Home extends StatelessWidget { @override Widget build(context) { //通过Get.put()方法初始化Controller final Controller c = Get.put(Controller()); return Scaffold( //当count变化时，Obx可以监听改变 appBar: AppBar(title: Obx(() =&gt; Text("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096d8050a80398a9c704ca137ed4062a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b07398c820bd11cca7694f73b04d03/" rel="bookmark">
			Docker系列 深度使用nextcloud（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自我的个人博客https://blognas.hwb0307.com。欢迎关注！
前言 通过Docker系列 搭建个人云盘服务nextcloud的学习，你应该已经成功搞定Nextcloud的搭建了吧！你当然可以像用百度网盘一样，先上传点文件；又或者去自己的手机里安装一个Nextcloud，备份自己的整个相册。我iPhone相册里6.5G的数据全部都是用Nextcloud来备份的！
接下来，我要告诉你一个事实：你或许并不了解Nextcloud。是的！试想，如果Nextcloud的功能只是如此简单，又怎么敢自称是“下一代云”呐！其实我在刚刚开始也纳闷。就这？但我同时也注意到一个情况，那就是Nextcloud的Docker pull量和Github项目：
一般只有很大的Project才采用的Github结构（还有众多的开发者）：
仅仅是docker，在Github上也有3.9k的收藏：
估计它已经是自建云的天花板了吧！所以，我觉得它应该不是这么单纯。于是，我决定花点时间去专门了解Nextcloud有哪些特别之处。
特性 老规矩，这里节选一些机翻Wiki：https://en.wikipedia.org/wiki/Nextcloud
Nextcloud是一套用于创建和使用文件托管服务的客户端-服务器软件。它是企业级的，具有全面的支持选项。作为免费和开源软件，任何人都可以在自己的私人服务器设备上安装和操作它。
Nextcloud在与其集成办公套件解决方案Collabora Online或OnlyOffice一起使用时，在功能上类似于Dropbox、Office 365或Google Drive。它可以托管在云端或本地。它可以从基于低成本 Raspberry Pi 的家庭办公解决方案一直扩展到支持数百万用户的全尺寸数据中心解决方案。
原ownCloud开发者Frank Karlitschek 分叉ownCloud 并创建 Nextcloud，继续由 Karlitschek 和原 ownCloud 团队的其他成员积极开发。
Nextcloud 文件存储在传统的目录结构中，必要时可通过WebDAV访问。用户文件在传输过程中加密，也可选择在静止时加密。Nextcloud 可以与运行Windows（Windows 7、8 和 10）、macOS（10.6 或更高版本）或各种Linux发行版的本地客户端同步。
Nextcloud 允许用户和组管理（通过OpenID或LDAP）。可以通过在用户和组之间定义细粒度的读/写权限来共享内容。或者，Nextcloud 用户可以在共享文件时创建公共URL 。还可以记录与文件相关的操作，以及根据文件访问规则禁止访问。
Nextcloud 计划了新功能，例如监控功能、全文搜索和Kerberos身份验证，以及音频/视频会议、扩展联合和更小的用户界面改进。
由于该软件是模块化的，因此可以使用插件对其进行扩展以实现额外的功能。开发人员可以通过制造商运营的平台将其扩展提供给其他用户进行安装。该平台通过开放协议与 Nextcloud 实例通信。App Store [12]包含 200 多个扩展。在这些扩展的帮助下，可以添加许多功能，包括：
日历 ( CalDAV )联系人 ( CardDAV )流媒体（Ampache）基于浏览器的文本编辑器书签服务URL 缩短套件画廊RSS提要阅读器Nextcloud 中的文档查看器工具连接到Dropbox、Google Drive和Amazon S3网络分析（使用Matomo）整合内容管理系统，例如 Pico CMS天气预报查看器DICOM查看器地图查看器烹饪食谱的管理 2020 年 1 月 17 日，版本 18 在柏林以产品名称Nextcloud Hub 发布。第一次在这里直接集成了一个办公包（这里是OnlyOffice），Nextcloud 宣布，它的目标是与Microsoft Office 365和Google Docs直接竞争。此外，当天还宣布了与Ionos的合作伙伴关系。Office 功能适用于具有 Collabora Online 的基于 x86/x64 和ARM64的服务器，OnlyOffice 目前不支持 ARM。与专有服务相比，开放式架构使用户能够完全控制他们的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b07398c820bd11cca7694f73b04d03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811b3f17b9ae5a47141d3699b81684ab/" rel="bookmark">
			Mysql实现父子递归(父查子，子查父)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一张关系表：
CREATE TABLE `ds_relation_folder` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增Id', `parent_folder_id` int(11) NOT NULL COMMENT '父类文件夹Id', `child_folder_id` int(11) DEFAULT NULL COMMENT '子文件夹Id', `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', `modify_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', `is_disable` tinyint(4) DEFAULT '0', `folder_layer` int(11) NOT NULL COMMENT '文件夹的层数', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 父查子递归逻辑实现：
SELECT @parentIds, @lev:=@lev+1, (select @parentIds:= group_concat(id) from ds_relation_folder where find_in_set(parent_folder_id ,@parentIds)) FROM ds_relation_folder drf , (select @parentIds:=6,@lev:=0) b where @parentIds is not null; 子查父递归逻辑实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811b3f17b9ae5a47141d3699b81684ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4fb17c898d2c0092d5810d69b48c89/" rel="bookmark">
			Gitea 的简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gitea 是一款使用 Golang 编写的可自运营的代码管理工具。
在这个领域，名气最响的应该是 Gitlab。
但实际使用中Gitlab也有点问题，首先就是资源占用。Gitlab 是使用 ruby 编写的，好几年之前刚出来的时候，一台1G内存的虚拟主机连安装运行都做不到，着实震惊。
时至今日都已经发展到了以docker镜 像分发，gitlab 仍旧会有体积和运行时资源占用的问题。另一点就是功能，对于一般标准团队来说，gitlab的功能太过于丰富，这是往好的地方说，往坏的地方说就是它包含了太多不需要的东西，而这些东西还占用磁盘和运行时资源。
同时 Gitlab 的许可证政策对新的用户也不是非常友好，主要在于与其他平台的同步上面。
例如有一个下面的场景：你将代码提交到自己的服务器上后，如果希望能够自动同步到其他的平台上，比如 GitHub 或者从其他平台上镜像回来，Gitlab 的社区版本是做不到的。
你需要使用企业版本，企业办法的收费是一个用户 5 美元，就算用户不再提交代码了，或者你的员工已经离职了，这个许可证也没有办法收回。
于是着手查看开源的可选方案，很快就找到了golang 研发的gitea。
使用golang研发的软件分发都很容易，体积小，安装使用简单，运行时占用资源少。
且gitea的功能很完备。
Gitea 和 Gogs 的关系 Gitea 其实是 Gogs 的一个分支。
这 2 个都有国人的参与，只是 Gogs 可能开发理念和 Gitea 有所不同，感觉社区上面的参与度不高。
同时 Gogs 更新速度较慢，因此可能选择 Gitea 会多一些。
我们也选择使用了 Gitea 。
Gitea 与其它 Git 托管工具的横向对比 这里列出了 Gitea 与其它一些 Git 托管工具之间的异同，以便确认 Gitea 是否能够满足您的需求。
请注意，此列表中的某些表项可能已经过时，因为我们并没有定期检查其它产品的功能是否有所更改。
使用界面 使用界面的情况如下：
你可以直接对你的代码库进行提交。
Gitea 的简单介绍 - SCM - OSSEZhttps://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc4fb17c898d2c0092d5810d69b48c89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b4852ac51bf9688c7b13bb20998cd6/" rel="bookmark">
			Hive启动报错：java.net.URISyntaxException: Relative path in absolute URI: ${system:user.name%7D
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 hive&gt; show databases; OK Failed with exception java.io.IOException:java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: ${system:user.name%7D Time taken: 0.744 seconds hive&gt; 解决办法：找到hive安装目录下conf配置文件目录：打开hive-site.xml文件
vi hive-site.xml 找到如下属性：
&lt;property&gt; &lt;name&gt;hive.querylog.location&lt;/name&gt; &lt;value&gt;${system:java.io.tmpdir}/${system:user.name}&lt;/value&gt; &lt;description&gt;Location of Hive run time structured log file&lt;/description&gt; &lt;/property&gt; 改为：
&lt;property&gt; &lt;name&gt;hive.querylog.location&lt;/name&gt; &lt;value&gt;${system:java.io.tmpdir}/${user.name}&lt;/value&gt; &lt;description&gt;Location of Hive run time structured log file&lt;/description&gt; &lt;/property&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135aa35e6dea84be1b10c375299ed573/" rel="bookmark">
			2022年4月27日 复盘&amp;计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 4.27实在太累，放到了草稿箱，没有及时更新，现在补上
工作方面 重新把bug改完了，这时候，测试的才拉我和owner对需求………好吧~把昨天的设计方案实现了：
举个例子，
平台有：P，W
平台下有部门：部门A和部门B，
角色有：超管，PM，PL，普通用户
用户有：user1，
需求： 超管能对部门A/B进行所有的CRUD操作部门APM/PL只能对部门A进行CRUD，同理B普通用户只能R，不能进行CUD。. 晚上下班后，owner给我打电话说，我写的功能既不能添加，也不能删除，我很慌。现在有点睡不着。 周计划进度 查看线上环境的nginx配置。80%完成kafka结合Spring Boot的遗留问题。0%了解redis地理坐标&amp;bitmap。0% 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa13766d5740e8e755cf70b596697239/" rel="bookmark">
			【暑期实习】字节后端开发一二面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大约1h30min
开头把项目挨个问了一遍大致内容，没有问的很深。（我不理解为什么这些面试官都对我深度学习的项目很感兴趣，每个面试官都在这里追问），聊了很久。数据库索引有哪些？数据库的事务是什么，四大特性数据库的隔离级别？读修改是什么？聚簇索引和非聚簇索引匿名管道和有名管道知道吗？
数据库答得太差了，以至于面试官直接问我，你会啥…tcp三次握手第一次握手发的是什么？四次挥手中time_wait是什么？要等多久？ping使用什么协议？TCP拥塞控制的方法有哪些？进程间通信的方式有哪些？什么是虚拟内存？页面置换算法有哪些指针和引用的区别？const和#define 的区别通过模板类/方法，实现一个size方法，如果传入的是string，就返回字符串的长度；如果传入的是int，就返回sizeof（int）；如果传入的是double类型，就返回sizeof(double).算法：最近公共祖先结点，力扣236 提问环节，问了对数据库的要求程度，原来面试官的组是做搜索的。。。难怪疯狂问数据库。数据库学得太浅了，要恶补才行…
问了base，问我广州还是深圳
正常面试下来感觉面试官人很好，模板类有几个bug都在面试官引导下改出来；最后算法A出来还算快，一次过。除了数据库其他知识点答得都还行，许愿二面。
二面 大约1h10min
二面面试官看起来级别很高，应该是总监一类的，年龄很大
讲讲c++多态如何实现的说一说private，protected，public的区别。对象能不能访问protected。友元函数是什么能否通过虚函数绕过private权限？指针和引用的区别？c++STL知道哪些？ set和unordered_set有什么区别，应用场景是什么样的？排序用什么（一行代码）——sort函数。然后问sort底层实现，我说快排，他问还有没有别的，我说不知道了脑筋急转弯：一共有1000个石头，A,B两个人每次只能拿1-7个，最后拿的获胜。A先拿，问A能不能获胜？
回答用回溯法。面试官说可以是可以，但是能不能找规律。找了好久也没想到。算法：最短路径问题， 力扣 64
很简单的dp，秒出来后，面试官让优化空间 优化了好半天最后优化出来
9.反问环节，问有哪里需要加强的。面试官把问题抛回给我自己，我说我基础还行，但是数据库有待加强，这两天也在恶补。
说到这里面试官就问了我上次一面没答上来的索引问题，我答上了之后他也只是点点头。然后他说，我基础还行，算法有待加强，有时候一些细节处理不好，让我别紧张。
总体体验感觉还行，脑筋急转弯和算法优化卡了好久呜呜呜呜呜 许愿三面吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fe377df6683aa281b15f138f93c7c3/" rel="bookmark">
			电脑热键冲突怎么修改？Windows11热键设置更改方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		热键冲突是指在热键设置中设置的热键跟其它软件或者系统的热键有冲突，这些问题往往都存在与游戏当中，对于这一问题，可在系统设置中修改，下面我们一起来看看是如何操作的吧。
更多重装系统教程尽在小白系统重装官网
1、首先，按键盘上的 Win 键，或点击任务栏底部的开始图标。
2、这时候，会打开开始菜单，然后找到并点击已固定应用下的设置。
3、Windows 设置窗口，利用搜索框，输入语言，然后在打开的搜索结果中，选择编辑语言和键盘选项。
4、点击中文简体右侧的三个小点，然后选择语言选项。
5、键盘下，找到微软拼音输入法右侧的三个小点，然后选择键盘选项。
6、接着，点击按键（模式切换、候选字词、快捷键）。
7、模式切换下，就可以对微软拼音按键进行设置了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d4991d354a731b2de45be22d028642/" rel="bookmark">
			4-7 求e的近似值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自然常数 e 可以用级数 1+1/1!+1/2!+⋯+1/n!+⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n+1 项和。
输入格式： 输入第一行中给出非负整数 n（≤1000）。
输出格式： 在一行中输出部分和的值，保留小数点后八位。
输入样例： 10 输出样例： 2.71828180 这道题难度不大，跟前面的序列和一样的想法与思路，唯一不一样的就是各分母是阶乘，就有点卡，但是你想阶乘是小标一直乘到一，我们计算的第一个阶乘与下一个阶乘只是差啦下一项的下标，所以我们把每一项单独提出来，乘以下一项的下标就得到下一项的阶乘。
代码如下：
#include&lt;stdio.h&gt; int main(){ int n; double he=1,sum=1; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++){ he=he*1.0/i; //每一项乘以下标，得到下一项的阶乘 sum+=he; } printf("%.8f\n",sum); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8921dcefbeea291de17acf89e0f0ec4f/" rel="bookmark">
			python Matplotlib绘图基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建画布与子图 目录
1.创建画布与子图
2.添加画布内容
3.绘制的保存与显示
Matplotlib所绘制的图形位于图片(Figure)对象中，绘图常见的方法及说明如表格：
Matplotlib绘图常用方法及说明 函数函数作用plt.figure创建一个空白画布，可以指定画布大小figure.add_subplot创建并选中子图，可以指定子图行数、列数与选中图片编号 表中plt.figure的主要左右是构建一张空白的画布，并可以选择是否将整个画布分为多个区域，方便在同一幅图片上绘制多个图形。最简单的绘图可以省略plt.figure部分，而直接在默认的画布上进行图形绘制
例1.创建子图
import matplotlib.pyplot as plt fig = plt.figure() #不能使用空白的figure绘图，需要创建子图 ax1 = fig.add_subplot(2,2,1) ax2 = fig.add_subplot(2,2,2) ax3 = fig.add_subplot(2,2,3) 例2.绘制子图
import matplotlib.pyplot as plt fig = plt.figure() ax1 = fig.add_subplot(2,2,1) ax2 = fig.add_subplot(2,2,2) ax3 = fig.add_subplot(2,2,3) ax1.plot([1.5,2,3.5,-1,1.6]) 可以使用语句”fig,axes = plt.subplots(2,3)“创建一个新的图片，然后返回包含了已经成生的子图对象的NumPy数组。数组axes可以像二维数组那样方便地进行索引，如axes[0,1]，也可以通过sharex和sharey表明子图分别有相同的X轴和Y轴
例3.创建子图序列
import matplotlib.pyplot as plt fig,axes = plt.subplots(2,3) 例4.调整子图周围的间距
import matplotlib.pyplot as plt import numpy as np fig,axes = plt.subplots(2,2,sharex = True,sharey = True) for i in range(2): for j in range(2): axes[i,j].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8921dcefbeea291de17acf89e0f0ec4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ae463633d777370222246efb3cca4c/" rel="bookmark">
			path.resolve()的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在webpack的使用中，都会遇到配置output的情况，在path中有这么一段配置：
const path = require('path') module.exports = { ... output: { filename: './js/[name][contenthash].js', path: path.resolve(__dirname, 'dist') } } 其中有一段path.resolve(__dirname, ‘dist’)一直没明白是什么意思，关键是不知道resolve的作用是什么，官方给出的解释如下：
path.resolve([…paths])#
中英对照
新增于: v0.3.4
…paths 路径或路径片段的序列
返回: path.resolve() 方法将路径或路径片段的序列解析为绝对路径。
给定的路径序列从右到左处理，每个后续的 path 会被追加到前面，直到构建绝对路径。 例如，给定路径片段的序列：/foo、/bar、baz，调用 path.resolve(‘/foo’, ‘/bar’, ‘baz’) 将返回 /bar/baz，因为 ‘baz’ 不是绝对路径，而 ‘/bar’ + ‘/’ + ‘baz’ 是。
如果在处理完所有给定的 path 片段之后，还没有生成绝对路径，则使用当前工作目录。
生成的路径被规范化，并删除尾部斜杠（除非路径解析为根目录）。
官方给的解释比较隐晦，看完后还是不太清楚，故尝试带入不同的参数查看结果，过程如下：
resolve的用法 我们先来看一下带入不同参数给出的结果，代码中文件所在目录为：
F:\Workspaces\webpack\src
__dirname为node自带参数，返回的是当前文件所在目录
// path.js path.resolve() // 输出结果：F:\Workspaces\webpack path.resolve('/dist') // 输出结果：F:\dist path.resolve('dist') // 输出结果：F:\Workspaces\webpack\dist path.resolve('./dist') // 输出结果：F:\Workspaces\webpack\dist path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9ae463633d777370222246efb3cca4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcaae47190f426b3409406ce762dbc94/" rel="bookmark">
			电脑开机滴滴两声报警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		boss设置改动报警！
重新启动，狂按F1，进入boss设置界面。
((进入boss时可能会显示帮助信息，翻译一下也就懂怎么操作了，回车))
按F9(好像是系统自动优化配置的意思),回车，
按F10(保存配置信息)，回车
ok，重新启动问题就解决了！
就这么简单
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e17d523236f9e3c911a8544572c4c15/" rel="bookmark">
			在FPGA板上用Verilog实现车牌识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个车牌识别系统先在Matlab中实现，然后将其在FPGA Xilinx Spartan-6上使用Verilog实现。以下是FPGA上系统的测试环境。
图像存储器： 存储10个图像并将其转换为.dat格式（gray data）。我们使用$ readmemh（可复合）Verilog 命令，通过读取.dat文件中的gray data来初始化内存。将10个图像转换为Gray格式，并使用Matlab写入.dat文件。
车牌识别识别核心：使用 FPGA上的开关作为“启动”信号来触发此核心工作并输出车牌号。
监视LED ：当“完成”信号是上升沿时，该块显示车牌号。
详情参阅 - 亚图跨际
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943918e45497a68d8384e57aa1c9aab9/" rel="bookmark">
			关于S参数的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【系列专栏】：博主结合工作实践输出的，解决实际问题的专栏，朋友们看过来！
《QT开发实战》
《嵌入式通用开发实战》
《从0到1学习嵌入式Linux开发》
《Android开发实战》
《实用硬件方案设计》
长期持续带来更多案例与技术文章分享；
欢迎商业项目咨询，10年+软硬全栈内功，助力解决您的尊贵需求。
——————————————————————————————————
无源网络如电阻、电感、电容、连接器、电缆、PCB线等在高频下会呈现射频、微波方面的特性。S参数是表征无源网络特性的一种模型，在仿真中即用S参数来代表无源网络，在射频、微波和信号完整性领域的应用都很广泛。 本文将从S参数的定义，S参数的表达方式，S参数的特性，混合模式S参数，S参数测量等多个方面介绍S参数的一些最基本的知识。
1，S参数的定义
人们都喜欢用一句话来概括一个术语。 譬如用一句话来表达什么是示波器的带宽，笔者概括为：带宽就是示波器前端放大器幅频特性曲线的截止频率点。如何用一句话来回答什么是S参数呢？ 笔者在网上搜索了很多关于S参数的文章，现摘录几段关于S参数的定义。
在维基百科上，关于S参数的定义是：Scattering parameters or S-parameters (the elements of a scattering matrix or S-matrix) describe the electrical behaviors of linear electrical networks when undergoing various steady state stimuli by electrical signals. The parameters are useful for electrical engineering, electronics engineering, and communication systems design. 翻译成中文：散射参数或者说S参数描述了线性电气网络在变化的稳态电信号激励时的电气行为。 该参数对于电气工程、电子工程和通信系统的研发是很有用的。（ 抱歉，英语水平太差，翻译得很别扭。）这个定义似乎不够好！ 在另外一篇文章中的定义是：The S-parameter (Scattering parameter) expresses device characteristics using the degree of scattering when an AC signal is considered as a wave.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943918e45497a68d8384e57aa1c9aab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2895e33cb9047061580e2ccea46d2536/" rel="bookmark">
			通信接口——RS-232与RS-422及RS-485三者之间的特性与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【系列专栏】：博主结合工作实践输出的，解决实际问题的专栏，朋友们看过来！
《QT开发实战》
《嵌入式通用开发实战》
《从0到1学习嵌入式Linux开发》
《Android开发实战》
《实用硬件方案设计》
RS232概述 RS-232接口符合美国电子工业联盟（EIA）制定的串行数据通信的接口标准，原始编号全称是EIA-RS-232（简称232，RS232）。它被广泛用于计算机串行接口外设连接。连接电缆和机械、电气特性、信号功能及传送过程。
RS-232-C标准规定的数据传输速率为每秒50、75、100、150、300、600、1200、2400、4800、9600、19200波特。
RS232特点： RS-232是现在主流的串行通信接口之一。由于RS232接口标准出现较早，难免有不足之处，主要有以下四点：
（1）接口的信号电平值较高，易损坏接口电路的芯片。RS232接口任何一条信号线的电压均为负逻辑关系。即：逻辑“1”为-3—-15V；逻辑“0”：+3—+15V，噪声容限为2V。即要求接收器能识别高于+3V的信号作为逻辑“0”，低于-3V的信号作为逻辑“1”，TTL电平为5V为逻辑正，0为逻辑负。与TTL电平不兼容故需使用电平转换电路方能与TTL电路连接。
（2）传输速率较低，在异步传输时，比特率为20Kbps；因此在51CPLD开发板中，综合程序波特率只能采用19200，也是这个原因。
（3）接口使用一根信号线和一根信号返回线而构成共地的传输形式，这种共地传输容易产生共模干扰，所以抗噪声干扰性弱。
（4）传输距离有限，最大传输距离标准值为50英尺，实际上也只能用在15米左右。
RS485概述 在要求通信距离为几十米到上千米时，广泛采用RS-485串行总线。RS-485采用平衡发送和差分接收，因此具有抑制共模干扰的能力。加上总线收发器具有高灵敏度，能检测低至200mV的电压，故传输信号能在千米以外得到恢复。
RS-485采用半双工工作方式，任何时候只能有一点处于发送状态，因此，发送电路须由使能信号加以控制。
RS485特点： RS-485用于多点互连时非常方便，可以省掉许多信号线。应用RS-485可以联网构成分布式系统，其允许最多并联32台驱动器和32台接收器。针对RS-232-C的不足，新标准RS-485具有以下特点：
（1）RS-485的电气特性：逻辑“1”以两线间的电压差+2V~+6V表示，逻辑“0”以两线间的电压差-6V~-2V表示。接口信号电平比RS-232-C降低了，就不容易损坏接口电路芯片，且该电平与TTL电平兼容，刻方便与TTL电路连接。
（2）数据最高传输速率为：10Mbps
（3）RS-485接口采用平衡驱动器和差分接收器的组合，抗共模干扰能力强，即抗噪声性能好。
（4）RS-485接口的最大传输距离标准值4000英尺，实际上可达3000米。
（5）RS-232-C接口在总线上只允许连接一个收发器，即单站能力；而RS-485接口在总线上只允许连接多达128个收发器，即具有多站能力，这样用户可以利用单一的RS-485接口方便地建立设备网络。
RS422概述 RS-422标准全称是“平衡电压数字接口电路的电气特性”，它定义了接口电路的特性。实际上还有一根信号地线，共5根线。由于接收器采用高输入阻抗和发送驱动器比RS232更强的驱动能力，故允许在相同传输线上连接多个接收节点，最多可接10个节点。一个主设备（Master），其余为从设备（Slave），从设备之间不能通信，所以RS-422支持点对多的双向通信。接收器输入阻抗为4k，故发端最大负载能力是10&amp;TImes;4k+100Ω（终接电阻）。
RS-422和RS-485电路原理基本相同，都是以差动方式发送和接受，不需要数字地线。差动工作是同速率条件下传输距离远的根本原因，这正是二者与RS232的根本区别，因为RS232是单端输入输出，双工工作时至少需要数字地线。发送线和接受线三条线（异步传输），还可以加其它控制线完成同步等功能。
RS-422通过两对双绞线可以全双工工作收发互不影响，而RS485只能半双工工作，发收不能同时进行，但它只需要一对双绞线。RS422和RS485在19kpbs下能传输1200米。用新型收发器线路上可连接台设备。
RS-422的电气性能与RS-485完全一样。主要的区别在于：RS-422有4根信号线：两根发送（Y、Z）、两根接收（A、B）。由于RS-422的收与发是分开的所以可以同时收和发（全双工）；RS-485有2根信号线：发送和接收。
RS422特性： RS-422四线接口由于采用单独的发送和接收通道，因此不必控制数据方向，各装置之间任何必须的信号交换均可以按软件方式（XON/XOFF握手）或硬件方式（一对单独的双绞线）。RS-422的最大传输距离为4000英尺（约1219米），最大传输速率为10Mb/s。其平衡双绞线的长度与传输速率成反比，在100kb/s速率以下，才可能达到最大传输距离。只有在很短的距离下才能获得最高速率传输。一般100米长的双绞线上所能获得的最大传输速率仅为1Mb/s。
RS-422需要一终接电阻，要求其阻值约等于传输电缆的特性阻抗。在短距离传输时可不需终接电阻，即一般在300米以下不需终接电阻。终接电阻接在传输电缆的最远端。
RS-232/RS-422/RS-485三者间的区别 1、RS232是全双工的，RS485是半双工的，RS422是全双工的。
2、RS485与RS232仅仅是通讯的物理协议（即接口标准）有区别，RS485是差分传输方式，RS232是单端传输方式，但通讯程序没有太多的差别。
PC机上已经配备有RS232，直接使用就行了，若使用RS485通讯，只要在RS232端口上配接一个RS232转RS485的转换头就可以了，不需要修改程序。
RS232/RS422/RS485接口外观有区别吗？
一般都是DB9，也有其他的，还是得看里面的线才知道到底是rs232rs422rs485里的哪种。
RS232是标准接口，为D形9针头，所连接设备的接口的信号定义是一样的，其信号定义如下：
RS-232只允许一对一通信（单站能力）
RS-485接口在总线上是允许连接多达128个收发器（具有多站能力）
由于PC机默认的只带有RS232接口，有两种方法可以得到PC上位机的RS485电路：
（1）通过RS232/RS485转换电路将PC机串口RS232信号转换成RS485信号，对于情况比较复杂的工业环境最好是选用防浪涌带隔离珊的产品。
（2）通过PCI多串口卡，可以直接选用输出信号为RS485类型的扩展卡。
计算机通过RS232-RS485转换器，依次连接多台485设备（门禁控制器），采用轮询方式，对总线上的设备轮流进行通讯。
接线标示是485+485-，分别对应链接设备（控制器）的485+485-。
通讯距离：最远的设备（控制器）到计算机的连线理论上的距离是1200米，建议客户控制在800米以内，能控制在300米以内效果最好。如果距离超长，可以选购485中继器（延长器）（请向专业的转换器生产公司购买，中继器的放置位置是在总线中间还是开始，请参考相关厂家的说明书。）选购中继器理论上可以延长到3000米。
负载数量：即一条485总线可以带多少台设备（控制器），这个取决于控制器的通讯芯片和485转换器的通讯芯片的选型，一般有32台，64台，128台，256台几种选择，这个是理论的数字，实际应用时，根据现场环境，通讯距离等因素，负载数量达不到指标数。微耕公司控制器和转换器按256台设计，实际建议客户每条总线控制在80台以内。
485通讯总线（必须用双绞线，或者网线的其中一组），如果用普通的电线（没有双绞）干扰将非常大，通讯不畅，甚至通讯不上。
每台控制器设备必须手牵手地串下去，不可以有星型连接或者分叉。如果有星型连接或者分叉，干扰将非常大，通讯不畅，甚至通讯不上。
某技术大牛讲的文章很深入透彻：http://www.rfsister.com/article/23575135.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945e5af1d20404ed082616a25a77203b/" rel="bookmark">
			Go语言-UDP编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1、服务端配置
2、客户端配置
3、多客户端对接消息
前言 UDP是用户数据报协议，是一种无连接传输协议，不需要建立连接就可以直接发送和接收数量，属于不可靠的，没有时序的通信，UDP实时性好，适合直播环境。
1、服务端配置 package main import ( "fmt" "net" ) //UDP服务端配置 func main() { //1:启动监听 listener, err := net.ListenUDP("udp", &amp;net.UDPAddr{ IP: net.ParseIP("127.0.0.1"), Port: 30000, }) if err != nil { fmt.Println("启动server失败，err：", err) return } defer listener.Close() //获取连接数据 for { var buf [1024]byte n, addr, err := listener.ReadFromUDP(buf[:]) if err != nil { fmt.Println("读取失败,err:", err) return } //信息输出 fmt.Printf("来自%v的消息：%v\n", addr, string(buf[:n])) //信息回复 _, err = listener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/945e5af1d20404ed082616a25a77203b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb231920a3fc1779f07e182207952df3/" rel="bookmark">
			std::chrono::system_clock::now
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::chrono::system_clock::now 使用std::chrono::system_clock::now计时的方法
auto tp_start = std::chrono::system_clock::now();
std::time_t start = std::chrono::system_clock::to_time_t(tp_start);
/**
需要计时的程序
*/
auto tp_end = std::chrono::system_clock::now();
std::time_t end = std::chrono::system_clock::to_time_t(tp_end);
if(end - start &gt;10) { //10的单位为S；
}
注释：
1、std::chrono::system_clock::now(); //值为 2022-04-30 08:00:00
2、to_time_t把2014年12月19日10：24：40这样的QDateTime的格式转变为1418955940这样的时间戳（单位为S）；
3、与to_time_t功能相反的是from_time_t()，把时间戳转为QDateTime类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70676e710cca5621a7417e54fee6aad/" rel="bookmark">
			Go语言-TCP编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、客户端和服务端模型
2.、服务器端配置
3.、客户端配置
4、优化聊天模式
1、客户端和服务端模型 socket: BSD UNIX的进程通信机制，通常也称作套接字”，用于描述IP地址和端口，是一个通信链的句柄。
socket可以理解为TCPIP网络的API,它定义了许多函数，程序员可以使用它来开发TCPIP网络的应用程序。
计算机上运行对应用程序通常通过“套接字”向网络发出请求或者应答网络请求。
服务端处理流程：
① 监听端口。
② 接收客户端连接。
③ 创建goroutine，处理此连接。
客户端处理流程：
① 建立与服务端连接。
② 进行数据收发。
Apache是同步模型，Nginx是异步模型
2.、服务器端配置 一个服务端连接多个客户端，例如:世界各地的用户使用自己电脑的浏览器访问淘宝网。
package main import ( "fmt" "net" ) //处理客户端连接请求 func process(coon net.Conn) { defer coon.Close() //定义接收信息的字节数组 var buf [1024]byte //读取数据 n, err := coon.Read(buf[:]) if err != nil { fmt.Println("获取信息失败，err:", err) return } fmt.Printf("对方回复信息是：%s", string(buf[:n])) } //TCP服务端配置 func main() { //1：启用监听 listener, err := net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e70676e710cca5621a7417e54fee6aad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ed8894ee06d279c6d21af09c82e79a/" rel="bookmark">
			C语言嵌套结构的编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;string.h&gt; #define AS 5 #define QW 20 #define RR 2 struct ww { char w[QW]; char e[QW]; char r[QW]; }; struct ss { char q[QW]; struct ww f; }; void vv(struct ss *g); struct ss h[AS]; int main(void) { char* ch; char cc; int a = 0; struct ss* pc; char d[QW]; while (a &lt; RR) { pc = &amp;h[0]; printf("请输入社会保险号："); gets_s((pc+a)-&gt;q, QW - 1); printf("请输入成员代表名："); gets_s((pc+a)-&gt;f.w, QW - 1); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ed8894ee06d279c6d21af09c82e79a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7073f0be63b60d12aabf812afeb1086/" rel="bookmark">
			什么是RTOS？RTOS与普通操作系统的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：什么是RTOS RTOS(Real-Time Operating System)，实时操作系统。实时性是其最大特征，实时操作系统中都要包含一个实时任务调度器，这个任务调度器与其它操作系统的最大不同是强调：严格按照优先级来分配CPU时间，并且时间片轮转不是实时调度器的一个必选项。
也可以这样理解：
实时操作系统（RTOS）是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。
实时系统的正确性不仅依赖系统计算的逻辑结果，还依赖于产生这个结果的时间。
换句话说，系统设计时所有的事件都可以在指定的时间内得到响应（时间确定性）。
如果系统关键任务响应时间都满足这条标准，则这样的实时系统可称为硬实时系统。
提供及时响应和高可靠性是RTOS的主要特点。
二：RTOS与普通操作系统的区别 与通用的分时操作系统不同（Linux、Windows、Unix等），实时操作系统在航空航天、军事与工业自动化领域更具优势，首先实时操作系统有着分时操作系统无法比拟的响应时间确定性，实时操作系统从调度器算法，到中断响应系统，到消息传递机制等所有的核心算法时间复杂度都是O（1），它表示系统的响应速度不依赖于系统任务的多少，负载的轻重，而只依赖于优先级的设计，就算当前系统满负荷运行，优先级高的事件发生后，系统还将会在指定的时间内立即响应事件。由于这种设计理念和算法上的优势，根据相关数学理论，分时系统在负载严重的情况下是不能通过提升处理器性能来获得确定的响应时间。
这种算法上的优势是通用分时系统所难以比拟的，而通用分时系统则更多考虑的是系统易用性、平衡性和数据吞吐率。
实时系统与分时系统设计思想和应用领域完全不同，不存在替代关系，而是一种互补关系。
我们常用的Windows XP windows 7/8/10，等都是分时系统，它打开文件，程序，不存在时间的确定性，而且快2秒，慢5秒不会对我们的生活和工作造成影响;
实时操作系统大部分是运行在芯片的底层，比如美国的Vx Works，RT-linux，我们国产的SylixOS,这些大型的实时操作系统实时的控制着最底层的应用，时间确定的执行着设定任务，例如火箭发射中定是分离，调整轨道等;
三：什么是硬实时？什么是软实时？ 硬实时与软实时之间最关键的差别在于，软实时只能提供统计意义上的实时。例如，有的应用要求系统在95%的情况下都会确保在规定的时间内完成某个动作，而不一定要求100%。
在许多情况下，这样的“软性”正确率已经可以达到用户期望的水平。比如，用户在操作DVD播放机时，只要98%的情况都能正常播放，用户可能就满意了;
而发射卫星、控制核反应堆的应用系统，这些系统的实时性必须达到100%，是绝对不允许出现意外。
硬实时系统有一个刚性的、不可改变的时间限制，它不允许任何超出时限的错误。超时错误会带来损害甚至导致系统失败、或者导致系统不能实现它的预期目标。
软实时系统的时限是一个柔性灵活的，它可以容忍偶然的超时错误。
实时操作系统就是在规定的时间内必须正确地完成操作，完成操作的时间有操作系统的因素，也有用户软件的因素。
非实时操作系统指操作系统无法保证哪怕是最高优先级任务开始执行的最后时限。
只有“非屏蔽中断＋执行时间确定的ISR”才可以称为硬实时系统，因为这个系统明确告诉我什么时候完成操作。
著名的硬实时系统包括：
VxWorks,SylixOS,RTlinux, ThreadX, QNX,Nucleus等.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569e80a05a4d759dd4b7bb2338ff99a1/" rel="bookmark">
			Arduino安全和警报系统项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个项目中，我们将学习如何制作一个Arduino安全和警报系统。您可以观看以下视频或阅读下面的书面教程。
Arduino安全和警报系统项目
概述
按下A按钮后10秒内将激活警报。 为了检测物体，它使用了超声波传感器，一旦警报器检测到某种东西，蜂鸣器就会开始发出声音。 为了停止警报，我们需要输入4位数字的密码。 预设密码是1234，但我们也可以更改它。
通过按B按钮，我们进入密码更改菜单，首先我们需要输入当前密码以继续，然后输入新的4位数字密码。 更改密码后，下次启动警报时，我们只能通过输入新密码来停止警报。 如果输入了错误的密码，我们将收到一条消息，需要再次尝试。
所需组件
现在，让我们看看该项目所需的组件。显然，我们需要一个Arduino板，一个超声波传感器，一个LCD显示器，一个蜂鸣器和一个4×4键盘。
电路原理图
这是电路原理图。
图略
因此，对于蜂鸣器，我们只需要一个引脚即可，但需要一个PWM引脚。 4×4键盘有8个引脚，其中4个用于行，而4个用于列。 每个按钮实际上都是一个按钮开关，按下该按钮可使行和列之间短路。
因此，例如，如果我们将第1行的行设置为低，而将所有列的行设置为高，则当我们按下按钮3时，由于两行之间的短路，第3列的行将降为低 在这种情况下，我们可以注册按钮3已被按下。
至于该项目的其他两个组件，即超声波传感器和LCD显示屏，您可以查看我之前有关如何连接和使用它们的详细教程。
Arduino报警系统源代码
接下来让我们看一下Arduino代码。由于代码较长，为了更好地理解，我将在各节中分别发布该程序的源代码和每个部分的说明。在本文结尾处，我将发布完整的源代码。
因此，我们需要包括用于LCD的标准LiquidCrystal库和需要额外安装的键盘库。 然后，我们需要定义蜂鸣器和超声波传感器的引脚，定义程序所需的一些变量，定义键盘的键，以及为键盘和LCD创建两个对象。
详情参阅 - 亚图跨际
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971f9728ac68c5e99bf7ad116592a0ce/" rel="bookmark">
			深入理解类加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解类加载 一:类文件到虚拟机二: 类加载过程2.1：装载2.2 验证2.2.1 文件格式验证2.2.2 元数据验证2.2.3 字节码验证2.2.4 符号引用验证 2.3 准备2.4 解析2.5 初始化2.6 使用2.7 卸载 一:类文件到虚拟机 💡:类加载就是将字节码文件加载到内存，并生成数据访问入口的机制，
类加载的最终目的是生成数据访问入口。
图示:
那么字节码文件是如何加载进内存的呢？这就要涉及类加载机制。
二: 类加载过程 所谓类加载本质上就是把Class文件加载进内存，并对数据进行校验，解析，初始化，最终生成Java虚拟机能够之间使用的数据，即java.lang.Class对象。
2.1：装载 装载:
通过一个类的全限定名获取一个类的二进制字节流。将这个二进制字节流所代表的静态储存结构转化为方法区运行时数据结构。在内存中生成代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口。 注意：JVM官方并为指定从class文件中获取一个类的二进制字节流，也就是说并为指定从哪里获取二进制字节流，这给开发者提供了开发的环境，我们一般有以下几种方式获取一个类的二进制字节流。
从本地系统中直接加载
典型场景：这个我就不废话了通过网络下载.class文件
典型场景：Web Applet，也就是我们的小程序应用从zip，jar等归档文件中加载.class文件
典型场景：后续演变为jar、war格式从专有数据库中提取.class文件
典型场景：JSP应用从专有数据库中提取.class文件，较为少见将Java源文件动态编译为.class文件，也就是运行时计算而成
典型场景：动态代理技术从加密文件中获取， 典型场景：典型的防Class文件被反编译的保护措施 2.2 验证 验证主要是为了确保Class文件中的字节流包含的信息完全符合当前虚拟机的要求，并且还要求我们的信息不会危害虚拟机自身的安全，导致虚拟机的崩溃。
而验证过程主要分为以下四种验证
2.2.1 文件格式验证 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。这阶段的验证是基于二进制字节流进行的，只有经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面验证都是基于方法区的存储结构进行的。
2.2.2 元数据验证 对类的元数据信息进行语义校验（其实就是对Java语法校验），保证不存在不符合Java语法规范的元数据信息。
2.2.3 字节码验证 进行数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。获取类的二进制字节流的阶段是我们JAVA程序员最关注的阶段，也是操控性最强的一个阶段。因为这个阶段我们可以对于我们的类加载器进行操作，比如我们想自定义类加载器进行操作用以完成加载又或者我们想通过JAVA Agent来完成我们的字节码增强操作。
2.2.4 符号引用验证 这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。
2.3 准备 为类变量赋初值，这里的初值是类型的默认值，即零值。
注意:这里会为基础数据类型赋对应的初值，而引用数据类型为空值。final static 修饰的变量在编译的阶段就已经赋值了，在准备阶段会显示初始化。准备阶段不会为实例变量赋值，实例变量会随类一起被加载到堆区去。 2.4 解析 我们只需要知道在解析阶段注意发生的事就是将符号引用转换为直接引用。
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。
2.5 初始化 初始化阶段主要是执行类构造器()方法的过程。
在准备阶段类变量已经赋值过零值，在该阶段主要是按照程序员设置的计划为类变量赋值。
说的通俗些该过程是执行&lt; clinit &gt;()方法的过程，这个方法不需要我们程序员编写，会由编译器在编译的时候自动收集类变量的直接初始化和静态代码块中初始化的信息生成的类构造方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971f9728ac68c5e99bf7ad116592a0ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a27c76c508ddb1492fb3ee7606c2de/" rel="bookmark">
			聊聊微服务拆分原则之 AKF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们搭建集群的时候,首先要想明白需要解决哪些问题,搞清楚这个之前,想想单节点、单实例、单机有哪些问题?
单点故障
容量有限
可支持的连接有限(性能不足)
......
为了解决这些问题,我们需要对服务器进行集群,一变多,具体怎们扩充服务器呢?
这儿引入一个概念,微服务设计原则之一——AKF原则
微服务拆分原则之AKF 首先来看单节点的单点故障这个问题,既然单节点容易挂,那么就可以进行复制,一变多,这儿设计到三个概念,主从、主主、主备,也是三种方式,简单来说,主主相当于多台服务器同时对外提供读写:
主从,主机可以读写,但是一般只对外提供写,从机对外提供读:
主备,主机提供读写,备机不对外提供服务,当主机挂了的时候,备机通过选举产生主机对外提供服务。
X轴拆分 可以看到的是,这几种拆分一台机器可以看成另一台机器的镜像,基本具有全量数据,这种拆分模式就是AKF拆分模式之一:X轴拆分
上图就是AKF拆分示意图,为了解决单点故障,所以弄几台全量数据的机器做备份,例如之前说到的主主、主备等,特点是任何两台包含的数据是差不多的,一台可以看成另一台的镜像。
Y轴拆分 这时候又有新的问题,例如一台服务器中,可能某些功能被频繁访问,涉及到的数据频繁读写,其他数据基本不怎么访问,这时候可以将这部分数据独立出来,也就是根据功能、业务继续拆分服务器,这种拆解就是AFK中的Y轴拆分
特点是Y轴纵向来看不同的Redis负责的功能是不同的,也就是所包含的数据也是不同的,另外仅仅扩展出一个Y轴上的业务服务器,又可能会存在单点问题,所以可以结合AFK的X轴拆分原则,继续对刚拆分的Y轴上的点进行X轴拆分。
Z轴拆分 在上面的AFK原则X-Y拆分之后,对服务器显示做了主从主备复制,然后做了业务拆分,不同的Redis负责不同的业务请求,这时候还会有一个新的问题,例如对于Y轴上一个Redis,它负责某一样业务,但是这天这个业务的数据访问巨大,贼大,那就只好对数据请求进行AFK的Z轴拆分,例如先分析下数据请求的情况,然后根据访问来源,分为北京的、上海的,这样不同的Redis虽然是负责不同的数据,但是负责的业务是一样的。AFK拆分图示:
AFK总结 X轴拆分:水平复制，就是讲单体系统多运行几个实例，做集群加负载均衡的模式,主主、主备、主从。
Y轴拆分:基于不同的业务拆分
Z轴拆分:基于数据拆分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f051aef8c690618377d656c269c6dd2/" rel="bookmark">
			css及css3详细学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS 概念：css（cascading style sheet）-层叠样式表
层叠：css的一个特点，指的是样式覆盖时的处理方式，
样式：页面的外在特征。比如说背景颜色、字体大小、类型、边框大小等。即CSS就是专门用于处理页面样式的。
作用：美化页面。
跟HTML之间的关系：
HTML：书写网页的内容
CSS：对页面进行美化
使用方式：
内联方式：通过&lt;head&gt;中添加&lt;style&gt;标签，并在&lt;style&gt;中书写CSS代码。
外联方式：新建以.css为后缀的文件，在文件李写css代码，在HTML页面通过&lt;link&gt;标签来引入并使用css文件。
特点：将样式代码和HTML代码分离的更彻底，存在不同的文件当中，而且css文件可以在多个HTML页面中使用。
&lt;link href="css文件地址" rel="stylesheet" type="text/css"&gt;
代码格式：css选择器{css属性名：属性值；}
style属性：直接在HTML标签里通过style属性来书写css代码。
&lt;p style="color:red;"&gt;&lt;/p&gt;
所有标签都支持style属性，一般需要最高优先级的时候才用style属性，一般推荐css文件&gt;style标签&gt;style属性
优先级：style属性&gt;style标签&gt;css文件
基础属性： background-color:设置背景颜色
color：设置文本颜色
font-size：设置文字大小，以px为单位。
border：设置某个标签的边框。
margin：处理标签之间的距离。
背景： background-color:设置背景颜色,
background-image：设置某个标签的背景图片，
background-image：url（图片地址）；
background-repeat：设置背景图片是否允许重复，
background-repeat：repeat/no repeat/repeat-x/repeat-y。
background-size：设置背景图片是否拉伸，
background-size：cover 拉伸 。
background-size：contain 尽可能让整张图片尺寸和标签的尺寸贴切，但不会超出标签的宽高。
文字： font-size：设置文字大小；
text-align：设置某个标签内部内容的对齐方式，left、center、right，默认left。
text-decoration：设置超链接的字体样式，
text-decoration：underline/none/line-through。
font-family：设置文字的字体类型，
font-family："微软雅黑"，"宋体"，"黑体"，支持写多个字体，当上一个字体没有找到了，会寻找下一个字体，如果都没有，使用系统默认字体。
font-weight：100~900/bold/bolder 设置字体粗细
line-height：设置某个标签内部文字的行高，行高指一行文字所占的高度。对于行高，一行中的文字始终会显示在行高的中间。
尺寸： width：设置标签宽度；
height：设置标签高度
列表： list-style：设置列表样式；
list-style：none/circle
list-style基本是列表专属
将垂直列表变成水平列表：给li设置float：left。
盒模型： padding：设置内容和边框之间的距离。列表有默认padding，如果要去掉，可以将padding设置为0.
表格： border-spacing：用于设置单元格之间的空隙，替代cellspacing。
表单：
vertical-align：设置标签的垂直对齐方式，适用于表单元素或img
vertical-align：middle/top/bottom 选择器： 标签选择器：通过标签名，利用css对页面上所有同类标签设置样式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f051aef8c690618377d656c269c6dd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba07029aadbeaf2c5a3b85fb02bbbdf/" rel="bookmark">
			批量替换角标，为角标添加中括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在word中使用快捷键CTRL + H打开查找替换，不能重复替换，会导致多重中括号
具体操作方式如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2309be2360f1ae2df7b84776afe17525/" rel="bookmark">
			转录组-差异基因火山图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ##增强版火山图1##
getwd() gene_info&lt;-read.csv("gene_info.csv")#gene信息表 gene_exp&lt;-read.csv("gene_exp.csv")#行名=sample_info列名；gene表达量数据表 de&lt;-read.csv("de.csv")#差异基因表 library(tidyverse) de_result&lt;-left_join(de,gene_info,by=c("id"="GID"))#关联基因信息表 de_result2&lt;-left_join(de_result,gene_exp,by=c("id"="GID"))%&gt;%#关联基因表达表 arrange(desc(abs(log2FoldChange)))#按abs(log2FoldChange)从大到小/小到大？排序 #查看差异基因总数 group_by(de_result2,direction)%&gt;% summarise(count=n()) #install.packages("EnhancedVolcano") #BiocManager::install("EnhancedVolcano") library(EnhancedVolcano) library(ggplot2) #BiocManager::install("ggrepel") library(ggrepel) EnhancedVolcano(de_result2, lab=de_result2$id, x="log2FoldChange", y="padj", FCcutoff=2,#改变FC阈值，默认为1 pCutoff=0.01)#改变pvalue阈值，默认为0.05 #保存到csv write.csv(de_result2, file="de_result2.csv", row.names = F,quote = F) save(de_result2,file="de_result3.rdate") ##火山图2##
getwd() de1&lt;-read.csv("diff_detail.csv")#全部基因信息表 library(tidyverse) #添加调控信息，添加一列为regulate de1 %&gt;% mutate(regulate = case_when(log2FoldChange&gt;1&amp;padj&lt;0.05 ~ "up", log2FoldChange&lt;(-1)&amp;padj&lt;0.05 ~ "down", TRUE ~ "ns")) -&gt;de1 #统计个数 table(de1$regulate) #ggplot2绘图 library(ggplot2) ggplot(de1,aes(log2FoldChange,-log10(padj),color = regulate))+ geom_point()+ scale_color_manual(values = c("blue", "gray", "red"))+ xlim(-10,10) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b47c145f6968889a42ec19183c78a5a/" rel="bookmark">
			bug:jar:1.0-SNAPSHOT is missing, no dependency information available
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 bug:jar:1.0-SNAPSHOT is missing, no dependency information available
解决bug
都是打包，由上到下的包括
packsge到本项目路径下的target
install会打包到本地仓库
deploy还打包到私有服务器
所以你会发现，把项目copy一份就单纯的运行备份，bug没有出现了，明明备份什么都没有改。
因为本地仓库有了，名字相同就会调用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0e5743b5a50369c2dee790e3a6d42b/" rel="bookmark">
			基于情感词典进行情感态度分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情感分析是指挖掘文本表达的观点，识别主体对某客体的评价是褒还是贬，褒贬根据进态度行倾向性研究。文本情感分析可以分为基于机器学习的情感分类方法和基于语义理解的情感分析。基于机器学习进行语义分析的话需要大量的训练集，同时需要人工对其进行分类标注。我所使用的方法是基于语义理解中的使用情感词典进行情感态度分析。
下面是我所使用的情感词典：
链接：https://pan.baidu.com/s/1toX2wqlIe2H-o_T6MFen1A 提取码：gobt
复制这段内容后打开百度网盘手机App，操作更方便哦
情感词典有很多种，比如哈工大整理的，知网情感词典以及台湾大学NTUSD简体中文情感词典等，但并不是每个词典对于我们来说都是有用的，我们要根据自己的文本内容来选择合适的情感词典。
进行情感分析，我们不能按照自己怎么想就去怎么进行分析，需要一定的支撑条件。我所用的算法是根据北京交通大学杨立月和王移芝两位所写的“微博情感分析的情感词典构造及分析方法研究”这篇论文所编写的，这论文的地址微博情感分析的情感词典构造及分析方法研究 - 中国知网
进行情感分析的大致流程如下图：
第一步先对文本进行预处理：
这里对文本进行预处理就是对句子进行分词，分词工具有很多，我选择的是使用python中的结巴分词，这个分词工具很好用，可以在分词的同时将词性也分析出来。不过在分词之前，对于一段文本内容来说，并不是所有的内容都对情感分析有帮助，比如一本书的书名，微博文本的标题以及一些非中文内容等，时候这个就我们可以用正则表达式只匹配我们需要的内容
import jieba.posseg as pseg #包括了词性（词语，词性） def seg_word(sentenct): d = "" sentenct = re.sub(u"\\#.*?\\#|\\@.*?\\ |\\《.*?\\》|【.*?】", "", sentenct) # 处理#...#和@... （空格）间的数据 s = re.compile(r'http://[a-zA-Z0-9.?/&amp;=:]*', re.S) sentenct = s.sub("", sentenct) segList = pseg.cut(sentenct) #分词 segResult = [] data_c = [] data_p =[] for word,flag in segList: if ('\u4e00' &lt;= word &lt;= '\u9fa5'): #判断字符串是否为中文 if len(word)&gt;1: data_p.append(word) segResult.append(word) s = word + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa0e5743b5a50369c2dee790e3a6d42b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/418c577ee30cc94da3133e513cc4cfc4/" rel="bookmark">
			拼多多电商部java岗三面落选，记下的面试题，不睡觉都要背下来！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直忍着准备放个大招，没想到还是被刷了...
前阵子，在准备拼多多的面试，好不容易挺近了三面，没想到被一波完虐，最终面试官请我回家等候通知了。
在等候面试过程中，跟周围的程序员同僚聊了起来，顺便加了一手联系方式。
嘿嘿，虽然没有过面试，但是东拼西凑，加上自己记下的面试题，把面试内容基本都统计了下来。
拼多多一面 1、项目中遇到的问题，及解决方案？
基本上都问到了这个问题，还好早有准备。之前看过介绍项目的star法则，我就跟面试官一唱一喝，把项目介绍介绍完了。(没有自己一个人长篇大论的说，稍加引导似的让面试官问我相关技术问题，回答起来当然就得心应手啦)
2、项目中用到的一些技术？
整个一面基本上都是围绕我之前做过的项目来讲的，也没什么好说的。面完之后，从面试官的表情看似乎对我挺满意的，自然就顺利进入二面了。(可见之前做了充足的准备，还是有好处的)
二面、三面 据说的电商部的一个主管和部门负责人，有点紧张，没有注意，稍微问了一下项目，就开始技术碾压了。
注意：我已经将这些面试题和答案汇总成了文档，需要的程序员朋友帮忙转发一下文章，私信 “真题” 免费领取了
并发编程三要素？实现可见性的方法有哪些？多线程的价值？创建线程的有哪些方式？创建线程的三种方式的对比？线程的状态流转图Java 线程具有五种基本状态什么是线程池？有哪几种创建方式？四种线程池的创建线程池的优点？常用的并发工具类有哪些？CyclicBarrier 和 CountDownLatch 的区别synchronized 的作用？volatile 关键字的作用sleep 方法和 wait 方法有什么区别?什么是 CASCAS 的问题什么是 Future？什么是 AQSAQS 支持两种同步方式ReadWriteLock 是什么FutureTask 是什么synchronized 和 ReentrantLock 的区别什么是乐观锁和悲观锁线程 B 怎么知道线程 A 修改了变量synchronized、volatile、CAS 比较为什么 wait()方法和 notify()/notifyAll()方法要在同步块中被调用多线程同步有哪几种方法？线程的调度策略ConcurrentHashMap 的并发度是什么？Linux 环境下如何查找哪个线程使用 CPU 最长死锁的原因？Java 死锁以及如何避免？怎么唤醒一个阻塞的线程？不可变对象对多线程有什么帮助？什么是多线程的上下文切换？如果你提交任务时，线程池队列已满，这时会发生什么？Java 中用到的线程调度算法是什么？什么是线程调度器(Thread Scheduler)和时间分片(TimeSlicing)？什么是自旋？Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？等等等等... 还有一堆就不列出来了，这些面试题都是我整理融合在一起的，有些重复的都去掉了。
相信大家都看出来了，逮着多线程和并发往死里虐啊这是！
自认为在多线程并发这方面做了一些功课，也扛不住360度无死角扫射袭击啊！
于是，通过网上四处找答案，找博客，把问题重新整理了一遍
另外还收罗了一套大厂面试真题
这些真题内容小编这里已经整理好了，需要领取的朋友麻烦转发、转发、转发这篇文章，然后私信小编【真题】就可以免费领取了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bdc1a5450f83e7a5d99b2a794170d0f/" rel="bookmark">
			同事拿下阿里菜鸟P6offer，程序员：没看两本书还真不敢去跳槽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前阵子，小天的同事程序员H偷偷的向阿里菜鸟投递了自己的简历...
不久后程序员H就收到了阿里菜鸟的面试通知，经历5轮面试，一举成功拿下offer并定级P6。
小天趁着未来的阿里大佬还在身边，向程序员H讨教了一下面试阿里菜鸟的经验，于是有了下面的情景：
小天把程序员H叫到了公司外面的阳台上，伸手递了一根相思鸟。
小天(小声地)：大佬，你那边准备什么时候入职哇？
程序员H：唉~不知道呀，我想尽早过去，但是这边离职流程走下来至少也得一个月，难搞哦！
小天：确实，以大佬你的能力，在这里一个月才拿8.5k实在是有点屈才了...
程序员H：嘘~小声点，公司不让谈论薪资的，你还想不想混了。我之前是跟老板提了三次涨薪，可老板一推再推，说是我以后在公司的前途无可限量，不要总是局限于眼前的这点工资
说完，程序员H望着远方，吐了一个烟圈，随着烟圈的远去，变得越来越大。
程序员H(指着烟圈)：老板给我画的饼呐，就是这个烟圈里看到的世界，大得很...对了，咱两差不多大，我看，你也尽快跳了吧！
小天：嘿嘿，有想过，但是能力不够，跳不得跳不得...
程序员H：啥跳不得啊？多看点技术书籍就差不多了
小天：唉~就是不喜欢看书，对了，大佬，你这次去面试问了些什么啊？很好奇阿里是怎么面试的，有哪些环节？
程序员H(突然振作精神)：我跟你讲啊，不得不说，这大公司到底是大公司，规范得很。我面试的时候加HR面，一共有5轮，大概回忆一下...
一面 (电话面试)
介绍自己比较熟悉的项目和项目中遇到的难点Springbean生命周期谈谈依赖注入和面向切面HashMap原理和扩容机制常用并发包下的类Redis持久化方式，为什么这么快？自己平时如何提升的，看书或者网站？ 二面
Jvm类加载机制，分别每一步做了什么工作？Jvm内存模型，垃圾回收机制，如何确定被清除的对象？了解哪些垃圾回收器和区别？多线程相关，线程池的参数列表和拒绝策略Jvm如何分析出哪个对象上锁？Mysql索引类型和区别，事务的隔离级别和事务原理Spring scope 和设计模式Sql优化 三面
fullgc的时候会导致接口的响应速度特别慢，该如何排查和解决？项目内存或者CPU占用率过高如何排查？ConcurrentHashmap原理数据库分库分表MQ相关，为什么kafka这么快，什么是零拷贝？小算法题http和https协议区别，具体原理 四面(Leader)
手画自己项目的架构图，并且针对架构和中间件提问印象最深的一本技术书籍是什么？ 五面(HR)
没什么过多的问题，主要就是聊了一下自己今后的职业规划，告知了薪资组成体系等等。
插播一条福利！！！最近整理了一套1000道面试题的文档(详细内容见文首推荐文章)，以及大厂面试真题，和最近看的几本书。
需要刷题和跳槽的朋友，这些可以免费赠送给大家，帮忙转发文章，宣传一下，后台私信【面试】免费领取！
小天：好像问了两次看书的情况诶？现在面试还问这个？
程序员H：是啊，幸亏之前为了弄懂JVM还看了两本书，不然真不知道说啥了！
小天：看来，我也要找几本书去看了，感情没看过两本书都不敢跳槽了！
程序员H：对了，还有简历，告诉你一个捷径
简历尽量写好一些，项目经验突出：
1、自己的知识广度和深度
2、自身的优势
3、项目的复杂性和难度以及指标
4、自己对于项目做的贡献或者优化
程序员H：唉~这还不能走可怎么办呀！你说，我把主管打一顿，是不是马上就可以走了？
小天：...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a737fde8aa73e4172a23f7abcea6ecde/" rel="bookmark">
			ESP32-CAM监控摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在此项目中，我们将使用ESP32-CAM开发板构建IP监控摄像头。 ESP32相机将托管一个视频流Web服务器，您可以使用网络中的任何设备对其进行访问。
您可以将此视频流Web服务器与流行的家庭自动化平台（如Home Assistant或Node-RED）集成。在本教程中，我们将向您展示如何将其与Home Assistant和Node-RED集成。
在此项目中，我们将使用ESP32-CAM开发板构建IP监控摄像头。 ESP32相机将托管一个视频流Web服务器，您可以使用网络中的任何设备对其进行访问。
您可以将此视频流Web服务器与流行的家庭自动化平台（如Home Assistant或Node-RED）集成。在本教程中，我们将向您展示如何将其与Home Assistant和Node-RED集成。
所需零件 介绍ESP32-CAM 视频流服务器 请遵循以下步骤，使用您可以在本地网络上访问的ESP32-CAM来构建视频流Web服务器。
安装ESP32插件 搜索ESP32，然后按安装按钮以获取“ Espressif Systems的ESP32”：
就这样。应该在几秒钟后安装它。
测试安装 将ESP32开发板插入计算机。打开您的Arduino IDE，执行以下步骤：
选择端口（如果您在Arduino IDE中看不到COM端口，则需要安装CP210x USB至UART Bridge VCP驱动程序）：
在文件&gt;示例&gt; WiFi（ESP32）&gt; WiFiScan下打开以下示例
一个新的sketch将在您的Arduino IDE中打开：
按下Arduino IDE中的``上传’'按钮。等待几秒钟，直到代码编译并上传到您的开发板上。
如果一切都按预期进行，您应该会看到“上传完成”。信息。
以115200的波特率打开Arduino IDE串行监视器：
视频流Web服务器代码 在上传代码之前，您需要在以下变量中插入网络凭据：
然后，确保选择正确的相机模块。在这种情况下，我们使用的是AI-THINKER模型。
现在，您可以将代码上传到ESP32-CAM开发板上。
上载代码 使用FTDI编程器将ESP32-CAM板连接到计算机。请遵循下面原理图：
要上传代码，请按照以下步骤操作：
转到Tools &gt; Board，然后选择AI-Thinker ESP32-CAM转到Tools &gt; Port，然后选择ESP32连接到的COM端口然后，点击上传按钮上传代码当您开始在调试窗口中看到这些点时，如下所示，请按ESP32-CAM板载RST按钮。 几秒钟后，该代码应成功上传到您的电路板上。
获取IP地址 上载代码后，将GPIO 0与GND断开。以115200的波特率打开串行监视器。按ESP32-CAM板上复位按钮。
ESP32 IP地址应在串行监视器中打印。
访问视频流服务器 家庭助理集成 对于大多数人来说，仅使ESP32-CAM通过IP工作可能会有用，但是您可以将此项目与Home Assistant（或其他家庭自动化平台）集成。
将ESP32-CAM添加到家庭助理 打开您的家庭助理仪表板，然后转到更多设置菜单。
将监视摄像机放在合适的位置。
然后，转到摄像机IP地址或家庭助手仪表板，实时查看发生了什么。
提示：Node-RED集成 详情参阅 - 亚图跨际
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/694985fb1bee078fefad27b72e0ceb62/" rel="bookmark">
			Ubuntu系统Root用户无法登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认 系统 root 登录 图形界面，出现 登录失败。解决方法如下：
1，登录普通用户, 打开终端执行命令, 使用su root或sudo -i切换到root用户(必须)
su root 按照提示输入密码即可切换用户。
若root账户密码忘记，使用如下命令重设后再切换。
sudo passwd root 2，在终端中输入如下命令，打开文件
gedit /etc/pam.d/gdm-autologin 将打开的文件中第三行前加#，如下注释掉语句 “auth required pam_succeed_if.so user != root quiet_success”
#%PAM-1.0 auth requisite pam_nologin.so #auth required pam_succeed_if.so user != root quiet_success auth optional pam_gdm.so auth optional pam_gnome_keyring.so auth required pam_permit.so @include common-account # SELinux needs to be the first session rule. This ensures that any # lingering context has been cleared.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/694985fb1bee078fefad27b72e0ceb62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/128b5b55630c757b9beb07cdd075a079/" rel="bookmark">
			使用Arduino控制TB6600步进电机驱动器教程（更新于 2022.03.19）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arduino步进电机4种演示 了解如何使用 ULN2003、L298N 和 A4988 等驱动程序通过 Arduino 控制双极和单极步进电机。
概述 简述:步进电机工作原理和特点：示意图显示和文字描述。微步工作方式：示意图显示和文字描述。步进电机类型介绍：双极步进电机（示意图和文字描述），单极步进电机（示意图和文字描述）。阅读步进电机规格。NEMA 电机尺寸介绍。试验步进电机描述。
演示 简述：演示 1 – 具有 ULN2003 的 28BYJ-48 单极步进器：文字描述、接线图和Arduino代码控制。演示 2 – 两个具有 ULN2003 的 28BYJ-48 单极步进器：文字描述、接线图和Arduino代码控制。演示 3 – 具有 L298N H 桥的双极步进器：文字描述、接线图和Arduino代码控制。演示 4 – 具有 A4988 的双极步进器：文字描述、接线图和Arduino代码控制。
TB6600步进电机驱动 在本教程中，您将学习如何使用TB6600微步进驱动器和Arduino控制步进电机。该驱动器易于使用，可以控制大型步进电机，例如3 A NEMA 23。
我提供了接线图和3个示例代码。 在第一个示例中，我将向您展示如何在没有Arduino库的情况下使用此步进电机驱动器。 该示例可用于使电动机连续旋转。 在第二个示例中，我们将研究如何控制步进电机的速度，转数和旋转方向。 最后，我们将看一下加速库。 该库非常易于使用，并允许您在步进电机的运动中添加加速和减速。
在每个示例之后，我都会分解并解释代码的工作原理，因此您可以毫无问题地修改代码以适合您的需求。
软硬件和工具 简述：所需软硬件材料
驱动器 简述：TB6600驱动器特性。
TB6600连接到步进电机和Arduino 简述：将TB6600步进电机驱动器连接到Arduino和步进电机及其注意事项。
TB6600微步设置 简述：TB6600微步调节方式和及其电流设置
使用Arduino的TB6000的示例代码 简述：使用以下sketch，您可以测试步进电机驱动器的功能。
代码分解 简述：Arduino 控制 TB6600的代码结构
控制旋转，速度和方向的示例代码 简述：该sketch控制步进电机的速度，转数和旋转方向。
代码分解 简述：旋转和速度及方向的代码结构
源代码 详情参阅 - 亚图跨际
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c032ed72b5312f7d12fe09fe541c25a3/" rel="bookmark">
			Unity Tag标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物体设置tag标签，也可以理解为标记物体，用以区分物体，例如场景中的默认相机的标签默认为MainCamera，在脚本中我们可以通过Camera.main来获取场景中标签为MainCamera的相机。
除了默认的标签外，可以通过Add Tag添加自定义标签：
我们自定义了一个标签Test，新建一个物体将其标签设为Test：
在脚本中通过标签查找该物体需要用到GameObject类中的FindGameObjectWithTag函数：
private void Start() { GameObject target = GameObject.FindGameObjectWithTag("Test"); } 查找后target即为该物体。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6de6d9ed61131c378e9aa334775f8d8/" rel="bookmark">
			Python多线程ping(ping3模块)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python多线程ping(ping3模块) 代码from ping3 import ping from concurrent.futures import ThreadPoolExecutor ######################################## 自定义函数_批量Ping ######################################## def pings(ips): # ips为可迭代对象,每个元素为一个IP地址或域名 # 返回值为一个字典,key保存ip,value保存是否能ping通 ips_status = dict() # 多线程执行ping函数 with ThreadPoolExecutor(max_workers=500) as pool: results = pool.map(ping,ips) for index,result in enumerate(results): ip = ips[index] if type(result) == float: ips_status[ip] = True else: ips_status[ip] = False return ips_status ips = ["192.168.85.1","192.168.85.200","192.168.85.10","192.168.85.16","192.168.85.254","192.168.85.19"] ips_status = pings(ips) print(ips_status) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abdcda798d859c8d0cb578d4e942e7b6/" rel="bookmark">
			Deepin20.5没有wifi图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备信息：
查了一堆攻略，包括自己安装驱动都不行。在我的观察里官方是带了几个驱动的，在复制Realtek的驱动的时候就能看到liscence。
最终在这里找到了答案
不需要格外再安装驱动，直接管理员权限删除fireware下面.pnvm的文件即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e2b043570fc2fa8b12ffbade75dfc7/" rel="bookmark">
			第三方应用调用系统SO 库失败Caused by: java.lang.UnsatisfiedLinkError: dlopen failed: library
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android 31平台，尝试使用第三方应用调用系统SO 库，会报如下的错误
Caused by: java.lang.UnsatisfiedLinkError: dlopen failed: library "/system/lib64/XXX.so" needed or dlopened by "/apex/com.android.art/lib64/libnativeloader.so" is not accessible for the namespace "classloader-namespace"
大体原因是，Android N 开始限制 第三方 应用使用非公开的 系统库
临时解决debug 方法：
将你要用的到 XXX.so 加入到 /system/etc/public.libraries.txt
1. adb remount
2： adb pull /system/etc/public.libraries.txt [你要保存的目录]
3：将你要用的到 XXX.so 加入到 /system/etc/public.libraries.txt
4. adb push [public.libraries.txt 所在的路径] /system/etc/
5. adb reboot
参考：
Android 7.0调用第三方库出现加载失败的问题 - 极客分享
第三方app加载系统/system/lib下的库--is not accessible for the namespace - 代码先锋网https://www.codeleading.com/article/67782154448/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72b365b7d24a294a8cbd13fb2d74959/" rel="bookmark">
			完全解读Prometheus查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 引言02 概念2.1 表达式类型（Expression language data types）2.2 字面量（Literals）2.2.1 String 字面量（String literals）2.2.2 Float 字面量（Float literals） 2.3 时间序列选择器（Time series Selectors）2.3.1 瞬时向量选择器（Instant vector selectors）2.3.2 范量向量选择器（Range Vector Selectors）2.3.3 持续时间（Time Durations）2.3.4 Offset修饰符（Offset modifier）2.3.5 @ modifier 2.4 子查询（Subquery）2.5 操作符（Operators）2.5.1 二元作符（Binary operators）2.5.1.1 算术二元操作符（Arithmetic binary operators）2.5.1.2 三角二元操作符符（Trigonometric binary operators）2.5.1.3 比较二元操作符（Comparison binary operators）2.5.1.4 逻辑二元操作符（Logical/set binary operators） 2.5.2 向量匹配（Vector matching）2.5.2.1 一对一向量匹配（One-to-one vector matches）2.5.2.2 多对一和一对多向量匹配（Many-to-one and one-to-many vector matches） 2.5.3 聚合运算符（Aggregation operators）2.5.4 二元操作符优先级（Binary operator precedence） 2.6 函数（Functions）2.7 注释（Comments）2.8 陷阱（Gotchas）2.8.1 过时（Staleness）2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b72b365b7d24a294a8cbd13fb2d74959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838eb85f4264c8f03365abc711231f4c/" rel="bookmark">
			Python Pandas 中的数据结构（超详细，你确定不学习一下？）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas有三种数据结构：Series、DataFrame和Panel。Series类似于数组；DataFrame类似于表格；Panel可视为Excel的多表单Sheet
目录
1.Series
1.1通过列表创建Series
1.2通过字典创建Series
2.DataFrame
3.索引对象 4.查看DataFrame的常用属性
1.Series Series是一种一维数组对象，包含一个值序列，并且包含数据标签，称为索引(index)，通过索引来访问数组中的数据。
1.1通过列表创建Series 例1.通过列表创建
import pandas as pd obj = pd.Series([1,-2,3,4]) #仅由一个数组构成 print(obj) out: 0 1 1 -2 2 3 3 4 dtype: int64 输出的第一列为index，第二列为数据value。如果创建Series时没有指定index，Pandas会采用整型数据作为该Series的index。也可以使用Python里的索引index和切片slice技术
例2.创建Series时指定索引
import pandas as pd i = ["a","c","d","a"] v = [2,4,5,7] t = pd.Series(v,index=i,name="col") print(t) out: a 2 c 4 d 5 a 7 Name: col, dtype: int64 尽管创建Series指定了index，实际上Pandas还是有隐藏的index位置信息。所以Series有两套描述某条数据手段：位置和标签 例3.Series位置和标签的使用
import pandas as pd val = [2,4,5,6] idx1 = range(10,14) idx2 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/838eb85f4264c8f03365abc711231f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea238fd9fff4840221898cad0867f5b6/" rel="bookmark">
			MATLAB----输入和输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1. 输入语句1.1 输入数值或矩阵1.2 输入字符串 2. 输出语句2.1. 输出单个字段2.2. 输出多个字段 1. 输入语句 1.1 输入数值或矩阵 value1 = input("请输入一个数值：") value2 = input("请输入一个矩阵：") 1.2 输入字符串 输入字符串，需要加第二个参数 ‘s’
string = input("请输入一个字符串: ", 's') 2. 输出语句 使用 disp(）函数可以输出，输出多个字段时，需要将多个字段转化成字符串矩阵，再进行输出。
2.1. 输出单个字段 disp(value2) disp(value1) disp(string) 2.2. 输出多个字段 % 输出多个字段时，需要将多个字段转化成字符串矩阵 disp( ["hello", "world"] ) disp( ["hello", 2] ) disp( ["1/3", 1/3] ) disp( ["1/3", num2str(1/3, 2)] ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e5ac509f0f92be6417ad052a1cec9b/" rel="bookmark">
			2022年4月28日 复盘&amp;计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 昨天下班之后，owner给我打电话说我所负责的模块，上了环境之后，既报400又报500，没法用~让我明天早点看，10点之前完成bug修复，否则算任务完不成，回退版本~~~吓得我很慌，一晚上睡不着”
今天2022年4月28日的总结
工作方面 昨晚睡不着，今天6点多就起床点着煤油灯上班，7点多到公司，把昨晚owner给我说的问题排查一遍，然而，最后的结论是我的后端功能没有问题，问题出现在测试和前端。
（1）测试的不会使用，该测试对需求理解有偏差，角色权限不够。
（2）前端传给后端的参数有问题，导致后端提示400.
总结：我能说测试只会用鼠标点点点浏览器，连用F12看请求参数都不会吗，我也能说前端也不会看参数吗？和其他项目组成员交流一下技术心得，准备看一下他们的docker和shardingJDBC如何实战，毕竟自己也从来没有用过。另外，希望也能看到有使用Spring Cloud Alibaba的~~~~吃晚饭的时候，owner又给我打电话说我的功能不对，在埋怨我，又喊我X哥，颇具讽刺意味。打个比方，该功能，我最初做的是版本A，然后测试人员测试的时候说功能不对，得改，改完后的版本叫版本B，接着，owner验收的时候，又说是我不对，版本B是不对，应该改为版本C，然而，最终的版本C就是和我最初的版本A是一样的功能！晚上我所在的外包公司的PM找谈话，让我开窍点，别一直背锅，嘴拙要吃亏。想想了，又是替测试和前端背锅，又被HW的owner骂，确实是人笨嘴拙。总结，人在社会走，不能欺负人，也不能被人欺负，做人做事有技巧。 周计划进度 查看线上环境的nginx配置。100%完成kafka结合Spring Boot的遗留问题。0%了解redis地理坐标&amp;bitmap。0% 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6108ca1816366aeedda2c43737b79bc0/" rel="bookmark">
			MATLAB简介与矩阵定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB简介与矩阵定义 MATLAB简介MATLAB简介MATLAB界面(以2016a为例)注释续行符每行结束符号常用函数 矩阵运算赋值运算符等号运算符定义空矩阵定义一个m*n的矩阵使用 冒号运算符 生成矩阵使用冒号运算符生成矩阵语法 使用```linspace()```生成矩阵矩阵的拼凑和变形矩阵的拼接矩阵的变形 特殊矩阵和随机矩阵特殊矩阵单位矩阵全0矩阵全1矩阵三维矩阵 随机数矩阵```rand()``````randi()``````randn()``` 在MATLAB中搜索相关函数用法 MATLAB简介 MATLAB简介 MATLAB是 matrix &amp; laboratory 两个词的组合，意为矩阵工厂（矩阵实验室）。它将数值分析、矩阵计算、科学数据可视化以及非线性动态系统的建模和仿真等诸多强大功能集成在一个易于使用的视窗环境中。
MATLAB界面(以2016a为例) 实时编辑器字体的放大缩小：ctrl + 鼠标的滚轮。
实时脚本编辑器中代码和文本切换的快捷键：alt + enter。
插入分解符，可以使代码分块运行。
注释 注释符号：%
续行符 续行符符号：...
每行结束符号 每行结束符号：;
常用函数 abs( 参数 )
求绝对值或复数的模
sqrt( 参数 )
开平方
mod( x, y )
取余
求 x 对 y 的余数
exp( 参数 )
指数函数，参数为次方
log( 参数 )
求以 e 为底的对数
log2( 参数 )
求以 2 为底的对数
log10( 参数 )
求以 10 为底的对数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6108ca1816366aeedda2c43737b79bc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81cda7da5e42a061e2c77843bb4c7c6/" rel="bookmark">
			java7新特性MethodHandle学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * @description: * @author: Candy * @date: 2022-04-28 22:43 **/ public class TestStudent { //测试普通方法 public void test(String str){ System.out.println(str); } //测试静态方法 public static void testStatic(String str){ System.out.println(str); } //测试私有静态方法 private static void testPrivate(String str){ System.out.println(str); } //测试私有方法 private String testReturn(){ System.out.println("赵六"); return ""; } public static void main(String[] args) throws Throwable { //相当于创建了MethodHandle工厂类 MethodHandles.Lookup lookup = MethodHandles.lookup(); MethodHandle mt = lookup.findVirtual(TestStudent.class, "test", MethodType.methodType(void.class, String.class)); //第一个参数为返回值类型,第二个参数为参数类型 mt.invoke(new TestStudent(),"张三"); MethodHandle m = lookup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e81cda7da5e42a061e2c77843bb4c7c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac9c6245cf89f0582780e8d960fa3ce/" rel="bookmark">
			用递归方法编程计算Fibonacci数列的前N项。当n=1或2时，fib(n)=1当n＞2时，fib(n)=fib(n-1)&#43;fib(n-2)。**输入格式要求：“%d“ 提示信息：“Input
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int fib(int n);
int main()
{
int n;
int x=1;
printf("Input n:\n");
scanf("%d",&amp;n);
for(x=1;x&lt;=n;x++)
{
printf("Fib(%d)=%d\n",x,fib(x));
}
}
int fib(int n)
{
if(n==1||n==2)
{
return 1;
}else
{
return fib(n-1)+fib(n-2);
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1adf1371dfa82a7823bbb136d9f5dd/" rel="bookmark">
			优麒麟搜狗输入法简繁切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 ubuntu 上没有找到顺手的输入法，支持的 linux 的输入法或多或少都会有点小毛病，偶然看到优麒麟优化过的输入法想尝试使用一下
但是刚使用就发现一个问题，简繁切换快捷键和 PyCharm 的全局搜索快捷键存在冲突，导致在 PyCharm 中无法全局搜索，网上搜索出来的解决方案基本分为两种.
改变 PyCharm 全局搜索快捷键关闭搜狗输入法的简繁切换 果断选择第二种
但是…
网上的解决方案都是针对官方的搜狗输入法的，例如下面几个链接
https://juejin.cn/post/6961396419852763143https://blog.csdn.net/RedLeaves2018/article/details/120759915 优麒麟的搜狗输入法是没有这个文件夹的
安装完优麒麟后，在 .config 目录下出现了两个目录
故在这两个文件夹下搜索 env.ini （别问我为什么，问就是官方配置文件叫这个名字，我猜优麒麟没有改）
然后真让我找到了
打开 env.ini 文件，搜索 FanJian （别问我为什么，因为官方有这个关键字）
发现设置的是 KeyFanJianSwitch=5
然后把他改为 KeyFanJianSwitch=0
保存文件，重启 fcitx
测试简繁切换快捷键已经无效
个人环境 ubuntu 20
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e025d8c1288e4ec9661e6dd390292d9c/" rel="bookmark">
			unity保存相机当前帧的图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 创建一个相机，把depth.cs和RenderTexture.cs挂在相机上 2 depth.cs代码 using System.Collections; using System.Collections.Generic; using System.IO; using UnityEngine; public class Depth : MonoBehaviour { // Start is called before the first frame update private Camera m_Camera; public RenderTexture depthTexture, source; public Material Mat; private int width = CameraTexture.width; private int height = CameraTexture.height; private static int index =0; void Start() { m_Camera = gameObject.GetComponent&lt;Camera&gt;(); // 手动设置相机，让它提供场景的深度信息 // 这样我们就可以在shader中访问_CameraDepthTexture来获取保存的场景的深度信息 // float depth = UNITY_SAMPLE_DEPTH(tex2D(_CameraDepthTexture, uv)); 获取某个像素的深度值 m_Camera.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e025d8c1288e4ec9661e6dd390292d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb2c0560bfafcc712c94d825178a941/" rel="bookmark">
			Vue拓展_深入浅出Vuex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、VueX概述1.Vuex的优点2.适合存储到Vuex的数据 二、Vuex核心概念1.State1.1 创建state1.2 State的使用 2.Getter2.1 创建Getter2.2 注册及使用Getter 3.Mutation3.1 创建Mutation3.2 Mutation的使用 4.Action4.1 创建Action4.2 注册及使用Action 三、使用步骤1.安装vuex42.注册及使用 前言 组件之间共享数据由许多种方式
父传子：v-bind属性绑定
子传父：v-on事件绑定
双向绑定：v-model事件绑定
兄弟组件之间共享数据：EventBus
vue2：
$on 接收数据的组件$emit发送数据的组件 子组件从父组件获取的值是只读的，不能直接修改
一、VueX概述 描述：实现组件全局状态管理的一种机制（方案），可以方便组件之间的数据共享
左图表示不使用Vuex实现数据共享
右图为使用Vuex实现数据共享
由上图可知：
若不使用Vuex的话要实现不想关的两个组件数据传递是非常繁琐的在未使用Vuex实现数据共享的时候，需要许多层组件进行数据传递，这就会影响到许多的组件，造成空间浪费若使用了Vuex想要获取某个组件的数据的话，可以让那个组件直接传值给store，然后再从store从获取值 1.Vuex的优点 能够再vuex中集中管理共享的数据，易于开发和后期维护能够高效的实现组件之间的数据共享，提高开发效率存储再Vuex中的数据都是响应式的，能实时保持数据和页面的同步 2.适合存储到Vuex的数据 对于组件之间共享的数据，才有必要存储到vuex中对于组件当中的私有数据，依旧再组件自身的data中即可 二、Vuex核心概念 主要核心概念有：State，Getter，Mutation，Action
1.State 描述：state提供唯一的公共数据源，所有的共享数据都要统一放到Store的State中进行存储
1.1 创建state import {createStore} from 'vuex'// new store export default createStore({ state:{ // 存储数据 数据是响应式的 age:23, }, }) 1.2 State的使用 &lt;template&gt; &lt;view&gt;This index&lt;/view&gt; &lt;view&gt;{{age}}&lt;/view&gt; &lt;/template&gt; &lt;script setup&gt; import {useStore} from 'vuex' const store = useStore() const age = store.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb2c0560bfafcc712c94d825178a941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab09c381c66cb3448ef9a8da7c85b285/" rel="bookmark">
			ESP32快速实现3.2英寸TFT LCD中jpeg图像（ILI9341）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此视频中，将向您展示了如何在ESP32中使用3.2英寸SPI TFT LCD。为了显示jpeg，您需要一个ESP32，Adafruit库，SPIFF和jpeg解码器。
要获得高速SPI，您需要使用正确的IO引脚。
注意：本篇只有视频版，全部操作过程在视频中均已展示，可以按步操作。
硬件 WEMOS LOLIN32 Lite3.2英寸320 * 240 SPI串行TFT LCD模块显示屏，带触摸屏驱动器IC ILI9341，用于MCU 软件 ESP32安装Adafruit ILI9341 DriverArduino esp32fs插件Arduino JPEG解码器库JPEG渲染功能动画gif生成 源代码 详情参阅 - 亚图跨际
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38aa37b5893b24640a1ffb2023aeb1be/" rel="bookmark">
			消息队列比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常见的消息队列对比 指标对比概述吞吐量万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级可用性都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用时效性RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级功能支持除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准消息丢失ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失 总结： ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc3382bf9197a5a2ecb34712a22da8f/" rel="bookmark">
			Linux安全常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、查看系统信息常用命令二、系统关机、重启等常用命令三、目录操作常用命令四、目录查看 ls [-al]五、目录操作[增、删、改、查]六、文件操作常用命令[增，删，改，查]七、压缩文件常用命令八、查找常用命令九、su、sudo十、系统服务常用命令十一、主机管理常用命令十二、定时任务指令crontab其他Linux常用命令 前言 以下内容是本人在学习过程中整理下来的一些知识点，路过的各位大佬仅供参考！
在Linux中常见的基础命令如下：
1、cd 命令、用于切换目录；
2、ls 命令、用于显示指定工作目录下的内容；
3、pwd 命令、用于显示工作目录所在的位置；
4、mkdir 命令、用于创建目录；
5、cp 命令、用于复制文件或目录等；
cd
change directory，切换目录
相对路径：参照当前所在目录进行查找 ；
绝对路径：从根目录开始指定，一级一级递归查找，在任何目录下，都能进入指定位置；
ls
用于显示指定工作目录下之内容(不加参数则列出当前目录下的内容)
使用选项：ls [选项] [文件或目录]
pwd
显示工作目录所在位置(显示绝对路径)
mkdir
创建目录，-p 递归创建，用于创建多级目录
语法：mkdir -p [目录名]
cp
copy，复制文件或目录
语法：cp [选项] [原文件或目录] [目标目录]
mv
move，剪切或改名，如果原文件和目标目录在同一目录下，则为改名，否则为剪切
语法：mv [原文件或目录] [目标目录]
rm
remove，删除文件或目录
语法：rm -rf [文件或目录]
选项：-r 删除目录；-f 强制执行
这个命令需多加慎重
rmdir
remove empty directories，删除空目录(很少用)
语法：rmdir [目录]
一、查看系统信息常用命令 Arch、uname -m 显示机器的处理器架构 Uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2022 显示2022年的日历表 date 061217002022.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cc3382bf9197a5a2ecb34712a22da8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e9a38c8dc7a0d17b66dc5342eea9fe/" rel="bookmark">
			构造器的重载与重写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重写：
定义：方法重写就是子类的一个方法和父类的某个方法的名称，形信列表，返回类型一样，那么就构成了重写。
要求：子类访问修饰符不能缩小父类访问修饰符的访问权限，返回类型本类或其子类，public&gt;protect &gt;默认的（也就是什么都不写）&gt;private。
重载：
定义：方法重载就是某个类的多个方法有相同的名称，不同形参列表，那么就构成了方法重载，重载只能在本类进行。
好处：避免给方法重复起名
要求：形信列表必需不同（类型，个数，顺序有一个不一样就满足要求），返回类型无要求。
比较：
重载 ：
发生范围：本类
方法名：一样
形信列表：必需不同（类型，个数，顺序有一个不一样就满足要求），
返回类型：无要求
修饰符：无要求
重写 ：
发生范围：父子类
方法名：一样
形参列表：必需相同
返回类型：和父类或其子类一致
修饰符：不能缩小父类父类方法的访问范围
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/156/">«</a>
	<span class="pagination__item pagination__item--current">157/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/158/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>