<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8845779a8564346813a2632b0d1ffac3/" rel="bookmark">
			【vue部署】本地正常，部署后报404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vu2本地运行正常，生成部署后报404 这是env.production 配置
//env.production # 页面标题 VUE_APP_TITLE = 管理系统-生产环境 # 生产环境配置 ENV = 'production' # 管理系统/生产环境 VUE_APP_BASE_API = '/api' # 路由懒加载 VUE_CLI_BABEL_TRANSPILE_MODULES = true 这是env.development 配置
//env.development # 页面标题 VUE_APP_TITLE = 管理系统-开发环境 # 开发环境配置 ENV = 'development' # 开发代理。!!!!! 在该文件的同级目录下新建`.env.development.local`文件配置。 VUE_APP_PROXY_URL=http://192.168.193.210:8088/fee # 管理系统/开发环境 VUE_APP_BASE_API = '/api' # 路由懒加载 VUE_CLI_BABEL_TRANSPILE_MODULES = true 以下是我的vue.config 代理配置
//vue.config proxy: { [process.env.VUE_APP_BASE_API]: { target: process.env.VUE_APP_PROXY_URL, changeOrigin: true, pathRewrite: { ['^'+process.env.VUE_APP_BASE_API]: '' } } ##问题 ：以上配置，在本地是没问题的，但是上线后，请求接口就报404
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8845779a8564346813a2632b0d1ffac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc017677a88ab0faeb0470d4cd8709c/" rel="bookmark">
			西安交通大学XJTU计算机专硕912专业课复习经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说下本人情况，本科成绩普通，没有学过计组，本科阶段数据结构学的一般。经过考研复习，最终专业课120+，在专业课复习方面还算比较有心得、方法。接下来我将分享一下我复习专业课的一些思路和经验，仅供参考。
交大计专专业课（912）的科目少言寡语数据结构和计算机组成原理。数据结构参考书：《数据结构与算法》（第一版）赵仲孟、张选平等编著，北京高等教育出版社，2016年11月。计算机组成原理参考书：《计算机组成与设计》（第一版）王换招、陈妍、赵青苹编著，北京清华大学出版社，2013年8月
数据结构：参考资料用了《王道2023数据结构》、西交参考书、数据结构1800题、数据结构习题集（非常重要）。总体来讲，西交912数据结构并不难，跟着王道不会出错，但是想拿高分需要认真运用上面我提到的资料。
六月份开始听王道的课并且做王道的课后习题，记笔记，期间配合数据结构1800题练习，因为还有学校的课程、考试，所以进度很慢，断断续续。数据结构一轮复习在七月底才结束。二轮复习是看西交指定参考书（重要），并做参考书后的课后题订正答案，继续做数据结构1800题练习，这个时候开始梳理归纳，大概九月中旬结束。三轮复习以数据结构习题集为重，认真做习题，将核心代码进行总结，对解题方法进行归类，梳理思路，三轮复习结束后就开始做真题，期间时不时对过去总结的知识进行复盘回看，一直持续到考试前。王道的课后题做了两遍，参考书的课后题做了三遍。
计算机组成原理：参考资料用了王换招老师的书、西交本科PPT、课本答案PPT讲解版。总体来说西交912计组不算特别难，主要是参考书很厚内容多，必须把握住复习重点，如果以王道的复习为主，可能专业课上不了100分。下面我分享下我是怎么复习计组的。
六月份开始看参考书，第一次拿到时真的感觉很厚，因为本科没学过这门课所以心里也有点犯怵。刚开始看有点像看天书，看到后面就好了，因为你会发现这本书后面会解答前面提出的一些问题，编写的还不错。我是一章一章看的，课本有看不懂的内容就去搜了哈工大计组的公共课，再去看书，这样会帮助理解知识，看完一章后尝试去做课后题，第一遍会发现没几道题会做（我很菜），但是会尽力去理解答案，最终在八月底吧，才将第一轮过完（其实我个人觉得这个进度刚好），期间会结合西交本科PPT，并且我做了完整的手写笔记（这个依照每人学习习惯、方法来就行）。
第二轮九月多开始，又看一遍书，这个时候看书会更快了，对于之前不理解的知识会有更多理解！继续做课后题，由于西交机组所能用到的资料很少，所以一定要珍惜每道课后题！这个时候梳理每章的结构，我画了思维导图帮助梳理，因为知识点太多了。最终课本我看了不下三遍，课后题做了很多遍（分享一个小tips:我把计组所有课后题整理了，打印成一本册子，后期每天都在刷那本册子），十一月开始做真题，同时开始背诵整理的简答题（计组每年都会考简答题，且占比不小，务必要重视）。
以上是我的专业课复习过程，可能有些地方没写全，欢迎大家咨询留言，我看到基本都会回复，因为自己淋过雨，所以想帮别人撑伞。关于上面提到的资料，可以私信我，回消息很快。祝福24考研的学弟学妹们心想事成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7648313bda174c5e7a0f925afbd0403/" rel="bookmark">
			Win10&#43;TensorRT 8.5安装&#43;VS2022配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 Anaconda3 [python 3.8]Visual Studio 2022CUDA 11.8cuDNN 8.6.0TensorRT 8.5.2.2 TensorRT 下载并 配置 下载 TensorRT 8.x # 如下载8.5.2.2版本 TensorRT-8.5.2.2.Windows10.x86_64.cuda-11.8.cudnn8.6.zip 加压后，添加环境变量PATH中(根据自己路径) # 将lib路径添加到环境变量 D:\AI_SoftEnv\TensorRT\TensorRT-8.5.2.2\lib 将TensorRT-8.5.2.2\lib下的lib文件和dll文件分别拷贝到CUDA的lib/x64路径和bin路径下 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.8\bin C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.8\lib\x64 安装pytho版本tensorrt # 到TensorRT-8.5.2.2\python下，根据自己的python版本安装tensorrt pip install tensorrt-8.5.2.2-cp38-none-win_amd64.whl # 测试 import tensorrt as trt trt.__version__ VS2022配置TensorRT并测试 使用VS2022打开TensorRT-8.5.2.2\samples\sampleOnnxMNIST\sample_onnx_mnist.sln
进行如下环境配置
注：对于VS2022，其已经默认添加了这几个库（前4个是tensorrt的，后3个是cuda的）。为了说明，还是按照上面方式配置即可。
nvinfer.lib
nvinfer_plugin.lib
nvonnxparser.lib
nvparsers.lib
cudnn.lib
cublas.lib
cudart.lib
到此为止，TensorRT在VS中就配置好了（实际上面也展示了CUDA的配置），下面就可以直接测试案例程序了。
为了防止后面执行exe操作闪退，添加getchar();到main函数下
之后编译build即可。
编译成功后，会在 TensorRT-8.5.2.2\bin 路径下生成可执行文件sample_onnx_mnist.exe
双击运行即可
以上就是TensorRT安装和VS配置以及官方Demo运行过程，到此就说明一切都OK了。
备注 以上过程可能存在找不到zlibwapi.dll的问题，解决办法：
官网下载 ZLIB DLL 库，解压后将zlibwapi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7648313bda174c5e7a0f925afbd0403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac18f6f2bb3b73268f33a49105916f57/" rel="bookmark">
			GitHub Action 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub Action 使用 GitHub Actions 是一种持续集成和持续交付 (CI/CD) 平台，可用于自动执行生成、测试和部署管道。 您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。GitHub 提供 Linux、Windows 和 macOS 虚拟机来运行工作流程，或者您可以在自己的数据中心或云基础架构中托管自己的自托管运行器。
计费规则 公共存储库中标准 GitHub 托管的运行器和自托管运行器可免费使用 GitHub Actions。 对于专用存储库，每个 GitHub 帐户可获得一定数量的免费时间和存储以用于 GitHub 托管的运行器，具体取决于帐户所使用的产品。 超出包含数量的任何使用量都由支出限制控制。分钟数每月重置一次，而存储空间使用量不会重置。ci机器使用超过 2 核的 Windows 和 Ubuntu 运行器，将始终收取费用，包括在公共存储库中。其中GitHub Free 给的存储是 500M,2000分钟/月。在 GitHub 主机的 Windows 和 macOS 运行器上运行的作业，其消耗分钟数是在 Linux 运行器上运行的作业的 2 倍和 10 倍。 例如，1000 分钟的 Windows 使用时间将占用帐户中包含的 2000 分钟。 1000 分钟的 macOS 使用时间将占用帐户中包含的 10000 分钟。仓库使用的存储空间是 GitHub Actions 构件和 GitHub Packages 使用的存储空间总计。
查看 GitHub Actions 使用情况 操作路径：在GitHub右上角点击头像 -&gt; Settings -&gt; 左侧变栏目(Billing and Plans) -&gt; Plans and usage -&gt; Usage this month
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac18f6f2bb3b73268f33a49105916f57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fc0d0c6e596818fc3d6fa5196f8c00/" rel="bookmark">
			ctfshow愚人杯web复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		easy_signin 题目url
base64解码是face.png，尝试flag.txt和flag.php，base64加密后传入都不对，用index.php加密后传入，看源码
将后面的base64解密得到flag
被遗忘的反序列化 源码
&lt;?php # 当前目录中有一个txt文件哦 error_reporting(0); show_source(__FILE__); include("check.php"); class EeE{ public $text; public $eeee; public function __wakeup(){ if ($this-&gt;text == "aaaa"){ echo lcfirst($this-&gt;text); } } public function __get($kk){ echo "$kk,eeeeeeeeeeeee"; } public function __clone(){ $a = new cycycycy; $a -&gt; aaa(); } } class cycycycy{ public $a; private $b; public function aaa(){ $get = $_GET['get']; $get = cipher($get); if($get === "p8vfuv8g8v8py"){ eval($_POST["eval"]); } } public function __invoke(){ $a_a = $this -&gt; a; echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1fc0d0c6e596818fc3d6fa5196f8c00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc22883227a8eac917e6e0a91259fe22/" rel="bookmark">
			mysql8增加远程用户访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依次执行以下三条语句即可
创建远程访问用户：（username为远程登录的用户名，password为对应的密码，“%”为允许所有ip及ip的占位符）
CREATE USER 'username'@'%' IDENTIFIED BY 'password';
进行远程访问权限授权
GRANT ALL PRIVILEGES ON *.* TO 'username'@'%' WITH GRANT OPTION; 刷新权限
FLUSH PRIVILEGES;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc67eb727f9c77f45be4f572f83220e/" rel="bookmark">
			前端有哪些常用的富文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 富文本编辑器（Rich Text Editor，RTE）是一种可内嵌于浏览器，所见即所得的文本编辑器。它提供类似于Office Word 的编辑功能，方便那些不太懂HTML用户使用，富文本编辑器的应用非常广泛，它的历史与图文网页诞生的历史几乎一样长。
作为一个技术人员，手上备上两款富文本编辑器还是很有用的，指不定那个项目就要集成一个进去。到时候现找现用那可就费功夫了，毕竟从开发上讲，每个富文本编辑器的用法都是有区别的。
下面是我收集的一些业界比较受欢迎的富文本编辑器，喜欢的朋友、用过的朋友可以一起看看，一起探讨。
正文 1、TinyMCE
TinyMCE是一个开源的所见即所得的HTML编辑器，界面相当清新，界面模拟本地软件的风格，顶部有菜单栏。支持图片在线处理，插件多，功能非常强大，易于集成，并且拥有可定制的主题。支持目前流行的各种浏览器，它可以达到微软Word类似的编辑体验。
而且这么好的东西还是开源免费的，目前一直有人维护，这款编辑器使用的人非常多。
更多介绍及下载：/link?link=https://www.tiny.cloud/docs/demo/full-featured/
2、CKEditor
Ckeditor也是一款非常经典的富文本编辑器，官方下载量过千万。它是在非常著名的FCkEditor基础上开发的新版本，FckEditor的用户现在基本都转移到Ckeditor了。
Ckeditor有高性能的实时预览，它特有行内编辑功能，使得编辑内容更加直观，仿佛是在编辑网页一样，有很强的可扩展性，被各大网站广泛运用。
更多介绍及下载：/link?link=https://ckeditor.com/
3、UEditor
UEditor 是由百度出品的富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源免费。这款编辑器用过的人也非常多，功能非常全面，插件很多，还可以很方便插入百度地图，接入十分简单。
16年之后百度没有怎么更新了，不过现有的功能也足够用了。UEditor分为UE版（全功能版）和UM版（精简版），大家可以根据自己使用环境选择不同的版本。
更多介绍及下载：/link?link=http://ueditor.baidu.com/website/
4、wangEditor
wangEditor轻量级，小巧实用，配置方便，使用简单。可以自定义皮肤功能，免费开源。用户数量也很多，尤其是用在一些轻型环境，比如论坛社区回帖。wangEditor是国人出品的开源项目。
更多介绍及下载：/link?link=http://www.wangeditor.com/
5、kindeditor
KindEditor历史也很长了，用户数也不少，国内某公司出品。免费开源。界面类似于office word，界面和功能中规中矩，文档齐全，使用还算方便。
更多介绍及下载：/link?link=http://kindeditor.net/demo.php
6、simditor
simditor是Tower平台使用的富文本编辑器，是一款轻量化的编辑器，界面简约，功能实用，插件不是很多，功能要求不高的可以使用。
虽然是国内出品，但文档是英文的。开源免费。
更多介绍及下载：/link?link=https://simditor.tower.im/
7、bootstrap-wysiwyg
bootstrap-wysiwyg是基于Bootstrap的轻型、免费开源的富文本编辑器，界面简洁大方。使用需要先引入bootstrap。
个人觉得bootstrap-wysiwyg这一长串像乱码一样的名字影响了它的推广和使用~ ~毕竟轻型使用环境还是很多的。
更多介绍及下载：/link?link=http://mindmup.github.io/bootstrap-wysiwyg/
8、summernote
summernote是一款轻量级的富文本编辑器，比较容易上手，使用体验流畅，支持各种主流浏览器。summernote开源免费，该项目一直比较活跃，一直都有人在维护。
summernote同样依赖于jquery和bootstrap，使用前先引入这两项。
更多介绍及下载：/link?link=https://summernote.org/
9、Froala
Froala是一款功能丰富的富文本编辑器，界面分类清晰，容易集成，容易升级，支持主流浏览器，具有行内编辑功能。Froala代码示例很多，可以集成在很多js框架里如React.js，Aurelia，Angular，Ionic，Django等。插件很多，易于扩充功能。
Froala是收费的，不过前端是开源的，如果要使用后台是要交费的（如果你使用国人强大的crack技能那就是另外一回事了~ ~）。目前有三个定价方式：基础版（239美元）、专业版（1199美元）和企业版（1999美元）。
更多介绍及下载：/link?link=https://www.froala.com/wysiwyg-editor
10、Quill
Quill是轻型的编辑器，样式一般（黑白风），功能中等，它的代码高亮功能比较强，同样支持行内编辑模式，工具条可自定义。
开源免费，项目活跃，一直有人维护。
更多介绍及下载：/link?link=https://quilljs.com/
11、FreeTextBox
FreeTextBox功能强大，前端支持主流浏览器，但后台只支持.NET。它的外观和使用风格都和微软 Word很类似。工具条可以定制，运行速度一般。FreeTextBox分为免费版和pro收费版，一般情况免费版本功能已经足够用了。
更多介绍及下载：/link?link=http://freetextbox.com/
12、dhtmlxEditor
DHTMLX组件是一整套基于JS的UI库，功能强大，其中包含编辑器dhtmlxEditor。该编辑器可以直接集成到Angular，React和Vue.js框架中，该编辑器还同时支持Markdown和富文本。
支持普通视图和类似word一样的页面视图，支持全屏幕，工具支持自定义，包括工具条颜色和样式等。
dhtmlxEditor分为免费版和收费版，免费版具有绝大多数功能，而且免费版是开源的你可以在代码级别随便扩充。
更多介绍及下载：/link?link=https://dhtmlx.com/docs/products/dhtmlxRichText/
13、eWebEditor
eWebEditor外观和使用风格都和微软 Word很类似，功能很多。工具条可以定制，运行速度很快。导入文件接口很多，支持word、excel、pdf、ppt直接导入，目前版本不支持代码高亮，不适合纯技术平台使用，适合内容编辑人员使用。
eWebEditor有很长的历史了，是典型的传统富文本编辑器，不论是界面，还是功能都比较传统。
eWebEditor是收费的，但也有免费的精简版，精简版没有后台功能。
更多介绍及下载：/link?link=http://www.ewebeditor.net/demo/
最后 富文本编辑器产品真的非常多，以上只是本人接触过的一些，相信还有很多很好的富文本存在，其实也没必要全都试一遍，只有最适合自己的，才是最好的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b85a2a5228b86ba7b03bb8c06ad8a7/" rel="bookmark">
			program2——跑模型遇到数组分配问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一：见代码
integer:: icel,ic1,ic2,ic3 real(kind = RK):: Pos0(3), cell_width integer, allocatable , save :: np_ic(:) integer , save :: nc1, nc2,nc3,non_conode integer , save :: ncel type(cell_info),save,allocatable::cell_nodes_temp2(:) nc1 = ceiling((xyzmax(1)-xyzmin(1))/cell_width)+1 nc2 = ceiling((xyzmax(2)-xyzmin(2))/cell_width)+1 nc3 = ceiling((xyzmax(3)-xyzmin(3))/cell_width)+1 ncel= nc1*nc2*nc3 如果nc1是200，nc2是4000，nc3是5000，ncel理论值应该是4000000000，但为什么计算机计算出的数值是-4812365230？
&gt;&gt;&gt;&gt; 有可能是由于nc2和nc3的数值过大，导致ncel的计算出现了数字溢出。当nc2和nc3的值与nc1相乘时，会产生一个非常大的数字，可能会超过32位整数所能代表的最大值。
在Fortran中，32位整数可表示的最大值为2,147,483,647。如果ncel的值超过这个值，就会因为整数溢出而绕成一个负值。这可能是ncel被计算为负值的原因。
一个可能的解决方案是使用64位整数来表示ncel，它可以处理比32位整数大得多的值。这可以通过将ncel声明为int64而不是整数来实现。另外，你也可以尝试使用kind参数来指定一个更大的整数类型，比如integer(kind=8)，它指定了一个64位整数。
问题二：见代码
为数组np_ic和cell_nodes_temp临时分配485244501的维度，
integer(kind=8):: icel,ic1,ic2,ic3 real(kind = RK):: Pos0(3), cell_width integer, allocatable , save :: np_ic(:) integer , save :: nc1, nc2,nc3,non_conode integer(kind=8) , save :: ncel type(cell_info),save,allocatable::cell_nodes_temp2(:) cell_width = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b85a2a5228b86ba7b03bb8c06ad8a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60a0fa7b807f99013e2597c03f71efa/" rel="bookmark">
			LeetCode刷题笔记（Top K Frequent Elements）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚刷了一道难度适中的题目，可能由于好久都没刷题了的缘故，在代码书写方面明显略显生疏，所以大家一定不要长时间不写代码啦，加油！
题目如下：
Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. 题意分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b60a0fa7b807f99013e2597c03f71efa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3c8b346726ac5e81977f3826c1d880/" rel="bookmark">
			Hive 调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive 调优 一、SQL语句分析——EXPLAIN二、Fetch抓取三、本地模式四、表的优化1、小表大表JOIN2、大表JOIN大表3、Group by4、Count(Distinct) 去重统计5、笛卡尔积6、行列过滤7、分区分桶 五、合理设置Map及Reduce数1、复杂文件增加Map数2、小文件进行合并3、合理设置Reduce数 六、并行执行七、严格模式八、JVM重用九、压缩 一、SQL语句分析——EXPLAIN EXPLAIN不会执行该SQL，会分析出该SQL执行的步骤。
EXPLAIN [EXTENDED | DEPENDENCY | AUTHORIZATION] query 示例：
hive (default)&gt; explain select deptno, avg(sal) avg_sal from emp group by deptno; Explain STAGE DEPENDENCIES: Stage-1 is a root stage Stage-0 depends on stages: Stage-1 STAGE PLANS: Stage: Stage-1 Map Reduce Map Operator Tree: TableScan alias: emp Statistics: Num rows: 1 Data size: 7020 Basic stats: COMPLETE Column stats: NONE Select Operator expressions: sal (type: double), deptno (type: int) outputColumnNames: sal, deptno Statistics: Num rows: 1 Data size: 7020 Basic stats: COMPLETE Column stats: NONE Group By Operator aggregations: sum(sal), count(sal) keys: deptno (type: int) mode: hash outputColumnNames: _col0, _col1, _col2 Statistics: Num rows: 1 Data size: 7020 Basic stats: COMPLETE Column stats: NONE Reduce Output Operator key expressions: _col0 (type: int) sort order: + Map-reduce partition columns: _col0 (type: int) Statistics: Num rows: 1 Data size: 7020 Basic stats: COMPLETE Column stats: NONE value expressions: _col1 (type: double), _col2 (type: bigint) Execution mode: vectorized Reduce Operator Tree: Group By Operator aggregations: sum(VALUE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae3c8b346726ac5e81977f3826c1d880/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f28764f5a2882193c2989b43224961/" rel="bookmark">
			通俗易懂的知识图谱（Knowledge Graph）简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 随着信息时代的到来，数据的规模和复杂性迅速增长，如何有效地管理和利用这些数据成为一项重要挑战。知识图谱作为一种新兴的技术，可以帮助我们将数据转化为知识，并提供更加智能化、个性化的服务。本文将从知识图谱的发展背景、发展历程、应用场景以及未来的发展趋势等方面，对知识图谱进行详细介绍。
一、发展背景 知识图谱的发展背景可以追溯到人工智能的发展历程。人工智能技术的发展经历了几个阶段，分别是符号推理、神经网络、深度学习和知识图谱。在符号推理阶段，人工智能主要使用逻辑推理和规则引擎等技术，以解决专家系统等问题。在神经网络阶段，人工智能主要使用感知机和多层神经网络等技术，以解决图像识别和语音识别等问题。在深度学习阶段，人工智能主要使用卷积神经网络和循环神经网络等技术，以解决自然语言处理和计算机视觉等问题。而在知识图谱阶段，人工智能主要使用知识表示和推理等技术，以解决语义理解和推荐系统等问题。
知识图谱的发展背景还可以追溯到Web的发展历程。Web的发展经历了几个阶段，分别是Web1.0、Web2.0和Web3.0。在Web1.0阶段，Web主要是一个静态的信息发布平台，用户只能被动地浏览网页。在Web2.0阶段，Web变成了一个交互式的社交平台，用户可以主动地创建和分享内容。而在Web3.0阶段，Web将变成一个语义化的知识网络，用户可以通过自然语言来查询和获取知识。
综上所述，知识图谱的发展背景既包括人工智能技术的发展历程，也包括Web的发展历程。知识图谱可以帮助我们将人工智能和Web相结合，构建一个智能化、个性化的知识网络。
二、发展历程 知识图谱的发展历程可以分为三个阶段，分别是知识表示、知识抽取、知识融合和知识推理。
1.知识表示 知识表示是指将现实世界的事物和概念用计算机可读的方式进行表达的过程。最早的知识表示方法是基于逻辑的，它将世界看作由实体、属性和关系三部分组成的知识体系，并通过谓词逻辑表达这些概念之间的关系。例如，可以使用“父亲（x，y）”表示x是y的父亲这一关系。这种方法虽然能够精确表达知识，但是对于复杂的知识结构来说，需要人工构建大量的规则和推理机制，且无法处理不确定性和模糊性等问题。
随着人工智能技术的发展，出现了一系列新的知识表示方法，如本体论、语义网络和图等。本体论是一种基于术语和概念的知识表示方法，它使用本体描述事物和概念的属性、关系和行为，并对其进行分类和层次化。语义网络则是一种图形表示方法，将实体和关系表示为节点和边，并使用图论方法进行推理和分析。而图则是一种更加通用的表示方法，可以用来表示任何事物和概念之间的关系，包括社交网络、知识图谱和生物网络等。
2.知识抽取 知识抽取是指从文本和其他非结构化数据中自动抽取出结构化的知识，以构建知识图谱的过程。知识抽取通常包括实体识别、关系抽取和事件抽取等步骤。
实体识别是指从文本中识别出具有特定含义的实体，如人物、地点、机构等。关系抽取是指从文本中抽取出实体之间的关系，如父子关系、工作关系等。事件抽取则是指从文本中抽取出事件的主题、参与者和结果等信息。这些抽取出来的信息可以用来构建知识图谱中的实体和关系，并用于知识推理和应用开发等领域。
知识抽取技术主要依赖于自然语言处理和机器学习技术，如分词、词性标注、句法分析、语义角色标注、实体识别、关系抽取和事件抽取等。随着深度学习技术的发展，知识抽取技术已经取得了很大的进展，能够在大规模数据上进行高效的知识抽取和构建。
3.知识推理 知识推理是指在知识图谱中进行推理和推断的过程。它可以利用已有的知识和规则来自动推导出新的知识和结论，帮助人们更好地理解和利用已有的知识。知识推理主要分为基于规则的推理和基于统计学习的推理两种。
基于规则的推理是指通过事先定义好的规则和逻辑规则来进行推理和推断。这种方法可以比较精确地描述和推断知识，但是对于复杂的知识结构和不确定性问题难以处理。
基于统计学习的推理是指通过训练模型来进行推理和推断。这种方法主要依赖于大规模数据的训练和模型优化，可以适应更复杂和不确定的知识结构。随着深度学习技术的发展，基于统计学习的推理方法已经在知识图谱中得到广泛应用。
4.知识融合 知识融合是指将来自不同数据源和领域的知识进行融合和整合的过程，以构建更加全面和准确的知识图谱。不同的数据源可能包含不同的知识和信息，需要将它们进行映射和匹配，以便于构建更加全面和一致的知识图谱。
知识融合通常包括实体对齐、关系匹配和模式挖掘等步骤。实体对齐是指将不同数据源中的实体进行映射和匹配，以便于构建一个统一的实体库。关系匹配是指将不同数据源中的关系进行匹配和映射，以便于构建一个统一的关系库。模式挖掘则是指在不同数据源中寻找相同或类似的知识模式，以便于构建更加全面和准确的知识图谱。
三、应用场景 知识图谱可以在各种领域中应用，包括搜索引擎、智能问答、语义理解、推荐系统、金融风险控制、医疗诊断、智能制造、智慧城市等。下面列举一些常见的应用场景。
1.搜索引擎 搜索引擎是知识图谱最早的应用场景之一。知识图谱可以将搜索结果与知识图谱中的实体和关系进行匹配和推理，提供更加准确和全面的搜索结果。例如，在搜索“比尔·盖茨”的时候，知识图谱可以自动识别他是微软公司的创始人，并给出相关的知识和信息，如其个人简介、职业经历、财富等。
2.智能问答 知识图谱可以为智能问答系统提供强有力的支持。通过将自然语言问题与知识图谱中的实体和关系进行匹配和推理，智能问答系统可以自动回答各种问题，如“谁是中国的国家主席？”、“成龙的出生地在哪里？”、“爱因斯坦发明了哪些东西？”等。
3.语义理解 语义理解是指对自然语言文本进行深层次的语义分析和理解，以获取其中所包含的实体、关系、事件等知识。知识图谱可以为语义理解提供基础数据和知识支持。通过将自然语言文本与知识图谱中的实体和关系进行匹配和推理，语义理解系统可以自动抽取出其中所包含的知识和信息。
4. 推荐系统 推荐系统是指根据用户的个性化需求和历史行为，为用户推荐感兴趣的产品或服务。知识图谱可以为推荐系统提供更加全面和准确的用户画像和商品画像。通过将用户行为数据与知识图谱中的实体和关系进行匹配和推理，推荐系统可以自动构建用户画像和商品画像，并进行精准推荐。
5.金融风险控制 知识图谱可以为金融风险控制提供强有力的支持。通过将金融数据与知识图谱中的实体和关系进行匹配和推理，风险控制系统可以自动发现各种风险因素和关联关系，如欺诈、洗钱、违规交易等，从而及时采取措施，降低风险和损失。
6.医疗诊断 知识图谱可以为医疗诊断提供强有力的支持。通过将医疗数据与知识图谱中的实体和关系进行匹配和推理，医疗诊断系统可以自动发现疾病因素和关联关系，从而进行精准诊断和治疗。
7.智能制造 知识图谱可以为智能制造提供强有力的支持。通过将工厂数据与知识图谱中的实体和关系进行匹配和推理，智能制造系统可以自动发现生产过程中的各种问题和关联关系，如故障、质量问题、物料短缺等，从而及时采取措施，提高生产效率和质量。
8.其他应用领域 除了上述应用领域，知识图谱还可以应用于其他各个领域。例如：
教育领域：知识图谱可以为教育领域提供个性化教育和智能评估服务；能源领域：知识图谱可以为能源领域提供智能能源管理和优化服务；农业领域：知识图谱可以为农业领域提供智能农业和精准农业服务；城市管理领域：知识图谱可以为城市管理领域提供智能交通和智慧城市服务。 四、未来发展趋势 随着人工智能技术的不断发展和应用，知识图谱将会迎来更广阔的发展空间和更多的应用场景。未来，知识图谱在以下方面可能会有更大的发展：
4.1.知识表示和知识获取 当前的知识图谱主要是基于人工构建的，其知识表示和知识获取方式受到人类知识结构和思维方式的限制。未来，随着自然语言处理和机器学习技术的不断发展，知识图谱的知识表示和知识获取方式可能会更加自动化和智能化。
4.2 知识融合和知识推理 当前的知识图谱主要是基于单一数据源和单一知识模型，其知识融合和知识推理能力有限。未来，随着数据共享和知识共享的不断增加，知识图谱的知识融合和知识推理能力可能会更加强大和灵活。
4.3 知识应用和知识交互 当前的知识图谱主要是基于机器理解和机器推理，其知识应用和知识交互方式有限。未来，随着自然语言处理和计算机视觉技术的不断发展，知识图谱的知识应用和知识交互方式可能会更加自然和人性化。
五、总结 知识图谱是一种基于语义网络的知识表示和知识推理技术，其主要目的是将海量的
异构数据整合成一个统一的知识库，并通过知识推理来发现数据之间的关联和规律。知识图谱已经在许多领域得到了广泛应用，包括搜索引擎、智能客服、智能制造、医疗健康等。
知识图谱的发展历程可以分为三个阶段：手工构建阶段、半自动构建阶段和自动构建阶段。当前，随着人工智能技术的不断发展和应用，知识图谱将会迎来更广阔的发展空间和更多的应用场景。未来，知识图谱的发展方向可能会更加自动化、智能化、强大和灵活。
知识图谱的关键技术包括：知识表示、知识获取、知识融合、知识推理、知识存储和知识应用。其中，知识表示是知识图谱的核心技术，它通过语义网络对知识进行结构化表示，并将不同数据源的知识整合在一起。知识融合和知识推理是知识图谱的关键能力，它们能够发现不同数据之间的关联和规律，从而支持更加复杂的应用场景。
目前，知识图谱的应用场景主要包括搜索引擎、智能客服、智能制造、医疗健康等。未来，知识图谱还有很多应用场景有待开发，例如教育、能源、农业和城市管理等领域。
总之，知识图谱是一项具有广泛应用前景的技术，其重要性和价值正在不断被人们认识和发掘。在未来，随着技术的不断发展和应用，知识图谱将会在更多的领域得到应用，为人们带来更多便利和价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038f498becee8798fedf1a734dffc546/" rel="bookmark">
			android studio安装automotive模拟器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加源 打开android studio的SDK Manager选择SDK Update Sites选项卡点击Add,弹出地址设置界面 添加polestar2-sys-img Name填写：Polestar 2 System Image (可自定义)URL填写：https://developer.polestar.com/sdk/polestar2-sys-img.xml其他保持默认 添加volvo-sys-img Name填写：Volvo auto image (可自定义)URL填写：https://developer.volvocars.com/sdk/volvo-sys-img.xml其他保持默认 应用及确定 创建Automative模拟器 打开android studio的Device Manager选择Virtual点击Create device选择Automative在设备列表选择一款设备即可点击Next，选择x86 Images，选择镜像下载，即可完成创建。 参考 Android Automotive模拟器“未为此目标安装系统映像”Android车载开发——车载模拟器搭建Android Automotive 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7514ad99a4ca8b221426eb9ceb006a14/" rel="bookmark">
			keil5 Logic Analyzer逻辑分析仪端口输出波形观测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言本文主要分为两部分： 第一部分是keil5逻辑分析仪的相关设置； 第二部分是单片机调试的时候解决的几个问题； 做此记录。 一、基础设置（以STM32F103C8T6为例）1.点击魔法棒2.debug设置3.进入仿真界面4.端口设置5.完成 二、硬件调试过程中遇到的几个问题1.keil5闪退2.单片机程序下载不了3.找不到STLINK 总结 前言 本文主要分为两部分：
第一部分是keil5逻辑分析仪的相关设置；
第二部分是单片机调试的时候解决的几个问题；
做此记录。 一、基础设置（以STM32F103C8T6为例） 1.点击魔法棒 2.debug设置 在选项卡中找到debug，如果是软件仿真，就要选择左边的"Use Simulation"。下面的"Dialog DLL" 和 “Parameter” 也需要更改；"Dialog DLL"软件仿真填入的是"DARMSTM.DLL” ，硬件仿真填入“TARMSTM.DLL” 。 “Parameter” 为 “-pSTM32F103C8”填的是芯片型号，以TM32F108C8T6为例。
设置好后点击OK
3.进入仿真界面 打开逻辑分析仪
也可以找到view-&gt;Analysis Window-&gt;Logic Analyzer
点击 View 菜单，选择 “Symbols Window” 选项，在弹出的窗口里 “Special Function Register” 里找到查看波形的引脚。
找到端口设置形式
4.端口设置 终于可以进入正题了，端口设置，此处我需要观测的是用作IIC的SCL信号的PB10和SDA的PB11引脚。
点击setup
新增端口，输入GPIOB_ODR，Display Type选择Bit，因为我们只观测B的一个端口，color选择颜色，And Mask:0x00000400，Shift Right:10，意为PORTB的端口10，如果是PB11，则And Mask:0x00000800，Shift Right:11。
5.完成 设置好之后，点击run运行，就可以观测到波形啦
二、硬件调试过程中遇到的几个问题 1.keil5闪退 原因：keil版本过高，打开低版本就会闪退
解决方法：win+R-&gt;输入redegit-&gt;找到HKEY_CURRENT_USER\SOFTWARE\Keil\礦ision5\Recent Projects-&gt;删除默认以外的数据-&gt;关闭注册表编辑器-&gt;重启keil-&gt;问题解决
2.单片机程序下载不了 可能问题：单片机被锁住了
解决方法：擦除芯片
通过串口模式进行烧写，
打开魔法棒-&gt;output-&gt;勾选creat HEX File
打开mcuisp-&gt;搜索串口-&gt;设置串口-&gt;添加HEX文件-&gt;设置DTP低电平复位，RTS高电平进BootLoader-&gt;清除芯片-&gt;结束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7514ad99a4ca8b221426eb9ceb006a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fdbd0145efabc651de7b56c21d5b11f/" rel="bookmark">
			《挑战不用macOS逆向iOS APP》之两百元成本的iOS逆向环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intro 很多人在学习逆向iOS app的时候，都有两个痛点：
iOS设备太贵需要macOS环境 前者需要小几千的iPhone，后者需要至少大几千的Macbook 。本系列文章就是为了解决这两个痛点，全部操作在一百多块钱的iPhone6上完成，且电脑端在r0env/Win上进行演示，让我们康康，这几乎无成本的一套环境，究竟可以让我们走多远，走多深！
本篇文章是《挑战不用macOS逆向iOS APP》系列的第一课环境搭建主要为了实现在iOS APP逆向过程中一些环境方面的常规需求，具体实现目标如下:
windows中iPhone基本信息获取/软件安装/投屏越狱设备分析推荐/工具推荐/unC0ver流程详解越狱后手机常用工具:日志/网络/包管理/免签名Frida/Objection/任意版本安装切换/动态分析ios砸壳/IPA静态分析基本流程/IDAF5函数定位linux中iphone手机信息获取:ID/名称/详情/签名/截屏/定位安装APP/IPA:安装/卸载/升级/备份/回复APP收发传输文件:usbmuxd OpenSSH=adb pull/push远程文件管理:磁盘映射/电脑上浏览手机文件夹升降级和激活:恢复模式/固件升降级/手机激活 该系列为学员优秀作品系列，附件apk、代码等位于我的项目中，大家可以自取：
https://github.com/r0ysue/AndroidSecurityStudy
1.Windows中iPhone基本信息获取/软件安装/投屏 (1)基本信息获取 Windows中操作iPhone官方推荐方式是使用iTunes，但是后续我们会安装未经签名的应用，因此这里我们推荐使用爱思助手进行操作。直接去官网下载安装爱思助手，打开并在手机上信任此电脑
(2)软件安装 软件安装:点开爱思助手的应用游戏可以直接安装，爱思上安装的软件有APP Store上架的也有未上架但有企业账号签名的，具体内容涉及IPA签名，会在后续文章解释。
(3)手机投屏 直接使用爱思助手中的投屏，可以使用有线投屏，同一局域网下也可以使用无线投屏
手机端上滑点击屏幕镜像点击爱思投屏即可。
2.越狱设备分析推荐/unC0ver流程详解 (1)越狱设备的分析与推荐 查看爱思助手的越狱方式可以看到
可以支持ios版本最高的是unc0ver方式可以支持到iOS14.8，而又由于iPhone越狱失败后重启设备失败的话需要恢复出厂设置，此时会自动更新到当前设备支持的最新iOS版本，而iPhone6最高版本是12.5.4，iPhone6s和iPhone7最新版本均是iOS 15，因此我们选择使用iPhone6作为越狱设备，这样即使越狱失败最新版本也依然在越工具支持版本之下。
越狱方式对比，这里主要分析两种方式unc0ver和Checkra1n
checkra1n:比较复杂还要制作u盘但是胜在稳定
unc0ver：过程简单但是成功比较看运气，需尝试多次才能成功
(2)checkra1n越狱详细流程 （1）制作一个越狱u盘 （2）刷入手机实现越狱 进入电脑BIOS选择VendorCo ProductCode 从u盘启动
选择ALT+F2进入Checkra1n刷机系统
上下左右空格键控制start开始越狱
next
进入刷机界面后根据提示操作
1.点击start
2.同时摁住侧边键和home键
3.摁住home键
这个界面就是在刷入，ALL Done就是刷入成功了。
补充：中间可能会失败，没关系多来几次总能成功的，但是一定注意，手机不要买到带锁机，二手iphone卖家有时会隐藏ID锁，这种机子可以登录自己ID但是一旦越狱失败就寄了。。。
3.越狱后手机常用工具:日志/网络/包管理/免签名 手机越狱成功后，会在桌面显示checkra1n图标，点击安装cydia，cydia是一个需要越狱后使用的三方软件仓库。这里我们主要安装以下几个工具：
(1)cydia自带源工具安装 cydia自带源的工具可以直接搜索安装
oslog 日志查看工具，默认安装在/usr/bin目录下OPENSSH 远程连接软件，作用是远程连接手机,默认账号密码为root/alpineFilza File Manager 是手机端的文件管理软件，作用是让我们更方便的操作手机上的文件。Apple File Conduit “2” IOS上的一个插件工具，作用是帮助我们在电脑端操作手机上的文件 (2)三方源工具安装 AppSync Unifield AppSync Unifield是IOS上的插件工具，作用是帮助我们安装未经苹果签名的IPA,安装后可以安装未经苹果签名的软件，安装具体流程如下：
首先添加源：编辑-&gt;添加-&gt;输入cydia.angelxwind.net
然后进行插件安装：karen-&gt;插件-&gt;AppSync-&gt;安装-&gt;确认-&gt;重启
frida-server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fdbd0145efabc651de7b56c21d5b11f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11dd69b4b3d0c0e940a3a5f546c8bf66/" rel="bookmark">
			Zabbix 6.0 图文安装部署讲解---LNMP环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zabbix 6.0 图文安装部署讲解---LNMP环境 简介环境需求部署环境关闭系统防火墙一、Mysql8.0.30 部署 二、nginx 部署三、PHP 部署四、zabbix-server 部署五、Web端初始化六、解决zabbix 6.0 中文乱码问题 简介 Zabbix 主要有以下几个组件组成：
Zabbix Server：Zabbix 服务端，是 Zabbix 的核心组件。它负责接收监控数据并触发告警，还负责将监控数据持久化到数据库中。
Zabbix Agent：Zabbix 客户端，部署在被监控设备上，负责采集监控数据，采集后的数据发送给 Zabbix Server 处理。Zabbix Agent 目前有两个版本：Zabbix agent 和 Zabbix agent 2。前者是 C 语言开发的，几乎支持所有的主流平台。而后者是 Go 开发的，优点包括：能有效降低 TCP 连接的数量；支持更高的并发；易于扩展。目标是替代 Zabbix agent ，目前只支持 Linux 和Windows 两个平台。
Zabbix Proxy：代替 Zabbix Server 接收监控数据并进行预处理，预处理后的数据批量发送给 Zabbix Server，这样可减轻 Zabbix Server 的压力。
Web 页面：可通过 Web 页面来管理和维护被监控设备的配置信息、查看监控数据、配置告警等。
数据库：负责存储被监控设备的配置信息和监控数据。支持的数据库有：MySQL（Percona，MariaDB），Oracle，PostgreSQL，TimescaleDB for PostgreSQL，SQLite
环境需求 数据库Mysql需要是8.0.x以上的版本，PHP不支持PHP8.0版本 ，详细信息可看–&gt;官方文档
本文安装环境：Centos 7.4、 Nginx 1.20 、 Mysql 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11dd69b4b3d0c0e940a3a5f546c8bf66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8afa2cb30eed0f3fc7240fb9a4c7171c/" rel="bookmark">
			Windows虚拟机激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开cmd命令提示符
首先连接kms服务器
slmgr -skms skms.netnr.eu.org 接着输入对应系统版本的产品密钥 xxxxx-xxxxx-xxxxx-xxxxx-xxxxx
slmgr -ipk xxxxx-xxxxx-xxxxx-xxxxx-xxxxx 最后进行激活
slmgr /ato 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8a7257d77f4880f31decc62deb8dd4b/" rel="bookmark">
			windows系统管理_windows server 2016网络参数配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络参数配置 要将安装好的操作系统接入到网络中，首先需要做的是为操作系统配置 IP 地址等参数。Windows
2016 支持 IPV4 以及 IPV6 两种网络协议。
IPV4 IPV6 DNS概述 IPV4介绍 网际协议版本4 （Inernet Protocol version 4， IPV4） 又称互联网通信协议第四版，是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4 是互联网的核心，
也是使用最广泛的网际协议版本，其后继版本为 IPv6。
IPV6 介绍 IPv6 是英文“Internet Protocol Version 6”（互联网协议第 6 版）的缩写，是互联网工程任务组（IETF）
设计的用于替代 IPv4 的下一代 IP 协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址[1]。
由于 IPv4 最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6 的使用，
不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍[1]。
互联网数字分配机构（IANA）在 2016 年已向国际互联网工程任务组（IETF）提出建议，要求新
制定的国际互联网标准只支持 IPv6，不再兼容 IPv4。
DNS 介绍 域名系统（服务）协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转
换，以及控制因特网的电子邮件的发送。大多数因特网服务依赖于 DNS 而工作，一旦 DNS 出错，就
无法连接 Web 站点，电子邮件的发送也会中止。
设置 IPV4 参数 为计算机设置的 IPV4 参数包含 IP 地址、子网掩码、默认网关和 DNS 服务器地址，设置的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8a7257d77f4880f31decc62deb8dd4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9939a34388b80c724695a40ad29d8fa4/" rel="bookmark">
			vue 高德天气接口，高德自定义天气图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="weather"&gt; &lt;div class="child"&gt; &lt;img :src="imgUrl || defaultImgUrl"&gt; &lt;div class="temperature"&gt;{{ temperature || defaultTemperature }}°C&lt;/div&gt; &lt;div class="word"&gt;{{ weather || defaultWeather }}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Weather', data() { return { weather: '', temperature: '', imgUrl: '', defaultWeather: '晴', defaultTemperature: '28', defaultImgUrl: require('@/assets/platform/weather/weather01.png'), weatherList: [ { id: 1, name: '晴', url: require('@/assets/platform/weather/weather01.png') }, { id: 2, name: '少云', url: require('@/assets/platform/weather/weather02.png') }, { id: 3, name: '晴间多云', url: require('@/assets/platform/weather/weather03.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9939a34388b80c724695a40ad29d8fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f0bc36e8bef0e62f892ff50a82ae68b/" rel="bookmark">
			Flutter（一）--初入Flutter&amp;基础组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前有个Dart的语言基础后，现在开始进入真正的跨平台Flutter开发，如果你学习过Jetpack Compose，那么Flutter的学习会变得十分简单，两者之间的概念几乎一样，都有含有状态、组件。同时状态是声明式UI中最重要的一环，在后续过程会逐渐使用
文章目录 一、第一个Flutter应用1.状态 二、基础组件1.Text1.1 基本使用1.2 TextStyle1.3 TextSpan1.4 DefaultTextStyle 2.Buttons2.1 TextButton2.2 ButtonStyle2.3 ElevatedButton2.4 OutlinedButton2.5 IconButton2.6 FloatingActionButton2.7 PopupMenuButton2.8 DropdownButton 3.Images3.1 AssetBundle 资源配置3.2 Image3.2.1 AssetImage3.2.2 NetworkImage3.2.3 BoxFit3.2.4 其他构造 3.3 Icon 4.Selections4.1 Radio4.2 Checkbox4.3 Switch4.4 Slider4.5 showDatePicker 5.Inputs5.1 TextField5.1.1 onChanged 获取内容值5.1.2 controller 获取内容值 5.2 Form 6.Chip 一、第一个Flutter应用 根据Dart文章中Dart（一）–初入Dart 环境配置 构建完项目后， 在main函数中调用runApp()方法，传入一个组件即可编译成一个App，由于暂时用不到状态，我们的组件先继承StatelessWidget：
import 'package:flutter/material.dart'; // 主函数 void main() { // 调用runApp 构建app runApp(const MyApp()); } // 自定义组件继承至StatelessWidget，表示无状态的组件 class MyApp extends StatelessWidget { const MyApp({super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f0bc36e8bef0e62f892ff50a82ae68b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c8e202526492d695ee459733b7fbed3/" rel="bookmark">
			Python&#43;GDAL 计算图像四个角的经纬度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考了文末的三个博客并进行修改和总结，在ArcGIS中验证了结果 本文使用的图像是基于WGS UTM投影坐标系，计算出的结果为投影坐标（M），需要将结果转为WGS1984坐标系才可得到经纬度坐标 首先输出图像的投影信息，查看图像的投影格式
# 输出图像的投影信息 print(ds.GetProjectionRef()) 输出结果如下所示，是UTM投影格式，如果是WGS1984地理坐标系算出来应该直接是经纬度坐标，不用转换
PROJCS["WGS 84 / UTM zone 44N", GEOGCS["WGS 84", DATUM["WGS_1984", SPHEROID["WGS84",6378137,298.257223563,AUTHORITY["EPSG","7030"]], AUTHORITY["EPSG","6326"]], PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]], UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]], AUTHORITY["EPSG","4326"]],PROJECTION["Transverse_Mercator"], PARAMETER["latitude_of_origin",0], PARAMETER["central_meridian",81], PARAMETER["scale_factor",0.9996], PARAMETER["false_easting",500000], PARAMETER["false_northing",0], UNIT["metre",1,AUTHORITY["EPSG","9001"]], AXIS["Easting",EAST], AXIS["Northing",NORTH], AUTHORITY["EPSG","32644"]] 1.首先计算图像四个角的投影坐标，代码如下 GetGeoTransform方法可以读取地理信息，返回六个参数 GT(0) 左上像素左上角的x坐标。
GT(1) w-e像素分辨率/像素宽度。
GT(2) 行旋转（通常为零）。
GT(3) 左上像素左上角的y坐标。
GT(4) 列旋转（通常为零）。
GT(5) n-s像素分辨率/像素高度（北上图像为负值）
from osgeo import gdal def project_xy(tif_path): dataset = gdal.Open(tif_path) geo_information = dataset.GetGeoTransform() col = dataset.RasterXSize # 行数 row = dataset.RasterYSize # 列数 # band = dataset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c8e202526492d695ee459733b7fbed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb79ad830d08a92b641e05b62b89e37/" rel="bookmark">
			第一章 Python概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 Python概述 【本章要点】 整数四则运算项目实训1：项目实训2：项目实训3：项目实训4： 【本章要点】 ● 输出函数
print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False) str.format(*args, **kwargs) f_string ● 输入函数
input([prompt])
● 对象的概念
基本属性：类型、身份标识和值
● 变量
对象的名字，依附于对象存在，首次出现于赋值符号“=”左侧
● 编码规范及注释
Python 编程应遵循PEPE8规范
注释以“#”开头，独占一行或置于代码后，至少空两格
整数四则运算 项目实训1： 日期格式化输出
在三行中分别输入当前的年、月、日的整数值，按要求完成输出。 1 输出年月日，空格分隔，格式：2020 09 16
2 输出年-月-日，连字符“-”分隔，格式：2020-09-16
3 输出年/月/日，斜线“/”分隔，格式：2020/09/16
4 输出月，日，年，逗号“,”分隔，格式：09,16,2020
5 用str.format()格式输出，格式：2020年09月16日
6 用字符串拼接方法输出，格式：2020年09月16日
运行代码：
year=input() month=input() date=input() print(year,month,date) print(year,month,date,sep='-') print(year,month,date,sep='/') print(month,date,year,sep=',') print('{}年{}月{}日'.format(year,month,date)) print(year+'年'+month+'月'+date+'日') 运行结果：
项目实训2： Python 可以方便的实现计算器的功能。input()函数做为int()函数的参数，用int(input())可以把输入转为整数，
类似，可以用float(input())将输入转为浮点数，round(num, n) 可以把num近似保留小数点后n位。
数学意义上的加、减、乘、除分别为符号“+、-、*、/”表示。
输入两个非零整数，在4 行中按顺序输出两个数的加、减、乘、除的计算结果。
输入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adb79ad830d08a92b641e05b62b89e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c55b54bf3671e989b0f074db63cfd6/" rel="bookmark">
			TiDB集群部署最细化教程-亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TiDB-TiUP集群部署 本次部署使用环境：
CentOS Linux release 7.9.2009 (Core) TiDB 6.5.1 三台服务器： (内)172.19.172.179 (内)172.19.172.180 (内)172.19.172.182 一、部署前准备 1.1 查询官方文档部署环境及配置要求-此处不赘述 1.2 检测及关闭系统 swap echo "vm.swappiness = 0"&gt;&gt; /etc/sysctl.conf swapoff -a &amp;&amp; swapon -a sysctl -p 1.3 检测及关闭目标部署机器的防火墙 检查防火墙状态
sudo firewall-cmd --state sudo systemctl status firewalld.service 关闭防火墙服务
sudo systemctl stop firewalld.service 关闭防火墙自动启动服务
sudo systemctl disable firewalld.service 检查防火墙状态
sudo systemctl status firewalld.service 1.4 检测及安装 NTP 服务 执行以下命令，如果输出 running 表示 NTP 服务正在运行：
sudo systemctl status ntpd.service 输出结果： ntpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c55b54bf3671e989b0f074db63cfd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74b3fce237818664b3d81506dffb2ba8/" rel="bookmark">
			uview城市选择器、省市区选择器（不含港澳台数据 ，需要的自己手动添加数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		城市选择器如果是做表单项目的时候出现频率还是比较高的，但是翻遍uview的组件库却只找到一个多列联动的picker，没办法只能自己动手撸一个了
最好是单独再封装成一个组件通过v-model绑定，并全局注册组件
组件代码： &lt;template&gt; &lt;view class="wid-box-100"&gt; &lt;u--input placeholder="请选择" border="surround" :readonly="true" suffixIcon="arrow-right" v-model="value" @click.native="show=true" &gt;&lt;/u--input&gt; &lt;u-picker :show="show" ref="uPicker" :columns="columns" @confirm="confirm" @change="changeHandler"&gt;&lt;/u-picker&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import {county} from "@/components/city-picker/data.js" export default { model:{ event:'cityPickerConfirm', }, data() { return { value:'', show: false, columns: [],//默认初始数据 columnData: [],//第二列的数据 columnData2:[],//第三列的数据 } }, created() { const arrOne = []//省(第一列数据) county.forEach(item=&gt;{ arrOne.push(item.name) }) const arrTwo = []//市(第二列数据) county.forEach(item=&gt;{ const list = item.children.map(ite=&gt;{ return ite.name }) arrTwo.push(list) }) const arrThree = []//区(第三列数据) county.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74b3fce237818664b3d81506dffb2ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668d6198f365928bd71e4f97f40c74c4/" rel="bookmark">
			LVGL V8自定义实现radio button
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天由于开发任务的需要，需要自定义实现一个radio button的功能，所以通过研究button添加LV_OBJ_FLAG_CHECKABLE属性实现了一个简单的radio button，下面直接上代码
#include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include "lvgl/lvgl.h" #define THIS_FILE "inpatient_cost.c" static void radio_btn_event_callback(lv_event_t* event) { if (event == NULL) { printf("[%s:%d] event is NULL\n", __FUNCTION__, __LINE__); return ; } uint32_t* active_id = (uint32_t*)lv_event_get_user_data(event); //获取用户数据 lv_obj_t* obj_cont = lv_event_get_current_target(event); // 获取当前目标事件的布局对象 lv_obj_t* obj_active = lv_event_get_target(event);//获取产生事件的对象 lv_obj_t* obj_old = lv_obj_get_child(obj_cont, *active_id); //根据id序号获取子对象 if (obj_active == obj_cont) { return; //不处理layout布局对象产生的事件 } lv_obj_clear_state(obj_old, LV_STATE_CHECKED); //清除先前的选择状态 lv_obj_add_state(obj_active, LV_STATE_CHECKED); // 设置点击的对象为选中状态 // 选中和非选中字体颜色要和背景颜色互换 lv_obj_t * obj_old_child = lv_obj_get_child(obj_old, 0); if (obj_old_child !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/668d6198f365928bd71e4f97f40c74c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec4c00e1abb4e03ac1b19ec936bcfba/" rel="bookmark">
			6.监控、审计和运行时安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监控、审计和运行时安全 主要内容 ❖ 分析容器系统调用：Sysdig
❖ 监控容器运行时：Falco
❖ Kubernetes 审计日志
分析容器系统调用：Sysdig Sysdig简介 Sysdig：一个非常强大的系统监控、分析和故障排查工具。
汇聚 strace+tcpdump+htop+iftop+lsof 工具功能于一身！
sysdig 除了能获取系统资源利用率、进程、网络连接、系统调用等信息， 还具备了很强的分析能力，例如：
按照CPU使用率对进程排序
按照数据包对进程排序
打开最多的文件描述符进程
查看进程打开了哪些文件
查看进程的HTTP请求报文
查看机器上容器列表及资源使用情况
项目地址：https://github.com/draios/sysdig
文档：https://github.com/draios/sysdig/wiki
sysdig 通过在内核的驱动模块注册系统调用的 hook，这样当有系 统调用发生和完成的时候，它会把系统调用信息拷贝到特定的 buffer，然后用户态组件对数据信息处理（解压、解析、过滤等）， 并最终通过 sysdig 命令行和用户进行交互。
安装sysdig 导入sysdig的repo源，安装epel源。
安装完sysdig的时候，需要更新一下软件包，会更新sysdig，才能加载模块。
[root@master01 ~]# rpm --import https://s3.amazonaws.com/download.draios.com/DRAIOS-GPG-KEY.public [root@master01 ~]# curl -s -o /etc/yum.repos.d/draios.repo https://s3.amazonaws.com/download.draios.com/stable/rpm/draios.repo [root@master01 ~]# yum install epel-release -y [root@master01 ~]# yum install sysdig -y [root@master01 ~]# yum update -y [root@master01 ~]# /usr/bin/sysdig-probe-loader # 加载驱动模块 sysdig常用参数 -l, --list：列出可用于过滤和输出的字段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec4c00e1abb4e03ac1b19ec936bcfba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8295ef1e6143140544b738426fe55da/" rel="bookmark">
			4.最小化微服务漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小化微服务漏洞 主要内容 ❖ Pod安全上下文
❖ Pod安全策略
❖ Secret存储敏感数据
❖ 安全沙箱运行容器
Pod安全上下文 安全上下文（Security Context）：K8s对Pod和容器提供的安全机制，可以设置Pod特权和访问控制。
安全上下文限制维度：
自主访问控制（Discretionary Access Control）：基于用户ID（UID）和组ID（GID），来判定对对象（例如文件） 的访问权限。安全性增强的 Linux（SELinux）： 为对象赋予安全性标签。以特权模式或者非特权模式运行。Linux Capabilities: 为进程赋予 root 用户的部分特权而非全部特权。AppArmor：定义Pod使用AppArmor限制容器对资源访问限制Seccomp：定义Pod使用Seccomp限制容器进程的系统调用AllowPrivilegeEscalation： 禁止容器中进程（通过 SetUID 或 SetGID 文件模式）获得特权提升。当容器以特权模式 运行或者具有CAP_SYS_ADMIN能力时，AllowPrivilegeEscalation总为True。readOnlyRootFilesystem：以只读方式加载容器的根文件系统。 案例实施 案例1：设置容器以普通用户运行 背景：容器中的应用程序默认以root账号运行的，这个root与宿主机root账号是相同的， 拥有大部分对Linux内核的系统调用权限，这样是不安全的，所以我们应该将容器以普 通用户运行，减少应用程序对权限的使用。
可以通过两种方法设置普通用户：
Dockerfile里使用USER指定运行用户K8s里指定spec.securityContext.runAsUser，指定容器默认用户UID spec: securityContext: runAsUser: 1000 # 镜像里必须有这个用户UID fsGroup: 1000 # 数据卷挂载后的目录属组设置为该组 containers: - image: lizhenliang/flask-demo:root name: web securityContext: allowPrivilegeEscalation: false # 不允许提权 创建Pod使用安全上下文测试是否改为uuid运行容器:
[root@master01:~] # cat pod-test.yaml apiVersion: v1 kind: Pod metadata: name: test spec: securityContext: runAsUser: 1000 fsGroup: 1000 containers: - image: lizhenliang/flask-demo:root name: test securityContext: allowPrivilegeEscalation: false 执行yaml之后进入容器查看当前的uuid：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8295ef1e6143140544b738426fe55da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319ccd67a718e0fd22a97268689a03c9/" rel="bookmark">
			word文档中工具栏不显示mathtype处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、确定受信任位置：
文件-选项-信任中心-受信任位置（这里为STARTUP文件夹位置，也可以是加载模板的位置）
我的本地位置：
C:\Users\YK\AppData\Roaming\Microsoft\Word\STARTUP
2、拷贝两个文件到 受信任位置
（1）找到mathtype的安装目录，在目录中找到mathPage把mathPage.wll文件复制
我的位置在：F:\MathPage\64
（2）Office Support\MathType Commands 2016 For Word.dotm 文件复制。
我的位置在F:\Office Support\64
即拷贝结果为
重启word，就可以在工具栏中看到mathtype了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8448660d523239df2a72d665a6ea8e4/" rel="bookmark">
			树状数组讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
单点修改，区间查询：
题目描述：
lowbit()运算：
插入、修改单点数据：
计算前缀和：
完整代码：
区间修改，单点查询：
计算差分数组：
计算每个点的值：
完整代码：
单点修改，区间查询： 题目描述： 如题，已知一个数列，你需要进行下面两种操作：
将某一个数加上 x
求出某区间每一个数的和
输入格式
第一行包含两个正整数 n, m，分别表示该数列数字的个数和操作的总个数。
第二行包含 n 个用空格分隔的整数，其中第 i 个数字表示数列第 i 项的初始值。
接下来 m 行每行包含 3 个整数，表示一个操作，具体如下：
1 x k 含义：将第 x 个数加上 k
2 x y 含义：输出区间 [x, y] 内每个数的和
输出格式
输出包含若干行整数，即为所有操作 2 的结果。
lowbit()运算： //非负整数n在二进制表示下最低位1及其后面的0构成的数值 //eg.lowbit(12) = lowbit((1100)2) = (100)2 = 4 //将1100按位取反后加一得到0100，会发现除了最低位的一和后面的零，其余位上与原数均相反 //故两者按位与后正好得到最低位1及其后面的0构成的数值 //又取反加一为补码，故lowbit为k &amp; -k int lowbit(int k) { return k &amp; -k; } 插入、修改单点数据： //如图： //tree[x]保存以x为根的子树中叶节点值的和 //将x转化为二进制后，发现每一层的末尾的零的个数都相同 //且tree[x]覆盖的长度即为lowbit(x)的值 //tree[x]的父节点为tree[x + lowbit(x)] void add(int x, int k) { while(x &lt;= n) { tree[x] += k; x += lowbit(x); } } 计算前缀和： //由图可知，若求前7项的和，则该值为tree[7] + tree[6] + tree[4] //故，通过循环可以求出结果 int sum(int x) { int ans = 0; while(x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8448660d523239df2a72d665a6ea8e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3455e4c5ab2ff1677640e5da5944b4/" rel="bookmark">
			科普：什么是CPU？CPU和芯片关系？CPU怎么做的？CPU有什么用？不同CPU有什么区别？我们怎么选CPU？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关内容的科普放在最前面：
笔记本CPU和台式机CPU区别：
https://blog.csdn.net/azj2019/article/details/105981673
CPU怎么选：（待更新）
不知道，你是否曾今存在过以下疑问：
CPU是什么？干什么的？
听则就听得多，但是他是干嘛的？
CPU就是芯片吗？芯片就是CPU吗？
手机CPU、电脑CPU都是一回事吗？是不同种类吗？
CPU种类这么多，有什么区别？
我知道这是很重要的东西，可是他是怎么做的，为什么中国造不出？
我们如何选择CPU？
当你阅读完本文，你这些疑惑都能解决了。我将会以通俗易懂的语言给你回答这些问题。（受篇幅长度限制，本文只解答CPU的基本知识，专业知识只给出超链接）
首先，什么是CPU呢？
名词解释：中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。
CPU包括运算逻辑部件、寄存器部件和控制部件等，英文Logic components；运算逻辑部件，可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。
其实简单的说，他就是大脑，一颗电子大脑。
通俗来讲，计算机的cpu就相当于人类的大脑，虽然不是主动指挥，但是通过遵循放置在计算机内存中的指令来实现指挥，其中包含指示它执行这些操作的代码。它也做算术运算，如加法，减法，乘法等，可以作出决定和选择。
我们常说cpu是手机，电脑等电子设备最重要的元件之一，在现实中我们很多用户都喜欢以CPU为标准来判断性能。我们使用电脑/手机之所以有声音，有图像，能运行微信让你愉快聊天，能运行游戏让你一展身手，我们使用的扫地机器人能走遍你家为你服务，这都是通过一个叫做CPU的芯片来完成的。如果你想更深入更准确的去了解，可以通过百度百科超链接继续深入了解。
目前我们使用的CPU是由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成。作为整个系统的核心，CPU也是整个系统最高的执行单元，因此CPU已成为决定性能的核心部件。（听不懂？没关系，知道什么都归他管，他很重要就行）
那么CPU就是我们平时说的芯片吗？
不是，CPU是芯片的一种，但芯片不一定就是CPU。用数学的包含关系来说，芯片包含CPU，但不等于。
CPU是超大规模的集成电路的一种，而集成电路都可以叫做芯片。如果说CPU是大脑，那么电子产品里面其他芯片就相当于小脑、脑干之类的，这个比喻不是很准确，反正就是负责内容不一样吧，有些芯片负责记忆，有些芯片负责升压降压（改变电源电压），而CPU只是相当于大脑思考的那部分，CPU不会记东西哦。（所以说电子产品里面有很多零配件，是很复杂的，一时半会儿我没办法全部讲清楚，等我慢慢更新完善吧。）
概念上不是一回事，但是口语中我们常说的芯片通常在指代CPU（因为他太重要了），很多电子设备中，主要的芯片，被叫做主控芯片=主芯抄片，往往都是CPU，或者是和CPU概念很类似的SoC，MCU。
也是因为这样，我们说华为能造芯片了指的也是麒麟芯片（CPU的一个“系列”，归属华为百分百控股的海思半导体公司）【注：华为能造其实与自产自销自足还远着，具体的我有时间会另外补充相关文章】
我们常说的AMD，英特尔，其实是造芯片的厂家（和海思一样）i5/i7/r7什么的都是产CPU的这些公司的一个系列罢了。
CPU种类那么多，怎么区分？
首先遇见最多的问题是，电脑CPU的问题了，因为很多小伙伴都是买电脑，手机的时候才会遇见CPU这个词。
笔记本CPU和台式机CPU区别（篇幅有限，请跳链接）https://blog.csdn.net/azj2019/article/details/105981673
想知道CPU种类，首先要知道CPU有一种核心的东西，叫做架构，看完你就知道手机CPU和电脑CPU是不是一样，能不能通用了。
【未完待续…】
附上一些知识超链接（我认为都是讲的很好的）
关于光刻机的视频链接：https://www.ixigua.com/i6840602212909974019/
在此视频里你可以知道DUV、EUV、光刻机、为什么中国光刻机落后、光刻机技术难点在哪、为啥光刻机这么难搞？ 为什么说光刻机是人类智慧的结晶？ 中国又应该怎么办？
【未完待续…】
【未完待续…】
【未完待续…】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22dcc090c8f6703986cc6731c0770a9/" rel="bookmark">
			如何正确理解分布式系统的CAP定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。
要进一步理解定义，首选要建立的大前提是：客户端对分布式系统中的任意存活节点的访问，这里的存活是指节点是运行中的而不是崩溃/下线的。
一致性Consistency，它的要求无论访问任何节点，得到的结果要么都是一样的，要么被拒绝。
可用性Availability，它的要求无论访问任何节点，接口都是可用的，但不一定每个节点的结果都一样。
分区容错性Partition tolerance，这一项是分布式系统的特征，它要求当发生网络问题时，该分布式系统能够自我的修复依然形成分布式状态具有高可用特性。
为什么只能实现两点，我们以不同的分布式系统为例进行说明。
只能实现CP：典型系统Zookeeper 我们假设有5个节点组成的zk集群正在正常的为各个Client提供服务
然后在某个时间段发生网络问题，由于Zookeeper具有P特性，将会重新选举Leader形成新的集群，我们假设有3个节点组成了新集群，有2个节点不幸由于网络不畅通无法组进来
新的集群继续为Client提供服务，而红色节点由于脱离了集群，他们的数据将无法保持与集群一致，因此原本与这些节点通讯的Client将会被拒绝。
由此理解CAP我们可以看到Zookeeper是分布式系统，它首先具有P，另外当发生网络分区时，它承诺的是C，这必将要求脱离集群的节点不再提供服务，所以既然承诺了C就必定不能再具有A。
只能实现AP：典型系统Eureka 理解了CP的Zookeeper，要理解AP为什么不能实现C也就自然了。
Eureka在部署上我们继续参考上述zk集群
Eureka也具有P，当发生网络分区时，它承诺的是A，即客户端访问脱离集群的节点时依然提供服务，但可想而知黄色节点的数据将无法与新的集群保持一致，因此它是无法保障C特性的。
至于Eureka为什么选择容忍数据的不一致，跟注册中心的使用特点有关系，Eureka认为就注册中心这个场景上集群的整体可用性比服务注册列表数据的一致性更重要，各有各的需求和理解吧。
只能实现CA：典型系统Mysql 有没有没有P的系统，有，单机系统就是，例如Mysql。
有人说Mysql可以主备高可用啊，怎么是单机了？原因有多个。主备模式Client不能与任意Mysql节点进行读写；主备模式不是集群模式，出现故障时无法自我的组成新集群。是的，因为Mysql不是天然的分布式系统。
所以Mysql这样的系统，没有了P，就一定成为了CA，因为单机要么提供一致的可用的服务，要么崩溃/下线。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38e94c44606b2fc1dbef6769487edf6/" rel="bookmark">
			怎么用C语言在屏幕上打印数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
char arr1[] = { "jin tian ye yao jia you a cheng jia jia" };
char arr2[] = { "#########################################" };
int left = 0;
int right = strlen(arr1) - 1;
while (left &lt;= right)
{
arr2[left] = arr1[left];
arr2[right] = arr1[right];
printf("%s\n",arr2);
Sleep(1000); //睡眠一秒；
system("cls"); //清空屏幕；
left++;
right--;
}
printf("%s\n", arr2);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4b4ddae4fa3300951629058299a5d5/" rel="bookmark">
			Mysql时间查询 昨天、今天、上月、本月...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为 【MySQl】 关于时间的查询
📌博主主页：一个肥鲇鱼
👉策略模式之Map+函数式接口：策略模式之Map+函数式接口
👉感受 Lambda 之美：体验一下Lambda之美吧，优雅编程
👉Bean转换工具：Mapstruct使用教程
查询最近一分钟的所有记录 SELECT * FROM table_name WHERE date_column &gt;= DATE_SUB(NOW(), INTERVAL 1 MINUTE); 查询最近一小时的所有记录 SELECT * FROM table_name WHERE date_column &gt;= DATE_SUB(NOW(), INTERVAL 1 HOUR); 解释：DATE_SUB函数是MySQL中的一个日期函数，用于在指定的日期上减去一定的时间间隔，返回计算后的日期。
其语法为：DATE_SUB(date, INTERVAL value unit)，其中date表示要进行计算的日期，value表示要减去的时间间隔，unit表示时间间隔的单位（如YEAR、MONTH、DAY、HOUR、MINUTE、SECOND等）。
查询昨天的SQL SELECT * FROM table_name WHERE DATE(date_column) = DATE_SUB(CURDATE(), INTERVAL 1 DAY); 解释：这条SQL语句使用了DATE_SUB函数，它用于从当前日期中减去指定的时间间隔。在这个例子中，我们使用了INTERVAL 1 DAY，这意味着我们要从当前日期中减去1天，以查询昨天的数据。DATE函数用于将日期列的时间戳截断为日期部分，以便与DATE_SUB函数返回的日期部分进行比较。
查询今天的SQL SELECT * FROM table_name WHERE DATE(date_column) = CURDATE(); 解释：这条SQL语句使用CURDATE函数，它返回当前日期。我们使用它来查询今天的数据。DATE函数用于将日期列的时间戳截断为日期部分，以便与CURDATE函数返回的日期部分进行比较。
查询上个月的SQL SELECT * FROM table_name WHERE DATE_FORMAT(date_column, '%Y-%m') = DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 1 MONTH), '%Y-%m'); 解释：这条SQL语句使用了DATE_FORMAT函数，它用于将日期列的时间戳格式化为指定的日期格式。在这个例子中，我们使用了'%Y-%m'格式，它将日期格式化为年份和月份。我们使用了DATE_SUB函数来减去1个月的时间间隔，然后将其格式化为'%Y-%m'，以便与日期列的格式进行比较。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e4b4ddae4fa3300951629058299a5d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00320c13cdcde5ab339e53cb91a1c822/" rel="bookmark">
			Spring Cloud子项目和版本选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud是基于SpringBoot的一整套实现微服务的框架，它跟SpringBoot框架一起使用的话，会让你开发微服务架构的云服务非常好的方便。那SpringCloud子项目包括哪些：
一、Spring Cloud子项目 Spring Cloud Config：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。
Spring Cloud Bus：事件、消息总线，用于在集群(例如，配置变化事件)中传播状态变化，可与Spring Cloud Config联合实现热部署。
Spring Cloud Netflix：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。
Netflix Eureka：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。
Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。
Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。
Netflix Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。
Spring Cloud for Cloud Foundry：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。
Spring Cloud Sleuth：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。
Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。
Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。
Spring Cloud Consul：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。
Spring Cloud Zookeeper：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。
Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。
Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。
二、SpringCloud的版本选择 在使用 Spring Boot + Spring Cloud 进行微服务开发时，我们需要根据项目中 Spring Boot 的版本来决定 Spring Cloud 版本，否则会出现许多意想不到的错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00320c13cdcde5ab339e53cb91a1c822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ac8177a906eb99f4b1169b712ea18c/" rel="bookmark">
			【C语言】一些库函数的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些较为常见的库函数 0.前言1.求字符串长度strlen 2. 长度不受限制的字符串函数strcpystrcatstrcmp 3. 长度受限制的字符串函数介绍strncpystrncatstrncmp 4. 字符串查找strstr 5. 字符串截断strtok 6. 错误信息报告strerror 字符操作is****7. 内存操作函数7.1 memcpy7.2 memmove7.3 memcmp7.4 memset 0.前言 如果觉得这篇博客不错的话，点个赞再走吧😊
这篇博客主要讲的是一些较为常见且实用的字符串函数。
C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在常量字符串中或者字符数组中。
字符串常量 适用于那些对它不做修改的字符串函数.
int main() { //字符数组 char arr[] = "asdfghh"; //常量字符串 char* p = "asdfghh"; return 0; } 1.求字符串长度 strlen 1.1 函数介绍
strlen
size_t strlen ( const char * str ); 这个函数非常常见，就是求一下字符串的长度。
从第一个字符开始计数，只要找到’\0’就停止计数。
int main() { char arr[] = "abcd"; printf("%d\n", strlen(arr));//结果为4 return 0; } 1.2 注意事项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ac8177a906eb99f4b1169b712ea18c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497f04aabf1fe4398311234a102a7e62/" rel="bookmark">
			Mysql-binlog的查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 简介 MySQL的二进制日志可以说是MySQL最重要的日志了，它记录了所有的DDL和DML(除了数据查询语句)语句，以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。一般来说开启二进制日志大概会有1%的性能损耗(参见MySQL官方中文手册 5.1.24版)。二进制有两个最重要的使用场景:
其一：MySQL Replication在Master端开启binlog，Mster把它的二进制日志传递给slaves来达到master-slave数据一致的目的。
其二：自然就是数据恢复了，通过使用mysqlbinlog工具来使恢复数据。
binlog日志概念 binlog全称为:binary，翻译就是二进制文件，主要记录了MySQL在进行DML（数据操作语言）过程中的操作日志。在执行SQL语句的过程中，作为使用者，无需关注程序执行的过程，但是当数据库数据丢失，或者需要搭建数据库主从复制时，则此时的binlog日志文件的重要性就展现出来了。
二进制日志包括两类文件：二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件，二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。
binlog本身是一类二进制文件。二进制文件更省空间，写入速度更快，是无法直接打开来查看的。
因此mysql提供了命令mysqlbinlog进行查看。
一般的statement格式的二进制文件，用下面命令就可以（后面会讲到什么是statement格式）
mysqlbinlog mysql-bin.000001 如果是row格式，加上-v或者-vv参数就行，如
mysqlbinlog -vv mysql-bin.000001 使用场景 以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。
MySQL主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到master-slave数据一致的目的数据恢复：通过使用 mysqlbinlog工具来使恢复数据查看数据更改记录 数据库操作类型： 在对数据库的日常操作中，MySQL的操作语法，经常使用的几种MySQL指令类型如下
DQL：数据查询语言，例如 where 、group by 、 orderby
DML：数据操作语言，例如 insert、delete、update等
DPL：事务处理语言，例如begin transaction、commit、rollback
DCL：数据控制语言，例如grant 、revoke控制用户访问权限等
DDL：数据定义语言，例如create、drop删除表、索引添加类等
binlog三种模式 format定义优点缺点statem ent记录的是修改SQL语句日志文件小，节约I0，提高性能准确性差，对一些系统函数不能准确复制或不能复制，如now0.uuid0等row记录的是每行实际数据的变更准确性强，能准确复制数据的变更日志文件大，较大的网络10和磁盘lOmixedstatement和row模式的混合准确性强，文件大小适中有可能发生主从不一致问题 业内目前推荐使用的是row模式，准确性高，虽然说文件大，但是现在有SSD和万兆光纤网络，这些磁盘IO和网络IO都是可以接受的。
那么，大家一定想问，为什么不推荐使用mixed模式，理由如下
假设master有两条记录，而slave只有一条记录。
master的数据为
+----+------------------------------------------------------+ | id | n | +----+------------------------------------------------------+ | 1 | d24c2c7e-430b-11e7-bf1b-00155d016710 | | 2 | ddd | +----+------------------------------------------------------+ slave的数据为
+----+-------------------------------------------------------+ | id | n | +----+-------------------------------------------------------+ | 1 | d24c2c7e-430b-11e7-bf1b-00155d016710 | +----+-------------------------------------------------------+ 当在master上更新一条从库不存在的记录时，也就是id=2的记录，你会发现master是可以执行成功的。而slave拿到这个SQL后，也会照常执行，不报任何异常，只是更新操作不影响行数而已。并且你执行命令show slave status，查看输出，你会发现没有异常。但是，如果你是row模式，由于这行根本不存在，是会报1062错误的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/497f04aabf1fe4398311234a102a7e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2243d4290d983b51eb3852afafcc8fb/" rel="bookmark">
			【Python基础-00】Anaconda给Python安装模块（包/库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0 前期准备1 通过pip安装模块 0 前期准备 在练习python前先使用Anaconda新建一个环境，并且使用PyCharm新建一个项目
（1）使用Anaconda新建环境ClassfiedProtection。
打开Anaconda。在开始菜单找到刚刚安装好的Anaconda，右键以管理员方式运行。新建环境。新建一个环境，命名为ClassfiedProtection。该步骤也可以在系统终端cmd窗口采用命令完成。
(2)为环境ClassfiedProtection更换镜像源。由于默认的镜像源是国外的，下载速度较慢。点击此处并进一步点击 open Teminal，进入终端配置窗口
查看目前你的conda源的情况， # 首先，看一下目前conda源都有哪些内容 conda info 执行如下几条命令更换国内常用的镜像源 conda config --add channels https://repo.huaweicloud.com/repository/pypi/simple/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 1 通过pip安装模块 （1）在上述的Teminal终端配置窗口，输入命令conda list查看当前环境所安装的模块有哪些。可以看到有安装了pip模块，可以进一步试用pip命令进行相关模块的安装。
（2）使用命令pip install --upgrade pip更新一波pip版本，如果弹出以下错误提示，则按照提示输入python.exe -m pip install --upgrade pip。
（3）继续使用pip命令安装相关模块。
pip install numpy pip install matplotlib pip install Pillow pip install scikit-learn #基于Python 语言的机器学习工具 pip install pandas pip --default-timeout=1000 install numpy	#如果网络不好经常断开，可以试试该命令设置断开链接的时间 （4）若安装模块的过程中，出现如下错误提示，在下载命令后增加如下代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2243d4290d983b51eb3852afafcc8fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cecee303c0d5090a3a30e996b522806a/" rel="bookmark">
			可重入函数，线程安全函数与异步信号安全函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.jianshu.com/p/b5200248f0f5
Reentrancy、Thread-safe、Async-signal-safe
以前写C代码，多核多线程下时，要注意函数的可重入性，保证线程安全， 即多个线程同时调用到此函数，其结果是可预期的（固定输入，固定输出），全局变量的使用需要注意加锁，线程函数中写操作必须要加锁，读操作则看实际情况来定，如果能确认业务整体逻辑上能保证写和读是有严格时序的，不需要对读进行加锁（比如写只在模块最开始初始化时完成，其他地方只是使用，不会修改，则可以读取时不需要锁）。
源于《Unix系统高级编程》一书中12.6章节示例结尾点评部分提到示例函数虽然是线程安全的，但因为调用了malloc函数，不是异步信号安全（Async-signal-safe）的，不能在信号处理句柄中使用，对此很是不解，一番搜索查询，才有所明白。
示例函数如下
char * getenv(const char *name) { int i, len; char *envbuf; pthread_once(&amp;init_done, thread_init); pthread_mutex_lock(&amp;env_mutex); envbuf = (char *)pthread_getspecific(key); if (envbuf == NULL) { envbuf = malloc(MAXSTRINGSZ); if (envbuf == NULL) { pthread_mutex_unlock(&amp;env_mutex); return(NULL); } pthread_setspecific(key, envbuf); } len = strlen(name); for (i = 0; environ[i] != NULL; i++) { if ((strncmp(name, environ[i], len) == 0) &amp;&amp; (environ[i][len] == ’=’)) { strncpy(envbuf, &amp;environ[i][len+1], MAXSTRINGSZ-1); pthread_mutex_unlock(&amp;env_mutex); return(envbuf); } } pthread_mutex_unlock(&amp;env_mutex); return(NULL); } Note that although this version of getenv is thread-safe, it is not async-signal safe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cecee303c0d5090a3a30e996b522806a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a8dec42e92c8fb3c4f813c63433f25/" rel="bookmark">
			Virtual memory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 A technique where secondary storage is used to extend the memory available temporarily.It is used to make CPU appear to access more memory space than available.Data in use can be swapped between RAM and virtual memory. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893c40073a902ff67de7d2d136c24c5e/" rel="bookmark">
			IDEA 自定义容器 &#43;Docker打包部署，一套带走
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要内容如下：
目录
一、背景 Docker打包部署方案
项目背景：新项目的后端框架是刚起步，搭建的是一套微服务框架，基础服务有网关 Gateway， Nacos 注册中心，以及其他的微服务。现在需要弄个简单且方便的，基于 Docker 的部署方式。
为什么用 Docker：为了让后端程序更容易打包部署和管理，所以用上了 Docker 容器化部署。比如用 Docker Swarm 或 K8s 来管理多个容器。
为什么要提到 Windows：本地机器是 Windows 系统开发，通过 Windows + IDEA 将应用程序打成 Docker 镜像，然后拷贝到 Linux 服务器进行容器化部署。
疑问1：有同学可能会有疑问，Windows 还能跑 Docker 吗？？？那必须的！
疑问2：如果项目的代码改了，是不是得重新打包 docker 镜像？不需要，直接替换 docker volume 里面的 JAR 包即可。
疑问3：怎么没有用 Jenkins？新项目，新项目，牛奶和面包都会有的。
二、Windows 运行 Docker 2.1 原理 为了在 Windows 能够打包 Docker 镜像，就必须弄个可以运行 Docker 的环境。
Docker 依赖于已存在并运行的 Linux 内核环境。实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。
如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/893c40073a902ff67de7d2d136c24c5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8161c55eaecb5d5fbc097fb4d1f258d/" rel="bookmark">
			coredump详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://blog.51cto.com/u_15471709/4868198
一，什么是coredump 我们经常听到大家说到程序core掉了，需要定位解决，这里说的大部分是指对应程序由于各种异常或者bug导致在运行过程中异常退出或者中止，并且在满足一定条件下（这里为什么说需要满足一定的条件呢？下面会分析）会产生一个叫做core的文件。
通常情况下，core文件会包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，我们可以理解为是程序工作当前状态存储生成第一个文件，许多的程序出错的时候都会产生一个core文件，通过工具分析这个文件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题所在并进行及时解决。
二，coredump文件的存储位置 core文件默认的存储位置与对应的可执行程序在同一目录下，文件名是core，大家可以通过下面的命令看到core文件的存在位置：
cat /proc/sys/kernel/core_pattern 缺省值是core
注意：这里是指在进程当前工作目录的下创建。通常与程序在相同的路径下。但如果程序中调用了chdir函数，则有可能改变了当前工作目录。这时core文件创建在chdir指定的路径下。有好多程序崩溃了，我们却找不到core文件放在什么位置。和chdir函数就有关系。当然程序崩溃了不一定都产生 core文件。
如下程序代码：则会把生成的core文件存储在/data/coredump/wd，而不是大家认为的跟可执行文件在同一目录。
通过下面的命令可以更改coredump文件的存储位置，若你希望把core文件生成到/data/coredump/core目录下：
echo “/data/coredump/core”&gt; /proc/sys/kernel/core_pattern 注意，这里当前用户必须具有对/proc/sys/kernel/core_pattern的写权限。
缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。很显然，如果有多个程序产生core文件，或者同一个程序多次崩溃，就会重复覆盖同一个core文件，因此我们有必要对不同程序生成的core文件进行分别命名。
我们通过修改kernel的参数，可以指定内核所生成的coredump文件的文件名。例如，使用下面的命令使kernel生成名字为core.filename.pid格式的core dump文件：
echo “/data/coredump/core.%e.%p” &gt;/proc/sys/kernel/core_pattern 这样配置后，产生的core文件中将带有崩溃的程序名、以及它的进程ID。上面的%e和%p会被替换成程序文件名以及进程ID。
如果在上述文件名中包含目录分隔符“/”，那么所生成的core文件将会被放到指定的目录中。 需要说明的是，在内核中还有一个与coredump相关的设置，就是/proc/sys/kernel/core_uses_pid。如果这个文件的内容被配置成1，那么即使core_pattern中没有设置%p，最后生成的core dump文件名仍会加上进程ID。
三，如何判断一个文件是coredump文件？ 在类unix系统下，coredump文件本身主要的格式也是ELF格式，因此，我们可以通过readelf命令进行判断。
可以看到ELF文件头的Type字段的类型是：CORE (Core file)
可以通过简单的file命令进行快速判断：
四，产生coredum的一些条件总结 1. 产生coredump的条件 首先需要确认当前会话的ulimit –c，若为0，则不会产生对应的coredump，需要进行修改和设置。
ulimit -c unlimited (可以产生coredump且不受大小限制) 若想甚至对应的字符大小，则可以指定：
ulimit –c [size] 可以看出，这里的size的单位是blocks,一般1block=512bytes
如：ulimit –c 4 (注意，这里的size如果太小，则可能不会产生对应的core文件，笔者设置过ulimit –c 1的时候，系统并不生成core文件，并尝试了1，2，3均无法产生core，至少需要4才生成core文件)
但当前设置的ulimit只对当前会话有效，若想系统均有效，则需要进行如下设置：
/etc/profile中加入以下一行，这将允许生成coredump文件
ulimit-c unlimited在rc.local中加入以下一行，这将使程序崩溃时生成的coredump文件位于/data/coredump/目录下:
echo /data/coredump/core.%e.%p&gt; /proc/sys/kernel/core_pattern 注意rc.local在不同的环境，存储的目录可能不同，su下可能在/etc/rc.d/rc.local
更多ulimit的命令使用，可以参考：​ ​https://baike.baidu.com/item/ulimit
这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的ulimit命令, 来设置core大小为无限.
2. 当前用户，即执行对应程序的用户具有对写入core目录的写权限以及有足够的空间。 3. 几种不会产生core文件的情况说明： The core file will not be generated if
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8161c55eaecb5d5fbc097fb4d1f258d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5affa2cac2438bec913e40955610d6d/" rel="bookmark">
			平面离散点集Delaunay三角化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 定义：准则：特性：算法：1.逐点插入法2.分治算法3.生长算法 对比：参考： 定义： 在数学和计算几何中，三角化就是对于给定的平面中的离散点集P，生成三角形集合T的过程。一般来说给定一个点集，往往存在不止一个三角剖分。其中基于 Delaunay 准则的三角化是一种特殊的三角化，也叫 Delaunay三角化。
准则： 空圆性：任何一个三角形的外接圆内部都不包含点集中的顶点。最大化最小角：三角形的最小角（所有三角形的内角中的最小值）最大。具体的说是在两个相邻的三角形构成凸四边形的对角线，在相互交换后，两个内角的最小角不再增大。 特性： 最接近：以最接近的三点形成三角形，且各线段（三角形的边）皆不相交。唯一性：不论从区域何处开始构建，最终都将得到一致的结果（点集中任意四点不能共圆）。最优性：任意两个相邻三角形构成的凸四边形的对角线如果可以互换的话，那么两个三角形六个内角中最小角度不会变化。最规则：如果将三角剖分中的每个三角形的最小角进行升序排列，则 Delaunay 三角剖分的排列得到的数值最大。区域性：新增、删除、移动某一个顶点只会影响邻近的三角形。具有凸边形的外壳：三角剖分最外层的边界形成一个凸多边形的外壳。 算法： Delaunay定理由俄国数学家Delaunay提出，使用该准则进行剖分得到的三角网格叫作Delaunay三角网格。Delaunay网格的空外接圆特性和最小内角最大的特性决定了Delaunay网格是网格化质量最好的网格。
​ 关于二维点集的Delaunay三角化算法，有逐点插入法、三角网生长法和分治法以及隶属于3类方法的各种不同实现算法。
1.逐点插入法 Lawson算法是一种基于点插入的Delaunay三角剖分算法。该算法通过不断地向剖分中加入点，来逐步构建整个Delaunay三角剖分。Lawson算法中的局部优化过程（LOP：Local Optimization Procedure）是逐点插入法的关键，局部优化过程的思路是，如果一个三角形不符合Delaunay三角剖分的规则，则将一个包含一对三角形的四边形的对角线对换，从而构成符合Delaunay三角剖分的新三角形。简单来说，Lawson算法通过不断地将剖分中非Delaunay边上的点进行“翻转”，使得该边成为Delaunay边，直到所有边都是Delaunay边为止。
该算法基于散点的构网算法理论严密、唯一性好，网格满足空圆特性，是一种比较理想的算法。其逐点插入的构网过程中如果遇到非Delaunay边时，可以通过删除调整，进而构造形成新的Delaunay边。在完成构网后，增加新点时，无需对所有的点进行重新构网，只需对新点的影响三角形范围进行局部构网。但是在实际应用当中，点集数量较大，分布复杂时构网速度较慢，而且对于区域为非凸，存在内环时，则会产生非法三角形。
2.分治算法 分治思想（Divide-and-Conquer）的Delaunay三角网构建算法由Lewis和Robinson提出，后由Lee和Schachter改进。Delaunay三角网分治算法的主要思想就是递归地将点集进行划分为多个子集，当每个子点集的点云数量被划分到一定程度时生成三角网格，通过递归的过程将不同三角网进行向上合并，最终得到一个完整的三角网。不同Delaunay三角网分治算法的实现差别往往体现在如何对数据划分进行。基于分治的Delaunay三角网生成算法，在最坏情况下的时间复杂度为O(nlogn)，在处理同样数量的点云数据的时候，分治的Delaunay三角网生成算法的时间复杂度最小，相对的，因为Delaunay三角网分治算法需要进行大量的递归，需要大量的内存。对于处理大规模的点云数据可能会因为内存空间问题而影响Delaunay三角网分治算法的使用。
3.生长算法 三角形生长算法最早是由Green和Sibson提出，算法的主要思想是以点集中任意一个点开始，寻找与该点欧式距离最小的点构成一条边，根据最大最小角的原则寻找另一个点构成三角形，不断选择新的点与三角形的边构成新的三角形，使三角形的区域不断扩大，知道点集中所有的点都被并入三角网中。由于三角形生长算法需要为三角形的边寻找符合条件的点构成新的三角形，需要遍历点集中的点，往往需要消耗很多时间寻找点。因此，三角形生长法很难达到线性时间，如果点集分布不平均，最坏情况下时间复杂度为O(n2)。
对比： 三角网生成法的时间效率最低，分治算法的时间效率最高，逐点插入法效率居中。由于区域生长法本质的缺陷，导致其效率受限，这种方法在80年代中期以后已经很少使用。分治算法时间效率相对较高，但是由于其递归执行，所以需要较大的内存空间，导致其空间效率较低。此外，分治法的数据处理及结果的优化需要的工作量也比较大。逐点插入算法实现简单，时间效率比较高，而运行占用的空间也较小，从时间效率和空间效率综合考虑，性价比最高，因而应用广泛。
​ 逐点插入算法最坏情况下的时间复杂度是O(N2)。但是，若点是随机插入的话，其性能将能达到O(NlogN)。但由于算法过程需要排序，其时间复杂度不能进一步改进。生长算法的效率最差，最坏情况下的时间复杂度为O(N2 )，性能最高也只能达到O(N3/2)。分治算法的效率很高，最坏情况下的时间复杂度都能达到O(NlogN)，最好情况下其性能甚至能达到O(loglogN)，同时输入点集对分治算法的效率影响较小，无论输入点集好坏都不会对分治算法的效率产生明显影响。3类方法各自典型的实现算法的时间复杂度如下表：
表1 几种Denauhy三角网生成算法的时间复杂度[1] 参考： [1] Chuang T , 陶闯. A Comparative Research on Methods of Delaunay TriangulationDelaunay三角网构建方法比较研究[J]. 中国图象图形学报, 1995, 15(8):1158-1167.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36880397a10c0e62364eddc8aa1afe9/" rel="bookmark">
			MySQL调优分析篇1(SHOW PROFILES)：SQL语句效率分析实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文章中，使用的是最新的 MySQL 8.0.32，采用主从架构。(未实现读写分离)
Step1：创建表结构。 首先，设计一个用户信息表作为调优案例表。
表结构如下图：
索引：
1、主键：user_id 规则：自增
其他字段见注释。
Step2：使用Navicat16自带的数据生成工具，生成模拟数据。 这里，我们先生成5w条测试数据。
数据内容如下图所示：
从上图来看，该工具可以支持多种随机格式的数据生成。
1、序列：自增序列。
2、数字：先设定一个数值范围，工具会随机生成范围内的数字。
3、姓名：工具提供的姓名生成器(来自工具中的姓名库)，包括中文、英文、日本语三种姓名。
4、正则表达式：支持根据用户输入的正则表达式去生成数据。
5、电子邮箱：先指定域，例如：gmail.com; qq.com; 163.com;等，即可生成邮箱。
6、日期时间：设定开始日期和结束日期(yyyy:MM:dd HH:mm:ss)，可以规定只生成星期几，也可以只生成工作日等。
生成好的数据如下图所示：
Step3：测试5w数据量的全表查询效率。 1、首先，通过命令行进入到MySQL，开启MySQL的Profiles分析。
SET profiling = 1; 2、执行SQL语句。
SELECT * FROM sys_user_base_info; 执行完SQL，我们可以看到，MySQL给出的提示是：该语句执行了0.07秒。
如下图：
3、查看Profiles分析记录。
SHOW PROFILES; 执行上面的SQL语句后，MySQL会给我们展示当前会话中，所有的查询用时。这里展示出：上一次查询的实际耗时为 0.0687375秒 。
如下图：
4、查看具体的执行步骤和耗时。
这里使用SHOW PROFILE语句，查看本次查询的详细耗时。
SHOW PROFILE cpu,block io FOR QUERY 1; 其中：最后面的 1 是需要查看的SQL语句的Query_ID（上图中），而 cpu,block io 为SHOW PROFILE语句的固定参数，其他参数放到了本文末尾的位置，大家到最后可以深入了解一下。这里我们只查询 块IO信息、CPU相关信息 作为示例。
查询结果如下图：
返回结果的含义：
Status：SQL语句执行的状态信息
Duration：每个步骤的耗时
CPU_user：当前用户占用CPU的时间
CPU_system：系统占用CPU的时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36880397a10c0e62364eddc8aa1afe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a18339a6d6073d2841aa3733604bd72/" rel="bookmark">
			2023首届大学生算法大赛 - 幸运数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 根据题目所给，整数N最大达到了10^12，而C++默认1s的运算量只有10^8，所以这道题用for从1开始暴力到N肯定行不通（在蓝桥杯说不定能拿点分）。
那我们换一个思路，直接去枚举所有可行的幸运数字。
要枚举的数字，每位上都可以是（8，2，6，9），如果有两位数，最多有4*4种情况，三位数就是4*4*4，N&lt;10^12，易得最多12位，复杂度最大4^12，大约一千万的计算量，小于一个亿。
所以直接一个深搜就可以解决这道题。
约束条件：1、（8，2，6，9）每个都至少有一个
2、枚举出来的数要小于输入的N
解空间树：
然后根据解空间树写递归就可以了。
AC代码
#include &lt;bits/stdc++.h&gt; #define int long long using namespace std; int n,vis[10],ans; void dfs(int now){ if(now&gt;n)return; if(now&lt;=n and vis[8] and vis[2] and vis[6] and vis[9])ans++; vis[8]++; dfs(now*10+8); vis[8]--; vis[2]++; dfs(now*10+2); vis[2]--; vis[6]++; dfs(now*10+6); vis[6]--; vis[9]++; dfs(now*10+9); vis[9]--; } signed main(){ cin&gt;&gt;n; dfs(0); cout&lt;&lt;ans; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f5bc62e28d0bc1c825697027a83e2b/" rel="bookmark">
			__raw_writel, writel_relaxed 和 writel的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为对别的平台不了解，下面仅谈它们在ARM上的区别
__raw_writel： 因为有volatile关键字， 所以编译器不会打乱多个__raw_writel的执行顺序。
对于ARM而言，当多个写以代码的顺序到达相同设备时，执行的顺序也是被保证的，不过
对于不同的设备，执行的顺序就不被保证了。
write_relaxed： 在ARM平台上与__raw_writel一样，因为与__raw_writel相比，它只多做
了一个大端到小端转换。
writel： 当CONFIG_ARM_DMA_MEM_BUFFERABLE被定义时，在写之前，它会多做
一个DSB和L2的sync。 为什么需要这样呢？ 因为，DMA buffer都是 bufferable了，
（详见加入CONFIG_ARM_DMA_MEM_BUFFERABLE的commit log）
在DMA进行之前要保证write buffer里的数据都到memory里。
所以说： 只有在有DMA操作的代码里，writel才是必须的，其实它是一个
当DMA buffer变成bufferable之后的一个补充品。因为要保证DMA buffer里的
内容在DMA开始之前都到memory里，所以开始DMA的指令(writel)里加了
sync memory的指令。
其实： writel也不能保证写的东西一定完成，它只能保证写的指令或写的内容
已经到了设备端，但具体有没有写完成是不知道的。如果有一定要设备端
写完成才能做下面的指令的要求，最好再用readl把它读回来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/190ccff9dac51fb7d3aee980e52dacd9/" rel="bookmark">
			rpmsg 内核开发 用户层接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地址：https://blog.csdn.net/thisway_diy/article/details/129195479
韦东山
Tina Linux E907开发指南
AMP 环境搭建
7.1 rpmsg 内核开发
7.2 rpmsg 用户层接口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cecb69529341d1427486f6aeb54d37d1/" rel="bookmark">
			ubuntu编译报错及解决办法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
错误描述1： Could not find a package configuration file provided by "Pangolin" with anyof the following names:PangolinConfig.cmake
错误描述2：fatal error: Eigen/Core: 没有那个文件或目录
错误描述3： nvcc fatal : Unsupported gpu architecture 'compute_30'：
错误描述4：Error: invalid texture reference: /home/y/SLAM/ElasticFusion-master/Core/src/Cuda/convenience.cuh:68
错误描述5：make: *** 没有规则可以创建“/usr/lib/x86_64-linux-gnu/libGL.so”需要的目标“XXXX”。 停止
错误描述6：X Error of failed request: BadShmSeg (invalid shared segment parameter)
错误描述7： "/usr/lib/cmake/vtk-6.3/VTKTargets.cmake" but not all the files it references.
错误描述1： Could not find a package configuration file provided by "Pangolin" with anyof the following names:PangolinConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cecb69529341d1427486f6aeb54d37d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a804a68c1b4ecb6ae726a361f4d85edd/" rel="bookmark">
			el-table多选toggleRowSelection不生效?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做弹窗里有个表格多选时，经常遇到再次打开弹窗，已选值赋值不上的问题，这里简单记录一下解决方案。
element官方提供的例子经常是有各种问题的，这里经常是toggleSelection不生效
toggleRowSelection是用来控制table表格选择框回显的方法，这个方法有两个参数toggleRowSelection(item, true)，第一个参数是你准备回显哪一项，也就是表格对应的哪一行，第二个就是那个勾勾，true就是勾选上。
一般遇到的业务是，第一次打开选中了，然后有个列表回显选中的值，再有个编辑，点编辑回显选中的，然后就会遇到选中不生效的问题…
直接上解决方案：
1、赋值前先清空值clearSelection()
2、在DOM节点更新后再进行赋值，这里使用nextTick
3、进行赋值渲染选中toggleRowSelection(item, true)
// 我这里是用的el-dialog弹窗里的，所以在@open事件中处理 onOpen () { const TABLE_DOM = this.$refs.multipleTable const { optCoupons } = this if (TABLE_DOM) { TABLE_DOM.clearSelection() this.$nextTick(_ =&gt; { optCoupons.forEach(item =&gt; { TABLE_DOM.toggleRowSelection(item, true) }) }) } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e65a06e68040deaaefd85f9e93f6df/" rel="bookmark">
			【已解决】在vue中引入echart的折线图时，echarts.graphic.LinearGradient报错，不能正常显示。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue中需要用到折线图，且有区域渐变色的效果，那么像下面那样子直接复制过来，在vue中不能渲染出来。
需要将原来的 new echarts.graphic.LinearGradient 改成这样，new this.$echarts.graphic.LinearGradient
报错 错误代码 //自定义环形图颜色 color: [ new echarts.graphic.LinearGradient(0, 0, 0, 1, [ { offset: 0, color: "#4494F5" }, { offset: 1, color: "#08DDF2 " } ]), new echarts.graphic.LinearGradient(0, 0, 0, 1, [ { offset: 1, color: "#08DDF280" }, { offset: 0, color: "#3D9CF580" }, ]), ], 修改后 color: [ new this.$echarts.graphic.LinearGradient(0, 0, 0, 1, [ { offset: 0, color: "#4494F5" }, { offset: 1, color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36e65a06e68040deaaefd85f9e93f6df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca60e12f680063a46106ba658eba6516/" rel="bookmark">
			git笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.拉取代码 git clone url 2.提交代码 git init git add . git status # 查看一提交的代码 git commit -m "说明" git pull # 拉取 git push # 提交 3.详细的git命令 提交部分修改了的代码
git status git add . | git add 'src' git commit -m 'xxx' git pull | git pull origin '分支名' git push | git push origin '分支名' 提交部分修改了的代码
git status -s git add 'xxx' git stash -u -k git commit -m '提交信息' git pull git push git stash pop 已经commit还未push时，撤销commit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca60e12f680063a46106ba658eba6516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0135a4875cb564e29b645353b296d437/" rel="bookmark">
			SQL Server | 设置默认值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、建表时设置默认值
Create table Sys_User ( Id int primary key identity, Name nvarchar(50), Gender char(2) default '男', CreationTime datetime default getdate() ) -- 添加一条测试数据 Insert into Sys_User(Name) values('admin') 结果如下所示：
2、已经存在的表设置默认值
alter table [表名] add default(默认值) for [列名]; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481927dcfc3d9e36170478a68b68a173/" rel="bookmark">
			JVM 类的加载过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 类的生命周期2 类加载过程2.1 加载2.2 验证2.3 准备2.4 解析2.5 初始化 3 类卸载 1 类的生命周期 类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，前三个阶段可以统称为连接（Linking）。
2 类加载过程 系统加载Class文件的三步：加载-&gt;链接-&gt;初始化。链接过程又可分为三步：验证-&gt;准备-&gt;解析
2.1 加载 类加载过程的第一步，主要完成下面 3 件事情：
通过全类名获取定义此类的二进制字节流。将字节流所代表的静态存储结构转换为方法区的运行时数据结构。在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。 加载这一步主要是通过我们后面要讲到的 类加载器 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 双亲委派模型 决定（不过，我们也能打破由双亲委派模型）。
每个 Java 类都有一个引用指向加载它的 ClassLoader。不过，数组类不是通过 ClassLoader 创建的，而是 JVM 在需要的时候自动创建的，数组类通过getClassLoader()方法获取 ClassLoader 的时候和该数组的元素类型的 ClassLoader 是一致的。
加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。
2.2 验证 验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。
验证阶段主要由四个检验阶段组成：
文件格式验证（Class 文件格式检查）元数据验证（字节码语义检查）字节码验证（程序语义检查）符号引用验证（类的正确性检查） 符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候。符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常
2.3 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 static 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。从概念上讲，类变量所使用的内存都应当在 方法区 中进行分配。除了字符串常量池分配在堆中这里所设置的初始值"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481927dcfc3d9e36170478a68b68a173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce4e0cc6782e851d0bfdfb59fc0cc39/" rel="bookmark">
			CentOS 7 管理员密码遗忘如何处理（保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多朋友经常会忘记Linux系统的用户密码，忘记密码的情况该怎么办呢？
接下来跟随我的脚步进行密码的修改吧
1、在进入系统的界面中按一下键盘E键
按E后的界面如下
2、移动方向键，将光标移动到ro这里，将ro改成rw init=/sysroot/bin，并且按CTRL+X进入到系统的紧急求援模式
3、依次输入以下的命令配置新密码
chroot /sysroot ##进入shell模式 passwd ##配置新密码 touch /.autorelabel ##建立新的SELinux安全脉络 exit ##退出shell模式 reboot ##重启 4、最后重启输入你修改的密码就可以登录了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275d3db346c8bb3cc0544c92d1f6399a/" rel="bookmark">
			处理退到后台之后再次点开应用不回到对应页面的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 处理退到后台之后再次点开应用不回到对应页面的问题 if (!this.isTaskRoot()) { Intent mainIntent = getIntent(); String action = mainIntent.getAction(); if (mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) &amp;&amp; Intent.ACTION_MAIN.equals(action)) { finish(); return; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b267fa7c989748daca1339ae3920449f/" rel="bookmark">
			解决win11能使用微信qq但是不可以使用浏览器上网的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 百度找了好多教程都是让修改dns首选地址的，这种一般是win10的解决方式，下面将win11遇到这个问题的解决方式贴到下面
wifi连接正常，且微信qq可以使用 解决方式如下 最后将这个代理服务器关掉即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f23a27f7c18f88df592e6ef54a35a48/" rel="bookmark">
			基于C的面向对象的状态机设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、状态机的三要素 状态机存储从开始时刻到现在的状态变化，并根据当前输入，决定下一个状态。因此状态机包含三大要素：
存储状态获得输入（我们称作跳转调节或者事件）作出响应 我们以mp3播放器为例实现一个简单的状态机，其状态图入下所示
图1.1 mp3播放器状态图
图中：“停止按钮/停止处理” 中 "停止按钮"代表输入“停止处理”代表响应，箭头代表从播放状态到停止状态的状态切换。
从上图中可以看出。
一共有三种状态： “停止状态”、”播放状态“、“暂停状态”。
一共有两种输入：”播放按钮“、”停止按钮“。
一共有三种响应：“播放处理”、“暂停处理”、“停止处理”。
2、状态机设计 为了便于理解我们对上诉状态图换一种表达方式，我们先创建一个2行3列事件-状态表格，表头的行存储所有的状态，列存储事件（即输入）。表格实体对应的是每种事件和每种状态组合后的4种响应。
事件-状态停止状态播放状态暂停状态播放按键播放处理暂停处理播放处理停止按钮无响应停止处理停止处理 要设计状态机我们需要完成状态机的三大要素设计即状态、输入、响应。
状态设计
设计各个状态之前首先定义一个状态结构体对象，结构体内部用来存储当前状态下每一种输入所对应的响应函数指针； /*定义状态对象*/ typedef struct State { void (* const KeyPlay)(); //当前状态下对应的”播放按键“事件（输入）响应 void (* const KeyStop)(); //当前状态下对应的”停止按键“事件（输入）响应 }State_Object; 至此我们只是完成对状态数据结构的抽象即State_Object，下面我们用抽象出来的状态对象定义我们需要的3种状态
/*定义"停止状态"对象实体*/ State_Object STOP = { StartPlay, //"停止状态"下对应的”播放按键“事件响应 Ignore, //"停止状态"下对应的”停止按键“事件响应 }; /*定义"播放状态“对象实体*/ State_Object PLAY = { PausePlay, //"播放状态"下对应的”播放按键“事件响应 StopPlay, //"播放状态"下对应的”停止按键“事件响应 }; /*定义"暂停状态“对象实体*/ State_Object PAUSE = { StartPlay, //"暂停状态"下对应的”播放按键“事件响应 StopPlay, //"暂停状态"下对应的”停止按键“事件响应 }; 我们需要定义一个状态指针后面会作为用来实现输入到响应的转换。
/*定义状态指针*/ State_Object * pCurrentState = &amp;STOP;//初始化为“停止状态” 响应设计 接下来我们定义需要4种响应处理函数（实际上只有三种响应函数，无响应也需要为其定义一个函数实体）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f23a27f7c18f88df592e6ef54a35a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace745f3b1b9c9310e4fd921da35241a/" rel="bookmark">
			2023首届大学生算法大赛 - 拿饼干
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读题可以发现是分组背包问题，但是要求每个组别至少用上一个，所以调用的前一种状态必须是已经含有前一组的物品，打个标记即可。
#include &lt;bits/stdc++.h&gt; using namespace std; const int N=501; int n,m,c,w[N],t[N],f[N][10001]; bool use[N][10001]; vector&lt;int&gt;a[N]; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;c; for(int i=1;i&lt;=n;++i) cin&gt;&gt;w[i]; for(int i=1;i&lt;=n;++i) cin&gt;&gt;t[i]; for(int i=1;i&lt;=n;++i){ a[t[i]].push_back(w[i]); } for(int j=1;j&lt;=c;++j) use[0][j]=true; for(int i=1;i&lt;=m;++i){ for(int j=1;j&lt;=c;++j){ for(auto k:a[i]){ if(j-k&gt;=0 and use[i-1][j-k]){//本组的当前物品可以拿,并且前一组对应状态是拿过的 if(f[i-1][j-k]+k&gt;f[i][j]){//拿了,并且更大,标记一下 f[i][j]=f[i-1][j-k]+k; use[i][j]=true; }else//拿不了,继承当前组的状态 f[i][j]=f[i][j-1]; } } } } cout&lt;&lt;f[m][c]; return 0; } 代码不知道对不对，只能过样例，本蒟蒻比赛的前一天没睡觉，导致while(true)rp--
提醒各位千万不要在考试或者比赛之前熬夜或者通宵（（（（
下面放一个时间超时的递归代码。
#include &lt;bits/stdc++.h&gt; using namespace std; const int N=501; int n,m,c,w[N],t[N],ans; bool vis[N]; void dfs(int now,int weight,int cnt){ if(now==n+1)return; if(weight&gt;c)return; if(cnt==m)ans=max(ans,weight); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ace745f3b1b9c9310e4fd921da35241a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c8934d0638bd0d8d963d0c747060ef/" rel="bookmark">
			BUUCTF-摩丝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BUUCTF-摩丝 dict = { '.-': 'A','-...': 'B','-.-.': 'C','-..':'D','.':'E','..-.':'F', '--.': 'G','....': 'H','..': 'I','.---':'J','-.-': 'K','.-..': 'L', '--': 'M','-.': 'N','---': 'O','.--.': 'P','--.-': 'Q','.-.': 'R', '...': 'S','-': 'T','..-': 'U','...-': 'V','.--': 'W','-..-': 'X', '-.--': 'Y','--..': 'Z','.----': '1','..---': '2','...--': '3','....-': '4', '.....': '5','-....': '6','--...': '7','---..': '8','----.': '9', '-----': '0','..--..': '?','-..-.': '/','-.--.-': '()','-....-': '-', '.-.-.-': '.'}; # 摩斯码转字符串 def decipherForMos(): a =input("input the string:") s = a.split(" ") #按空格将输入的字符切片 for item in s: print(dict[item],end='') # 字符串转摩斯码 def decipherForStr(): a = input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3c8934d0638bd0d8d963d0c747060ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7236f658f56323252d04079e9bb346b2/" rel="bookmark">
			存储过程的基本开发步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle存储过程语法如下：
1、创建存储过程
CREATE [OR REPLACE] PROCEDURE procedure_name (parameter1 IN datatype1, parameter2 OUT datatype2) IS --声明变量 BEGIN --语句块 END procedure_name;
2、调用存储过程
EXECUTE procedure_name(param1, param2);
3、存储过程参数
参数分为3种：输入参数（IN）、输出参数（OUT）和输入输出参数（IN OUT）。 参数定义格式：parameter_name [IN | OUT | IN OUT] datatype
4、存储过程变量
存储过程变量需要声明并赋初值，可以使用DECLARE语句进行声明，语法如下：
DECLARE variable_name datatype := initial_value;
5、存储过程条件判断
IF条件判断语句用于判断条件是否满足，语法如下：
IF condition THEN statement1; ELSE statement2; END IF;
6、存储过程循环
LOOP、WHILE和FOR循环用于存储过程的循环操作，语法如下：
LOOP statement1; statement2; END LOOP;
WHILE condition LOOP statement1; statement2; END LOOP;
FOR variable_name IN lower_bound…upper_bound LOOP statement1; statement2; END LOOP;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7236f658f56323252d04079e9bb346b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1007bee3c91b485ca91fccd97493cb98/" rel="bookmark">
			navicat连接虚拟机中docker容器中的mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机是VMware中的centos7，用docker run mysql镜像时注意映射端口即可，也可后续通过修改docker的配置文件增加，在用navicat连接时在“常规”栏中填写设置的用户名（一般为“root”）和密码即可，地址填虚拟机地址或者127.0.0.1或者默认的localhost一般都可以，在“ssh栏中”填写登录虚拟机的用户名和密码。
原理是先进行虚拟机认证后再进行mysql的连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7934cb36e7bef271fc828cef512929f/" rel="bookmark">
			网站被劫持怎么办？传奇网站打开跳到其他站的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站劫持一直是工信部着重打击的，刚开始流量劫持行为还没有被定义为刑事犯罪，不少人把它当做一种快速牟利的手段。2015年流量劫持首次被认定为犯罪，上海浦东新区人民法院判决了全国首起流量劫持刑事案件，两名被告人被判有期徒刑3年，缓刑3年。尤其在sf这个灰色产业链上，劫持相当严重，很多玩家朋友的电脑打开A网站无缘无故就跳到了B网站，令人头疼。今天飞飞和你们分享几种劫持方式和解决办法，但不保证100%有效，可以逐个尝试。
1、HOSTS劫持 HOSTS劫持是早期常用的方法，通过安装一些软件或者外挂修改hosts，这个文件的位置在C:\Windows\System32\drivers\etc下面，如果不显示我们就设置下系统显示隐藏文件，因为有些不法分子把属性设置成了隐藏，如果没有可以手动建一个hosts.txt文件，加入以下内容：
# Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7934cb36e7bef271fc828cef512929f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0537a3990402a3c72ae29188fe2cb48/" rel="bookmark">
			一文读懂23种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 代码质量的评判标准设计原则1、SOLID原则：SRP(Single Responsibility Principle)单一职责原则2、SOLID原则：OCP(Open-Closed Principle)开闭原则3、SOLID原则：LSP(Liskov Substitution Principle)里氏替换原则4、ISP(Interface Segregation Principle)接口隔离原则5、SOLID原则：DIP(Dependence Inversion Principle)依赖倒置原则6、KISS(Keep It Short and Simple)原则7、YAGNI(You Ain't Goona Need It)原则8、DRY(Don't Repeat Yourself)原则9、LOD原则 设计模式三大类创建模式单例模式原型模式工厂模式抽象工厂模式建造者模式 结构模式外观模式组合模式装饰器模式适配器模式享元模式代理模式桥接模式 行为模式模版模式迭代器责任链模式策略模式状态模式备忘录模式中介者模式命令模式访问者模式观察者模式解释器模式 结合最近学习内容，分享设计模式相关总结，后面会结合java语言，给出每种设计模式的代码实现和案例分析。 这篇文章是对设计模式的综述，简单介绍23种设计模式的应用场景和优缺点； 为了提高编码能力和编码规范性，首先需要定义标准，什么样的代码算是规范的代码？ 代码质量的评判标准 如何评价代码质量的高低 标准多，带有主观性，无法用单一的标准去评判，需要综各个维度； 最常用的评价标准有哪些 最常用：可维护性、可扩展性、可读性其他：灵活性、简洁性、可复用性、可测试性 如何才能写出高质量的代码 设计思想设计原则设计模式编码规范重构技巧 设计原则 1、SOLID原则：SRP(Single Responsibility Principle)单一职责原则 概念：一个类只负责完成一个职责或者功能；意义： 提高类的内聚性实现代码的高内聚、低耦合 2、SOLID原则：OCP(Open-Closed Principle)开闭原则 软件实体应对扩展开放，而对修改关闭开闭原则不是完全杜绝修改，而是以最小修改代码的代价来完成新功能的开发如何实现？ 时刻具备扩展意识，封装意识和抽象意识常用来提高代码扩展性的方法：多态、依赖注入、基于接口非实现编程、大部分设计模式：装饰、策略、模版、职责链和状态 3、SOLID原则：LSP(Liskov Substitution Principle)里氏替换原则 概念：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来的逻辑行为不变及正确性不被破坏核心：“design by contract，按照协议来设计”，父类中定义了函数的约定（或协议），子类可以改变函数内部的实现逻辑，但不能改变函数原有的约定里氏替换原则VS多态 里氏替换是一种设计原则，用来指导继承关系中子类该如何设计，子类设计要保证在替换父类的时候，不改变原程序的逻辑及不破坏原有程序的正确性多态是面向对象编程的一大特性，是面向对象编程的一种语法，是一种代码实现的思路 4、ISP(Interface Segregation Principle)接口隔离原则 概念：客户端不应该强迫依赖它不需要的接口，其中“客户端”可以理解为接口的调用者或使用者核心：“接口”三种不同理解 1.把“接口”理解为一组接口的集合2.把“接口”理解为单个接口或者函数3.把“接口”理解为OOP中的接口 单一职责原则VS接口隔离原则 单一职责原则针对的是模块、类、接口的设计接口隔离原则提供了一种判断接口职责是否单一的标准：通过调用者中如何使用来间接判定 5、SOLID原则：DIP(Dependence Inversion Principle)依赖倒置原则 控制反转（IOC）：一个比较笼统的设计思想，并不是一种具体的实现方式；抽象不应该依赖于细节，细节应该依赖于抽象依赖注入：和控制反转刚好相反，是一种具体的编码技巧依赖注入框架：通过依赖注入提供的扩展点，简单配置下所有需要的类及其类与类之间的依赖关系，就可以实现由框架自动创建对象，管理对象的生命周期，依赖注入等原本需要程序员做的事情 6、KISS(Keep It Short and Simple)原则 概念：尽量保持简单‘意义：保持代码可读和可维护的重要手段如何满足KISS原则 不要使用同事可能不懂的技术实现代码不要重复造轮子，善于使用已经有的工具类库不要过度优化 7、YAGNI(You Ain’t Goona Need It)原则 概念：不要设计当前用不到的功能，不要去编写当前用不到的代码核心：不要过度设计 8、DRY(Don’t Repeat Yourself)原则 概念：不要写重复的代码3中代码重复的情况 实现逻辑重复功能语义重复代码执行重复 提高代码复用性的手段 减少代码耦合满足单一职责原则模块化业务与非业务逻辑分离通用代码下沉继承、多态、抽象、封装应用模版等设计模式有复用意识 9、LOD原则 高内聚、松耦合 高内聚：指导类本身的设计。松耦合：指导类与类依赖关系的设计高内聚：相近的功能应该放在同一个类中，不相近的功能不要放在同一个类中松耦合：即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类代码的改动 迪米特法则 概念：不该有直接依赖关系的类之间，不要有依赖；有依赖的类之间，尽量只依赖必要的接口意义：减少类之间的耦合，让类越独立越好 设计模式三大类 设计模式分为三种类型，共23类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0537a3990402a3c72ae29188fe2cb48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58036361c6d948428f4393c94b32053c/" rel="bookmark">
			linux ctrl &#43;r 键搜索上一条匹配记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Linux中使用ctrl+r可以进入反向搜索模式，在该模式下，输入关键字会搜索之前输入的命令历史记录，并显示最近一次匹配该关键字的命令。若想查找上一条匹配，可以重复按下ctrl+r，直到找到所需的命令为止。另外，也可以按下Enter键执行当前匹配的命令 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ab3282be91b1a5d7e08b852328e884/" rel="bookmark">
			C语言练习：计算BMI其中的scanf小细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中初学者的练习中对于scanf有些细节没能注意到，比如在计算BMI小练习中我就遇到了因为scanf小细节而输出失败的问题，话不多说看代码。
#include &lt;stdio.h&gt; /*输入一个人的身高(m)和体重(kg)，根据BMI公式（体重除以身高的平方）计算他的BMI指数。 例如：一個52公斤的人，身高是155cm，则BMI为 : 52(kg)/1.55^2(m)= 21.6(**) BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖*/ int main(int argc, char *argv[]) { //1.定义两个变量用来存放身高和体重，一个变量存放BMI float height, weight, BMI; //2.输入身高，体重 printf("请输入身高\n"); scanf("%.2f", &amp;height); printf("请输入体重\n"); scanf("%.2f", &amp;weight); //3.计算BMI的值 BMI=weight/(height*height); //4.用if语句来判断BMI属于哪个档次并输出相应身体状况 if (BMI&gt;32){ printf("严重肥胖！"); } else if (BMI&gt;28){ printf("肥胖！"); } else if (BMI&gt;25){ printf("过重！"); } else if (BMI&gt;18.5){ printf("正常"); } else{ printf("过轻！"); } return 0; } 在第二步的时候使用scanf的时候我想把输出的数据显示小数点后两位，所以在这里加入了.2，这就是概念混淆的问题。实际上想要确定输出的数据显示小数点后两位只需要在printf中加入.2就行了。正确代码如下所示：
#include &lt;stdio.h&gt; /*输入一个人的身高(m)和体重(kg)，根据BMI公式（体重除以身高的平方）计算他的BMI指数。 例如：一個52公斤的人，身高是155cm，则BMI为 : 52(kg)/1.55^2(m)= 21.6(**) BMI指数： 低于18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ab3282be91b1a5d7e08b852328e884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1552c1418fa4c67747f435b5d29e06/" rel="bookmark">
			洛谷B2019整型与布尔型的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 洛谷B2019
题目描述
将一个整型变量的值赋给一个布尔型变量，再将这个布尔型变量的值赋给一个整型变量，得到的值是多少？
输入格式
一个整型范围内的整数，即初始时整型变量的值。
输出格式
一个整数，经过上述过程后得到的结果。
运行代码
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int x; cin&gt;&gt;x; if(x==0)cout&lt;&lt;0; else cout&lt;&lt;1; return 0; }``` 运行结果 ![在这里插入图片描述](https://img-blog.csdnimg.cn/a4308590e9a94cc19ae5e3dffca9c6fe.png)注意： 布尔型是PHP4种标量数据类型中的一个，只能保存两个值true和false，不区分大小。变量值为整型的时候，如果值为0为假（false），其他为真。为浮点型的时候，值为0.00为假，其余时候为真。变量值为字符串的时候，为空则为假，其余时候为真。变量是数组型时，数组中没有成员为假，其余时候为真。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33849e8716002630ec1673839d8afc99/" rel="bookmark">
			CTF-show部分wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		热身 根据题目提示
flag为flag{一个不能说的秘密}
奇怪的压缩包 下载文件后，发现有加密，根据网上所说，ctf考过伪加密的考点，用winhex打开压缩包，发现伪加密字符
将 09 改为 00 ，ctrl+s保存，直接从压缩包拖出，black.png，发现未提示需要压缩密码，打开文件
怀疑是长宽高被截取，但折腾好久之后发现并非如此，想到题目描述中 压缩包乎？图片乎？遂用winhex
打开，拖到最下面，发现flag.png与key字样
猜测key为base64编码，解码得出 yurenjie ，至此我猜测应该隐写了一个文件在图片中，启动binwalk
扫描未果，于是继续从winhex入手，翻看时看到熟悉字样
如果你看不懂，看下面这张图
可以看到， 504B0304140090 猜测是同源zip压缩包，于是复制右键存为新文件
并添加后缀为 .zip ，打开后发现果然有 flag.png ，遂用7zip解压，发现有加密，联想到刚刚解码得出的yurenjie
成功得到flag.png,打开后，我以为需要和black.png进行融合得到密码，但是越想越不对劲，于是又用
winhex打开，发现有大部分数据与
black.png，相似，拷出到vscode进行查看
发现对应字段，猜测下方字符串为base64编码
解码得出
本以为flag为 ctfshow{愚人节快乐！！！} ，提交后发现不对，然后想 哦愚人节，于是直接提交
ctfshow{Th1s_i5_f1ag} ，正确
easy_signin 打开网页，发现url地址： img=ZmFjZS5wbmc= ,敏感如我直接base64解码face.png ,猜测可能存在文件
读取漏洞，这个解决了就找数据回显的地方，按下F12，看到不同寻常的地方
最后一个值巨大，另有base64字样，寻找一个在线base64转图片的地方输入值
果然得到图片，于是对 index.php 进行编码，得到 aW5kZXgucGhw ,拼接到url中，发现src中有值，并对
值进行解码
easy_base 根据题目提示，密文为base编码得到，扔进工具进行fuzz测试，发现只有base16，不是乱码
得到LEZVE3LDGJUHMZBTOQ2WIVRZPFNFONLGMFVEM3CYGJUGQVKIII2USU2FNBTFCPJ5 ，继续进行fuzz
发现base32，不乱码，得到 Y3Rmc2hvd3t5dV9yZW5fajFlX2hhUHB5ISEhfQ==
这串太熟悉了，直接base64解码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d90f2cbf2e06a0410e733fd98f8f09/" rel="bookmark">
			如何查看自电脑上安装的python版本？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础小知识，首先需要确认版本信息，因为有些库使用的时候，不兼容最新的版本，不要拿起来就搞。
要查看自己安装的 Python 版本，可以打开命令行终端并输入以下命令：
python
python --version
这将显示当前 Python 版本的信息，例如：
Python 3.8.10
如果安装了多个 Python 版本，可以使用以下命令查看所有已安装的 Python 版本：
python
python3 --version
这将显示所有已安装的 Python 版本信息。如果系统中没有安装 Python，可以从官方网站下载并安装：https://www.python.org/downloads/。
好啦，你学会了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76418873965198cd4826537c1bbf1d96/" rel="bookmark">
			【Keycel】用java写一个猜数字游戏（1到100以内）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需要用到键盘输入功能，所以我们要用到Scanner;需要随机数，所以我们要用到Random。
import java.util.Random; import java.util.Scanner; public class guessnumber{ public static void main (String[] args){ Random a=new Random(); Scanner b=new Scanner(System.in); int xnumber= a.nextInt(100)+1; 2.我们输入的数需要与随机数匹配，所以我们要用到分支语句if类。同时我们也需要while的死循环来支持我们可以一直输入数字直到等于随机数。
while(true){ System.out.println("请输入你要猜测的数字(1到100以内)"); int guessnumber=b.nextInt(); if(xnumber&lt;guessnumber){ System.out.println("你猜的数字较大"); System.out.println("———————————————————————"); } else if(xnumber&gt;guessnumber){ System.out.println("你猜的数字比较小"); System.out.println("———————————————————————"); } else{ System.out.println("恭喜你！你猜对了！"); break; } } 以上就是用java写一个猜数字游戏的全部了，感谢阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a0bd61437f36dbfefdc36d27d9b926a/" rel="bookmark">
			STM32CubeIDE（MX）下载安装、汉化、使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先配置JAVA环境
JAVA下载地址https://www.java.com/zh-CN/download/
JAVA安装：
1、打开.exe安装包，勾选更改目标文件夹，点击安装
2、选择安装路径，点击下一步
3、等待安装，安装完毕，点击关闭
确认JAVA已经安装：win+R----输入命令符cmd----输入Java -version----看到版本号证明安装完成----关闭
一、STM32CubeIDE（单独使用不需要JAVA环境）
1、下载安装
软件下载地址STM32CubeIDE - STM32的集成开发环境 - 意法半导体STMicroelectronics
选择版本号获取软件----点击接受----输入邮箱就可以下载----将压缩包解压到新建的、无中文的路径
解压好的.exe文件以管理员身份运行----Next----I Agree----修改安装路径（不放在C盘，不能有中文）----Next----Install----等待安装----Finish----项目存放路径（默认C盘并记住路径（文件存放地点），不能有中文），勾选并Launch
2、汉化
打开网址http://mirrors.ustc.edu.cn/eclipse/technology/babel/update-site/
选择汉化包地址
最终地址格式为（http://mirrors.ustc.edu.cn/）加上（自己选择汉化包地址的部分）
例如：http://mirrors.ustc.edu.cn/eclipse/technology/babel/update-site/R0.20.0/2022-12/
打开STM32CubeIDE----Help----Install New Software...----Add...----Name:language----Location:复制汉化包地址Add----Chinese(Simplified)----...for eclipse...----NEXT、Agree----重启
3、使用
文件---新建工程IDE----选择芯片----工程命名（不能有中文）----开始配置
晶振源RCC配置
时钟树配置（芯片不同，板内晶振不同）
仿真接口SYS配置（Debug多次调试）
配置引脚外设之前，需要在生成代码时生成相应的.c和.h文件
Project Manager----Code Generation----勾选Generate peripherall...
（需要使用时配置）定时器配置、GPIO配置、UART配置、中断配置
串口UART配置中允许输出浮点数
右键点击属性----C/C++构建----设置----所有配置----MCU settings----两个都勾选
点击小车轮生成代码----在main.c中编写程序----Debug----小虫子调试并烧写
二、STM32CubeMX（需要JAVA环境）
1、下载安装
软件下载STM32CubeMX - STM32Cube initialization code generator - STMicroelectronics
必须配置好JAVA环境再安装STM32CubeMX！！！
解压好的.exe文件以管理员身份运行----Next----勾选I accept，Next----勾选第一个，Next----修改安装路径（不放在C盘，不能有中文）----根据需求勾选，Next----等待安装----Next，Done
2、MX嵌套在IDE内，使用同理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eeea83c4a2743c83c68a274ac66ad39/" rel="bookmark">
			免费可商用开源GPT模型问世，50G权重直接下载，性能不输GPT-3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		萧箫 发自 凹非寺
量子位 | 公众号 QbitAI 真·开源GPT模型，终于来了。
参数量级130亿，大小比肩最近Meta开放的LLaMA-13B，但从数据集、模型权重到计算优化训练，全部开源。
最关键的是，可商用。
没错，虽然就GPT-3而言，之前DeepMind、Meta等组织陆陆续续开源过几个模型，不过基本都是半遮半掩。
尤其最接近GPT-3的Meta OPT模型，不仅权重只开放给研究者，而且不可商用：
这意味着之前企业就算能抄作业，抄来的也没办法直接用。
现在，一家名叫Cerebras的公司开源了这一系列GPT模型，业界终于有机会追赶了。
模型性能如何？ Cerebras一共开源了7个GPT模型，参数量分别达到1.11亿、2.56亿、5.9亿、13亿、27亿、67亿和130亿。
据Cerebras公司表示，他们开放出来的模型不仅包含数据集，可用于研究也可商用，而且关键是预训练模型权重开放（从下图来看文件大小近50G）。
基于他们公开的预训练模型，大伙儿只需要用少量的数据对对模型进行微调，就能构建出效果不错的模型来。
除此之外，这次GPT模型的训练还额外考虑到了计算优化训练 （Compute-Optimal Training）。
这个方法最早由DeepMind在2022年提出，名叫Chinchilla，它认为大语言模型的语料数量和模型效果之间符合一个凸曲线，因此模型参数量和训练程度成一定比例。
依据这个方法，DeepMind认为，包括GPT-3在内的超大参数LLM模型，有很多都是训练不足的。
基于此，Cerebras搞出了这一系列GPT模型，并将背后的流程进行了开源。
所以，Cerebras-GPT系列模型性能如何呢？
团队将Cerebras-GPT系列和LLaMA、GPT-3等模型的性能进行了对比。
这是包括GPT-3、Gopher、Chinchilla和LLaMA在内的其他GPT模型，在完成句子、问答等特定任务上表现的效果。
这是不同大小的Cerebras-GPT模型零次学习（0-shot）的效果：
数据对比不是特别直观，团队还将结果进行了可视化。
可以看出，在最终性能相差不大的情况下，Cerebras-GPT的训练效率要更高一些。
曾开发最大AI芯片 其实，Cerebras的“本职”是一家AI芯片公司。
Cerebras公司由Sean Lie和Andrew Feldman等人于2016年创立。
其中，Andrew Feldman曾创建微型服务器公司SeaMicro，并以3.34亿美元的价格出售给AMD。
与其他AI芯片公司不同，Cerebras开发的芯片超大，像晶圆一样（但确实是芯片）：
他们当年做出来过一个名叫“晶圆级引擎”（Cerebras Wafer Scale Engine，简称WSE）的AI芯片，将逻辑运算、通讯和存储器集成到单个硅片上，一口气创下了4项世界纪录：
晶体管数量最多的运算芯片：总共包含1.2万亿个晶体管。虽然三星曾造出2万亿个晶体管的芯片，却是用于存储的eUFS。
芯片面积最大：尺寸约20厘米×23厘米，总面积46,225平方毫米。面积和一块晶圆差不多。
片上缓存最大：包含18GB的片上SRAM存储器。
运算核心最多：包含40万个处理核心。
后来这个超大WSE又升级了二代，然后团队基于WSE-2打造出了一个名叫Cerebras CS-2的AI超算。
这次的Cerebras-GPT系列模型，就是在这个Cerebras CS-2的AI超算中训练出来的。对此这家公司表示：
虽然训练这么大体量的模型通常需要几个月时间，但我们几周就能搞定。
Cerebras还表示，虽然很多硬件公司都声称训练效果能接近英伟达GPU的水平，但他们还没看到任何一家亲自推动开源LLM的硬件公司，这势必不利于开源LLM的发展。
这波啊，这波Cerebras格局大了（手动狗头）
模型地址：
https://huggingface.co/cerebras/Cerebras-GPT-13B
参考链接：
https://www.cerebras.net/blog/cerebras-gpt-a-family-of-open-compute-efficient-large-language-models/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4ae90c47163f4fe243ec2d2a1ae929/" rel="bookmark">
			基于Docker搭建Hadoop集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 下载VMware、Xshell、Xftp、centos7映像文件、hadoop和jdk的压缩包。
二、配置虚拟机 1.创建虚拟机 使用VMware新建虚拟机，同时安装centos7系统，命名为master。
2.给虚拟机配置IP、网关等 vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改BOOTPROTO为static,并在最后添加虚拟机的IP地址，子网掩码、网关和DNS等，如下图。
保存后退出。
重启网络服务，测试能否ping通百度，可以则配置成功，如下图。
3.关闭防火墙 查看此时防火墙的状态。
systemctl status firewalld 发现此时防火墙开启，所以将其关闭，并设置永久关闭。
systemctl stop firewalld systemctl disable firewalld 此时再查看防火墙的状态，发现已关闭。（若要测试是否永久关闭可以重启后查看）
4.补充：找不到ifconfig命令（可用于查看IP） 进行如下操作即可。
5.使用xshell连接虚拟机 选择“接受并保存”，然后输入用户名和密码即可。
6.修改主机名 若第一步未命名虚拟机，可通过如下命令。
vi /etc/hostname 输入名字，保存后退出。然后重启，命名生效。
三、安装docker服务 1.自动安装docker curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 2.查看docker的版本 3.启动docker，并设置开机自启动 4.配置docker镜像加速器 vi /etc/docker/daemon.json 添加如下内容
保存后退出。
5.重启docker服务 systemctl daemon-reload systemctl restart docker 输入docker info，最下方显示我们配置的地址时即为成功配置镜像加速器，如下图。
四、安装pipework和bridge-utils 1.新建文件夹software mkdir software cd software 2.安装git yum install -y git 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe4ae90c47163f4fe243ec2d2a1ae929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0294f49a84fc8001190466905c7e5b8d/" rel="bookmark">
			秒懂SpringBoot之参数验证全解析(@Validated与@Valid)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[版权申明] 非商业目的注明出处可自由转载
出自：shusheng007
文章目录 概述实例SpringBoot 验证概述引入依赖使用相关注解标记使用@Valid标记统一处理异常 高级用法复杂对象参数验证基本类型参数验证Service方法参数验证手动验证分组验证自定义约束注解JPA Entity验证 概述源码题外话 概述 在构建 Web 应用程序时，确保进入应用程序的数据有效并满足您的业务需求非常重要。 实现此目的的一种方法是在服务器端验证输入数据。 在这篇博客中，我们将探讨如何在 Spring Boot 应用程序中进行输入数据验证，善用的话可以写出健壮而优美的代码。
让我们从一个实例开始吧
实例 邻家有女初长成，大名唤作牛翠华，家里催翠花找对象，无奈翠花深受互联网女拳师的影响，搞得翠花对另一半的要求非常高…
择偶标准
非王思聪类型不嫁年龄大于30不嫁身高矮于185cm不嫁体重高于85kg不嫁没有大别墅不嫁没有大奔驰不嫁父母建在且没有城市养老金不嫁
… 假如我们要写一个产生符合其要求的男朋友的API，如何来写呢？
@Slf4j @RestController @RequestMapping("/validation") public class ValidateController { @Autowired private ValidationService validationService; @PostMapping("/boy-friends") public ResponseEntity&lt;BoyFriend&gt; createBoyFriend(@RequestBody BoyFriend boy) { log.info("create:{}", boy); return ResponseEntity.ok(boy); } } 于是我们今天的主角就登场了。
SpringBoot 验证概述 Spring Boot 使用 Jakarta Bean Validation API 为输入数据验证提供内置支持，Java Bean Validation API 是用于验证 Java 对象的标准 API。 此 API 允许您使用注释定义 Java 类属性的约束，并根据这些约束验证输入数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0294f49a84fc8001190466905c7e5b8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47908f4d2844cc5673931b03b966759d/" rel="bookmark">
			PCB模块化设计19——光口模块PCB布局布线设计规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 PCB模块化设计19——光口模块PCB布局布线设计规范 PCB模块化设计19——光口模块PCB布局布线设计规范 链接: 史上最全的光模块介绍，看这一篇就够了！
链接: 关于光模块，看这一篇就够啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/072c8103857c5227cd87ed7da3325736/" rel="bookmark">
			bash脚本编写教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这部教程是我在网上找到比较经典的BASH中文教程，对新手学习bash脚本，bash编程的好文章。
建立一个脚本
Linux中有好多中不同的shell，但是通常我们使用bash (bourne again shell) 进行shell编程，因为bash是免费的并且很容易使用。所以在本文中笔者所提供的脚本都是使用bash(但是在大多数情况下，这些脚本同样可以在 bash的大姐，bourne shell中运行)。
如同其他语言一样，通过我们使用任意一种文字编辑器，比如nedit、kedit、emacs、vi
等来编写我们的shell程序。
程序必须以下面的行开始(必须方在文件的第一行)：
#!/bin/sh
符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。
当编辑好脚本时，如果要执行该脚本，还必须使其可执行。
要使脚本可执行：
chmod +x filename
然后，您可以通过输入： ./filename 来执行您的脚本。
注释
在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。
变量
在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：
变量名=值
取出变量值可以加一个美元符号($)在变量前面：
#!/bin/sh
#对变量赋值：
a="hello world"
# 现在打印变量a的内容：
echo "A is:"
echo $a
在您的编辑器中输入以上内容，然后将其保存为一个文件first。之后执行chmod +x first
使其可执行，最后输入./first执行该脚本。
这个脚本将会输出：
A is:
hello world
有时候变量名很容易与其他文字混淆，比如：
num=2
echo "this is the $numnd"
这并不会打印出"this is the 2nd"，而仅仅打印"this is the "，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：
num=2
echo "this is the ${num}nd"
这将打印： this is the 2nd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/072c8103857c5227cd87ed7da3325736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0472ac6b448e48e819b847480474142/" rel="bookmark">
			第三、四章 面向对象 （第三次作业）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次作答 一.单选题（共29题,34.8分） 1下面选项中，类的声明方式正确的是（）
A、public void AA{…}
B、public class Move(){…}
C、public class void number{…}
D、public class Car{…}
正确答案： D
2在java中，以下程序的输出结果是（）
class Point {
int x;
boolean y;
void output() {
System.out.println(x);
System.out.println(y);
}
public static void main(String[] args) {
Point pt =new Point();
pt.output();
}
}
A、运行错误
B、0 ture
C、0 false
D、0 0
正确答案： C
3在Java接口中，下列选项中属于有效的方法声明的是（）
A、public void aMethod();
B、final void aMethod();
C、void aMethod(){}
D、private void aMethod();
正确答案： A
4下列程序的运行结果是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0472ac6b448e48e819b847480474142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e5aa388ca032281939d17bf83309d4/" rel="bookmark">
			在docker中配置mysql数据库 并配置远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动docker systemctl docker start 启动：systemctl start docker service docker start 停止：systemctl stop docker 重启：systemctl restart docker 每次都需要用如下命令手动开启服务：
systemctl daemon-reload systemctl restart docker.service 可以设置开机自启docker
# docker 服务开机自启动命令 systemctl enable docker.service # 关闭docker 服务开机自启动命令 systemctl disable docker.service 查看当前docker 所有镜像
docker images 查看停止运行的容器
docker ps -aq 若已存在mysql容器 直接运行
docker start mysql8.0(容器名称) 安装mysql 指定版本
docker pull mysql:8.0.25 创建并启动mysql sudo docker run -p 3306:3306 --name mysql \ -v /mydata/mysql/log:/var/log/mysql \ -v /mydata/mysql/data:/var/lib/mysql \ -v /mydata/mysql/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=root \ -d mysql:8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73e5aa388ca032281939d17bf83309d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e296ef9a8932f9549a0890e236746e65/" rel="bookmark">
			【哈希表：哈希函数构造方法、哈希冲突的处理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预测未来的最好方法就是创造它💦
目录 一、什么是Hash表 二、Hash冲突 三、Hash函数的构造方法 1. 直接定址法
2. 除余法
3. 基数转换法
4. 平方取中法
5. 折叠法
6. 移位法
7. 随机数法
四、处理冲突方法 1. 开放地址法
• 线性探测法
• 双散列函数法
2. 拉链法
一、什么是Hash表 哈希表（Hash Table），也叫散列表，是一种根据关键字直接访问内存存储位置的数据结构。它通过把关键字映射到哈希表中一个位置来访问记录，以加快查找的速度。
哈希表是由哈希函数和数组组成的，通过哈希函数将关键字转换成数组的下标，然后把该关键字存储在这个下标所对应的数组元素中，从而实现快速的查找、插入和删除操作。
二、Hash冲突 当不同的关键字被映射到同一个数组下标时，就发生了哈希冲突（Collision）。哈希表解决冲突的方式有多种，常见的方式是使用链式法（Chaining）和开放地址法（Open Addressing）。
三、Hash函数的构造方法 对于Hash函数的构造，没有特定的要求，所以方法很多，只是我们需要了解，什么样的哈希函数，才叫好的Hash函数，这样就便于我们根据实际情况来构造合理的Hash函数。
衡量一个哈希函数是否合理，是否是一个好的哈希函数，就看哈希函数对一组关键字所产生的冲突的频率有多高，如果一个哈希函数能够尽量的避免掉这些冲突，那么这个哈希函数就是一个好的哈希函数。
1. 直接定址法 取关键字或关键字的某个线性函数值为哈希地址。即：
H(key) = key 或 H(key) = a*key +b
2. 除余法 以关键码除以表元素总数后得到的余数为存储地址 例:
对21，30，11三个数，利用k MOD 3的方式，求他们的哈希地址有:
21 MOD 3=0
30 MOD 3=0
11 MOD 3= 2
3. 基数转换法 将关键码看作是某个基数制上的整数，然后将其转换为另一基数制上的数，转换后得到的数据就是存储地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e296ef9a8932f9549a0890e236746e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e31dbf941e1af7b2b082ba8b8bb4c9c/" rel="bookmark">
			【linu】ARM安装vscode服务器，本地vscode远程服务器开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里目录 一、VSCODE安装二、本地登录远程服务器三、免密登录 记录arm中开发。
一、VSCODE安装 1、从官网下载最新的版本
我的开发板是arm32位的，因此下载arm32的.deb版本。
2、安装
deb版本：
安装 sudo dpkg -i 文件名.deb 如果出现依赖关系错误，可以使用以下命令修复： sudo apt-get install -f 如果需要卸载deb文件，可以使用以下命令： sudo dpkg -r 文件名 tar.gz版本：
二、本地登录远程服务器 远程登录参考：参考
三、免密登录 免密参考文章：参考
1、本地密钥生成
本地电脑上找到C:\user\xxx.ssh
本地生成：
2、服务器
将本地生成的 id_rsa.pub 文件上传至服务器 ~/.shh/目录下，并重名名为authorized_keys
重启服务器的sshd服务（最好以下三条命令都执行一次）
systemctl restart sshd 重启sshd服务
systemctl reload sshd 使系统重新加载sshd服务配置
service sshd restart
一般到这里重启vscode，即可实现免密登录了
问题：
找不到 .ssh 目录
解决：
如果在上面生成秘钥后，执行 cd ~/.ssh 找不到 .ssh 目录，是因为没有使用 ssh 登录过，使用 ssh 登录一下即可生成 .ssh 目录，之后再重新执行 ssh-keygen 生成秘钥即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833cce55481daa60b65aa046a04f1d94/" rel="bookmark">
			Linux shell 脚本 a || b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		|| 是逻辑或的意思
只有在命令a执行失败时，命令b才会被执行
nano file.txt || vi file.txt 如上例，如果nano打不开指定文件，那就用vim打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7300e8a1030beb82d6423472ccf66fe5/" rel="bookmark">
			微信小程序的授权登录-Java 后端 （Spring boot）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信开发文档链接：https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html
1. 前提 一个可以测试的微信小程序此微信小程序的APPID和APPscret（至开发者后台获取） 2. 开发流程 从时序图我们可以了解到流程大致分为两步：
小程序端获取code后传给Java后台Java后台获取code后向微信后台接口获取open_id 2.1 小程序端(前端要做的) 在微信小程序的前端调用wx.login()获取一个code，这个code就像是我们去微信后台服务器获取用户信息的一个钥匙，微信通过获取这个code的过程给用户一个选择是否授权的选择，如果用户选择了授权就会返回一个code。这个code是一次性的，也是有时限的。
这里简单的做一个说明，首先由小程序端调用wx.login()去获取code，然后，再通过wx.getUserInfo()去获取用户信息（这里请求login和getUserInfo是一起的，把这两次请求的数据合并发给服务端的login接口），通过请求，把：
1.code //临时登入凭证 // 如果不同意获取用户信息，则下面四个参数获取不到 2.rawData //用户非敏感信息，头像和昵称之类的 3.signature //签名 4.encryteDate //用户敏感信息，需要解密，（包含unionID） 5.iv //解密算法的向量 给到服务端，服务端根据 appid+secret+js_code+grant_type
去请求，获取到session_key和openid（这里无法获取unionID），通过session_key，iv来解密encrypteDate获取用户敏感信息和unionID，把用户信息保存到数据库。然后，我们把sesssoin_key和openid保存下来，与token（自定义登入状态）来进行关联，最后把小程序需要的数据返回给小程序端，以后就通过token来维护用户登入状态。
用户表结构设计：
CREATE TABLE `wechat_user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `token` varchar(100) NOT NULL COMMENT 'token', `nickname` varchar(100) DEFAULT NULL COMMENT '用户昵称', `avatar_url` varchar(500) DEFAULT NULL COMMENT '用户头像', `gender` int(11) DEFAULT NULL COMMENT '性别 0-未知、1-男性、2-女性', `country` varchar(100) DEFAULT NULL COMMENT '所在国家', `province` varchar(100) DEFAULT NULL COMMENT '省份', `city` varchar(100) DEFAULT NULL COMMENT '城市', `mobile` varchar(100) DEFAULT NULL COMMENT '手机号码', `open_id` varchar(100) NOT NULL COMMENT '小程序openId', `union_id` varchar(100) DEFAULT '' COMMENT '小程序unionId', `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '插入时间', `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `deleted_at` timestamp NULL DEFAULT NULL COMMENT '删除时间', PRIMARY KEY (`id`), KEY `idx_open_id` (`open_id`), KEY `idx_union_id` (`union_id`), KEY `idx_mobile` (`mobile`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='小程序用户表'; 具体代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7300e8a1030beb82d6423472ccf66fe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81dabd1e1cecc72ac3e7cd1dcbaa946/" rel="bookmark">
			洛谷B2005
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 洛谷B2005
题目描述
给定一个字符，用它构造一个底边长 5个字符，高 3个字符的等腰字符三角形。
输入格式
输入只有一行，包含一个字符。
输出格式
该字符构成的等腰三角形，底边长 5个字符，高 3个字符。
在洛谷提交成功的题解：
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { char a; cin&gt;&gt;a; cout&lt;&lt;" "&lt;&lt;" "&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;" "&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;endl; return 0; } 运行结果：
个人认为这样也可以，但是不知道为什么提交失败（呜呜），后来用的上面那个答案就ok。
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int i,j,t; char l; cin&gt;&gt;l; for(i=1;i&lt;=3;i++) { t=3-i; for(t=0;t&lt;3-j;t++) { cout&lt;&lt;" "; } for(j=1;j&lt;2*i;j++) { cout&lt;&lt;l; } cout&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02457e7e1c9dc5974a3eba5924e8bbd5/" rel="bookmark">
			File类的使用，InputStream, OutputStream 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java-code: java代码管理 (gitee.com)
文章目录 目录
文章目录
一、File类
1.File的属性:
2.File类的构造方法：
3.File类的方法：
二、文件的基本操作
1.inputStream
2.OutputStream ​编辑
3.字符流读取(Reader)
4.字符流写（Writer）
一、File类 File类的使用在JAVA中操作文件~
1.File的属性: 在new是时候输入路径，这个路径是绝对路径和相对路径都可以。
一个是依赖于系统的路径分隔符，String 类型的表示
另外一个是依赖于系统的路径分隔符，char 类型的表示
2.File类的构造方法： File(File parent, String child) ：根据父目录和孩子文件路径，创建一个File实例 File(String pathname) ：根据文件路径创建一个File实例，可以是绝对路径或者相对路径 File(String parent, String child) ：根据父目录的路径和孩子文件的路径，创建一个File实例 3.File类的方法： 这里举例几个简单常用的方法~ public class IODemo1 { public static void main(String[] args) throws IOException { File file=new File("./哲学家.png"); System.out.println(file.getParent()); //返回File对象的父目录文件路径 System.out.println(file.getName()); //返回File对象的纯文件名称 System.out.println(file.getPath()); //返回File对象的文件路径 System.out.println(file.getAbsoluteFile()); //返回File对象的绝对路径 System.out.println(file.getCanonicalPath()); //返回File对象修饰过的绝对路径 } } 执行结果为:
public class IODemo2 { public static void main(String[] args) throws IOException { //相对路径中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02457e7e1c9dc5974a3eba5924e8bbd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a47dc52fdcf76f33a3e2843eae4bae/" rel="bookmark">
			【自动控制原理复试面试简答题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
自动控制原理复试面试简答题 第一章 自动控制系统的基本概念第二章 连续系统的数学模型第三章 时域分析法第四章 频率法第五章 校正第六章 非线性系统 第一章 自动控制系统的基本概念 古典控制论和现代控制理论的区别
描述方法不同：古典控制理论采用传递函数现代控制理论采用状态空间表达式
解决问题不同：古典控制理论适用于单输入单输出系统 现代控制理论适用于多输入多输出系统
自动控制系统的三要素
稳定性，快速性，准确性：
请列举一个自动控制系统
空调控制系统
给定：设定的温度，
测量：温度传感器，
比较：对输入与反馈量进行比较产生误差
放大：将偏差信号进行放大达到能控制温度
执行：制热或制冷器
校正：是对控制系统动态以及静态性能进行改善，使得温度控制稳准快
什么是自动控制系统？自动控制系统由哪些环节组成，各环节有什么作用？
在无人参与的情况下系统自动按预期进行控制
分为六部分
给定环节：设定被控量的数值
检测装置：检测被控量
比较环节：将装置的被控量和给定量进行比较，确定偏差值
放大环节：将偏差值信号转换成对执行机构的控制信号
执行机构：直接作用于控制对象
控制对象：要进行控制的设备
什么是系统的暂态过程
系统从一个稳态过程到另一个稳态得需要经历得过渡过程
单调过程，衰减震荡过程，持续震荡过程，发散震荡过程
简述控制系统的类型
线性与非线性系统
线性：系统中所有元件的特征都是线性的
时不变与时变系统
时不变：系统的结构和参数不随时间变化
连续与离散系统
连续：系统各信号随着时间连续变化
第二章 连续系统的数学模型 什么是数学模型？常见得数学模型有哪些？
描述系统因果关系的数学表达式
微分方程，传递函数，频率特性，结构图
什么是状态变量？什么是状态控制？什么是状态空间表达式？
状态：系统在时间域中的运动信息的集合称为状态
状态变量：确定系统状态的一组独立变量称为状态变量
状态空间：以n个状态变量作为基底所组成的n维空间称为状态空间
线性系统的状态空间表达式：描述输出量与状态量和输入量之间关系的输出方程是向量代数方程的组合称为线性系统状态空间表达式，也叫动态方程
建立状态空间表达式都有哪些方法？什么是系统的实现问题
根据系统方框图列写，把每个积分器的输出作为一个状态变量，根据方框图各环节之间的关系来列写状态空间表达式。
根据系统机理建立响应的微分方程来列写状态空间表达式。
由系统微分方程或传递函数建立状态空间表达式。
由输入输出描述确定状态空间描述的问题叫做实现问题。
简述能控性和能观性
如果系统所有状态变量的运动都可以由输入来控制而由任意的初态达到原点则称系统是完全可控的
如果系统的所有状态变量的任意形式的运动均可由输出完全反映，则称系统是完全可观测的。
简要说明解析法编写自动控制系统动态微分方程得步骤（系统网络写微分方程）
确定系统的输入量和输出量。
从系统的输入端开始，沿着信号的传递方向，根据各原部件的物理规律，列写元件或环节的微分方程。
消除中间变量，建立只有输入量和输出量及其各阶导数构成的微分方程
什么是偏差线性化？这种方法能解决那类问题
就是将一个非线性函数在工作点展开为泰勒级数，略去二次项以上的高次项，得到线性化方程，用来替代原来的非线性函数，综合来说就是某点的切线方程代替原非线性曲线
传递函数是什么？定义传递函数的前提条件是什么？为什么要附加这个条件？传递函数有哪些特点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a47dc52fdcf76f33a3e2843eae4bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c811cbf09c567a0ebb8818afa05ce0/" rel="bookmark">
			UNIX环境高级编程——UNIX基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 引言 所有操作系统都为它们所运行的程序提供服务，典型的服务包括：
执行新程序打开文件读文件分配存储区获得当前时间… 1.2 UNIX体系结构 可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境，通常将这种软件称为内核，因为它相对较小，而且位于环境的核心；内核的接口被称为系统调用；公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可以使用系统调用；shell是一个特殊的应用程序，为运行其他应用程序提供了一个接口。
1.3 登录 1. 登录名 登录名保存在口令文件：/etc/passwd。 2. shell 登陆后，系统先显示一些系统信息，然后用户可以向shell程序键入命令；UNIX系统常见shell：
1.4 文件和目录 1. 文件系统 文件系统是目录和文件的一种层次结构，所有东西的起点是称为根的目录，这个目录的名称是一个字符“/”；目录是一个包含目录项的文件，即目录也是文件；每个目录项都包含一个文件名和说明该文件属性的信息；文件属性指文件类型、大小、所有者、权限、修改时间等。 2. 文件名 目录中的各个名字称为文件名；斜线（/）和空字符不能出现在文件名中，斜线用来分隔构成路径名的各文件名，空字符用来终止一个路径名。 3. 路径名 路径名：由斜线分隔的一个或多个文件名组成的序列（也可以斜线开头）；绝对路径名：以斜线开头的路径名称；相对路径名：不以斜线开头的路径名称，指向相对于当前目录的文件；根：文件系统的根是个特殊的绝对路径名，它不包含文件名。 4. 工作目录 每个进程都有一个工作目录，也称其为当前工作目录；进程可以用chdir函数更改其工作目录。 5. 起始目录 登录时，工作目录设置为起始目录；起始目录从口令文件中相应用户的登录项中取得。 1.5 输入和输出 1. 文件描述符 文件描述符是一个小的非负整数，内核用以标识一个特定进程正在访问的文件；内核打开、创建一个文件时，都返回一个文件描述符，读、写文件时，都可以使用这个文件描述符。 2. 标准输入、标准输出和标准错误 每当运行一个新程序时，所有shell都为其打开3个文件描述符，即：标准输入、标准输出、标准错误；如果不做特殊处理，这3个描述符都链接向终端；可将这3个文件描述符重定向到某个文件。 3. 不带缓冲的I/O 函数open、read、write、lseek以及close提供了不带缓冲的I/O，这些函数都使用文件描述符。
4. 标准I/O 标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。
fgets：读取一个完整的行；read：读取指定字节数；getc：读取一个字符；putc：将字符写到标准输出。 1.6 程序和进程 1. 程序 程序：是一个存储在磁盘上的可执行文件；内核使用exec函数将程序读入内存并执行程序。 2. 进程和进程ID 进程：程序执行的实例，正在执行的程序；进程ID：进程的唯一标识符，一个非负整数。 3. 进程控制 有3个用于进程控制的主要函数：
forkexec（7种变体，统称为exec函数）waitpid 4. 线程和线程ID 一个进程内的所有线程共享同一地址空间、文件描述符以及与进程相关的属性；线程不共享栈，每个线程有单独的栈、程序计数器PC；线程在访问共享数据时要采取同步措施以避免不一致性；线程ID：线程的唯一标识符，线程ID只在它所属的进程内起作用。 1.7 出错处理 当UNIX系统函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值，文件&lt;errno.h&gt;中定义了errno以及可以赋予它的各种常量，这些常量都以字符E开头。
errno的两条注意规则：
如果没有出错，其值不会被例程清除；任何函数都不会将errno值设置为0，而且在&lt;erroro.h&gt;中定义的所有常量都不为0。 C标准中的两个用于打印出错信息的函数：
strerror：将errnum（通常就是errno值）映射为一个出错消息字符串，并且返回此字符串的指针； #include &lt;string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24c811cbf09c567a0ebb8818afa05ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac947488407e776684a5210d05f54b2/" rel="bookmark">
			洛谷B2003
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 洛谷B2003
题目描述
输入三个整数，整数之间由一个空格分隔。把第二个输入的整数输出。
输入格式
只有一行，共三个整数，整数之间由一个空格分隔。
输出格式
只有一行，一个整数，即输入的第二个整数。
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { long a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;b&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290dd7eccd9df07fd28f2eefbbc75202/" rel="bookmark">
			newrelic 与 springboot 整合 保姆级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot 与 newrelic 配置流程 1. 在newrelic官网注册账号(免费期为15-30天)： https://newrelic.com，注册登录
api key 快捷链接 https://one.newrelic.com/admin-portal/api-keys/home
2. 左侧点击菜单 APM &amp; Services 选择 add data 后面就是选择 可参考下面的步骤
3. 配置pom 会自动跳到官方文档
或者直接使用 https://docs.newrelic.com/install/java/
相当于根据2的步骤 推荐了官方配置步骤
pom.xml文件的配置
配置扩展项
&lt;dependency&gt; &lt;groupId&gt;com.newrelic.agent.java&lt;/groupId&gt; &lt;artifactId&gt;newrelic-java&lt;/artifactId&gt; &lt;version&gt;JAVA_AGENT_VERSION&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;type&gt;zip&lt;/type&gt; &lt;/dependency&gt; 这个步骤 是下载newrelic的jar包的zip文件 JAVA_AGENT_VERSION 这个地方需要我们更改对应的版本 可参考下面链接 选择版本 https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/ 配置 plugin(解压zip文件 mvn clean package 时才会操作)
&lt;!-- Unzip New Relic Java agent into target/ --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack-newrelic&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includeGroupIds&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/290dd7eccd9df07fd28f2eefbbc75202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/679b5a00ac740c53686f608a330db011/" rel="bookmark">
			http协议为何不安全？教你使用抓包抓取到登录时输入的账号密码！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 大家可以发现，在2023年，基本上需要用户输入数据的网站都是使用https协议，简单来说就是比http更安全，使用了更高级的加密方式，即使部分网站使用http协议，用户输入数据也会使用哈希函数或者其他加密方式，http协议为什么不安全呢？我们不妨亲自抓包感受一下，自己输入的账号密码可以直接被获取，我最近正在学习网络的东西，老师在课堂演示了一遍，我觉得很有意思，于是自己找了一个网站试一下，如果有什么问题欢迎大家批评指正。
抓包软件：科来（wireshark比较流行，科来全中文界面，而且可以帮你分析数据，对于初学者来说比较友好）
1、先设置过滤条件，只捕获http的数据包 2、点击上方的TCP会话 3、打开网站（我这里随便找了一个学校官网） 账号我随便写了一个当天日期，2023年4月1日，密码是123456，验证码是a7ru，然后点击登录 然后系统提示账号密码错误，不过没关系，本来就是编的。 4、打开科来查看 ok，我们发现有两条记录，一般是数据比较大的那一个会有我们的账号密码，我们点击第一个 URL中，POST是提交账号密码的，我们点击POST的那一行，下一步点击数据流，科来会自动帮你分析： 然后会发现这么一行数据： userAccount=&amp;userPassword=&amp;RANDOMCODE=a7ru&amp;encoded=MjAyMzA0MDE%3D%25%25%25MTIzNDU2 这行数据有一个关键字：password，而且那个a7ru是不是很眼熟？没错，就是我们当时输入账号密码的时候那个验证码，那也就是说着一行数据就有我们的账号密码,但是我们该如何分析呢？ userAccount：用户账号，值为空 userPassword：用户密码，值为空 RANDOMCODE：随机码，值为a7ru encoded：编码值，值为MjAyMzA0MDE%3D%25%25%25MTIzNDU2 这个字符串经过了 Base64 编码，并且包含了一个编码后的分隔符 “%%%”，当一个字符串包含百分号 “%” 时，通常表示它经过了 URL 编码，即使用特殊的编码方式将特殊字符转换为可在 URL 中安全传输的形式。在 URL 编码中，字符 “%” 用 “%25” 表示。因此，“%3D%25%25%25” 实际上是被编码的 “=%%%” 字符串。将 “%25%25%25” 转换为 “%%%”，就得到了 “=%%%”，这是一个编码后的分隔符，用于分隔两个编码的值。 MjAyMzA0MDE%3D%25%25%25MTIzNDU2 -&gt; MjAyMzA0MDE%%%MTIzNDU2 然后将编码后的字符串部分 “MjAyMzA0MDE” 和"MTIzNDU2"解码，可以使用任何 Base64 解码工具或库进行解码: MjAyMzA0MDE-&gt;20230401 MTIzNDU2-&gt;123456 因此，完整的解码后的字符串为 “20230401%%%123456”。是不是和我们账号密码一模一样嘞，如果我们连到了别人网络，别人可以通过这种方式抓取你的数据包，从而得到你的账号密码。而且这种已经属于Base64编码加密过的数据，有些http包数据直接就是明文显示：user=xxx&amp;password=xxxx，甚至不需要解码，更加的不安全。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5682173a124c67db2f6158a8323233bd/" rel="bookmark">
			【模板】最近公共祖先（LCA）——暴力&#43;倍增
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【模板】最近公共祖先（LCA） 题目描述 如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。
输入格式 第一行包含三个正整数 N , M , S N,M,S N,M,S，分别表示树的结点个数、询问的个数和树根结点的序号。
接下来 N − 1 N-1 N−1 行每行包含两个正整数 x , y x, y x,y，表示 x x x 结点和 y y y 结点之间有一条直接连接的边（数据保证可以构成树）。
接下来 M M M 行每行包含两个正整数 a , b a, b a,b，表示询问 a a a 结点和 b b b 结点的最近公共祖先。
输出格式 输出包含 M M M 行，每行包含一个正整数，依次为每一个询问的结果。
输入样例 #1 5 5 4 3 1 2 4 5 1 1 4 2 4 3 2 3 5 1 2 4 5 输出样例 #1 4 4 1 4 4 提示 对于 30 % 30\% 30% 的数据， N ≤ 10 N\leq 10 N≤10， M ≤ 10 M\leq 10 M≤10。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5682173a124c67db2f6158a8323233bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13c26a90900ad30fdb9094a07b4896f/" rel="bookmark">
			头歌python实训通关六——文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：读取CSV文件1 任务描述
本关任务：编写一个能读取csv文件的程序,将指定的文件按照要求的格式输出。
相关知识
为了完成本关任务，你需要掌握：1.csv模块
测试说明
平台会对你编写的代码进行测试：在你的程序的当前目录下存在一个book.csv文件，读取该文件的内容，并输出要求的内容和格式。
编程提示
测试输入：； 预期输出： 书名 python程序设计 数据结构 C语言程序设计 `
import csv def readcsv(): # 请在此处添加代码 # # *************begin************# csvfile=open('book.csv','r',encoding='utf-8') csvreader=csv.reader(csvfile) for row in csvreader: print(row[0]) csvfile.close() # **************end*************# if __name__ == '__main__': readcsv() 第2关：读取CSV文件2 任务描述
本关任务：编写一个能读取csv文件的程序，将指定的文件按照要求的格式输出。
相关知识
为了完成本关任务，你需要掌握：1.csv模块 2.列表
测试说明
平台会对你编写的代码进行测试：在你的程序的当前目录下存在一个book.csv文件，读取该文件的内容，并输出要求的内容和格式。
编程提示
测试输入： 预期输出： ['python程序设计', '39'] ['数据结构', '49'] ['C语言程序设计', '42'] `
import csv def readcsv(): # 请在此处添加代码 # # *************begin************# fc=open('book.csv','r',encoding='utf-8') lst=[] for line in fc: line = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13c26a90900ad30fdb9094a07b4896f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293e31bf0ad9201abee5351fe8cb3903/" rel="bookmark">
			oracle查询符号分隔字段，结果再分隔显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select listagg(b.check_part_name,';')within group(order by b.check_part_name) from DIC_CHECK_PART_DICT b where b.check_part_code in (SELECT REGEXP_SUBSTR(examPartCode, '[^;]+', 1, LEVEL, 'i') FROM DUAL CONNECT BY LEVEL &lt;= LENGTHB(TRANSLATE(examPartCode, ';' || examPartCode, ';')) + 1) examPartCode检查部位编码是‘1；2；3；4’ DIC_CHECK_PART_DICT 检查部位字典
查询结果‘检查部位1，检查部位2，检查部位3，检查部位4’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638508112292a30cbb2327d392f443f0/" rel="bookmark">
			[C语言]之数组的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一: 一维数组
1.1 数组的创建
1.2 数组如何初始化？
1.3数组的使用
1.4 数组在内存中的存储
二 : 二维数组
2.1 2维数组的创建和初始化
2.2 2维数组的使用
2.3 2维数组在内存中的存储
三. 数组的越界
四. 数组作为函数参数
五.接下来，我们使用数组完成冒泡排序！！
什么是数组？
数组是一组相同类型的元素的集合,
int arr[ ] = { }; 为一维数组 int arr[ ][ ] = { }; 为二维数组，当然也有三维数组，使用较少；
一: 一维数组 1.1 数组的创建 type_t arr_name [const_n]; //type是类型 arr 是 数组名 const是常量 //注:[ ] 在c99之前 里面必须是常量 c99之后 支持了变长数组的概念。 //如何正确的创建数组？ int arr1[10]; //代码2 int count = 10; int arr2[count];这里[]内不是常量 //代码3 char arr3[10]; float arr4[1]; double arr5[20]; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/638508112292a30cbb2327d392f443f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd33828478df154e8a61aed602367fc/" rel="bookmark">
			C语言基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一:什么是c语言？？？
1 第一个C语言程序：打印hello world
2 数据类型
(1) printf函数输出时类型表示
3 常量与变量
(1) 定义变量的方法
(2) 变量的分类
(3) 局部变量和全局变量
(4) scanf输入语句
常量的定义
4 字符串
5 转义字符
6 注释
7 选择语句 if
(1).if(表达式)
(2).if-else语句
(3).多重if-else语句
(4).嵌套if-else语句
8 循环语句
(1) while;
(2) for循环
9 函数
10 数组
11 操作符‘
12 常见关键字
一:什么是c语言？？？ 可自行百度：简单
来说如下
C语言是一门通用计算机编程语言，广泛应用于底层开发。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。
C语言是一门面向过程的计算机编程语言，与C++，Java等面向对象的编程语言有所不同。
其编译器主要有Clang、GCC、WIN-TC、SUBLIME、MSVC、Turbo C等。
1 第一个C语言程序：打印hello world #include&lt;stdio.h&gt; int main() { printf("hallo world!\n"); return 0; } //#include 是预处理过程 &lt;stdio.h&gt; 头文件 // 函数（printf）在使用前需要声明才能使用； //主函数main函数，它是程序的入口，一个工程中主函数（main）有且仅有一个； int main() { ； } 这是基本写法，在未来编程中，无处不在main函数；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd33828478df154e8a61aed602367fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64fee07988848f89e101dab4875e55e1/" rel="bookmark">
			（附源码）基于web的酒店预订及个性化服务系统 毕业设计241822
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		酒店预订及个性化服务系统
摘 要
信息化社会内需要与之针对性的信息获取途径，但是途径的扩展基本上为人们所努力的方向，由于站在的角度存在偏差，人们经常能够获得不同类型信息，这也是技术最为难以攻克的课题。针对酒店预订等问题，对酒店信息管理进行研究分析，然后开发设计出酒店预订及个性化服务系统以解决问题。
酒店预订及个性化服务系统主要功能模块包括首页、站点管理（轮播图、公告栏）用户管理（管理员、注册用户）内容管理（酒店资讯、资讯分类）更多管理（酒店分类、地区管理、酒店客房、客房预订）管理，采取面对对象的开发模式进行软件的开发和硬体的架设，能很好的满足实际使用的需求，完善了对应的软体架设以及程序编码的工作，采取MySQL作为后台数据的主要存储单元，采用SSM框架、Java技术、Ajax技术进行业务系统的编码及其开发，实现了本系统的全部功能。本次报告，首先分析了研究的背景、作用、意义，为研究工作的合理性打下了基础。针对酒店预订及个性化服务系统的各项需求以及技术问题进行分析，证明了系统的必要性和技术可行性，然后对设计系统需要使用的技术软件以及设计思想做了基本的介绍，最后来实现酒店预订及个性化服务系统和部署运行使用它。
关键词：酒店预定；SSM框架；MySQL数据库
Hotel reservation and personalized service system
Abstract
In the information society, there is a need for targeted information access, but the expansion of access is basically the direction of people's efforts. Due to the deviation of the perspective, people can often obtain different types of information, which is also the most difficult subject for technology to overcome. Aiming at the problems of hotel reservation, this paper studies and analyzes the hotel information management, and then develops and designs the hotel reservation and personalized service system to solve the problems.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64fee07988848f89e101dab4875e55e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315b4365b10e06324fffaeebff62c5ab/" rel="bookmark">
			信息学奥赛一本通 1388：家谱(gen) | 洛谷 P2814 家谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目链接】 ybt 1388：家谱(gen)
洛谷 P2814 家谱
【题目考点】 1. STL map 2. 并查集 【解题思路】 解法1：把名字转为整数 设置将名字与整数互相转换的映射。name2Num保存的键值对为(名字，编号)。可以将名字转为编号。
num2Name保存的键值对为(编号，名字)，可以将编号转为名字。
每输入一个名字，都先检查一下name2Num中是否有以该名字为键的键值对（即该名字是否出现过），如果之前没出现过，则为该名字分配一个新的编号。而后该名字对应的编号为name2Num[名字]
每个人都是用一个整数来表示的，那么就可以用树的双勤表示法（也就是并查集中的fa数组）来表示所有人之间的关系。
fa[x]为编号为x的人的父亲的编号。
如果输入的是父亲，用fatherNum记录父亲编号，在后面输入儿子时会用到。如果输入的是儿子，那么把儿子编号x的父亲设为fatherNum，即fa[x] = fatherNum如果查询某人多祖先，写出并查集中的查询函数find，find(x)的返回值即为x的祖先。 解法2：直接使用字符串 设map&lt;string, string&gt; fa，fa[x]表示名字为x的人的父亲的名字。
模仿并查集中的查询操作，写出find函数，求x的祖先。
如果输入的名字是父亲，且第一次出现。将该名字保存在father变量中，那么类似并查集中的做法，把father的父亲设为自己，即fa[father] = father。如果输入的名字是儿子，保存在child变量中。父亲名字已经保存在father变量，那么设父子关系fa[child] = father。如果要查询一个人的祖先，调用find函数。 【题解代码】 解法1：把名字转为整数 #include &lt;bits/stdc++.h&gt; using namespace std; #define N 50005 map&lt;string, int&gt; name2Num;//name2Num[名字]：编号 map&lt;int, string&gt; num2Name;//num2Name[编号]：名字 int fa[N]; void init(int n) { for(int i = 1; i &lt;= n; ++i) fa[i] = i; } int find(int x) { if(x == fa[x]) return x; else return fa[x] = find(fa[x]); } int n; int main() { int fatherNum; char c; string s; init(50000); while(cin &gt;&gt; c &gt;&gt; s &amp;&amp; s !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315b4365b10e06324fffaeebff62c5ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a42dd92928c205a11f208a5fab5f9e9/" rel="bookmark">
			Nginx正向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 需求直接上配置记录遇到的坑总结 需求 需要一套服务器对外，转发到另一个服务器
直接上配置 主要是server 配置，监听所有80端口请求转发到https://www.baidu.com;
#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; client_header_buffer_size 64k; large_client_header_buffers 4 64k; client_body_buffer_size 20m; fastcgi_buffer_size 128k; fastcgi_buffers 4 128k; fastcgi_busy_buffers_size 256k; gzip_buffers 16 8k; proxy_buffer_size 64k; proxy_buffers 4 128k; proxy_busy_buffers_size 256k; keepalive_timeout 240; fastcgi_connect_timeout 600; fastcgi_send_timeout 600; fastcgi_read_timeout 600; proxy_connect_timeout 600s; proxy_send_timeout 1200; proxy_read_timeout 1200; #log_format main '$remote_addr - $remote_user [$time_local] "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a42dd92928c205a11f208a5fab5f9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1103705ef9510481a98d8b424a5cedbc/" rel="bookmark">
			【在Linux中centos7上安装vscode】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 主要介绍在虚拟机中centos上如何安装vscode，已成功安装。
详细过程 1.打开终端 2.按步骤执行命令 sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc sudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" &gt; /etc/yum.repos.d/vscode.repo' 第一步，将上面第一条代码复制到终端执行
第二步，将上面第二条命令复制到终端执行
第三步，使用下面命令安装
yum check-update sudo yum install code 等待下载（亲测等了很久）
3.启动vscode 安装完成后，输入code，即可打开vscode，如下。
以上就是今天要讲的内容，本文简单介绍了vscode的安装（精简安装）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c233bb040690bfd7c6529e03b099c3/" rel="bookmark">
			GitLab-CI &#43; Harbor &#43; Kubernetes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitLab + GitLab CI + Harbor + Kubernetes 项目要求 该公司决定采用GitLab + GitLab CI + Harbor + Kubernetes架构来构建CICD环境，以缩短新功能开发上线周期，及时满足客户的需求，实现DevOps的部分流程，来减轻部署运维的负担，实现可视化容器生命周期管理、应用发布和版本迭代更新，请完成CICD环境部署。CICD应用系统架构如下：
环境准备 这里使用项目为2048游戏
项目地址： https://gitee.com/isicman/demo-2048.git
1.节点规划 使用Docker或者使用Kubernetes集群环境，这里使用的是Kubernetes集群环境。
IP地址主机名称主机资源节点名称10.11.121.111k8s-master12G/6VCPUGitLab+GitLab-Runner10.11.121.112k8s-node18G/6VCPUHarbor10.11.121.113k8s-node28G/6VCPUnode 2.查看集群状态 可以通过kubectl cluster-info命令查看当前的集群信息。 通过 kubectl get node查看当前节点数量。
[root@k8s-master ~]# kubectl cluster-info Kubernetes control plane is running at https://10.11.121.111:6443 KubeDNS is running at https://10.11.121.111:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. [root@k8s-master ~]# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master Ready control-plane,master 25h v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c233bb040690bfd7c6529e03b099c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1cf61d942d90283d4b121cc8f27aaad/" rel="bookmark">
			spring6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring6 备注：本文根据学习尚硅谷视频编写
1、概述 1.1、Spring是什么？ Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。
Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。
自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring 6。本课程采用Spring当前最新发布的正式版本6.0.2。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W1aKRldj-1680254824898)(images\spring6\image-20221201102513199.png)]
1.2、Spring 的狭义和广义 在不同的语境中，Spring 所代表的含义是不同的。下面我们就分别从“广义”和“狭义”两个角度，对 Spring 进行介绍。
广义的 Spring：Spring 技术栈
广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。
经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1cf61d942d90283d4b121cc8f27aaad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c42a1f5e83b64e3383a67557fdffb6/" rel="bookmark">
			标准帧和拓展帧的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 标准帧和拓展帧的区别标准帧的仲裁域拓展帧的仲裁域 标准帧和拓展帧的区别 ​ 标准帧和拓展帧的区别在于仲裁域，拓展帧拥有庞大的ID群，不会担心ID不够用的情况出现，以便扩展更多的CAN节点
​ 帧ID越小代表访问总线的消息优先级越高
标准帧的仲裁域 ​ 标准帧的仲裁域是连续的11位，可以出现2^11种报文，也就是帧ID的范围是000-7FF1
拓展帧的仲裁域 ​ 拓展帧的仲裁域是29位，可以出现2^29种报文，也就是帧ID的范围是0000-0000-1FFF FFFF
11位的二进制表示为十六进制的数字，帧ID一般都是十六进制的数字 ↩︎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a757a8bfe71d9036d8e2ffe93ea6319/" rel="bookmark">
			Kepware里一些特殊驱动说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		U-CON驱动：
有两种工作模式：一种是单向通讯，Kepware只是作为接收端不停地接收设备端发过来的数据，这种模式下Kepware只能作为Server端使用，典型应用为以太网接口（或使用串口转网络接口设备转换）的扫描枪设备；一种是双向通讯，Kepware(U-CON)需要主动发送命令给设备，设备再回复消息，采一问一答的方式（或者只问不答，设备只执行不回复），Kepware可以作为Server端或Client端使用。需要注意的是，在Kepware作为Client的时候，只有tag在被读取的情况下（即打开Quick Client查看tag状态，或其它应用在读取tag状态），Kepware才会连接到作为Server端的设备商（TCP/IP的连接）
MQTT Client驱动与IoT Gateway里的MQTT Client的区别：
前者是连接到MQTT Server上并订阅MQTT消息，收到的消息以tag的形式呈现；
后者是连接到MQTT Server上，把已有的tag（所有通道下的，不一定是MQTT的）的内容发送到MQTT Server上去。
ODBC Client驱动和Data Logger：
与MQTT类似，ODBC Client是连接数据库，把数据库的数据以tag的形式呈现；而Data Logger则是把当前项目下的所有的通道下的tag的值写到数据库里去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63230d7a09a03cc541f49f494e9298fa/" rel="bookmark">
			个人笔记：ESP8266发送POST请求调用API的一种方法——以TinywebDB的增删改查为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
TinyWebDB
代码讲解
整体代码
前言： 硬件：ESP8266主板、数据线
编译器：Arduino IDE
需要的库：&lt;ESP8266WiFi.h&gt; &lt;ArduinoJson.h&gt;
TinyWebDB TinyWebDB是一个非关系型数据库，它的数据结构是键值对（Key-Value）结构。在TinyWebDB中，每个数据项都有一个键和一个对应的值，键值对之间没有固定的关系，可以随时添加、删除和修改。TinyWebDB的数据库结构可以简单地表示为：
{
"key1": "value1",
"key2": "value2",
"key3": "value3",
...
}
其中，"key1"、"key2"、"key3"等表示键名，"value1"、"value2"、"value3"等表示对应的值。这种数据结构非常简单，但也非常灵活，可以存储各种不同类型的数据，包括字符串、数字、布尔值等。
在TinyWebDB中，每个数据项的键名是唯一的，如果添加了重复的键名，后面的键值会覆盖前面的键值。这种设计可以保证数据的唯一性和正确性。同时，由于TinyWebDB的数据结构非常简单，因此可以很方便地进行数据的查询、修改和删除操作。
总的来说，TinyWebDB的数据库结构非常简单，由键值对组成，这种设计具有灵活性和高效性，非常适合存储小规模的数据。TinyWebDB本是用于APP Inventor中的网络微数据库，但由于其简洁、轻量且免费，所以在此项目中被用来作为POST请求的操作对象。
以下是TinyWebDB服务器的网址，可以自行注册登录使用：
TinyWebDB服务器 - APPInventor网络微数据库http://tinywebdb.appinventor.space/
注册并登录后记住以下信息：
API地址：http://tinywebdb.appinventor.space/api
用户名（user）：your_username
密钥（secret）：your_secret
以及各种操作与各种参数要求。
代码讲解 首先是库的导入：
#include &lt;ESP8266WiFi.h&gt; #include &lt;ArduinoJson.h&gt; 该段代码使用了ESP8266WiFi和ArduinoJson两个库。
其中ESP8266WiFi库用于连接Wi-Fi网络，ArduinoJson库用于解析JSON格式的数据。
以及一些字段的定义：
const char* ssid = "Wifi_ID"; const char* password = "Wifi_password"; const char* host = "tinywebdb.appinventor.space"; // TinyWebDB的API地址 const int httpPort = 80; String user = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63230d7a09a03cc541f49f494e9298fa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/96/">«</a>
	<span class="pagination__item pagination__item--current">97/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/98/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>