<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86085332565960c27233bc8b8a61eb71/" rel="bookmark">
			Linux 系统下 docker 搭建和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 docker 搭建2 docker 使用2.1 查看 docker 镜像2.2 给镜像重名2.3 docker 常用命令2.4 docker启动常用命令2.5 容器操作2.6 保存容器为新的镜像2.7 文件传输2.8 挂载2.9 docker 服务的启动和关闭2.10 docker 镜像保存与导入2.11 docker 使用的主要命令 3 docker 存储目录的更改方法一：软链接（建议使用）方法二：直接更改目录方法 4 docker 使用小 tips，方便你我他的小设置4.1 用户权限问题，添加新用户后挂载目录无法读取。4.2 通过ssh 连接容器 5 docker 服务器搭建容器整体流程梳理docker 挂载docker container 的脚本文件在 notion 6 Docker 问答录7 搭建 wiki8 搭建 xwiki 1 docker 搭建 docker 官方文档地址： https://docs.docker.com/engine/reference/commandline/docker/
安装方法官方文档：https://docs.docker.com/engine/install/ubuntu/#prerequisites
单用户授权： https://docs.docker.com/engine/install/linux-postinstall/
# 卸载之前的docker sudo apt-get remove docker docker-engine docker.io containerd runc # 安装docker 需要的包 sudo apt-get update sudo apt-get install \ ca-certificates \ curl \ gnupg \ lsb-release # docker 添加证书 curl -fsSL https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86085332565960c27233bc8b8a61eb71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1996f8e46d4250acbb87ef1d67045bb/" rel="bookmark">
			jetpack compose系列（入门基础案例讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在上一章讲完compose的设计原理和基本概念之后，大家对compose的基本设计应该有了一个大概的了解，Jetpack Compose是在2019Google i/O大会上发布的新的库。Compose库是用响应式编程的方式对View进行构建,可以用更少更直观的代码，
更强大的功能，能提高开发速度（这一段是谷歌自己说的）。 说实话，View/Layout的模式对安卓工程师来说太过于熟悉，对于学习曲线陡峭的Jetpack Compose能不能学会还是有所担心，所以这一篇我们再来讲一些基本案例来为大家加深理解。
1. 教程 1.1 创建新的项目或导入库 Jetpack Compose是从Android Studio 4.2开始支持的，所以需要通过4.2(现在是canary版本)创建新的项目或者添加导入库。这里按照创建新的项目来进行介绍。
根据上图所示，在创建新的项目时需要选择Empty Compose Activity。
此时模块中的build.gradle文件会新增下列的库的依赖。
`dependencies { ... implementation 'androidx.ui:ui-layout:"${compose_version}"' implementation 'androidx.ui:ui-material:"${compose_version}"' implementation 'androidx.ui:ui-tooling:"${compose_version}"' ... }` 还有在模块的build.gradle文件中新增下列的设置。
`android { ... buildFeatures { compose true } composeOptions { kotlinCompilerExtensionVersion "${compose_version}" kotlinCompilerVersion "1.3.70-dev-withExperimentalGoogleExtensions-20200424" } }` 1.2 UI相关 1.2.1 @Compose 所有关于构建View的方法都必须添加@Compose的注解才可以。并且@Compose跟协程的Suspend的使用方法比较类似,被@Compose的注解的方法只能在同样被@Comopse注解的方法中才能被调用。
`@Composable fun Greeting(name: String) { Text(text = "Hello $name!") }` 1.2.2 @Preview 加上@Preview注解的方法可以在不运行App的情况下就可以确认布局的情况。
@Preview的注解中比较常用的参数如下：
name: String: 为该Preview命名，该名字会在布局预览中显示。showBackground: Boolean: 是否显示背景，true为显示。backgroundColor: Long: 设置背景的颜色。showDecoration: Boolean: 是否显示Statusbar和Toolbar，true为显示。group: String: 为该Preview设置group名字，可以在UI中以group为单位显示。fontScale: Float: 可以在预览中对字体放大，范围是从0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1996f8e46d4250acbb87ef1d67045bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0e26f424fcabf3227a53c75212e5fe/" rel="bookmark">
			零基础熟悉mmdetection3d数据提取、模型搭建过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本图文从介绍配置文件开始，逐步构建一个新的配置文件，并依次构建相关模型，最终使用一条点云数据简单走了一下处理流程关于mmdetection3d的安装，参考官方文档安装 — MMDetection3D 1.0.0rc4 文档 1、读取配置文件 1.1 mmdetection3d配置文件的组成 官方文档:教程 1: 学习配置文件 — MMDetection3D 1.0.0rc4 文档
在mmdetection3d中，主要思想是通过继承默认配置来实现自定义模型，当然，也可以将模型的所有配置写在一个文件里，按需使用。
配置文件存放于mmdetection3d/config目录下，其中**_base_目录为mmdetection3d自带的基础配置，即原始配置，从_base_**目录的组成来看，mmdetection3d将配置文件分为四种，分别是：数据集 (dataset)，模型 (model)，训练策略 (schedule) 和运行时的默认设置 (default runtime)
下面基于一个配置文件的部分内容，解释一下该怎么看
# configs/centerpoint/centerpoint_01voxel_second_secfpn_4x8_cyclic_20e_nus.py _base_ = [ '../_base_/datasets/nus-3d.py', '../_base_/models/centerpoint_01voxel_second_secfpn_nus.py', # 继承了这个模型的基础文件 '../_base_/schedules/cyclic_20e.py', '../_base_/default_runtime.py' ] model = dict( pts_voxel_layer=dict(point_cloud_range=point_cloud_range), pts_bbox_head=dict(bbox_coder=dict(pc_range=point_cloud_range[:2])), # model training and testing settings train_cfg=dict(pts=dict(point_cloud_range=point_cloud_range)), test_cfg=dict(pts=dict(pc_range=point_cloud_range[:2]))) 可以看出，在centerpoint_01voxel_second_secfpn_4x8_cyclic_20e_nus.py这个文件中，model部分只有一小段内容，这是因为继承了centerpoint_01voxel_second_secfpn_nus.py，只是在继承文件的基础上来修改或添加某些特定字段
为了方便说明，来一份简化版的配置文件
# configs/_base_/models/centerpoint_01voxel_second_secfpn_nus.py model = dict( type='CenterPoint', pts_voxel_layer=dict( max_num_points=10, voxel_size=voxel_size, max_voxels=(90000, 120000)), pts_voxel_encoder=dict(type='HardSimpleVFE', num_features=5), pts_middle_encoder=dict(), pts_backbone=dict(), pts_neck=dict(), pts_bbox_head=dict(), # model training and testing settings train_cfg=dict(), test_cfg=dict()) 为了查看具体网络是怎么实现的，我们首先从model最开始出发，根据配置文件，第一个字段为type，上述例子中使用了CenterPoint，我们需要在mmdetection3d/mmdet3d/models/detectors/__init__.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b0e26f424fcabf3227a53c75212e5fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118a043b73be866fe2ee833c1e5debfb/" rel="bookmark">
			【Flutter入门到进阶】Flutter基础篇---介绍与环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Flutter介绍 Flutter是谷歌公司开发的一款开源、免费的UI框架，可以让我们快速的在Android和iOS上构建高质量 App。它最大的特点就是跨平台、以及高性能。 目前 Flutter 已经支持 iOS、Android、Web、Windows、macOS、Linux等。
Flutter基于谷歌的dart语言，如果没有任何Dart语言的基础，不建议直接学习Flutter。建议先学习Dart 语言的基本语法。然后再进入Flutter的学习。
市面上已经有很多的混合App开发框架了，但是有些混合APP开发框架主要是针对前端开发者的：比如 ReactNative (基于React)、 Ionic (基于Angular、Vue、 React)。有些则是针对.Net平台针对.Net开 发者的比如： Xamarin
Flutter是谷歌基于Dart语言开发的一款跨平台的App开发框架。它针对的开发者是全部开发者。它的性 能相比RN、 Ionic这样的框架要更好一些。
Flutter在2019年的时候就拥有了非常高的关注度。 Flutter目前已经非常稳定，并且社区也非常完善了, 应用市场中新发布的新 应用有进一半是Flutter开发的应用。 Flutter3.x以后不仅支持了Android Ios App的跨平台开发，还支持 了Web、Windows、 MacOs、 Linux桌面应用的跨平台开发。全球很多公司都已经在商业项目中使用 Flutter，比如Google、微软、阿里、字节、百度、京东等。 Flutter 在 Github Star 数已经有150万了， 在跨端框架中排名第一。据官方统计截止到2022年6月，已经有超过50万个商业应用程序是用Flutter建 立的。Flutter是一个非常值得学习的框架，Flutter不仅具有跨平台、高性能等特点，还具有稳定性的特点，从2018年12月5日发布的Flutter1.0到后面的所有版本用法都是一样的。
2 资源地址 Flutter 官网： https://ﬂutter.dev/
Flutter Packages官网： https://pub.dev/
3 环境安装与配置 3.1 Windows上面搭建Flutter Android运行环境 3.1.1 电脑上面安装配置JDK 1、下载安装JDK
https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
2、配置JDK
1、系统变量 里面新增JAVA_HOME，设置值为java sdk 根目录：
2、系统变量 找到Path 在Path环境变量里面增加如下代码
;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin
3.1.2 电脑上下载安装Android Studio 1、安装dart与flutter插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/118a043b73be866fe2ee833c1e5debfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ae4f286435f83c10ba569cbaa08540/" rel="bookmark">
			数据库设计规范中之表的设计规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 表的设计是有一定标准的。通常当设计表时会有默认，但是有一套规定的规范。
可以看下面这个创建表的语句
注意点：
一定要有id，是主键。
所有的表都必须拥有公共字段。比如说id，乐观锁，创建人，创建时间，更信任，更新时间等
所有字段都要非空，要有默认值。
一般使用软删除，即update语句，只要把数据默认就好。不使用物理删除，即delete语句。
尽可能去遵循三大范式。不了解三大范式的可以看我的文章：数据库设计三大范式。（点击链接即可）。
然后对于数字类型的字段，不能只使用bigint，而要使用bigint unsigned。
自己理解的第六点：因为bigint unsigned是无符号的。而负数一般用不到。有0和正数，一般0用来表示默认值。因为非空，一定要有默认值
varchar类型的默认值设为32，而不是系统默认255.
自己理解的第七点：一般varchar类型的数据占不到255字节，甚至很小。所以默认值可不为255.而且整体空间是一样的，如果varchar定义得太大，留给后续新加字段使用的空间就越少。
当然实际情况还有看你们公司或机构的规范。根据实际情况而来。
最后，上面的表内容我放在下面。
CREATE TABLE `t_friend_chat` ( `id` bigint unsigned NOT NULL COMMENT '主键id', `from_user_id` bigint unsigned NOT NULL DEFAULT '0' COMMENT '消息发送者', `to_user_id` bigint unsigned NOT NULL DEFAULT '0' COMMENT '消息接收者', `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '消息内容', `content_type` int unsigned NOT NULL DEFAULT '0' COMMENT '消息类型', `server_from_recall` int unsigned NOT NULL DEFAULT '0' COMMENT '服务器有没有给发送者回调', `server_to_send` int unsigned NOT NULL DEFAULT '0' COMMENT '服务器有没有给接受者发送消息', `server_to_recall` int unsigned NOT NULL DEFAULT '0' COMMENT '服务器有没有收到接受者的回调', `status` int unsigned NOT NULL DEFAULT '0' COMMENT '状态(0,未完成，1，已完成，2，撤回)', `finish_time` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '消息发送成功时间', `withdraw_time` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '消息撤回时间', `revision` int unsigned NOT NULL DEFAULT '0' COMMENT '乐观锁', `creator` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '创建人', `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `updater` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '更新人', `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `del_flag` int unsigned NOT NULL DEFAULT '0' COMMENT '删除标志（0，未删除，1删除）', PRIMARY KEY (`id`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC COMMENT='好友聊天'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfaa5fbacc9a02c5ee5c03e992f4fc16/" rel="bookmark">
			基于Simulink对调制-解调系统的仿真（BASK&#43;BFSK&#43;BPSK）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
项 目四阶段一报告 1
一 、调制-解调系统的基本原理 1
1.1 BASK 1
1.1.1 调制原理 1
1.1.2 解调原理 1
1.2 BFSK 2
1.2.1 调制原理 2
1.2.2 解调原理 2
1.3 BPSK 3
1.3.1 调制原理 3
1.3.2 解调原理 3
二 、基于Simulink对调制-解调系统的仿真 3
2.1 BASK 3
2.2 BFSK 5
2.3 BPSK 6
三 、信道环境对信号的影响 8
四 、附录 8
4.1 SNR-BER绘图源码 9
上图为BASK仿真系统的结构，可分为调制、信道、解调、输出、检测五大模块。
调制
【伯努利二进制数生成器】1秒设10k个采样点，即基带信号频率为10kHz。
【正弦波】根据采样定理，采样点不能少于20k个；由于是模拟仿真，我们直接设100k个采样 点。又因载波频率应远大于基带信号频率，所以我们取正弦波频率为100kHz。
信道
【加性高斯白噪声】模拟真实信道的噪声，这里设SNR=2。
解调
【带通滤波器】下通带截止频率为90kHz（载波频率-信号频率），上通带截止频率为110kHz
（载波频率+信号频率）。
【正弦波】由BASK原理可知，参数与调制载波严格一致。
【低通滤波器】截止频率为10kHz（信号频率），因为要把200kHz左右的成分滤掉。
【滞回比较器】阈值需要根据示波器输出进行调试，最终确定在0.25。
输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfaa5fbacc9a02c5ee5c03e992f4fc16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6378f99f33f5a75d3a164140745c53b/" rel="bookmark">
			算法-双指针（Java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法-双指针（Java实现） 双指针-合并两个有序的数组
双指针-判断是否是回文字符串
双指针-合并区间
双指针-最小覆盖子串
双指针-反转字符串
双指针-最长无重复子数组
双指针-盛水最多的容器
双指针-接雨水问题
双指针-合并两个有序的数组 合并两个有序的数组 描述：给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组
数据范围： 0≤n,m≤100，∣Ai∣&lt;=100，∣Bi∣&lt;=100
注意：
1.保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n
2.不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印
3.A 数组在[0,m-1]的范围也是有序的
示例2 输入：
[1,2,3],[2,5,6]
返回值：
[1,2,2,3,5,6]
import java.util.*; public class Solution { public void merge(int A[], int m, int B[], int n) { int[] res = new int[m+n]; int i=0,j=0,r=0; while(i&lt;m &amp;&amp; j&lt;n){ //遍历A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6378f99f33f5a75d3a164140745c53b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5401199cd94f96f4c3bb8c01ae9914ea/" rel="bookmark">
			【项目展示】基于Unity开发的3DRPG游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 项目为大四毕业设计的游戏内容部分，使用Unity3D开发，总代码6000+行，全部为自己实现，主要是一套简单的代码框架，具备一定的扩展性。游戏中填充了第一关的内容以展示功能。（仍然有许多改进空间）
战斗系统 在动画中添加事件从而调用伤害判定函数，使用Cast函数进行伤害检测
交互系统 使用Physics.Raycast()检测屏幕中央可交互物体，目前游戏中包含对话物、拾取物、宝箱三类可交互物体
物品系统 ScriptableObject实现的物品配置
通过实现IBeginDragHandler、IDragHandler、IEndDragHandler、IPointerDownHandler、IPointerEnterHandler、IPointerExitHandler、IPointerClickHandler七个接口，从而实现拖动更换物品所在的物品格、光标悬浮时显示物品详细信息、点击以使用/购买/出售物品的功能
AI系统 使用Navigation来对AI进行控制，从而在移动时自动避开障碍物。目前包含四类AI：
士兵：通过判断与玩家之间的距离改变行为模式，远距离时在自身一定范围内游走待机，中距离时主动向玩家移动，近距离时攻击或后撤野猪：在初始位置周围选取固定坐标并来回游走，在受到攻击后会改变移动速度进入奔跑状态野兔：类似于野猪，但在玩家靠近时便会逃走村民：在配置好的路径点之间来回移动，并在对应位置播放待机动画 展示 3DRPG项目展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378cda979da0a8a1e8e0ee9dcedbe14b/" rel="bookmark">
			多线程之线程的常见方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程的常见方法：
1、wait()：使一个线程处于等待状态
会释放持有的对象锁，进入等待此对象的锁定池(lock blocked pool )，直到针对此对象调用notify()/notifyAll()被唤醒，释放同步锁使线程回到可运行状态（Runnable）
2、sleep()：使一个线程处于睡眠（阻塞）状态。
调用此方法过程中线程不会释放对象锁。它会导致程序暂停执行指定的时间，让出cpu给其他线程，但是它仍然保持对Thread的监控状态，直到指定的时间结束后又会自动恢复可运行状态（Runnable）
3、notify()：使一个等待状态的线程唤醒。
并不能确切唤醒等待状态线程，是由JVM决定且不按优先级
4、allnotify()：使所有等待状态的线程唤醒。
并不是给所有线程上锁，而是让它们竞争
5、join()：等待该线程结束，才能执行其他线程。
join方法的作用是阻塞线程，即等待线程结束，才继续执行
6、yield(）：提示线程调度器让出当前线程对CPU的使用
调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084936335f65d3e61fa84376d84fe0bf/" rel="bookmark">
			第三方软件测试机构需要具备哪些资质?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是第三方软件测试机构?
第三方软件测试机构是区别与软件开发方与需求方的第三方检测机构，因为与软件产品本身无利益关系且有着丰富的测试经验，操作软件测试过程更为专业熟练，得到的测试结果更真实客观，为软件产品的质量保驾护航。
二、第三方软件测试机构需要具备的资质
1、CMA认证
CMA是中国计量认证的英文简称，是由省级以上人民政府计量行政部门对检测机构的检测能力及可靠性进行的一种全面的认证及评价，是强制认证的资质。
2、CNAS认可
CNAS是中国合格评定国家认可委员会的简称，是国家行政部门授权的国家认可机构，负责对实验室进行检测资质认定，是实验室自愿进行认可的。通过CNAS认可的检测机构可以在产品检测报告上加盖CNAS标记，表示对该产品的一种权威认可，具有公信力，同时，该检测机构也会受到CNAS机构的监督与约束，不能随意滥用检测资质。
三、软件测评收费标准
软件测评的价格是随着测试功能点和项目大小来决定的，时间和地域的不同，不同第三方软件测试机构的收费也会有所差异，因此行业内并无统一具体的收费标准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc2326838b9318fea7e3c65a57a929e6/" rel="bookmark">
			git使用pull 远程仓库到本地——清除本地修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开发者 A 发布了一个版本v1
开发者 A 在自己本地修改了文件，没有提交commit没有satge缓存
开发者 B 在v1 基础上修改了，发布了 V1.1
开发者A 要同步到 V1.1
本地 working tree 下文件修改，没有进行satge和 commit先 git reset 到最后一个 commit 的版本git cleanup ，清理掉不要的且未保存到本地库的本地文件pull 或 sync 远程，更新到远程最新版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6d7978eeb435c3c9cbe6876d612d65/" rel="bookmark">
			解决ubuntu 22.04上teamViewer/toDesk闪退等问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：同时安装teamviewer和向日葵等远程控制软件，同时开，g了一个用另一个重启。
向日葵官网下载：https://sunlogin.oray.com/download/linux
teamviewer下载办法：https://cloud.tencent.com/developer/article/1652777
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6715d56f46065caafafa12d32407a8fd/" rel="bookmark">
			实战：通讯录的实现(附带源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 今天我们的目标是，写出我们自己满意的通讯录。实现通讯录的五个功能：增，删，查，改，示，也就是增加联系人，删除联系人，查找联系人，修改联系人信息，展示联系人。那就让我们进入主题吧。
文件建立： 我们分别建立3个文件：一个头文件和两个源文件。
①.头文件Contact.h： 该文件是用于包含其它头文件，并且存放功能实现函数的函数声明。好处就是可以整合整个程序中所用到的全部头文件和函数声明，一目了然。并在引用时只需引用Contact.h头文件。
②.函数定义文件Contact.c： 这个文件主要是用于书写所有的程序功能实现的函数定义。一、将所有定义书写在一起方便我们进行阅读，修改；二来大大提升了程序的可移植性，当他人想要使用我们定义的函数时，只需将整个Contact.c文件发送给对方即可；最后也可以将其设置为静态库从而实现我们函数代码的隐藏。
③.工程测试文件test.c： 这文件里所书写的是我们程序主体部分，并对程序进行执行逻辑的编辑和检查。结合前面两个文件的使用，可以使得我们的程序逻辑变得清晰，既有利于我们进行程序的运行逻辑检查。
通讯录整体实现思路： 首先我们定义两个函数，menu为菜单函数，负责向玩家打印游戏菜单，Contact为通讯录功能函数，负责实现整个通讯录功能的实现。当程序开始编译运行后，首先执行菜单函数供玩家选择功能，接着执行Contact函数实现玩家选择的功能。
//菜单 void menu() { printf("*************************************\n"); printf("*************************************\n"); printf("*************************************\n"); printf("*************************************\n"); printf("*************************************\n"); printf("*************************************\n"); printf("*************************************\n"); printf("*************************************\n"); } //实现通讯录功能函数 void Contact() { } int main() { menu(); Contact(); return 0; } 同时，我们在使用通讯录时，往往会出现一次性添加、删除或修改多个联系人信息的场景，于是我们就需要让我们的程序多次循环执行：
void Contact() { int input = 0; do { menu(); printf("请您进行选择："); scanf("%d", &amp;input); switch (input) { case 1: break; case 2: break; case 3: break; case 4: break; case 5: break; case 0: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6715d56f46065caafafa12d32407a8fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd593f187e641d72fd86df005eda837/" rel="bookmark">
			python实现Dijkstra算法求解最短路径问题（Shortest Path Problem）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 最短路径问题2. 求解算法2.1 Label Algorithm2.1.1 Dijkstra algorithm2.1.2 python代码实现Dijkstra算法 2.2 python调用SCIP求解器求解最短路径问题 3. 算法结果参考文献 1. 最短路径问题 最短路问题（Shortest Path Problem，SPP）是图论的一个经典问题，其目的在于寻找网络中任意两个节点间的最短路径，这里的最短可以衍生为距离最短、费用最小、时间最短等一系列度量。当前的涌现了很多最短路径的变种，如带资源约束的最短路径问题（Shortest Path Problem with Resource Constraints, SPPRC）等；
数学模型
m i n ∑ ( i , j ) ∈ A c i j x i j ∑ j ∈ V x i j − ∑ j ∈ V x j i = { − 1 , i = s 0 , i ≠ s a n d i ≠ t 1 , i = t min\sum_{(i,j)\in A}{c_{ij} x_{ij}}\\ \sum_{j \in V}x_{ij} - \sum_{j\in V}x_{ji} = \begin{cases} -1, &amp; {i = s } \\ 0, &amp; {i \neq s \quad and \quad i \neq t}\\ 1, &amp; {i=t}\\ \end{cases} min(i,j)∈A∑​cij​xij​j∈V∑​xij​−j∈V∑​xji​=⎩ ⎨ ⎧​−1,0,1,​i=si=sandi=ti=t​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cd593f187e641d72fd86df005eda837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14b0783ef1e200362bcc65b334784592/" rel="bookmark">
			进程、线程、Core、OS Application、task、event、runnable、SWC、port的区别与联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程： 进程是资源分配的最小单位，进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是系统进行资源分配和调度的基本单位。进程是一个动态的概念，是一个活动的实体。
“独立功能”表示进程是面向使用者的定义，它关心的是要做什么？比如，在电脑上我要写一篇文章，打开Word。那么计算机就会创建一个Microsoft Word的进程，如果我想同步写两篇文章，就要再打开一个Word，计算机就又创建一个Microsoft Word的进程。普通的计算机机可以同步做几件事情，比如“上网”，“看电影”，“打游戏”，就是说可以运行很多进程。但是嵌入式计算机通常设计成只做一件事情，比如在汽车领域，整车控制器VCU，发动机喷油点火控制器ECU，变速箱换挡控制器TCU，车身控制器BCM等。这样类比，传统的一个电子控制单元ECU相当于只运行一个进程。
线程： 线程是程序执行的最小单位，也是处理器调度的基本单位，是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等）
当我们提及多线程的时候会想到thread和threadpool，这都是异步操作，threadpool其实就是thread的集合，具有很多优势，不过在任务多的时候全局队列会存在竞争而消耗资源。thread默认为前台线程，主程序必须等线程跑完才会关闭，而threadpool相反。
小结：threadpool确实比thread性能优，但是两者都没有很好的api区控制，如果线程执行无响应就只能等待结束，从而诞生了task任务。
对比进程与线程： 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据，使用相同的地址空间，因此，CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程小很多。线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行（如队列，信号，管道，接套字等）。不过如何处理好同步与互斥是编写多线程程序的难点。但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也跟着死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。 Core： 可以理解为就是ECU,一个核就代表一个进程。多核就是多个ECU。也就是说在多核的情况下，可以执行多进程。
不论是进程还是线程，一个cpu核一个时刻就只能干一件事，所以一个cpu核处理多个线程或者进程的话，都是并发；
对于多核心的架构，由于共用一套MMU和cache，所以地址空间是一个，同一时刻只能运行一个进程，此时进程不能并行只能并发。同一个进程下的多线程可以并行执行，因为多线程共享同一套进程空间资源。
OS Application： 说明1：Task、Interrupt、Alarm、schedule Table、Resource、Event 我们称他们叫对象(Object)
说明2：【OS 包含1~N个Core】-&gt;【1个Core 包含1~N个Application，相当于一个core可以运行多个进程，一般AUTOSAR Aurix定义两个进程，一个trusted，一个nontrusted】-&gt;【1个Application 包含0~N个Object，也就是一个OS-Application包括多个任务Task】
不论是进程还是线程，一个cpu核一个时刻就只能干一件事，所以一个cpu核处理多个线程或者进程的话，都是并发；
AUTOSAR OS必须能够支持构成一个有多功能单元的Operating System objects (Tasks, ISRs, Alarms, Schedule tables, Counters)的集合。此对象集合称为 OS-Application
OS Application分为两类，一类是Trusted, 一类是Non-Trusted
对于Trusted OS Application，可以运行在监控或保护功能关闭的情况下，对于内存或者OS Api的访问没有限制；如果处理器支持，可以运行在特权模式，OS默认Trusted类型的OS Application不会引发内存相关故障，如果发生了内存故障，系统稳定性将不再保证，可能需要关闭OS。
对于Non-Trusted OS Application，不允许关闭监控或保护功能，对于内存或OS Api的访问也受权限控制，也不允许运行在特权模式。对于non-trusted OS Application，操作系统会保护MPU，timer，中断控制器等控制寄存器，不允许修改。如果需要修改这些寄存器，那么OS服务必须执行在特权模式。如果ISR Handler在non-trusted OS Application中，那么OS需要在ISR() wrapper中先切换到非特权模式，再执行ISR handler。
task： 在嵌入式操作系统里，任务就是线程的意思。
AUTOSAR OS中存在两种任务：基本任务(Basic Task)和扩展任务（Extended Task）。基本任务则存在以下三种状态：
运行状态(Running)：
处于运行状态的任务可能被高优先级任务或者中断抢占从而进入就绪状态，且同一Core中任何时刻只会存在一个任务处于运行状态，任务运行结束后则将自己挂起进入阻塞状态；
就绪状态(Ready): 处于就绪状态的任务由调度器决定是否启动进入运行状态，且该状态时任务切换至运行状态的前提；
阻塞状态(Suspend): 处于阻塞状态的任务是被动的，可以由API函数或Alarm激活进入就绪状态；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14b0783ef1e200362bcc65b334784592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef53139f3d134914147c209891a25d75/" rel="bookmark">
			java将数据存入excel中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java将数据存入excel中 下面将由方法分开展示步骤，以及合并方法展示步骤两部分组成。
可直接观看第二部分合并后的方法即可，便于快速使用
文章目录 java将数据存入excel中1，分开方法展示步骤分开方法展示java将数据存入excel中的步骤 2，进行方法的合并2.1 合并方法，将java将数据存入excel中2.2 进行测试 1，分开方法展示步骤 分开方法展示java将数据存入excel中的步骤 //创建sheet页 public static void setSheet(String sheetName) { workbook = new XSSFWorkbook(); sheet = workbook.createSheet(sheetName); } //创建表头 public static void createHead(List&lt;String&gt; headList) { //创建表头，也就是第一行 row = sheet.createRow(0); for (int i = 0; i &lt; headList.size(); i++) { cell = row.createCell(i); cell.setCellValue(headList.get(i)); } } //创建表内容 public static void createContent(List&lt;List&lt;String&gt;&gt; contentList) { //创建表内容，从第二行开始 for (int i = 0; i &lt; contentList.size(); i++) { row = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef53139f3d134914147c209891a25d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b8880eb7ffaea7189dcdeb2e9ec3a3/" rel="bookmark">
			SSL/TLS 介绍以及如何利用openssl生成证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 SSL:Secure Socket Layer 安全套接字层。
TLS:Transport layer Security 传输层安全性，是一种加密协议。
发展历程 到2020年，SSL以及TLS1.0，TLS1.1已被弃用
TLS用在哪里？ 为什么用TLS？ Authentication:通信双方可以确认双方的身份，不被黑客拦截信息伪造身份。
Confidentiality：通信的内容经过加密，更加安全,不被授权的用户无法识别内容。
Integroty：通讯内容可以查出是否被破坏。
TLS是怎么工作的？ 两阶段：
握手阶段，双方通过非对称加密通信，建立连接，传输用于加密数据的对称秘钥
通信阶段，双方通过对称秘钥加密数据，互相通信
为什么TLS同时采用了非对称加密和对称加密呢？
只用对称加密的话，我们不能保证双方在商量秘钥是什么的情况下秘钥在网络传输中不被泄露，也不能确认信息是否被修改了。
如果只用非对称加密的话，它比对称加密的效率要低上成千上万倍。
对称密码学 一般对称加密方式，发送方和接收方共享一个秘钥，发送方利用秘钥加密，接收方利用秘钥解密。
上述的加密，黑客可以对信息拦截并进行位翻转来进行攻击。请看下面的例子。
由于信息可能会被篡改，所以现在还需要进行验证信息的真伪。
所以要为传输的信息附上验证信息。
带有验证信息的对称加密过程： 根据秘钥 secret key和初始向量 IV 通过对称加密算法，对明文进行加密。
将秘钥，初始向量，密文通过MAC算法，生成HASH串，作为验证code。使用MAC算法时我们还可以添加一些附加信息，这些信息是明文的，且应当是双方知道的。
将验证code附加到密文上，一起传输。
带有验证信息的解密过程： 将验证信息取出。
将秘钥 ，IV，附加信息，密文通过MAC算法得到新的hash串。
比较两个hash串是否一致，一致就可以通过秘钥和IV进行解密得到明文
现在还存在一个问题？双方是怎么共享秘钥的？ 为了保证传输过程中秘钥的安全性，我们通过非对称加密来共享秘钥。非对称加密的具体流程在下面有专门的讲述。
首先双方生成各自的私钥和公钥，生成的算法有很多，RSA算法，ECC算法（与椭圆曲线有关）
下面介绍的是Diffile-Hellman Ephemeral（DHE）
g是一个公知的幂的底,p为公知的一个模。g,p是双方都认可的一个值
双方各自选择一个值作为自己的私钥，比如说发送方为a，接收方为b。
然后双方计算出各自的公钥A,B，并且传送给对方。
双方收到后通过计算可以得到S，这个值双方计算出来是一样的。如何计算看下图。
双方就可以通过S这个共享秘钥来进行数据加密。
现在还存在一个问题，S的长度是不固定的，我们还需要用HKDF进行一次转换，把它转换为确切长度的key。
HKDF(H mark base key derivation functon) p,g,A,B对公众来说都是已知的，黑客是否可以通过p,g,A,B算出a,b的值来呢？
我们可以看到 p有2048bit,a,b各有256bit。
算法很简单，但是很难算出来
但是如果我们多次对话都用同样的a,b的话，早晚会被算出来
所以我们应使用临时秘钥，每一次会话都重新商议秘钥
成熟的非对称加密算法有RSA，EEC
RSA：类似于刚才说的那种生成私钥和公钥的方法。
EEC: 在生成公钥和私钥时，用到的椭圆曲线。具体如何不展开。
下面是EEC,RSA秘钥位数与安全级别的对比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0b8880eb7ffaea7189dcdeb2e9ec3a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d52c364a0cab429f04593b0353f624/" rel="bookmark">
			Android 开发者指针位置调试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象 系统开发者选项中，开启指针位置调试后发现一些界面按钮等点击无反应。
代码分析 通过代码看：开启指针位置调试是修改 Settings.System.POINTER_LOCATION 属性值。而系统 WMS 中通过 SettingsObserver 内部类监听此属性值变化，执行 updatePointerLocation() 函数，最后在 DisplayPolicy::enablePointerLocation() 方法中创建 PointerLocationView 添加到系统窗口中。t同时对系统Input事件加入监听等。
而系统 View 的 dispatchTouchEvent 方法中，有一个 onFilterTouchEventForSecurity 判断条件
/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */ public boolean dispatchTouchEvent(MotionEvent event) { // If the event should be handled by accessibility focus first.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d52c364a0cab429f04593b0353f624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16fcd97ee127c54c8190eed3b9dbcbc/" rel="bookmark">
			字节跳动青训营--Webpack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、为什么要学习Webpack？二、什么是Webpack？1. 产生背景2. 基础概念 三、使用Webpack1. 安装2. 编辑配置文件3. 执行编译命令核心流程 四、如何使用Webpack流程类配置配置总览 五、理解Loader六、理解插件插件钩子 课外关注资料 前言 此文章仅用来记录学习。
一、为什么要学习Webpack？ 理解前端工程化概念、工具、目标一个团队总要有那么几个人熟悉Webpack，某种程度省可以成为个人的核心竞争力高阶前的段必经之路 二、什么是Webpack？ 1. 产生背景 在过去主要是通过手动管理这些资源，这会导致出现大量的问题：
依赖手工，比如有50个JS文件…操作，过程繁琐当代码文件之间有依赖的时候，就得严格按依赖顺序书写开发与生产环境一致，难以接入TS或JS新特性比较难接入Less、Sass等工具JS、图片、cSS资源管理模型不一致 由于上诉问题的出现，就衍生出了很多现代化工具：webpack，vite，rollup，gulp等等
2. 基础概念 概念：用于现代 JavaScript 应用程序的静态模块打包工具
多份资源文件打包成一个 Bundle支持 Babel、Eslint、TS、CoffeScript、Less、Sass支持模块化处理 css、图片 等资源文件支持 HMR + 开发服务器支持持续监听、持续构建支持代码分离支持 Tree-shaking支持 Sourcemap… 三、使用Webpack 1. 安装 npm i -D webpack webpack-cli 2. 编辑配置文件 module.exports = { optimization:{ minimize: false // 关闭代码压缩，可选 }, entry: "./src/index.ts", output: { path: path.resolve(__dirname, "dist"), filename: "bundle.js", environment: { arrowFunction: false // 关闭webpack的箭头函数，可选 } }, module: { rules: [{ test: /\.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16fcd97ee127c54c8190eed3b9dbcbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1682e24232ee5585073c5441d6bfbc/" rel="bookmark">
			CSDN编程竞赛·第31期赛后分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次的题目不算难，但是没有满分的，应该都是最后一题只拿到了10%的得分，在此分享一下我的解答给大家~~
欢迎一起讨论最后一题的题解~
1、题目名称:最优利润值 你在读的经营课程上，老师布置了一道作业。在一家公司的日常运营中，是会对一些商品的价格走势根据一些经验和数据 进行预估，并据此进行决策。例如，假设某商品每天的价格都有可能变动，我们要做的就是低买高卖获得最高利润。比如 假设我们预估该商品接下来七天内的价格走势如下: 4 1 2 3 6 4 8 那我们采取的最佳策略是在价格1块钱的时候买入，在 价格8块钱的时候卖出。为了简化整个过程，我们限定在此周期内只能有一次买入一次卖出，且商品在没有购入前是无法 卖出的，即该商品不是期货而是现货。 现要求你用程序来实现自动决策。输入一定天数的商品预估价格，自动计算出最优 利润值。例如，上面的例子中，最优利润值为8-1=7。(简单起见，只考虑0-100000之间的整数价格)。
题解如下： import java.util.ArrayList; import java.util.Scanner; class Main { public static void main(String[] args) { Scanner scan = new Scanner(System.in); String str_0 = scan.nextLine(); String[] line_list_0 = str_0.trim().split(" "); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; line_list_0.length; i++) { arr.add(Integer.parseInt(line_list_0[i])); } scan.close(); int result = solution(arr); System.out.println(result); } public static int solution(ArrayList&lt;Integer&gt; arr){ int result = 0; // TODO: 请在此编写代码 for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1682e24232ee5585073c5441d6bfbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497340c0b51331c0a0f9363999f66be0/" rel="bookmark">
			Android Button修改背景颜色及实现Button水波纹效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Button修改背景颜色及实现Button水波纹效果，效果如下：
以下基于API33（Android13.0），向下兼容至API24（Android7.0）。
1.修改Button背景 我们可以发现在布局xml文件中直接修改background是没有作用的，会变成默认的主题色（themes.xml中的colorPrimary颜色，默认为紫色）
&lt;Button android:id="@+id/dialog_button" android:layout_width="match_parent" android:layout_height="40dp" android:layout_centerHorizontal="true" android:layout_marginTop="105dp" android:background="@drawable/ripple_grey_e" android:text="确定" android:textColor="@color/grey_3" android:textSize="@dimen/main_text" tools:ignore="TouchTargetSizeCheck" /&gt; 这是由于在Android4.1之后的开发中创建的Button是Material类型的，默认使用主题色的，所以我们需要替换主题色或者使用非Material类型的Button，修改如下：
&lt;android.widget.Button android:id="@+id/dialog_button" android:layout_width="match_parent" android:layout_height="40dp" android:layout_centerHorizontal="true" android:layout_marginTop="105dp" android:background="@drawable/ripple_grey_e" android:text="确定" android:textColor="@color/grey_3" android:textSize="@dimen/main_text" tools:ignore="TouchTargetSizeCheck" /&gt; 将Button修改为android.widget.Button标签即可。
2.实现按压水波纹效果 首先在drawable文件夹中创建ripple类型的xml文件，例如我创建的ripple_grey_e.xml文件：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;ripple xmlns:android="http://schemas.android.com/apk/res/android" android:color="@color/grey_e"&gt; &lt;item android:drawable="@color/selector_btn_transparent"/&gt; &lt;/ripple&gt; 其中的@color/grey_e为colors.xml文件中定义的颜色（这个颜色就是水波纹的颜色，此处为浅灰色#eeeeee，示例动图中为使效果明显替换为了深灰色#333333），@color/selector_btn_transparent为color文件夹（推荐自建，也可以放在drawable文件夹中），selector_btn_transparent.xml内容如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--按压下时--&gt; &lt;item android:state_pressed="true" android:color="@color/grey_f7" /&gt; &lt;item android:color="@color/transparent"/&gt; &lt;/selector&gt; grey_f7为浅灰色（#f7f7f7），transparent为透明色（#00ffffff）。
使用如下：
&lt;android.widget.Button android:id="@+id/dialog_button" android:layout_width="match_parent" android:layout_height="40dp" android:layout_centerHorizontal="true" android:layout_marginTop="105dp" android:background="@drawable/ripple_grey_e" android:text="确定" android:textColor="@color/grey_3" android:textSize="@dimen/main_text" tools:ignore="TouchTargetSizeCheck" /&gt; 本示例采用颜色较浅，如果想使效果更加明显，可以将颜色换为更加明显的颜色。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5009b6d7264786e4727967b2bfa3398/" rel="bookmark">
			Python 自动交替排班
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路：假设7人，每人最多只能连续上六天班。六个时间段
1.每次排六位，再将排完的前一位追加到列表后面
2.将排完的前一位删除
这样每次得到的新列表就只有六人，剩一人休息
代码：貌似还要pip下某个库，运行会提示
import pandas as pd # 六个时间段循环排班 def gen_data(n): data = [] # 存入每次排班的数据 employee = ['天谷','九环','大圣','不空','天音','杀憎','菩提'] # 原始员工及顺序数据 for i in range(n): data.append(employee[:6]) # 排班，排进6人 employee.extend(employee[:1]) # 前1个人追加到列表后总 del employee[:1] # 删除前1个，下次就休息了 return data index_rows=pd.date_range(start='2023-03-01', periods=31) # start为日期，periods为天数 index_colums=['9-14','14-19','19-24','9-14','14-19','19-24']#定义列字段 df = pd.DataFrame(gen_data(31), index=index_rows,columns=index_colums )#gen_data()修改为天数 df_T=pd.DataFrame(df.values.T,columns=index_rows,index=index_colums)#转置 print(df_T) df_T.to_excel('时间段排班-202303.xlsx') 结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79512b106ee57172e4291eb98a1d750/" rel="bookmark">
			HAL库学习02---按键（中断和扫描）控制LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、硬件设备 STM32F103ZET3开发板
STLink
1、实现功能 上电初始化后，LED0灯灭；
当按键按下时LED0状态翻转；
3、原理图分析 LED灯原理在上节已经解释，这节不再赘述，这里共有两个按键分别为KEY0、KEY1，以KEY0为例当按键按下时，电流流向按键，然后接地，则 PE4 为低电平0。
当按键松开时，电流流向 PE4 ，则 PE4 是高电平 1。
因此实现按键控制LED可以有两种方法
1、扫描：读取PE4引脚的电平，当为低电平时LED状态发生反转
2、中断：按键按下，触发外部中断，则将LED2灯状态翻转。
3、CubeMX配置 这里不再详细阐释步骤，采用中断控制LED时，记得要开启中断使能，这里的优先级采用默认的抢占优先级0，子优先级0，其中优先级数越小代表该中断的优先级也就越高。
按键
配置RCC时钟源
3、程序编写 采用模块化编程方式，适合后续的程序调用和移植，也可以理解为函数封装
函数封装： 函数封装是指将一组相关的功能封装到一个函数中，以便重复使用。它可以帮助程序员更有效地编写代码，并减少重复代码的重复编写。
方法一：
key.c
#include "key.h" #include "led.h" void Key(void) { if(HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_4)) { HAL_Delay(100);//按键消抖 if(HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_4)) Red_ON(); else Red_OFF(); } } key.h
#ifndef _KEY_H #define _KEY_H #include "main.h" void Key(void); #endif main.c
直接在while后面加入
key(); 方法二：
在main.c中直接增加中断回调函数，当检测到中断时执行中断回调函数，翻转LED0灯的状态。
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)//中断回调函数，当有中断发生时，将LED0灯进行翻转 {	HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);	//sorry,忘记在上一章中定义LED翻转了，自己可以直接在后面定义的，如：#define LEDTOGGLE HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b430fc1618f6e7d7ed933c07e287f387/" rel="bookmark">
			银河麒麟高级服务器v10 sp2编译安装postgresql 14.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.安装说明 环境：CPU为海光x86 ；内存8G; 硬盘256G
1.1 麒麟官网申请下载kylin v10 sp2 镜像
银河麒麟操作系统 麒麟操作系统 中标麒麟 麒麟软件官方网站 (kylinos.cn)
银河麒麟操作系统 麒麟操作系统 国产操作系统 中标麒麟 开放麒麟 openKylin 麒麟软件官方网站
pg源码下载：PostgreSQL: File Browser
操作系统内核 : 4.19.90-24.4.v2101.ky10.x86_64
1.2 刻录镜像安装kylin server v10 sp2，本次全自动分区安装形式，安装过程省略
二.操作系统准备 2.1 本地yum源配置
mount /dev/cdrom /mnt
新增编辑/etc/yum.repos.d/kylin_local.repo文件，添加以下内容
[kylin_local]
name = kylin local
baseurl = file:///mnt
gpgcheck = 0
enabled = 1
2.2 安装readline和zlib包
因为是源码安装方式，依赖readline和zlib的devel包也要安装
yum install readline-devel -y
yum install zlib-devel -y
三. 开始安装 3.1 解压安装包
下载后得到postgresql-14.1.tar.bz2的文件。上传服务器后，解压缩它：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b430fc1618f6e7d7ed933c07e287f387/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea8c82b3140e86e990dba96575bca77a/" rel="bookmark">
			vue项目 npm-install时报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm-install出现该问题 npm ERR! code EAUDITNOPJSON npm ERR! audit No package.json found: Cannot audit a project without a package.json 解决方法：
1、上面报错是因为没有package.json这个json配置文件，然后我们重新创建一个就行： npm init --yes 创建之后它还会报错： npm ERR! audit Neither npm-shrinkwrap.json nor package-lock.json found: Cannot audit a project without a lockfile npm ERR! audit Try creating one first with: npm i --package-lock-only 2、然后继续根据提示输入： npm i --package-lock-only 然后就可以启动项目！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663ac4e7dfd984c354d81efd27b431f4/" rel="bookmark">
			【javadoc 异常】java.lang.IllegalArgumentException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原博客地址
Problem： 环境变量CLASSPATH中包含%JAVA_HOME% Solution： 将%JAVA_HOME%替换为直接地址，重启cmd 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e12c674de812c8026da123e3eaf57bf/" rel="bookmark">
			pygame迷宫生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.预习内容： 项目分析
一个完整的迷宫，需要能够实现产生不同路径供玩家游戏，同时需要能够记录玩家所走过的路，避免由于迷宫的范围太大而导致无法走到最后的结尾。迷宫本身也应该自带友好的交互功能，可以让玩家可以根据提示获得愉快的游戏体验。
实验目标
1.随机生成一个迷宫，并且求解迷宫。
2.要求游戏支持玩家走迷宫，和系统走迷宫路径两种模式。玩家走迷宫，通过键盘方向键控制，并在行走路径上留下痕迹；系统走迷宫路径要求基于A*算法实现，输出走迷宫的最优路径并显示。
3.设计交互友好的游戏图形界面。
二.算法设计 深度遍历算法生成迷宫路径
1、整体思路
1）利用深度遍历的思想。访问到一个节点时，搜索这个节点没有被访问过的相邻节点，选择一个继续做同样的操作，直到没有邻节点为止再回溯到上一个访问的节点，并选择另外的邻节点。
2）这种方案生成的迷宫会有一条明显的主路，这条主路特别长，贯穿大部分区域的路线，同时，迷宫的路线一般比较扭曲。这种采用深度优先算法（递归回溯算法）生成的迷宫称之为“主路扭曲型”迷宫
2、设计过程
（1）把数组地图初始化为如下结构。选择一个靠近边缘的1作为起点，在它的周围随机找另一个黄色的1（这里的“周围”指的是上下左右4个方向）。找到就把他们联通，并且把两个1之间的0（灰色墙）也变成通路，这里用红色来表示。
（2）选择一个靠近边缘的1作为起点，在它的周围随机找另一个黄色的1（这里的“周围”指的是上下左右4个方向）。找到就把他们联通，并且把两个1之间的0（灰色墙）也变成通路，这里用红色来表示。
（3）把上一步”终点”的格子作为新的一个“起点”格子，不断循环第2步的过程……
直到，找不到周围有黄色的1，就回溯，回到之前的位置，看看周围是否有黄色的1，如果有，就按照2步骤，不断将黄色1变联通，接下来就是不停地重复上面的步骤，找到就联通，找不到就往回走。
（4）遍历完所有的点即可生成一个迷宫，然后再选择出口与入口，一个完整的迷宫就形成了。
1.整体框架结构 通过二维数组生成迷宫坐标，参考教程使用深度优先算法的递归回溯算法完成对迷宫的随机生成，不断随机访问每一个相邻格子，记录访问路径，最后将网格按访问路径擦除，玩家按照访问路径实现迷宫中的行走。
2.关键代码 （1）递归回溯算法
递归回溯是一个深度优先算法，如果当前单元有相邻的未访问过的迷宫单元，就一直向前搜索，直到当前单元没有未访问过的迷宫单元，才返回查找之前搜索路径上未访问的迷宫单元，所以用堆栈来维护已访问过的迷宫单位。
算法主循环，重复下面步骤2直到堆栈为空：
1 随机选择一个迷宫单元作为起点，加入堆栈并标记为已访问
2 当堆栈非空时，从栈顶获取一个迷宫单元（不用出栈），进行循环
如果当前迷宫单元有未被访问过的相邻迷宫单元
随机选择一个未访问的相邻迷宫单元
去掉当前迷宫单元与相邻迷宫单元之间的墙
标记相邻迷宫单元为已访问，并将它加入堆栈
否则，当前迷宫单元没有未访问的相邻迷宫单元
则栈顶的迷宫单元出栈
（2）墙体绘制
（3）玩家设计
此处设计了两个玩家，为对抗方式，先到达对方生成点者获胜（自己的出口）
迷宫运行界面如下
可设置是否展示生成过程
源码
# 导入枚举 from enum import Enum import random import pygame as pg # 全局参数常量 SCREEN_WIDTH = 1200 SCREEN_HEIGHT = 1024 MAZE_WIDTH = 20 # 方格数 MAZE_HEIGHT = 20 # CELL_COUNT = MAZE_WIDTH * MAZE_HEIGHT # 总单元格数 BLOCK_SIZE = 8 # 墙厚 PATH_WIDTH = 3 # 道路宽度 # 是否显示迷宫生成过程 SHOW_DRAW = True # SHOW_DRAW = False # 墙壁 CELL_SIZE = BLOCK_SIZE * PATH_WIDTH + BLOCK_SIZE # 右下边缘 MAZE_WIDTH_PX = CELL_SIZE * MAZE_WIDTH + BLOCK_SIZE # 左边缘 MAZE_HEIGHT_PX = CELL_SIZE * MAZE_HEIGHT + BLOCK_SIZE # 上边缘 # 颜色 BACK_COLOR = (100, 100, 100) WALL_COLOR = (18, 94, 32) MAZE_COLOR = (255, 255, 255) UNVISITED_COLOR = (0, 0, 0) PLAYER1_COLOR = (255, 0, 0) PLAYER2_COLOR = (0, 0, 255) MESSAGE_COLOR = (0, 255, 0) # 绘制起点 MAZE_TOP_LEFT_CORNER = (SCREEN_WIDTH // 2 - MAZE_WIDTH_PX // 2, SCREEN_HEIGHT // 2 - MAZE_HEIGHT_PX // 2) # 用枚举表示格子四方向访问状态 class CellProp(Enum): Path_N = 1 Path_E = 2 Path_S = 4 Path_W = 8 Visited = 16 class Direction(Enum): North = (0, -1) East = (1, 0) South = (0, 1) West = (-1, 0) # 玩家 class Player(pg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e12c674de812c8026da123e3eaf57bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa7f691348349cb41af96692f3cdd31/" rel="bookmark">
			摸鱼的小贤在瞎搞R - R语言内置数据集的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 1-R语言的安装及使用（还没写这个，太简单了不太想写）
2-R语言内置数据集的使用
……
文章都会尽量详细，话多请见谅（我是话痨
文章目录 系列文章目录1. 查看包中有哪些数据集2. 查看某一特定数据集的基本信息3. 调用内置数据集 系统：Windows 10 R语言版本：4.2.1 IDE：RStudio
参考：如何使用R语言中的内置数据集？-青盐
1. 查看包中有哪些数据集 简单来说就是使用data()函数来“Loads specified data sets, or list the available data sets.”。
在说明data函数的功能之前，首先要简单了解一下R语言的数据集（data sets）和包（packages）是怎么会事儿。从文件结构来看，数据集是包的上级目录，比如以datasets包为例，data（这相当于数据集）是datasets（这相当于包）文件夹下的一个独立文件夹，data文件夹中则有着相关的存储这些数据的数据库文件（.rdb看起来是一个数据库类型的文件后缀）。这里可能有点乱，反正就是R语言程序所在的文件中，library文件夹下的下级独立文件夹每个都是package（包括datasets），而点进去某一个package如果有data这个文件，那这一个package也就有其指定的数据集（specified data sets）;所有这些有data这个文件的package，他们的数据集的总和便是可用的数据集（available data sets）。
下面具体敲代码来看一下是怎么回事儿吧！
查看特定package（e.g. datasets, ggplot2）中所有数据集，以及如果查看不存在数据集的package（e.g. car）的结果。
&gt; data(package="datasets") &gt; data(package="ggplot2") &gt; data(package="car") no data sets found 查看可用的所有数据集（这是翻译自data函数的帮助文档的原话，但是我觉得有点指代不清，其所指的应该是当前运行环境下可用的所有数据集，即如果某一个包没有导入的话，那么这个包便不在当前的运行环境下）。
&gt; data() 如果此时你的运行环境中没有导入任何包，结果同data(package=“datasets”)，我认为这是因为R语言默认一定访问datasets包里的数据集（类似于一个default），但是如果先导入了一个包（e.g. ggplot2），在输出的结果中便会同时包含datasets和ggplot2的数据集。
&gt; library(ggplot2) &gt; data() 查看所有可用的包（packages）中的数据集。
&gt; data(package=.packages(all.available=TRUE)) 2. 查看某一特定数据集的基本信息 使用help()函数来查看某一特定数据集（e.g. BOD）的基本信息。
&gt; help("BOD") 需要注意的是如果没有导入包含某一特定数据集的包（e.g. ggplot2包的diamonds数据集），那么并不会输出该数据集的信息。
&gt; help("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afa7f691348349cb41af96692f3cdd31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb3f809d5d3edffb308f20deea812539/" rel="bookmark">
			ArrayList 在CompletableFuture 执行存储为null问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
预期结果是list中正常都打印出名字跟年龄信息，但结果居然存在打印null的情况
最终还是因为arraylist不是线程安全
引用：https://blog.csdn.net/weixin_39517199/article/details/114538568
调整成copywritelist 、Collections.synchronizedList(new ArrayList&lt;&gt;()) 正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7dbd5a843d25140f76a89285b5af72/" rel="bookmark">
			微信小程序登录及获取手机号码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端：微信先授权登录后再授权获取手机号码
后端：先微信登录获取openid返回前端，前端再传递手机号码code给后端获取手机号码并在本地数据量注册用户信息，需提供2个接口
第一步：先通过code微信授权登录获取openid
$url = 'https://api.weixin.qq.com/sns/jscode2session?appid=' . $this-&gt;appid . '&amp;secret=' . $this-&gt;app_secret . '&amp;js_code=' . $code . '&amp;grant_type=authorization_code'; $this-&gt;curl-&gt;get($url); if ($this-&gt;curl-&gt;error) { return ['status' =&gt; 0, 'msg' =&gt; '微信获取授权失败']; } $result = json_decode($this-&gt;curl-&gt;response,true); if (isset($result['openid']) &amp;&amp; $result['openid'] != '') { return ['status' =&gt; 1, 'msg' =&gt; '成功', 'data' =&gt; $result]; }else{ return ['status' =&gt; 0, 'msg' =&gt; '微信获取授权失败-' . $result['errmsg']]; } 第二步：根据app_id和app_secret获取access_token
$url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=' . $this-&gt;appid . '&amp;secret=' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b7dbd5a843d25140f76a89285b5af72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf39776b92470d57dde63ab0a5c9f6d/" rel="bookmark">
			vue 表格 侧边(竖向)表头展示数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现效果:
表格区域：
&lt;!-- 表格区域 :loading="loading"--&gt; &lt;el-table height="calc(100% - 60px)" :data="transData" border :header-cell-style="{ 'text-align': 'center', background: '#F5F6FA', color: '#646E92', }" style=" width: 96%; margin-top: 30px; margin-left: 25px; color: #666e92; font-size: 14px; " :cell-style="{ 'text-align': 'center' }" &gt; &lt;el-table-column v-for="(item, index) in transTitle" :label="item" :key="index" align="center" &gt; &lt;template slot-scope="scope"&gt; {{ scope.row[index] }} &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; data 属性定义：
// originData 为表头展示数据 保证数组里每一个对象中的字段顺序, 从上到下 一次对应显示表格中的从左到右 originTitle: ['月份', '名称', '站点', '月总销售额', '亚马逊物流赔偿金额', '买家支付的运费', '邮费积分', '买家支付礼品卡金额', '退款中的亚马逊物流交易费返款' , '退款中的平台费返款', '退货后的促销返款', '销售退款总额', '退款中的运费', '促销折扣额/促销回报', '退款管理费', '退款中的积分费用', '广告费用' , '尾程配送费', '平台佣金扣点', '秒杀费用', 'Coupon费用', '店租', 'FBA库存仓储费', '其他', 'VAT消费税' , '汇率', '推广费', '商品成本', '商品头程', '利润（人民币）', '利润率', '店铺压货成本', '下单商品成本'], transTitle: [], // transTitle 该标题为转化后的标题, 注意多一列, 因为原来的标题变成了竖着显示了, 所以多一列标题, 第一个为空即可 transData: [] //表格数据 js 获取后台数据 转化成展示数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccf39776b92470d57dde63ab0a5c9f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53460cc1fda21384974a689c1e06bdfa/" rel="bookmark">
			C语言服务端端口监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言连接成功MySQL后需要监听端口发来的消息，最后使用NetAssist测试
服务端输出界面
注意，这里需要改成你虚拟机的ip和端口
完整代码，点赞收藏不迷路：
#include &lt;stdio.h&gt; #include &lt;netinet/in.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdlib.h&gt; #include "/usr/include/linux/socket.h" #include &lt;string.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;time.h&gt; #include &lt;netinet/tcp.h&gt; #include &lt;sys/types.h&gt; #include &lt;ctype.h&gt; #include &lt;signal.h&gt; #include &lt;stdbool.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdarg.h&gt; #include &lt;/usr/local/mysql/include/mysql.h&gt; void monitor() { // 1. 创建监听的套接字 int lfd = socket(AF_INET, SOCK_STREAM, 0); printf("创建监听的套接字\n"); if(lfd == -1) { perror("socket"); exit(0); } // 2. 将socket()返回值和本地的IP端口绑定到一起 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(5555); // 大端端口 // INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址 // 这个宏可以代表任意一个IP地址 // 这个宏一般用于本地的绑定操作 addr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53460cc1fda21384974a689c1e06bdfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d8a986e81378767829472c7ccb1bb4/" rel="bookmark">
			linux升级gcc版本详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 一般linux操作系统默认的gcc版本都比较低，例如centos7系统默认的gcc版本为4.8.5。gcc是从4.7版本开始支持C++11的，4.8版本对C++11新特性的编译支持还不够完善，因此如果需要更好的体验C++11以及以上版本的新特性，需要升级gcc到一个较高的版本。
本文给出了linux系统中涉及国家gcc的操作步骤，供大家参考。
升级步骤可以大致分为下面四个步骤：
查看确认原来的gcc版本
下载需要升级的gcc版本
下载新版本gcc需要的依赖
编译并安装gcc新版本
查看确认gcc原来的版本 linux命令行中输入：
gcc --version 可以看到显示如下：
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44) Copyright © 2015 Free Software Foundation, Inc. 本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保； 包括没有适销性和某一专用目的下的适用性担保。 一般很多linux系统默认的gcc版本为4.8.5，该版本对C++11的支持还不够完善，可以将版本升级到一个更高的版本。本文以升级到版本10.1.0为例。
下载需要升级的gcc版本并解压 2.1下载gcc新版本 由于linux系统没有外网，本文给出的示例是先在windows系统上将gcc版本下载，然后上传的linux系统中。
下载gcc新版本地址为：
http://ftp.gnu.org/gnu/gcc/ 上面有很多gcc版本，需要自己需要的版本进行下载即可。
本文以版本10.1.0为例，点击红色部分，下载文件gcc-10.1.0.tar.gz：
2.2 将gcc新版本上传到linux系统并解压 将下载好的gcc版本上传到linux系统中。本文将版本放在目录：
/opt2/test_other/debug_test/ 进入到/opt2/test_other/debug_test/目录，将文件解压到/usr/local目录下面：
tar -zvxf gcc-10.1.0.tar.gz --directory=/usr/local/ 解压之后可以在/usr/local目录下面看到解压后的gcc目录：
下载并gcc需要的依赖 3.1 查看gcc需要的依赖 cd 到gcc-10.1.0目录下面，查看需要的依赖：
vim contrib/download_prerequisites 可以看到需要的依赖以及版本如下：
从上面看到一共有四个依赖：gmp、mpfr、mpc以及isl。
3.2 下载需要依赖 在安装gcc新版本之前一定要先下载这几个依赖（注意依赖的版本）。
依赖下载的地址：
https://gcc.gnu.org/pub/gcc/infrastructure/ 下载好4个依赖之后，将文件上传到linux系统的目录/opt2/test_other/debug_test/下面。
3.3 将依赖解压到目录gcc-10.1.0 cd到/opt2/test_other/debug_test/目录下面，用下面命令将gmp文件解压到目录gcc-10.1.0：
tar -jvxf gmp-6.1.0.tar.bz2 --directory=/usr/local/gcc-10.1.0/ 用同样的命令可以将isl-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d8a986e81378767829472c7ccb1bb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcae3abe25c2ead22a1f6a7e91205c9/" rel="bookmark">
			JS——数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个数组的数据是一组对象，对象可能有一个属性是与数组相似的结构 要求，把数组中对象中的一个值作为新对象的键，数组中对象的另一个值作为新对象的值，包括嵌套的数组中的对象都放到新对象中
如果有一个导航菜单的数据是下面的结构
const MenuList = [{ key: '/dashboard', label: 'DASHBOARD', children: [{ key: '/dashboard/console', label: '主控页', }, { key: '/dashboard/monitor', label: '监控页', }, { key: '/dashboard/workplace', label: '工作台', }] }, { key: '/notion', label: '公告管理', }, { key: '/charts', label: '图表管理', children: [{ key: '/charts/bar', label: '柱状图' }, { key: '/charts/pic', label: '饼图' },] }] 将上面数据转成下面的格式
const newMenuList = { "dashboard": "DASHBOARD", '/dashboard/console': "主控页", '/dashboard/monitor': "监控页", "/dashboard/workplace": "工作台", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dcae3abe25c2ead22a1f6a7e91205c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a133b7d496266bba1b4007ebfca731e/" rel="bookmark">
			C整合MySQL增删查改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		帮助小白理解，能打注释的地方都打上了，C语言就是调用函数，而Java把这些函数都封装了，这是最大的不同
喜欢就点个赞吧，收藏不迷路
数据库表
-- MySQL dump 10.13 Distrib 8.0.30, for Win64 (x86_64) -- -- Host: 192.168.154.141 Database: school -- ------------------------------------------------------ -- Server version 8.0.31 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */; /*!50503 SET NAMES utf8 */; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */; /*!40103 SET TIME_ZONE='+00:00' */; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; -- -- Table structure for table `Student_info` -- DROP TABLE IF EXISTS `Student_info`; /*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a133b7d496266bba1b4007ebfca731e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfb9570f6a7d8337db5036dcbbf3bd2/" rel="bookmark">
			解决libc.so.6: `GLIBC_2.17‘ not found问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用yum安装 xx-agent 应用后执行启动服务命令 service xx-agent start 时报如下错误：
/lib64/libc.so.6: version `GLIBC_2.14`not found
/lib64/libc.so.6: version `GLIBC_2.17`not found
原因：系统 glibc 版本太低，运行xx-agent需要GLIBC_2.14和GLIBC_2.17版本
查看系统当前支持的glibc版本：
$ strings /lib64/libc.so.6 |grep GLIBC GLIBC_2.12 GLIBC_2.3 GLIBC_2.4 GLIBC_PRIVATE GLIBC_TUNABLES $ ldd --version 解决：下载安装GLIBC_2.14和GLIBC_2.17版本
下载并编译安装2.14版本的：
$ wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz $ wget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.14.tar.gz $ tar -xvf glibc-2.14.tar.gz $ tar -xvf glibc-ports-2.14.tar.gz $ mv glibc-ports-2.14 glibc-2.14/ports $ mkdir glibc-2.14/build &amp;&amp; cd glibc-2.14/build $ ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin $ make &amp;&amp; make install 下载并编译安装2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cfb9570f6a7d8337db5036dcbbf3bd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a1f1eb74b8f96c3ec9d23384ac6f66/" rel="bookmark">
			【Linux】零成本在家搭建自己的私人服务器解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我这个人自小时候以来就特喜欢永久且免费的东西，也因此被骗过（花巨款买了永久超级会员最后就十几天）。
长大后骨子里也是喜欢永久且免费的东西，所以我不买服务器，用GitHubPage或者GiteePage搭建自己的静态私人博客，虽然没有服务器搭建的功能强大，但是它免费，且永久。
但是这远远不够，我受学长启发，想在家里搞一个私人服务器，可以挂载云盘，可以安装数据库，可以写博客，可以挂脚本，可以搞家庭影院等等。
零成本在家搭建自己的私人服务器解决方案：
第一个方案——机顶盒：我翻箱倒柜翻出了家里的机顶盒，经典的中国移动魔百盒，办宽带送的，限制性很强，不办宽带的话系统很多功能被锁死，反正现在家里都能智能电视了，我就开始弄它，先是拆机，用铁丝（镊子也行）短接C77短接点，然后插入含有update.zip的刷机包，不过最后还是没有成功，我的机顶盒是ZN代工的，没有被我要刷的系统的作者给破解，然后就放弃了，这机子也最终被我刷成砖我才死心了。
第二个方案——iPhone5s，下载了一个ish模拟Linux系统，也忙活了很久，按理说是可以实现的，但是我一直不能用电脑连接到ish，就算把端口改到2000以上也不行，我就放弃了，毕竟我的5s断触了，按键失灵严重。
第三个方案——华为麦芒5，这虽然最后成功了，但是也走了很多弯路，一开始用Linux Deploy，但是要root，我就去给手机root，换了好多root软件都失败了，一键root大师，rootKing，360一键root等都不行，于是我就搜为什么不行，原来是20年之后各大厂商就关闭了很多root通道，而且华为手机本身有自己的BL锁，我就不想走root这条路了，然后我就继续找其他路，又找到了Termux，不需要root，但是和我手机不兼容，启动不了，我就又pass了，然后又找到了商业级Linux——AidLux，一开始下载完可以进入Linux页面，但是只要切到后台，就再也打不开了，这条路又pass掉了。
到这都是为了实现零成本搭建私人服务器，走了很多弯路，完全都是找家里的旧机器，但是“山穷水复疑无路，柳暗花明又一村”，弯路走了这么多，也该到头了。
我选择了UserLAnd，一开始的时候登不进去，说是需要强效网络，然后我不断刷新，终于刷进去了，然后选择了Ubuntu系统进行下载，最后成功了，然后就算apt update | upgrade两操作，根据网上教程做好相关配置，实现了两个功能，第一个功能是远程ssh访问，我在老安卓机上启动了Linux后，直接在PC端FinalShell上输入该机的本地ip，一开始用22端口总是登不进去，后来阅读了GitHub上UserLAnd的英文原文文档知道了只有2022端口才行，一下子就搞定了，就算sshd is not running红字在Linux界面上闪着，也丝毫不影响我远程连接Linux（如下图）：
而且还自带python3，有了python我就可以下django，django可以做各种web端网页，这样我就可以再也不用GitHub弄静态博客了，直接搞数据库弄动态博客，爽得很。
除此之外我还搭建了Alist，挂载了我10T的阿里云盘，半实现了家庭影院，效果如下：
我的iPhone5s也能看4K《狂飙》！
输入局域网ip可以很快访问，实现了家里各设备的资源共享，然后我又搞了个内网穿透。
由于我的Linux是搭建在安卓手机上的，它的架构是arm64，内网穿透比较著名的花生壳内网穿透只提供amdx64 x86 xi386三种Ubuntu安装包，于是又放弃了花生壳，又是走弯路啊，终于找到个还凑合的NatAPP，实现了内网穿透，让我远在天边的同学也体验了一下我的服务器。
以上就是这几天捯饬的东西，接下来我打算给服务器添加docker、智能家居控制等功能。
Alist也走了弯路，Alist还不能一键脚本安装arm64，我是下载了传Linux的，然后FinalShell对这种自带服务器又不能直接传，又下载了rz，最后才手动安装成功的，每次报错我都害怕是不是这就根本实现不了，不过在网上看了一百多篇教程后，终于搞定了。
这过程中获得的一些知识：
arm64一般是安卓手机，arm32是树莓派，amd64_x86就是电脑了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd60643f30e322f8fb54e7eb46fe910/" rel="bookmark">
			微信小程序实现地图定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 地图定位这个功能相信大家在学习插件的时候都有过接触，那么在这篇文章中我来为大家介绍微信小程序中的地图定位功能，很简单哦
在此之前我们可以先去微信官方文档&gt;小程序&gt;组件&gt;地图进行了解
点此进入小程序中map介绍
map组件提供了地图展示、交互、叠加点线面及文字等功能，同时支持个性化地图样式，可结合地图服务 API 实现更丰富功能。
1. 写一个map标签，并在其中写入经纬度属性，mark标记与点击事件 &lt;view&gt; &lt;map latitude="{{latitude}}" longitude="{{longitude}}" markers='{{marker}}' bindtap="click"&gt;&lt;/map&gt; &lt;/view&gt; 2.在js文件中的data声明首次加载的经纬度 data: { latitude: '', //纬度 longitude: '', //经度 marker:[], } 3.接着在onLoad生命周期中写入wx.getLocation方法 onLoad(options) { wx.getLocation({ isHighAccuracy: true, type: 'gcj02', success: (res) =&gt; { this.setData({ latitude: res.latitude, longitude: res.longitude, marker: [{ id:1, latitude: res.latitude, longitude: res.longitude, iconPath: '/image/401.png', width: '100rpx', height: '100rpx' } ] }) } }) }, 这里marker里的iconPath是一个标点记号图片 （如右图）
4. 最后在单击事件中写入wx.openLocation方法，使用微信内置地图查看位置 click(){ wx.openLocation({ latitude: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd60643f30e322f8fb54e7eb46fe910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473cab5a1805722877e04e001fca1582/" rel="bookmark">
			Linux中内存交换空间(swap)之创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中的swap（内存交换空间） 对于服务器而言，由于不知道何时会有大量请求的到来，因此，需要预留一部分swap来缓冲一下系统的内存用量。对于实际解决方法主要有两个：
添加硬盘，对硬盘进行分区，并格式化后用于内存交换空间。(将添加的硬盘当做swap partition使用)不需要使用额外的硬盘，在已有的文件系统中使用一部分移动硬盘用于交换空间。(创建一个虚拟内存文件) 使用实际磁盘创建swap分区 创建 swap 分区步骤：
分区：先使用 gdisk/fdisk 在磁盘中划分一个分区给系统作为 swap分区 格式化：利用 mkswap 设备文件名 格式化分区成为 swap 格式 使用：使用 swapon 设备文件名 将该 swap 设备挂载启动 观察：通过 free与 swapon -s 指令来观察一下内存用量 列出所有存储设备查看（lsblk，list block device）
study@virtual-machine:~$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS loop0 7:0 0 155.6M 1 loop /snap/firefox/1232 loop1 7:1 0 248.8M 1 loop /snap/gnome-3-38-2004/99 loop2 7:2 0 81.3M 1 loop /snap/gtk-common-themes/1534 loop3 7:3 0 43.6M 1 loop /snap/snapd/15177 loop4 7:4 0 4K 1 loop /snap/bare/5 loop5 7:5 0 61.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473cab5a1805722877e04e001fca1582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c2af469044482176e2d529c2915b2f7/" rel="bookmark">
			一分钟教你配置DHCP服务，超级简单一看就会！！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DHCP
C/S架构
Client (UDP 68) /Server(UDP 67)
1,客户端首次获取IP
4个过程
2,客户端第二次获取IP
2个过程
DHCP工作流程图
DHCP DISCOVER(广播)
DHCP OFFER（单播或广播）
DHCP REQUEST(广播)
租期—1 day
T1时间… 租期的50% — 12小时
续租：使用单播的形式发送DHCP-Resquest
T2时间… 租期的87.5% ― 21小时
续租：使用广播的形式发送DHCP-Resquest
DHCP-Release — DHCP客户端主动释放IP地址使用的数据包
拓扑图
基本步骤
1，首先要分析pc都需要啥？（ip，子网掩码，网关）
2，其次要配置接口ip（g/0/0/0, g0/0/1），并将其当做为pc的网关
3，在路由器上打开dhcp服务（dhcp enable）
4，创建IP池
5，配置IP池(IP地址，子网掩码，网关)
6，接口上选择全局配置
7，pc端打开dhcp并且应用
ipconfig进行查看即可
R2配置代码
改名就不用说了
&lt;Huawei&gt;sys
[Huawei]sys r2 开启路由器的dhcp服务
[r2]dhcp enable Info: The operation may take a few seconds. Please wait for a moment.done.
[r2]dhcp enable
创建ip池
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c2af469044482176e2d529c2915b2f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1ce0aaf558d1cc5de19cee17ca584a2/" rel="bookmark">
			假溢出的解决策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假溢出：在顺序队列中，队列出队时并没有像线性表那样使后面的元素往前移。
为了解决假溢出，常用的方法是把队列想成一个首尾相接的环，这种叫循环队列。在循环队列的入队和出队操作中，用到了求模运算（%），以确保front和rear的值保持在队列的有效范围内。
对于队列q，初始化为空队列使q-&gt;front==q-&gt;rear==0。
新元素入队时操作为：
q-&gt;data[q-&gt;rear]=x; q-&gt;rear=(q-&gt;rear+1)%MAXSIZE; 出队操作为：
x=q-&gt;data[q-&gt;front]; q-&gt;front=(q-&gt;front+1)%MAXSIZE; 此时我们发现从一开始一直入队直到队列满时，此时q-&gt;front==q-&gt;rear==0;和判队列空的条件一摸一样，那怎么办？？我们有以下三种方案
闲置循环队列中一个元素空间。当 rear 的下一个位置是 front 时，则宣告列满。此时，循环队列为空的条件为 rear==front，而循环队列为满的条件为:(q-&gt;rear+1)%MAXSIZE==q-&gt;front。按照这种办法，循环队列出队、入队操作不变，只是入队时循环队列的判断条件修改为(q-&gt;rear+1)%MAXSIZE= q-&gt;front 即可。
在循环队列上增加一个标志变量 flag，初始时q-&gt;flag=0。当因为入队操作q-&gt;front==q-&gt;rear时，置q-&gt;flag为1;当因为出队操作使q-&gt;front==q-&gt;rear 时，置 q-&gt;flag为0。因此，循环队列空的条件为q-&gt;flag==0&amp;&amp;q-&gt;front==q-&gt;rear,循环队列满的条件为 q-&gt;flag==1&amp;&amp;q-&gt;front==q-&gt;rear。
在循环队列中增加一个计数器 count，初始时 count=0;成功出队时 q-&gt;count减1，成功入队时 count 加1。因此，循环队列空的条件为 q-&gt;count==0。循环队列满的条件为 q-&gt;count==MAXSIZE，或者 q-&gt;count&gt;0&amp;&amp;q-&gt;rear==q-&gt;front。
flag法
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef int DataType; #define MAXSIZE 6 typedef struct { DataType data[MAXSIZE]; int front, rear; int flag; }CSeqQueue; void Init_Queue(CSeqQueue* q) { q-&gt;front = 0; q-&gt;rear = 0; q-&gt;flag = 0; } int Out_Queue(CSeqQueue* q, DataType* x) { if (q-&gt;flag == 0 &amp;&amp; q-&gt;front == q-&gt;rear) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1ce0aaf558d1cc5de19cee17ca584a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334f3f034ee3531734811856ada4fc7c/" rel="bookmark">
			VS 设置管理员权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因： 想让我的程序能拥有管理员权限，于是设置了UAC执行级别，requireAadministrator。运行后发现，无效
明明已经设置了，但没达到想要的效果，程序没有弹出需要管理员权限的确认
app.manifest的配置如下
解决方法 直接在.mainfest文件里面加上下面这段代码，问题解决
&lt;trustInfo xmlns="urn:schemas-microsoft-com:asm.v3"&gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level="requireAdministrator" uiAccess="false"/&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt; &lt;/trustInfo&gt; 像下面这样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b640d6b46051bbc3cf6c536d6966c87/" rel="bookmark">
			案例2-2 小明都可以买什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 编写一个智能购物计算小程序，在一家商店有书本、铅笔、橡皮、可乐、零食5种商品，商品价格如表
假如你带了20元，且必须购买一本书，剩余的钱还可以购买哪种商品？可以购买几件，购买完后又能剩余多少钱？
个人思路： 1.设计一个菜单，给商品编号
2.需要利用switch语句进行判断
3.利用取余、取模求得可购买数量和剩余
代码实现： import java.util.Scanner; public class Example2_2 { public static void main(String[] args) { int pencil = 1;//铅笔 int rubber = 2;//橡皮 int cola = 3;//可乐 int snacks = 5;//零食 System.out.println("书本的价格是12元，你总共带了20元"); System.out.println("1.铅笔的价格是1元"); System.out.println("2.橡皮的价格是2元"); System.out.println("3.可乐的价格是3元"); System.out.println("4.零食的价格是5元"); System.out.print("请输入你还想购入的商品编号:"); Scanner sc=new Scanner(System.in); int x=sc.nextInt(); switch(x) { case 1: System.out.println("购买完书本后还可以购买铅笔"+8/pencil+"支，还剩"+8%pencil+"元"); break; case 2: System.out.println("购买完书本后还可以购买橡皮"+8/rubber+"块，还剩"+8%rubber+"元"); break; case 3: System.out.println("购买完书本后还可以购买可乐"+8/cola+"瓶，还剩"+8%cola+"元"); break; case 4: System.out.println("购买完书本后还可以购买零食"+8/snacks+"袋，还剩"+8%snacks+"元"); break; } } } 运行结果： 举一反三： 可改变题目条件，输入一个资金数目，然后选择一项商品，求得最多可买该商品多少件，剩余多少钱。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b640d6b46051bbc3cf6c536d6966c87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5400239db9550769cff2f58485e59617/" rel="bookmark">
			将课程表导入日历，实现电脑手机日程同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 写在前面：我运行时环境为python3.x环境，需自行配置，如果一定要在2.x环境运行的话，代码里有修改注释，源代码是在网络上找的（(又到了每年此刻，教你把课程表导入日历 - 少数派 (sspai.com)))下载后修改了一些问题（包括修改为3.x运行环境）
原作者代码几乎完全没有注释，遇到问题时去啃代码也是蛮痛苦的。
另外此脚本不一定只能用于课程表，如果有长期的需要以周为单位进行的事务的话，也可以使用此脚本快捷的转换为ICS文件导入日历，只需稍微修改配置信息即可
​同步到日历后也有一些好处，比如装x，如查看课程表时不再需要连接网络，并且上课前日历会自动提醒（可设置提前多久），电脑查看也很方便，如下图
Gitee代码链接: 课程表导入日历
开始 实现思路：将课程信息输入Excel表格，使用Python解析表格文件并输出ICS文件，将课程转换为日历中的日程信息，使用日历打开ICS文件完成导入
主要代码文件如下：
编辑conf_classTime.json文件中的数据，其中数据代表着第几节课，课程开始时间，结束时间
这个我已经按照我自己实际情况编辑好了，使用的是学校的作息时间，其他学校根据实际去改
编辑classInfo.xlsx文件，其中截图的各列数据意义如下
classNamestartWeekendWeekweekdayclassTimeclassroom课程名称第几周开始第几周结束星期几上课第几节上课教室 其中的classTIme对应conf_classTime.json文件中的数据，从1开始数，如classTime在xlsx文件中为1，表示这节课的上课时间为conf_classTime.json文件中的第一条数据（如下图）
压缩包里的xlsx文件中的数据直接删除就好，是我测试时的数据 运行excelReader.py文件，注意运行过程中需要输入0继续，完成后会生成一个conf_classInfo.json文件
注意在运行之前最好先把文件夹中的conf_classInfo.json文件删除
运行此文件需要安装xlrd软件包，且必须安装1.2.0版本的包，最新版本不支持读取此表格文件
运行时会出现下列内容，做为检查数据列和上一步配置的excel文件表头是否一一对应，一般输入数字零，然后回车即可完成运行
运行完成后生成文件图片如图：
运行main.py文件，中间需要输入本学期开学第一天的时间（格式为20020101）和选择日历提前多久提示上课，完成后会生成一个class.ics文件
同样在运行前最好先把原有的class.ics文件删除
正常运行时的情况，蓝色文字为输入的内容：
生成的文件：
电脑直接双击打开class.ics文件即可，win10系统会自动导入，其他的大同小异，手机也可以直接打开文件，选择使用手机日历打开，即可保存到手机日历中。
注意win10系统打开后可能会出现所有时间都提前一个小时的情况，这个是win10日历固有的问题，截止书写这句话的时候win10日历尚未解决该问题
解决方案：下载Outlook邮箱的手机app，将class.ics文件发送到手机，打开时选择使用outlook打开即可
注意手机outlook登录的邮箱账号需要和电脑使用的是同一个邮箱账号，否则无法同步到电脑。
ps： outlook导入日历时最好导入到新建的空白日历中，默认的日历不可删除，且outlook邮箱不支持批量删除日历数据，数据如果出错的话会很麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186031c9eb67ed7a3164b30d17b804e4/" rel="bookmark">
			IntelliJ IDEA背景颜色和背景图片设置!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：首先IDIEA是可以设置背景颜色和背景图片的 像有些有个性的同学就像设置自己的一个背景颜色和背景图片 现在将教你们如何设置
背景颜色 在IDEA里先打开File&gt;Settings&gt;Appearance &amp; Behavior&gt;Appearance在里面选择
第一种是IDEA默认的一种白色第二种是根据你自己的一个Windows颜色来决定的第三种是一个灰色(个人推荐灰色 看的舒服点 没这么刺眼)第四种是一个高对比度 这个我想应该没人设置吧 太夸张了 根据个人兴趣选择 如果是觉得不喜欢的话 接着可以设置自己喜欢的背景图片
背景图片 还是这个地方往下看可以看到一个Background Imagen按钮 点击一下 会弹出一个框
Image 是你选择图片的路径 (可以点击后方的 ... 来找到你要上传的图片)Opacity 是这个图片的透明度 跟你个人喜欢来调节有图案的就是图片的样式 也是可以根据个人喜欢来调节This project only 打勾的话是仅限于这个项目的背景图片 不打勾就是整个IDEA都是这个背景图片最下面就是你选择完图片的样子咯 当然也可以选择一张纯色的图片啦 选择完后 点击OK 就行了!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/474c76b73b1dd266e0818890d362f5b5/" rel="bookmark">
			logStash多数据源配置匹配不同tag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		input { tcp { mode =&gt; "server" host =&gt; "0.0.0.0" port =&gt; 5044 codec =&gt; "json_lines" type=&gt;"test" } file { path =&gt; "/mnt/dolphinscheduler/wx_project/comm/utils/log/**/info.log" start_position =&gt; "beginning" type =&gt; "info_log" } } input { file { path =&gt; "/mnt/dolphinscheduler/wx_project/comm/utils/log/**/error.log" start_position =&gt; "beginning" type =&gt; "error_log" } } filter { grok { match =&gt; { "message" =&gt; '%{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}" %{NUMBER:response:int} (?:-|%{NUMBER:bytes:int}) %{QS:referrer} %{QS:agent}' } } if[type] == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/474c76b73b1dd266e0818890d362f5b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/573b9beb0bd20cc5c3e90cff7e8d77c8/" rel="bookmark">
			Docker的安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker的安装步骤 先决条件 操作系统要求 要安装Docker引擎，您需要CentOS 7、CentOS 8（stream）或CentOS 9（stream）的维护版本。
这个centos-extras必须启用存储库。默认情况下，此存储库处于启用状态，但如果已禁用它，则需要重新启用它 .
查看自己虚拟机的内核：
uname命令用于打印当前系统的相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。
cat /etc/redhat-release uname -r 卸载旧版本 旧版本的Docker被称为docker或docker引擎。如果安装了这些文件，请将其连同相关的依赖项一起卸载。
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 如果yum报告没有安装这些包
内容/var/lib/docker/，其中包括图像、容器、卷和网络。现在调用Docker引擎包 docker ce公司。
yum安装gcc相关 首先需要安装gcc和gcc c++环境配置：
yum -y install gcc yum -y install gcc-c++ 安装方法 根据您的需要，您可以通过不同的方式安装Docker Engine：主要通过设置Docker的存储库并从中安装，以便于安装和升级任务。
使用存储库安装 在新主机上首次安装Docker Engine之前，需要设置Docker存储库。之后，您可以从存储库安装和更新dockerf。
（1）设置存储库 安装yum-utils包（提供um-confi-anger实用程序）并设置稳定的存储库
yum install -y yum-utils yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 为镜像库（阿里云）最好用这种：https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
（2）更新yum软件包索引 yum makecache fast （3）安装引擎 1、安装最新版本Docker Engine、containerd和Docker编写或转到下一步安装特定版本：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/573b9beb0bd20cc5c3e90cff7e8d77c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cdc0c228c8ad2d3f54ac9ac31a1e1dc/" rel="bookmark">
			docker dbus-x11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来想用terminator启动nvidia-docker，显示出图形界面的，结果发现启动的时候出问题了。
(terminator:1): dbind-WARNING **: 07:31:53.725: Couldn't connect to accessibility bus: Failed to connect to socket /tmp/dbus-KZfwhNFwYM: Connection refused Traceback (most recent call last): File "/usr/bin/terminator", line 107, in &lt;module&gt; ipc.new_window_cmdline(optionslist) File "/usr/share/terminator/terminatorlib/ipc.py", line 190, in _exec bus = dbus.SessionBus() File "/usr/lib/python2.7/dist-packages/dbus/_dbus.py", line 211, in __new__ mainloop=mainloop) File "/usr/lib/python2.7/dist-packages/dbus/_dbus.py", line 100, in __new__ bus = BusConnection.__new__(subclass, bus_type, mainloop=mainloop) File "/usr/lib/python2.7/dist-packages/dbus/bus.py", line 122, in __new__ bus = cls._new_for_bus(address_or_type, mainloop=mainloop) dbus.exceptions.DBusException: org.freedesktop.DBus.Error.Spawn.ExecFailed: /usr/bin/dbus-launch terminated abnormally without any error message 首先呢，建议自己先用之前的docker images来验证本机上相关的x11显示依赖都安装完毕并且不会有什么问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cdc0c228c8ad2d3f54ac9ac31a1e1dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31bbd2d3c5aa2a0cca1501efaf7313b9/" rel="bookmark">
			ubuntu系统下source: not found错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu系统下运行含有source命令的Shell脚本时，出现source: not found错误，原因可能是Shell的解释器不是bash，需把Shell的解释器更改为bash。
请按以下步骤更改Shell的解释器：
执行ls -l /bin/sh命令，若得到结果/bin/sh -&gt; dash，则说明Shell的解释器为dash。执行sudo dpkg-reconfigure dash命令，然后选择no。再次执行ls -l /bin/sh命令，若得到结果/bin/sh -&gt; bash，则说明成功更改Shell的解释器为bash。 参考链接：如何解决ubuntu系统下source: not found错误？_Alibaba Cloud Toolkit-阿里云帮助中心
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0626dc9b65fc3579d3806162527943f/" rel="bookmark">
			vue3 在线编辑预览 选用 CodeMirror
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Codemirror （用户最多，生态最好，插件也相对完备，能想到的基本都有，同时也被很多线上应用在用，有什么问题百度搜下基本都能搜到。） ：https://codemirror.net/examples/
vue2-ace-editor（已长期未维护）
vue-monaco-editor（已长期未维护）
Vue-code-view （基于vue2+cli）https://andurils.github.io/vue-code-view/#/home
Monaco Editor（微软开源的一个web代码编辑器，但是相关文档比较少）
Codemirror CodeMirror 是一款 “Online Source Editor”，基于 Javascript，短小精悍，实时在线代码高亮显示，他不是某个富文本编辑器的附属产品，他是许多大名鼎鼎的在线代码编辑器的基础库。
Codemirror具备在线编辑、语法高亮、搜索、代码块折叠、只读预览、格式化代码、撤销、重置、重做、复制等功能。
使用的是基于Codemirror实现代码在线编辑功能，iframe进行预览视图。
1.插件地址：https://github.com/surmon-china/vue-codemirror
2.安装插件
npm install codemirror --save
↑（我的版本是5.65.11）
推荐安装@types/codemirror以支持类型推断
npm i @types/codemirror -D
3.repl文件夹放到utils下
4.component下创建组件
replcompnents.vue
5.在assets下创建js文件
6.在使用的页面里引入上面创建好的组件，此处用ReplComponent.vue来举例。引入js文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3dab0173f68931e5f7edd34f0a17ccc/" rel="bookmark">
			mysql5.7实践之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql5.7实践之路 1 mysql linux版安装1.1 下载地址2.2 检查当前系统是否安装过mysql2.3 安装mysql服务端2.4 查看mysql安装时创建的mysql用户和mysql组2.5 mysql服务的启动+停止 3 mysql服务启动后，连接3.1 连接报错3.2 查看默认密码3.3 使用默认密码登录3.4 修改密码3.5 设置root可远程登录4 自启动mysql服务2.8 修改配置文件位置2.9 修改字符集和数据存储路径 3、mysql配置文件3.1 二进制日志log-bin3.2 错误日志log-error3.3 查询日志log3.4 数据文件3.4.1 frm文件3.4.1 myd文件3.4.1 myi文件 3.5 如何配置 4、mysql逻辑架构介绍4.1 连接层4.2 服务层4.3 引擎层4.4 存储层 5、mysql存储引擎mysql配置文件 1 mysql linux版安装 二级制源码安装、rpm包本地安装、yum安装。
本次采用rpm安装
1.1 下载地址 https://dev.mysql.com/downloads/
beta版
release版
ga版（稳定发布版）generally available release
mysql-community-common-5.7.27-1.el6.x86_64.rpm
mysql-community-libs-5.7.27-1.el6.x86_64.rpm
mysql-community-client-5.7.27-1.el6.x86_64.rpm
mysql-community-server-5.7.27-1.el6.x86_64.rpm
2.2 检查当前系统是否安装过mysql # 查询当前系统是否安装过mariadb或mysql rpm -qa | grep -i 'mariadb\|mysql' # 删除卸载安装过的package rpm -e xxxx rpm -e --nodeps yyyy 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3dab0173f68931e5f7edd34f0a17ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb18b20cb5aa1e2f5af041e2cb652a7/" rel="bookmark">
			ffmpeg的日志系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件
include &lt;libavutil/log.h&gt; 这里设置了debug水平，那么debug水平及以上的都会被打印，其他道理相同。
av_log_set_level(AV_LOG_DEBUG) 最后两个值和printf相同
av_log(NULL, AV_LOG_INFO, "%s\n", value) 错误级别高-&gt;低
AV_LOG_ERROR
AV_LOG_WARNING
AV_LOG_INFO
AV_LOG_DEBUG
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c055f94719f9a8c887bae50f66e5c4/" rel="bookmark">
			pip下载第三方库失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip下载第三方库失败的问题 遇到的情况，出现大量的警告和报错
最终解决办法，改用豆瓣源镜像，并加上信任动作
pip install burp -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 下载其他包，把上面的语句中的burp换为其他包名即可 pip install numpy -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c456f530c265dcdfa1ba3d0cbac79b9/" rel="bookmark">
			Vue保留一位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 value.toFixed(1) 有用的话请点个赞再走呗！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69432eb7513647cea2ab3cbc6dfdbdbf/" rel="bookmark">
			Java 字符串常量池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🐒 什么是"池"
🐒 字符串常量池 🍂 字符串常量池位置的变化
🍂 String 在字符常量池中的创建
🍂 intern 方法
🐒 什么是"池" "池" 是编程中的一种常见的, 重要的提升效率的方式, 我们会在未来的学习中遇到各种 "内存池", "线程池", "数据库连接池" .... 比如电脑的硬盘，你有256G，有一天你下了一个3A游戏，结果发现空间不够用了，这时候你就想着买一个硬盘装上去，中间你要等快递，要装盘。而池的方式就是直接给硬盘上到最大容量，一条不够装十条🤬，你要下游戏尽管用，随下随用，效率非常高。 常量池又分为 Class 文件常量池、运行时常量池、字符串常量池。 🐒 字符串常量池 public static void main(String[] args) { String a = "hello"; String b = "hello"; System.out.println(a == b); String aa = new String("haha"); String bb = new String("haha"); System.out.println(aa == bb); } 先看下上面的代码，想一下输出结果分别是什么？
看到输出结果后为啥 new 的 String 字符串为啥比较结果是 false 呢？
这一切都要归于字符串常量池。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69432eb7513647cea2ab3cbc6dfdbdbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b001a311c0bcd215550c8b62272e8f/" rel="bookmark">
			AOP &#43; Spring-EL表达式构建优雅的系统操作日志框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是操作日志本文使用到的技术栈我们想要实现的效果日志表需要记录的字段写日志的方式查询日志的方式 部分核心代码操作类型描述生成策略"更新"操作的默认策略 - 1日志注解和AOP切面日志注解AOP切面配置 "更新"操作的默认策略 - 2 什么是操作日志 区别于"控制台日志"， 操作日志的存在是为了让人查看的， 所以控制台日志那种一个txt文件混在一起的情况是不符合要求的。
本文使用到的技术栈 加粗的为重要
Spring boot 3JacksonAOP + Spring-EL表达式Mybatis + Mybatis-plus (查询和更新操作)Spring Data JPA （字段名格式化时需要读取它的注解，也可以自定义注解）Spring doc (swagger) （字段名格式化时需要读取它的注解，也可以自定义注解）Lombok权限校验框架： Shiro 或 Spring Security 本次我们不涉及模糊查询功能，不引入ES等技术栈。
我们想要实现的效果 日志表需要记录的字段 字段非空性说明时间戳✓精确到秒操作类型✓这应该是一个枚举类型， 至少包括4种典型操作:增删改查； 可能还包括: 重置， 上传，下载，登陆，登出等操作人使用用户ID关联或者直接登记姓名，由权限校验框架提供操作人IP由WEB框架提供主实体类型✓被操作的实体类型(写包名)， 例如登陆登出的主实体类型即为 本系统的用户类主实体ID✓被操作实体的唯一编号副实体类型副实体ID使用的策略描述生成策略的包名，后详请求参数请求中使用的参数 ， 因为可能存在敏感信息 ， 应当允许选择是否记录响应结果请求的响应内容 ， 因为可能存在敏感信息 ， 应当允许选择是否记录操作描述[重要] ，后详会话ID可以通过SessionId看出用户多端登陆的情况， 与IP的含义有所不同执行耗时 其中：
副实体类型：有时候我们实际操作的是实体类B ， 但是希望该操作登记在实体类A名下，如: 用户个人信息与用户分表存储的情况 。 此时， 主实体类型 = 用户 ， 副实体类型 = 用户个人信息操作描述：需要根据一定的规则(即策略)生成一段一般用户能够看懂的代表这一次操作内容的描述信息，策略应当根据被操作的实体的类型和操作类型有所不同。 同时应当有通用的默认策略，避免相同策略重复书写。对于4种典型操作而言，它的默认策略大致应该是这样的 添加：新增 [实体类型] ID:xxx [某些关键字段数据]修改：修改 xxx 字段，从 aa 更新为 bb字段名应该有可读性（中文），不记录没有修改的字段；对于一些不太有可读性的字段（与其他表关联的外键xxxId， 枚举类， 内部约定的表达方式等），应该可以转换为有可读性的描述查询：查询了 [方法名] 查询参数为 xxx删除：删除了 xxx，一般情况下不应该删除主实体类(那样可能就不再能查询到它的日志)，而是删除了实体名下的副实体类型 另外，如果日志表的记录数过大会对查询性能有影响，需要分表存储，同时过于古早的日志可能也没有保存价值了可以删除。这里我们进行简单设计：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7b001a311c0bcd215550c8b62272e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3610e5a4f1593fedd610589367ffe29/" rel="bookmark">
			Chisel入门（一）------搭建Chisel开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 概述 之前在windows环境下简单学习了Scala的基本语法，并在windos环境下安装了JVM环境和Scala编译器，运行了一些简单的Scala程序。今天开始正式搭建Chisel开发环境和学习Chisel，同时为了有利于后续的学习和开发，也是因为Chisel的工作环境对windows不太友好，所以后续的开发都会在linux上进行。
我这里选择的是使用的VMware搭建的虚拟机环境，版本为ubuntu 22.04，如果不确定版本号的可以使用
lsb_release -a 进行查询。虚拟机的安装等等网上资源很多就不赘述了。
1 安装sbt sbt(scala build tool)的Github网址：sbt Reference Manual — sbt Reference Manual (scala-sbt.org)
有兴趣的，可以在主页上查看，上边介绍的也很详细。大概的安装步骤包括：
安装JDK（推荐使用JDK8, 11或17版本）安装sbt并运行建立一个简单的“hello world”工程学习如何使用sbt到.sbt的构建定义下去了解更多关于构建的更多信息 1.1 安装JDK 安装JDK有两种方法，第一种方式是通过AdoptOpenJDK来安装，需要输入命令
sudo apt install openjdk-8-jdk git make gtkwave 即可。
另一种方法是通过SDKMAN来安装和管理多个JDK版本，这也是sbt官网推荐的方法，它最大的好处就是可以使用sdk来直接安装sbt，非常的方便，但是经过多次尝试，一直无法成功安装SDKMAN，尽管SDKMAN和现有网站资料上都给出了一些教程，但都不外乎
curl -s "https://get.sdkman.io" | bash source "$HOME/.sdkman/bin/sdkman-init.sh" sdk version sdk list java //查询sdk支持的java版本 sdk install java //安装最新的java版本 sdk install java **** //安装指定版本 这些，在亲自尝试了多次之后：
首先是发现22.04版本没有预装curl，安装后再次运行遇到了各种各样的报错信息，先是无法连接github.com，增加hosts之后仍报错
curl: (56) Recv failure: Connection reset by peer 多次尝试无果后改为第一种直接安装JDK 8的方式，随后再单独安装sbt，如果有安装成功SDKMAN的非常希望可以给出一些建议，指出问题，感激不尽！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3610e5a4f1593fedd610589367ffe29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7df756567846691148b70cd16517b3e/" rel="bookmark">
			删除二值图中的毛刺并提取骨架线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除二值图中的毛刺 整体代码实现连通性保证 在不改变二值图中各个连通域的连通性的条件下，删除二值图中的毛刺，并提取骨架线
整体代码实现 //连通域分析 bool connectedanalysis(std::vector&lt;int&gt; vPixelVal) { if (vPixelVal.size() != 9) return true; int p1, p2, p3, p4, p5, p6, p7, p8, p9; p1 = vPixelVal[0]; p2 = vPixelVal[1]; p3 = vPixelVal[2]; p4 = vPixelVal[3]; p5 = vPixelVal[4]; p6 = vPixelVal[5]; p7 = vPixelVal[6]; p8 = vPixelVal[7]; p9 = vPixelVal[8]; //8 simple判定 if (p2 == 0 &amp;&amp; p6 == 0) { if ((p9 == 255 || p8 == 255 || p7 == 255) &amp;&amp; (p3 == 255 || p4 == 255 || p5 == 255)) return false; } if (p4 == 0 &amp;&amp; p8 == 0) { if ((p9 == 255 || p2 == 255 || p3 == 255) &amp;&amp; (p5 == 255 || p6 == 255 || p7 == 255)) return false; } if (p8 == 0 &amp;&amp; p2 == 0) { if (p9 == 255 &amp;&amp; (p3 == 255 || p4 == 255 || p5 == 255 || p6 == 255 || p7 == 255)) return false; } if (p4 == 0 &amp;&amp; p2 == 0) { if (p3 == 255 &amp;&amp; (p5 == 255 || p6 == 255 || p7 == 255 || p8 == 255 || p9 == 255)) return false; } if (p8 == 0 &amp;&amp; p6 == 0) { if (p7 == 255 &amp;&amp; (p9 == 255 || p2 == 255 || p3 == 255 || p4 == 255 || p5 == 255)) return false; } if (p4 == 0 &amp;&amp; p6 == 0) { if (p5 == 255 &amp;&amp; (p7 == 255 || p8 == 255 || p9 == 255 || p2 == 255 || p3 == 255)) return false; } return true; } //去除二值图像边缘的突出部 //uthreshold、vthreshold分别表示突出部的宽度阈值和高度阈值 //type代表突出部的颜色，0表示黑色，1代表白色 void delete_jut(cv::Mat&amp; src, cv::Mat&amp; dst, int uthreshold, int vthreshold, int type) { src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7df756567846691148b70cd16517b3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/511e95efd67289fb73dba99f3398d529/" rel="bookmark">
			瑞芯微RK3568开发板源码编译与交叉编译环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇，将进行OK3568-C开发板Linux系统开发需要用的软件交叉编译环境的配置。下面就介绍两种交叉编译环境的配置方法。
01C/C++交叉编译环境编译
如果只是使用C/C++代码，则在自己的Ubuntu虚拟机中添加RK3568对应的交叉编译器(gcc/g++)即可。进行代码的交叉编译时可用使用如下方法，该配置方式简单便捷。
1. 下载aarch64类型的gcc
在Linaro官网中下载GCC交叉编译工具链，飞凌嵌入式OK3568-C开发板采用的是64位的Cortex-A55内核，需要使用aarch64-linux-gnu。
地址：&gt;&gt;https://releases.linaro.org/components/toolchain/binaries/latest-7/aarch64-linux-gnu/
我下载的是这个：gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz。
然后解压：
tar -xvf gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar 解压结果如下：
解压完成之后，可以在其下的bin目录中看到aarch64编译器：
使用这里的gcc或g++，就能交叉编译C或C++程序了。
2. 交叉编译C/C++程序测试
写一个简易的hello word的C++测试程序main.cpp：
#include &lt;stdio.h&gt; 然后使用如下指令进行编译：
export PATH=/home/xxpcb/myTest/OK3568/gcc_aarch64/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin:$PATH 第一句是临时添加环境变量，当然也可以添加到.bashrc中实现永久添加，由于每种开发板用到的编译工具链不太一样，我一般都使用这种临时添加的方式。
第二句是使用aarch64-linux-gnu-g++来编译C++程序，编译结果如下，可用使用file指令查看编译出的程序的文件类型：
可以看到，编译出的文件是ELF 64-bit LSB的可执行文件，ARM aarch64架构的。
然后将程序放到飞凌嵌入式OK3568-C开发板中运行，这里使用ADB拷贝程序。可以看到在下图右侧窗口中看到，在OK3568-C开发板中已成功运行hello word程序。
3. 关于开发板的WiFi自动联网
想要给开发板传输文件，就需要先连上网络。在上篇《发烧友实测 | OK3568-C开发板初体验》中介绍过，OK3568-C开发板使用一个脚本来进行WiFi配网，但每次开机后都需要再配置。可以写个脚本加入到开机自启动程序中。
例如，在/etc/init.d目录下，添加一个S99myinit文件，写入如下内容即可实现开机自动连网：
#!/bin/sh 这里注意要替换为自己的WiFi名和密码，并且要给这个文件可执行权限。
02RK3568 Linux源码编译
刚才介绍了只进行C/C++程序开发时进行交叉编译环境配置的方法。
如果还要进行Qt开发，可以通过编译RK3568 Linux源码的方式，得到Qt的交叉编译工具链。由于我这里已经安装过了VirtualBox虚拟机和Ubuntu18系统，那就在自己的开发环境中进行RK3568的开发吧。
1. 基础环境配置
在进行RK3568的源码编译之前，需要先进行对自己的虚拟机进行一些依赖包的安装，如下。首先是安装一些必要的库：
sudo apt-get update sudo apt-get install build-essential 然后还有安装一些编译OK3568 Linux源码所需的库：
sudo apt-get update 此外，为了便于Qt开发，可选择安装Linux版的Qt Creator到自己的虚拟机中，安装过程也比较简单，并且我之前已经安装过了，这里就不过多介绍了。当然，不安装Qt Creator也是可以进行Qt程序的编译的，只要有Qt交叉编译环境即可。
2. 准备RK3568源码
复制RK3568源码到Ubuntu虚拟机中，准备编译：
cat OK3568-linux-source.tar.bz2.a* &gt; OK3568-linux-source.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/511e95efd67289fb73dba99f3398d529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5429daef3243c00894b56ad986db6b4/" rel="bookmark">
			word排版难题：如何消除页面末尾的空白行？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用Word的过程中，会遇到各种各样的小问题，所以常有小伙伴留言提问，希望帮忙解答。这不，最近有位小伙伴就遇到了这样一个难题：
上面这位小伙伴所说的是什么情况呢？其实就是这样：
可以看到，上一页末下方有几行的空白，浪费纸张不说，还不美观。看到这里，许多人应该会有疑惑？为什么下一页的内容不自动延续到上一页末空白区域呢？这是怎么回事？
其实，这是因为设置了“孤行控制”所导致的。
什么是孤行控制呢？Word中“孤行”通常分为“段首孤行”和“段未孤行”，是指在页面顶端的段落末行或者页面底端的段落首行，那单独的一行即被称为孤行。
因此，在Word中如果我们设置了孤行控制，那么段落中的首行或最后一行就不会单独出现在页面的底端或顶端。Word会自动将段落中与之相邻的一行移动到此孤行所在的页面，以保证该页面上至少显示出此段落的两行内容，由此就出现了文首小伙伴所提问的情况了。
那这种情况应该怎么处理呢？很简单，只需取消勾选“孤行控制”选项即可。
操作方法为：点击【开始】-【段落】组右下角的“扩展”按钮，打开“段落”对话框，选择“换行和分页”选项卡，在“分页”栏中取消勾选“孤行控制”复选框，然后再单击“确定”按钮。此时，可以看到文档中原本在下一页的内容自动显示在上一页的空白区域处了！
除此之外，Word中出现上述情况还有一种可能，即设置了段中不分页。
什么是段中不分页呢？是指当该段落恰好在页面底部时，整个段落中所有的内容都将全部调整到下一页内显示，如下图所示。
因此，当我们打开“段落”对话框，选择“换行和分页”选项卡，在“分页”栏中取消勾选“段中不分页”复选框，再单击“确定”按钮，段落内容将分页显示，填补上一页底部空白区域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000ea3e63a096375dd14e8db37ad7452/" rel="bookmark">
			安装nvm（node版本管理器）以及nvm常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言：什么是nvm Node.js 默认一台电脑只能装一个版本，有时为了开发项目经常会使用不同版本的Node.js 版本，通常情况版本切换就比较麻烦了。
为了解决这个问题，nvm （node version manager）应运而生。有了 nvm，便可以在一台电脑上安装多个 Node.js 版本，并且可以一条指令随时下载或切换版本，而不需要频繁地下载/卸载不同版本的 node.js 来满足当前项目的要求。
Mac安装nvm的方法 Mac使用brew安装，brew安装方法自行百度哈
打开终端 brew install nvm 执行成功后，添加配置代码到zsh文件 vi ~/.zshrc export NVM_DIR="$HOME/.nvm" [ -s "/usr/local/opt/nvm/nvm.sh" ] &amp;&amp; \. "/usr/local/opt/nvm/nvm.sh" # This loads nvm [ -s "/usr/local/opt/nvm/etc/bash_completion.d/nvm" ] &amp;&amp; \. "/usr/local/opt/nvm/etc/bash_completion.d/nvm" # This loads nvm bash_completion 3、添加成功后重启终端 在终端中输入nvm -v如果出现版本号就证明安装成功啦
Windows安装nvm方法 通过GitHub下载安装包 github下载地址：https://github.com/coreybutler/nvm-windows/releases
nvm-noinstall.zip： 绿色免安装版本，但是使用之前需要配置
nvm-setup.zip：安装版，下载之后点击安装，无需配置就可以使用
在运行nvm install 的时候，有可能会出现无权限安装的问题，请 以管理员身份 运行 cmd
nvm的常用命令 nvm on #启用版本管理 nvm off #禁用版本管理 nvm ls #查看本地 Node 版本 nvm ls-remote #查看官网 Node 版本 nvm ls-remote --lts #查看官网 Node LTS 版本 nvm current #显示当前的版本 nvm install [node版本号] #安装指定版本 nvm uninstall [node版本号] #卸载指定版本 nvm use [node版本号] #使用指定版本 nvm alias default [node版本号] #设置默认使用版本 nvm alias [别名] [node版本号] #给不同的版本号添加别名 nvm unalias [别名] #删除已定义的别名 nvm install-latest-npm #在当前node版本中，将npm升级到最新版 nvm reinstall-packages [node版本号] #在全局重新安装npm，从[node版本号]版本到当前版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6040544e6e9a008c448a424510804470/" rel="bookmark">
			deque的简单介绍 &amp; 优先级队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
deque
空间结构：
迭代器：
deque的优缺点
优先级队列（priority_queue）
仿函数的概念
push()和top()
pop(）
size()和empty()
测试
deque Dequ（double-e nded queue）双端队列，是一种可以在头尾两端进行插入和 删除操作且时间复杂度为O(1)的"连续"空间的数据结构
空间结构： deque是由一段段等长度的连续空间和一个map中控区（指针数组）所构成的，当空间不足时只需在开一个空间并将他链接到map，与list不同，deque不能保证将其所有元素存储在连续的存储位置.
迭代器： dequr的迭代器维护起来相对复杂，是由四个指针一起来维护，node指向中控区，first和node分别指向一段空间的开始和结束，cur指向访问到的位置。如果访问的元素不在当前空间，cur就等于下一个空间的first,依次跑下去
deque的优缺点 与vector比较，deque的优势是：头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的。
与list比较，其底层是连续空间，空间利用率比较高，不需要存储额外字段
deque有一个致命缺陷：不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到 某段小空间的边界，导致效率低下。
为什么选择deque作为stack和queue的底层默认容器
stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。
优先级队列（priority_queue） 优先级队列（priority_queue）是一种容器适配器，优先级队列（priority_queue）其实并不像queue那样满足先进先出，优先级队列中，将具有最高优先级的元素将被首先删除，
仿函数的概念 仿函数又称为函数对象，是一个能行使函数功能的类。
作为仿函数的类，都必须重载 operator() 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。
让我们看两个例子
template&lt;class T&gt; struct less { bool operator()(const T&amp; x1,const T&amp; x2) { return x1 &lt; x2; } } template&lt;class T&gt; struct greater { bool operator()(const T&amp; x1,const T&amp; x2) { return x1 &gt; x2; } } 我们看到 greater 和 less 都只是将 operator（）运算符进行重载，只不过返回的真假结果不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6040544e6e9a008c448a424510804470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c265b3729cfed4811e7252ea6e9925/" rel="bookmark">
			JAVA：数组元素求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public class 数组元素求和 { public static void main(String[] args) { int[] arr = {68, 27, 95, 88, 171, 996, 51, 210}; int sum = sum(arr); System.out.println(sum); } public static int sum(int[] arr) { int sum = 0; for (int i = 0; i &lt; arr.length; i++) { int ge = arr[i] % 10; int shi = arr[i] / 10; if (ge != 7 &amp;&amp; shi != 7 &amp;&amp; arr[i] % 2 == 0) { sum += arr[i]; } } return sum; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8ed802e00d26369d217851e8a749ad/" rel="bookmark">
			CentOS上安装docker-compose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装docker-compose 简介 docker compose是用于定义和运行多容器docker应用程序的工具,compose 通过一个配置文件来管理多个docker容器。可以使用docker-compose.yml脚本来启动、停止、重启应用，进行docker容器的编排和管理。但是docker compose并没有实现容器的负载均衡，还需要借助其他工具实现。
安装 docker官网地址：https://docs.docker.com/compose/install/
centos上安装docker 1.查看本地docker版本 sudo docker version 2.根据docker版本选择对应的compose版本 docker-compose官网地址：https://docs.docker.com/compose/compose-file/compose-file-v3/
3.开始安装 官网安装地址：https://docs.docker.com/compose/install/other/
通过github直接下载（我这里选择的版本是v2.16.0）：
curl -SL https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose 因为https://github.com是国外网站，下载会很慢，所以可以使用如下命令：
curl -L https://get.daocloud.io/docker/compose/releases/download/v2.16.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 当然如果本地有docker-compose-linux-x86_64这个安装包也可以进行手动上传，上传到/usr/local/bin这个目录下，并重命名为docker-compose
4.添加可执行权限 sudo chmod +x /usr/local/bin/docker-compose 5.测试 # 三种方式都可以 docker-compose version docker-compose --version docker-compose -v 6.常用命令介绍 启动并后台运行所有的服务
docker-compose up -d 列出项目中目前的所有容器
docker-compose ps 停止服务
docker-compose stop 服务名 启动服务
docker-compose start 服务名 停止并删除容器、网络
docker-compose down 修改yml文件后，重新加载运行
docker-compose up --force-recreate -d 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2ce1f326b5c24b58ab02d72ff3a5fe/" rel="bookmark">
			Reids实战—黑马点评（三）秒杀篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reids实战—黑马点评（三）秒杀篇 来自黑马的redis课程的笔记
【黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目】
目录 Reids实战—黑马点评（三）秒杀篇一、全局唯一ID小结 二、实现优惠券秒杀下单三、超卖问题3.1 问题描述3.2 乐观锁和悲观锁3.3 乐观锁实现3.3.1 版本号法3.3.2 CAS（Compare And Swap） 3.4 小结 四、一人一单4.1 添加功能4.2 并发问题4.3 字符串问题4.4 Spring事务问题4.4.1 锁在事务内4.4.2 事务不生效 4.5 集群模式下的一人一单问题 五、分布式锁5.1 分布式锁概述5.2 基于redis实现分布式锁5.2.1 锁误删5.2.2 Lua脚本保证命令原子性 5.3 小结 六、Redisson6.1 使用Redisson分布式锁6.2 Redisson分布式锁原理6.2.1 可重入原理6.2.2 可重试原理6.2.3 解决超时释放6.2.4 保证主从一致6.2.5 小结 七、redis优化秒杀八、Redis消息队列实现异步秒杀8.1 基于List结构模拟消息队列8.2 PubSub发布订阅模式8.3 基于Stream结构的消息队列8.3.1 基本使用8.3.2 消费者组8.3.3 改造秒杀业务8.3.4 小结 一、全局唯一ID 每一个订单都需要不同的ID，如何做到ID唯一？
如果似乎用自增：
id规律明显（安全问题）受单表数据量限制 为了解决这些问题，我们有了全局ID生成器，这是一种生成全局唯一ID（或者叫分布式唯一ID）的工具，所生成的ID满足以下特征：
唯一性高可用高性能递增性安全性（复杂递增） 唯一性和递增性我们可以用redis自增来实现，恰好，redis本身就满足高可用、高性能，安全性如何解决？
方案：
用Long（数值效率比字符串高）类型，一个Long类型占64位（Java中），我们可以在这些bit位上做文章。
首先：从左数第一位，是符号位，我们的id永远为正数，所以让它永远为0。接下来的31位，用来存时间戳，保证安全性的同时，让id基本不可能重复。最后的32位，我们存普通的递增值。这个方案，理论上可以保证68年都不会有id重复。
为了避免最后的自增值超出redis自增限制，我们可以每天新建一个key用于自增（例如，yyyy:MM:dd），不仅解决了问题，还方便统计。
实现：
@Component public class RedisIdWorker { private StringRedisTemplate stringRedisTemplate; // 起始的时间戳值 private static final Long BEGIN_TIMESTAMP = 1640995200L; public RedisIdWorker (StringRedisTemplate stringRedisTemplate) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2ce1f326b5c24b58ab02d72ff3a5fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7827276fcd8653cbd27006ca99b4b03/" rel="bookmark">
			黑盒测试的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我们先设置一个示例,后面的文章中会根据示例来进行讲解
假设有一个程序是判断一个整形数字是否属于1-100
目录
1.等价类法
2.边界值法
3.判定表法
4.场景设计法
5.错误猜测法
6.正交法
1.等价类法 概念:系统性的确定要输入的测试条件的方法可以看出概念非常抽象,那我们就直接用示例来理解
如上面程序,我们需要设计的等价类有两种
1.有效等价类:有效切有意义的集合
在1-100之间的数
2.无效等价类:无效且无意义的集合
大于100或者小于1的数就是无效等价类
注意:假如题目中给的是输入的数字是否为1或50或100,那么有效等价类就是1,50,100,这种不是范围的必须全部覆盖,无效等价类就是除了这三个数之外的其他数
2.边界值法 概念:边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界
我们为上述示例设置边界值测试用例就是
1,100,0,101
边界值法主要的关注对象成了边界
3.判定表法 判定表法就是对我们已知的条件和操作进行组合并绘制判定表
这里我们为了方便理解,我们给上述示例加一个条件,如果数字为50,则多输出一个yes,对此做出判定表如下:
4.场景设计法 事件流:事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流
场景设计法存在基本事件流和备选事件流
正常执行结束的事件就是基本事件流,如上述示例中,假如用户输入正常的整形数字,那么程序就会按照基本事件流执行下去,而如果用户输入一个浮点型的数据,那么程序就无法正常执行了,那么我们针对这种事件流,就需要做处理,则成为备选事件流
5.错误猜测法 错误猜测法我们目前是无法很好的使用的,因为错误猜测法就是根据测试人员的从业经验进行猜测项目可能出现的BUG,并进行测试
6.正交法 概念:正交试验设计(Orthogonal experimentaldesign)是研究多因素多水平的一种设计方法，它是根据正交性，由试验因素的全部水平组合中挑选出部分有代表性的点进行试验，通过对这部分试验结果的分析了解全面试验的情况，找出最优的水平组合。
正交表中的元素:
因素:在一个项目中,凡是要考察的变量都成为因素
水平(位级):在考察的变量中的值,叫做水平
类似这种就是一个正交表
正交表的构成:
行数:正交表有几行,即试验次数,上图有9行
因素数:即有多少个因素即为列号,上图为4
水平数:即为最大的值,上图为3
正交表的表示形式:行数(因素数*水平数) -&gt; L = N(TC)
正交表的性质:
1.每一列中,出现的每个值的个数是相同的
这个很好理解的,就不过多赘述
2.任意两列中,各有序对出现的次数一样多
如上表,第一列和第二列中第一行(1,1)只出现了一次,那么(1,2),(1,3)(2,2......也只会出现一次
我们人工去设计正交表太复杂了,所以我们可以使用allpairs来生成正交表,这里就不过多讨论软件的使用方法了,感兴趣可以自己去百度一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2c03f282a974745cd7aa3663db3d8d/" rel="bookmark">
			BSAH中$0、$1、$2、$#、$@、$*、$? 的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行命令：sh myshell.sh x y z haha那么怎么来获取到对应的参数呢？
$0 对应 “myshell.sh” 这个值。如果执行的是 ./shell/myshell.sh， 则对应 ./shell/myshell.sh 这个值，而不是只返回文件名本身的部分。
$1 会获取到 x，即 $1 对应传给脚本的第一个参数。
$2 会获取到 y，即 $2 对应传给脚本的第二个参数。
$3 会获取到 z，即 $3 对应传给脚本的第三个参数。
$4 会获取到 haha，即 $3 对应传给脚本的第三个参数。$5、$6 等参数的含义依此类推。
$# 会获取到 4，对应传入脚本的参数个数，统计的参数不包括 $0。
$@ 会获取到 “x” “y” “z” “haha”，也就是所有参数的列表，不包括 $0。
$* 也会获取到 “x” “y” “z” “haha”， 其值和 $@ 相同。但 $* 和 $@ 有所不同。$* 把所有参数合并成一个字符串，而 $@ 会得到一个字符串参数数组。
$? 可以获取到执行命令后的返回值。在执行一个前台命令后，可以立即用 $? 获取到该命令的返回值。该命令可以是系统自身的命令，可以是 shell 脚本，也可以是自定义的 bash 函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb2c03f282a974745cd7aa3663db3d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba903dc49f06fc5fb407045aaa2d0865/" rel="bookmark">
			吉林大学 软件学院 计算机网络题型总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intro 本题型分类整理是按照：
简答；大题； 分类的，适用于吉林大学软件学院计算机网络考试。
简答 19级学姐整理的简答，很全面，直接看就行
下面是根据学姐回忆的19年软件的题整理出的答案： 简答
描述分组交换网中的存储转发机制 存储转发机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。分组交换采用的存储转发技术,原理是把一个报文划分为几个部分传输,我们一般发送的数据称之为一个“报文”,在发送报文前，把比较长的报文划分为几个小的数据段,在每个数据段之前加上必要的信息组成了首部;这就构成了一个分组,分组也可以称之为“包”，分组的头部就称之为“包头”。
路由器则是用来进行分组交换的。路由器收到一个分组，先暂存下来，存在路由器的存储器（内存）中,。然后查找转发表，按照首部的地址转发出去，把分组交给下一个设备，就这样以存储转发的形式，把分组转发到最终的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和维持在路由器中的转发表，使转发表能够在整个网络拓扑结构发生变化时及时更新。
IPv6相比IPv4的好处（写两点） IPv6是128bit，相比于32bit的IPv4具有更大的地址空间；IPv6数据报具有更简单、更高效的结构。 排队时延的原理 分组在交换机中被接收后，先被交换机存储到输入队列中去等待交换机查找转发表，等到路由器处理完该分组之后，该分组又被塞到输出队列中等待发出。如果当一个分组到达时，前方并没有分组在排队，那他的排队时延就是0；相反，如果前方排队的分组很多甚至有填满缓存的趋势时，排队时延往往都会很大，甚至有概率会发生丢包现象。
描述选择重传中发送发和接收方的运作过程 大题 第一章 计算机网络和因特网 4种时延、端到端时延和吞吐量 第二章 应用层 数据报分片 第三章 运输层 可靠性数据传输原理：GBN(go back n)协议和SR(selective repeat)协议
TCP连接管理（三次握手四次挥手，背就完了）
TCP拥塞控制
第四章 网络层：数据平面 划分子网 第五章 网络层：控制平面 路由选择算法 Dijkstra算法 DV算法
路由表更新 第六章 链路层和局域网 CSMA/CDCRC校验
还有一种题型：采用CRC检验，G（x）=x3+x2+1,接收端收到的比特序列是11001100110011，如何判别在传输过程中数据有没有发生改变？ 第七章 无线网络和移动网络 CDMA 考虑单一发送放的CDMA情况，如果发送方的CDMA码是（1,1,1,-1,1,-1,-1,-1），若果要发送两个数据比特0和1，发送方的输出是什么？请画图说明。 CDMA码是（1,1,1,-1,1,-1,-1,-1），接收到两个输入分别是（-1,-1,-1,1,-1,1,1,1）和(1,1,1,-1,1,-1,-1,-1),接收方如何解码？ 第八章 计算机网络中的安全 简述报文鉴别码MAC的含义和作用？ 含义：用鉴别密钥s级联报文m，生成的m+s,计算出的散列H(m+s)就是报文鉴别码作用：Alice将 MAC 附加到报文m上，形成拓展报文 ( m , H (m + s) ) ，将拓展报文传给Bob. Bob收到一个拓展报文 (m,h) ，由于Bob知道鉴别秘钥s，Bob可计算出MAC2：H(m+s). 比较MAC2和h，如果它们相同，则报文在旅程中未被改变，保障数据的可靠性。 背公式，然后将公式转化成图画出来 假设Alice要向Bob发送的报文为m，用于机密性的随机对称会话密钥为Ks，Alice的公钥和私钥分别为K+A,K-A,Bob的公钥和私钥分别为K+B,K-B；用于鉴别的散列函数是H。请画图说明一个能够提供机密性、发送方鉴别和报文完整性的电子邮件系统，注意：请完整地画出Alice的发送过程和Bob的接受过程？ 公式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba903dc49f06fc5fb407045aaa2d0865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ef8ab72e584a0dfbdb273bb89ed0e0/" rel="bookmark">
			Gradle7.4安装与基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.前言二.下载Gradle三.Gradle镜像源-全局级配置四.配置Gradle wrapper-项目级配置五.Gradle对测试的支持五.生命周期5.1 settings文件 六.Gradle任务入门6.1 任务行为6.2 任务依赖方式 七. Dependencies依赖引入7.1 依赖冲突及解决方案 八.Gradle整合多模块SpringBoot九. Gradle整合微服务SpringCloud 一.前言 gradle有突出的版本不兼容问题.因此要注意SpringBoot对Gradle的要求,以及IDEA对Gradle的要求.
在IDEA的plugins/lib/gradle中规定了gradle的最大版本号. 在2022.2.1中是6.7 在2022.3.2中是7.4.
其余自行查看该位置的版本控制.不过idea规定的版本号可以更改.
查看SpringBoot与Gradle的兼容性
二.下载Gradle Gradle官网地址
下载完整版解压后
系统变量配置Gradle仓库
键必须为GRADLE_USER_HOME
系统变量配置Gradle全局系统变量 gradle的bin目录
验证 gradle -v
三.Gradle镜像源-全局级配置 Gradle使用maven定位镜像地址参考: 阿里云云效Maven
全局配置 在Gradle的init.d目录下新建gradle为后缀的文件.
allprojects { repositories { maven { name "Alibaba" ; url "https://maven.aliyun.com/repository/public" } maven { name "google" ; url 'https://maven.aliyun.com/repository/google' } mavenCentral() } buildscript { repositories { maven { name "Alibaba" ; url 'https://maven.aliyun.com/repository/public' } maven { name "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05ef8ab72e584a0dfbdb273bb89ed0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93aa10658457c6787659e1c406812b82/" rel="bookmark">
			Mac本地软件打包dmg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 需求制作dmg磁盘复制应用压缩文件 需求 部分软件网上找不到，本地之前安装无法找到安装包，本地打包给朋友。网上搜的感觉讲的没那么细！自己写一个吧。
制作dmg磁盘 打开mac磁盘工具
选择文件-&gt;空白映像命名设置磁盘大小，需要注意大小设置为你打包软件的大小（可选择找到应有右键简介查看应用大小） 复制应用 回到桌面选择刚刚新建的空间新建文件窗口，选择找到需要打包的本地应用，复制到新建的磁盘里 压缩文件 磁盘工具，映像-&gt;转换，选择压缩目录即可
至此压缩完成，可以传给朋友啦！
之前的新建的dmg空间可以直接删除
视频教程地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00910004ee83f344c3cf06ef02f82d45/" rel="bookmark">
			markdown根号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下，根号打法如下
$\sqrt{a+b}$ a + b \sqrt{a+b} a+b ​
如果要开的不是二次根，而是三次或其他次根，则打法如下
$\sqrt[n]{a+b}$ a + b n \sqrt[n]{a+b} na+b ​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e22b171c85414aa74a98829ec765a15/" rel="bookmark">
			（附源码）springboot大学生社团管理系统的设计与实现 毕业设计150912
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
摘要 1
1 绪论 1
1.1研究背景 1
1.2研究意义 1
1.3系统开发技术的特色 1
1.4论文结构与章节安排 1
2大学生社团管理系统分析 3
2.1 可行性分析 3
2.2 系统流程分析 3
2.2.1数据增加流程 3
2.3.2数据修改流程 4
2.3.3数据删除流程 4
2.3 系统功能分析 4
2.3.1 功能性分析 4
2.3.2 非功能性分析 5
2.4 系统用例分析 6
2.5本章小结 7
3大学生社团管理总体设计 8
3.1 系统架构设计 8
3.2 系统功能模块设计 8
3.2.1整体功能模块设计 9
3.2.2用户模块设计 9
3.2.3评论管理模块设计 10
3.3 数据库设计 10
3.3.1 数据库概念结构设计 10
3.3.2 数据库逻辑结构设计 15
3.4本章小结 18
4大学生社团管理详细设计与实现 19
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e22b171c85414aa74a98829ec765a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619fbcd833c96264efc06978e8a385f7/" rel="bookmark">
			电脑技巧：分享8个Win11系统必备小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、让任务栏显示“右键菜单”
2、任务栏置顶
3、还原经典右键菜单
4、Win11版任务管理器
5、新版Alt+Tab
6、开始菜单不再卡
7、为Edge浏览器添加云母效果
8、自动切换日/夜模式
Win11在很多地方都做了调整，但由于涉及到诸多旧有习惯，再加上前期Bug的缘故，初上手时让人很不适应。
好在微软的号召力不俗，各种“改装”小工具也是层出不穷。虽然不能解决掉Win11的所有问题，但至少可以让你的Win11用起更顺手！
1、让任务栏显示“右键菜单” 不支持右键，是Win11任务栏中一个最大的“Bug”，日常使用超级不便。
StartAllBack是一款第三方工具，通过点击“任务栏项→启用增强型经典任务栏”，可以快速恢复任务栏的右键菜单功能。
此外它还提供了图标大小、间距调节、任务栏透明等小功能，实用的同时美观度也不错。
2、任务栏置顶 很多小伙伴都喜欢将任务栏放置到屏幕顶端或侧面，但Win11并不支持。
想要解决这个问题，依旧还是利用前面提到的那款StartAllBack，点击“任务栏项→启用增强型经典任务栏”，修改“屏幕任务栏位置”到喜欢的位置，就可以了。
3、还原经典右键菜单 除了任务栏以外，右键菜单也是Win11中越改越难用的设计之一。想要还原经典的右键菜单模样，除了使用工具软件外，你也可以通过在Windows终端中输入几行代码快速实现。
首先，在桌面空白部位右击鼠标，选择“在Windows终端中打开”；
然后，将下列代码复制进去：
reg add "HKCU\SOFTWARE\CLASSES\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32" /f /ve 回车确定后，再次打开任务管理器，右击“Windows资源管理器”并选择“重新启动”即可；
4、Win11版任务管理器 任务管理器是Windows中为数不多的N年未更新的系统组件之一，现在借助一款名叫ViveTool的小工具，你可以提前体验一下最新版的Win11任务管理器。
首先，将Win11升级至Dev频道Build 22538，并下载好最新版ViveTool 0.2.1；
然后，打开ViveTool文件夹，在窗口空白部位右键选择“在Windows终端中打开”；
接下来，顺序输入以下命令：
.\vivetool addconfig 35908098 2.\vivetool addconfig 37204171 2.\vivetool addconfig 36898195 2
重新启动电脑后，任务管理器就会升级到全新版本。
注：新版Win11任务管理器尚处于预览阶段，很多功能并未适配。目前已有网友发现该版本存在稳定性问题，在官方未提供处理结果前，暂时只能进行回滚处理，请大家谨慎开启。
5、新版Alt+Tab 除了新版任务管理器外，Win11也带来了全新的Alt+TAB外观。
与初版的全屏式设计不同，新版Alt+Tab还原了Win10的窗口化设计，同时又融合上最新的“云母Mica”特效，看起来“果”味十足！
首先，将Win11升级至Dev频道Build 22526以上，同时下载好最新版ViveTool 0.2.1；
然后，打开ViveTool文件夹，在窗口空白部位右键选择“在Windows终端中打开”；
接下来，输入命令：
.\vivetool addconfig 36226836 2
重新启动电脑后，Alt+Tab便成功美颜了！
6、开始菜单不再卡 无论是资源管理器还是开始菜单，Win11给人的感觉总是有那么一点点卡顿。
很多人认为这是由于Win11的底层代码优化不佳所致，其实真正导致Win11卡顿的是因为它在打开这些位置时，会自动检索一遍Office.com里的内容。
而这种联网式操作原本就会导致反应速度减慢，更何况国内访问Office.com一直都不是很通畅。
要想解决这个问题，我们可以通过调整组策略加以搞定。
具体方法是：点击开始菜单，输入“gpedit.msc”打开组策略编辑器。然后依次定位到“计算机配置→Windows设备→管理模板→Windows组件→文件资源管理器”。
双击右侧“在‘快速访问’视图中关闭Office.com的文件”，将默认的“未配置”修改为“已禁用”。重新启动电脑后，你会发现资源管理器和开始菜单在打开操作上，将比以前更流畅。
7、为Edge浏览器添加云母效果 由于种种原因，Win11版Edge浏览器并没有加入全新的“云母Mica”特效，其实只要我们在地址栏中输入“edge://flags”，搜索“mica”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619fbcd833c96264efc06978e8a385f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d00320230a4a3fa887b24eef0361c49/" rel="bookmark">
			CSDN原力增长规则解读 实测一个月
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN原力越来越难了，当然，这对生态发展来说也是好事。
介绍下原力增长有哪些渠道吧。
发布原创文章：10分/次，每日上限为15分、2篇
回答问题：1分/次，每日上限2分，2回答
发动态：1分/次，每日上限2分、2动态
浏览文章：1分/天，需要阅读浏览20篇文章
翻译文章5分，不知道每天可以两篇还是多少
转载文章，每次1分，但是官方数据不明确，不知道上限多少。
点赞1分，评论一分
互动的贡献：写回答，写评论，转载博客，赞，踩，等。 这些等级的贡献，每次应该获得 1 分。
获得的评价：获得别的用户的赞，代码被fork，star，等等。 这些等级的认可， 每次应该获得 1 分
之前测试了视频上传，没有加分。官方也没有详细的分来源，不太好增加，目前每天只能增加25分左右。
也就是说目前来分最快的方法，2原创+2翻译+2动态+点赞+评论文章。每天任务就算是完成了
15+5+2+2+1+1
这是我基本每天完成的任务，马上500分了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58dba0916a006ef97b78f0413a602d3f/" rel="bookmark">
			统计学学习笔记三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.2离散程度的度量 分类数据：异众比率
顺序数据：四分位差
数值型数据：方差和标准差
相对离散程度：离散系数
描述样本数据离散程度的统计量主要有全距、四分位距、方差、标准差以及测度相对离散程度的离散系数等
4.2.1全距和四分位距 1.全距 全距是一组数据的最大值与最小值之差，也称极差，用R表示。
R = max(x) - min(x)
容易受极端值的影响，不能全面反映数据的差异状况。虽然全距在实际中很少单独使用，但是它总是作为分析数据离散程度的一个参考值
2.四分位距 一组数据75%位置上的四分位数与25%位置上的四分位数之差，也称四分位差，用IQR表示
IQR = Q75% - Q25%
四分位距反映了中间50%数据的离散程度：其数值越小，说明中间的数据越集中，数值越大，说明中间的数据越分散。四分位距不受极值的影响。
由于中位数处于数据的中间位置，因此，四分位距的大小在一定程度上也说明了中位数对一组数据的代表程度
4.2.2方差和标准差 数据离散程度的最常用测度值
反映了各变量值与均值的平均差异
标准差为方差的开方
根据总体数据计算的，称为总体方差（标准差），记为（σ）；根据样本数据计算的，称为样本方差（标准差），记为 （s）
平均差，也称平均绝对离差：将离差取绝对值，求和再平均得出的结果
方差：将离差平方后再求平均数得到的结果
标准差：方差开方后的结果
方差（或者标准差）是实际中应用最广泛的测度数据离散程度的统计量
4.2.3离散系数 标准差是反映数据离散程度的绝对值，11其数值的大小受原始数据取值大小的影响，数据的观测值越大，标准差的值通常也就越大
标准差与原始数据的计量单位相同，采用不同计量单位计算的数据，其标准差的值也就不同
对于不同组别的数据，如果原始数据的观测值相差较大或者计量单位不同，就不能用标准差直接比较，这是需要计算离散系数
离散系数（CV）：
又称变异系数，是统计学当中的常用统计指标。离散系数是测度数据离散程度的相对统计 量，主要是用于比较不同样本数据的离散程度。离散系数大，说明数据的离散程度也大；离散系数小，说明数据的离散程度也小。
一组数据的标准差与其相应的平均数之比。离散系数消除了数据取值大小和计量单位对标准差的影响，因此可以反映一组数据的相对离散程度
CV = s / 平均数x（标准差与平均数的比值（相对值）
4.2.4标准分数
也叫z分数，是一种具有相等单位的量数。它是将原始分数与团体的平均数之差除以标准差所得的商数，是以标准差为单位度量原始分数离开其平均数的分数之上多少个标准差，或是在平均数之下多少个标准差。它是一个抽象值，不受原始测量单位的影响，并可接受进一步的统计处理。
有了平均数和标准差之后，可以计算一组数据中每个数值的标准分数。它是某个数据与其平均数的离差除以标准差后的值。
标准分数可以测度每个数值在该组数据中的相对位置，并可以用来判断一组数据是否有离群点。
例：全班平均考试分数为80分，标准差为10分，你的考试分数是90分，与平均分有1个标准差的距离
这里的1就是你考试成绩的标准分数
标准分数说的是某个数据与平均数相比相差多少个标准差
将一组数据化为标准化得分的过程称为数据的标准化
在对多个具有不同量纲的变量进行处理时，常常需要对各变量的数据进行标准化处理，也就是把一组数据转化为具有平均数为0、标准差为1的新数据。
标准分数只是将原始数据进行了线性变换，它没有改变某个数值在该组数据中的位置，也没有改变该组数据分布的形状
判断一组数据中是否存在离群点
对称分布的数据（经验法则）：
当一组数据对称分布时，约有68%的数据在平均数加减1个标准差的范围之内；
约有95%的数据在平均数加减2个标准差的范围之内；
约有99%的数据在平均数加减3个标准差的范围之内
在平均数加减3个标准差的范围之内几乎包含了全部数据，而在3个标准差之外的数据在统计上也称为离群点。
适合任何分布形态的数据（切比雪夫不等式）：
切比雪夫不等式提供的是“下界”，也就是“所占比例至少是多少”
对于任意分布形态的数据，根据切比雪夫不等式，至少有（1-1/k的平方）的数据落在+-k个标准差之内。其中k是大于1的任意值，但不一定是整数。
对于k= 2,3,4，该不等式的含义是：
至少有75%的数据在平均数+-2个标准差的范围之内
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58dba0916a006ef97b78f0413a602d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e38040ebf6fd6dd47871c0596ff0cd9c/" rel="bookmark">
			Vue.min.js下载 单文件v2.7.14
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把后缀.TXT改成.js就行了
抗揍云链接：vue.min.txt - 蓝奏云
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a3e02703a04431059297dce9c7f706/" rel="bookmark">
			【算法设计技巧】分治算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分治算法 用于设计算法的另一种常用技巧为分治算法(divide and conquer)。分治算法由两部分组成：
分(divide)：递归解决较小的问题(当然，基准情况除外)治(conquer)：然后，从子问题的解构建原问题的解。 传统上，在其代码中至少含有两个递归调用的例程叫作分治算法，且一般认为子问题是不相交的(即基本上不重叠)。例如，最大子序列和问题的一个 O(N logN) 的解法，以及分治算法的经典例子：归并排序 和 快速排序，它们分别有 O(N logN) 的最坏情形以及平均时间的时间界。
分治算法的运行时间 有效的分治算法都是把问题分成一些子问题，每个子问题都是原问题的一部分，然后进行某些附加的工作以算出最后的答案。例如，归并排序对两个问题进行运算，每个问题均为原问题大小的一半，然后用到 O(N) 的附加工作。由此得到运行时间方程(带有合适初始条件)：
T(N) = 2T(N/2) + O(N) 该方程的解为 O(N logN)。下面的定理可以用来确定大部分分治算法的运行时间。
方程 T(N) = aT(N/b) + O(Nk) 的解为
其中 a ≥ 1 以及 b ＞1。
最近点问题 问题的输入是平面上的点集 P。如果 p1 = (x1, y1) 和 p2 = (x2, y2)，那么 p1 和 p2 间的欧几里得距离为 [ (x1 - x2)2 + (y1 - y2)2 ]1/2 。需要找出一对最近的点。这其中有可能两个点位于相同的位置，在这种情况下它们的距离为 0。
如果存在 N 个点，那么就存在 N(N-1)/2 对点间的距离。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4a3e02703a04431059297dce9c7f706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c7388f90b97082e5dadf01697519ab/" rel="bookmark">
			硕士论文第5章-算法软件测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地铁客流计数传感器应用软件-功能测试
初始化程序，等待接收控制命令。
8009开始计数·
8004请求计数信息
8005清零
800a停止计数
8006上传视频
8007结束程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d39e2ddb097264dc3ce4615bb99f85/" rel="bookmark">
			Java编写的聊天系统 带详细设计报告 功能非常齐全 完整源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家分享一个java语言编写的聊天系统程序，目前系统功能已经很全面，后续会进一步完善。整个系统界面漂亮，有完整得源码，希望大家可以喜欢。喜欢的帮忙点赞和关注。一起编程、一起进步
开发环境 开发语言为Java，开发环境Eclipse或者IDEA都可以，数据为MySQL。运行主程序，或者执行打开JAR文件即可以运行本程序。
系统框架 利用JDK自带的SWING框架开发。纯窗体模式，直接运行Main文件即可以。同时带有详细得设计文档。
主要功能 设计思路 随着计算机技术的飞速发展,尤其是互联网技术的兴起,使人们愈来愈倾向于通过网络来交流、传递消息。网络实时聊天系统正是这样一个被广泛应用的媒介。借助它,人们可以方便地进行实时对话。本次课程设计利用课程上所学的Java网络编程知识，开发出一个简易版本的多人和单人的聊小程序。系统的实现是基于TCP/IP通信协议,使用的是客户端/服务器模式,用到了Java里面的Swing、多线程、Socket等编程技术。通过直接使用Java提供的ServerSocket和ObjectInputStream等类将客户端和服务器端发送的各类消息封装实现消息的交换。需要实现的主要功能有
实现聊天室服务器端的要求：
①设计实现在特定端口上进行侦听，等待客户端的连接。
②用户确定服务器的侦听端口。
③系统能向已经连接到服务器端的用户发送系统消息。
④系统能统计在线人数。
⑤当系统停止服务时，设计程序应能断开所有的用户连接。
实现聊天室客户端的要求：
①系统能连接已经开启聊天服务的服务端。
②用户确定要连接服务器端的IP地址与端口号，连接后系统应能提供显示的用户名。
③当服务器端开启的话，实现用户的登录与注销。
④用户可以通过设计的系统向所有人或者某一个人发送消息
主要功能 本次课程设计实现的程序的关键功能有以下4点：
1 本程序分客户端和服务器端。服务器端启动一个socket连接，socket是多线程，接受从客户端发来的连接，如果更新成功，同时更新用户立表。
2 客户端启动，相应的就和服务器端建立一个socket，接受从服务器传递过来的消息，同时更新Textarea中，实时可以看到群里的内容。
3 服务器断开的时候，客户端能够收到提示，并且相应收到实时的消息，客户端能够收到消息提示，并且客户端退出。
4 能够一个服务器端和多个客户端进行通信
运行效果 (1) 启动服务器 启动服务端，启动服务器的端口，可以接受多个客户端发过来的，同时启动一个ServerThread，接受客户端发过的连接请求，发送消息等。
(2) 客户端启动 服务器端启动后，客户端可以进行启动，建立客户端和服务器的socket的连接，客户端可以看到当前在线用户，用户额聊天记录等，并且客户发送消息。发送的消息在服务端也能显示。
(3) 服务器关闭 当服务器关闭的时候，所有的客户端都会强制进行关闭。
清空用户列表
listModel.removeAllElements();
关闭并且释放SOCKET的相关资源
用户当前状态断开
(4) 群聊 多人聊天是指的，可以跟群里的所有人聊天，发送的消息，聊天室的所有人都能看到。
(4) 单聊 消息只能在发送和接受的人直接收到，其他的人不能收到。
关键代码 // 启动服务器 public void serverStart(int max, int port) throws java.net.BindException { try { clients = new ArrayList&lt;ClientThread&gt;(); serverSocket = new ServerSocket(port); serverThread = new ServerThread(serverSocket, max); serverThread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9d39e2ddb097264dc3ce4615bb99f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153967daccd63f4e97fc9af29599fda9/" rel="bookmark">
			Vue点击div按钮使其具备自动居中功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.写一个支持滑动的组件scroll.vue
&lt;template&gt; &lt;div class="scrollBarWrapper" :style="scrollBarWrapperStyle"&gt; &lt;div class="scrollBarContent" :class="direction === 'y' ? 'directionY' : 'directionX'" ref="scrollBarContent" &gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { direction: { type: String, default: "x", validator(value) { return value === "x" || value === "y"; } }, activeIndex: { type: Number, default: 0, validator(value) { return value &gt;= 0; } } }, watch: { activeIndex(newVal, oldVal) { this.handleChange(); } }, computed: { scrollBarWrapperStyle() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/153967daccd63f4e97fc9af29599fda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8de77fdbe3ac894cebbf3df42fb97cf1/" rel="bookmark">
			将echarts导入到word中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将echarts导入到word中 echarts自带保存图表配置 在echarts中有导出echarts图表图片的工具配置项
// 保存图片配置 toolbox: { feature: { saveAsImage: {} } }, 具体看下面代码的配置项
Documentation - Apache ECharts
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- vue在线引入 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- 引入样式 --&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;!-- 引入组件库 --&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;!-- 在线引入echarts --&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.1/echarts.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div id="main" style="width: 500px; height: 400px;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: '#app', data: { myChart: null }, methods: { // 初始化echarts initEcharts() { var chartDom = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8de77fdbe3ac894cebbf3df42fb97cf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed335c3b3549d5d6ae2333c0285ae047/" rel="bookmark">
			SpringBoot中整合Junit测试注入Bean失败的问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到这样一个问题；junt测试类引入bean失败导致查询数据报空指针。
博主就亲自测试了一下，成功注入。效果如下。
这里给大家讲一下如何处理bean注入失败的问题。
1:引入pom依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 2：创建测试类
加上下图中的两个注解
SpringbootApplication指的是启动类（非测试启动类）
注意的是测试包不要引用错了
这样就可以正常运行 了，希望能帮到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852a6ae6a980d1279e8e9b846c4e4009/" rel="bookmark">
			MySQL问题： mysql-community-libs-compat-5.7.41-1.el7.x86_64.rpm 的公钥尚未安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MySQL问题： mysql-community-libs-compat-5.7.41-1.el7.x86_64.rpm 的公钥尚未安装1、问题描述2、出现原因3、解决方案 MySQL问题： mysql-community-libs-compat-5.7.41-1.el7.x86_64.rpm 的公钥尚未安装 1、问题描述 使用yum安装mysql
yum -y install mysql-server 提示错误:
警告：/var/cache/yum/x86_64/7/mysql57-community/packages/mysql-community-common-5.7.41-1.el7.x86_64.rpm: 头V4 RSA/SHA256 Signature, 密钥 ID 3a79bd29: NOKEY mysql-community-common-5.7.41-1.el7.x86_64.rpm 的公钥尚未安装 mysql-community-libs-compat-5.7.41-1.el7.x86_64.rpm 的公钥尚未安装 失败的软件包是：mysql-community-libs-compat-5.7.41-1.el7.x86_64 GPG 密钥配置为：file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 2、出现原因 大概意思：
​ 如果使用的4.1以上版本的rpm的话，除了import mysql的公钥到个人用户的配置中，还需要import mysql的公钥到RPM的配置中
参考连接：
MySQL :: MySQL 5.7 Reference Manual :: 2.1.4.4 Signature Checking Using RPM
MySQL :: MySQL 5.7 Reference Manual :: 2.1.4.2 Signature Checking Using GnuPG
3、解决方案 运行命令：rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022
在重新安装 运行命令 [root@localhost ~]# rpm --import https://repo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852a6ae6a980d1279e8e9b846c4e4009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9ca2173b8272f2aa289ec7a194cf26/" rel="bookmark">
			Centos7 安装 MySQL5.7 步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7 安装 MySQL5.7 步骤 （一）、使用yum源方式安装1、卸载系统自带 mariadb2、下载并安装MySQL官方的 Yum2.1 下载mysql的yum源配置2.2 安装mysql的yum源2.3 使用yum方式安装mysql2.3.1 安装过程中报错解决 3、使用并设置mysql3.1 启动mysql并查看状态3.2 获取临时密码3.3 登录mysql3.4 修改登录密码 4、设置远程访问4.1 开启mysql的远程访问权限4.2 为firewalld添加开放端口33064.3 远程连接测试 5、至此，mysql安装结束 （二）、本地 tar 文件方式安装1、获取tar安装包文件1.1 下载mysql5.7安装包1.2 包上传到 Linux 服务器 2、安装前查看设置2.1 卸载 CentOS7 系统自带 mariadb2.2 检查系统是否安装过 MySQL2.3 检查有无 MySQL 用户组 3、安装 MySQL5.73.1 解压下载的tar文件3.2 解压tar.gz文件3.3 修改文件夹名称3.4 更改文件夹权限3.5 初始化mysql和获取密码3.6 编译my.cnf 配置文件3.6.1 修改 my.cnf 配置文件3.6.1 修改 my.cnf 权限 3.7 编译mysql.server 文件 4、设置mysql服务4.1 查询服务4.2 启动服务4.3 添加软连接，并重启服务 5、使用并设置mysql5.1 登录mysql5.2 修改密码 6、设置远程访问6.1 开启mysql的远程访问权限6.2 设置开机自启6.3 开放3306端口6.4 远程连接测试 7、至此，mysql安装结束 之前一直是在window上安装mysql，但是实际应用mysql都是安装在服务器上，所以记录一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e9ca2173b8272f2aa289ec7a194cf26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c08ffd753702afc5df74472d1d4653c/" rel="bookmark">
			Linux系统下gcc使用以及原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统下gcc使用以及原理详解 1.引言 在Windows系统下，我们已经能够很熟练的使用**VS、VSCode、VSC++**等编译器熟练地输出“Hello World”。可是在不同的Lunux操作系统下又该是怎样操作的呢？ 这就不得不提到今天所提的gcc系列命令。
​
例如：在Linux下创建一个Goodbye.c用来输出“Goodbye”
#include&lt;stdio.h&gt; int main() { printf("Goodbye!!\n"); return 0; } ​
​ gcc一个文件，系统会默认生成一个是a.out的一个可执行文件，再执行a.out方可输出。
[root@VM-16-17-centos Blog]# gcc Goodbye.c [root@VM-16-17-centos Blog]# ./a.out [root@VM-16-17-centos Blog]# Goodbye!! ​ 注意：[./+可执行文件]是直接执行的命令，一般gcc后不具体添加命令选项会默认给a.out可执行文件。
​ 可恶！ 在这里我们意识到，Linux下并不会直接编译通过就输出，而是gcc后会生成一个可执行文件，再通过一个可执行文件来间接执行。那么为什么在Linux系统下会这样”多此一举“呢？接下来我们就要了解一下一段程序电脑是怎么翻译的。
2.具体介绍 ​ 首先，一段程序电脑会进行预处理、编译、汇编、链接的翻译：
​
​
由于Linux系统默认自带语言级别的头文件和库，经过此“四大才子”之手程序才会最终呈现出我们想要的方式。
2.1预处理 作用： 展开所包含的头文件、宏的替换和满足条件的编译(如if、else语句满足即编译，不满足忽略)等。
文件格式：Goodbye.i
命令选项： -E
具体命令：gcc -E + 可执行文件 -o + 名称.i
该命令意为从现在开始进行程序翻译直到预处理完就停止。命令可以查看预处理完后的文件形态。
2.2编译 作用：将程序翻译成汇编语言。
文件格式：Goodbye.s
命令选项：-S
具体命令：gcc -S + 可执行文件 -o + 名称.s
、
该命令意为从现在开始进行程序翻译直到编译完就停止。命令可以查看编译完后的文件形态。
2.3汇编 作用：汇编成可重定位的目标二进制文件，如：.bin .obj文件等，该状态下不可被执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c08ffd753702afc5df74472d1d4653c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96d43bbc5e514179c64df838805f5ea/" rel="bookmark">
			海思Hi3516DV300---部署yolov5检测&#43;Sort跟踪算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海思Hi3516DV300-部署 1. 部署yolov5检测+Sort跟踪算法---统计地铁中人流量（双向计数+tof相机）2. yolov5s模型转换onnx模型3. 在虚拟机中安装caffe （caffe模型的转化是在虚拟机中完成的）4. onnx模型转换caffe模型5. caffe模型转换wk模型6. 在虚拟机中利用RuyiStudio生成的.wk文件转换成model.o文件（最终目标）7. 可以用MobaXterm（或者Shell）连接上海思Hi3516DV300开发板8. 计数平均准确度超过95%。9. 参考文献 1. 部署yolov5检测+Sort跟踪算法—统计地铁中人流量（双向计数+tof相机） 先用python—yolov5s训练一个best.pt模型
我们与大家部署的更多一个跟踪Sort算法
2. yolov5s模型转换onnx模型 pip安装onnx和onnx-simplifierpip install onnxpip install onnx-simplifiergit clone https://github.com/ultralytics/yolov5.git训练自己的模型步骤参考yolov5官方介绍，训练完成后我们得到了一个模型文件cd yolov5python models/export.py --weights 训练得到的模型权重路径 --img-size 训练图片输入尺寸python -m onnxsim onnx模型名称 yolov5s-simple.onnx 得到最终简化后的onnx模型 3. 在虚拟机中安装caffe （caffe模型的转化是在虚拟机中完成的） 有点复杂，拷贝我的虚拟机。在我的笔记本上，我已经装好了。
密码：123
4. onnx模型转换caffe模型 git clone https://github.com/Wulingtian/yolov5_onnx2caffe.git解压 yolov5_onnx2caffecd yolov5_onnx2caffevim convertCaffe.py设置onnx_path（上面转换得到的onnx模型），prototxt_path（caffe的prototxt保存路径），caffemodel_path（caffe的caffemodel保存路径）python convertCaffe.py 得到转换好的caffe模型（可得到一个.prototext文件和一个.caffemodel文件） 5. caffe模型转换wk模型 1.链接: 华为Hi3516DV300 系列芯片平台模型转换，caffe 转NNIE wk注意事项.
2. caffe模型转换wk模型本质：利用.prototext文件和一个.caffemodel文件生成.wk文件
3. 步骤: 按照上述链接新建工程—&gt;双击左边的最下的.cfg文件
4. cfg配置如下：
5. 注意将.cfg文件中compile_mode = 0 改成compile_mode = 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96d43bbc5e514179c64df838805f5ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f393aebce8c0664ad1fe4da555c5958/" rel="bookmark">
			C语言常见函数返回值类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sizeof() 返回值 size_t
strlen() size_t strlen(const char *string);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdace39cada60dc034814e5fc5cacf8f/" rel="bookmark">
			Lombok--使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：Lombok--使用_IT利刃出鞘的博客-CSDN博客
简介 说明
本文介绍Lombok。
官网
Project Lombok
https://github.com/rzwitserloot/lombok
Lombok简介 Automatic Resource Management, automatic generation of getters, setters, equals, hashCode and toString, and more!
在项目使用了Lombok的情况下，安装lombok插件可以保证开发时的代码提示和代码检查的正常。
Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。
当修改/增加属性时，往往需要修改toString()，getter/setter等，容易遗漏。Lombok可以自动生成。
Lombok实现原理
自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”规范，只要程序实现了该API，就能在javac运行的时候得到调用。
Lombok就是一个实现了"JSR 269 API"的程序。在使用javac的过程中，它产生作用的具体流程如下：
1. javac对源代码进行分析，生成一棵抽象语法树(AST)
2. javac编译过程中调用实现了JSR 269的Lombok程序
3. 此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树 (AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点
4. javac使用修改后的抽象语法树(AST)生成字节码文件
插件安装 1.引入依赖
maven：
&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; grable：
其他网址：lombok官网（gradle部分）
法1：非插件法
dependencies { compileOnly 'org.projectlombok:lombok:1.18.12' annotationProcessor 'org.projectlombok:lombok:1.18.12' testCompileOnly 'org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdace39cada60dc034814e5fc5cacf8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a376a18b17320f7b949055aad957cee7/" rel="bookmark">
			C语言 格式化占位符的语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf 函数用于打印格式化字符串到标准输出流。 函数原型：参数解析：format 参数flags（标志，可选）的内容即含义如下：width（宽度，可选）是一个数值，用于指定最小字段的宽度.precision（.精度，可选），通过点号（.）分隔字段的宽度和精度length（长度修饰符，可选）的值可以是 h、hh、l、ll 或 L... 附加参数返回值： int *；存放已写字符的个数
函数原型： #include &lt;stdio.h&gt; ... int printf ( const char * format, ... ); 参数解析： format 参数 format 参数是一个格式化字符串，由格式化占位符和普通字符组成。
格式化占位符（以 % 开头）用于指明输出的参数值如何格式化。
格式化占位符的语法如下：
%[flags][width][.precision][length]specifier
每一个格式化占位符均以 % 开始，以转换字符结束。
specifier（转换字符，必选）的内容及含义如下：
转换字符参数类型；转换结果cchar；字符dint；有符号十进制整数i同上edouble；以指数形式输出单、双精度浮点数（小写 e）E同上（大写 E）fdouble；以小数形式输出单、双精度浮点数gdouble；以 %f 或 %e 中较短的输出宽度输出单、双精度浮点数（指数显示小写 e）G同上（指数显示大写 E）ounsigned int；无符号八进制（无前导 0）schar *；字符串uint；无符号十进制xunsigned int；无符号十六进制（无前导 0x）X同上（无前导 0X）pvoid *；指针值nint *；存放已写字符的个数%不进行参数转换；% 自身 注：如果 % 后边的字符不是转换字符，则其行为没有定义。
flags（标志，可选）的内容即含义如下： 标志含义-指定被转换的参数在其字段内左对齐（默认是右对齐）+指定在输出的数前面加上正负号空格如果第一个字符不是正负号，则在其前面加上一个空格0对于数值转换，当输出长度小于字段宽度时，添加前导 0 进行填充#指定另一种输出形式：1. 如果转换字符为 o，则第一个数字为0。2. 如果转换字符为 x 或 X，则指定在输出的非 0 值前加 0x 或 0X。3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a376a18b17320f7b949055aad957cee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cb5e2f77865d2965569fd1f00f2b74a/" rel="bookmark">
			一个由二级索引引发的P1惨案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、业务背景二、故障出现三、故障定位&amp;&amp;止血四、事后复盘删除二级索引的动机二级索引的设计 五、故障总结开发侧：DBA侧：阿里云： 结语 前言 前不久在实习的时候搞了个P1故障，导致服务不可用将近一小时，最后排查复盘发现竟然只是一个二级索引！
一、业务背景 5000w+数据，1024分表
中午12点准时推单，一般推单会持续15min-30min，该业务为核心业务，一旦受阻影响面很大。
二、故障出现 业务侧反馈中午推单卡住，一单未推（该业务为关键业务，很紧急，影响面大）。
上阿里云日志看到
Error updating database. Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: [15b848918060c000-2][10.0.62.142:3306][booking_center]ERR-CODE: [TDDL-4614][ERR_EXECUTE_ON_MYSQL] Error occurs when execute on GROUP 'BOOKING_CENTER_1617764186004XHSA_PURM_0001' ATOM 'rm-bp17rbdzegw1600mp_booking_center_nmqq_0001': Lock wait timeout exceeded; try restarting transaction 报警出现大量锁等待超时。
同时钉钉群里有大量长事务告警。
三、故障定位&amp;&amp;止血 12:19 初步定位
看到报警内容，可以定位到是数据库长事务导致新的语句无法执行。此时确定是数据库的问题，开始联系dba解决。
由于是饭点，其他开发和dba都去吃午饭了，都匆匆赶回公司。
12:38 dba到场
看到故障的第一反应是kill掉所有的长事务，但是尝试kill发现并不能成功kill。
回顾最近的修改，只有昨天五点左右删除了相关表的一个二级索引。我们推测和这个有关，所以建议执行增加二级索引的DDL操作。
12:43 执行后发现该索引一直在pending，没有执行，猜测是长事务霸占了行锁。开始联系阿里云技术人员支持。
此时所有update都被阻塞。
我们找到了产生长事务的sql
&lt;!-- 经过脱敏的代码 --&gt; &lt;update id="***"&gt; &lt;foreach collection="***" item="i" open="" close="" index="index" separator=";"&gt; update bh_order_line &lt;set&gt; &lt;if test="i.a!=null"&gt; a=#{i.a}, &lt;/if&gt; &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cb5e2f77865d2965569fd1f00f2b74a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6539d884f6d8bd5dc1b875d17f63dc30/" rel="bookmark">
			excel核对技巧：这么多数据对比的方法应该够用了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常工作不时会需要对比数据，查找差异，查找重复值等。有的是对比同一工作表中的数据，有的是对比不同工作表之间的数据。希望接下来介绍的多种Excel数据对比方法，让大家能在不同情况下都能快速完成数据的对比。
第一部分：同一表内数据比较
1.严格比较两列数据是否相同：所谓严格比较就是指数据按位置对应比较。
1）快捷键对比Ctrl+
如下图所示，选中需要对比的两列数据A列和B列，然后按下快捷键Ctrl+，不同的数据B5、B9、B10、B15则会处于选中状态。
2）定位法对比（快捷键F5或Ctrl+G）
以下表为例，框选A列和B列的列标题快速选择两列数据，然后按快捷键F5（或Ctrl+G）即可调出定位窗口，选择定位条件为“行内容差异单元格”，单击“确定”按钮，不同的数据会处于选中状态。
注意：以上两种方法可以快速比对两列数据的差异但均不会区分字母大小写。
3）IF函数对比
（1）不需要区分字母大小写的if函数对比
下表A、B两列都是数字，不存在字母，不需要区分大小写。
可以在C2单元格输入公式=IF(A2=B2,"相同","不相同")，输入好之后拉动手柄向下拖动，直到本列数据截止，相同不同结果一目了然，如下表。
（2）区分字母大小写的if函数对比
如遇对比数据含字母，并且需要区分大小写，则上述公式不能准确对比。此时可将C2公式更改为=IF(EXACT(A2,B2)=TRUE,"相同","不相同")，然后下拉填充公式，最终如下图所示。
2.找出两列数据的重复值
1）IF + MATCH函数查找重复值
现在要对下表找出连续两个季度中奖的名单，又有什么方法呢？
其实，就是要通过对比A列与B列，找出重复值。我们可以用IF+MATCH函数组合公式，在C2单元格输入公式=IF(ISERROR(MATCH(A2,$B$2:$B$25,0)),"",A2)，然后下拉复制公式，则可完成查找任务。对比查找结果见下表：
公式解析：
MATCH用于返回要查找的数据A2在区域$B$2:$B$25中的位置。如果查到会返回一个行号（表示有重复），没有查到则返回错误#N/A（表示无重复）。
公式中加入ISERROR函数，用于判断MATCH返回的值是否是个错误#N/A，是错误#N/A则返回TRUE，不是错误#N/A则范围FALSE。
最外围的IF函数，根据ISERROR（MATCH（））是TRUE还是FALSE，返回不同值。如果是TURE（也就是没有重复），则返回空；如果是FALSE，则返回A2。
如果我们要查找出1季度中奖但2季度没有中奖的名单，我们就可以将上述函数公式改成为：=IF(ISERROR(MATCH(A2,$B$2:$B$25,0)), A2, "")。
2）IF+COUNTIF函数查找重复值
下表A、B两列都是客户的姓名，需要找到两列重复的客户名称，并在C列标识出来。
操作方法为在C2单元格输入公式=IF(COUNTIF(A:A,B2)=0,"",B2)，然后下拉完成excel两列数据对比。请看下面演示！
COUNTIF函数是对指定区域中符合指定条件的单元格计数的一个函数。
考考你：
如果上述中对比的数值超过15位，比如对比的是身份证号，上述公式是否还可以用？如果上述公式不能用了，改换成以下公式呢？
=IF(COUNTIF(A: A,B2&amp;"*")=0," ",B2)
或者
=IF(SUMPRODUCT(1*(A:A=B2)),B2,"")
如果不知道答案，欢迎观看教程《卡号离奇减少表哥冤枉被罚——Excel，原来你有真假重复！》。
3）IF+VLOOKUP函数查找重复值
如下表所示，有这样两组员工号。不知道哪些是A、B两组都有的。我们也可以用if+VLOOKUP函数公式来完成比对。
在C2单元格中输入公式：=IF(ISNA(VLOOKUP(A2,$B$2:$B$25,1,))," ",A2)，然后下拉复制公式，则可找到Excel两列数据中的重复值。
公式解析：
ISNA函数用于判断值是否为错误值#N/A(即是值不存在),如果是,则返回TRUE;否则返回FALSE。
公式里面需要在查找区域的数据前都加上$符号，固定查找区域。否则在下拉填充的时候，查找区域也会跟着变化，这将会影响查找对比的结果。
应用扩展：用Vlookup找不同
该公式稍作调整即可在找出不同值，或缺少值、错误值（非严格比较，不讲究位置或顺序）。譬如上面的B组是标准数据，要把A组中与B组不同的值找出来，公式可以写成：
=IF(ISNA(VLOOKUP(A2,$B$2:$B$25,1,)), A2, " ")
第二部分：跨表数据比较
1.严格比较两个表的数据是否相同
当两个格式完全一样的表格进行对比查找差异时，可以采用下方的方法。
1）条件格式法对比两表差异
现以下面两表为例，要比对出哪些数值存在差异并突出显示出来。
首先，先选中一个表，新建规则，并选择“使用公式确定要设置格式的单元格”，然后输入=A9A1 , 对相对应的单元格进行判断，判断其是否相等。请看下面演示！
温馨提示：
如果要清除条件格式，先选中要清除格式的单元格区域，依次执行“开始”- “条件格式”–“ 清除规则”–“ 清除所选单元格的规则”（或清除整个工作表的规则）。
2）选择性粘贴法对比两表差异（该法只适合数字的比较）
如下图所示，两表格式相同姓名排序相同，要求快速找出两个表格的数据差异。
复制其中一个数值区域，然后按快捷键Ctrl+Alt+V选择性粘贴，设置为“减”运算，单击“确定”后，非0部分即差异所在。请看下面演示！
此方法只适合快速定位差异数据，看一眼就算的那种，因为会破坏原数据表格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6539d884f6d8bd5dc1b875d17f63dc30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4e68a7e9d65e3724b0f10251ad89be/" rel="bookmark">
			深入浅出，全方位剖析 ES6 的 class 类及其继承机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、class 类
在 ES6 之前生成实例对象的传统方法是通过构造函数，方式如下。
function Person(name, age) { this.name = name; this.age = age; } Person.prototype.fn = function() {}; const p = new Person('ZhangSan', 18); 而 ES6 提供了一种更接近传统语言的写法，即引入 class （类）的概念，定义类时，使用关键词 class，上述代构造函数的例子，可以换成类来实现，写法如下。
class Person { constructor(name, age) { // 构造方法 name = name; age = age; } fn() { ... } // 原型方法 } const p = new Person('ZhangSan', 18); 上述代码定义了一个 Person 类，constructor() 是类的构造方法，构造方法里面的 this 代表的是类的实例对象。
1、 类的语法，定义类的时候需要使用 class 关键词。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe4e68a7e9d65e3724b0f10251ad89be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cf047d049fc1ad998426c1bd00348d/" rel="bookmark">
			线性方程组求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初来乍到，多多指教！
问题：
线性方程组求解
输入是N（N&lt;256）元线性方程组Ax=B，输出是方程组的解，也可能无解
或有多组解。可以用高斯消去法求解，也可以采用其它方法。
1.高斯消元：通过增广矩阵将系数与常数集中放在一起，利用增广矩阵性质
将矩形变为\形，再倒着依次求出相关变量值
2.矩形变\形：通过依次以1~n行为操作对象，将此行以下的行首系数与此行首系数比较，化同，做差即为消去系数少一个变量的方程，如此，最后形成的方阵便是\形
3.从后回代求解：在矩阵变\形时，对每行行首系数化为一，若此行为第i+1行，则第i行第i+1列未知量就是此行行首未知量，因为行首系数为1，则第i行方程减去第i+1行方程的a[i][i+1]倍（第i行第i+1列未知量的系数）即得到第i行行首未知量，如此循环得到所有变量。
4.解的判定：高斯消元后，若是标准的\形，有唯一解；若消元后的行数小于n行（元的个数）且没有出现0=常数（矛盾）的情况，则有多解，若出现0=常数的情况，则无解。
附上源代码
#include&lt;iostream&gt;
#include &lt;cmath&gt;
#include&lt;iomanip&gt;
using namespace std;
const int N = 260;
const double eps = 1e-6;//double精度
double a[N][N];
int n,i,j;
int work(int x)
{
//矩形变\形
//每循环一次重新定义一次，这样可以同时记录有几行，可以与原行数进行比较，进而判断解的情况
int c=0, r=0;//c表示在枚举哪一列，r表示在枚举哪一行
//高斯消元
for (; c &lt; x; c++)
{
int maxr = r;
for (i = r; i &lt; x; i++)//列不变，行变，找到对应系数绝对值最大的交换，减小误差
{
if (fabs(a[i][c]) &gt; fabs(a[maxr][c]))//定位到当前列主元的最大系数所在行 maxr = i;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75cf047d049fc1ad998426c1bd00348d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eecf04573bd516710680561b2b05f38b/" rel="bookmark">
			3DMAX 卸载方法，完美彻底卸载清除干净3DMAX各种残留注册表和文件【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3DMAX卸载工具，完全彻底删除干净3DMAX各种残留注册表和文件。3DMAX安装失败，怎么完全彻底删除清理干净3DMAX各种残留注册表和文件呢？有些同学想把3DMAX重新安装，但是3DMAX安装失败显示失败，有时3DMAX安装到一半就显示失败，然后会问3DMAX无法重装是怎么回事。那么3DMAX安装失败的原因是什么呢？如何才能把3DMAX卸载干净呢？有人说只要把3DMAX注册表7d2f删除就可以了，但是有的同学找到了3DMAX注册表7d2f也删除了，但是3DMAX再次安装失败。还有的同学直接重装系统，但是重装系统后3DMAX仍然无法安装。还有的同学直接把3DMAX的程序文件删除，重装3DMAX的时候会显示已安装。那么3DMAX卸载不干净无法重装的原因到底是什么呢？答案可能不是唯一！
3DMAX提示安装未完成，某些产品无法安装该怎样解决呢？一些朋友在win 7或者win 10系统下安装3DMAX失败提示3DMAX安装未完成，某些产品无法安装；也有时候想重新安装3DMAX的时候会出现本电脑windows系统已安装3DMAX，你要是不留意直接安装3DMAX，只会安装3DMAX的附件或者直接提示安装失败，3DMAX是安装不上的。这种原因就是大家在之前卸载3DMAX时没有把3DMAX残留注册表信息删除或者是因为C++版本不对。下面我来教大家如何把3DMAX强力卸载掉然后重新安装，最后完美安装运行3DMAX，如果纯手工删除3DMAX会有很多条注册表记录要删。
3DMAX没有按照正确方式卸载，导致3DMAX安装失败。楼主也查过网上关于如何解决3DMAX安装失败的一些文章，是说删除几个3DMAX文件和3DMAX软件注册表就可以解决3DMAX安装失败的问题，实际的情况并没有这么简单，导致3DMAX安装失败的原因有很多种。3DMAX安装时产生了几万条注册表，想要彻底卸载3DMAX软件再重新安装3DMAX就有几万条3DMAX注册表要删除，非人力所能为。现在虽然360或者其他一些卸载软件提供了强力卸载3DMAX的工具，可以将3DMAX注册表和一些3DMAX目录的3DMAX残留信息删除，但仍不能确保将3DMAX所有相关dll程序文件、exe可执行文件和注册表全部彻底删除干净。3DMAX安装失败还和C++版本问题有关，因为每个版本的3DMAX都是基于一定版本的C++版本而开发的，如果是这种情况，重装系统C++问题还是可能会存在的。安装成功后，如果缺少必要的dll动态链接库文件，也会导致3DMAX启动和注册失败。上面说了这么多，只是几种3DMAX安装失败最常见的情况。这里使用到一个3DMAX卸载工具，专门用来解决卸载修复3DMAX软件卸载安装失败的问题。3DMAX卸载工具会自动执行一系列问题的排查和修复，极大的节省了排除安装3DMAX失败问题的时间。卸载之后，建议最好用Autodesk官方原始的安装包，压缩包的常常会缺少一些组件也可能导致3DMAX安装失败，安装时还要使用管理员帐户进行安装。
Autodesk卸载工具是专门为了针对Autodesk类软件卸载不干净而导致Autodesk安装失败问题进行研发的Autodesk一键卸载工具。现在虽然360或一些卸载软件提供了强力卸载Autodesk的工具，可以将Autodesk注册表和一些Autodesk目录的Autodesk残留信息删除，但仍不能确保将Autodesk所有相关程序文件和注册表全部彻底删除。也查过网上关于如何卸载Autodesk的一些文章，是说删除几个Autodesk文件和Autodesk软件注册表就可以了，情况并没有这么简单。Autodesk安装时产生了几万条注册表，想要彻底卸载Autodesk软件，就有几万条Autodesk注册表要删，非人力所能为。Autodesk安装失败还和C++版本问题有关，因为每个版本的Autodesk都是基于一定版本的C++版本而开发的。上面说了这么多，只是两种最常见的情况。这里介绍一个Autodesk卸载工具，专门用来解决卸载修复Autodesk类软件卸载安装失败的问题。Autodesk卸载工具会自动执行一系列问题的排查和修复，极大的节省了排除安装Autodesk失败问题的时间。
绿色版卸载工具分享下载
地址一(百度网盘)
地址二(直接下载)
密钥：【AtrXShXX9zRwhMmRwShzXXtwXMzXrm899Jm5J6yXA5zmh8xzbhXzy6hzoyah6xAm##】
解决方法：
1、选择想要卸载的软件，比如3DMAX，其他的autodesk软件也是一样的操作
2、选择autodesk 3DMAX的版本
3、点击“开始卸载&amp;修复”按钮，等他提示卸载结束的对话框
4、卸载后重新安装autodesk 3DMAX软件、可以愉快的使用了
enjoy it !
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/077427881d0e811bb3ba0c8fa3e449e9/" rel="bookmark">
			CAD 卸载工具，完美彻底卸载清除干净CAD各种残留注册表和文件【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些同学安装CAD出错了，也有时候想重新安装CAD的时候会出现这种本电脑已安装CAD，你要是不留意直接安装，只会安装CAD的附件，CAD是安装不上的。这种原因呢就是大家在之前卸载CAD时没有把CAD残留信息删除，下面我来教大家把CAD卸载然后重新安装，最后完美安装运行CAD。
绿色版卸载工具分享下载
地址一(百度网盘)
地址二(直接下载)
密钥：【AtrXShXX9zRwhMmRwShzXXtwXMzXrm899Jm5J6yXA5zmh8xzbhXzy6hzoyah6xAm##】
1、在软件中选择CAD
2、选择CAD的版本
3、点击“【开始卸载&amp;修复】”按钮，等待卸载结束
​​​​​​4、重新安装、可以使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def45b5f1aae82737257f872caf63d1d/" rel="bookmark">
			【AutoCAD 卸载工具，完全彻底删除清理干净AutoCAD各种残留注册表和文件】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AutoCAD卸载工具，完全彻底删除干净AutoCAD各种残留注册表和文件。AutoCAD安装失败，怎么完全彻底删除清理干净AutoCAD各种残留注册表和文件呢？有些同学想把AutoCAD重新安装，但是AutoCAD安装失败显示失败，有时AutoCAD安装到一半就显示失败，然后会问AutoCAD无法重装是怎么回事。那么AutoCAD安装失败的原因是什么呢？如何才能把AutoCAD卸载干净呢？有人说只要把AutoCAD注册表7d2f删除就可以了，但是有的同学找到了AutoCAD注册表7d2f也删除了，但是AutoCAD再次安装失败。还有的同学直接重装系统，但是重装系统后AutoCAD仍然无法安装。还有的同学直接把AutoCAD的程序文件删除，重装AutoCAD的时候会显示已安装。那么AutoCAD卸载不干净无法重装的原因到底是什么呢？
AutoCAD提示安装未完成，某些产品无法安装该怎样解决呢？一些朋友在win7或者win10系统下安装AutoCAD失败提示AutoCAD安装未完成，某些产品无法安装，也有时候想重新安装AutoCAD的时候会出现本电脑windows系统已安装AutoCAD，你要是不留意直接安装AutoCAD，只会安装AutoCAD的附件或者直接提示失败，AutoCAD是安装不上的。这种原因就是大家在之前卸载AutoCAD时没有把AutoCAD残留注册表信息删除或者是因为C++版本不对，下面我来教大家如何把AutoCAD强力卸载掉然后重新安装，最后完美安装运行AutoCAD，如果纯手工删除AutoCAD会有很多条注册表记录要删。
AutoCAD没有按照正确方式卸载，导致AutoCAD安装失败。楼主也查过网上关于如何解决AutoCAD安装失败的一些文章，是说删除几个AutoCAD文件和AutoCAD软件注册表就可以解决AutoCAD安装失败的问题，实际的情况并没有这么简单，导致AutoCAD安装失败的原因有很多种。AutoCAD安装时产生了几万条注册表，想要彻底卸载AutoCAD软件再重新安装AutoCAD就有几万条AutoCAD注册表要删除，非人力所能为。现在虽然360或者其他一些卸载软件提供了强力卸载AutoCAD的工具，可以将AutoCAD注册表和一些AutoCAD目录的AutoCAD残留信息删除，但仍不能确保将AutoCAD所有相关dll程序文件、exe可执行文件和注册表全部彻底删除干净。AutoCAD安装失败还和C++版本问题有关，因为每个版本的AutoCAD都是基于一定版本的C++版本而开发的，如果是这种情况，重装系统C++问题还是可能会存在的。安装成功后，如果缺少必要的dll动态链接库文件，也会导致AutoCAD启动和注册失败。上面说了这么多，只是几种AutoCAD安装失败最常见的情况。这里使用到一个AutoCAD卸载工具，专门用来解决卸载修复AutoCAD软件卸载安装失败的问题。AutoCAD卸载工具会自动执行一系列问题的排查和修复，极大的节省了排除安装AutoCAD失败问题的时间。卸载之后，建议最好用Autodesk官方原始的安装包，压缩包的常常会缺少一些组件也可能导致AutoCAD安装失败，安装时还要使用管理员帐户进行安装。
绿色版卸载工具分享下载
地址一(百度网盘)
地址二(直接下载)
密钥：【AtrXShXX9zRwhMmRwShzXXtwXMzXrm899Jm5J6yXA5zmh8xzbhXzy6hzoyah6xAm##】
解决方法：
1、选择想要卸载的软件，比如AutoCAD，其他的autodesk软件也是一样的操作
2、选择autodesk AutoCAD的版本
3、点击“【开始卸载&amp;修复】”按钮，等他提示卸载结束的对话框
4、卸载后重新安装autodesk AutoCAD软件、可以愉快的使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa8501fa212092177a32c7024407a91/" rel="bookmark">
			libcublas.so.11: undefined symbol: cublasLtGetStatusString, version libcublasLt.so.11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装pytorch之后，import torch报错
libcublas.so.11: undefined symbol: cublasLtGetStatusString, version libcublasLt.so.11 解决方法
pip uninstall nvidia_cublas_cu11 https://stackoverflow.com/questions/74394695/how-does-one-fix-when-torch-cant-find-cuda-error-version-libcublaslt-so-11-no
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a725fe3de06db25f64487a0fa472129/" rel="bookmark">
			vue-cli引入wangEditor、Element，封装可上传附件的富文本编辑器组件（附源代码直接应用，菜单可调整）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Element安装引入，请参考我的另一篇文章：vue-cli引入Element Plus（element-ui），修改主题变量，定义全局样式_shawxlee的博客-CSDN博客_chalk variables
1、安装wangeditor npm i wangeditor --save wangEditor官方文档：Introduction · wangEditor 用户文档
2、在页面中引入wangeditor创建编辑器 附上自己封装的富文本编辑器组件源代码，可上传图片和附件：
&lt;template&gt; &lt;!-- 富文本编辑器 --&gt; &lt;div class="rich_editor"&gt; &lt;div :id="id" style="margin-bottom: 10px"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;!-- 上传附件 --&gt; &lt;el-upload ref="upload" action="#" multiple :on-remove="onRemove" :on-change="onChange" :auto-upload="false" :file-list="fileList"&gt; &lt;template #trigger&gt; &lt;el-button type="text" icon="el-icon-circle-plus" style="line-height: normal;"&gt;添加附件&lt;/el-button&gt; &lt;/template&gt; &lt;!-- 操作按钮 --&gt; &lt;span style="float:right;"&gt; &lt;el-button type="primary" size="small" @click="submit" :disabled="(!editorInput.content &amp;&amp; fileList.length == 0) || loading"&gt;&lt;i class="el-icon-loading" v-show="loading"&gt;&lt;/i&gt; 提交&lt;/el-button&gt; &lt;el-button size="small" @click="cancel"&gt;取消&lt;/el-button&gt; &lt;/span&gt; &lt;!-- 提示文本 --&gt; &lt;template #tip&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a725fe3de06db25f64487a0fa472129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/165de2658d948fa40441fef9f6726dfd/" rel="bookmark">
			WordCloud库的安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看与自己系统所匹配的WordCloud库的版本
在命令行中输入：pip debug --verbose
2、 下载对应版本的WordCloud文件 下载地址：https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud
下载后将文件保存至Python Interpreter位置中：
3、下载完成后在命令行中执行安装命令
进入文件所在文件夹：cd C:\Users\Win10\AppData\Local\Programs\Python\Python38
安装：pip install wordcloud-1.8.1-cp38-cp38-win_amd64.whl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e7aa45d5e62ffe29899a1acc32adf6/" rel="bookmark">
			mysql中select查询group by引起的报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 系统环境二 问题描述三 原因分析四 解决方案 一 系统环境 [root@db01 ~]# cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) [root@db01 ~]# uname -r 3.10.0-862.el7.x86_64 二 问题描述 安装mysql5.7.26版本，在建库建表后进行查询操作出现下面报错。
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'sql_mode =STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY' at line 1 三 原因分析 我的查询语句是这样的。
select id,countrycode,sum(population) from city group by countrycode; 根据报错大概推断，select后面的内容要和group by后面的内容必须完全一致，如果不一致，则需要添加参数进行设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e7aa45d5e62ffe29899a1acc32adf6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/104/">«</a>
	<span class="pagination__item pagination__item--current">105/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/106/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>