<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78f4fc601eb0c793ce987ed6a62a72d/" rel="bookmark">
			uniapp安卓在线更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在pages里创建一个app-update.vue文件并注册
&lt;template&gt; &lt;view class="page-height"&gt; &lt;view class="page-content"&gt; &lt;view class="wrap" v-if="popup_show"&gt; &lt;view class="popup-bg"&gt; &lt;view class="popup-content" :class="{'popup-content-show' : popup_show}"&gt; &lt;view class="update-wrap"&gt; &lt;image src="../../static/images/img.png" class="top-img"&gt;&lt;/image&gt; &lt;view class="content"&gt; &lt;text class="title"&gt;发现新版本V{{update_info.versionNo}}&lt;/text&gt; &lt;!-- 升级描述 --&gt; &lt;view class="title-sub" v-html="update_info.updateContent"&gt;&lt;/view&gt; &lt;!-- 升级按钮 --&gt; &lt;button class="btn" v-if="downstatus &lt; 1" @click="onUpdate()"&gt;立即升级&lt;/button&gt; &lt;!-- 下载进度 --&gt; &lt;view class="sche-wrap" v-else&gt; &lt;!-- 更新包下载中 --&gt; &lt;view class="sche-bg"&gt; &lt;view class="sche-bg-jindu" :style="lengthWidth"&gt;&lt;/view&gt; &lt;/view&gt; &lt;text class="down-text"&gt;下载进度:{{(downSize/1024/1024 ).toFixed(2)}}M/{{(fileSize/1024/1024).toFixed(2)}}M&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;image src="../../static/images/close.png" class="close-ioc" @click="closeUpdate()" v-if="downstatus &lt; 1 &amp;&amp; update_info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78f4fc601eb0c793ce987ed6a62a72d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec0373f97bf541bdb39129048495429a/" rel="bookmark">
			玩家必备，2款顶级游戏录屏软件！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“游戏怎么录屏呀？最近迷上了网游，觉得自己的游戏技术挺厉害的，想把游戏视频录下来出一个教程，方便给朋友进行参考，但是我不会录屏，大家有没有游戏录屏的软件或者方法推荐一下。”
随着游戏产业的飞速发展，玩家们对于游戏体验的需求也在不断提升。除了游戏本身的品质外，许多玩家还希望将自己在游戏中的精彩瞬间记录下来，与他人分享。游戏录屏软件应运而生，为玩家们提供了便捷的录制方法。本文将详细介绍两款流行的游戏录屏软件，帮助玩家更好地记录和分享游戏时刻。
游戏录屏软件1：Xbox Game Bar Xbox Game Bar是微软推出的一款内置于Windows 10系统的游戏工具，具有游戏录屏、截图、性能监测等多项功能。使用Xbox Game Bar进行游戏录屏的步骤如下：
第1步：点击左下角的Windows图标，选择齿轮形状的“设置”图标，找到“Xbox Game Bar”选项，打开其右侧的开关按钮。
第2步：在游戏中，按下“Win+G”组合键打开Xbox Game Bar。此时屏幕顶部会出现一个悬浮窗口。
第3步：在Xbox Game Bar窗口中，点击中央的圆形“录制”按钮开始录制。录制过程中，按钮会变为红色。
第4步：如果需要停止录制，再次点击“录制”按钮即可。录制完成后，视频将自动保存在“我的文档/视频/捕获”文件夹中，打开即可找到刚才录制的游戏视频。
游戏录屏软件2：专业录屏软件 数据 蛙录屏软件是一款专业的游戏录屏软件，它拥有专业的游戏录制模式，支持免费试用、无水印录制，可以录制电脑上任意地方，包括应用程序、窗口、音频等，满足您的一切需求。
它具有高清录制、多种视频输出格式（F4V、WebM、MOV等）、灵活的录制区域选择（全屏或自定义）等优点。使用数据 蛙录屏软件进行游戏录屏的步骤如下：
操作环境： 演示机型：Dell optiplex 7050 系统版本：Windows 10 软件版本：数据 蛙录屏软件1.1.8 第1步：访问数据 蛙录屏软件的官方网站，下载适用于Windows系统的安装包，并按照提示完成安装过程，打开在主界面中选择中间的“游戏录制”模式。
第2步：在“游戏录制”页面，选择我们需要录制的游戏窗口，根据需要对麦克风和扬声器进行调整。
第3步：如果您希望录屏自动开始录制，可以点击下方的“计划任务”功能，添加一个游戏录制任务，设定好时间，软件就会自动开始录屏。
第4步：游戏录制过程中可以随时暂停，录制完成后，软件提供了视频剪辑工具，您可以使用它们来裁剪录制的游戏视频。
结论 总之，游戏录屏软件在游戏体验中扮演着越来越重要的角色。通过本文的介绍，相信玩家们已经掌握了Xbox Game Bar和数据 蛙录屏软件的使用方法和步骤。希望通过这些介绍，能够帮助大家更好地记录和分享自己的游戏过程，获得更多的乐趣。
文章推荐：
mac录屏快捷键指南，轻松录制屏幕内容！https://blog.csdn.net/shujuwa__net/article/details/134133032?spm=1001.2014.3001.5502
电脑录像功能在哪？一文帮你轻松破解https://blog.csdn.net/shujuwa__net/article/details/134133751?spm=1001.2014.3001.5502
如何清除电脑缓存？简单几步，让你的电脑运行如飞！https://blog.csdn.net/shujuwa__net/article/details/134134442?spm=1001.2014.3001.5502
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2803c56cf50b018df74a2305c430475/" rel="bookmark">
			Spring中的Bean的管理（史上最全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.BeanFactory接口
本文介绍Spring里的BeanFactory。包括：BeanFactory 和 FactoryBean的ApplicationContext的委托。
BeanFactory 和 FactoryBean Spring的本质是一个bean工厂(beanFactory)或者说bean容器，它按照我们的要求，生产我们需要的各种各样的bean，提供给我们使用。只是在生产bean的过程中，需要解决bean之间的依赖问题，才引入了依赖注入(DI)这种技术。也就是说依赖注入是beanFactory生产bean时为了解决bean之间的依赖的一种技术而已。
beanFactory会在bean的生命周期的各个阶段中对bean进行各种管理，并且spring将这些阶段通过各种接口暴露给我们，让我们可以对bean进行各种处理，我们只要让bean实现对应的接口，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean.
在介绍BeanFactory前，我们先想一个问题。我们都知道BeanFactory主要的内容是帮我们生成Bean信息和管理Bean信息，那么我们在xml文件中&lt;baen&gt;属性的时候。Spring是如何帮我们生成Bean.
BeanFactory
接口具体实现类
1. DefaultListableBeanFactory
BeanFactory接口体系的默认实现类，实现以上接口的功能，提供BeanDefinition的存储map，Bean对象对象的存储map。
其中Bean对象实例的存储map，定义在FactoryBeanRegistrySupport，FactoryBeanRegistrySupport实现了SingletonBeanRegistry接口，而DefaultListableBeanFactory的基类AbstractBeanFactory，继承于FactoryBeanRegistrySupport。
2. StaticListableBeanFactory
用于存储给定的bean对象实例，不支持动态注册功能，是ListableBeanFactory接口的简单实现。
beanFactoty后置处理器： BeanFactoryPostProcessor
benFactoryPostProCessor是BeanFactory的后置处理器：
在BeanFactory创建好，加载好其所包含的所有beanDefinitions，但是还没有实例化bean之前，执行，具体为调用postProcessBeanFactory方法。
1. 加载更多的bean元数据
ConfigurationClassPostProcessor，用于从BeanFactory中检测使用了@Configuration注解的类，对于这些类对应的BeanDefinitions集合，遍历并依次交给ConfigurationClassParser，ConfigurationClassBeanDefinitionReader处理，分别是处理与@Configuration同时使用的其他注解和将类内部的使用@Bean注解的方法，生成BeanDefinition，注册到BeanFactory。
2. 对bean元数据进行加工处理
BeanDefinition属性填充、修改：在postProcessBeanFactory方法中，可以对beanFactory所包含的beanDefinitions的propertyValues和构造函数参数值进行修改，如使用PropertyPlaceHolderConfigurer来对BeanDefinition的propertyValues的占位符进行填充、赋值。或者使用PropertyResourceConfigurer获取config文件中属性，对BeanDefinitions的相关属性进行赋值或者值覆盖。
bean对象后置处理器：BeanPostProcessor
Bean后置处理器：负责对已创建好的bean对象进行加工处理。
主要是可以对新创建的bean实例进行修改，提供了一个类似于hook机制，对创建好的bean对象实例进行修改。
核心方法
postProcessBeforeInitialization：在创建好bean实例，但是在任何初始化回调执行之前，如InitializingBean的afterPropertiesSet，先执行该方法。
postProcessAfterInitialization：在创建好bean实例，并且所有的初始化回调都执行完了，如InitializingBean的afterPropertiesSet，再执行该方法。
至此：BeanFactory的Bean加载过程全部分析完成:
2.静态工厂实例化 首先创造静态工厂
Bean2
配置文件：
创建测试文件：
3.实例工厂实例化 创建Bean
创建实例化工厂
xml配置：
bean4test：
4.Spring中Singleton作用域和Prototype作用域 基本概念 singleton作用域就是单例模式；用spring容器实现单例模式
而prototype作用域可以理解为多例模式！
注意：单例模式哈希值只有一个，多例模式哈希值有两个！
编写以下代码：（xml主要配置）
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean class="singleandprodemo.demo.Bean2" id="bean2" scope="singleton"/&gt; &lt;bean class="singleandprodemo.demo.Bean1" id="bean1"&gt; &lt;property name="bean2" ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2803c56cf50b018df74a2305c430475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de3c90b99cd7a13fb5712b8589f31814/" rel="bookmark">
			面试小总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人预大四学生，面试了渗透实习岗位的小总结。
确实我最近三个月内面试了四次，就这四次的面试进行一次比较深刻的总结，希望对将来的你有所帮助。
1、面试官一般会问的比较详细，尽量绕过自己不熟悉的知识点，避免面试官对你不熟悉的知识点一直提问。如果问到了你不熟悉的知识点，尽量说一些自己知道的，不要一直保持沉默，让面试官语气略显示尴尬。
2、刚开始面试官一般会让你做一个自我介绍，自我介绍一定要说自个真实做过的一些事情，因为面试官会问你一些你印象深刻所做出来的知识点，并且对其中的知识点更加深层次提问，提问时你一定要理解面试官所要问的问题，并作出相应的回答。
3、面试官会从你的个人经历里面提出问题，或者给出一道题，让你去现场解析，一定不要去解析自己不太熟的题目，一定要给面试官提供自己比较熟悉的题目（如果面试官让你去提供一道题），这时候才会永远不被面试官拿捏。
4、面试官肯定是比较高级层次的存在，比如有一次我作为蓝队初级，面试官竟然是红队高级人员，高出自己层次不少的话，一定不要感到害怕，其实我感觉面试官也是害怕自己问的问题的深度太深。大胆回答就行，哪怕自己说的是错的，也一定要有自己的一个思路所在，毕竟他也不可能把全部的知识学完，他也有不会的东西存在。
5、最重要一点就是要敢于吹牛逼，不吹牛逼永远没有机会面试成功，当然要吹自己有过的奖项等东西，这个不仅仅靠自己，还有团队获得的奖项。吹的越牛逼，伪装到最后，不敢说百分之百，六七十会录用你。
6、最后环节肯定是问你还有什么想问公司的，这个时候不要认为没有什么用，一定要说出自己的困惑，比如作为打ctf的话，我一定要去问一下靶场环境是否搭建了，是否有公司团队的内部资源能够让自己去提升，对目前的我们来说提升最为重要，就是说是否有能让自己快速提升的渠道。再者你多问面试官才能对你的了解更为深刻。
7、你有不会的不用怕，很正常，不可能都会，这时候就看自己表现，遇到不会的不要说不会，这样面试官只会觉得你对学习的积极性不太高，说的咋让面试官舒服咋地来。有时候面试官会问你一些紧跟当前时代相关东西（比如新出现的xxx漏洞，你是否去了解过），不要慌，咱们都不会，直接说不太了解就行（如果你要是会的话最好给你加分）
8、这最后一点也是最为重要的一点（我个人认为），面试完一定不要认为这家能进去，多投几家，将此次面试自己没有答出来的知识点作为一个总结，下次面试到这些不至于让你感到尴尬。
最后，祝大家能收到自己比较满意的offer！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad105ba3ab6f03bdeddc066503b55a36/" rel="bookmark">
			IDEA 使用自定义MAVEN（maven安装及IDEA配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 我首次下载使用的maven版本是3.8.6，但是在IDEA配置了对应的jar依赖后，下载lib时抛出了
Error injecting constructor, java.lang.NoSuchMethodError: org.apache.maven.model 异常，截图如 百度排查了之后，最简单的解决方法是降低对应的maven版本，所以下载使用了第二次的3.6.3。
二、maven 下载
1.从maven官网下载地址直通车进入，划拉到底部，找到archives进入历史版本下载页面
​
2.选择对应的maven版本，我这里选择的是3.6.3，进入后有两个选项，binaries 二进制文件，该选项下载的文件是经过编译之后的绿色包版本，可以直接使用；source 源码，该选项下载的文件是未经过编译的源码包版本，需要编译后使用，暂时没有看maven源码的需求，就下载的二进制文件绿色包。
​
​
3.选择ZIP包下载解压即可。
​
​
三、maven的配置
主要两部分的配置，一部分是maven的配置，包括环境变量和本地仓库，一部分是IDEA的配置
1.环境变量的配置，打开系统属性→环境变量，在系统变量中增加MAVEN_HOME，填入自己的maven解压路径根目录，保存后在Path变量中，填入MAVEN的bin路径%MAVEN_HOME%\bin，保存。
​
​
​
2.在命令行窗口(ctrl+r 输入 cmd)输入mvn -v校验，如果打印对应的配置信息则表示maven环境变量配置成功
​
3.配置maven本地仓库
选定一个存放maven下载jar包的路径，创建repository文件夹，我是在maven解压包同级目录下；
​
打开settings.xml配置文件，路径为$maven_root_path/conf/settings.xml如图，下载的绿色包中的settings.xml配置文件基本没有有效配置，我们需要添加几个基础配置​
本地仓库配置，为上一步创建的repositroy仓库路径
&lt;localRepository&gt;D:/Program Files/maven/repository&lt;/localRepository&gt; ​
远程仓库地址，我没有使用默认的仓库配置，选择的是阿里云的仓库配置，因为阿里云的maven公共库的配置使用比较广泛。
&lt;mirror&gt;
&lt;id&gt;alimaven&lt;/id&gt;
&lt;name&gt;aliyun maven&lt;/name&gt;
&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
&lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;
最后是编译环境版本，我选择的是JDK8
&lt;profile&gt;
&lt;id&gt;jdk-dev&lt;/id&gt;
&lt;activation&gt;
&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
&lt;jdk&gt;1.8&lt;/jdk&gt;
&lt;/activation&gt;
&lt;properties&gt;
&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
&lt;/properties&gt;
&lt;/profile&gt;
4.IDEA maven配置(我选择的是全局配置，该操作会清理掉用户自定义配置，读者可根据自己实际情况操作)
打开IDEA的全局配置界面
配置对应的maven路径，顺便吧IDEA自动下载勾上，然后应用 apply。
到这里IDEA环境的maven配置就基本完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32cf2c454592249b778c2c4ff25902c/" rel="bookmark">
			简单基于TCP的文件传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于python的文件传输
生活中我们如何通过脚本进行传输文件呢，以下提供如何进行传输txt，jpg等格式的文件
代码如下：
客户端.py
import socket import time import threading import struct #将int类型打包成byte类型 import json #反序列化 path=r'' def run(): cmd=socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建一个套接字对象，tcp格式，面向网络 cmd.connect(('127.0.0.1',8081)) #连接测试地址，并且设置端口号 while True: try: #1.发命令 cmd1=input("请输入文件名称").strip() #【get,a.txt】 if not cmd1: continue #如果没有命令直接继续执行 cmd.send(cmd1.encode('utf-8')) #将发送的命令通过操作系统并且通过utf-8编码 #2.拿命令的结果，并且打印 #第一步，先拿到数据的长度 header=cmd.recv(4) #接收一下报头的长度 header_size=struct.unpack('i',header)[0] #将报头的byte类型解压成int类型 header_bytes=cmd.recv(header_size) #接收数据部分 header_json=header_bytes.decode('utf-8'); #将数据的byte类型经过解码utf-8 header_dic=json.loads(header_json) #通过json的包进行反序列化成字符串类型 print(header_dic) #打印一下字符串 total_size=header_dic['file_size'] #取出字符串中总长度 filename=header_dic["filename"] #取出输入的姓名 #第二步，从报头解析出，从filename的报头进行解析 num=0 with open('%s\%s'%(path,filename),'wb') as file: recv_size = 0 #设置接受的字符长度 while recv_size &lt; total_size: #经过循环遍历出总长度 data = cmd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c32cf2c454592249b778c2c4ff25902c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/063f9c963867193e231278cd2aabac46/" rel="bookmark">
			Python 算法高级篇：多阶段决策问题与状态转移方程的构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 算法高级篇：多阶段决策问题与状态转移方程的构建 引言 1. 多阶段决策问题简介2. 动态规划基础3. 状态转移方程4. 案例：生产计划问题5. Python 实现6. 总结 引言 多阶段决策问题是一类在不同决策阶段需要做出一系列决策以实现特定目标的问题。这类问题涵盖了许多实际应用，如项目管理、资源分配、生产计划等。解决多阶段决策问题的一种常见方法是使用动态规划。在本篇博客中，我们将重点讨论多阶段决策问题的基本概念、状态转移方程的构建和 Python 实现。
😃😄 ❤️ ❤️ ❤️
1. 多阶段决策问题简介 多阶段决策问题是指一个决策问题可以被分解为多个决策阶段，并且在每个阶段需要选择一组行动来实现某个特定的目标。每个决策阶段的决策可能会影响后续阶段的状态和选择。
这类问题通常用有向图（有向图中的每个节点代表一个决策阶段）来表示。在每个阶段，决策者必须选择从一个节点到另一个节点的路径，以达到最终的目标。问题的目标通常是最小化或最大化某种指标，如成本、利润、时间等。
2. 动态规划基础 动态规划（ Dynamic Programming ）是解决多阶段决策问题的一种常见方法。它的核心思想是将问题分解为一系列阶段，然后逐个阶段地解决问题。在每个阶段，通过构建状态转移方程来确定如何选择行动以达到最终目标。
动态规划包括以下基本步骤：
1 . 定义问题的阶段：将问题分解为多个决策阶段。2 . 定义状态：确定每个阶段可能的状态。状态是问题的关键信息，它描述了问题在每个阶段的特定情况。3 . 构建状态转移方程：确定问题的状态如何在不同阶段之间转移。这是解决问题的核心，通常使用递推公式表示。4 . 初始条件：确定第一个阶段的状态和可行行动。5 . 计算顺序：按照问题阶段的递进顺序计算每个阶段的状态值。6 . 解决问题：根据最终阶段的状态值找到最优解。 3. 状态转移方程 状态转移方程是解决多阶段决策问题的关键。它描述了问题的状态如何在不同阶段之间转移，以及如何根据先前阶段的状态选择行动。
状态转移方程通常以递归的方式定义。例如，如果我们将问题的状态表示为函数 dp(i, j) ，其中 i 是阶段， j 是状态变量，那么状态转移方程可以表示为 dp(i, j) = f(dp(i-1, k)) ，其中 k 表示上一个阶段的状态。这个方程表示，在当前阶段 i 的状态 j 下，我们通过考虑前一个阶段 i-1 的所有可能状态 k 来计算最优值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/063f9c963867193e231278cd2aabac46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7452cd55d0916e9369de9bfc450f5083/" rel="bookmark">
			Python 算法高级篇：最小生成树算法的优化与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 算法高级篇：最小生成树算法的优化与应用 引言 1. 最小生成树问题简介2. Prim 算法3. Kruskal 算法4. 优化与比较5. 案例应用：通信网络设计6. 总结 引言 最小生成树（ Minimum Spanning Tree ， MST ）是图论中的一个重要问题，涉及到在一个加权连通图中找到一棵包含所有节点且边的权重之和最小的树。最小生成树问题在许多实际应用中都有重要作用，例如通信网络设计、电路板布线、城市规划等。在本篇博客中，我们将深入探讨最小生成树算法的优化和应用，主要关注两个著名的算法： Prim 算法和 Kruskal 算法。
😃😄 ❤️ ❤️ ❤️
1. 最小生成树问题简介 最小生成树问题是一个图论问题，通常描述为以下几个步骤：
给定一个带权重的连通图，其中节点表示地点，边表示路径，并带有权重表示路径的代价或距离。找到一个子图，这个子图是原图的一颗树，包含了所有的节点。保证这颗树的边的权重之和最小。 最小生成树问题的解可以有多个，但它们都具有相同的特点：包含了所有节点，但是边的权重之和最小。 Prim 算法和 Kruskal 算法是两个用于解决这个问题的经典算法。
2. Prim 算法 Prim 算法以一个起始节点开始，然后逐步将与当前最小生成树集合相连的最短边加入到该集合中。它维护两个集合：一个是已包含在最小生成树中的节点集合，另一个是未包含在其中的节点集合。在每一步中，算法从未包含集合中选择一个节点，并找到连接已包含节点集合和未包含节点集合的最短边。这个边会被添加到最小生成树中，将对应的节点移到已包含集合中。这个过程一直进行，直到已包含集合包含了所有节点为止。
下面是 Prim 算法的 Python 实现：
import heapq def prim(graph): min_spanning_tree = [] start_node = list(graph.keys())[0] visited = set([start_node]) edges = [ (cost, start_node, next_node) for next_node, cost in graph[start_node].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7452cd55d0916e9369de9bfc450f5083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242d45f0bad66b99d747a098b50bcc76/" rel="bookmark">
			软考证书，彻底爆了！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💰#IT人 #积分落户、升职加薪、领奖金！到底是什么神仙证书吸引众多程序员争相报考？ 最近发现，软考报考人数已超500万！2020年40万，2021年94万，2022年129万，两年时间直翻3倍！如此火爆原因是什么？ 据统计：2023上半年不仅报名人数大涨，参考率也同步上升，竞争逐步激烈！软考也叫软件水平考试，IT圈公认的高含金量证书，加上政策福利贼好、市场需求变大，才日渐火热… 🔥软考可考专业多：
高级：信息系统项目管理师
中级：系统集成项目管理工程师、软件设计师、网络工程师
其中针对有编程基础的同学特别推荐【软件设计师】！
软件设计师属于软考中级资格，报名门槛低，对编程能力要求不高，懂一定的程序语言就可以，还能学到很多计算机与软件工程理论知识，几乎涵盖了整个计算机科学与技术的常用领域。 证书含金量高，简单好考，好处多多！👇👇
“6大好处”人人都想要
1、城市积分落户，人才引进 持有证书可帮助申请北京工作居住证，上海、广州、天津等积分落户。例如上海人才落户要72分，普通落户120分，软考资格证就可获得60-140分；持有软考的中级，可直接落户广州。
2、官方认可，含金量高！好考！ 软考既是国家职业资格考试，又是职称资格考试。企事业单位、很多私企都非常认可，甚至开始列入招聘条件！
相关政策表明：部分证书级别还与日本、韩国等国家签定了相互认证备忘录，往后还将继续加强这一证书在国内、外的认可度！
*证书样式示例-截图源自官网
🔥 落户加分、领补贴奖金
🔥 国央企评职称
🔥 私企升职加薪、找工作...
软考中级「软件设计师」训练营
基础入门—备考规划—提分技巧
本号粉丝，今日可0元领！
👇👇
现在扫码，还可获得
🎁 3G备考资料（案例分析/大纲/题集等）
3、评中级职称 以考代评：简单来说，通过软考考试获得证书，就证明你已具备从事对应岗位的工作能力和水平，即可直接获得职称，不需要再经过额外的评审！
比如拿下软考「中级软件设计师」，即可获得中级职称！
4、利于晋升、涨工资 随着软考证书在IT行业里认可度越来越高，很多企业会组织员工学习软考拿证，并提供相应的晋升、加薪、奖金等福利；还有很多企业在招聘时，会优先考虑软考相关证书持有者。 5、入专家库、多领退休金等 入专家库：具有中级（包括）以上职称或同等专业水平等条件，可进入评标专家库
退休金：可享受退休中高级职称补贴，每月多领200元左右
个税抵扣：取得证书当年可申报3600元个税补贴
企业投标：根据政府采购法及招标文件要求，持软考中高级证书可获加分，增加中标率
*以上信息整理自网络，如有调整，具体政策请以官方最新发文为准 6、个人水平系统提升 如果你也在IT行业，考一个软考证书完全能帮你梳理知识体系、学习专项项目管理，直线提升个人水平，无论在现公司发展还是借机跳槽，都大有益处！
报考条件是什么？
1、目前报名条件宽泛，不设年龄、学历、专业、资历条件等限制
2、软考每年举行两次
软考具体考什么？
软考中级【软件设计师】考试科目：
计算机与软件工程知识：考试时间为150分钟，笔试，选择题；
软件设计：考试时间为150分钟，笔试，问答题。
软考考试分为初、中、高级，分别对应不同科目。（其他专业课参考下图）
截图源自官网：https://www.ruankao.org.cn/ 哪些人适合考软考？
1. 有北、上、广、天、深等城市落户需求
2. 想晋升/涨薪的计算机行业从业者
3. 各政府部门及事业单位从事企业信息化，需要评中级、高级职称的人
4. 想通过职业证书领取补贴的人
5. 想要学习项目管理知识、系统提升、职场升级与转型的人
6. 计算机专业的大学生，想在应聘时更受企业青睐，搞定就业第一步垫脚石的同学......
怎么学，才能考过？
1. 上班太忙，没法计划时间？
2. 0基础小白，怎么入手？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242d45f0bad66b99d747a098b50bcc76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5904b26beee0b5bb9272cf34ca60bd21/" rel="bookmark">
			FPGA与ASIC有什么差异？二者该如何选用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 对于一个数字电路的新手来说，这可能是会经常遇到的一个问题：FPGA和ASIC之间的区别是什么?
接下来本文将尝试讲解 “什么是FPGA？” 和 “什么是ASIC？”，然后讲述一些关于FPGA和ASIC的问题，例如它们之间的异同。我们将总结二者的优点和缺点，以便您能够根据应用需求来做出一个明智的选择。
什么是FPGA? FPGA是指现场可编程门阵列（Field Programmable Gate Array）。它是一个可以现场编程的、并按照预定设计意图来工作的集成电路。这意味着它可以既作为一个微处理器工作，也可以作为一个加密单元工作，还可以作为一张显卡来工作，它甚至可以同时具备这三者的功能。顾名思义，FPGA是可编程的，因此我们可以对作为以微处理器模式工作的FPGA重新编程，使其在工作现场（不需要去半导体工厂）就可以在功能上变成一张显卡。在FPGA上运行的设计通常使用诸如VHDL和Verilog等硬件描述语言（HDL）构造。
FPGA由成千上万个可配置逻辑块(Configurable Logic Blocks ，CLB)组成，这些CLB嵌在可编程互联结构中。CLB主要由查找表(Look-Up Table，LUT)、多路复用器（Multiplexer）和触发器（Flip-Flop）构成。它们可以用来实现复杂的逻辑功能。除了CLB和布线（routing interconnect）之外，许多类型的FPGA还包括某些专用的硬件资源，例如BRAM、DSP、外部存储控制器（External Memory Controllers）、PLL、吉比特收发器（Gigabit Transceiver）等。最近的一个趋势是在同一个FPGA中嵌入一个处理器硬核(例如Xilinx Zynq系列中的ARM Cortex A9)。这样处理器可以处理普通的、非关键的任务，而FPGA则可以实现高硬件加速（high-speed acceleration），仅仅用处理器的话，这是无法做到的。这些专用硬核在与ASIC的竞争中至关重要。
什么是ASIC? ASIC是指应用专用集成电路（Application Specific Integrated Circuit，ASIC）。顾名思义，ASIC是专用的。它们是专为某个（些）目的而设计的，在其整个生命周期内，它们的功能是固定不变的。比如你手机里的CPU也是ASIC，在它的整个生命周期内，它都是作为一个CPU来工作的，它的逻辑功能无法被改变，因为它的数字电路是由恒定连接的门电路和触发器所构成的。ASIC的逻辑功能使用如Viilog或VHDL等硬件描述语言来实现。
与FPGA不同的是，ASIC中所生成的电路被直接固定了，而FPGA中的电路则是通过连接多个CLB来灵活实现的。FPGA类似于用乐高积木来拼一个城堡，而ASIC则像是用钢筋混凝土来浇筑一个城堡。当你需要的时候，你可以把FPGA城堡拆了，再重新用这些乐高积木拼一辆汽车；但你却无法把钢筋混凝土重新浇筑成一辆汽车了。
FPGA与ASIC的比较 序号FPGAASIC1可重构电路。FPGA可通过不同的设计重新配置。甚至在芯片的某一部分处于工作状态时，也能对另一部分进行重配置（部分重配置）。这一功能在数据中心的加速计算中得到了广泛应用。固定电路。一旦设计被转换成实体电路，就无法改变了。该电路在其生命周期内将一直处于同一功能模式.2设计通常使用硬件描述语言(hdl)生成，如VHDL或Verilog。与FPGA一致。3低门槛。成本、学习曲线、与半导体工厂联系等方面的门槛很高。4不适合大规模生产适合大规模生产5功耗高功耗低6与类似工艺节点的ASIC相比，工作频率有限。布线路由逻辑和可配置逻辑会吞噬时序裕量。利用相同的工艺节点制作的ASIC，其工作频率远高于FPGA。7无法进行模拟设计。虽然FPGA可能包含某些模拟电路的硬核，如PLL和ADC等，但它们并不能灵活地来创建如射频收发器等模拟电路。可以有完整的模拟电路，例如Wi-Fi收发器等。这是FPGA所不具备的优势。8FPGA非常适合雷达、手机基站等应用，目前的设计可能需要升级，以便使用更好的算法或更好的设计。在这些应用中，FPGA高昂的成本并不是决定性因素，它的可编程特性才是决定因素。ASIC不适合在可能需要经常更新设计的应用领域。9最好用于原型验证和验证设计。很多ASIC都使用FPGA来做原型验证。一些大的处理器厂商也在使用FPGA来验证他们的片上芯片(SOC)。不建议使用ASIC来做原型设计，除非它是绝对有效的。一旦流片后，几乎就没有办法来修复设计错误了（流片失败成本巨大）。10FPGA设计师通常不需要管后端设计。所有的事情都由综合工具来处理，这些工具会确保设计如RTL代码所描述的那样，并确保其满足时序要求。因此,设计师可以专注于完成RTL的设计。从RTL向下到复位树、时钟树、物理布局和布线、工艺节点、制造约束(DFM)、测试约束(DFT)等，ASIC设计师都需要关注。一般而言，上述每个领域都由不同的工程师负责。 FPGA与ASIC的成本分析 ASIC和FPGA的成本分析图如上。成本和单位值在图表中被省略了，因为它们与所用的工艺技术和时间有所不同。ASIC的NRE成本高达数百万美元，而实际的每一个die成本可能只有几美分。FPGA没有NRE成本，成本的大部分来源于软件（知识产权）。因为NRE成本的存在，ASIC的总成本在一开始就非常高，但其成本斜率较低。也就是说，小规模的ASIC的成本很高，但在大规模的ASIC中，每个批量的成本将变得非常低。
以下是ASIC成本构成主要部分:
ASIC 的EDA工具和培训设计费用DFT费用仿真费用掩膜成本晶圆成本晶圆加工Die Utilization生产和制造损失封装 与ASIC相比，FPGA的成本仅限于购买现成的IC。
如何在FPGA或ASIC之间进行选择 你是一个想学习更多关于数字电路和硬件设计内容的新手？那么FPGA和仿真软件最适合您。你在设计自己的产品吗？酷！请问问自己目标市场是什么，预期的价格是多少，功率预算是多少，速度要求等问题。能用FPGA实现吗？如果是的话，那就继续把你的想法实现。如果不能，那你可能只好用ASIC了。在大多数情况下，至少可以使用FPGA制作原型并验证您的想法。当你完成原型的时候，你自己就会知道你是否需要使用ASIC。当然，如果您的设计完全是突破性的，并且非常特殊，有着非常具体的要求（在成本、功率、速度等方面），那么您除了使用ASIC外别无选择。FPGA可以满足大多数的应用情况，特别是当您需要可以重新配置电路时。
参考 《FPGA Vs ASIC: Differences Between Them And Which One To Use?》
📣您有任何问题，都可以在评论区和我交流📃！📣本文由 孤独的单刀 原创，首发于CSDN平台🐵，博客主页：wuzhikai.blog.csdn.net📣您的支持是我持续创作的最大动力！如果本文对您有帮助，还请多多点赞👍、评论💬和收藏⭐！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b98fe73ea738c2f1d65612043e7097/" rel="bookmark">
			【HBZ分享】ES分词器的拆分规则 及 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES分词器种类 常见的分词器，如Standard分词器、Simple分词器、Whitespace分词器、IK分词等，还支持自定义分词器(比如一些小国家的语言需要自定义分词器)ES默认就是Standard分词器 分词器在分词时的过程 标记化：分词器第一步是将文本拆分成单个标记(tokens), 就是单个的单词或中文词组，这个标记可以是单词，数组，特殊字符，中文词语等。 此时会包含一些分隔符，标点，停用词等，并非最终形态的分词。过滤：对第一步分出来的所有标记进行过滤操作，比如大小写转换，去除停用词，去掉分隔符标点等操作，形成最终形态的分词集倒排索引：分词完成后，ES会创建倒排索引来存储这些分词， 倒排索引是一种数据结构，通过倒排索引，把分词和文档document(即原始文本)建立起映射关系，当搜索某个分词的时候，就会将映射到的文档进行返回。查询匹配：查询时我们输入的文本内容，也会在ES进行分词处理，将搜索内容分词后，拿着分词去倒排索引中进行查询，把匹配到的分词对应的映射document进行返回。 Standard分词器的规则 标点符号切分：如果文本中含有标点符号，那么会根据标点符号进行拆分，比如apple,peach,food。那么拆分结果就是[apple 和 peach 和 food]这3个，会根据逗号拆分词分割： 即按照空格进行拆分， 比如: my name is hbz, 拆分结果就是[my 和 name 和 is 和 hbz]这4个词拆成独立的分词小写转换：即会将文本中的大小写全部转成小写， 比如Hellow World, 则拆分结果就是[hellow 和 world], 首字母的H，W都会转成小写的h, w停用词过滤： 过滤掉无效的单词，比如a, an, the这种连接词，这些词本身没啥意义，做分词的时候Standard分词器会将这些排除词干提取：将单词还原成原始形态， 比如 running–&gt;run， swimming–&gt;swid, going–&gt;go, jumped–&gt;jump==注意：以上这5个特点是同时生效的，即一段文本会按照这5中规则进行分词，最终结果一定是符合这5中规则的。 == 如何查看ES分词存储效果？ GET /索引名称/_analyze GET /_index/_analyze { "analyzer": "分词器名称", "field": "字段名称" "text": "待分析的文本" } 案例：
#字段是text类型 POST /my_index/_analyze { "field": "title", "text": "This is some text to analyze" } #字段是text类型 POST /my_index/_analyze { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64b98fe73ea738c2f1d65612043e7097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f591fa7cbf1611ec9329ca918bbff2/" rel="bookmark">
			mybarisplus插件(分页与乐观锁)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.分页插件2.自定义分页3.乐观锁3.1 场景3.2 乐观锁与悲观锁3.3 模拟修改冲突3.4 乐观锁解决问题 1.分页插件 MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能
添加配置类MyBatisPlusConfig
@Configuration @MapperScan("com.atguigu.mybatisplus.mapper") public class MyBatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 编写测试方法
@Test public void testPage(){ //new Page()中的两个参数分别是当前页码，每页显示数量 Page&lt;User&gt; page = userMapper.selectPage(new Page&lt;&gt;(1, 2), null); List&lt;User&gt; users = page.getRecords(); users.forEach(System.out::println); } 2.自定义分页 上面调用的是MyBatis-Plus提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？
在UserMapper接口中定义一个方法
/** * 根据年龄查询用户列表，分页显示 * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位 * @param age 年龄 * @return */ Page&lt;User&gt; selectPageVo(@Param("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f591fa7cbf1611ec9329ca918bbff2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4bfcee9e76897c90f9602c1895d64a/" rel="bookmark">
			error: src refspec main does not match any
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际就是如果把github上文件先下载在本地，在创建git目录，会将分支命名为master，而clone到本地分支会命名为main，这要提交会出错，这时候需要改名。
解决方案A-如果要将分支命名为master
运行git push -u origin master而不是git push -u origin main
或者解决方案B-如果你想把分支命名为main
Run git checkout -B main before git push -u origin main
参考：
https://www.5axxw.com/questions/content/hv0007
这是master对main争论的一个令人不快的结果。
您的本地GIT客户机创建了一个名为master的默认分支（当您使用git init初始化repo时），但是GitHub上的远程存储库没有master，而默认分支称为main。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8507b8178b2fb0e084adc83a049377/" rel="bookmark">
			el-cascader 动态加载选项、编辑时数据回显问题 、单选不加载下一级节点、点击标签选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求描述
1.实现动态加载选项
2.数据回显
3.组件BUG：再次编辑不再加载
4.点击单选框选中节点时，同时加载下一级选项（额外需求）
5.点击label标签时，能够直接选中该节点（额外需求）
需求描述 需求情景描述
前端使用el-cascader组件来实现一个层级选择器，可以支持单选或多选节点，节点的层级关系和名称都由后端来定义和控制，前端根据后端提供的数据来渲染。
实现该需求，需要后端配合需要提供2个接口：
1.接口1：前端传入指定节点ID，后端返回该节点的下一层所有节点ID信息列表。
2.接口2：前端传入指定节点ID，后端返回该节点从顶部父节点至该节点的所有路径节点ID列表。
级联选择器 el-cascader 使用
最关键的只有这两项：v-model绑定值 和 props 配置项
&lt;el-cascader v-model="IdList" :props="props" &gt;&lt;/el-cascader&gt; 1.实现动态加载选项 常用props配置：
动态加载选项不需要 : options 配置，一般静态的才使用options配置。
checkStrictly：true 是否可以选择树干节点作为选项（根据实际需求选择）lazy：true 是否动态加载节点（当然，这正是我们需要的）lazyLoad: this.loadTreeNode 指定加载节点的方法，这里我定义的名字叫loadTreeNode multiple: true 是否支持多选 props: { checkStrictly: true, //是否可以选择树干节点作为选项 lazy: true, // 是否动态加载子节点 // lazyLoad加载动态数据的方法(仅在 lazy 为 true 时有效) lazyLoad: this.loadTreeNode, }, loadTreeNode ，自定义的加载节点的方法（具体逻辑看注释基本就能看明白）：
//加载树节点 首次加载页面时就会执行一次，之后每选中一个节点也会调用，来渲染下一层 loadTreeNode(node, resolve) { console.log(node); // 首次加载时 node为{root:true,level:0} // node 节点数据 获取node的level字段的值 const { level } = node; //下一层节点 const nodes = []; //如果有子节点 或者 为根节点（即首次进入level为0） //也有人写成 node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8507b8178b2fb0e084adc83a049377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001181887bf834e4fe0407cc8d9a230d/" rel="bookmark">
			SpringBoot&#43;Vue老年一站式服务平台源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 🍅文末获取源码联系🍅
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
千份开题报告和答辩PPT下载
一、采用技术： 后端：Java+SpringBoot
前端：Vue
数据库：MySQL
开发软件：Eclipse、MyEclipse、IDEA都可以运行
系统功能： 用户管理
员工管理
商家管理
任务信息管理
接单任务管理
任务完成管理
店铺信息管理
店铺信息
商品信息管理
购买信息管理
志愿活动管理
统计任务管理
统计商品管理
系统管理
运行截图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55fe42d5a84a151ddf8c8d2bb94dc91f/" rel="bookmark">
			2.1.2 练习 for 循环求数组元素的最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++自学精简教程 目录(必读)
求数组 [3 1 4 1 5 9 2 6]中的最大值9的过程
求数组的最大值，实际上是遍历数组，不断更新我们已经找到的最大值的过程
原始数组 用一个变量max来存已经找到的最大值，一开始把3当作最大值 找到一个新的最大值4 max值更新为4 遍历完数组所有元素，找到最大值9存储于max中 C++实现：
1 下标for循环实现
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; arr{ 3,1,4,1,5,9,2,6 }; int max = arr[0]; for (int i = 1; i &lt; arr.size(); ++i) { if (arr[i] &gt; max) { //(1) your code } } cout &lt;&lt; "max=" &lt;&lt; max; return 0; } 调用max函数实现（仅作参考）
接下来的实现利用了 求两个数的最大值max 中的函数。
完整代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55fe42d5a84a151ddf8c8d2bb94dc91f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75fc4b8c5807be68c8af8def4ef32ae6/" rel="bookmark">
			IOI车机系统刷机和改包笔记2 - 改包脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 最近对雪佛兰改包需求感兴趣的网友很多，大家都遇上了很多奇怪的问题，这里就我自己使用的环境和脚本进行分享，供大家参考。
1. 准备环境 我这里使用Ubuntu系统进行操作
andy@andy-vm:~$ sudo lsb_release -a No LSB modules are available. Distributor ID:	Ubuntu Description:	Ubuntu 22.04.2 LTS Release:	22.04 Codename:	jammy 2. 准备原始img包和目录 andy@andy-vm:~/mycar$ tree . . ├── system ├── system.img.tar ├── system.img.tar.md5sum ├── system.md5 ├── _temp_ │ └── my_sparse.img 一定要注意 _temp_ 目录，my_sparse.img 是对 system.img.tar 解压后得到。
system 目录是我们自己创建的，用于挂载img镜像使用的。
注意这三个文件，这是生成之后的，重新制作前，解压出 my_sparse.img 就可以删除掉了。
├── system.img.tar ├── system.img.tar.md5sum ├── system.md5 # 制作新的之前可以删除掉 rm system.* 3. 挂载img镜像 # 注意路径 # 挂载img到system 文件夹 sudo mount .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75fc4b8c5807be68c8af8def4ef32ae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c4ac9170e230f6fac466f0a0e6eb8f/" rel="bookmark">
			用docker-compose快速搭建Nacos集群详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0x00 用处不大的开场白
1、docker-compose简介
2、Nacos简介
0x01 资源及环境准备
1、系统升级到最新
2、Docker安装
3、docker-compose安装
4、数据库准备
0x02 详细安装步骤
0x03 扩展
0x00 用处不大的开场白 1、docker-compose简介 Docker Compose 是一个用于定义和运行多个 Docker 容器的工具。它使用简单的 YAML 文件来定义应用程序的服务、网络和卷等配置，然后可以使用单个命令来启动、停止和管理整个应用程序的容器。 Docker Compose 的一些主要特点和优势：简化多容器应用的管理、声明式配置、快速启动和停止容器、跨平台和可移植性支持扩展和服务发现。
2、Nacos简介 Nacos（全称为 "Dynamic Naming and Configuration Service"，中文名为 "服务发现和配置管理系统"）是阿里巴巴开源的一个用于服务发现、动态配置和服务管理的平台。 Nacos 的一些主要特点和功能：服务发现与注册、动态配置管理、服务路由和负载均衡、服务健康监测、配置共享和推送、命名空间和权限管理。
Nacos 是一个功能强大、可靠且易于使用的服务发现和配置管理系统。它提供了丰富的功能和灵活的配置选项，可以帮助开发人员构建和管理可伸缩、高可用的微服务应用程序。
0x01 资源及环境准备 本教程用到的资源以及对于的版本：
OS：Centos 7.6 64bit
服务器1ip：192.168.1.1
服务器2ip：192.168.1.2
服务器3ip：192.168.1.3
docker：17.06.2-ce
docker-compose：1.12.0
Nacos：2.2.0
DB：MySQL5.7
1、系统升级到最新 把服务器系统升级到最新。（非必选，需自行判断是否需要升级。）
yum update -y 2、Docker安装 运行以下命令进行安装docker 17.06版本，安装可能需要等待一些时间。
curl https://releases.rancher.com/install-docker/17.06.sh | sh 设置开机启动docker
systemctl enable docker 检查是否安装成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c4ac9170e230f6fac466f0a0e6eb8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/830321f192dbafad72dffcf17dafaf81/" rel="bookmark">
			Python 算法高级篇：最短路径算法的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 算法高级篇：最短路径算法的优化 引言 1. Dijkstra 算法2. Bellman-Ford 算法3. SPFA 算法4. 优化与比较5. 案例分析：地理导航6. 总结 引言 最短路径算法是图算法中的一个重要领域，它用于查找从一个起始节点到目标节点的最短路径。在这篇博客中，我们将深入探讨三种最短路径算法的优化： Dijkstra 算法、 Bellman-Ford 算法和 SPFA 算法。这些算法在各种实际应用中都发挥着关键作用，从网络路由到地理信息系统，再到社交网络分析。
😃😄 ❤️ ❤️ ❤️
1. Dijkstra 算法 Dijkstra 算法用于解决从一个节点到所有其他节点的最短路径问题，但要求边的权重为非负数。该算法维护一个距离表，通过不断选择距离最短的节点来更新表中的距离值。
下面是 Dijkstra 算法的 Python 实现：
import heapq def dijkstra(graph, start): distances = {node: float('infinity') for node in graph} distances[start] = 0 queue = [(0, start)] while queue: current_distance, current_node = heapq.heappop(queue) if current_distance &gt; distances[current_node]: continue for neighbor, weight in graph[current_node].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/830321f192dbafad72dffcf17dafaf81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f062e2b91888f503f5e86ea196bc259a/" rel="bookmark">
			git的使用——如何创建.gitignore文件，排除target、.idea文件夹的提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 git作为开发人员必备的技能，需要熟练掌握，本篇博客记录一些git使用的场景，结合具体问题进行git使用的记录。以gitee的使用为例。
本篇博客介绍如何创建.gitignore文件，排除一些文件夹的提交，比如排除target、.idea文件夹。
其他相关的git操作博客：
git的使用——结合具体问题记录git的使用 &amp; 代码提交从入门到熟练
文章目录 前言引出.gitignore文件1.新建.gitignore文件2.编辑.gitignore文件 提交gitee1.init、add2.commit3.romote add，push 总结 引出 1.已有的本地项目推送到gitee仓库；
2.创建.gitignore文件，排除一些代码的提交；
.gitignore文件 1.新建.gitignore文件 鼠标右键，打开 Git bash窗口
touch .gitignore 2.编辑.gitignore文件 对.gitignore文件进行编辑，加入要排除提交的文件，比如排除target、.idea文件夹
提交gitee 1.init、add 2.commit 3.romote add，push 总结 1.已有的本地项目推送到gitee仓库；
2.创建.gitignore文件，排除一些代码的提交；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09fe803d3533ca593c49689277ba48de/" rel="bookmark">
			【小程序教程】微信小程序的事件处理和交互逻辑（tap logpress touchmove input submint事件&amp;冒泡与捕捉最详细讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序的事件处理和交互逻辑 1. 事件处理基础1).`事件类型和触发条件`2).`事件绑定和监听`3).`事件对象和属性` 2.常见的事件处理方法1).`点击事件（tap）`2).`长按事件（longpress）`3).`滑动事件（touchmove）`4).`输入事件（input）`5).`表单提交事件（submit）` 3.事件冒泡和捕获1).`如何阻止事件冒泡`2).`事件捕获的使用场景`4.交互逻辑实现1).`条件判断和逻辑控制`2).`数据绑定和更新`3).`异步操作和回调函数` 为什么要学习事件处理和交互逻辑？
事件处理和交互逻辑在小程序开发中扮演着至关重要的角色。以下是几个原因：
提升用户体验：良好的事件处理和交互逻辑可以使小程序更加易用和友好，提升用户体验。通过合理设置事件触发条件和交互效果，可以使用户操作更加顺畅和自然。
增加功能和互动性：事件处理可以实现用户与小程序之间的交互，例如点击按钮、滑动页面、输入表单等。通过事件处理，开发者可以为小程序增加各种功能和互动性，满足用户的需求。
数据交互和更新：事件处理可以与后台数据进行交互，实现数据的获取、更新和展示。通过合理处理事件，可以实现数据的实时更新和展示，提供更加动态和丰富的内容。
逻辑控制和业务流程：事件处理和交互逻辑可以实现小程序的逻辑控制和业务流程。通过条件判断、跳转页面、异步操作等，可以实现复杂的业务逻辑和流程控制。
1. 事件处理基础 了解了事件类型和触发条件、事件绑定和监听、事件对象和属性后，我们可以更好地理解和应用事件处理和交互逻辑。
1).事件类型和触发条件 在微信小程序中，常见的事件类型包括点击事件（tap）、长按事件（longpress）、滑动事件（touchmove）、输入事件（input）、表单提交事件（submit）等。每种事件类型都有对应的触发条件，例如点击事件需要用户点击某个元素，长按事件需要用户长时间按住某个元素等。
2).事件绑定和监听 在小程序中，我们可以通过在组件上绑定事件来监听用户的操作。事件绑定可以在组件的标签上使用 bind 或 catch 属性，后接事件类型和对应的处理函数名称。例如，对于点击事件，可以使用 bindtap 或 catchtap 属性来绑定事件。
&lt;view bindtap="handleTap"&gt;点击我&lt;/view&gt; 在对应的 Page 或 Component 的 JavaScript 文件中，可以定义对应的事件处理函数。
Page({ handleTap:function(event){ console.log("点击了组件"); } }) 3).事件对象和属性 当事件触发时，小程序会自动将事件对象传递给事件处理函数。事件对象包含了一些属性，可以用于获取触发事件的相关信息，例如触发事件的元素、坐标、触摸点等。
常见的事件对象属性包括：
type：事件类型，例如 tap、longpress 等。target：触发事件的组件的一些信息，例如 id、class、dataset 等。currentTarget：当前正在处理事件的组件的一些信息。touches：触摸点的信息，例如坐标、标识符等。timeStamp：事件触发的时间戳。 通过访问事件对象的属性，我们可以获取和处理事件相关的信息，以实现更复杂的交互逻辑。
2.常见的事件处理方法 在微信小程序开发中，有许多常见的事件处理方法可以用于实现不同的交互逻辑。下面将介绍几种常见的事件处理方法。
1).点击事件（tap） 点击事件（tap）是最常见的事件之一，当用户点击某个元素时触发。可以通过在组件上使用 bindtap 或 catchtap 属性来绑定点击事件。
&lt;view bindtap="handleTap"&gt;点击我&lt;/view&gt; 在对应的 Page 或 Component 的 JavaScript 文件中，定义对应的事件处理函数。
Page({ handleTap:function(event){ console.log("点击了组件"); } }) 2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09fe803d3533ca593c49689277ba48de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db49e615c19134a75fe31be352c073f/" rel="bookmark">
			2023-2024-1高级语言程序设计第1次月考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-1-1 计算摄氏温度
给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：C=5×(F−32)/9。题目保证输入与输出均在整型范围内。
输入格式: 输入在一行中给出一个华氏温度。
输出格式: 在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。
输入样例: 150 输出样例: Celsius = 65 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; printf("Celsius = %d",5*(n-32)/9); return 0; } 7-1-2 计算火车运行时间
本题要求根据火车的出发时间和达到时间，编写程序计算整个旅途所用的时间。
输入格式： 输入在一行中给出2个4位正整数，其间以空格分隔，分别表示火车的出发时间和到达时间。每个时间的格式为2位小时数（00-23）和2位分钟数（00-59），假设出发和到达在同一天内。
输出格式： 在一行输出该旅途所用的时间，格式为“hh:mm”，其中hh为2位小时数、mm为2位分钟数。
输入样例： 1201 1530 输出样例： 03:29 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int x,y; cin&gt;&gt;x&gt;&gt;y; int a,b,c; a=x/100*60+x%100;b=y/100*60+y%100; c=b-a; printf("%02d:%02d",c/60,c%60); return 0; } 7-1-3 混合类型数据格式化输入
本题要求编写程序，顺序读入浮点数1、整数、字符、浮点数2，再按照字符、整数、浮点数1、浮点数2的顺序输出。
输入格式： 输入在一行中顺序给出浮点数1、整数、字符、浮点数2，其间以1个空格分隔。
输出格式： 在一行中按照字符、整数、浮点数1、浮点数2的顺序输出，其中浮点数保留小数点后2位。
输入样例： 2.12 88 c 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db49e615c19134a75fe31be352c073f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9fd2db9fd4974c5d2e46848ed603a7/" rel="bookmark">
			网络爬虫——urllib（4）文末好书推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言🍭 ❤️❤️❤️网络爬虫专栏更新中，各位大佬觉得写得不错，支持一下，感谢了！❤️❤️❤️
Python网络爬虫_热爱编程的林兮的博客-CSDN博客
上篇我们讲解了百度详细翻译这个案例，这篇同样也是进行案例讲解。
9.ajax的get请求🍉 Ⅰ、ajax的get请求请求豆瓣电影第一页🍓 我们打开豆瓣电影，随便打开一个排行榜（电影-&gt;剧情）
豆瓣电影分类排行榜 - 剧情片 (douban.com)
​
我们F12，打开开发者工具
打开第一个接口，可以看到只有网页，没有数据，我们继续找
​
找到下面这个，发现了“肖申克的救赎” ，但是这个只有一个数据啊，继续找
​
我们又找到一个，有20个数据（都是json格式的，因为它给我们返回的就是json数据，前后端分离），我们打开来看看
​
前面两个是 肖申克的救赎 和 霸王别姬
​
最后一个（第二十个）是 海上钢琴师 ​
果然 第二十部电影是 海上钢琴师 ​
这个接口就是我们想要的数据，好下面我们来写代码：
​
这是get请求，我们就按get请求来做。
# get请求 # 获取豆瓣电影的第一页的数据 并且保存起来 import urllib.request # header中的url url = 'https://movie.douban.com/j/chart/top_list?type=11&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36' } # (1) 请求对象的定制 request = urllib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c9fd2db9fd4974c5d2e46848ed603a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a512ab530e12fc9ad92e336cd612a512/" rel="bookmark">
			加速软件开发和交付的革命性方法-DevOps
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ 随着信息技术的快速发展，现代软件开发和交付已经经历了巨大的变革。DevOps（Development和Operations的结合）已经成为这一变革的关键推动力，让开发团队和运维团队之间的界限变得模糊，以加速软件的开发、测试和部署过程。本文将介绍DevOps的核心概念、原则和优势，以及它如何影响现代软件开发。”
一、关于DevOps DevOps是一种软件开发方法，它强调开发团队和运维团队之间的紧密协作，以实现以下核心目标：
**自动化：**DevOps鼓励自动化软件交付流程中的各个环节，包括代码构建、测试、部署和监控。自动化可以减少手动操作，提高效率，并降低人为错误的风险。
**协作：**开发人员和运维人员之间的紧密协作是DevOps的关键。他们共同负责软件的全生命周期，而不仅仅是各自负责一部分。这种协作有助于更早地发现和解决问题。
**持续交付：**DevOps鼓励采用持续交付流程，允许频繁地发布新功能和修复。这有助于缩短软件发布周期，满足用户需求，并提高市场竞争力。
**监控和反馈：**DevOps强调在生产环境中积极监控应用程序，并及时获取用户反馈。这使得团队可以快速响应问题，并不断改进软件质量。
二、DevOps原则 DevOps背后的一些关键原则包括：
**自动化一切：**通过自动化，从代码构建到部署和测试的所有过程，可以实现可靠性和一致性。
**持续集成：**将代码的变更频繁合并到共享代码库，并通过自动化构建和测试确保新代码不会引入问题。
**持续交付：**自动化部署和测试，以便能够随时准备将新功能交付给用户。
**微服务架构：**将应用程序拆分为小的、独立的服务，以便更容易部署、扩展和维护。
**监控和反馈：**主动监控应用程序，及时发现和解决问题，并从用户反馈中学习。
三、DevOps优势 DevOps的采用可以带来许多优势，包括：
**更快的交付：**DevOps允许团队更快地交付新功能和修复，提高了市场敏捷性。
**更高的质量：**自动化测试和持续集成有助于减少缺陷，并提高软件质量。
**更高的可靠性：**自动化部署和监控可以降低故障风险，提高系统可用性。
**更好的协作：**DevOps鼓励开发和运维团队之间的紧密协作，有助于快速问题解决和知识共享。
**更好的用户体验：**持续交付和快速反馈循环有助于满足用户需求，提供更好的用户体验。
DevOps已经成为现代软件开发和交付的核心方法之一。它强调自动化、协作、持续交付和监控，以提高软件开发的效率和质量。通过采用DevOps原则和实践，组织可以更好地满足市场需求，提供更好的用户体验，并提高竞争力。无论是小型创业公司还是大型企业，DevOps都有潜力为其带来巨大的好处。
DevOps社区大会（广州站） 主会场 主会场共邀请到 6位 大咖讲师，从如何渐进式的拥抱DevOps到混沌工程，再到SRE里锻造的平台工程。不仅有DevOps的接口全生命周期管理，更有可观测性洞悉复杂的生产系统，同时还邀请到Daniel Flower为大家带来DevOps Experiments with AI的分享。大咖汇聚，重磅登场！
质量测试专场
金融科技专场
数据治理专场
智能制造专场
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50f2f87c9842ee5e4eaa03bf8db69a4/" rel="bookmark">
			Python教程总结版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. chr()和ord()的用法
2. input()——读取数据的转换
2.1 int(),float(),list() 数据转换
2.2 split()函数处理多个输入值
2.3 map()强制转换
1. chr()和ord()的用法 for i in range(65, 91): print(chr(i), end='') # 控制台输出：ABCDEFGHIJKLMNOPQRSTUVWXYZ print() print(ord('刘')) # 21016 print(chr(76)) # L ord函数可以将字符转化为你所需要的ASCII码。
chr函数根据传入的int类型参数返回对应的Unicode 码位的字符，比如chr(76) 返回的是字符L
print(chr(i), end='')
print输出不换行
2. input()——读取数据的转换 没有报错，说明输入的数，赋值给x，x是字符串类型，如果是int类型，不能直接与字符串相加
所以无论输入什么，input函数统一当做字符串处理
2.1 int(),float(),list() 数据转换 我们可以使用类型强制转换，将数据转换为我们想要的int、float、list等类型。
如下：
if __name__ == '__main__': a = int(input('请输入整型：')) b = float(input('请输入浮点型：')) c = list(input('请输入数组类型：')) print(a, b, c) &gt;&gt;&gt; E:\myProjects\PycharmProjects\pythonProject\venv\Scripts\python.exe E:\myProjects\PycharmProjects\pythonProject\chap2\test01.py 请输入整型：420 请输入浮点型：11.11 请输入数组类型：a,b,c,d 420 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50f2f87c9842ee5e4eaa03bf8db69a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a219f66e426f42cd58f727ff7b820a15/" rel="bookmark">
			Error: Projects must list all files or use an ‘include‘ pattern.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import引入文件时，文件明明存在却报错：
File 'xxx/packages/@vue/src/use-list.ts' is not listed within the file list of project 'xxx/packages@/vue/tsconfig.json'. Projects must list all files or use an 'include' pattern. 解决方法：
在 is not listed within the file 指明的文件中的 include 中添加或修改路径正则。
当前指明路径正则有问题的文件是tsconfig.json，所以到tsconfig.json文件中查看 include项。
tsconfig.json：
{ "include": ["src"], } 修改后的 tsconfig.json： { "include": ["src/**/*.ts"], } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1090f7406d288328bee82860e14f2663/" rel="bookmark">
			[ts]控制台报错 ts类型 AxiosRequestConfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [ts]控制台报错 ts类型 AxiosRequestConfig
problem
执行 yarn build
控制台报错 ts类型
axios 类型报错 version “1.3.4”
Argument of type '(config: AxiosRequestConfig) =&gt; AxiosRequestConfig&lt;any&gt;' is not assignable to parameter of type '(value: InternalAxiosRequestConfig&lt;any&gt;)
reason 不清楚是什么已有
solution 方法1：用 AxiosRequestConfig 代替 AxiosRequestConfig 可以解决
方法2：临时用any解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f9c0ebf73fd4e9311afe1c93e5a7262/" rel="bookmark">
			Vue3 &#43; TS4.8的一些类型标注踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文记录一些使用Vue3 + TS4.8的类型标注踩坑记录，持续更新：
ts是"typescript": "~4.8.4"
先上我的基本package.json配置：
{ "name": "vue-project", "version": "0.0.0", "private": true, "scripts": { "dev": "vite", "build": "run-p type-check build-only", "preview": "vite preview", "test:unit": "vitest", "build-only": "vite build", "type-check": "vue-tsc --noEmit -p tsconfig.vitest.json --composite false", "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .eslintignore", "format": "prettier --write src/" }, "dependencies": { "pinia": "^2.0.32", "vue": "^3.2.47", "vue-router": "^4.1.6" }, "devDependencies": { "@rushstack/eslint-patch": "^1.2.0", "@types/jsdom": "^21.1.0", "@types/node": "^18.14.2", "@vitejs/plugin-vue": "^4.0.0", "@vitejs/plugin-vue-jsx": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f9c0ebf73fd4e9311afe1c93e5a7262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1918610c7115ad2a7871977b4424d07a/" rel="bookmark">
			React 组件点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击事件 点击事件方式1、传统类方法（不推荐）2、传统类方法 16.3.0 - 自动绑定（不推荐）3、箭头函数3.1、类组件3.2、函数组件3.3、内联箭头函数 4、useState Hook 点击事件方式 1、传统类方法（不推荐） 当你需要在React中使用.bind(this)时，通常是在类组件中，以确保在事件处理程序中访问组件的this。以下是.bind(this)的写法示例：
import React, { Component } from 'react'; class MyComponent extends Component { constructor(props) { super(props); this.state = { count: 0, }; // 绑定 handleClick 方法的 this this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState({ count: this.state.count + 1 }); } render() { return ( &lt;div&gt; &lt;p&gt;Count: {this.state.count}&lt;/p&gt; &lt;button onClick={this.handleClick}&gt;Click me&lt;/button&gt; &lt;/div&gt; ); } } export default MyComponent; 在这个示例中，我们在类构造函数中使用.bind(this)来绑定this.handleClick，确保在handleClick方法中可以正确访问组件的状态。这是传统的做法。
2、传统类方法 16.3.0 - 自动绑定（不推荐） React 在版本16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1918610c7115ad2a7871977b4424d07a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a5724308e10a207327de76b6ee88cf3/" rel="bookmark">
			【GNSS测试技术（一）】GNSS基础原理介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、GNSS概述 GNSS（全球卫星导航系统）是一种基于卫星信号的定位技术，通过使用分布在地球轨道上的卫星，为用户提供全球范围内的定位、导航和授时服务。目前有如下GNSS定位系统：
2、GNSS系统组成 卫星导航系统的主要组成部分包括：空间段、控制段和用户段。
空间段：由卫星或航天器 (SV) 组成，用于传输包含卫星轨道、位置、传输时间的导航电文。控制段：指地面监测站和主控中心，用于跟踪卫星信号、收集伪距测量数据和大气层模型数据、提供导航信息更新、大气信息和校正信息以及进行卫星控制。用户段：是指 GNSS接收机。 3、GNSS定位原理 卫星导航系统GNSS接收机通过三边测量法来计算自身位置。它使用导航电文中的传输时间和位置数据，测量卫星信号的时延，并由此计算接收机与卫星的距离(伪距)。首先，距离某颗卫星特定距离(伪距)的GNSS接收机所有的可能位置构成了一个球面。两个球面的交集是一个圆环。三个球面的交集则是两个点。最后需要第四个数据来确定接收机的正确位置。第四个数据可以是地球表面，也就是说，如果接收机位于地球表面，则位于地球表面上的点就是接收机的正确位置。对于更普遍的解决方案，则需要第四颗卫星的伪距，来进行定位。同时通过对四颗卫星进行测量，不仅可以确定接收机的位置信息，即经度、纬度和高度，还可以校正接收机的时钟误差，确定正确时间。
卫星导航系统GNSS卫星信号的传输功率很低。在地球表面，功率电平大约为-155至-160dBW(-125至-130dBm)。在复杂的城市环境，特别是存在遮挡的时候，信号功率还会更低。GNSS接收机通过低噪声放大器和信号处理，来恢复GNSS信号。 4、GNSS误差来源 GNSS系统的误差来源可以分为4类：与信号传播有关的误差、与卫星有关的误差、与接收机有关的误差以及与地球转动有关的误差，如下表：
GNSS系统误差误差来源对测距的影响（米）与信号传播有关的误差电离层延迟误差1.5-15对流层延迟误差多路径效应误差与卫星有关的误差卫星星历误差1.5-15卫星时钟误差卫星轨道误差相对论效应与接收机有关的误差接收机时钟误差1.5-5天线相位中心误差与地球转动有关的误差地球潮汐的影响1地球自转的影响 4.1、电离层延迟误差 电离层是处于地球上空50~1000km 高度的大气层。该大气层中的中性分子受太阳辐 射的影响发生电离，产生大量的正离子与电子。在电离层中，电磁波的传输速率与电子密度有关。因此直接将真空中电磁波的传播速度乘以信号的传播时间得到的距离，很大可能与 卫星至接收机间的真实几何距离不相等，这两种距离上的偏差叫电离层延迟误差。
电离层 延迟误差是影响卫星定位的主要误差源之一，它引起的距离误差较大，一般在白天可以达到 15m 的误差，在夜晚则可以达到3m 的误差；并且在天顶方向引起的误差最大可达50m，水 平方向引起的误差最大可达150m。
针对电离层延迟误差的改进措施通常包括利用双频观测、利用电离层模型辅以修正和利用同步观测值求差。
4.2、对流层延迟误差 对流层是地球大气层的低层，位于地面上方约10公里至50公里的高度范围内。对流层中存在气象变化、温度梯度和湿度变化等现象，这些因素会对GNSS信号的传播产生影响。对流层误差主要表现为信号传播速度的变化和折射效应，这会引起定位误差。对流层误差通常在地面观测（如基站观测）中更为显著，尤其在较长的测量路径上更容易受到影响。
4.3、多路径效应误差 接收机接收信号时，如果接收机周围物体所反射的信号也进入天线，并且与来自卫星的信号通过不同路径传播且于不同时间到达接收端，反射信号和来自卫星的直达信号相互叠 加干扰，使原本的信号失真或者产生错误，造成衰落。这种由于多径信号传播所引起的 衰落被称作多径效应，也称多路径效应。
多径效应误差是卫星导航系统中一种主要的误差源，可造成卫星定位精确度的损害，严重时还将引起信号的失锁。改进措施通常包括将接收机天线安置在远离强发射面的环境、选择抗多径天线、适当延长观测时间、降低周期性影响、 改进接收机的电路设计、改进抗多径信号处理和自适应抵消技术。
4.4、卫星星历误差 由星历所给出的卫星位置与卫星实际位置之差称为卫星星历误差。卫星星历误差主要 由钟差、频偏、频漂等产生。针对卫星在运动中受到的多种摄动力的综合影响，对于目前的 技术来说，要求地面监测站实现准确、可靠地测出这些作用力，并掌握其作用规律是比较困 难的，因此卫星星历误差的估计和处理尤为关键。
改进措施通常包括忽略轨道误差、通过轨 道改进法处理观测数据、采用精密星历和同步观测值求差。
4.5、相对论效应 根据相对论的理论，由于卫星的高速运动使得卫星钟的频率比静止在地球上的同类钟的频率有所增加。
4.6、卫星时钟误差 卫星钟的精确度会受到多种因素的影响，例如温度变化、电子器件的老化等，这些因素可能导致卫星钟与地面时钟之间存在微小的差异，进而引入定位误差。 4.7、卫星轨道误差 卫星在轨道上运动时，可能会受到地球的引力、月球的引力、太阳的引力以及其他天体的引力扰动。这些扰动会导致卫星轨道的微小变化，从而影响定位精度。
4.8、接收机时钟误差 接收器本身的硬件设计和性能也可能引入定位误差，例如时钟不准确、信号采样率低等。
4.9、天线相位中心误差 由于天线设计或安装不精确，天线接收到的信号可能与天线的几何中心不完全对齐，导致定位误差。
4.10、地球潮汐的影响 由于地球固体潮和负荷潮引起测站位移，使得不同时间的测量结果互不一致。
4.11、地球自转的影响 由于地球的自转的影响引起卫星坐标的变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f2d92ded0b848ddab049fff70c7396/" rel="bookmark">
			response.setContentType()的作用及参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		response.setContentType的作用及参数 response.setContentType作用SpringMVC produces与setContentTypecontent-type对照表参考优秀文章 response.setContentType作用 response.setContentType(MIME)的作用是使客户端浏览器区分不同种类的数据，并根据不同的MIME调用浏览器内不同的程序嵌入模块来处理相应的数据。
MIME映射策略就是在网页中使用哪个应用程序（即插件），打开哪种文件。
例如web浏览器就是通过MIME类型来判断文件是PNG图片。通过MIME类型来处理json字符串。
请看如下代码案例：
@GetMapping("getImage") public void getPngImage(HttpServletResponse response) throws IOException { // 利用 输入流从磁盘中读取一个jpg的图片 String imagePath = "E:\\壁纸\\8b82b9014a90f6030add233a3b12b31bb051ed5a.jpg"; FileInputStream in = new FileInputStream(imagePath); // 设置响应给客户端的文件格式 response.setContentType("image/jpeg"); // 获取响应体的输出流 ServletOutputStream os = response.getOutputStream(); // 用 BufferedOutputStream（处理流/包装流）来包装上面那个输出流 BufferedOutputStream bos = new BufferedOutputStream(os); byte[] buff = new byte[1024]; int len = 0; // 输入流读入字节码内容 while ((len = in.read(buff, 0, 1024)) != -1) { // 输出流写出字节码内容 bos.write(buff, 0, len); } // 关闭输出流 if (bos !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f2d92ded0b848ddab049fff70c7396/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb71e98fa7132267a73e437cb8fd9634/" rel="bookmark">
			Fastjson与Gson的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fastjson与Gson的简单使用 FastjsonJava对象 -&gt; Json字符串Json字符串 -&gt; Java对象Json字符串 -&gt; JSONObject对象Json字符串 &lt;-&gt; JSONArray对象FastJson序列化时"\$ref":"\$.a.b" ——引用类型 GsonJava对象 -&gt; Json字符串Json字符串 -&gt; Java对象Json字符串 -&gt; List 和 Map Fastjson Java对象 -&gt; Json字符串 Fastjson将对象转成Json字符串依赖于对象的get方法，以Person类为例（注意该类中没有sex属性的set、get方法，且多加一个非本类属性的getOther方法）：
public class Person { String name; Integer age; Integer sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getOther() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb71e98fa7132267a73e437cb8fd9634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5d96fc661be39b1f770167b97208ec/" rel="bookmark">
			Pycharm使用阿里云SDK发送短信（超详细&#43;避坑！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 注册阿里云2. 创建签名3. 创建模板4. 创建AccessKey5. API发送测试6. 获取示例7. pycharm发送验证码7.1 安装sdk7.2 参数修改7.3 发送随机四位数字7.4 验证码信息返回7.5 简易版代码： 1. 注册阿里云 访问阿里云官网，进行注册
https://www.aliyun.com/ 同时进行实名认证
2. 创建签名 按下列顺序来到阿里云的短信服务
这里自行填入：
签名：就是你发送短信的标签，比如：【签名】您的验证码为：1234，您正在登录，若非本人操作，请勿泄露。
签名来源：我选择的是“测试或学习”（因为我本身也是用来做项目测试用的）
场景说明：也可以说明一下是自己用来学习测试用的。
更多资料：可以不用上传。
提交后等待审核即可，若审核未通过，就看看是什么原因造成的，再重新修改并添加。
3. 创建模板 这里需要等待签名审核通过后再创建模板。
模板类型：选择不同的类型，下面模板内容的提示描述不同。
模板名称：就是简单描述你这个模板是干嘛的，比如上图我创建了两个模板“用户注册”和“登录验证码”，一个就是拿来登录用的，另一个就是拿来注册用的。
模板内容：就是短信具体的内容了，比如我前面举的例子（您的验证码为：1234，您正在登录，若非本人操作，请勿泄露。）注意，【签名】是它自动帮你生成的，不用管。还要注意下面说的变量，看看它提供的变量格式就明白了。
应用场景：就自己填写了，我之前自己创建了一个公众号，就用了公众号的名字。
场景说明：就按照它说明的，写上用来测试账号即可。
创建好后等待审核通过即可。
4. 创建AccessKey 我这里选择的是继续使用AccessKey
创建好后就会显示你的ID和Secret，一定要保存好AccessKey Secret，因为一旦关掉这个后后面就找不到它了。
这样AccessKey就创建好了。
5. API发送测试 提前购买一些短信套餐，新人有折扣挺便宜的，也就几块钱，这里不多说。
就是在这个页面往上拉一点就能看到“购买国内套餐包”。
点击“调用API发送短信”后来到这个页面
直接点击“发送调用”，它会提示你会产生费用，所以我们最好提前购买好套餐。
然后就可以从手机上看到了
6. 获取示例 测试后我们回到刚刚的网页，按顺序点击
第三个步骤是复制上面的python代码，复制后的代码我放在下面了。
# -*- coding: utf-8 -*- # This file is auto-generated, don't edit it. Thanks. import os import sys from typing import List from alibabacloud_dysmsapi20170525.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5d96fc661be39b1f770167b97208ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ed4edc2251a7bd23e1ca7cf88933c8/" rel="bookmark">
			轻量级gif制作工具 GIFfun中文 for mac
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GIFfun是一款GIF制作工具，可以帮助用户从照片和视频中创建GIF动画。该软件具有多种功能，例如GIF转视频、视频转GIF、照片转GIF、照片转视频、GIF转JPG、调整GIF大小、PDF转GIF、PDF转JPG、裁剪视频、GIF编辑等。
GIFfun还提供了专业版功能，如裁剪视频、视频转GIF、GIF转视频、照片转视频等。用户需要升级到专业版才能解锁这些功能。此外，GIFfun支持简体中文等多语言
1. GIF转视频
将GIF转换为视频。
2. 视频转GIF
将视频转换为GIF。
3. 照片转GIF
将多张照片转换为GIF。
4. 照片转视频
将多张照片转换为视频。
5. GIF转JPG
将GIF选择的帧导出为JPG图片。
6. 调整GIF大小
更改GIF尺寸。
GIFfun中文 for mac
7. PDF转GIF
将PDF转换为GIF。
8. PDF转JPG
将PDF选择的页面导出为JPG图片。
9. 裁剪视频
将视频裁剪为短视频。
10. GIF编辑
反转GIF，智能降帧，裁剪GIF，调整延迟时间和循环次数等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91579b81b7d42bc7e8990b8e6e0c3d91/" rel="bookmark">
			双轮差速模型机器人通过线速度、角速度计算机器人位姿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已知上一时刻机器人位置P_OLD (x,y,),机器人当前时刻的线速度和角速度（v,）,短时间内t内，机器人在线性部分和非线性部分的增量为
线性部分：
非线性部分： 由于可能非常小，导致非线性部分数值不稳定， 因此可以对以上部分做泰勒级数展开，我们只做一阶泰勒展开 所以 ，所以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e896107f6943d2cde526ff5ae008750a/" rel="bookmark">
			ARMV7架构知识点记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArmV7-A架构知识点记录 ​ ARM会定期发布该架构的新版本。它们会添加新功能或对现有行为进行更改。此类更改几乎总是向后兼容的，这意味着在旧版本的体系结构上运行的用户代码将继续在新版本上正确运行。当然，为了利用新特性而编写的代码无法在缺乏这些特性的旧处理器上运行。在体系结构的所有版本中，一些系统特性和行为都是由实现定义的。例如，体系结构没有定义各个指令的缓存大小或循环时间。这些是由个别的核心和SoC决定的。每个架构版本还可以定义可选的扩展。这些可能在处理器的特定实现中实现。例如，在ARMv7体系结构中，高级SIMD (Advanced SIMD, NEON)技术是可选的扩展，在第7章介绍NEON时会介绍它。ARMv7体系结构也有配置文件的概念。这些是描述针对不同市场和用途的处理器的体系结构的变体。
1.ArmV7体系 ​ ArmV7有三个体系分别是ArmV7-A,ArmV7-R,ArmV7-M
A 应用程序配置文件定义了一种针对高性能处理器的体系结构，支持使用内存管理单元(MMU)的虚拟内存系统，因此能够运行功能齐全的操作系统。提供了对ARM和Thumb指令集的支持。ARMv8-A架构支持AArch32状态，这是该架构的32位实现，向后兼容ARMv7-A。
R 实时概要文件定义了针对需要的系统的体系结构确定性定时和低中断延迟。不支持虚拟内存系统，但可以使用简单内存来保护内存区域保护单元(MPU)。R系列一般用于对实时性要求较高的场景。
M 微控制器配置文件定义了一种针对低成本系统的体系结构，其中低延迟的中断处理至关重要。它使用了与其他配置文件不同的异常处理模型，并且只支持Thumb指令集的一个变体。M系列一般用于控制以及低功耗方面。
2.架构历史和扩展 ​ 从80年代中期的第一个测试硅到90年代早期的第一个ARM6和ARM7器件，ARM架构变化相对较小。在该体系结构的第一个版本中，大部分的加载、存储和算术操作以及异常模型和寄存器集都由ARM1实现。版本2增加了multiply和multiply-accumulate指令，并支持协处理器，还有其他一些创新。这些早期的处理器只支持26位的地址空间。该体系结构的版本3分离了程序计数器和程序状态寄存器，并添加了几个新模式，支持32位地址空间。版本4增加了对半字加载和存储操作的支持，以及一个额外的内核级特权模式。如果不熟悉ARM体系结构的读者在本描述中使用了他们不熟悉的术语，也不用担心，因为所有这些主题都将在后续章节中介绍。ARMv4T架构引入了Thumb(16位)指令集，由ARM7TDMI®和ARM9TDMI®处理器实现，这些产品已经出货数十亿美元。ARMv5TE架构增加了对dsp类型操作和饱和运算以及ARM/Thumb互操作的改进。ARMv6做了许多增强，包括支持非对齐内存访问、对内存架构的重大更改和多核支持，以及支持在32位寄存器中操作字节或半字的SIMD操作。它还提供了许多可选的扩展，特别是Thumb-2和安全扩展(TrustZone)。Thumb-2将Thumb扩展为混合长度(16位和32位)指令集。
​ ARMv7-A体系结构强制使用Thumb-2扩展，并添加了Advanced SIMD扩展(NEON)
​ 多年来，ARM对处理器采用了顺序编号系统，从ARM9到ARM8，再到ARM7。各种数字和字母被附加到基族中以表示不同的变体。例如，ARM7TDMI处理器有T表示Thumb, D表示Debug, M表示快速乘法器，I表示EmbeddedICE。
​ 对于ARMv7架构，ARM有限公司为其处理器采用了Cortex品牌名称，并附带一个字母表示处理器支持三种配置文件(A, R或M)中的哪一种。
​ 下图显示了不同版本的架构如何对应不同的处理器实现。这个图并不全面，也不包括所有的体系结构版本或处理器实现。
​ 我们常见的STM32F1，F4系列就是ARMV7-M架构的，可以去官网下载对应的我文档，这里介绍ArmV7-A。
​ ARM Cortex-A7处理器是ARM开发的最节能的应用处理器，扩展了ARM在入门级智能手机、平板电脑和其他先进移动设备上的低功耗领导地位。下图时ARMV7-Ac处理器架构框图
上图可以看出
支持处理器多核调式和跟踪支持数据处理引擎支持指令缓存和数据缓存支持硬件浮点运算128-bitAMBA总线接口 3处理器模式和寄存器组 ​ ARM架构是一种模态架构。在引入安全扩展之前，它有7种处理器模式，如下表图所示。有6种特权模式和1种非特权用户模式。特权是执行某些在用户(非特权)模式下无法完成的任务的能力。在用户态下，对影响系统整体配置的操作有限制，例如MMU配置和缓存操作。ARMV7-M如我们的STM32只由特权和非特权两种。
在不同处理器模式下对LR（R14）寄存器的调整。
​ 特定处理器模式和状态的存在取决于处理器是否实现了相关的架构扩展，如下图所示。
​ 当前处理器模式和执行状态包含在当前程序状态寄存器(current Program Status Register, CPSR)中。改变处理器状态和模式可以通过特权软件显式地进行，也可以通过异常处理来实现。
3.1寄存器组 ​ ARM架构提供了16个32位通用寄存器(r0 ~ r15)供软件使用。其中15个(r0 ~ r14)可用于通用数据存储，R15为程序计数器，其值随着核心执行指令的变化而变化。软件对R15的显式写入将改变程序流程。软件也可以访问CPSR，以及先前执行模式下保存的CPSR副本，称为保存的程序状态寄存器(SPSR)。
​ Cortex-A7 有 9 种运行模式，每一种运行模式都有一组与之对应的寄存器组。每一种模式可见的寄存器包括 15 个通用寄存器(R0~R14)、一两个程序状态寄存器和一个程序计数器 PC。在这些寄存器中，有些是所有模式所共用的同一个物理寄存器，有一些是各模式自己所独立拥有的，各个模式所拥有的寄存器如下图所示。
​ 浅色字体的是与 User 模式所共有的寄存器，蓝绿色背景的是各个模式所独有的寄存器。可以看出，在所有的模式中，低寄存器组(R0~R7)是共享同一组物理寄存器的，只是一些高寄存器组在不同的模式有自己独有的寄存器，比如 FIQ 模式下 R8~R14 是独立的物理寄存器。假如某个程序在 FIQ 模式下访问 R13 寄存器，那它实际访问的是寄存器 R13_fiq，如果程序处于 SVC 模式下访问 R13 寄存器，那它实际访问的是寄存器 R13_svc。总结一下，CortexA 内核寄存器组成如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e896107f6943d2cde526ff5ae008750a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f984bffd4d64a0b87fb47f35bdb592/" rel="bookmark">
			自荐一本良心Java教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年的某天，北大出版社联系到我，希望我能写一本Java语言教程，而我也很开心的接下了这个项目。本着服务于广大Java学习者的心态，在接下来的日子里，我努力策划、用心编排，写啊写啊。。。边写边向出版社提交文稿，不知掉了多少头发，终于用了一年时间把全部稿子提交给了出版社，结果，对方的回复是：
出版社方说写的太多了，估计会定价较高，怕没人买。接到这个消息后，我虽不至于感觉到五雷轰顶，但也感觉深深自己的心血被大大的打了折扣，我不想让自己的作品被“阉割”，于是我做出了一个决定，把本书以博客的形式发布到网上供读者观看学习，传送门如下：
《Java从小白到高手》
在这本书中，我努力的把知识点讲得清晰易懂，在word文档中用“方正中等线简体”9.5号字体整整写了将近1000页，全书共分为三大篇25章，目录如下：
第一篇 Java语法
第1章 初学者问题大集合
1.1 我能学会编程吗？
1.2 学会编程就可以成为软件工程师吗？
1.3 学了Java编程能应聘什么岗位？
1.4 Java程序是如何执行的？
1.5 Java开发环境的搭建
1.5.1下载并安装JDK
1.5.2配置环境变量
1.5.3测试开发环境
1.5.4配置环境变量的意义
1.5.5 JDK、JRE和JVM的关系
1.6 IntelliJ IDEA的下载与安装
1.7 编写第一个Java程序
1.8 Java程序初步释疑
第2章 Java程序世界初探
2.1 认识Java语言的变量
2.1.1 Java语言基础数据类型
2.1.2 变量的声明与使用
2.2 常量的使用
2.3 在程序中添加注释
2.4 实战第一仗 计算圆形面积
2.5 算术运算符
2.5.1 双目算术运算符
2.5.2 单目算术运算符
2.6 赋值运算符
2.6.1 普通赋值运算符
2.6.2 复合赋值运算符
2.7关系运算符及条件语句
2.8条件运算符
2.9逻辑运算符
2.9.1 双目逻辑运算符
2.9.2 单目逻辑运算符
2.10 多重if...else语句
2.11 switch结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f984bffd4d64a0b87fb47f35bdb592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76e9c2481ad354998aa35257c26bb97/" rel="bookmark">
			Java中日期格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中日期格式转换可以使用DateFormat类和SimpleDateFormat类。下面是使用SimpleDateFormat类将日期字符串转换为指定格式的日期示例：
import java.text.SimpleDateFormat; import java.util.Date; public class DateFormatExample { public static void main(String[] args) { String dateString = "2023-10-31 15:30:45"; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try { Date date = dateFormat.parse(dateString); String newDateString = dateFormat.format(date); System.out.println("Original Date String: " + dateString); System.out.println("Formatted Date String: " + newDateString); } catch (Exception e) { System.out.println("Date format exception: " + e.getMessage()); } } } 输出结果为：
Original Date String: 2023-10-31 15:30:45 Formatted Date String: 2023-10-31 15:30:45 在上述示例中，我们使用SimpleDateFormat类创建了一个日期格式对象，该对象指定日期格式为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76e9c2481ad354998aa35257c26bb97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00a1d4f734083e1e33eebd11f130ea4/" rel="bookmark">
			每日自动化提交git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前这个功能，有个前提：
这个git代码仓库，是一个人负责，所以不存在冲突问题
我这个仓库地址下载后的本地路径是：D:\Projects\Tasks
然后我在另外一个地方新建了一个bat文件：
bat文件所在目录为：D:\CacheFiles\Bats\git_tasks_up.bat
bat文件的注释与内容：
:: 将目录切换到git仓库所在位置
cd /d D:\Projects\Tasks
:: 获取git最新代码
git pull
:: 将所有改动和新增文件到暂存区
git add .
:: 提交并备注
git commit -m "update"
:: 推送到git服务器
git push :: 如果第一次怕有问题，可以打开下面的pause查看有无报错
:: pause
上面就是最简单的提交命令，如果你需要解决冲突问题，则需要另外添加对应的处理命令
建议首次手动点击一次，因为需要账号密码登录一次，保证有私钥记录。
第二次自动化提交就不用了。
然后在任务计划程序里，新建一个任务：
任务的目录就指向bat文件：D:\CacheFiles\Bats\git_tasks_up.bat
时间定到下班时间之后，或者0点钟。
建好之后，右键点击【运行】试一下，运行没有问题，之后就可以自动化提交了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc33389bb5211345913bb706057f5fc/" rel="bookmark">
			MySQL性能测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着大数据时代的发展，数据库系统的性能已经成为影响业务稳定性和用户体验的重要因素之一。为了确保数据库的高效运行，我们需要对它进行定期的性能测试。MySQL是一款非常流行的开源关系型数据库管理系统，因此本文将为您详细介绍几款常用的MySQL性能测试工具及其使用方法。
MySQL性能测试工具通常具备以下特点：
（1）支持多种操作系统和MySQL版本；
（2）可模拟多种数据访问模式和负载情况；
（3）提供详细的性能指标和报告；
（4）易于集成到自动化测试框架。
使用MySQL性能测试工具进行性能测试的一般步骤如下：
（1）选择合适的工具并配置连接参数；
（2）根据需求设置测试场景和负载情况；
（3）执行测试并收集性能数据；
（4）分析性能数据并制定优化方案。
一、sysbench sysbench是一个非常强大的性能基准测试工具，它可以用来模拟高负载情况下的数据库行为。以下是使用sysbench对MySQL进行性能测试的基本步骤：
安装sysbench： sudo apt-get install sysbench 创建测试表： CREATE TABLE sbtest ( id INT NOT NULL AUTO_INCREMENT, k INT NOT NULL, c CHAR(120), pad CHAR(60) NOT NULL, PRIMARY KEY (id) ); 运行sysbench命令进行测试： sysbench oltp_read_write.lua --tables=10 --table_size=1000000 run 此命令将在单个CPU核心上执行一个读写混合的工作负载，每个表包含100万个记录。
二、BenchmarkSQL BenchmarkSQL是另一款常用的MySQL性能测试工具，它源自TPC-C标准，并对其进行了简化和优化。以下是使用BenchmarkSQL进行性能测试的基本步骤：
下载并解压BenchmarkSQL： wget http://sourceforge.net/projects/benchmarksql/files/latest/download?source=files tar xvf benchmarksql.tar.gz cd benchmarksql 编译和安装BenchmarkSQL： make sudo make install 运行BenchmarkSQL： ./benchmarksql -S localhost -P 3306 -D test 此命令将在本地MySQL服务器上运行测试，数据库名称为test。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc33389bb5211345913bb706057f5fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc3d84ce464f98fe6eb9415c90f1689/" rel="bookmark">
			Python123：求e的近似值、统计素数并求和、统计一个整数的位数、用序列求和公式1&#43;1/1！&#43;1/2！ &#43; ……（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、求e的近似值2、统计素数并求和3、统计一个整数的位数4、用序列求和公式1+1/1！+1/2！ + …… 1、求e的近似值 题目： 自然常数 e 可以用级数 1+1/1!+1/2!+⋯+1/n!+⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n+1 项和。
输入格式：
输入第一行中给出非负整数 n（≤1000）。
输出格式：
在一行中输出部分和的值，保留小数点后八位。
输入样例：
10 输出样例：
2.71828180 代码1：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; double fact(int a) { double b=1; int i; if(i=0){b=1;} else{ for(i=1;i&lt;=a;i++){ b=b*i;} } return b; } int main() { int i,n; double s=0; scanf("%d",&amp;n); for(i=0;i&lt;=n;i++){ s=s+1.0/fact(i); } printf("%.8f",s); return 0;	} 代码2：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int i,n; double sum=1; double fact(int n); scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc3d84ce464f98fe6eb9415c90f1689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca04ac88fb67d9da5031f58574da7c40/" rel="bookmark">
			tps5430手把手教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TPS5430手把手教学
目录
一、buck电路原理
二、tps5430芯片介绍
1.1芯片引脚图
1.2芯片引脚说明
三、tps5430参考电路讲解以及PCB布局
1.正压降压（15V转12V）
1.1原理图
1.2器件选择
1.3PCB布局
2.正压降负压
2.1原理图
2.2PCB布局
2.3注意事项
一、buck电路原理 BUCK电路原理：
BUCK电路，又称降压式变换电路，由开关（一般是MOS管），二极管，电感，电容，电阻组成。（电路需要比较高的开关频率，较理想的开关元件就是MOS管）
电路的拓扑结构如下图所示，和boost电路也很相像。
电路实现降压的原理类似pwm脉宽调制，但是在输出端对pwm波进行了处理。
我们知道，总电压和输出电压之比等于开关打开和整个周期的时间之比。那么，控制好开关输出的矩形波占空比就能得到等效的输出电压。
但是，实际电路输出电压不可能是矩形波，我们希望理想状态下是恒定的电压，则需要对矩形波进行处理。
考虑在电路工作一段时间后的完全响应（不考虑零状态响应的情况）
开关导通时的回路如下图所示
前一时刻的电路为开关断开，所以导通时，电路中的电流逐渐增大，此时Vin电源给电容和电感充电，RL输出的电压逐渐增大，二极管反向关断。此时，电感，电容将一部分电能转化为磁能储存起来。由于电感和电容在充电，电路中的电流增大的速度会降低。
开关断开时
电路右侧形成回路，此时为零输入状态，电路中的电流总体趋势为下降，由于电感的存在，会阻碍开关断开时电流的减小，并将电感中的能量释放出来。电容正极上方的电位也小于电容正极板电位，所以电容放电，也将电容的能量释放，阻碍电路中电流的减小。
通过开和关的两个回路，电容和电感将导通时的电压“拉低”，关断时的电压“升高”，将原本的矩形波变为如下图所示
高频率开关的一个时间周期内，电容电感的充放电的时间效应明显。当一个周期的平均输出电压小于理论电压时，电感电容充电时的电压大，储存的能量更多，输出时的电压则会提高，最后稳定在该占空比对应的理论电压左右。
开关频率很高时，电容电感维持在理论电压值左右，“来不及”充放电。所以输出电压较稳定，但是在理论上电路就会产生纹波，实际buck的电路，纹波确实会相对较大。
二、tps5430芯片介绍 1.芯片引脚图 2.芯片引脚说明 名字
引脚
功能概述
BOOT
1
升压电容的高侧FET栅极驱动器。与PH端连接0.01uF低ESR电容
NC
2,3
空闲端
VSENSE
4
反馈电压调节器。连接到输出电压的分压器。
ENA
5
开关控制。低于0.5V停止工作，一般悬空使能。
GND
6
接地端。连接到使用PowerPAD
VIN
7
输入电源电压。旁路到GND管脚VIN端子间用低ESR陶瓷电容器连接。
PH
8
高偏功率MOSFET的源级。连接到外部电感器和二极管。
PowerPAD
9
一般作为GND连接到外露焊盘
3.芯片重要参数 （1）输入电压范围：5.5V~36V
（2）输出电压范围：1.23V~31V
（3）最大输出电流：3A
（4）静态电流： 3mA
三、tps5430参考电路讲解以及PCB布局 1.正压降压（15V转12V） 1.1原理图 原理图参考下图，输入C3尽力靠近芯片输入端口VCC，EN悬空默认为芯片工作状态。C4的电容值必须为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca04ac88fb67d9da5031f58574da7c40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd713fcea71c0ee5048582a4c0927c53/" rel="bookmark">
			深入剖析ResNet152残差网络：代码解析与实战应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景简介
二、ResNet152残差网络应用实践
1、定义ResNet152模型
2、输入图像预处理
3、定义自定义数据集类
4、检测可用计算设备及定义优化器
5、模型训练
6、完整代码及结果展示
三、总结
一、背景简介 ResNet152是深度残差网络（Deep Residual Network）的一种，它是一个非常强大的图像分类模型。该网络由微软研究院提出，其核心思想是通过引入残差模块和瓶颈结构，使得模型可以在更深的层次上有效地学习图像特征，从而避免优化函数陷入局部最优解和梯度消失的问题。基本原理是通过引入残差模块和瓶颈结构，使得模型可以在更深的层次上有效地学习图像特征，从而避免优化函数陷入局部最优解和梯度消失的问题。
ResNet的设计思路是将输入特征通过一系列的卷积层、池化层等操作后，再将其与原始输入特征进行求和，这样就可以保留更多的原始信息，避免信息在多层网络中传递时被丢失。这种残差连接的设计使得网络在训练时可以跳过一些不必要的卷积操作，从而减少计算量和模型大小，同时提高模型的性能。
二、ResNet152残差网络应用实践 ResNet152残差网络在应用实践中表现出色，被广泛应用于各种计算机视觉任务中，如图像分类、目标检测、语义分割等，本次将以图像分类方面为案例进行实践操作演示。
1、定义ResNet152模型 resnet_model = models.resnet152(weights=models.ResNet152_Weights.DEFAULT) #创建ResNet152模型实例 for param in resnet_model.parameters():#冻结模型参数，只剩全连接层 param.requires_grad = False in_features = resnet_model.fc.in_features resnet_model.fc = nn.Linear(in_features,20) params_to_update = [] for param in resnet_model.parameters():#遍历ResNet152模型的所有参数 if param.requires_grad == True: params_to_update.append(param) 具体参数详解如下：
resnet_model = models.resnet152(weights=models.ResNet152_Weights.DEFAULT)：这行代码创建了一个ResNet152模型实例。models.resnet152是PyTorch中预定义的ResNet152模型函数。weights=models.ResNet152_Weights.DEFAULT指定了使用默认的预训练权重。for param in resnet_model.parameters(): param.requires_grad = False：这行代码将ResNet152模型中所有参数的requires_grad属性设置为False。这意味着在反向传播（backpropagation）时，这些参数不会更新。这通常用于冻结模型的某些部分，以防止在训练过程中改变其参数。in_features = resnet_model.fc.in_features：这行代码获取ResNet152模型的最后全连接层的输入特征数量。resnet_model.fc = nn.Linear(in_features,20)：这行代码将ResNet152模型的最后全连接层替换为一个新的全连接层，该全连接层的输入特征数量与原来的相同（in_features），输出特征数量为20。params_to_update = [] for param in resnet_model.parameters(): if param.requires_grad == True: params_to_update.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd713fcea71c0ee5048582a4c0927c53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a010eff9c2691e08ea6b3e7b6b0cca/" rel="bookmark">
			批量修改文件名方法合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景
二、window系统自带重命名
三、Everything工具
四、Bat脚本批量
一、背景 日常工作中，有时会遇到需要批量重名文件的场景，文件数目不多时可手动修改，当数目较多时，此时如果还一个个文件手动修改无疑效率低，耗时。下面将介绍批量修改文件名/文件夹名的方法
二、window系统自带重命名 以下图路径的文件和文件夹为例，名称和文件类型也多样，需要将其重命名为财富自由+序号，如“财富自由（1）”
使用ctrl+a选择所有的文件与文件夹
单击鼠标右键，弹出设置框，选择“重命名”
在鼠标箭头当前所在的文件名会出现如下选定重命名的状态，如下图名称为jk的文件夹。
输入“财富自由”，注意此时所有文件和文件夹都是处于选定状态
按Enter键后即完成自动命名，根据文件类型，名称后自动加上编号，如下图
三、Everything工具 使用everything工具也实现批量命名文件或文件夹，打开everything工具，进入“搜索-&gt;高级搜索”
搜索文件夹中设置为重命名文件所在的文件夹路径
点击“确定”，主界面展示路径下的文件和文件夹
ctra+a选定所有文件，文件夹，将鼠标箭头移动下图选定的蓝色背景位置，鼠标右键弹出重命名框
选择“重命名”，弹出重命名设置框，正则前面的框表示是否使用正则表达式进行替换，不勾表示不用正则表达式替换。
原始文件名显示修改前名字，取消勾选“正则”，在新文件名表达式中输入重命名的名称，如“财务自由”，点击“确定”，
点击“确定”，所有名称前都加上“财务自由”
也可勾选“正则”使用正则表达式筛选再进行替换，如将名称带有数字的替换为number，原始文件名表达式中输入正则表达式，\d+表示一个或多个数字，新文件名表达式输入替换的名称number，新文件名框中会自动显示替换后的名称，点击“确定”
替换前
替换后，所有的数字被number替换，无数字的名称不受影响，也可以单独替换部分内容。
四、Bat脚本批量 使用bat脚本相对前面两种方法是流程稍复杂一些
首先，ctrl+a选择目录下所有文件，一直按住shift键，再点击鼠标右键，弹出操作框，此时会有一个“复制为路径”的选项，点击该选项，
将路径复制到excel表格中
将路径替换掉只保留文件名，替换为中为空，选择“全部替换”
替换后只有文件名
将路径复制一列，添加第一列为ren，如下图所示，A列为命令名，B列为文件原始名，C列为文件修改名
在需修改文件名的目录下新建一个txt文件，将表格中的三列数据复制过去，注意，如果文件名中有中文时，先将编码格式设为"使用ANSI编码"，否则执行脚本会出现识别不了中文而报错
再将表格中的内容复制过去
重命名将rename.txt文件修改为rename.bat脚本
修改后
在路径窗口输入cmd打开命令窗口，按“Enter”键
弹出命令窗口
再将bat脚本选中后按住鼠标左键后拖入命令窗口，按Enter间执行脚本
执行结果记录如下
结果查看，改名后的文件和设置的一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9fdd4da2b9a9d342823b0d11a9cf16/" rel="bookmark">
			STM32的bootloader程序（通过串口更新STM32应用程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是bootloader？ Bootloader，也被称为引导加载程序，是操作系统启动过程中的一个重要组成部分。它是存储在非易失性存储器中的一段小程序，负责在操作系统内核运行之前加载并启动一些必要的系统组件。
当计算机开机后，BIOS（基本输入/输出系统）会首先运行，检查并初始化系统硬件，然后从设定的启动设备（如硬盘、U盘等）中找到Bootloader并把控制权交给它。Bootloader随后开始执行，它会加载操作系统内核到内存，并传递一些必要的系统参数。
2 为什么需要Bootloader？ Bootloader的任务很重要，因为它构成了硬件和操作系统之间的桥梁。如果没有Bootloader，操作系统就无法启动。Bootloader还通常包括一个用户接口，允许用户在多个操作系统中选择一个进行启动，或者修改操作系统的启动参数。
3 Bootloader实例 Bootloader的具体实现和功能可能根据操作系统和硬件的不同而有所差异。例如，Linux系统常见的Bootloader有GRUB和LILO，而Windows系统通常使用的是NTLDR或BootMGR。
说实话，从单片机角度来说，上述例子并不典型。这里举个最为典型的例子：ArduinoIDE为何能给Arduino开发板下载程序？就是因为开发板上搭载了Bootloader。当串口启动后，Arduino即进入复位，进入Bootloader程序，进行监听串口，接受串口下发的应用程序，将应用程序写入arduino芯片中。这样就可以不通过ISP，JTAG等方式，而是通过串口实现了芯片上程序的更新。
具体原理，笔者在之前的文章写过，可跳转：
Arduino是如何实现打开串口时，程序复位的？-CSDN博客
4 如何实现在STM32的bootloader程序？ 根据上面举的arduino的例子，我们来实现一个STM32版本的，通过串口更新程序的bootloader吧。
其运行原理大致可以归纳为以下几个步骤：
上电复位：首次给STM32供电或者按下复位键后，STM32会开始从预设的启动地址（一般是内部Flash的起始地址或者其他特定内存位置）开始运行程序。
启动阶段：在供电后的最初阶段，STM32的Bootloader会先被执行。Bootloader是一个预先在STM32内部ROM中烧录的小程序，其主要任务包括初始化硬件设备、设置系统时钟、配置内存等。
程序加载：Bootloader完成启动后，会开始加载用户程序。该程序通常存储在内部的Flash内存或者外部的存储设备中。程序被加载到SRAM中执行。如果用户程序存储在Flash中，Bootloader可以直接跳转到Flash的起始地址开始执行。
主循环：用户程序通常会包含一个主循环（main loop），在这个主循环中，程序会周期性地或者根据特定事件执行特定任务。例如，它可能会每隔一段时间读取一个传感器的数据，或者当接收到一个网络包时进行处理。
中断处理：在程序运行过程中，可能会发生各种中断，比如定时器到期、外部引脚状态变化、接收到串口数据等。当中断发生时，CPU会停止当前的任务，跳转到对应的中断服务程序进行处理，处理完毕后再返回到原来的任务继续执行。
4.1 keil编译后，HEX文件内容解读 要实现串口下载功能，就得先知道烧录程序HEX或者BIN文件究竟是个什么东西。关于HEX我以前也写过相关文章，可以跳转一下：
STM32的hex文件格式的分析-CSDN博客
关于BIN，目前还未过深的了解，印象中是二进制版本的HEX文件。
4.2 如何实现程序跳转 STM32的程序实际上就是从FLASH地址由上到下，根据指令内容，跳转到FLASH相应地址继续执行的而已。
因此，如果我们要实现从bootloader跳转到我们flash写入的地址，如何实现呢？这里给个bootloader跳转到用户程序的参考例子：
#define FLASH_SAVE_ADDR 0x08020000	//设置 FLASH 地址(必须为偶数，且其值要大于本代码所占用FLASH的大小+0X08000000) typedef void (*iapfun)(void);	//定义一个函数类型的参数. //设置栈顶地址 //addr:栈顶地址 __asm void MSR_MSP(uint32_t addr) { MSR MSP, r0 //set Main Stack value BX r14 }iapfun jump2app; //跳转到应用程序段 //appxaddr:用户代码起始地址. void iap_load_app(uint32_t appxaddr) { if(((*(__IO uint32_t*)appxaddr)&amp;0x2FFE0000)==0x20000000) //检查栈顶地址是否合法. { jump2app=(iapfun)*(__IO uint32_t*)(appxaddr+4);	//用户代码区第二个字为程序开始地址(复位地址)	MSR_MSP(*(__IO uint32_t*)appxaddr);	//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址) jump2app();	//跳转到APP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d9fdd4da2b9a9d342823b0d11a9cf16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db21f4c057d69ea1ca8a33ecef9476d/" rel="bookmark">
			C语言 每日一题 PTA 10.30 day8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.高空坠球 皮球从某给定高度自由落下，触地后反弹到原高度的一半，再落下，再反弹，……，如此反复。问皮球在第n次落地时，在空中一共经过多少距离？第n次反弹的高度是多少？
输入格式 :
输入在一行中给出两个非负整数，分别是皮球的初始高度和n，均在长整型范围内。
输出格式 :
在一行中顺序输出皮球第n次落地时在空中经过的距离、以及第n次反弹的高度，其间以一个空格分隔，保留一位小数。题目保证计算结果不超过双精度范围。
代码实现 #include &lt;stdio.h&gt; int main() { int n; int i;//i为循环变量 double a, h; scanf("%lf %d", &amp;h, &amp;n); a = 0; if (n == 0) { a = 0; h = 0; printf("%.1f %.1f\n", a, h); } else { for (i = 1; i &lt;= n; i++) { //由于知道循环次数，因此使用for循环 a = a + h; //加上落地距离 h = 0.5 * h; //计算反弹高度 a = a + h; //加上反弹高度 } a = a - h; //最后一次计算反弹高度后，多加了1个反弹高度，因此在输出前要在这里减去 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db21f4c057d69ea1ca8a33ecef9476d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151069daa3b602eeb1a009c39c78b97d/" rel="bookmark">
			【编程强化48】3rd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、以下能对二维数组a进行正确初始化的语句是（）
A. int ta[2][]={{0,1,2},{3,4,5}}; B. int ta[][3]={{0,1,2},{3,4,5}}; C. int ta[2][4]={{0,1,2},{3,4},{5}}; D. int ta[][3]={{0,,2},{},{3,4,5}}; 解析：
• 二维数组的初始化
行可以省略，列不可省略；最外面的“{}”代表行，内部的“{}”代表列。例如，对于“{{0,1,2},{3,4,5}}”，{0,1,2}和{3,4,5}代表了两行元素，其中0,1,2和3,4,5代表了三列元素；初始化每一行的时候，必须连续初始化。 本题选B。
2、设变量已正确定义，以下不能统计出一行中输入字符个数（不包含回车符）的程序段是
A. n=0;while(ch=getchar()!='\n')n++; B. n=0;while(getchar()!='\n')n++; C. for(n=0;getchar()!='\n';n++); D. n=0;for(ch=getchar();ch!='\n';n++); 解析：
• getchar()
从键盘的输入中获取单个字符
• for（ 初始化部分；条件判断；调整部分 ）
for循环的初始化部分（D项为ch=getchar()）只执行一次，getchar()无法再获取后续的字符，故无法统计输入字符的个数。
本题选D。
3、32位系统中，定义**a[3][4],则变量占用内存空间为()
A. 4 B. 48 C. 192 D. 12
解析：
• 操作符的优先级：[] &gt; *
• 任何类型的指针在32位系统下占4字节，在64位系统下占8字节
[]的优先级比*高，a先与[]结合为一个三行四列的数组。数组中存放的是一个“**”类型，即一个没有明确所指变量类型的二级指针类型，故a是一个指针数组。数组中一共有3x4=12个指针，在32位系统下，每个指针占4字节，故数组a总共占48个字节。
本题选B。
4、假设在一个 32 位 little endian（小端）的机器上运行下面的程序，结果是多少？
#include &lt;stdio.h&gt; int main(){ long long a = 1, b = 2, c = 3; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151069daa3b602eeb1a009c39c78b97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e881c3ee842796031323b78ad05192/" rel="bookmark">
			第12关：中缀表达式转化为后缀表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务描述 本关任务：输入一个中缀算术表达式，将其转换为后缀表达式。运算符包括+、-、*、/、(、)、=，参加运算的为小于10的自然数。（只考虑二元运算即可）
编程要求 输入 多组数据，每组数据一行，对应一个算术表达式，每个表达式均以“=”结尾。当表达式只有一个“=”时，输入结束。
输出 对于每组数据输出一行，为表达式的后缀式。
测试说明 平台会对你编写的代码进行测试：
测试输入： 9+(3-1)*3+1/2= 1+2= =
预期输出： 931-3*+12/+ 12+
代码 #include&lt;iostream&gt; using namespace std; #define MAXSIZE 100 #define OK 1 #define ERROR 0 #define OVERFLOW - 2 #define Status int typedef struct { char * base; char * top; int stacksize; } SqStack; Status InitStack(SqStack &amp; S) { //初始化栈 S.base = new char[MAXSIZE]; if (!S.base) return OVERFLOW; S.top = S.base; S.stacksize = MAXSIZE; return OK; } Status Push(SqStack &amp; S, char e) { //入栈 if (S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8e881c3ee842796031323b78ad05192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9222043cedaf49ce11ddbc1e56ce38/" rel="bookmark">
			【大数据基础平台】星环TDH社区开发版单机部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍁 博主 "开着拖拉机回家"带您 Go to New World.✨🍁 🦄 个人主页——🎐开着拖拉机回家_大数据运维-CSDN博客 🎐✨🍁
🪁🍁🪁🍁🪁🍁🪁🍁 🪁🍁🪁🍁🪁🍁🪁 🪁🍁🪁🍁🪁🍁🪁🍁🪁🍁🪁🍁
感谢点赞和关注 ，每天进步一点点！加油！
目录
🍁 博主 "开着拖拉机回家"带您 Go to New World.✨🍁
一、概述
二、安装TDH-CE-DEV
2.1 环境准备
2.2 安装TDH社区开发版
2.3 自助申请许可证
三、基本配置
3.1 开启安全
3.2 Hyperbase设置
3.3 安装TDH客户端
3.4 集群外使用hadoop client
3.4.1 使用zookeeper-client
3.4.2 使用hadoop/hdfs
3.4.3 使用hbase shell
一、概述 TDH企业级一站式大数据基础平台致力于帮助企业更全面、更便捷、更智能、更安全的加速数字化转型。通过数年时间的打磨创新，已帮助数千家行业客户利用大数据平台构建核心商业系统，加速商业创新。为了让大数据技术得到更广泛的使用与应用从而创造更高的价值，依托于TDH强大的技术底座，星环科技推出TDH社区版（Transwarp Data Hub Community Edition）版本，致力于为企业用户、高校师生、科研机构以及其他专业开发人员提供更轻量、更简单、更易用的数据分析开发环境，轻松应对各类人员数据分析需求。
社区版官网：TDH社区版-TDH Community Edition-星环科技
二、安装TDH-CE-DEV 2.1 环境准备 主机名和映射配置
cat /etc/hosts 192.168.2.117 devops hostnamectl set-hostname devops 关闭防火墙或者配置端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9222043cedaf49ce11ddbc1e56ce38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a0b3c4f758f925c3c9182a914c6081/" rel="bookmark">
			mybatis-plus正确使用姿势：依赖配置、Mapper扫描、多数据源、自动填充、逻辑删除。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 本文基于 springboot、maven、jdk1.8、mysql 开发，所以开始前我们需要准备好这套环境。
1.1 依赖准备 想要什么依赖版本的去 maven 仓库查看：https://mvnrepository.com/
引入 mybatis-plus 依赖：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; 引入 mysql 依赖：
&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; 目前，多数项目会有多数据源的要求，或者是主从部署的要求，所以我们还需要引入 mybatis-plus 关于多数据源的依赖：
&lt;!-- mybatis-plus 多数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; 1.2 配置准备 springboot 启动类。配置@MapperScan 注解，用于扫描 Mapper 文件位置:
import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient @MapperScan("com.wjbgn.user.mapper") @SpringBootApplication public class RobNecessitiesUserApplication { public static void main(String[] args) { SpringApplication.run(RobNecessitiesUserApplication.class, args); } } 数据源配置，此处配置一主一从的环境，当前我只有一台，所以此处配置一样的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a0b3c4f758f925c3c9182a914c6081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923cf3c79cf437f921063df224994f45/" rel="bookmark">
			Docker 服务端口一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近研究微服务，使用Docker来进行部署应用。说实话docker是个好东西，只要编写好Dockerfile文件和docker-compose.yml文件，便能快速启动并运行相关服务。
调试过程中查看服务可以使用
docker ps 然而调试项目的时候必须输入一堆的ip和端口来，让人有点不爽。
咱们发挥技术人的优势，能用程序搞定的绝不手工，找了一通，发现下面这个命令可以查看应用名称和端口的对应关系。
docker ps --format "{{.Names}} {{.Ports}}" 便想到通过调用shell脚本的方式来获取内容，传送到前端页面进行展示！
话不多说，下面上核心代码：
@Autowired HttpServletRequest request; @GetMapping({"", "/", "index"}) public String index(Model model) throws IOException { // 输出docker应用映射端口 String[] cmd = SystemUtils.IS_OS_WINDOWS ? new String[] {"cmd", "/C", "docker ps --format \"{{.Names}} {{.Ports}}\""} : new String[] {"/bin/sh", "-c", "docker ps --format \"{{.Names}} {{.Ports}}\""}; Process ps = Runtime.getRuntime().exec(cmd); BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream())); Map&lt;String, Set&lt;String&gt;&gt; map = new TreeMap&lt;&gt;(); String line; while ((line = br.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/923cf3c79cf437f921063df224994f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b32fdcb2ba9ff1e1be61f25e2dd655f/" rel="bookmark">
			【聚类笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文参考资料为：《交通时空大数据分析、挖掘与可视化（python版）》余庆，李玮峰编著，清华大学出版社
基于划分的聚类（K-means） 随机初始化k个样本，作为初始聚类中心；将每个样本分到距离最小的聚类中心所在类；计算新的聚类中心位置重新将样本划分到最小的聚类中心所在类计算新的聚类中心位置直到收敛 基于密度的聚类（DBSCAN） 直接密度可达：如图B在A的σ邻域内，则B是A关于σ和最小包含点数MinPts的“直接密度可达”密度可达：如果两个点不是“直接密度可达”，但可以通过多个“直接密度可达”的关系到达，则可称为“密度可达”，比如AC密度可达密度相连：如果两个点不是“密度可达”，但可以通过多个“密度可达”的关系到达，则可称为“密度相连”，比如ABC并集内的点都是密度相连K-means和DBSCAN对比
基于层次的聚类（Hierarchical） 通过某种相似性测度计算节点或类簇之间的相似性（或距离），并依据分裂或凝聚方式构建树状图，再根据实际需求横切树状图。
基于密度与基于层次的聚类（HDBSCAN） 但是上述方法都有缺陷：合适的参数很难确定
如果你定义eps太小，那么就会把所有样本点识别为噪声点
如果定义eps太大，那么无法达到分类效果
然后HDBSCAN就使用了层次树方式来决定，我应该采用哪个参数（扫描半径eps和最小包含点数MinPts）
HDBSCAN相当于运行了所有扫描半径（eps）情况下的DBSCAN
这是DBSCAN，eps=0.01，0.02，0.03
如果是高维的数据，你很难直接用眼睛去一个个试一个个判断。
但是可以通过建立不同类别数量的树，来判断，
在大量数据面前，树将很复杂，所以剪枝，剪哪些？剪去哪些小于MinPts的类别数量的枝条
在计算点与点之间的距离时，不是采用欧式距离，而是采用netrual reach ability distance
也就是两个点不仅要求邻近，而且还要在同一个高密度区
左图，由于红圆和绿圆半径都小于红点与绿点的距离，那么这个d就取两样本点间的距离，
右图，由于蓝圆的半径要小于蓝点与绿点的距离，则这个d取这三个值中的最大值，也就是绿圆半径。
DBSCAN 和 HDBSCAN 对比
import hdbscan clusterer = hdbscan.HDBSCAN(min_cluster_size=5, gen_min_span_tree=True) clusterer.fit(test_data) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242e15c8b238b3f7baf699357e7349b1/" rel="bookmark">
			记录Unity和C#遇到的坑(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UI图是完整的, 但导入Unity后UI图残缺了 把MeshType改成Full Rect
美术只给了左边一半UI, 用2张图在Unity里拼, 然后发现中间有缝 把 Filter Mode 改成 Point(no filter)
MeshType 也要改成 Full Rect
改特效的startLifetime 特效是沿直线发射粒子, 需求是用startLifetime控制特效的长度
这样, 长度不是瞬间达到目标长度, 而是会缓慢变化到目标长度 eff.main.startLifetime = 10 所以要将特效的时间前进1秒, 使其立即突变为目标长度 eff:Simulate(1) eff:Play() 关闭多点触控 Input.multiTouchEnabled = false; 关闭之后Input.touches[n]就不好用了
Editor扩展UI面板 [CustomEditor(typeof(Transform), true)] -- 行 [CustomEditor(typeof(Text), true)] -- 不行 解决方法:
自己写个脚本MyText继承Text, 然后再扩展
using UnityEditor; using UnityEngine; using UnityEngine.UI; [CustomEditor(typeof(MyText), true)] [CanEditMultipleObjects] public class AdaptiveTextEditor : UnityEditor.UI.TextEditor { Text txt; protected override void OnEnable() { base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242e15c8b238b3f7baf699357e7349b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84621efe4c684446013b25b61d62e3a/" rel="bookmark">
			vue3 &#43; elememt-plus 表单生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: vue3 + elememt-plus 表单生成器
date: 2023-10-27 16:12:57
categorys: [“技术”]
tags: [“前端”, “vue3”] 缘由 昨天写一个表单十几个二十个字段，写起来有点麻烦，中途还出现了改动，一大串一大串 el-form-item 看起来有点烦，就算是用循环写也差点意思， 刚好今天有闲余的时间，就写了个生成器，自动生成表单。
生成器使用 支持组件类型 // 暂时支持这些类型（全是element-plus的组件，我把前面的el给省略了） export type fieldType = | "input" | "number" | "select" | "textarea" | "date" | "time" | "datetime" | "cascader" | "tree-select" | "radio" | "checkbox"; 表单渲染 &lt;!-- 每个formColumns子项目支持两个插槽 --&gt; &lt;!-- slot=${prop} 完全替代form-item --&gt; &lt;!-- slot=${prop}Component 替代该form-item下的组件, label不变动 --&gt; &lt;FormGenerator ref="formGeneratorRef" :formColumns="formColumns" :model="form" :rules="rules" :property="property" &gt; &lt;template #nameComponent&gt; 这是个name &lt;/template&gt; &lt;template #number&gt; 数量组件取代 form-item &lt;/template&gt; &lt;/FormGenerator&gt; 表单绑定 // 绑定表单 const form = reactive({ name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c84621efe4c684446013b25b61d62e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ed633710f2bcc05f5fd11d1e68f2e6/" rel="bookmark">
			BEVFusion（北大&amp;阿里）环境搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BEVFusion环境搭建 论文题目：BEVFusion: A Simple and Robust LiDAR-Camera Fusion Framework
论文地址：https://arxiv.org/pdf/2205.13790.pdf
代码地址：ADLab-AutoDrive/BEVFusion: Offical PyTorch implementation of “BEVFusion: A Simple and Robust LiDAR-Camera Fusion Framework” (github.com)
前言：这是今年新发的一篇论文，我在第一次阅读时，代码还未开源，前几天发现开源了，而且这个框架做的很清晰，可以基于这个工作熟悉一下融合方案，也能稍稍改进一下。
笔者环境：
sys.platform: linux
Python: 3.8.3 | packaged by conda-forge | (default, Jun 1 2020, 17:43:00) [GCC 7.5.0]
CUDA available: True
GPU 0,1: NVIDIA GeForce RTX 3090
CUDA_HOME: /usr
NVCC: Build cuda_11.5.r11.5/compiler.30672275_0
GCC: gcc (Ubuntu 7.5.0-6ubuntu2) 7.5.0
PyTorch: 1.8.0+cu111
PyTorch compiling details: PyTorch built with:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ed633710f2bcc05f5fd11d1e68f2e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055d0adca977145b3d67e7e612b7ff5a/" rel="bookmark">
			Charles的安装及证书配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载及安装
1、下载地址：Download a Free Trial of Charles • Charles Web Debugging Proxy
下载完成后，直接点击安装即可 2、汉化补丁下载链接: https://pan.baidu.com/s/1lyOF7kOwIZXc2qe_KnlYQw 提取码: rr2n 打开汉化补丁 选择“中文破解版”，按下patch即可打开汉化补丁 选择“中文破解版”，按下patch即可
注：安装好charles后，要先进行汉化破解再打开，如果先打开了软件，在汉化的话就会无效，只能重新安装
二、证书配置
1、PC端证书安装
①帮助——SSL代理——安装Charles Root证书
②点击“安装证书”——“下一步”
③选择“将所有证书都放入下列存储”——“浏览”，选中“受信任的根证书颁发机构”，点击“确定”——“下一步”
④点击“完成”，提示“导入成功”
查看证书结果：帮助——SSL代理——安装Charles Root证书——证书路径——证书状态
2、移动端证书安装（以iOS为例）
①帮助——SSL代理——在移动设备或远程浏览器上安装Charles Root证书
②出现如下提示信息：
③在手机浏览器输入chl.pro/ssl下载证书，下载的证书文件，进入手机【设置】就能看到下载好的证书，点击即可安装完成
④手机，设置-&gt;通用-&gt;关于本机-&gt;证书信任设置，打开右边按钮，开启完全信任
⑤手机与电脑保证连接同一网络，点击下进入局域网设置
⑥HTTP代理，配置代理——选择“手动”，输入与电脑一致的IP及端口号，点击“存储”
⑦手机正确连接后，Charles会弹框，即连接成功。选择“Allow”
注：一台电脑对应一个手机终端，需要换电脑时，手机端的证书需要同步更新
三、常见问题
1、代理配置完成，导致手机WiFi无法访问网络
解决方案：控制面板-&gt;Windows Defender 防火墙-&gt;允许的应用，勾选“Charles Web Debugging Proxy”，保存后重启电脑
2、链接显示unknow
解决方案：代理——SSL代理设置——启用SSL代理——添加，主机添加*，端口添加443
3、如何删除手机端已配置的Charles证书
解决方案：设置-&gt;通用-&gt;VPN与设备管理，可以查看到想要删除的证书，点击相应的证书进入描述文件页，即显示“移除描述文件”操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce029322f0f3101f4059e89ae717644/" rel="bookmark">
			如何设置微信公众号网页授权域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在【设置与开发】-【公众号设置】-【功能设置】点击“网页授权域名”的“设置”，将MP-开头的文件下载下来，放在前端文件根目录中，以nginx转发前端页面为例
网页授权
文件放置完毕之后，填写备案域名，点击保存，完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566e441985a016ab805bbea27c3b4b3b/" rel="bookmark">
			ARM架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ARM体系结构 1、ARM相关的概念 1. 机器码：编译器将汇编指令编译生成具有特定功能的机器码(二进制数010101的集合)， 执行机器码可以完成某个特定的功能。 2. 汇编指令：执行汇编指令可以完成某个特定的功能(指令是硬件，加法运算器等，由三极管mos管组装而成)。 3. 汇编指令集：很多不同功能的汇编指令的集合。汇编指令的可移植性比较差 4. 架构：汇编指令集的版本的命名 ARM架构 X86-64架构 Mips架构 PowerPC架构 Risc-V架构 loongarch架构 ARM架构的版本： ARM-v1 ~ ARM-v6 : 目前已经淘汰 ARM-v7：32位的架构，支持32位的ARM指令集 ARM-v8：64位的架构，支持64位的ARM指令集，向下兼容ARM-v7架构 ARM-v9: 2021年发布的新的一代ARM架构，目前ARM高端处理器基本使用的都是 ARM-v9架构 5. ARM内核：ARM公司基于不同的ARM架构，设计出不同性能的ARM内核。 ARM内核的命名方式： Cortex-A53/A55/A72/A76/A78/A710/A510 : 主要用于高端处理器中 Cortex-x1/x2/x3 : 主要用于高端处理器中 Cortex-M0/M1/M3/M7 : 主要用于单片机中，低端的处理器 cortex-R系列：主要针对于对实时性要求比较高的场合 6. SOC : System On Chip:片上系统 一款处理器，在内核的基础之上，有添加了很多不同的外设资源， 这样的处理器可以统称为SOC. SOC : 片上系统， 可以是单片机，可以是高端处理器 CPU : 中央处理单元， 可以是单片机，可以是高端处理器 MCU : 微控制单元， 主要指的单片机 MPU : 微处理单元，主要指高端处理器 GPU : Graph Process Unit,图形处理单元 VPU : Video Processing Unit，视频处理单元 2、RISC和CISC的区别 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566e441985a016ab805bbea27c3b4b3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df6746ebec7f09afe2ac03d16474f49/" rel="bookmark">
			Python123：找出最小值、最大公约数和最小公倍数（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、找出最小值2、最大公约数和最小公倍数 1、找出最小值 题目：本题要求编写程序，找出给定一系列整数中的最小值。
输入格式：
输入在一行中首先给出一个正整数n，之后是n个整数，其间以空格分隔。
输出格式：
在一行中按照“min = 最小值”的格式输出n个整数中的最小值
输入样例：
4 -2 -123 100 0 输出样例：
min = -123 代码1：
#include&lt;stdio.h&gt; int main() { int n,a,min=0,i; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++){ scanf("%d",&amp;a); if(min&gt;a){ min=a; } } printf("min = %d",min); return 0; } 代码2：
#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { int i,n,min,temp; scanf("%d",&amp;n); scanf("%d",&amp;temp); min=temp; if (n==1) { printf("min = %d\n",min); } else { for (i=1;i&lt;=n-1;i++) { scanf("%d",&amp;temp); if (min&gt;temp) { min=temp; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df6746ebec7f09afe2ac03d16474f49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40b98d96e51ed1858c36af1361fb083/" rel="bookmark">
			Python123：打印一个高度为n的、由“*”组成、猴子吃桃问题（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、打印一个高度为n的、由“*”组成2、猴子吃桃问题 1、打印一个高度为n的、由“*”组成 题目：本题要求编写程序，打印一个高度为n的、由“*”组成的正菱形图案。
输入格式：
输入在一行中给出一个正的奇数n。
输出格式：
输出由n行星号“*”组成的菱形，如样例所示。每个星号后跟一个空格
输入样例：
7 输出样例：
* * * * * * * * * *	* * * * *	* * * * *	* * * * * 代码1：
#include&lt;stdio.h&gt; int main() { int i,j,n,k; scanf("%d",&amp;n); k=(n+1)/2; for(i=0;i&lt;k;i++){ for(j=1;j&lt;n-2*i;j+=2){ printf(" "); } for(j=0;j&lt;2*i;j++){ printf("* "); } printf("* \n"); } for(i=k;i&lt;n;i++){ for(j=1;j&lt;2*i+2-n;j+=2){ printf(" "); } for(j=0;j&lt;2*(n-i-1);j++){ if(i!=n-1){ printf("* "); } } printf("* \n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40b98d96e51ed1858c36af1361fb083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8cbf9525d5ab990d71d2cf2ac36a289/" rel="bookmark">
			Python123：高速公路超速罚款、出租车计价（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、高速公路超速罚款2、出租车计价 1、高速公路超速罚款 题目：按照规定，在高速公路上行使的机动车，达到或超出本车道限速的10%则处200元罚款；若达到或超出50%，就要吊销驾驶证。请编写程序根据车速和限速自动判别对该机动车的处理。
输入格式：
输入在一行中给出2个正整数，分别对应车速和限速，其间以空格分隔。
输出格式：
在一行中输出处理意见：若属于正常行驶，则输出“OK”；若应处罚款，则输出“Exceed x%. Ticket 200”；若应吊销驾驶证，则输出“Exceed x%. License Revoked”。其中x是超速的百分比，精确到整数。
输入样例1：
65 60 输出样例1：
OK 输入样例2：
110 100 输出样例2：
Exceed 10%. Ticket 200 输入样例3：
200 120 输出样例3：
Exceed 67%. License Revoked 代码1：
#include&lt;stdio.h&gt; int main() { float v,y; char a; a='%'; scanf("%f%f",&amp;v,&amp;y); if(v&lt;y+0.1*y){ printf("OK"); } else if(v&gt;y+0.5*y){ printf("Exceed %.0f%c. License Revoked\n",(v-y)*100/y,a); } else{ printf("Exceed %.0f%c. Ticket 200\n",(v-y)*100/y,a); } return 0; } 代码2：
#include &lt;stdio.h&gt; int main() { int a,b; double c; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8cbf9525d5ab990d71d2cf2ac36a289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23e21d796bf4cb60ccc347c15550273/" rel="bookmark">
			Python123：统计学生成绩、统计学生平均成绩与及格人数、成绩转换（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、统计学生成绩2、统计学生平均成绩与及格人数3、成绩转换 1、统计学生成绩 题目：本题要求编写程序读入N个学生的百分制成绩，统计五分制成绩的分布。百分制成绩到五分制成绩的转换规则：
大于等于90分为A；小于90且大于等于80为B；小于80且大于等于70为C；小于70且大于等于60为D；小于60为E。 输入格式：
输入在第一行中给出一个正整数N（≤1000），即学生人数；第二行中给出N个学生的百分制成绩，其间以空格分隔。
输出格式：
在一行中输出A、B、C、D、E对应的五分制成绩的人数分布，数字间以空格分隔，行末不得有多余空格。
输入样例：
7 77 54 92 73 60 65 69 输出样例：
1 0 2 3 1 代码1：
#include&lt;stdio.h&gt; int main() { int i,N,a=0,b=0,c=0,d=0,e=0; double x; scanf("%d\n",&amp;N); for(i=1;i&lt;=N;i++){ scanf("%lf",&amp;x); if(x&lt;60){ a=a+1; } else if(x&lt;70){ b=b+1; } else if(x&lt;80){ c=c+1; } else if(x&lt;90){ d=d+1; } else{ e=e+1; } } printf("%d %d %d %d %d",e,d,c,b,a); return 0; } 代码2：
#include&lt;stdio.h&gt; int main() { int i,n; int grade; int A=0,B=0,C=0,D=0,E=0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23e21d796bf4cb60ccc347c15550273/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f39ab9903fc0fa3a25a7557f547402/" rel="bookmark">
			微信小程序如何获取元素节点信息？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常在做微信小程序的时候我们经常会需要获取元素的信息，但是微信小程序有没有完整的“DOM”操作，无法像浏览器中获取元素。
不过在微信中也有一套自己的“DOM”，那就是NodesRef，它可以让我们像开发浏览器程序一样轻松愉快的获取页面元素
一、NodesRef 节点对象 1.1、NodesRef是什么？ NodesRef 用于获取 WXML 节点信息的对象
1.2、NodesRef具备的方法？ NodesRef.fields(Object fields) 获取节点的相关信息获取节点的相关信息NodesRef.boundingClientRect() 添加节点的布局位置的查询请求相对于显示区域，以像素为单位功能类似于 DOM 的 getBoundingClientRectNodesRef.scrollOffset() 添加节点的滚动位置查询请求以像素为单位节点必须是 scroll-view 或者 viewport 二、SelectorQuery 查询节点信息的对象 1.1、 创建SelectorQuery查询对象 let query = wx.createSelectorQuery() 1.2、SelectorQuery方法 SelectorQuery.in (对应的组件)
将选择器的选取范围更改为自定义组件 component 内初始时，选择器仅选取页面范围的节点，不会选取任何自定义组件中的节点 SelectorQuery.select(string selector)
在当前页面下选择第一个匹配选择器 selector 的节点 SelectorQuery.selectAll()
在当前页面下选择匹配选择器 selector 的所有节点。 SelectorQuery.selectViewport()
选择显示区域用于获取显示区域的尺寸、滚动位置等信息 SelectorQuery.exec(function callback)
执行所有的请求请求结果按请求次序构成数组，在callback的第一个参数中返回 三、获取某个元素节点信息 第一步、 创建SelectorQuery查询对象 let query = wx.createSelectorQuery() 第二步、 获取节点对象 方法一：query.select(queryString) 选择第一个匹配节点
方法二：query.selectAll(queryString) 选择所有匹配节点
queryString 类型 ID选择器：#the-idclass选择器（可以连续指定多个）：.a-class.another-class子元素选择器：.the-parent &gt; .the-child后代选择器：.the-ancestor .the-descendant跨自定义组件的后代选择器：.the-ancestor &gt;&gt;&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f39ab9903fc0fa3a25a7557f547402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89bc2d1d83dd37ff7cc993fd4a3fb2f0/" rel="bookmark">
			OA——菜单里无法找到流程监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在门户引擎里面做查看菜单的权限设置
编辑里面的可查看权限管理
把权限给到对应的人员或者部门就可以 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc3952433103236c5b1bcbf0aa94479/" rel="bookmark">
			Python123：高空坠球、换硬币、猜数字游戏（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、高空坠球2、换硬币3、猜数字游戏 1、高空坠球 题目：皮球从某给定height(米)高度自由落下，触地后反弹到原高度的一半，再落下，再反弹，……，如此反复。问皮球在第n次落地时，在空中一共经过多少距离？第n次反弹的高度是多少？
输入格式：
输入在一行中给出两个非负整数，分别是皮球的初始高度height和n，均在长整型范围内。
输出格式：
在一行中顺序输出皮球第n次落地时在空中经过的距离、以及第n次反弹的高度，其间以一个空格分隔，保留一位小数。题目保证计算结果不超过双精度范围。
输入样例：
33 5 输出样例：
94.9 1.0 代码1：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int n,a,h,i; double s=0,l; scanf("%d%d",&amp;h,&amp;n); s=s+h; for(i=0;i&lt;n-1;i++){ s=s+h*1.0/pow(2,i); } l=h*1.0/pow(2,n); printf("%.1f %.1f",s,l); return 0; } 代码2：
#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { long h,n,i; double sum=0; scanf("%ld%ld",&amp;h,&amp;n); if(n==0) { printf("%.1f %.1f\n",0.0,0.0); } else if (n==1) { printf("%.1f %.1f\n",1.0*h,h/2.0); } else { for (i=1;i&lt;=n;i++) { sum=sum+1.0/pow(2,i-1); } printf("%.1f %.1f\n",h*(2*sum-1),h/pow(2,i-1)); } return 0; } 2、换硬币 题目：将一笔零钱换成5分、2分和1分的硬币，要求每种硬币至少有一枚，有几种不同的换法？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc3952433103236c5b1bcbf0aa94479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92bfa66d456973e39709047c99758588/" rel="bookmark">
			设计模式之单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式 独生子女饿汉模式懒汉模式懒汉模式类的定义线程安全问题双重检查锁定的问题静态局部对象 创建一个任务队列 在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫单例模式。单例模式的典型应用就是任务队列。 独生子女 如果使用单例模式，首先要保证这个类的实例有且仅有一个，也就是说这个对象是独生子女，如果我们实施计划生育只生一个孩子，不需要也不能给再他增加兄弟姐妹。因此，就必须采取一系列的防护措施。对于类来说以上描述同样适用。涉及一个类多对象操作的函数有以下几个：
构造函数：创建一个新的对象拷贝构造函数：根据已有对象拷贝出一个新的对象拷贝赋值操作符重载函数：两个对象之间的赋值 为了把一个类可以实例化多个对象的路堵死，可以做如下处理：
构造函数私有化，在类内部只调用一次，这个是可控的。
由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是静态的，这样就可以通过类名来访问了，为了不破坏类的封装，我们都会把这个静态对象的访问权限设置为私有的。
在类中只有它的静态成员函数才能访问其静态成员变量，所以可以给这个单例类提供一个静态函数用于得到这个静态的单例对象。
拷贝构造函数私有化或者禁用（使用 = delete）
拷贝赋值操作符重载函数私有化或者禁用（从单例的语义上讲这个函数已经毫无意义，所以在类中不再提供这样一个函数，故将它也一并处理一下。）
由于单例模式就是给类创建一个唯一的实例对象，所以它的UML类图是很简单的：
因此，定义一个单例模式的类的示例代码如下：
// 定义一个单例模式的类 class Singleton { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 Singleton(const Singleton&amp; obj) = delete; Singleton&amp; operator=(const Singleton&amp; obj) = delete; static Singleton* getInstance(); private: Singleton() = default; static Singleton* m_obj; }; 在实现一个单例模式的类的时候，有两种处理模式：
饿汉模式懒汉模式 饿汉模式 饿汉模式就是在类加载的时候立刻进行实例化，这样就得到了一个唯一的可用对象。关于这个饿汉模式的类的定义如下:
// 饿汉模式 class TaskQueue { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 TaskQueue(const TaskQueue&amp; obj) = delete; TaskQueue&amp; operator=(const TaskQueue&amp; obj) = delete; static TaskQueue* getInstance() { return m_taskQ; } private: TaskQueue() = default; static TaskQueue* m_taskQ; }; // 静态成员初始化放到类外部处理 TaskQueue* TaskQueue::m_taskQ = new TaskQueue; int main() { TaskQueue* obj = TaskQueue::getInstance(); } 在第17行，定义这个单例类的时候，就把这个静态的单例对象创建出来了。当使用者通过getInstance()获取这个单例对象的时候，它已经被准备好了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92bfa66d456973e39709047c99758588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633344bed4c9e672d8e19e987726edcb/" rel="bookmark">
			【计算机网络】IP地址和子网掩码的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、IP地址
（1）IP地址分类
（2）IP地址构成
二、子网掩码
三、广播地址
四、子网容量相关
（1）子网数
（2）最大主机数
（2）可用主机数
总结
一、IP地址 了解IP地址扮演的角色有助于明白IP地址的含义乃至IP地址和子网掩码的关系
IP（Internet Protocol—网际互连协议），是TCP/IP体系中的网络层协议，它可以向传输层提供各种协议的信息，例如TCP、UDP等；对下可将IP信息包放到链路层。他最大的作用是网际互连，因此它是统一的国际标准，大家都按这一套来，网际中传输的额资源只有通过IP识别才能找到网关（局域网内部负责人），再通过网卡（MAC地址）进而定位到电脑。简单来说，IP就是位于网络层的一个通用的用来标识网络主机进行通讯的协议。
TCP/IP体系涵盖很广，包括应用层：Telnet、FTP、SMTP等，传输层：UDP、TCP，数据链路层：ARP、RARP，网络层：ICMP、IP、IGMP，每个协议都发挥着重要的作用。
（1）IP地址分类 IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”。
二进制表示 A类地址分配给规模特别大的网络使用，B类地址分配给一般的中型网络，C类地址分配给小型网络，如局域网，C类地址分配给小型网络，如局域网。
十进制表示及二进制IP地址特征 很多情况下IP地址会以十进制表示，但是大家也不要忘了他的二进制表现形式
（2）IP地址构成 IP地址 = 网络地址 + 主机地址
这儿的IP地址表现形式参考二进制，若从十进制表现形式（例1.0.0.0）来看，点隔开了每个字节（1字节8位），也就是说A类地址第一个字节是网络地址、后三个字节是主机地址。
比如一个C类IP地址：192.168.1.1，那么网络地址：192.168.1.0、主机地址：0.0.0.1
网络地址是子网中最小的地址，主机地址该网段中 主机的地址编号，大家把网络地址想象成街道地址，把主机地址想象成门牌号就容易理解了，两者结合的IP地址就是具体的家庭地址（电脑主机）。
二、子网掩码 子网掩码是一个32位的2进制数 ，它必须结合IP地址一起使用。
子网掩码只有一个作用，就是将某个IP地址划分成“网络地址”和“主机地址”两部分。
其实很多时候，你并不知道这个IP地址究竟是A类、B类还是C类地址，那么子网掩码的作用就出现了，子网掩码通过和IP地址的“与”运算，求出主机地址是多少。
位与（）即如果两个位进行比较两位同时为1，结果才为1，否则结果为0。👇
125 &amp; 7
二进制: 01111101 &amp; 00000111
位与比较: 0 1 1 1 1 1 0 1
---------------
0 0 0 0 0 1 1 1
| | | | | | | |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/633344bed4c9e672d8e19e987726edcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feee8ea06ee6eb487af72681275993bf/" rel="bookmark">
			Linux系统下安装RabbitMQ教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、下载安装RabbitMQ 1.1、下载Erlang并安装1.2、下载RabbitMQ并安装1.3、启动RabbitMQ 2、RabbitMQ管理界面以及授权操作 2.1、安装启动RabbitMQWeb管理界面2.2、添加远程用户 1、下载安装RabbitMQ 1.1、下载Erlang并安装 RabbitMQ是采用 Erlang语言开发的，所以系统环境必须提供 Erlang环境，需要是安装 Erlang。
Erlang和RabbitMQ版本对照：https://www.rabbitmq.com/which-erlang.html
这里安装3.8.14版本的RabbitMQ，对应的Erlang版本推荐23.x。我们下载erlang-23.2.7-2.el7.x86_64.rpm
下载地址：https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-23.2.7-2.el7.x86_64.rpm
然后将下载好的文件上传到服务器，创建一个文件夹用来存放文件
[root@zsr ~]# mkdir -p /usr/rabbitmq 再将刚才下载的 rpm 上传到文件夹中
然后切换到/usr/rabbitmq目录，解压安装erlang
# 解压 rpm -Uvh erlang-23.2.7-2.el7.x86_64.rpm # 安装 yum install -y erlang 如上安装成功
如果出现如上情况则（没有则跳过下一步）
rpm -Uvh erlang-23.2.7-2.el7.x86_64.rpm --force --nodeps 1.2、下载RabbitMQ并安装 下载地址：https://www.rabbitmq.com/download.html
选择对应的系统版本点击下载，下载后会得到.rpm文件
然后上传到 /usr/rabbitmq 目录中，并解压。
# 解压 rpm -Uvh rabbitmq-server-3.8.14-1.el7.noarch.rpm # 安装 yum install -y rabbitmq-server 1.3、启动RabbitMQ # 启动rabbitmq systemctl start rabbitmq-server # 查看rabbitmq状态 systemctl status rabbitmq-server 显示active则表示服务安装并启动成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feee8ea06ee6eb487af72681275993bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c38f5621c9d7e0b7682c7a189095b82/" rel="bookmark">
			使用inno setup生成桌面安装程序最新教程，常用功能及详解。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、下载inno setup
二、使用
1.依次点击file-New，然后点击下一步
2.设置应用程序信息（安装包信息）
3.应用程序文件夹
4.应用程序文件
5.然后依次点击下一步
6.设置安装语言
7.编译设置
8.继续点下一步
三、其他一些常用设置
1.卸载时删除指定文件夹
2.安装时创建文件夹
3.修改默认安装路径
4.安装时增加密码
前言 本文主要讲解inno setup如何生成一个安装包以及一些问题的解决方案，如安装时增加密码，修改默认安装路径，删除文件等。
一、下载inno setup 可前往Inno Setup Downloads (jrsoftware.org)下载安装。
二、使用 1.依次点击file-New，然后点击下一步 2.设置应用程序信息（安装包信息） 设置应用程序名称和版本号后点击下一步
3.应用程序文件夹 这里一般只用设置文件夹名称即可
4.应用程序文件 Add folder(添加文件夹) ：此处添加应用程序主执行文件依赖的文件夹，一般指应用程序主执行文件所在的文件夹。
5.然后依次点击下一步 这里设置应用程序的图标，点击下一步即可。
应用程序文档信息，一般空着就行。
6.设置安装语言 默认的是英文安装，简体中文安装是没有的需要自己去官网下载中文语言包，具体方法如下：
1，去inno setup官网找到translations，点击然后下拉找到简体中文语言包Chinese (Simplified)下载下来。
2，找到Inno Setup安装文件，进入Languages子文件夹，将语言包复制进去就行。
7.编译设置 8.继续点下一步 三、其他一些常用设置 1.卸载时删除指定文件夹 ExpandConstant('{userappdata}\路径)设置删除文件夹的路径,userappdata指计算机的%appdata%文件夹。
[Code]
procedure CurUninstallStepChanged (CurUninstallStep: TUninstallStep);
var mres : integer;
begin
case CurUninstallStep of usPostUninstall:
begin
mres := MsgBox('你要删除软件残留信息吗？删除后软件使用记录无法恢复。', mbConfirmation, MB_YESNO or MB_DEFBUTTON2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c38f5621c9d7e0b7682c7a189095b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1125944c111261a1a750f53d1f8d21/" rel="bookmark">
			【设计模式三原则】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式三原则 单一职责原则开放封闭原则依赖倒转原则里氏代换原则 我们在进行程序设计的时候，要尽可能地保证程序的可扩展性、可维护性和可读性，所以需要使用一些设计模式，这些设计模式都遵循了以下三个原则，下面来依次为大家介绍。 单一职责原则 C++面向对象三大特性之一的封装指的就是将单一事物抽象出来组合成一个类，所以我们在设计类的时候每个类中处理的是单一事物而不是某些事物的集合。
设计模式中所谓的单一职责原则，就是对一个类而言，应该仅有一个引起它变化的原因，其实就是将这个类所承担的职责单一化。
如果一个类承担的职责过多，就等于把这些职责耦合到了一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致设计变得脆弱，当变化发生时，设计会遭受到意想不到的破坏。
软件设计真正要做的事情就是，发现根据需求发现职责，并把这些职责进行分离，添加新的类，给当前类减负，越是这样项目才越容易维护。
开放封闭原则 开放 – 封闭原则说的是软件实体（类、模块、函数等）可以扩展，但是不可以修改。也就是说对于扩展是开放的，对于修改是封闭的。
该原则是程序设计的一种理想模式，在很多情况下无法做到完全的封闭。但是作为设计人员，应该能够对自己设计的模块在哪些位置产生何种变化了然于胸，因此需要在这些位置创建抽象类来隔离以后发生的这些同类变化（其实就是对多态的应用，创建新的子类并重写父类虚函数，用以更新处理动作）。
此处的抽象类，其实并不等价与C++中完全意义上是抽象类（需要有纯虚函数），这里所说的抽象类只需要包含虚函数（纯虚函或非纯虚函数）能够实现多态即可。
开放 – 封闭原则是面向对象设计的核心所在，这样可以给我们设计出的程序带来巨大的好处，使其可维护性、可扩展性、可复用性、灵活性更好。
依赖倒转原则 关于依赖倒转原则，对应的是两条非常抽象的描述：
高层模块不应该依赖低层模块，两个都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。 先用人话解释一下这两句话中的一些抽象概念：
高层模块：可以理解为上层应用，就是业务层的实现
低层模块：可以理解为底层接口，比如封装好的API、动态库等
抽象：指的就是抽象类或者接口，在C++中没有接口，只有抽象类
先举一个高层模块依赖低层模块的例子：
大聪明的项目组接了一个新项目，低层使用的是MySql的数据库接口，高层基于这套接口对数据库表进行了添删查改，实现了对业务层数据的处理。而后由于某些原因，要存储到数据库的数据量暴增，所以更换了Oracle数据库，由于低层的数据库接口变了，高层代码的数据库操作部分是直接调用了低层的接口，因此也需要进行对应的修改，无法实现对高层代码的直接复用，大聪明欲哭无泪。
通过上面的例子可以得知，当依赖的低层模块变了就会牵一发而动全身，如果这样设计项目架构，对于程序猿来说，其工作量无疑是很重的。
如果要搞明白这个案例的解决方案以及抽象和细节之间的依赖关系，需要先了解另一个原则 — 里氏代换原则。
里氏代换原则 所谓的里氏代换原则就是子类类型必须能够替换掉它们的父类类型。
这个原则的要满足的第一个条件就是继承，其次还要求子类继承的所有父类的属性和方法对于子类来说都是合理的。关于这个是否合理下面举个栗子：
比如，对于哺乳动物来说都是胎生，但是有一种特殊的存在就是鸭嘴兽，它虽然是哺乳动物，但是是卵生。
如果我们设计了两个类：哺乳动物类和鸭嘴兽类，此时能够让鸭嘴兽类继承哺乳动物类吗？答案肯定是否定的，因为如果我们这么做了，鸭嘴兽就继承了胎生属性，这个属性和它自身的情况是不匹配的。如果想要遵循里氏代换原则，我们就不能让这两个类有继承关系。
如果我们创建了其它 的胎生的哺乳动物类，那么它们是可以继承哺乳动物这个类的，在实际应用中就可以使用子类替换掉父类，同时功能也不会受到影响，父类实现了复用，子类也能在父类的基础上增加新的行为，这个就是里氏代换原则。
上面在讲依赖倒转原则的时候说过，抽象不应该依赖细节，细节应该依赖抽象。也就意味着我们应该对细节进行封装，在C++中就是将其放到一个抽象类中（C++中没有接口，不能像Java一样封装成接口），每个细节就相当于上面例子中的哺乳动物的一个特性，这样一来这个抽象的哺乳动物类就成了项目架构中高层和低层的桥梁，将二者整合到一起。
抽象类中提供的接口是固定不变的
低层模块是抽象类的子类，继承了抽象类的接口，并且可以重写这些接口的行为
高层模块想要实现某些功能，调用的是抽象类中的函数接口，并且是通过抽象类的父类指针引用其子类的实例对象（用子类类型替换父类类型），这样就实现了多态。
基于依赖倒转原则将项目的结构换成上图的这种模式之后，低层模块发生变化，对应高层模块是没有任何影响的，这样程序猿的工作量降低了，代码也更容易维护（说白了，依赖倒转原则就是对多态的典型应用）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6edf73e54bf68c3d07bb33ccc4ae28ce/" rel="bookmark">
			Android Ble蓝牙开发总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文出处 标题：Android Ble蓝牙开发总结
作者：Android_Gaomh
原文链接：Android Ble蓝牙开发总结_bluetoothgattcharacteristic property_notify-CSDN博客
前言 本文总结了ble的搜索，连接，读写操作。以及在开发过程中可能遇到的坑。
首先我们需要知道，什么是ble。 蓝牙发展至今经历了8个版本的更新。1.1、1.2、2.0、2.1、3.0、4.0、4.1、4.2。那么在1.x~3.0之间的我们称之为传统蓝牙，4.x开始的蓝牙我们称之为低功耗蓝牙也就是蓝牙ble。
蓝牙BLE相对于传统蓝牙的优点：最大化的待机时间、快速连接和低峰值的发送/接收功耗。应用区别：BLE低功耗蓝牙一般多用在蓝牙数据模块，拥有极低的运行和待机功耗，使用一粒纽扣电池可连续工作数年之久；BT经典蓝牙模块多用在蓝牙音频模块，音频需要大码流的数据传输更适合使用。
1、蓝牙BLE的发送和接受任务会以最快的速度完成，完成之后蓝牙BLE会暂停发射无线（但是还是会接受），等待下一次连接再激活;而传统蓝牙是持续保持连接。
2、广播信道（为保证网络不互相干扰而划分）仅有3个，而传统蓝牙是32个。
3、蓝牙低能耗技术“完成”一次连接(即扫描其它设备、建立链路、发送数据、认证和适当地结束)只需3ms。而标准蓝牙技术完成相同的连接周期需要数百毫秒。
4、蓝牙低能耗技术使用非常短的数据包，标准蓝牙技术使用的数据包长度较长。
ble的相关概念 Generic Attribute Profile (GATT) 通过BLE连接，读写属性类小数据的Profile通用规范。现在所有的BLE应用Profile都是基于GATT的。
Profile可以理解为一种规范，一个标准的通信协议，其存在于手机中，蓝牙组织规定了一些标准的profile:HID OVER GATT ,防丢器等，每个profile中包含了多个service。
Attribute Protocol (ATT) GATT是基于ATT Protocol的。ATT针对BLE设备做了专门的优化，具体就是在传输过程中使用尽量少的数据。每个属性都有一个唯一的UUID，属性将以characteristics and services的形式传输。
Service
可以理解为一个服务，这里要区分的是BluetoothServer，一个是服务，一个是服务器端。在BLE从机中有多个服务，电量信息，系统服务信息等，每一个service中包含了多个characteristic特征值，每一个具体的characteristic特征值才是BLE通信的主题。 Characteristic的集合。例如一个service叫做“Heart Rate Monitor”，它可能包含多个Characteristics，其中可能包含一个叫做“heart rate measurement”的Characteristic。
Characteristic Characteristic可以理解为一个数据类型，它包括一个value和0至多个对次value的描述（Descriptor）。通过操作Characteristic可以实现Ble的数据传输。
Descriptor 对Characteristic的描述，例如范围、计量单位等。
UUID（统一标识码） service和characteristic均需要这个唯一的UUID进行标识。UUID可以双方自定义，例如客户端访问服务器端的写characteristic，那么客户端就需要有服务器端定义的写characteristic UUID
这三部分都用UUID作为唯一标识符。UUID为这种格式：0000ffe1-0000-1000-8000-00805f9b34fb。比如有3个Service，那么就有三个不同的UUID与Service对应。这些UUID都写在硬件里，我们通过BLE提供的API可以读取到，同时也可以自定义Application层的UUID。
他们关系可以总结如下：一个BLE终端可以包含多个Service， 一个Service可以包含多个Characteristic，一个Characteristic包含一个value和多个Descriptor，一个Descriptor包含一个Value。
Characteristic是比较重要的，是手机与BLE终端交换数据的关键，读取设置数据等操作都是操作Characteristic的相关属性。
代码实现 1.权限设置 使用蓝牙必须先获取到相应的权限，因为需要使用BLE，所以Manifest中需要加入以下权限及说明，在6.0上面需要使用BLE蓝牙，我们还需要加上LOCATION权限
&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt; &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;uses-feature android:name="android.hardware.bluetooth_le" android:required="true" /&gt; 2.检查设备蓝牙状态 判断当前设备是否支持蓝牙，并且是否开启蓝牙，如果支持且没有打开则需要开启蓝牙，要是不支持蓝牙，那就不用继续看了，直接说做不了就行了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6edf73e54bf68c3d07bb33ccc4ae28ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53300aa58b5e1455d1b24c7d137c68b9/" rel="bookmark">
			物联网_基于无线传感网的智能空调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		左侧通过文字显示室内温湿度信息，右边为风扇的工作模式:分为人工模式和智能模式。
启动智能模式之后，当温度的实际值与设置的温度值（没有设置的时候默认为 23 度）相差大于 2 小于 10 的时候，风扇中速转动，当相差大于 10 的时候，风扇以快速转动。否则不转动。 启动人工模式之后，风扇打开，之后人工确定关闭，风扇关闭。 （由左边的空调图片可以查看风扇状态）
通过表格的形式显示各个端口的传感器的详细信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb68027e1741d23ea3f08422c3f14fb/" rel="bookmark">
			物联网_基于无线传感网的智慧农业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验结果： 1、程序运行结果
左侧通过文字和图片显示光照和结露信息，右边通过曲线（有上角的 temp 和 hum 用来选择显示曲线和数据显示温湿度。
2、传感器报警设置
结露和光照是默认打开报警，温湿度是通过上下按钮设置上下限，每修改一次数值都需要打开报警之后才为有效数据。
3、传感器信息的图表显示
通过表格的形式显示各个端口的传感器的详细信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3bea5922f003422b5ae51d95953d7a4/" rel="bookmark">
			物联网_RDID自动读卡实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验结果： 当检测到无卡放置时，串口返回EE CC FE 01 01 00 00 00 00 00 00 00 00 FF.
当检测到有卡放置时，串口返回EE CC FE 01 01 01 00 7B DA 08 E4 00 00 FF
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f6c8975a88915daaeefa3a06c8f940/" rel="bookmark">
			【vmware esxi】导入导出问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【vmware esxi】导入导出问题处理 操作步骤： 步骤1. 打开VMware Workstation，选择目标虚拟机，然后依次点击“虚拟机”&gt;“管理”&gt;“更改硬件兼 容性”。
步骤2. 选择硬件兼容性版本，然后单击“下一步”。
步骤3. 选择“创建此虚拟机的新克隆”或“更改此虚拟机”，然后单击“下一步”&gt;“完成”。
注意：如果选择创建克隆，则需要为此新虚拟机提供名称和位置。
步骤4. 返回Workstation主界面，选中目标虚拟机，点击左上角的“文件”&gt;“导出到OVF”。
步骤5. 指定一个目标路径，然后点击“保存”即可开始导出，等待导出完成之后，您将在目标路径找到 3个文件，其中.mf、.ovf文件提供虚拟机的完整规范，.vmdk则为虚拟机磁盘文件。
步骤6. 访问VMware ESXi Web 客户端，导航到“虚拟机”，然后单击“创建/注册虚拟机”以打开向导。
步骤7. 在选择创建类型选项卡上，选择“从OVF或OVA文件部署虚拟机”，然后单击“下一步”。
步骤8. 为新虚拟机设置名称（不超过80个字符），单击空白以指定导出的OVF/OVA文件，单击“下 一步”继续。
步骤9. 指定用于存储虚拟机文件的数据存储，单击“下一步”，接着设置网络映射、磁盘置备和是否自动打开电源，然后单击“下一步”，再单击“完成”即可成功导入虚拟机。
问题与解决： 【vmware esxi】行 25: 硬件系列“vmx-20”不受支持。
vmware fusion 导入虚拟机ovf文件，再导入到esxi 发生报错 "行 25: 硬件系列“vmx-20”不受支持。" 分析：导出ovf的虚拟机版本太高 方式一： 打开ovf后缀文件，把&lt;vssd:VirtualSystemType&gt;vmx-20&lt;/vssd:VirtualSystemType&gt;里的20改成17或其他支持的版本 打开mf后缀文件，删掉SHA1(.....)=.....，这段用于检测完整性。 方式二：当初导出ovf文件时，选择vmware workstation的菜单栏“虚拟机”——“管理”——更改硬件兼容性，改成兼容的版本 2. 出现“无法打开虚拟机 xxx 的电源。无法在当前状况 (已关闭电源) 下执行尝试的操作” 请等待下方读条完成，再操作虚拟机 3. esxi上载磁盘经常失败 需要在设置中将应用程序超时关闭，待上传完毕之后改回15分钟即可，亲测有效！！！（注：如果禁用会话超时可能会使您的 ESXi 主机易受恶意活动的攻击存在一定的风险）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d09ed7b2260cfce8f22c4839a2f1d9/" rel="bookmark">
			node问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在运行npm run dev 时，报错sh: vite: command not found
没有安装package.json中的依赖导致的
安装依赖 npm i ，npm run dev就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad732ca65c106ed6e16cad895fa390a/" rel="bookmark">
			windows下启动redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.进入redis所在文件夹，在地址栏输入cmd，然后按回车
E:\Redis-x64-3.2.100
2.redis-server.exe redis.windows.conf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b5ef4d8efc6892bf337a4eab3d54be/" rel="bookmark">
			Mybatis创建逆向工程的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加依赖和插件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- MyBatis核心依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 控制Maven在构建过程中相关配置 --&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;!-- 插件的依赖 --&gt; &lt;dependencies&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0b5ef4d8efc6892bf337a4eab3d54be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6649460365c93345660ac7d18f8689c7/" rel="bookmark">
			Mybatis特殊SQL的执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 模糊查询批量删除动态设置表名添加功能获取自增的主键自定义映射resultMapresultMap处理字段和属性的映射关系 多对一映射处理级联方式处理映射关系使用association处理映射关系 分步查询1. 查询员工信息 2. 查询部门信息 一对多映射处理collection 模糊查询 /** * 根据用户名进行模糊查询 * @param username * @return User */ List&lt;User&gt; getUserByLike(@Param("username") String username); &lt;!--List&lt;User&gt; getUserByLike(@Param("username") String username);--&gt; &lt;select id="getUserByLike" resultType="User"&gt; &lt;!--select * from t_user where username like '%${mohu}%'--&gt; &lt;!--select * from t_user where username like concat('%',#{mohu},'%')--&gt; select * from t_user where username like "%"#{mohu}"%" &lt;/select&gt; 其中select * from t_user where username like "%"#{mohu}"%"是最常用的
批量删除 只能使用${}，如果使用#{}，则解析后的sql语句为delete from t_user where id in ('1,2,3')，这样是将1,2,3看做是一个整体，只有id为1,2,3的数据会被删除。正确的语句应该是delete from t_user where id in (1,2,3)，或者delete from t_user where id in ('1','2','3')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6649460365c93345660ac7d18f8689c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e87cf5928ec7e6a13a78a13e34f192be/" rel="bookmark">
			Linux安装部署zabbix运维监控平台，实操，步骤明晰&#43;常见问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux安装部署zabbix运维监控平台，实操，步骤明晰+常见问题解决方案
工作中，如果服务器多且需要对服务器进行24小时不间断的监控，保证业务的正常运行，那么就需要一款高效的监控管理工具，那么zabbix运维监控平台必不可少。
首先准备lnmp环境和相关安装包文件zabbix-5.0.0.tar.gz。
1、关闭防火墙和selinux。　systemctl stop firewalld systemctl disable firewalld setenforce 0 # 设置临时关闭selinux　sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config #设置永久关闭selinux reboot #重启 2、为zabbix新建用户和组（可以不用）
groupadd --system zabbix useradd --system -g zabbix -d /usr/lib/zabbix -s /sbin/nologin -c "Zabbix Monitoring System" zabbix 为zabbix家目录修改权限
2、安装依赖
yum -y install gcc gcc-c++ mysql-devel libdbi-dbd-mysql net-snmp-devel curl-devel net-snmp libcurl-devel libxml2-devel libevent-devel 3、编译
./configure --prefix=/usr/local/zabbix --enable-server --enable-agent --with-mysql=/usr/local/mysql/bin/mysql_config --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2 4、安装
make install
5、进入数据库配置 zabbix 数据库和用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e87cf5928ec7e6a13a78a13e34f192be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22e1d6695773fe5684b24e02b36edcb/" rel="bookmark">
			RPC与HTTP的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首选理清楚关系 RPC与HTTP是两个不同维度的东西
HTTP 协议（Hyper Text Transfer Protocol），又叫做超文本传输协议，是一种传输协议，平时通过浏览器浏览网页网页，用到的就是 HTTP 协议。
而 RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。
RPC这种调用方式，主要有两部分组成
传输协议序列化方式 传输协议有多种，比如HTTP协议、自研协议等。
序列化方式有很多种，比如二进制流，JSON，XML等
所以HTTP协议只是RPC中传输协议中的一种
如果传输协议与序列化方式选择HTTP与JSON，只要封装的好，也能实现这个远程调用，也能称之为RPC。
只不过早期的RPC因为传输效率的原因，大多没有选择HTTP与JSON，而是自研协议与二进制传输。
网上区分RPC与HTTP的文章太多了，我也没必要重复，所以我提供一种新的角度，就是根据历史的发展进行解释。
历史发展 早期互联网，大多是C/S架构，并且不需要对外开发API，仅自己内部调用（中国互联网对外开放事件：3Q大战），并且大家的带宽还很低，此时的HTTP协议还是1.0（1.0传输效率低，具体为什么，后面会讲）。
基于以上背景，当时需要一种高效率的传输方式，并且不需要考虑兼容性。
所以在传输协议的选择上，基于TCP的自研协议的RPC就应运而生了。
也是因为上述相同的历史背景，所以当时传输信息的序列化方式不是现在流行的JSON或者XML，而是二进制流，因为体积更小，传输效率更高。
内部系统 但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；
其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。
RPC额外优势 一般RPC框架，不仅仅有传输功能，还添加了很多其他功能，比如服务发现、负载均衡、链路追踪、限流降级等等。比如这里的Dubbo
为什么不直接使用TCP协议？ 这里就不赘述，简单说TCP协议有自身的问题，比如粘包问题等，直接使用会有问题，所以都是基于TCP的自研协议。
RPC 协议 https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/
HTTP协议为什么效率低？ 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。
HTTP请求报文 这里可以看出，HTTP协议为了传输内容，前后增加了很多“冗余”的字段，当然这里的“冗余”是为了通用性与兼容性，毕竟HTTP协议要兼容大多数不同的浏览器与不同的设备。
但是如果不需要考虑兼容性，只针对具体的设备，那就是真冗余了
为什么现在用了HTTP协议？ 现在很多是直接使用HTTP协议，并且现在很多RPC框架也是使用的HTTP协议，原因如下
因为HTTP也一直在升级，也优化了性能网友的带宽也在提升，对性能要求没这么高了兼容性，之前接口仅需支持单个设备，现在需要支持多设备了，而HTTP的兼容性是最好的，几乎所有设备都会支持成本问题：自研也需要开发成本，还要考虑兼容性。 基于以上原因，如果对性能没有极致要求，没必要自研协议，直接使用HTTP协议
总结 而 RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式，只要能够实现这种调用方式都可以称为RPC
实现RPC有两个核心点，传输协议与序列化方式，而HTTP只是传输协议中的一种。
参考 RPC 协议 https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/
既然有 HTTP 协议，为什么还要有 RPC？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de71a8e9f005250713cfd875dbfbd72f/" rel="bookmark">
			ZYNQ连载06-EasyLogger日志组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZYNQ连载06-EasyLogger日志组件 1. EasyLogger介绍 Easylogger仓库
2. EasyLogger移植 EasyLogger移植比较简单，在Vitis中移植时主要注意路径问题，然后适配下接口即可：
void elog_port_output(const char *log, size_t size) { printf("%.*s", size, log); } elog_cfg.h、elog.h、elog_port.c、elog_utils.c elgo.c从仓库获取。
my_elog.h、my_elog.c为自定义文件。
/* my_elog.c */ #include "include/my_elog.h" void my_elog_init(void) { elog_init(); elog_set_fmt(ELOG_LVL_ASSERT, ELOG_FMT_TAG | ELOG_FMT_LINE | ELOG_FMT_DIR | ELOG_FMT_FUNC | ELOG_FMT_TIME); elog_set_fmt(ELOG_LVL_ERROR, ELOG_FMT_TAG | ELOG_FMT_LINE | ELOG_FMT_DIR | ELOG_FMT_FUNC | ELOG_FMT_TIME); elog_set_fmt(ELOG_LVL_WARN, ELOG_FMT_TAG | ELOG_FMT_LINE | ELOG_FMT_DIR | ELOG_FMT_FUNC | ELOG_FMT_TIME); elog_set_fmt(ELOG_LVL_INFO, ELOG_FMT_TAG | ELOG_FMT_LINE | ELOG_FMT_DIR | ELOG_FMT_FUNC | ELOG_FMT_TIME); elog_set_fmt(ELOG_LVL_DEBUG, ELOG_FMT_TAG | ELOG_FMT_LINE | ELOG_FMT_DIR | ELOG_FMT_FUNC | ELOG_FMT_TIME); elog_set_fmt(ELOG_LVL_VERBOSE, ELOG_FMT_TAG | ELOG_FMT_LINE | ELOG_FMT_DIR | ELOG_FMT_FUNC | ELOG_FMT_TIME); elog_set_text_color_enabled(true); elog_start(); } /* main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de71a8e9f005250713cfd875dbfbd72f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a8533e3fd5912e56552852ec1de304/" rel="bookmark">
			插值法（二次插值法和三次插值法算法分析以及python代码解释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习了之前几期一维搜索算法后，今天我们来分析两种最新的算法，分别是两点三次插值法和两点插值法。之前的几种算法，在整个搜索过程中只对函数值进行了比较，在删除“坏”的区间时，已经计算出的函数值并没有得到充分的利用。今天介绍的两种方法是利用低次多项式P（x）在搜索区间上逼近目标函数，然而用近似多项式P（x）的极小点作为新区间的分割点的方法。近似多项式P（x）取二次多项式，则得二次插值法；取三次多项式，则得三次插值法。
二次插值法： 算法分析: 基本思想：在极小点附近，用二次三项式P（x）逼近目标函数,P（x）与在三点有相同的函数值，并假设：
令 ,
又令 记 ,,
,,
则可得：
令,将P(x)的驻点x记作,则
这样，把作为的极小点的一个估计，再从中选择目标函数值最小的点，以及其左右两点，给予相应的下标，代入上式，求出极小点的新的估计值，以此类推，产生点列{}，满足或者，终止迭代。
例题分析： 下面我们通过例题来进一步探讨：
例题：用二次插值法求函数的极小点，迭代三次给定.
解：由已知三个点，可求出（-1.2，-4.1472），（-1.1，-4.8037），（-0.8，-4.4032）
由迭代公式：
,,
,,
迭代次数第一次x-1.2-1.1-0.8-0.984f-4.147-4.804-4.403-4.996第二次x-1.1-0.984-0.8-0.990f-4.804-4.996-4.403-4.998第三次x-1.1-0.990-0.984-1.008f-4.804-4.998-4.996-4.999 那么我们看这个迭代结果，不难发现，求出的极小点是x=-1的近似值，并不是问题的全局最优解（x=2），由此，我们可以确定二次插值法对于初始点的要求较高，有时求出的并不是全局最优解，而是局部最优解。
算法代码： ''' 二次插值算法(抛物线法） 2023.10.9 ''' def fun(x): return x ** 2 + 2 * x - 10 def run(x1, x2, x3): B1 = (x2 * x2 - x3 * x3) * fun(x1) B2 = (x3 * x3 - x1 * x1) * fun(x2) B3 = (x1 * x1 - x2 * x2) * fun(x3) C1 = (x2 - x3) * fun(x1) C2 = (x3 - x1) * fun(x2) C3 = (x1 - x2) * fun(x3) D = (x1 - x2) * (x2 - x3) * (x3 - x1) if (B1 + B2 + B3) == 0: x0 = 0 else: x0 = (B1 + B2 + B3) / (2 * (C1 + C2 + C3)) Arr = [x0, x1, x2, x3] Arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80a8533e3fd5912e56552852ec1de304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cb712860b4ef1230b1acb0ae77aa1ab/" rel="bookmark">
			一篇文章让你数组入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组的基本概念 首先，我们需要了解什么事数组，数组是一组相同元素的集合
这里面有两个关键点：1.数组里面可以存放一个或多个数据，但所存放的数据不能为0
2.数组里面存放的数据，类型是相同的。
数组分为一维数组和多维数组，常见的多维数组是二维数组。
一维数组的创建和初始化 数组的创建 一维数组创建的常用语法如下
type arr_name[常量值];
type表示数据的类型，可以是int float char double，也可以是自定义类型
arr_name指的是数组名的名字，可以根据自己的需要，取得有意义就好
【】的常量值是用来指定数组的大小的，这个数组的大小根据实际的需要指定就行。
比如，我们想现在存储一个班20个人的数学成绩，我们可以创建一个数组
1.int math[20];
当然，我们也可以根据需要来创建其他类型和大小的数组
1. char ch[8];
2.double arr[20]; 数组的初始化 有时候，我们在创建数组的时候，需要根据需要对数组提供一些初始的值，这就叫做数组的初始化。
那数组应该怎么初始化呢，我们可以看下面的代码块
//完全初始化：
int ch[8] = { 1,2,3,4,5,6,7,8 };
//不完全初始化,只提供了一个1，默认其他的七个值为0
int ch[8] = { 1 };
//错误的初始化,超过了所能容纳的值，程序会报错
int ch[1] = { 4,5,6 };
数组的类型 数组也是有类型的，且大多数都是自定义类型，去掉组名后其余的部分就是数组的类型，例如：
int arr1[3];
int arr2[4];
int arr3[4]; arr1 的类型是int [3];
arr2 的类型是int [4];
arr3 的类型是int [4];
一维数组的使用 上面我们讲述了一维数组的基本语法，一维数组可以存放数据，存放的数据的目的是为了方便对数据的操作，下面我们讲一些它的使用。
数组下标 C语言规定数组中的元素是有下标的，下标就类似于数组元素的编号，数组下标是从0开始，要是假设有n个数据，则最后一个数据的下标是n-1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cb712860b4ef1230b1acb0ae77aa1ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c64e0f0127332f90d8ae8fb49944e9b6/" rel="bookmark">
			mac 安装homebrew ,golang
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mac 安装homebrew ,golang 安装homebrew安装golang选择 apple arm 版本安装配置环境变量 安装homebrew /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 回车执行指令后，根据提示操作。具体包括以下提示操作：
选择下载镜像。一般选择中科大或者清华确认删除旧版本输入开机密码安装git【如果没安装会提示你，点击安装即可】再次执行 /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 验证是否安装成功
输入 brew -v 安装golang 安装包下载地址为：https://go.dev/dl/。
如果打不开可以使用这个地址：https://golang.google.cn/dl/。
选择 apple arm 版本安装 下载完点击安装，会默认安装到 /usr/local/go
配置环境变量 vim ~/.bash_profile export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin export GOPATH=$HOME/go export GOPROXY=https://goproxy.cn 刷新环境
source ~/.zshrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82950accab3b156c9a1275a7dd0f2465/" rel="bookmark">
			eNSP动态路由之ospf配置(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、目标
二、关键命令
三、拓扑
四、完整流程
1.根据拓扑图配置设备ip
【AR1】
【AR2】
【PC1】
【PC2】
2.配置ospf
区域规划
【AR1】
【AR2】
3.验证
验证路由器中是否存在路由表
【AR1】
【AR2】
连通性测试
总结
前言 上一篇文章我们了解了动态路由中的rip那么本篇文章我们就来看看动态路由中的ospf，ospf的优势有无路由自环、路由变化收敛速度快、支持区域划分等优势因此它更加适用于大规模网络中。
一、目标 PC ping通 pC2
二、关键命令 # 设置ospf进程号可以写ospf 1或者直接ospf，如果直接写ospf它默认还是1，以下面演示为前者 ospf 进程号 #eg ospf 1 # 进入ospf区域 area 区域名 #eg area 0 # 宣告area区域网段 network 网段 + 反子网掩码 #eg network 10.0.0.0 0.0.0.255 三、拓扑 四、完整流程 1.根据拓扑图配置设备ip 【AR1】 # 进入系统视图 &lt;AR1&gt;system-view # 进入各个接口根据拓扑图配置ip [AR1]interface g0/0/0 [AR1-GigabitEthernet0/0/0]ip address 10.0.0.1 24 [AR1-GigabitEthernet0/0/0]interface g0/0/1 [AR1-GigabitEthernet0/0/1]ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82950accab3b156c9a1275a7dd0f2465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b08fc249378a821349d6759e9c59d7f7/" rel="bookmark">
			【Android】Gradle 切换 国内源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上现在很多都不知道是哪个版本的Android studio 的配置。
要去 Settings.gradle 里边修改。
pluginManagement { repositories { maven { url 'https://plugins.gradle.org/m2/' } maven { url 'https://maven.aliyun.com/nexus/content/repositories/google' } maven { url 'https://maven.aliyun.com/nexus/content/groups/public' } maven { url 'https://maven.aliyun.com/nexus/content/repositories/jcenter'} gradlePluginPortal() google() mavenCentral() } } dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { maven { url 'https://plugins.gradle.org/m2/' } maven { url 'https://maven.aliyun.com/nexus/content/repositories/google' } maven { url 'https://maven.aliyun.com/nexus/content/groups/public' } maven { url 'https://maven.aliyun.com/nexus/content/repositories/jcenter'} google() mavenCentral() } } 2023年10月29日 修改
上边的方法好像有问题 只需要设置代理就型
在 File-&gt;Setting-&gt;SystemSettings-&gt;HttpProxy 找到： Auto detect proxy setttings 打对钩 输入 https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b08fc249378a821349d6759e9c59d7f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b289aa6adb007bb7302ffac952f3490/" rel="bookmark">
			Java中File类的构造方法、常用成员方法和简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 java.io.File类File类对象的创建File类常用成员方法判断相关方法获取相关方法修改相关方法遍历方法 File类的简单应用计算文件夹的大小删除非空文件夹 参考资料 java.io.File类 Java语言有专门的File类用来管理磁盘文件和文件夹。
每个File类的对象表示一个磁盘文件或文件夹，其对象属性中包含了文件或文件夹的相关信息，如名称、长度、所含文件个数等，调用它的方法则可以完成对文件或文件夹的常用管理操作，如创建、删除等。
利用File类可以创建、删除文件或文件夹以及获取文件或文件夹的属性，但是File类没有包含读写文件内容的方法，因而用来无法来读取一个文件中存储的数据。
File类对象的创建 构造方法说明File(String pathname)根据文件路径字符串创建File对象File(String parent, String child)根据父路径名字符串和子路径名字符串创建File对象File(File parent, String child)根据父路径File对象和子路径名字符串创建File对象 File对象可以定位文件和文件夹，它封装的只是一个路径名，这个路径可以存在也可以不存在。
构造方法里的文件路径可以是绝对路径也可以是相对路径，绝对路径是从盘符根文件夹开始一直到某个具体的文件或文件夹，相对路径是相对于当前项目的。
File file1=new File("E:\\Java Program"); File file2=new File("E:\\Java Program","Test"); File file3=new File(file1,"Test"); File类常用成员方法 判断相关方法 方法说明boolean exists()判断文件/文件夹是否存在boolean isDirectory判断是否是文件夹boolean isFile判断是否是文件boolean isAbsolute()判断封装的是否是绝对路径 获取相关方法 方法说明String getPath()返回文件/文件夹定义时的路径String getAbsolutePath()返回文件/文件夹的绝对路径String getName()返回文件/文件夹的名称，文件会带后缀名long length()返回文件大小，字节表示（不能返回文件夹大小）long lastModified()返回文件/文件夹的最后修改时间，时间毫秒值表示 //可通过创建Date对象返回最后修改时间 System.out.println(file1.lastModified()); System.out.println(new Date(file1.lastModified())); /*输出结果 1697870718439 Sat Oct 21 14:45:18 CST 2023 */ 修改相关方法 方法说明boolean createNewFile()创建一个新的空的文件boolean mkdirs()创建多级文件夹boolean delete()删除路径对应的文件/空文件夹（不进入回收站） 遍历方法 方法说明File[] listFiles()获取当前文件夹下的所有一级文件对象，返回File对象数组 当调用的File表示的路径不存在、表示的是文件、或者是需要权限才能访问的文件夹时，返回null。
当调用的File表示的路径是一个空文件夹时，返回一个长度为0的数组。
File类的简单应用 计算文件夹的大小 public static long getDirLength(File f){ long lengthAll=0; File[] files=f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b289aa6adb007bb7302ffac952f3490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba15dbf5f00b712a16a315f425876277/" rel="bookmark">
			【教3妹学编程-java实战5】结构体字段赋值的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插： 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
坚持不懈，越努力越幸运，大家一起学习鸭~~~
2哥 :3妹，考考你，你知道java结构体字段的赋值都有哪些方式吗？
3妹：神马？结构体赋值不是在代码中随处可见的嘛，直接set不就行了嘛， 还有很多种方式？
2哥 :没错，直接set就其中一种，不过如果字段比较多的话，一个个set也比较麻烦， 代码行数也比较多，影响阅读啊。
3妹 :代码行数比较多怎么啦，放在30年前，程序员可是按照代码行数算工资的， 代码行数多还能拿更多的钱呢，哈哈哈。
2哥 :时代在进步嘛，作为一个有追求的程序媛，你还知道其他set字段的黑科技吗？让我们来学习一下吧~
用例 首先，假设有一个结构体Person，用于后面的事例演示。 为简化篇幅，只有2个字段，实际应用中结构体的字段可能会比较多，也一样适用。
@Data public class Person { /** * 姓名 */ private String name; /** * 年龄 */ private Integer age; } 方法一：直接set 这个没什么好说的， 最基础的用法
Person person = new Person(); person.setName("张三"); person.setAge(18); 方法二：构造函数 在结构中手写带参数的构造函数，也可以用lombok的@AllArgsConstructor注解
@AllArgsConstructor @Data public class Person { /** * 姓名 */ private String name; /** * 年龄 */ private Integer age; } 赋值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba15dbf5f00b712a16a315f425876277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527bb4708c3bf2c47f877dbb8854eab0/" rel="bookmark">
			基于微信小程序地图组件实现行车轨迹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序是一款能够开发出各种功能的便捷工具，其中内置的地图组件，为我们提供了强大的地图展示和交互的能力，为我们的开发节约了不少时间和精力。同时，利用微信小程序内置的定时器，我们也能够简单地实现经纬度轨迹移动的效果。
在这个程序中，我们需要用到地图组件的polyline和marker属性。先来了解一下它们的作用：
polyline：用于在地图上展示一条折线，可以设置线条样式、颜色、粗细、折线点等属性。marker：用于在地图上创建标记点，可以设置标记点的经纬度、图标、标签等属性。 接下来我们就可以开始介绍这个程序的实现过程了。
首先，我们需要在wxml文件中引入map组件，并设置相应的属性：
&lt;map id="map" longitude="{{longitude}}" latitude="{{latitude}}" markers="{{markers}}" polyline="{{polyline}}" style="width: 100%; height: 100%;"&gt;&lt;/map&gt; 其中，longitude和latitude分别表示地图中心所在的经纬度，markers和polyline则是我们需要在地图上展示的标记点和折线的属性。
接下来，我们需要在js文件中定义相应的数据：
data: { longitude: 0, latitude: 0, markers: [], polyline: [] } 在这里，我们将地图中心的经纬度、标记点和折线数据都定义为空。
然后，我们需要在onLoad生命周期函数中获取当前用户的位置信息，并将地图中心设置为当前位置：
onLoad: function () { wx.getLocation({ type: 'gcj02', success: res =&gt; { this.setData({ longitude: res.longitude, latitude: res.latitude }) } }) } 在获取到用户位置的经纬度后，我们将其设置为地图的中心点。
接下来，我们需要通过定时器，实现经纬度轨迹移动的效果。我们可以在onShow生命周期函数中设置一个定时器，每隔一段时间更新一次标记点和折线的经纬度数据：
onShow: function () { let index = 0; let timer = setInterval(() =&gt; { if (index &lt; points.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/527bb4708c3bf2c47f877dbb8854eab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf5ef177f59a6181bfbb9f28ce9b19f/" rel="bookmark">
			IMYAI-人工智能聊天绘画机器人4.0 - 终身学习者的超级生产力工具！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是ChatGPT？ChatGPT能帮我干什么？
在开始之前，我们首先需要知道ChatGPT是什么。
ChatGPT 全名Chat Generative Pre-trained Transformer (聊天生成性预训练转换模型)
说简单点，ChatGPT就是一个AI聊天机器人，背后是一个十分庞大的语言模型，由国外的OpenAI公司通过基于8000亿个单词的语料库（或45TB的文本数据）训练出来的，于2022年11月30日发布（2023年初正式爆火），包含了1750亿个参数。8000亿是ChatGPT的训练数据，1750亿是它从这些训练数据中所学习、沉淀下来的内容。ChatGPT 最大的特点是能够像人一样聊天，回答你提出的各种问题，并根据海量数据中搜索以及掌握的知识为你提供信息和建议，完成你指定的所有任务，一个妈见打以及老师看了都要落泪的网站！而且它的答案不是说从哪里搬过来的，而是自己通过深度学习自己原创生成的，简直就是论文、写作、办公、编程、学习以及搜索神器！更多资料→点这里（拓展资料：什么是AI？什么是AIGC？认识AIGC）
在哪里可以使用ChatGPT？什么是ILoveChatGPT（IMYAI）？
ChatGPT官网无法直接访问，所以为了方便广大粉丝特别是学生群体，能够无需额外工具即可使用ChatGPT这款AI工具，耗时几乎一两周的研究以及搭建，2023年5月15日，由图欧学习资源库站长、图欧学习资源导航站站长、学习资源船舱船长、B站UP主图欧君出品的ChatGPT国内可访问版ILoveChatGPT（又名：IMYAI）正式上线！无需魔法即可访问，接口与官方一样！可放心使用！而且承诺永久有效！不会像国内某些站点用着用着充了钱还突然跑路之类的，毕竟自己搭建的网站，自己用着才放心哈哈哈。
请尽量用谷歌或者Edge浏览器打开以下网站入口，运行更稳定，体验感更佳！
IMYAI网站实时更新地址
IMYAI网站永久发布页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473da557a50b4e4f71c5402ce3ae3b0d/" rel="bookmark">
			SpringBoot&#43;Vue在线课程管理系统(源码&#43;论文&#43;开题报告)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍅文末获取源码联系🍅
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
千份开题报告和答辩PPT下载
一、采用技术： 后端：Java+SpringBoot
前端：Vue
数据库：MySQL
开发软件：Eclipse、MyEclipse、IDEA都可以运行
二、系统功能： 本文首先介绍了在线课程管理系统的现状及开发背景，然后论述了系统的设计目标、系统需求、总体设计方案以及系统的详细设计和实现，最后对在线课程管理系统进行了系统检测并提出了还需要改进的问题。本系统能够实现教师管理，科目管理，教学计划管理，学生管理，课程管理，课程留言管理，课程收藏管理，通知公告管理等功能[1]。在设计方面，本系统采用B/S三层结构，采用MVC模式，这种模式通过Vue技术来表现页面的动态设计，从系统的安全性和代码的可重用性方面考虑，运用SpringBoot对程序的关键代码进行封装，后台数据库选用MySQL数据库。经过设计开发测试，基本满足了用户的相关需求，较好实现了在线课程管理系统相关的功能和模块。
三、运行截图： 四、关键代码： /** * 用户账户：用于保存用户登录信息(User)表控制层 */ @Slf4j @RestController @RequestMapping("user") public class UserController extends BaseController&lt;User, UserService&gt; { /** * 服务对象 */ @Autowired public UserController(UserService service) { setService(service); } /** * Token服务 */ @Autowired private AccessTokenService tokenService; @Autowired private UserGroupService userGroupService; /** * 注册 * @param user * @return */ @PostMapping("register") public Map&lt;String, Object&gt; signUp(@RequestBody User user) { // 查询用户 Map&lt;String, String&gt; query = new HashMap&lt;&gt;(); query.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473da557a50b4e4f71c5402ce3ae3b0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0cccd9cbba4834b13d556d087fc0044/" rel="bookmark">
			MySQL总结 （思维导图，常用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常见的增删改查 二、约束（五种） 三、聚合查询 1、聚合函数 2、group by 和 having 3、联合查询 案例表：
drop table if exists classes; create table classes ( id int primary key auto_increment, name varchar(20) ); insert into classes (name) values ('计算机1班'), ('自动化2班'), ('机械3班'); drop table if exists student; create table student ( id int primary key auto_increment, name varchar(10), classes_id int, foreign key (classes_id) references classes(id) ); insert into student (name,classes_id) values ('小花',2), ('小张',1), ('小贺',1), ('小方',3), ('小乔',3); drop table if exists course; create table course ( id int primary key auto_increment, name varchar(20) ); insert into course (name) values ('java程序设计'), ('大学英语'), ('高等数学'), ('数据结构'), ('工程制图'); drop table if exists score; create table score ( id int primary key auto_increment, score decimal(3,1), student_id int, course_id int, foreign key (student_id) references student(id), foreign key (course_id) references course(id) ); insert into score (score,student_id,course_id) values -- 小花 (98.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0cccd9cbba4834b13d556d087fc0044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29208f5bfb2bf4996e80758e5aeb7db3/" rel="bookmark">
			使用 BCC 开发 eBPF 程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 BCC 开发 eBPF 程序，可以把前面讲到的五步简化为下面的三步。
第一步：使用 C 开发一个 eBPF 程序
新建一个 hello.c 文件，并输入下面的内容：
int hello_world(void *ctx)
{
bpf_trace_printk("Hello, World!");
return 0;
}
第二步：使用 Python 和 BCC 库开发一个用户态程序
接下来，创建一个 hello.py 文件，并输入下面的内容：
#!/usr/bin/env python3
# 1) import bcc library
from bcc import BPF
# 2) load BPF program
b = BPF(src_file="hello.c")
# 3) attach kprobe
b.attach_kprobe(event="do_sys_openat2", fn_name="hello_world")
# 4) read and print /sys/kernel/debug/tracing/trace_pipe
b.trace_print()
第三步：执行 eBPF 程序
sudo python3 hello.py
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/535edeef850f264a60ea4c81d7ecef6d/" rel="bookmark">
			c语言项目实践-猜数字大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		掌握了我之前说的那些代码知识，接下来，我们就可以写一些基本的小游戏，例如-猜数字的游戏。
游戏要求：
1. 电脑⾃动⽣成1~100的随机数
2. 玩家猜数字，猜数字的过程中，根据猜测数据的⼤⼩给出⼤了或⼩了的反馈，直到猜对，游戏结束
随机数的生成 想要完成猜数字的游戏，首先我们要生成1-100的随机数，那。该怎么生成嘞
rand函数 在C语言中，有一个专门生成随机数的语句-rand语句，它的格式如下：
int rand （void）; rand会生成一个伪随机数，这个伪随机数的值在0~RAND_MAX之间，这个RAND_MAX是依据编译器来实现的，大多数编译器的这个值都是32767
rand使用的时候有一个头文件stdlib.h
那接下来我们展示一下rand函数的功能
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
printf("%d\n", rand());
printf("%d\n", rand());
printf("%d\n", rand());
printf("%d\n", rand());
printf("%d\n", rand());
printf("%d\n", rand());
return 0;
} 结果如下 你会发现，每次循环的结果都是如上图所示，是一样的，这是为什么呢
这就是我们说的rand函数生成的是一个伪随机数，为什么叫伪随机数呢，因为他是基于一个叫种子
的基准值用算法计算生成的，之所以前面的每个数都一样，就是因为rand()中默认种子为1，而想要产生变化的值，就要让种子也产生相应的变化。
srand函数 srand函数在C语言当中是初始化随机数的生成器的，它的格式如下：
void srand( unsigned int seed);
我们在调用sand函数之前，要先调用srand函数来生成种子的随机值，当种子在变化的时候，那么生成的随机数的值也就会发生相应的变化。
time函数 在C语言我们常用程序运行的时间来作为种子，因为程序运行的时间是时刻在发生变化的。
在C语言中有一个函数叫time，就可以获得这个时间，time函数的具体格式如下：
time_t time (time_t *timer); time函数会返回当前的日历时间，实际返回的是1970年1月1日0分0秒到现在的时间差，单位是秒，返回的类型是time_t类型的，而time_t实际上是32位或64位的整数类型。
time函数的参数timer如果是非指针NULL的话，函数会将时间差这个值放到timer指向的内存中带回去。
timer如果是NULL的指针的话，就只返回这个时间的差值，time函数返回的这个时间差也叫：时间戳
如果只让time函数返回时间戳，我们可以这样写。
time（NULL）；//调用time函数返回时间戳，这里没有接收值 那么，我们就可以将生成随机数的代码改写成：
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
int main()
{
srand((unsigned int)time(NULL));//使用time函数的返回值接收种子，srand的接收类型是unsigned int，所以对time用强制类型转换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/535edeef850f264a60ea4c81d7ecef6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863f423521ef47cfa0f8bd00e4c84b0c/" rel="bookmark">
			【人脸识别】基于matlab GUI LBP人脸识别【含Matlab源码 1282期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、LBP简介 LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。它是首先由T. Ojala, M.Pietikäinen, 和D. Harwood 在1994年提出，用于纹理特征提取。而且，提取的特征是图像的局部的纹理特征；
1 LBP特征的描述
原始的LBP算子定义为在33的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，33邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。如下图所示：
LBP的改进版本：
原始的LBP提出后，研究人员不断对其提出了各种改进和优化。
（1）圆形LBP算子：
基本的 LBP 算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala 等对 LBP 算子进行了改进，将 3×3 邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子；
（2）LBP旋转不变模式
从 LBP 的定义可以看出，LBP 算子是灰度不变的，但却不是旋转不变的。图像的旋转就会得到不同的 LBP值。
Maenpaa等人又将 LBP 算子进行了扩展，提出了具有旋转不变性的 LBP 算子，即不断旋转圆形邻域得到一系列初始定义的 LBP 值，取其最小值作为该邻域的 LBP 值。
图 2.5 给出了求取旋转不变的 LBP 的过程示意图，图中算子下方的数字表示该算子对应的 LBP 值，图中所示的 8 种 LBP模式，经过旋转不变的处理，最终得到的具有旋转不变性的 LBP 值为 15。也就是说，图中的 8 种 LBP 模式对应的旋转不变的 LBP 模式都是00001111。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863f423521ef47cfa0f8bd00e4c84b0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212457b0c895f2d458dcc1c29951b4ad/" rel="bookmark">
			从瀑布模式到水母模式：ChatGPT如何赋能软件研发全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀欢迎来到本文🚀
🍉个人简介：陈童学哦，目前学习C/C++、算法、Python、Java等方向，一个正在慢慢前行的普通人。
🏀系列专栏：陈童学的日记
💡其他专栏：C++STL，感兴趣的小伙伴可以看看。
🎁希望各位→点赞👍 + 收藏⭐️ + 留言📝 ​
⛱️万物从心起，心动则万物动🏄‍♂️
ChatGPT如何赋能软件研发全流程 前言内容简介作者简介专家推荐读者对象目录直播预告 前言 计算机技术的发展和互联网的普及，使信息处理和传输变得更加高效，极大地改变了金融、商业、教育、娱乐等领域的运作方式。数据分析、人工智能和云计算等新兴技术，也在不断地影响和改变着各个行业。
如今，我们正在见证人工智能技术的突破性发展。以OpenAI的ChatGPT为代表的人工智能技术，使我们有机会站在人类知识总和的巅峰上完成工作。ChatGPT的强大文本生成能力，使我们能够在软件开发过程中迅速提高需求分析、方案设计和代码生成的效率。因此，我们需要从ChatGPT的新角度，重新审视软件开发过程中的需求分析、架构设计、代码实现、软件测试、系统运维和项目管理的理论与实践，认真思考如何运用人工智能的新技术创新工作方式和优化产业格局。
《ChatGPT 驱动软件开发：AI 在软件研发全流程中的革新与实践》 陈斌 著 IT领军者陈斌新作 详解ChatGPT在软件研发全流程的应用 大幅提升研发效率 塑造工程师AI时代竞争优势 本书全面、深入地介绍了使用ChatGPT进行软件产品需求分析、架构设计、技术栈选择、高层设计、数据库设计、UI/UX 设计、后端应用开发、Web前端开发、软件测试、系统运维、技术管理等的方法与经验，目标是帮助产品经理、架构师、数据库管理员、UI/UX设计师、程序员、测试工程师、运维工程师和项目经理更深入地理解ChatGPT的实际应用和潜力，并为他们提供实用的操作建议。
通过阅读本书，读者能够掌握ChatGPT在软件产品需求分析、架构设计、代码实现、系统优化、软件测试和团队协作等方面的核心概念和方法。这将有助于软件开发企业和个人在人工智能时代迅速利用这一强大工具武装自己，实现价值创新并形成竞争优势，为未来发展奠定坚实的基础。
内容简介 这是一本讲解以ChatGPT/GPT-4为代表的大模型如何为软件研发全生命周期赋能的实战性著作。它以软件研发全生命周期为主线，详细讲解了ChatGPT/GPT-4在软件产品的需求分析、架构设计、技术栈选择、高层设计、数据库设计、UI/UX 设计、后端应用开发、Web 前端开发、软件测试、系统运维、技术管理等各个环节的应用场景和方法，让读者深刻地感受到ChatGPT/GPT-4在革新传统软件工程的方式和方法的同时，还带来了研发效率和研发质量的大幅度提升。
更为重要的是，本书能帮助架构师、开发工程师、数据库工程师、测试工程师、运维工程师、项目经理、产品经理、UI/UX工程师和技术管理者深入地理解ChatGPT/GPT-4的原理和应用，全面塑造他们在AI时代的核心竞争力，实现价值创新并形成竞争优势，为未来的发展奠定基础。
作者在本书中创新性地提出了大模型时代的软件研发新范式——水母开发模式（顶部大、底部小）。该模式将研发活动分成6个层次，分别对应软件研发生命周期的分析、设计、编码、测试、部署和维护。其中分析和设计层的工作量大很多，类似水母的头部；其余4个层次的工作量较少，类似水母的触手。
除此之外，本书还给出了工程师们与ChatGPT互动（Prompt）的步骤和注意事项，整个过程分为6步，只要遵循这6步就能比较容易地获得较为满意的输出结果。
作者简介 陈　斌 资深技术专家，IT技术领域的领军人物，有超过30年的支付、软件研发、技术架构、系统运维、技术管理经验。对人工智能技术及其应用有深入研究，对大模型在软件工程中的应用有丰富的实践经验。现任职日本华人支付创业企业NetStars的CTO，曾担任易宝支付的CTO、ebay/PayPal的高级架构师、Nokia美国的首席工程师。
CTO领袖联盟的联席主席和中国互联网技术百人会的理事长。从传统的大型计算机核心技术，到互联网技术应用，再到大数据、云计算、生物特征识别和金融科技，他都有非常丰富的实践经验。努力推动互联网技术与传统产业的结合，曾经多次参加“互联网大篷车”活动，足迹遍及中国大江南北的传统企业。
经常在中国、美国和日本的互联网行业论坛分享知识和经验，也在多所中国和日本的知名大学里教授互联网支付、金融科技和互联网技术管理等课程。著有畅销书《一本书读懂支付》，翻译并出版了《架构即未来》《架构真经》《数据即未来》等多部经典著作。
专家推荐 ChatGPT的横空出世，是大数据和人工智能发展到一定阶段的必然产物。陈斌先生的这部著作出版非常及时，他结合自己在软件开发和技术管理方面的丰富经验，针对如何在软件开发的需求分析、架构设计、代码生成、系统优化、测试等各环节应用ChatGPT给出了建议，对于软件工程师和产品经理等各类IT人员都很有帮助，值得一读。
—— 刘震　日本工程院外籍院士/长崎综合科学大学教授/博士生导师
本书详细探讨了ChatGPT在软件开发过程中的应用，为AI和软件开发的结合提供了一条新途径。这本书不仅理论深入，讲解了ChatGPT的工作原理，而且实践性强，包含大量案例，充满启示与智慧，将AI在软件开发领域的可能性面面俱到。对于任何对AI和软件开发感兴趣的人来说，这都是一本必读之书。
—— 李刚　NETSTARS创始人兼董事长
AI技术的突破为包括软件研发在内的各行各业带来了新的发展机遇。如何充分利用以ChatGPT为代表的AI新技术来革新软件开发的新模式和新方法，成为软件行业的一个重要课题。作者通过总结和分析在软件开发中使用ChatGPT的经验与教训，为软件开发探索了一条新路。如果你有兴趣使用ChatGPT来提升软件开发的效率，那么本书就是一本不可或缺的指南。
—— 张云泉　中国科学院计算技术研究所研究员/博士生导师/全国政协委员/九三中央科技委副主任
软件行业一直致力于为人类提供高效的自动化工具。然而，颇具讽刺的是，这个充满创新力的领域却仍然大量依赖人力，是一个脑力劳动密集型行业，时间长、效率低、成本高是众多软件项目的顽疾。幸运地是，ChatGPT的问世带来了前所未有的改变，软件开发的效率将获得极大的提升，甚至可能重塑整个行业的风貌。如果你是一位软件行业从业者，渴望借助ChatGPT引领软件行业变革，那么这本书无疑将为你提供宝贵的指导，成为你的得力助手。
—— 向江旭　澳门产业技术研究院执行院长/境成资本管理合伙人
多年来，工程师们一直在不断优化软件开发工具来提高软件的工程化效率，GPT大模型正是优化软件工程效率的一把利器。陈斌先生对AI技术的理解与丰富的软件工程经验，必将极大地促进AI技术在软件开发领域中的应用。本书将晦涩难懂的技术通俗地表达出来，并配有大量的案例，不仅是一场GPT大模型的实践之旅，更是对软件开发过程理解的升华。
—— 赵国光　中信云网首席技术官
读者对象 对ChatGPT感兴趣并希望在实际项目中应用这一先进技术的研究人员和开发工程师。本书将通过实际应用案例深入解析ChatGPT在软件开发方面的应用，帮助读者快速掌握利用ChatGPT助力软件开发的技能。
希望运用ChatGPT为产品创新和用户体验带来价值的产品经理和设计师。本书将提供如何将ChatGPT与产品设计相结合的方法和实践案例。
需要管理和指导具有ChatGPT相关技术背景的技术团队的领导者。他们将从本书中学到如何更有效地组织和协调团队资源，以及如何进行技术规划和战略部署。
负责企业或项目的系统运维和管理工作的专业人员。他们将在本书中了解到如何维护和优化基于ChatGPT的系统，以确保其高效、稳定地运行。
从事人工智能教育的教师、讲师及相关专业的学生。他们可以通过阅读本书系统地学习和了解ChatGPT及其在实际项目中的应用，为教学和学术研究提供参考。
对人工智能和ChatGPT有浓厚兴趣的普通读者。他们可以从本书中获取对ChatGPT的发展历程、应用领域以及未来前景的全面认识，丰富自己的知识体系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/212457b0c895f2d458dcc1c29951b4ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1cd5ed8694a278a4efde971d7761d3/" rel="bookmark">
			【人脸识别】基于matlab GUI BP神经网络双人脸识别（含识别率）【含Matlab源码 2383期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、BP神经网络简介 1 BP神经网络概述
1.1 BP神经网络的内涵
BP神经网络是神经网络的一种经典结构，其结构简单、训练简单，是学习神经网络的一种输入算法，包含一个特定的模型(神经网络)和一个特定的训练算法[1，2，3]。神经网络被描述为多层神经元的叠加。外部输入首先通过连接传递给一组神经元。训练后，一些神经元之间的连接权值会很低，这意味着这些神经元之间的通信强度很低。通常使用“层”来表示一组神经元，最后一层神经元的输出是一维向量，可以代表分类任务中的特定类别。
1.2 BP神经网络原理
制造机器和机器控制是BP神经网络应用的最终目标。神经元在接收和处理信号后，会将结果传递给邻近的特定神经元，并建立一个神经网络来执行特定的任务：
layer_i=(layer_Ⅰ_1， layer_Ⅰ_2， …， layer_I_j， …， layer_I_K__) 。
layer_I-1层的神经元接收并处理信号后， 将信号传输到layer_I层的每个神经元。layer-i中的每个神经元都被接收并处理以产生新的信号。人工神经元实际上是一个逻辑回归模型， 其能输入线性组合并与SIGMOD函数映射， 以获得像“概率”的值。将x_2中最大的元素赋予值1，而其他元素被赋予值0，获得类标签。
1.3 BP神经网络技术在人脸识别中的应用
BP神经算法的核心是通过网络的误差函数计算出一个极小值，确定函数的权重分布，让神经网络的收敛处于一个相对平衡的状态，这样在网络接收到未知输入的时候，可以通过适当的输出来维持网络的稳定。BP神经元应用到人脸识别中，需要经过以下流程：第一，需要在人脸识别的样本特征中求出协方差矩阵，得出协方差矩阵的特征值，并计算出相应的特征向量，选取较大的特征根，定下特征向量，将第一步求出的特征向量与原始数据计算出一个乘积；第二，得到训练样本的主成分后，进入输入层进行训练，截取未知人脸的样本数据，与特征向量相乘进行分类识别，就能得到未知人脸的类别。
2 人脸识别技术
人脸识别算法利用卷积神经网络对大量的人脸图像进行深度学习，利用输入图像区分不同人脸的特征向量。在人脸识别算法中，每个人脸都被赋予了一组对应的特征值，机器从同一人的不同照片中提取特征值，并设定一个阈值，将其作为判断是否通过的标准。
人脸识别的应用场景很多。例如，对于智能相册的照片分类，其技术原理是将图像存储在与图像像素点阵相对应的数字矩阵中， 每个像素用一个数值的RGB表示， 无论它出现在图像中的什么位置， 它在数值分布上都会表现出一定的特征， 将所有与人脸识别相关的问题转化为基于数值矩阵的分类或回归问题。采用机器学习的方法定位人脸特征点，能够为每幅图像标记相应的特征点。人脸识别过程有4个关键步骤，即人脸检测、人脸对齐、人脸编码和人脸匹配。
(1)人脸检测。人脸检测的目的是找出人脸在图像中的位置。当在一张图片中发现一个人脸时，不管是什么样的人脸信息， 机器都会标记出人脸的坐标信息， 或者将人脸切割， 用HOG检测出人脸的位置， 然后计算出图像中的像素梯度。机器算法能够将图像转化为HOG， 进而得到人脸的位置信息。(2) 人脸对齐。人脸对齐是将不同角度的人脸图像对齐到同一标准的人脸形状中。机器算法首先会定位人脸上的特征点，然后通过几何变换将特征点对齐。
(3)人脸编码。人脸编码指将人脸图像的像素值转换为紧凑、可分辨的特征向量。在理想情况下，同一主题的所有面部信息都应该映射到相似的特征向量。
(4)人脸匹配。在人脸匹配模块构建中，将两个模板进行比对，度量两个人脸之间的相似度，判断两个人脸是否属于同一个人。
3 BP神经网络在人脸识别中的应用流程
3.1确定人脸识别的位置点
在进行人脸识别时需要确定机器算法，通过人脸数据库进行不同人脸形象的采集和抽取，确定特征点坐标，将左右眼的瞳孔、左右嘴角、眼眉外端、内端、鬓角鼻孔等20个特征点进行特征值定位，确定瞳孔、嘴角、两眉间的距离等关键信息，并将数据存储在处理器中。
3.2 预处理数据
第一，将人脸特征进行预处理处理后的样本作为原始样本，通过原始样本中数据采集的特征点确定出特征根，用特征根和原始样本数据进行比对。第二，从样本集中取一个样本(xp，yp)，并将xp输入网络中，其中xp是输入向量，yp是期望输出向量。
3.3 人脸样本检验
第一，将BP神经网络算法中确定的神经元进行输入检验，将样本数据库中的数据与输入的数据进行对比。第二，调用MAT LAB神经网络工具箱， 构建BP神经网络， 在函数new ff中建立一个可训练的前馈网络。查准率和查全率的算法为：
[Precision l， Recall 1] =Precision_Recall(B， num_train) ；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b1cd5ed8694a278a4efde971d7761d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001c06a0c30a6c067c1ad523b7076fdb/" rel="bookmark">
			CVE-2019-0708（远程桌面服务RCE）漏洞复现（超详细Getshell）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
漏洞介绍
影响版本
漏洞复现
靶场环境
开始攻击
漏洞修复
漏洞介绍 通过利用远程桌面的3389端口，RDP协议进行攻击，从而导致机器蓝屏瘫痪。该漏洞的触发无需任何用户交互操作，这就意味着，存在漏洞的计算机只要联网，无需任何操作，就有可能遭遇黑客远程攻击，运行恶意代码等，极具破坏性！
影响版本 该漏洞影响旧版本的Windows系统，包括：
Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows 2003、Windows XP。
Windows 8和Windows 10及之后版本不受此漏洞影响。
漏洞复现 靶场环境 靶机ip地址win 7192.168.0.128kali192.168.0.132 前提条件：win7允许远程桌面连接，关闭防火墙，两者可以通信
开始攻击 使用kali的msf模块
搜索 0708 模块
这里编号0为探测模块 编号1、2、3为攻击模块
我们先使用编号为0的模块探索目标主机是否有漏洞
use 0
show options
set rhosts 192.168.0.128
run
接下来使用编号为1的模块进行攻击
use 1
show options
set rhosts 192.168.0.128
show targets
set target 5
run
攻击后发现目标主机蓝屏了，接下来等待目标主机重启后我们进行getshell
首先 Ctrl+Z 先退出msf
接着重新进去重复之前操作
msfconsole
search 0708
use 1
set rhosts 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/001c06a0c30a6c067c1ad523b7076fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e330e99a55f43fd8dad0c5ef7c0fc55/" rel="bookmark">
			数据结构 | 栈（顺序栈&#43;链栈）的基本实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习教材：王红梅《数据结构——从概念到C++实现》、严蔚敏《数据结构》
学习课程：青岛大学王卓《数据结构与算法基础》
分类专栏：数据结构与算法(C++)
目录
前言
正文
1.栈的介绍
1.1 栈的概述
1.2 栈的特点
2.栈的基本实现及设计
2.1 顺序栈设计
2.1.1 数据类型设计
2.1.2 算法设计
（1）构造函数
（2）析构函数
（3）入栈操作
（4）创建指定长度的顺序栈
（5）判空操作
（6）出栈操作
（7）取出栈顶元素（不删除）
（8）输出顺序栈长度
（9）遍历打印顺序栈当前元素
2.2 链栈设计
2.2.1 数据类型设计
2.2.2 算法设计
（1）构造函数
（2）析构函数
（3）入栈操作
（4）创建指定长度的链栈
（5）出栈操作
（6）输出链栈长度
（7）判空操作
（8）取出栈顶元素（不删除）
（9）遍历打印链栈当前元素
2.3 菜单设计
2.3.1 主页面菜单设计
2.3.2 二级页面菜单设计
3.全部代码(分文件编写)
SeqStack.h
SeqStack.cpp
LinkedStack.h
LinkedStack.cpp
my_Menu.h
my_Menu.cpp
main.cpp
前言 最近刚在学习《数据结构与算法》，单纯地跟课、看书觉得并不能很好的掌握好这些知识点，所以决定尝试将学习的知识点归纳总结，也将其进行代码实现，强化对知识点的理解。即作为笔记、实践，又作为我的思路分享。因为初学，难免有不正确、不恰当之处，敬请指正！
正文 1.栈的介绍 1.1 栈的概述 栈（stack）是限定仅在表的一端进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶（stack top），另一端为栈底（stack bottom），不含任何数据元素的栈称为空栈。跟据存储结构的不同，栈同样可以分为顺序栈和链栈两种。
1.2 栈的特点 栈可以理解为一种功能受限的线性表，因此栈中的元素同样具有线性关系。但因为其只能通过一端进行元素的插入和删除，入栈、出栈具有顺序性，因此栈还具有“后进先出”的特性。
举个简单的例子：一把枪我们填入子弹后，如果要将最底下（也就是最先放入）的子弹取出来的话，我们需要把在它之后填入的子弹按照顺序取出，即“后进先出”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e330e99a55f43fd8dad0c5ef7c0fc55/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/48/">«</a>
	<span class="pagination__item pagination__item--current">49/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/50/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>