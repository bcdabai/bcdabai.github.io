<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c071dcdd8ea0d0e674897f0f2ec0bb31/" rel="bookmark">
			查看电脑内存个数、主频（工作频率）、容量、位宽等的方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑内存是电脑运行数据动态存储单元，内存的容量和运行频率直接决定了电脑运行速度和性能的好坏。下面总结了查看内存信息的5种方法：
一、运用系统命令行命令查看（最便捷，无需安装软件）
该方法是靠windows系统自身的工具盒方法来查看内存频率。按下WIN键+R组合键，打开运行，输入cmd,回车，进入命令提示符窗口，在其中输入wmic memorychip。注意，wmic和memorychip两个单词之间的空格不要忽略哦。如图，你会查看到关于内存非常详细的信息，包括频率，还包括内存个数、容量、位宽、描述等等。
二、利用CPU-Z软件查看
下载安装好CPU-Z，打开CPU-Z软件，单击菜单栏中的“内存”，就可以看到关于系统内存的信息了，内存频率也包含其间。
注意：cpu-z体现的内存频率要*2才是实际频率，现在的频率是665.1*2=1330.2，（正常时1333）.
三、利用鲁大师查看
安装好鲁大师后，打开鲁大师软件，可以看到硬件检测下电脑概览中清晰的显示了各个硬件的具体信息，其中包含了内存的频率。
四、进入BIOS查看
系统的 BIOS 是存储在主板上的一段程序，它不依赖于操作系统，即便在没有硬盘，或者硬盘上没有操作系统的情况下也可以运行。 在 BIOS 中可以查看基本的硬件配置信息，包括 CPU、内存及硬盘等。本文介绍了查看这些信息的方法。 进入 BIOS（各个品牌电脑进入方法不同） BIOS 的 Main 页面（硬盘、光驱、内存信息），在下面的 Installed Memory 项目，显示的是已安装的总内存数量以及内存类规格。操作系统，即便在没有硬盘，或者硬盘上没有操作系统的情况下也可以运行。 在 BIOS 中可以查看基本的硬件配置信息，包括 CPU、内存及硬盘等。本文介绍了查看这些信息的方法。 进入 BIOS（各个品牌电脑进入方法不同） BIOS 的 Main 页面（硬盘、光驱、内存信息），在下面的 Installed Memory 项目，显示的是已安装的总内存数量以及内存类规格。 五、通过内存卡的外标签查看（最简单粗暴）
查看内存卡的外标签
点此欢迎光临我的个人网站【一几文星球】
微信公众号，欢迎关注，一起学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4fa9c0e107b6b76c1982d0865d73c5/" rel="bookmark">
			Python从两个List构造Dict
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种解决方案：实现不使用内置函数的操作！
def Run():
list2 = [1, 2, 3, 4, 5 ];
list3 = ["a", "b", "c", "d","e"];
dict={};
i=0;
length=len(list2); while i&lt;length:
'dict[list2[i]]=list3[i];这种方法也可以'
dit={list2[i]:list3[i]};
dict.update(dit);
i+=1;
return dict;
if __name__ == '__main__':
print Run();
第二种解决方案：使用内置函数的话，zip的方法：
&gt;&gt;&gt; l1=[1,2,3,4,5,6]
&gt;&gt;&gt; l2 = [ 4 , 5 , 6 , 7 , 8 , 9 ] &gt;&gt;&gt; print ( dict ( zip (l1,l2))) { 1 : 4 , 2 : 5 , 3 : 6 , 4 : 7 , 5 : 8 , 6 : 9 } 那么还有一种情况，当两个list的长度不一样，如果要组成dict的话，怎么办呢？ 我们直接执行这个就可以，它会自动的匹配！自动的省去多余的部分！ &gt;&gt;&gt; ls1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] &gt;&gt;&gt; ls2 = [ 4 , 5 , 89 , 1 ] &gt;&gt;&gt; print ( dict ( zip (ls1,ls2))) { 1 : 4 , 2 : 5 , 3 : 89 , 4 : 1 } 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4fa9c0e107b6b76c1982d0865d73c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf43c44478acb7265b3f73219c34a667/" rel="bookmark">
			ue4 for循环的使用注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不能使用delay所有的for循环最终都会执行到completed引脚
以下提供一个测试方案
loop在使用过程中，如果在循环体break出来，completed也会执行
可以通过自定义一个加delay参数的for循环的宏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91635dcde02a3da38f7f2713ff5639bf/" rel="bookmark">
			saltstack常用操作----salt-api    实现 通过http请求远程调用saltstack的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在master主机上面执行如下操作：
1.创建登录的用户名和密码：
useradd username
pwsswd username
2. 修改master的配置文件，
进入下面的目录
cd /etc/salt/maaster.d/
touch eauth.conf
touch rest_api.conf
cat rest_api.conf
rest_cherrypy:
port: 8000
ssl_crt:/etc/pki/tls/certs/localhost.crt
ssl_key:/etc/pki/tls/certs/localhost.key
cat eauth.conf
external_auth:
pam:
username:
- .*
3. 产生认证证书：
首先保证master机器上面也装了salt-minion应用，因为需要执行salt-call 来调用tls模块，产生远程登录主机的认证证书。
执行如下命令：salt-call--local tls.create_self_signed_cert
4. 登录产生token串：
curl -k https://localhost:8000/login \
-H 'Accept: application/x-yaml' \
-d username=username \
-d password=password \
-d eauth=pam
5. 调用
curl -sSk https://localhost:8000\
-H 'Accept: application/x-yaml' \
-H 'X-Auth-Token:697adbdc8fe971d09ae4c2a3add7248859c87079'\
-d client=local \
-d tgt='*' \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91635dcde02a3da38f7f2713ff5639bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a3ecc06d41baf42b160534f8c2a6bb/" rel="bookmark">
			require和dofile的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1在lua中require和dofile都是用来加载和执行模块的，那么他们有什么不同呢？？？
差异：
在加载一个.lua文件的时候，require会先在package.loaded中查找此模块是否存在，如果存在则直接返回模块，如果不存在，则加载此模块。 dofile会对读入的模块编译执行，每调用dofile一次，都会重新编译执行一次。 require它的参数只是文件名，而dofile要求参数必须带上文件名的后缀。 例： foo.lua模块： test: 结果： 总结： 可以看到，对于同一个foo模块，require和dofile分别调用两次的结果是不同的。require只加载了 一次。
2、loadfile与dofile的区别 loadfile只编译模块，但是不执行模块，loadfile将模块编译之后当做函数返回。dofile编译并执行模块。 例：用loadfile打开foo模块，并打印结果，可以看到loadfile是只编译，不执行的。 结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e0f6d4c0bd7dcccf797d63c59513cb/" rel="bookmark">
			react 问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、控制台报错：
Uncaught Error: addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component's `render` method, or you have multiple copies of React loaded
Uncaught Error: removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component's `render` method, or you have multiple copies of React loaded
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03e0f6d4c0bd7dcccf797d63c59513cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36821081e353c65de1925338f0c738f/" rel="bookmark">
			OpenGL单缓冲与双缓冲的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 单缓存和双缓存 在我们电脑中，屏幕中显示的东西都会被放在一个称为显示缓存的地方，在通常情况下我们只有一个这样的缓冲区即单缓冲，在单缓冲中任何绘图的过程都会被显示在屏幕中，这也就是我们为什么会看到闪烁。而所谓双缓冲就是再这个显示的缓冲区之外再建立一个不显示的缓冲区，我们所有的绘图都将在这个不显示的缓冲区中进行，只有当一帧都绘制完了之后才会被拷贝到真正的现实缓冲区显示出来，这样中间过程对于最终用户就是不可见的了，那即使是速度比较慢也只会出现停顿而不会有闪烁的现象出现。
单缓存:帧缓存区开辟一个屏幕绘图缓存区。 双缓存:帧缓存区开辟两个屏幕绘图缓存区,交替使用,便于动画绘制 。 可以通过以下方法来设置窗口的展示模式为单缓冲或双缓冲
glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); glFlush(); //单缓冲的刷新模式; glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB); glutSwapBuffers(); //双缓冲的刷新模式; 一般用OpenGL绘图都是用双缓冲，单缓冲一般只用于显示单独的一副非动态的图像。
使用深度测试函数： 在解决了闪烁的问题之后，我们来解决另一个问题：首先我们在窗口中画两个交叉的分别位于ZOX 和 ZOY 平面的长方形，并用不同的颜色填充它们，然后让它们旋转很快我们发现有个比较严重的问题，因为我们发现OpenGL显然没有空间的位置观念，因为它根本不能分辨物体的前后关系，当然也不能做出适当的显示。在OpenGL中我们使用深度缓冲区来解决这个问题，在这个缓冲区中存放着每个象素深度信息，当有一个新的象素需要显示的时候，我们可以通过一个被称为深度测试的函数来确定它们的先后关系。
使用 glEnable(GL_DEPTH_TEST)。在默认情况是将需要绘制的新像素的z值与深度缓冲区中对应位置的z值进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新帧缓存中对应像素的颜色值。但是可以使用glDepthFunc(func)来对这种默认测试方式。其中参数func的值可以为GL_NEVER（没有处理）、GL_ALWAYS（处理所有）、GL_LESS（小于）、GL_LEQUAL（小于等于）、GL_EQUAL（等于）、GL_GEQUAL（大于等于）、GL_GREATER（大于）GL_NOTEQUAL（不等于），其中默认值是GL_LESS。一般来讲，使用glDepthFunc(GL_LEQUAL);来表达一般物体之间的遮挡关系。启用了深度测试，那么这就不适用于同时绘制不透明物体。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24f0f756f491ab18cbc59b3d4127b39/" rel="bookmark">
			CANoe的CAPL编程基础（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、检查错误帧 进行CAN通讯的测试时，检查错误帧是很常见的，要用CAPL脚本实现自动检测错误帧也不困难，它的核心就是调用错误检查函数ChkStart_ErrorFrameOccured();该函数一旦被调用，CANoe就会从此函数被调用时开始持续检测总线上有没有出现错误帧。 下面是一个小的例子：
dword chechId; dword numCheckEvents; checkId=ChkStart_ErrorFrameOccured();//开始检测错误帧 TestAddCondition(checkId);//添加检测条件，如果出现了错误帧，则输出报告中会记录下来 TestWaitForTimeout(5000);//持续检测5s checkControl_Stop(checkId);//停止检测错误帧 numCheckEvents=ChkQuery_NumEvents(checkId);//对5s内的检测情况进行获取，若函数返回0则没有出现错误帧 if(numCheckEvents&gt;0) TestStepFail("Error Frames Occured"); 2、添加事件信号 这种事件信号相当于uC-OS中的信号量机制，一般使用在需要等待某个或者是多个条件满足时进行下一步操作的地方。具体做法是：在一个位置添加需要等待的事件，程序中的其他地方，如果某个事件发生了（如周期超界等），提供该事件的供应，则等待的程序段获得了该事件，继续执行下面的操作。主要使用的函数有以下几个：
//供应text事件 long TestSupplyTextEvent( char aText[] ); //添加text事件 long TestJoinTextEvent(char[]aText); //等待text事件，有一个出现则程序执行下一步 long TestWaitForAnyJoinedEvent(dword aTimeout); //等待text事件，所有等待事件都出现则程序执行下一步 long TestWaitForAllJoinedEvents(dword aTimeout); 以下是一个例子：
TestJoinTextEvent("Test finished"); TestJoinTextEvent("Error Frame Occured"); TestWaitForAnyJoinedEvents(20000); 或者： TestWaitForAllJoinedEvents（20000）; 在系统事件on errorFrame中： on errorFrame { TestSupplyTextEvent("Error Frame occured"); } 在系统的on message 中： on message 0x400 { TestSupplyTextEvent("Test Finished") } 3、回调函数 CAPL中也有类似于C语言中的回调函数的机制，如检测报文周期和错误帧的函数中就可以使用，当周期超界或者总线出现错误帧就会自动调用回调函数执行一些操作； 如：
ErrChkId=ChkStart_ErrorFramesOccured("Callback_ErrorFrameOccured");//检查错误帧，如果发现错误帧就调用回调函数 回调函数设计如下： void Callback_errorFrameOccured(dword chk_id) { float t; t=timeNow()/100000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24f0f756f491ab18cbc59b3d4127b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec361232c73a7acb324fad9e53d3f5b9/" rel="bookmark">
			中文常用字体字符编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可用于网站中文常用字验证码
\u7684\u4e00\u4e86\u662f\u6211\u4e0d\u5728\u4eba\u4eec\u6709\u6765\u4ed6\u8fd9\u4e0a\u7740\u4e2a\u5730\u5230\u5927\u91cc\u8bf4\u5c31\u53bb\u5b50\u5f97\u4e5f\u548c\u90a3\u8981\u4e0b\u770b\u5929\u65f6\u8fc7\u51fa\u5c0f\u4e48\u8d77\u4f60\u90fd\u628a\u597d\u8fd8\u591a\u6ca1\u4e3a\u53c8\u53ef\u5bb6\u5b66\u53ea\u4ee5\u4e3b\u4f1a\u6837\u5e74\u60f3\u751f\u540c\u8001\u4e2d\u5341\u4ece\u81ea\u9762\u524d\u5934\u9053\u5b83\u540e\u7136\u8d70\u5f88\u50cf\u89c1\u4e24\u7528\u5979\u56fd\u52a8\u8fdb\u6210\u56de\u4ec0\u8fb9\u4f5c\u5bf9\u5f00\u800c\u5df1\u4e9b\u73b0\u5c71\u6c11\u5019\u7ecf\u53d1\u5de5\u5411\u4e8b\u547d\u7ed9\u957f\u6c34\u51e0\u4e49\u4e09\u58f0\u4e8e\u9ad8\u624b\u77e5\u7406\u773c\u5fd7\u70b9\u5fc3\u6218\u4e8c\u95ee\u4f46\u8eab\u65b9\u5b9e\u5403\u505a\u53eb\u5f53\u4f4f\u542c\u9769\u6253\u5462\u771f\u5168\u624d\u56db\u5df2\u6240\u654c\u4e4b\u6700\u5149\u4ea7\u60c5\u8def\u5206\u603b\u6761\u767d\u8bdd\u4e1c\u5e2d\u6b21\u4eb2\u5982\u88ab\u82b1\u53e3\u653e\u513f\u5e38\u6c14\u4e94\u7b2c\u4f7f\u5199\u519b\u5427\u6587\u8fd0\u518d\u679c\u600e\u5b9a\u8bb8\u5feb\u660e\u884c\u56e0\u522b\u98de\u5916\u6811\u7269\u6d3b\u90e8\u95e8\u65e0\u5f80\u8239\u671b\u65b0\u5e26\u961f\u5148\u529b\u5b8c\u5374\u7ad9\u4ee3\u5458\u673a\u66f4\u4e5d\u60a8\u6bcf\u98ce\u7ea7\u8ddf\u7b11\u554a\u5b69\u4e07\u5c11\u76f4\u610f\u591c\u6bd4\u9636\u8fde\u8f66\u91cd\u4fbf\u6597\u9a6c\u54ea\u5316\u592a\u6307\u53d8\u793e\u4f3c\u58eb\u8005\u5e72\u77f3\u6ee1\u65e5\u51b3\u767e\u539f\u62ff\u7fa4\u7a76\u5404\u516d\u672c\u601d\u89e3\u7acb\u6cb3\u6751\u516b\u96be\u65e9\u8bba\u5417\u6839\u5171\u8ba9\u76f8\u7814\u4eca\u5176\u4e66\u5750\u63a5\u5e94\u5173\u4fe1\u89c9\u6b65\u53cd\u5904\u8bb0\u5c06\u5343\u627e\u4e89\u9886\u6216\u5e08\u7ed3\u5757\u8dd1\u8c01\u8349\u8d8a\u5b57\u52a0\u811a\u7d27\u7231\u7b49\u4e60\u9635\u6015\u6708\u9752\u534a\u706b\u6cd5\u9898\u5efa\u8d76\u4f4d\u5531\u6d77\u4e03\u5973\u4efb\u4ef6\u611f\u51c6\u5f20\u56e2\u5c4b\u79bb\u8272\u8138\u7247\u79d1\u5012\u775b\u5229\u4e16\u521a\u4e14\u7531\u9001\u5207\u661f\u5bfc\u665a\u8868\u591f\u6574\u8ba4\u54cd\u96ea\u6d41\u672a\u573a\u8be5\u5e76\u5e95\u6df1\u523b\u5e73\u4f1f\u5fd9\u63d0\u786e\u8fd1\u4eae\u8f7b\u8bb2\u519c\u53e4\u9ed1\u544a\u754c\u62c9\u540d\u5440\u571f\u6e05\u9633\u7167\u529e\u53f2\u6539\u5386\u8f6c\u753b\u9020\u5634\u6b64\u6cbb\u5317\u5fc5\u670d\u96e8\u7a7f\u5185\u8bc6\u9a8c\u4f20\u4e1a\u83dc\u722c\u7761\u5174\u5f62\u91cf\u54b1\u89c2\u82e6\u4f53\u4f17\u901a\u51b2\u5408\u7834\u53cb\u5ea6\u672f\u996d\u516c\u65c1\u623f\u6781\u5357\u67aa\u8bfb\u6c99\u5c81\u7ebf\u91ce\u575a\u7a7a\u6536\u7b97\u81f3\u653f\u57ce\u52b3\u843d\u94b1\u7279\u56f4\u5f1f\u80dc\u6559\u70ed\u5c55\u5305\u6b4c\u7c7b\u6e10\u5f3a\u6570\u4e61\u547c\u6027\u97f3\u7b54\u54e5\u9645\u65e7\u795e\u5ea7\u7ae0\u5e2e\u5566\u53d7\u7cfb\u4ee4\u8df3\u975e\u4f55\u725b\u53d6\u5165\u5cb8\u6562\u6389\u5ffd\u79cd\u88c5\u9876\u6025\u6797\u505c\u606f\u53e5\u533a\u8863\u822c\u62a5\u53f6\u538b\u6162\u53d4\u80cc\u7ec6
转载于:https://www.cnblogs.com/zhengzhen0512/p/7683570.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b89acbf0347f8930c11b2e692e9a15e/" rel="bookmark">
			Android中Canvas的使用（画直线、虚线、圆、圆环、矩形、多边形、圆角矩形、矩形字体居中、图片、图片旋转等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久之前就想写博客，分享一些自己的总结体会，可总是因为工作忙+本人懒惰才一直没写。以后准备每月写1~2篇博客吧，希望自己能坚持下去。好了废话不多说直接上canvas绘制效果图及代码。 Canvas与Paint介绍 在Android中把Canvas当做画布、Paint当做画笔，那么就可以在画布上用画笔绘制我们想要的任何东西。我们可以设置一些画布/画笔的属性，比如：画布的颜色、画笔的抗锯齿等。使用Canvas画图，一般绘图都是在自定义view中使用，特别是onDraw(Canvas canvas)方法中，使用参数canvas这个画布进行绘制图型，该方法里面就是绘制图形的过程。如下图所示就是我进行绘制的效果图、在其下有对应源码。 Canvas绘制文字 drawText(String s, int x, int y, Paint paint) canvas绘制字体比较简单，直接调用drawText(String s, int x, int y, Paint p)方法，其参数分别是：s-&gt;待绘制的文字，x-&gt;文字在屏幕上的横坐标，y-&gt;文字在屏幕上的纵坐标，paint-&gt;绘制文字的画笔。 // 创建画笔 Paint textPaint = new Paint(); textPaint.setColor(Color.BLACK);//设置黑色 textPaint.setTextSize(60); //设置字体大小为100像素点 //画字 canvas.drawText("画圆(圆环)", 30, 200, textPaint); canvas.drawText("画线(虚线)", 30, 400, textPaint); canvas.drawText("画圆角矩形(文字居中)", 30, 600, textPaint); canvas.drawText("画图片(旋转)", 30, 1000, textPaint); canvas.drawText("画椭圆(三角形)", 30, 1350, textPaint); Canvas绘制圆、圆环 drawCircle(int x, int y, int r, Paint paint) canvas绘制圆环其原理就是绘制小圆覆盖大圆形成圆环效果，先画大圆在此基础上再画小圆。调用drawCircle(int r, int x, int y, Paint paint)方法来，其参数分别是：x-&gt;圆心在屏幕上的横坐标，y-&gt;圆心在屏幕上的纵坐标，r-&gt;圆的半径，paint-&gt;绘制文字的画笔。在这里画笔抗锯齿尤为重要，会使圆环边缘光滑。 //创建红画笔 Paint redPaint = new Paint(); redPaint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b89acbf0347f8930c11b2e692e9a15e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec503d7437107546a4c588c20a7f83ec/" rel="bookmark">
			我面试到的培训公司
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我是刚来到北京的一名实习生，再找工作，面试了5，6家培训公司，还有其他在网上搜到没有去的。现在写去来分享给大家，避免车费和时间吧谢谢。
翔博科技 地点：海淀区上地信息路科视大厦A座307
优才创智集团 地址：海淀区苏州街长远天地大厦B座3A07
华软汇智 地点：海淀区东北旺西路8号院1号楼中关村发展集团一层（最北头）
开网科技 北京海淀区中关村软件园孵化器2号楼2A座2208室、
华软 地点:中关村软件园信息中心（北门） 海淀区东北旺西路8号院1号楼中关村发展集团一层A座（最北头）a103（同华软汇智）
华软 地点：海淀区中关村软件园信息中心8号院1号楼一层A座A103（最北头）
宏创科技 地点：昌平区回龙观西大街琥珀天地3单元667（公司原名：宏林云创，又名：华威信科有限公司）
这些是我现在面试到培训公司，以后有的话再添加。
我在加些网上搜到的培训公司：
北京汇瑞安网络科技有限公司 天瑞地安网络科技有限公司北京分公司 北京嘉惠卓通科技有限公司 北京瑞丰时代网络科技有限公司 北京天利瑞安科技有限公司 北京瑞通合力科技有限公司 北京新安时代科技有限公司 中软智创（北京）科技有限公司 中软电联(北京)科技有限公司 京东高科(北京)科技有限公司 京东联创(北京)科技有限公司 华为联创软件(北京)有限公司 盈科联创(北京)软件有限公司 中科富盈(北京)科技有限公司 北京荣新广育科技有限公司 中软创新(北京)科技有限公司 中创科达(北京)科技有限公司 阁瑞钛伦特软件(北京)有限公司 因特驰软件(北京)有限公司 中软基地(北京)科技有限公司 硅谷汇(北京)软件技术有限公司 北京无忧前程科技有限公司 北京华为云端科技有限公司 北京特训连科技有限责任公司 北京春玉影视文化传媒有限公司 微奥互动科技有限公司 北京博达远创科技发展有限公司 北京瑞明恒通科技有限公司 北京海新创业科技有限公司 北京理博软件科技有限公司 中明盈佳(北京)计算机科技有限公司 云软高科(北京)软件有限公司 宏林云创(北京)科技有限公司 华软汇智（北京）国际软件技术研究院 北京富尧软件有限公司 中软宏图（北京）科技有限公司 开网科技(北京)有限公司 华锐祥博(北京)科技有限公司 中软高科（北京）科技有限公司 北京东软数字科技有限公司 北京紫达恒科技有限公司 华为高科（北京）软件有限公司 北京伟林鑫越科技有限公司 中软开创（北京）科技有限公司 北京大华明智软件有限公司 北京天和恒通科技有限公司 北京携诚开创软件有限公司 北京卡爱特科技有限公司 联创先锋（北京）软件有限公司 中软亚信科技有限公司 北京嘉豪时代科技有限公司 联创云时代(北京)软件有限公司 北京弘睿千里信息技术有限公司 微码云（北京）软件有限公司 网易高科(北京)软件有限公司 华为云软(北京)软件有限公司 联创开拓(北京)科技有限公司 国投联创(北京)软件有限公司 华软汇通(北京)科技有限公司 东软互联(北京)科技有限公司 拓普互联（北京）科技有限公司 高德云软(北京)技术有限公司 博彦高科(北京)软件有限公司 中软联创（北京）科技有限公司 中航云天（北京）软件有限公司 中软互联(北京)科技有限公司 京仲联达科技有限公司 睿一（北京）科技有限公司 华软国创(北京)科技有限公司 北京清软创新科技有限公司 世纪金辰（北京）科技有限公司 中软博创（北京）科技有限公司 北京泰至诚科贸有限公司 北京东软睿道教育科技有限公司 北京东软高科软件技术研究院 博创华宇（北京）科技有限公司 清软高科（北京）有限公司 中开联创(北京)科技有限公司 北京储瑞隆科技有限公司 东软联创(北京)科技有限公司 华为云集（北京）软件有限公司 易智互联(北京)科技有限公司 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58178e454017d3a204720f53389adfe6/" rel="bookmark">
			虚拟机Linux(Centos)上用户密码忘记了怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们有时会忘记虚拟机上的登陆密码,今天来说一下怎样修改我们的密码.应该对大多数的linux版本都有帮助. tep_1:启动虚拟机，出现下面的倒计时界面时，按键盘上的e键. （说明：要确保光标此时已经在虚拟机内了，要不然，按了e键，也是在windows内，无效。e代表edit，启动前编辑） 红字对小白很重要再说一遍! ! ! step_2:进入如下后界面，再按e键 step_3:进入如下界面后，使用键盘上的上下键，选中第二项以kernel开头的项。选中后，再次按e键。 step_4:进入以下界面后，在最后面输入空格和s，然后回车。（注意：有的系统显示的内容可能和我下面出现的这一行不一样，没关系，直接加空格和s就行，不影响的；也就说什么呢，只要进入到这个页面，直接加空格和s，不要管他显示的是什么；） step_5:接着会回到如下界面，然后按下b键（b代表boot启动） step_6:进入如下界面： step_7:此时输入passwd root回车, step_8:输入密码，回车，确认密码，回车，输入reboot，回车； (声明：输入的密码不会显示出来，如果密码中想要带数字的话，不要使用键盘右边的number pad栏，要使用字母键盘上的数字，因为你不确定此时num lock是否锁定(针对笔记本而言)) 以上就完成了! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff177b656d008a975e2b384f345ae940/" rel="bookmark">
			向量组的线性相关性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向量组及其线性组合向量组的线性相关性向量组的秩向量空间线性方程组解的结构 向量组及其线性组合 n n 个有次序的数a1,a2,...,ana1,a2,...,an所组成的一个有序数组 (a1,a2,...,an) ( a 1 , a 2 , . . . , a n ) 称为一 n n 维向量，这nn个数称为该向量的 n n 个分量，其中aiai称为第 i i 个分量.ai(i=1,2,...,n)ai(i=1,2,...,n)都为实数的向量称为实向量，分量为复数的向量称为复向量.n维向量可写成一行或一列，分别称为行向量或列向量，即行矩阵或列矩阵.列向量一般用小写黑体字母 α,β,γ α , β , γ 等表示，行向量则用 αT,βT,γT α T , β T , γ T 等表示.若干个同维数的列向量（行向量）组成的集合称为向量组. 设向量 A：α1,α2,...,αm A ： α 1 , α 2 , . . . , α m ，对于任意实数 k1,k2,...,km k 1 , k 2 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff177b656d008a975e2b384f345ae940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0275f82086e713915efec8cd5ce16b30/" rel="bookmark">
			NWERC 2013
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B Battle for Silver 容易发现答案最多有4个点，枚举所有4个点一下的完全图。
#include&lt;bits/stdc++.h&gt; using namespace std; #define For(i,n) for(int i=1;i&lt;=n;i++) #define Fork(i,k,n) for(int i=k;i&lt;=n;i++) #define ForkD(i,k,n) for(int i=n;i&gt;=k;i--) #define Rep(i,n) for(int i=0;i&lt;n;i++) #define ForD(i,n) for(int i=n;i;i--) #define RepD(i,n) for(int i=n;i&gt;=0;i--) #define Forp(x) for(int p=pre[x];p;p=next[p]) #define Forpiter(x) for(int &amp;p=iter[x];p;p=next[p]) #define Lson (o&lt;&lt;1) #define Rson ((o&lt;&lt;1)+1) #define MEM(a) memset(a,0,sizeof(a)); #define MEMI(a) memset(a,0x3f,sizeof(a)); #define MEMi(a) memset(a,128,sizeof(a)); #define MEMx(a,b) memset(a,b,sizeof(a)); #define INF (0x3f3f3f3f) #define F (1000000007) #define pb push_back #define mp make_pair #define fi first #define se second #define vi vector&lt;int&gt; #define pi pair&lt;int,int&gt; #define SI(a) ((a).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0275f82086e713915efec8cd5ce16b30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db385f0a5e19a3bcb63fa2341f89bab1/" rel="bookmark">
			记忆网络之Dynamic Memory Networks模型介绍及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记忆网络之Dynamic Memory Networks 今天我们要介绍的论文是“Ask Me Anything: Dynamic Memory Networks for Natural Language Processing”，这篇论文发表于2015年6月，从题目中就可以看得出来，本文所提出的模型在多种任务中均取得了非常优秀的表现，论文一开始说道，NLP中很多任务都可以归结为QA问题，所以本文的DMN模型以QA为基础进行训练，但是可以扩展到很多别的任务中，包括序列标注、分类、seq-to-seq、QA等等。之所以有这么强的推广能力，原因就在于其使用RNN作为处理数据的工具，而大部分NLP任务都是序列问题，所以很方便就可以进行推广。而前面介绍的几篇Memory Networks的局限性就在于，其使用词袋子的方法处理输入，使用embedding来编码输入的信息，限制了模型用在别的任务上面。
模型架构 本文提出的DMN网络模型包含输入、问题、情景记忆、回答四个模块，架构图如下所示。模型首先会计算输入和问题的向量表示，然后根据问题触发Attention机制，使用门控的方法选择出跟问题相关的输入。然后情景记忆模块会结合相关的输入和问题进行迭代生成记忆，并且生成一个答案的向量表示。最只答案模块结合该向量以及问题向量，生成最终的答案。从整个框架上看跟MemNN十分相似，也是四大模块，而且各模块的功能都很像。
接下来我们看一个各个模块的细节是如何实现的，这也是其区别与MemNN的地方。首先结合实例和细节模型图了解一下模型的原理：
如上图所示，假设我们的输入就是Input模块中的8句话，问题是“Where is the football？”首先，模型会将相应的输入都编码成向量表示（使用GRU），如图中的S1~S8和问题向量q。接下来q会触发Attention机制，对输入的向量进行评分计算，如上图中在计算第一层的memory时，只选择了S7（因为问题是足球在哪，而S7是jhon放下了足球，与问题最为相关）。然后q作为第一层GRU的初始隐层状态进行迭代计算得到第一层的记忆m1；之后因为第一层选择出了john这个关键词，所以在第二层memory计算时，q会选择出S2和S6（其中S2属于干扰信息，权重较小），同样结合m1进行迭代计算得到第二层的记忆m2，然后将其作为输出向量传递给Answer模块，最终生成最后的答案hallway。这就是整个模型直观的解释，然后我们在对每个模块一一介绍。
Input Module 使用GRU对输入进行编码，（这里论文中有提到GRU和LSTM，说GRU可以达到与LSTM相似的准确度而且参数更少计算更为高效，但都比RNN要好），具体GRU的计算公式就不在详细列了，这里说一下当输入不通时应该如何区别对待。
输入是一个句子时，直接输入GRU，步长就是句子的长度。最终也会输出句长个向量表示（对应S1~S8）,这是Attention机制用来选与Question最相关的单词；输入是一堆句子时，将句子连接成一个长的单词序列，然后每个句子之间使用end-of-sentence的特殊标志进行分割，然后将每个end-of-sentence处的隐层状态输出即可，这时Attention机制选择的就是与Question相关的句子表示； Question Module 这部分与Input Module一样，就是使用GRU将Question编码成向量。不同的是，最后只输出最后的隐层向量即可，而不需要像Input模块那样（输入是句子时，会输出句长个向量）。而且，q向量除了用于Attention外，还会作为Memory模块GRU的初始隐层状态~~
Episodic Memory Module 本模块主要包含Attention机制、Memory更新机制两部分组成，每次迭代都会通过Attention机制对输入向量进行权重计算，然后生成新的记忆。
首先看一下Attention机制，这里使用一个门控函数作为Attention。输入是本时刻的输入c，前一时刻的记忆m和问题q。首先计算相互之间的相似度作为特征向量传入一个两层的神经网络，最终计算出来的值就是门控函数的值，也就是该输入与问题之间的相似度。如下：
其中相似度的特征向量是有c,m,q,c*m,c*q,|c-q|,|c-m|,cWq,cWm contact起来的向量，将其传入一个二层神经网络即可。
接下来看一下记忆更新机制，计算出门控函数的值之后，我们就要根据其大小对记忆进行更新。更新方法就是GRU算出的记忆乘以门控值，再加上原始记忆乘以1-门控值，其实就类似于反向传播中的梯度更新一样。公式如下，更直观：
Answer Module 仍然使用GRU最为本模块的模型，根据memory模块最后的输出向量（将其作为初始隐层状态），然后输入使用的是问题和上一时刻的输出值连接起来（每个时刻都是用q向量）。并使用交叉熵损失函数作为loss进行反向传播训练。
模型扩展 以上就是DMN的模型架构及细节介绍，可以看得出来，其每个模块都使用GRU作为编码/记忆的基础模型，而且模型性能很依赖于Attention机制的效果。所以可以从以上两个方面对DMN进行改进，接下来我们就参考两篇论文来说一下他们对DMN作出的改进：
DMTN 这是论文“Ask Me Even More: Dynamic Memory Tensor Networks (Extended Model)”所提出的改进模型，DMN在用于bAbI数据集时，和MemNN一样，需要对答案所依赖的事实进行监督训练。而本文所提出的模型由于改进了Attention机制，所以可以自己学习到这个点。本文提出的模型叫做Dynamic Memory Tensor Network（DMTN），主要的改进点就是DMN的Attention机制，其他地方未做改动。
原始的Attention机制，首先根据c，m，q三个向量构造一个相似度的特征向量，然后通过一个二层神经网络计算门控值g（见上图）。而DMTN中，作者认为上面那种人工构造特征向量计算相似度的方法存在某种局限，所以推广到让模型自己学习参数构造该特征向量，最后仍适用一个二层神经网络计算门控值g。如下图所示，其实就是将原来的内积、|~|距离替换成使用矩阵参数学习两个向量之间的相似度而已（个人感觉比较牵强==）：
然后作者有尝试了另外一种方案，令z=（c,m,q），然后使用下面的公式直接进行计算，而不再使用上面的几个变量连接的方法，这样可以减少参数量的同时保持比较高的准确度：
DMN+ 这是论文“Dynamic Memory Networks for Visual and Textual Question Answering”提出的改进模型。上面的DMTN改动较小，仅仅是对特征向量表示方法的一些尝试。而本篇论文所提出的改进就相对较多，而且还把模型运用到了visual QA的任务上面并取得了较好地成果。其改进点主要集中在对Input module、Attention机制和Memory更新三个地方，是结合了End-to-End MemNN和DMN两个模型的优点作出的改进，可以说是比较完善的解决方案，下面我们看一下改进的点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db385f0a5e19a3bcb63fa2341f89bab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a8d50189f54021f160e034bd30ddef/" rel="bookmark">
			Mac下安装mongoldb 报错 shutting down with code:100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体错误栈：
2017-10-11T09:31:12.140+0800 I CONTROL [initandlisten] MongoDB starting : pid=2382 port=27017 dbpath=/data/db 64-bit host=songyuxiangdeMacBook-Pro.local
2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] db version v3.4.9 2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] git version: 876ebee8c7dd0e2d992f36a848ff4dc50ee6603e 2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 0.9.8zh 14 Jan 2016 2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] allocator: system 2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] modules: none 2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] build environment: 2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] distarch: x86_64 2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] target_arch: x86_64 2017-10-11T09:31:12.141+0800 I CONTROL [initandlisten] options: {} 2017-10-11T09:31:12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a8d50189f54021f160e034bd30ddef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c09260844ad3e999e2893523716b37/" rel="bookmark">
			js 颜色格式rgb-&gt;16进制的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://www.zhangxinxu.com/wordpress/2010/03/javascript-hex-rgb-hsl-color-convert/
这个链接是一篇对颜色格式转换的必要性和原理介绍的比较清晰的一篇文章，需要的小伙伴可以借鉴一下~
今天看到一段做转换的代码，较于之前用过的代码更加精简，个人觉得很棒~特此记录。
function zero_fill_hex(num, digits) { var s = num.toString(16); while (s.length &lt; digits) s = "0" + s; return s; } function rgb2hex(rgb) { if (rgb.charAt(0) == '#') return rgb; var ds = rgb.split(/\D+/); var decimal = Number(ds[1]) * 65536 + Number(ds[2]) * 256 + Number(ds[3]); return "#" + zero_fill_hex(decimal, 6); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9968a85489ddd7670feb58b9b94cf316/" rel="bookmark">
			JDK自带的URLConnection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.example.demo.util;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
public class HttpRequest {
/**
* 向指定URL发送GET方法的请求
*
* @param url 发送请求的URL
* @return URL 所代表远程资源的响应结果
*/
public static String sendGet(String url) {
String result = "";
BufferedReader in = null;
try {
URL httpUrl = new URL(url);
// 打开和URL之间的连接
HttpURLConnection connection = (HttpURLConnection) httpUrl.openConnection();
connection.setRequestMethod("GET");
connection.setConnectTimeout(5 * 1000);
// 设置通用的请求属性
connection.setRequestProperty("accept", "*/*");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9968a85489ddd7670feb58b9b94cf316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed691fc428c23a9d4c50fa80eb74d8ef/" rel="bookmark">
			Java 获取HTTP首部信息内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本方法获取HTTP头部信息 通过HTTP服务器响应信息时候，一般来说，HTTP首部可能包含所请求的文档的内容类型、文档长度(字节数)、对内容编码所采用的字符集、日期时间、内容的过期时间及内容的最后修改日期。可以使用URL API创建连接，获取相关信息，报头信息如下所示：
可以获取的信息类型如下所示：
代码如下：
import java.io.IOException; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.util.Date; public class HeaderViewer { public static void main(String[] args) { try { URL u = new URL("http://www.baidu.com"); URLConnection uc = u.openConnection(); System.out.println("Content-type: " + uc.getContentType()); if(uc.getContentEncoding() != null) { System.out.println("Content-encoding: " + uc.getContentEncoding()); } if (uc.getDate() != 0) { System.out.println("Date: " + new Date(uc.getDate())); } if (uc.getLastModified() != 0) { System.out.println("Last Modified: " + new Date(uc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed691fc428c23a9d4c50fa80eb74d8ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45839d1a12ac8ade4ec72275b8ebc017/" rel="bookmark">
			SQL-简单地保存数据到表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前 以前一般用Open方法执行SQL语句，然后再用AddNew来添加数据行来添加数据，这样很麻烦。 现可用一句话搞掂。
SQL插入数据语句与执行 Sql = “insert into 表格名 (列名1，列名2，列名3） values (列1数据,列2数据，列3数据)” SQLConn.Execute(Sql)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf6af640ee4626634c768edd0dcf8a4/" rel="bookmark">
			Python绘图问题：Matplotlib中柱状图bar使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matplotlib.pyplot.bar(left, height, alpha=1, width=0.8, color=, edgecolor=, label=, lw=3)
Make a bar plot，绘制柱状图。
参数： 1. left：x轴的位置序列，一般采用arange函数产生一个序列； 2. height：y轴的数值序列，也就是柱形图的高度，一般就是我们需要展示的数据； 3. alpha：透明度 4. width：为柱形图的宽度，一般这是为0.8即可； 5. color或facecolor：柱形图填充的颜色； 6. edgecolor：图形边缘颜色 7. label：解释每个图像代表的含义 8. linewidth or linewidths or lw：边缘or线的宽度
一个例子：
%matplotlib inline import numpy as np from matplotlib import pyplot as plt plt.figure(figsize=(9,6)) n = 8 X = np.arange(n)+1 #X是1,2,3,4,5,6,7,8,柱的个数 #uniform均匀分布的随机数，normal是正态分布的随机数，0.5-1均匀分布的数，一共有n个 Y1 = np.random.uniform(0.5,1.0,n) Y2 = np.random.uniform(0.5,1.0,n) plt.bar(X, Y1, alpha=0.9, width = 0.35, facecolor = 'lightskyblue', edgecolor = 'white', label='one', lw=1) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cf6af640ee4626634c768edd0dcf8a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196729356051cae95aac1ebdf11c2cde/" rel="bookmark">
			Python绘图问题：Matplotlib中%matplotlib inline是什么、如何使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%matplotlib inline
是一个魔法函数（Magic Functions）。官方给出的定义是：IPython有一组预先定义好的所谓的魔法函数（Magic Functions），你可以通过命令行的语法形式来访问它们。可见“%matplotlib inline”就是模仿命令行来访问magic函数的在IPython中独有的形式。
magic函数分两种：一种是面向行的，另一种是面向单元型的。 行magic函数是用前缀“%”标注的，很像我们在系统中使用命令行时的形式，例如在Mac中就是你的用户名后面跟着“$”。“%”后面就是magic函数的参数了，但是它的参数是没有被写在括号或者引号中来传值的。
单元型magic函数是由两个“%%”做前缀的，它的参数不仅是当前“%%”行后面的内容，也包括了在当前行以下的行。
注意：既然是IPython的内置magic函数，那么在Pycharm中是不会支持的。
#内嵌画图 %matplotlib inline import matplotlib # 注意这个也要import一次 import matplotlib.pyplot as plt myfont = matplotlib.font_manager.FontProperties(fname=r'C:/Windows/Fonts/msyh.ttf') # 这一行 plt.plot((1,2,3),(4,3,-1)) plt.xlabel(u'横坐标', fontproperties=myfont) # 这一段 plt.ylabel(u'纵坐标', fontproperties=myfont) # 这一段 #plt.show() # 有了%matplotlib inline 就可以省掉plt.show()了 总结：%matplotlib inline 可以在Ipython编译器里直接使用，功能是可以内嵌绘图，并且可以省略掉plt.show()这一步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccd95778c4a88ea7ada78bf1bed04fa/" rel="bookmark">
			&#34;LPWSTR&#34; 类型的值不能用于初始化 &#34;char *&#34; 类型的实体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 "LPWSTR" 类型的值不能用于初始化 "char *" 类型的实体 void CFaceTemptureDlg::OnButtonClick_SO2() { // TODO: Add your command handler code here CString strLine, strTemp, result; int row = 0; CString filename = L"111.txt"; CStdioFile file(L"111.txt", CFile::modeRead); while (file.ReadString(strLine)) { char *str = strLine.GetBufferSetLength(strLine.GetLength()); char *p; if (strLine != "") { result += strLine; GetDlgItem(IDC_Edit_SO2)-&gt;SetWindowText(result); row++; } } file.Close(); } 解决办法： 类型转换 参考知识 CString与LPCWSTR、LPSTR、char*、LPWSTR等类型的转换 char *str = strLine.GetBufferSetLength(strLine.GetLength());改为： char *str = (char *)strLine.GetBufferSetLength(strLine.GetLength()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423b2be38d42472b3e387fc7c9990866/" rel="bookmark">
			find 递归/不递归 查找子目录的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、递归查找（find 命令 是递归遍历文件夹的）
命令：find . -name “*.txt” //当前路径下递归查找以.txt结尾的文件夹
2、不递归查找
find . -name “*.txt” -maxdepth 1
//当前路径下不递归查找以.txt结尾的文件夹，-maxdepth 1表示查找深度为1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b986e8c471ffc18602a4fd06acec2f/" rel="bookmark">
			卡特兰数（好像很有用的说）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于卡特兰数 卡特兰数是一种经典的组合数，经常出现在各种计算中，其前几项为 : 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ... 计算公式 卡特兰数一般的计算公式：
另类递推公式：C(n)=C(n-1)*((4*n-2)/(n+1));
一般性质 Cn的另一个表达形式为
所以，Cn是一个自然数，这一点在先前的通项公式中并不显而易见。 这个表达形式也是André对前一公式证明的基础。
卡塔兰数满足以下递推关系 它也满足 这提供了一个更快速的方法来计算卡塔兰数。
卡塔兰数的渐近增长为 它的含义是左式除以右式的商趋向于1当n → ∞。（这可以用n!的斯特灵公式来证明。）
所有的奇卡塔兰数Cn都满足n = 2^k − 1。 所有其他的卡塔兰数都是偶数。
实际问题的解决 说了这么多，那么卡特兰数在实际问题中的应用还是很广泛的：
经典问题：
给出一个n，要求一个长度为2n的01序列，使得序列的任意前缀中1的个数不少于0的个数， 以下为长度为6的序列: 111000 101100 101010 110010 110100 证明： 令1表示进栈，0表示出栈，则可转化为求一个2n位，含n个1，n个0的二进制数， 满足从左往右扫描到任意一位时，经过的0数不多于1数 显然含n个1，n个0的2n位二进制数共有个，下面考虑不满足要求的数目. 考虑一个含n个1，n个0的2n位二进制数，扫描到第2m+1位上时有m+1个0和m个1（容易证明一定存在这样的情况）， 则后面的01排列中必有n-m个1和n-m-1个0 将2m+2及其以后的部分0变成1，1变成0，则对应一个n+1个0和n-1个1的二进制数 反之亦然（相似的思路证明两者一一对应） 从而
将上例的X换成左括号，Y换成右括号，Cn表示所有包含n组括号的合法运算式的个数: ((())) ()(()) ()()() (())() (()())
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b986e8c471ffc18602a4fd06acec2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb02f89a9aaf9441972acf202b8e8e2f/" rel="bookmark">
			Angular Material Menu 组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 menu 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8262cc7ebac3002d1f000d894b2a59c/" rel="bookmark">
			wireshark 找不到wifi网卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我今天用wireshark想来试一下抓包。我是用wifi上网，结果wireshark上根本就找不到无线网卡。原因是因为我没有打开npf服务。 原本我也不知道是因为没有开启npf服务的原因，我偶然中打开了wireshark安装目录下的wireshark-gtk.exe程序 打开之后提示我“The NPF driver isn’t running” 所以我才知道是没有打开npf服务。
打开npf服务办法： 以管理员方式运行命令行工具 输入net start npf
开启之后就可以捕捉到无线网卡了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807c3b67af35ffd635574a0455cd1672/" rel="bookmark">
			面向对象状态机框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.状态类（Istate)当前状态下所有要执行的动作
using System.Collections; using System.Collections.Generic; using UnityEngine; namespace FSM { /// &lt;summary&gt; /// 状态接口 /// &lt;/summary&gt; public interface Istate { /// &lt;summary&gt; /// 状态名 /// &lt;/summary&gt; string Name { get; } /// &lt;summary&gt; /// 状态标签 /// &lt;/summary&gt; string Tag { set; get; } /// &lt;summary&gt; /// 当前状态的状态机 /// &lt;/summary&gt; IstateMachine Parent { get; set; } /// &lt;summary&gt; /// 从进入状态开始计算的时长 /// &lt;/summary&gt; float Timer { get; } /// &lt;summary&gt; /// 状态过度当前状态的所有过度 /// &lt;/summary&gt; List&lt;ITransition&gt; Transition { get; } /// &lt;summary&gt; /// 进入状态时的回调 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/807c3b67af35ffd635574a0455cd1672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc6b6477ee091b8d9ab2530e803f7ee/" rel="bookmark">
			MMORPG战斗系统随笔（二）、浅谈场寻路Flow Field PathFinding算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处http://www.cnblogs.com/zblade/　今天给大家带来一篇游戏中寻路算法的博客。去年，我加入一款RTS的游戏项目，负责开发其中的战斗系统，战斗系统的相关知识，属于游戏中比较繁杂的部分。今天就说说其中的寻路的实现思想，当然，由于牵涉工作保密，我不会贴出核心代码，那么就用简单的意向代码表达核心思想即可：D
博客写的慢，马上又要国庆了，下一篇等我国庆放完假再回来更新吧~
一、游戏中的常用寻路算法
说到寻路算法，很多人的第一反应就是A*算法，是的，这是正常的反应，而且A*已经在一些游戏中论证了其实用性。无论是基本的A*算法还是后期基于A*的优化算法，以及延伸出来的变异算法，比如B*、JPS算法等，都对游戏的寻路算法做到了极大的推动作用。下面我会给出一个基本优化版本的A*算法原理及初步代码。
在一般的单机游戏中，或者ARPG，亦或是优化比较好的MMORPG游戏中，基于A*优化的寻路都可以满足基本的寻路要求。但是在多人RTS游戏中，如果同屏几十上百个玩家，每个玩家进行一次寻路，就会消耗10-20ms左右，那么累积下来的时间损耗就会很大。而我做的RTS游戏又是一款帧同步的游戏，如果我们锁定帧数为30/s，那么游戏中的对象每帧的更新频率在33ms左右，如果分出10-20ms用于寻路，那么，只能看游戏对象寻路了，其他的战斗系统都运行不起来了：D
基于这样的考虑，只有Pass通用的A*算法，我们采用的是Unity3D的游戏引擎，那么，自然就会考虑下一个对象：Unity中自带的Navigation寻路。这确实是一个比较优秀的寻路组件，unity内部封装的组件，而且做了一系列的优化，执行的效率比较高。具体的Navigation介绍，可以参考这篇文章：unity navigation社区index/,， 这儿，我就不过多的深入讨论这个寻路组件了。由于我们采用的是帧同步的同步机制，对于每个游戏对象的计算都是在各个客户端计算，为了确保计算结果的一致，需要确保各自的寻路计算是一致的。如果采用navigation，那么不一定能确保在不同的机型下计算得到的寻路节点一致，如果出现寻路节点不一致，就会在不同的机型上出现同一个游戏对象不同的寻路行为，从而引发一系列的不同步，最终这局游戏被判定为作弊Orz
文章说到这儿，也许有的同仁会给出其他的寻路解决办法，可以留言在下面，一起学习。
接着说，这时候否定了Unity自带的navigation组件，感觉思维似乎走到一个节点了。如果深入的优化A*，最终效果也似乎在10ms左右，不能稳定的符合游戏的设计。这时候，偶然发现一个论坛，其中讨论了《军团要塞》这款游戏的寻路。军团要塞游戏中，也是类似的RTS游戏，会出现同屏几十上百个战斗单位，进行寻路和AI操作。其中的寻路算法就是V社自己提出的场寻路算法Flow Field PathFinding。不得不说RTS游戏对于寻路算法的贡献是不可忽略的，针对多人同屏操作的性能优化，其中的重头戏就是寻路的优化。这儿给出查阅到的场寻路算法的链接：flow-field-pathfinding/
在这篇文章中，大概讲述了场寻路算法的思想，当然我没有逐字细看，不过其基本思想大概了解，基于此，我进一步查找了相关的算法，找到国外的一个RTS论坛，得到一些启发：如何开启一款RTS游戏， 在其中提到了Flow Field算法，并给出一定的实现代码。虽然并不是完全的代码，而且由于和AI控制中的steeringBehaviour混合在一起，初期还有一定的迷惑性，后来我结合项目的基本节点刷新，利用其中提到的Dijkstra算法的进一步优化，总算推导出文章中所提到的寻路思想。
二、两种寻路算法的基本原理和实现代码
1、A*算法及其优化
这儿说的A*算法，是针对格子类型的地图的寻路算法，现在有很多讲解A*算法的文章，可以参考很多的文章，其核心的思想是对两张列表的操作，开放表openset和关闭表closeset，用一个列表pathSet作为路径点列表。其基本的函数： F = G + H， 这儿就不再赘述，可以查看相关的算法讲解。
这儿，我就用大概的思维代码来列举A*的基本过程吧：
1） 设置初始点 startPoint， 目标点endPoint，地图相关的数据：宽度width，高度height，地图对应的各个格子的阻挡与否数据mapData；
2） 首先将初始点塞入开放表openset，计算其F，如果对计算不做优化，H可以用哈曼计算，计算其直线距离即可；
3） 做一个循环判断，判断条件是openset表中元素个数为0，此时跳出判断；
4） 进入循环判断，取出openset表的第一个元素current，判断其是否为重点，如果是，则寻路完成，对路径表pathset进行操作，得到最后的路径链表；
5） 将该点从openset表移除，塞入到closeset中，更改相关标记；
6） 以current为中心，寻找周边8个方向（具体方向上下左右及四个对角方向），在取点的时候做一个可行走判断，只塞入可行走的区域点，得到neighborPoints;
7）对neighborPoints点进行逐个计算和判断，首先，不在closeset表中，然后计算当前标准点current到当前节点neighbor代价F1，如果小于当前节点neighbor的代价，则设置为新的路径点，进行下一个操作8)
8）在该操作中，对于当前节点neighbor，首先将当前标准点current，然后更新当前节点neighbor的消耗为F1，更新其消耗F为F1+H(neighbor，endPoint), 接着进行下一步操作9）
9）在这步操作中，主要是当前节点neighbor塞入到openSet中，然后即可进行一次堆排序，当然是最小堆排序，这样保证openSet的第一个元素永远是消耗最小的节点。返回到步骤7）中
10）步骤7的neighborPoints都遍历完后，返回到步骤4）
最后，要么我们找到了到目标点的路径，要么没有路径点，这就是整个A*的算法过程，其中的优化一个是采用数据结构的方式，动态设置每个节点在openSet还是closeSet，一个是采用堆排序的方法保持openSet的第一个元素一定为消耗最小的临近点。
下面我就再次用我的灵魂写法，写一个基本的代码思路吧， 哈哈：
A* F = G + H 1. startPoint/endPoint/width/height/mapData 初始化 2. openset/closedset/pathSet 初始化 3. startPoint-&gt;openset 4. while openset.length &gt; 0 基本循环 5. current = openset[1] 取首节点 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc6b6477ee091b8d9ab2530e803f7ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29afc4f588a7c3df6e96cd1991901bc/" rel="bookmark">
			Android MimeTypeMap使用--MIME类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MimeTypeMap使用--MIME类型 首先创建通过单例获取到MimeTypeMap的对象。 MimeTypeMap mimeTypeMap = MimeTypeMap.getSingleton(); 判断这个集合中是否存在这个MIME类型。 mimeTypeMap.hasMimeType("text/html"); 判断集合中是否存在该扩展名的类型。 mimeTypeMap.hasExtension("txt"); 获取该扩展名的MIME类型。 mimeTypeMap.getMimeTypeFromExtension("mp4"); 获取该MIME类型的扩展名。 mimeTypeMap.getExtensionFromMimeType("video/mpeg"); MimeTypeMap中支持的类型（Android 2.2）： sMimeTypeMap.loadEntry("application/andrew-inset", "ez"); sMimeTypeMap.loadEntry("application/dsptype", "tsp"); sMimeTypeMap.loadEntry("application/futuresplash", "spl"); sMimeTypeMap.loadEntry("application/hta", "hta"); sMimeTypeMap.loadEntry("application/mac-binhex40", "hqx"); sMimeTypeMap.loadEntry("application/mac-compactpro", "cpt"); sMimeTypeMap.loadEntry("application/mathematica", "nb"); sMimeTypeMap.loadEntry("application/msaccess", "mdb"); sMimeTypeMap.loadEntry("application/oda", "oda"); sMimeTypeMap.loadEntry("application/ogg", "ogg"); sMimeTypeMap.loadEntry("application/pdf", "pdf"); sMimeTypeMap.loadEntry("application/pgp-keys", "key"); sMimeTypeMap.loadEntry("application/pgp-signature", "pgp"); sMimeTypeMap.loadEntry("application/pics-rules", "prf"); sMimeTypeMap.loadEntry("application/rar", "rar"); sMimeTypeMap.loadEntry("application/rdf+xml", "rdf"); sMimeTypeMap.loadEntry("application/rss+xml", "rss"); sMimeTypeMap.loadEntry("application/zip", "zip"); sMimeTypeMap.loadEntry("application/vnd.android.package-archive", "apk"); sMimeTypeMap.loadEntry("application/vnd.cinderella", "cdy"); sMimeTypeMap.loadEntry("application/vnd.ms-pki.stl", "stl"); sMimeTypeMap.loadEntry("application/vnd.oasis.opendocument.database", "odb"); sMimeTypeMap.loadEntry("application/vnd.oasis.opendocument.formula", "odf"); sMimeTypeMap.loadEntry("application/vnd.oasis.opendocument.graphics", "odg"); sMimeTypeMap.loadEntry("application/vnd.oasis.opendocument.graphics-template", "otg"); sMimeTypeMap.loadEntry("application/vnd.oasis.opendocument.image", "odi"); sMimeTypeMap.loadEntry("application/vnd.oasis.opendocument.spreadsheet", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f29afc4f588a7c3df6e96cd1991901bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8434136e80537be7bd3c95751338f6fc/" rel="bookmark">
			vue axios同步请求解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue项目里面，需要循环发送ajax请求，出现的问题就是循环结束，第一次服务器还没返回，导致数据处理错误，需要使用同步请求
解决方案
目前没有发现axios可以同步请求，所以只能使用jQuery，配置同步请求；
$.ajax({ url:'/comm/test1.php', type:'POST', //GET async:false, //或false,是否异步 data:{ name:'yang',age:25 }, timeout:5000, //超时时间 dataType:'json', //返回的数据格式： beforeSend:function(xhr){ }, success:function(data,textStatus,jqXHR){ }, error:function(xhr,textStatus){ }, complete:function(){ } }) vue 安装jQuery插件
$ npm install jquery --save 打开 build/webpack.base.conf 配置文件
配置完成后，在需要组件使用import $ from 'jquery';
就可以使用！
方法二
.使用promise
例子：浅谈 : Promise使用解析
加入我的技术群，一起学习
707196135
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a34a0d4424af2773092222c42ded62c1/" rel="bookmark">
			动画（Animation）来回变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;动画（Animation）来回变换&lt;/title&gt;
&lt;style&gt;
@-webkit-keyframes 'myAnimation'{
/* 1.从左至右滑动 */
/* 0% {
margin-left: 100px;
background: green;
}
40% {
margin-left: 250px;
background: orange;
}
60% {
margin-left: 350px;
background: blue;
}
100% {
margin-left: 1000px;
background: red;
}*/
/* 2.从上至下滑动 */
0% {
margin-top:: 100px;
background: green;
}
40% {
margin-top: 250px;
background: orange;
}
60% {
margin-top: 350px;
background: blue;
}
100% {
margin-top: 1000px;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a34a0d4424af2773092222c42ded62c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec300779ae94516d67bf417d81b5df5c/" rel="bookmark">
			Ubuntu 中采用 update-alternatives 配置软件多版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址《Ubuntu 中采用 update-alternatives 配置软件多版本》 我的博客 http://tramp.cincout.cn/ 摘要 在 Debian 系统，比如 Ubuntu 中，经常会出现一个软件安装多个版本或类别的需求，而在使用时可以方便的切换。update-alternatives 就是用来在 Debian 系统中维护系统命令连接符的工具。 通过一定的设置，可以实现系统自动的选择最新的软件版本或最合适的软件类别。比如，维护系统的多个JDK 的版本；维护editor 命令所对应的编辑工具是 vim 或 emacs。 命令介绍 基本的命令格式 在Ubuntu 的终端中输入 man update-alternatives 就可以查看该命令的详细使用信息。
命令的基本格式：
update-alternatives [option...] command install 命令 install 命令用来增加一组新的系统命令连接符。
update-alternatives --install link name path priority [--slave link name path]... sudo update-alternatives --install /usr/bin/java java /usr/local/java/jdk-9/bin/java 1702 link 系统中功能相同的软u件的公共链接目录。比如 /usr/bin/javaname 命令连接符在alternatives 目录的名字path 需要被链接的软件的目录，比如/usr/local/java/jdk-9/bin/javapriority 优先级，数值越大优先级越高。当alternative 为 auto 模式时，系统会自动选择优先级高的软件slave slave 创建的链接从属某一个主链接。 查看命令 display update-alternatives --display name 用来展示某一个 name 的包含的链接的详细信息。包括模式、优先级以及当前最佳的软件版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec300779ae94516d67bf417d81b5df5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f645d93914e168df08b169b5dcb5b41/" rel="bookmark">
			Excel 数字按长度补0，并转换为文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补齐8位，前面补0 公式：
=REPT(0,8-LEN(A2))&amp;A2 因为单纯的改为数字（单元格格式，自定义，示例8个0），只是显示8位，实际导入数据库的时候还是实际的位数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33aed7d479810f5ed80d32255e49ae5d/" rel="bookmark">
			MySQL-日期字符串（****年**月**日 格式）转Date类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 如题，简单说明一下此需求出现的背景。通过爬虫在互联网上抓取的一些数据中包含年月日格式的日期数据，并且没有对日期进行处理，直接以varchar数据类型保存到了MySQL数据库中。
但是，后期在对这些数据进行分组统计时，字符串格式的日期处理起来并不是很方便。因此有了这篇文章，希望可以帮到有需要的朋友。 解决方案 在MySQL关于处理日期和时间的函数中找到了它：
STR_TO_DATE(str,format)
但是，这个函数处理的日期字符串中并不包含“年月日”的格式，直接处理会返回Null值。所以我们先把“年月日”格式的字符串转换为 STR_TO_DATE 可以处理的字符串。比如可以使用 REPLACE 函数把字符串中的“年月日”替换为“-”。
REPLACE(REPLACE(REPLACE(releaseDate,'年','-'),'月','-'),'日','') 然后再用 STR_TO_DATE 函数把字符串转换为 Date类型。
str_to_date(REPLACE(REPLACE(REPLACE(releaseDate,'年','-'),'月','-'),'日',''),'%Y-%m-%d') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776f44a64676b5a7ecd3993434f2b6b1/" rel="bookmark">
			打印金字塔，1 121 12321 1234321 123454321
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序示例，代码如下：
void main() { int i,j,k,m; for(i=1;i&lt;=5;i++){ //打印行数,共5行 for(j=1;j&lt;=5-i;j++){ printf(" "); //打印每行的空格数 } for(k=1;k&lt;=i;k++){ //打印前半部分 printf("%d",k); } for(m=i-1;m&gt;0;m--){ //打印后半部分 printf("%d",m); } printf("\n"); //换行 } system("pause"); } —————————— 2017.09.27 00：40
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7a2dcd37fcaf1611532370dc07e655/" rel="bookmark">
			如果你恨他，就让他去做AWS云计算吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你恨他，就让他去做AWS云计算吧（转）
前言：AWS云计算领域一度被VC很看好，然而事实证明，AWS云计算依旧属巨头之争。
AWS云计算领域，一度被风投所追捧。
2020年，我们看到中国公有云服务总市场规模达到 50 亿美元，比 2014 年同比增长 53.8%
IDC预计，2020 年之前企业对 IaaS 的需求依然强烈，复合年增长率达到 36.6%，PaaS 平台的复合年增长率为 38%，SaaS 为 28%，整个公有云市场以每年 32.2% 的速度增长。
然而，几年下来，当结果开始明朗的时候，我们开始为中国电子商务巨头开始拥有自己的高增长、高利润率的云业务而欣慰，也为很多中小云服务商的节节退败而悲哀。
面对巨头，这条路依旧艰巨。
因此，如同你恨他，那么就让他做AWS吧。
巨头攒动与中小企业的悲哀
作为AWS行业的一个IT技术男，A近期频繁接到猎头的电话。
在一个又一个电话的背后，A感觉到了行业的火热。
然而，作为一家创业公司的技术总监，其实，A并没有太多离职的想法。作为一个海归，在回国后在BAT公司都有过工作经验之后，他已经适应了国内创业的氛围，实在适应不了外企的节奏了。
或许，钱并不是他这种技术人才所看中的东西。
创始人是他的朋友，他有义务帮助哥们。
但是，他也同时感受到了创业的艰难，面对BAT及国际巨头的涌入，留给他们这种创业公司的机会不多了。
“这些公司的产品一再降价，这给我们小公司提供带来不小的压力，而且从工资待遇上来说，我们也不能跟他们竞争，虽然我不太考虑工资，但是大部分员工都会比较。”A找到GPLP君，狠狠骂了一下BAT们。
2014年开始，AWS这个行业内，各家的竞争激烈起来，2014初阿里云第一次降价时，这让行业开始轰动，结果阿里云一年六次降价。而在阿里云的带动下，行业竞品基本上都开始降价。
2016年，伴随着巨头阿里云的强势发力，行业更是发展到了赤身肉搏的时候，彼此之间不断混战，短兵交接，咬牙厮杀。
当中也包括A所在的创业公司，只不过，每次竞争之后，他们的盈利遥遥无期，很多企业，比如多次融资的七牛云等被迫转型，由公有云转到了私有云。
这让A对巨头不得不爱恨交加。不过。骂完之后，A开始自言自语，这是行业的问题，AWS本就是资金及技术密集型的产业——如同房地产生意，前期投入巨大，成长周期漫长。要继续玩下去，他们还要布局更加高端、适合大型企业的技术和服务，中小云平台公司还要过人才关、技术关和运营关，这一切都需要钱。
追坚持到最后，谁才有可能像电信公司一样，尝到寡头垄断的甘甜。
当技术不再成为决战的主要因素的时候，迟迟不能盈利的创业公司则希望渺茫，不光他们这种创业公司，即便BAT之间，竞争也异常激烈，也有可能因为战略而掉队。
让我们看这个行业的参与者：
归根结底，在中国做云计算的不外乎以下三类公司：第一是大公司系，除了BAT，还有360云、京东云等等，目前除了BAT，这些公司大多以服务母公司为主；第二是Ucloud之类的创业公司，未来面对BAT的夹击，最好的选择只能是做好自己的细分，等待被收购；第三类是AWS、Azure之类的外来户，技术上确实有一定优势，但是由于政策的限制，很难有真正的发展空间。
换句话说，乱世出英雄，就看你够不够拼。
因此，AWS的激烈竞争之下，面对巨头的步步进攻，很多创业企业要么负重前行，快速前进，要么倒闭在血泊中，车轮之下，多少有点悲凉。
其中包括身为巨头的百度与腾讯。
一失足千古恨，而他们仅仅因为一个战略失误。
2010年的深圳IT峰会上，李彦宏说云计算是新瓶装旧酒，马云说不做云计算就会死，而马化腾则认为云计算将变成水电一样的基础设施但实现还要上百年。
如今他们都为此付出了代价。
在这个市场当中，据德银的报告统计，阿里巴巴云计算规模是腾讯的10倍，百度的30倍。
“腾讯百度在思想和行动上的落后给了阿里太多的机会去扩大领先幅度。对于我们来说，也相当于失去了选择的机会，只能削减脑门往阿里挤。
第二梯队里，作为基础供应商的联通电信还是有不少的份额的，作为国企能做到这样已经算不错了；
第三梯队里，3年前就入华的AWS上个月才拿到“居民身份证”，此前一直水土不服，现在增速很快，不久后应该就会进入第二阵营，甚至跟阿里云交锋。”
事实如此吗?
巨头之争
对于经历了云计算从0到1过程的人，应该不难感觉到，全球云计算市场已经越来越往亚太地区倾斜，欧洲是最排斥云计算的地区，美国的大型科技企业又自信到不屑用云计算，唯独亚洲这个新兴市场，一枝独秀，对云计算有强烈的需求。
因此，中国也就成了兵家必争之地。
谷歌、亚马逊、微软都开始进军中国。
英特尔的服务器业务正在高速增长，其中，约有30%的客户云计算公司，也就是说，在英特尔的200个客户中，前7家云计算领域公司的芯片需求量占到了三分之一，这7家公司分别是谷歌、亚马逊、微软、Facebook、百度、阿里巴巴和腾讯。
而从亚马逊自身来讲，在此行业耕耘了十年，他们不过才尝到甜头——2015财年第一财季，AWS营收为15.7亿美元，高于2014年同期的11亿美元。此外，在2015年的前三个月，AWS为亚马逊带来了2.65亿美元的利润，营业利润率为17%。
一直以来，因对短期利润缺乏兴趣而闻名的亚马逊，在AWS的帮助下，在硅谷的鼻子底下建立了一个快速增长的现金牛形象。
自那以后，AWS一直在继续提供服务。在2017年第二季度，AWS的销售额为28.9亿美元。在2016年第二季度的表现中，这一增幅达到了令人瞠目的42%。该部门的运营收入惊人的9.16亿美元。
而阿里巴巴，或许可以说是亚马逊的中国学徒。
只不过，它学的还不错，而且比较快的成长起来。
2017年8月17日，阿里巴巴公布其半年报，在惊人的总收入74亿美元当中，没有人注意到默默无闻的AWS业务，虽然仍处于起步阶段，但该部门的营收增长近100%，已经达到3.59亿美元。
而且，这家公司正在布局海外，在海外设立了8个数据中心。
师傅与徒弟的直面竞争不可避免。
然而，一个不容忽视的现实则是，亚马逊的中国之路并不容易。早在两年前，亚马逊就开始尝试在华开展业务，其间经历了两种擦边球的运营模式——「前店后厂」和「有限预览」模式。最终，在牌照问题上纠缠了两年后，2016年9月份，亚马逊才以光环新网代运营的方式在中国获得了合法身份。
不过，由光环新网代运营的机房，AWS无权进行管理，技术支持能力有限，这让亚马逊苦不堪言。因为数据中心所有的安装，部署，排错，包括后续的运维，技术支持等工作均由光环新网来处理，但他们并不具备处理问题的技术能力。
此外，腾讯云的步步追赶也让行业并不平静。
虽然比阿里云起步晚了三年，然而目前升势明显。
据腾讯2017年6月30日公布的第二季度财报现实，在来源于支付相关服务及云服务收入的增长方面，这部分业务同比增长177%。
据其公开资料显示，“云服务是腾讯战略布局的重点方向之一，今年腾讯云在全球范围进一步扩展其基础设施的覆盖范围，目前在全球已有34个可用区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf7a2dcd37fcaf1611532370dc07e655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca8fd34747141770fe52c5d30b03fe3/" rel="bookmark">
			golang实现微信公众号发送代金券及获取代金券的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps：在读代码前一定要先阅读微信公众号发红包官方文档：
https://pay.weixin.qq.com/wiki/doc/api/tools/sp_coupon.php?chapter=12_3&amp;index=4
说明：批次号是在微信商户平台配置号系统自动生成的
package server import ( "time" "math/rand" "strconv" "strings" "github.com/alecthomas/log4go" "fmt" "encoding/xml" "net/http" "io/ioutil" "encoding/hex" "bytes" "crypto/md5" "crypto/tls" "crypto/x509" "sort" "reflect" ) var ( _tlsConfig *tls.Config sendCouponUrl = "https://api.mch.weixin.qq.com/mmpaymkttransfers/send_coupon" queryCouponInfo = "https://api.mch.weixin.qq.com/mmpaymkttransfers/querycouponsinfo" CashCouponRequestStr = "CashCouponRequest" formatDate = "20060102" weixinPayKey="19200bbb0b4c09247ec02edce69f6ddd" //微信密钥 weixinMchId = "10000098" //微信商户号 xmlStr = "xml" strWeixinAppId =	"wx8888888888888888" //公众账号ID strWeixinClientCertPemPath = "/home/apiclient_cert.pem" //客户端证书存放绝对路径 strWeixinClientKeyPemPath = "/home/apiclient_key.pem" //客户端私匙存放绝对路径 strWeixinRootCaPath = "/home/rootca.pem" //服务端证书存放绝对路径 ) type WeixinSendCoupon struct { } //公众号代金券请求实体 type CashCouponRequest struct { CouponStockId	string `xml:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca8fd34747141770fe52c5d30b03fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124f436af37435c5741725e443d065a5/" rel="bookmark">
			golang实现微信公众号发红包功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps：在读代码前一定要先阅读微信公众号发红包官方文档：
https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_4&amp;index=3
以下是代码实现，
package server import ( "crypto/tls" "fmt" "io/ioutil" "crypto/x509" "net/http" "bytes" "strings" "sort" "reflect" "time" "math/rand" "strconv" "encoding/xml" "github.com/alecthomas/log4go" "crypto/md5" "encoding/hex" ) var _tlsConfig *tls.Config var ( weixinPayKey="19200bbb0b4c09247ec02edce69f6ddd" //微信密钥 weixinMchId = "10000098" //微信商户号 wechatUrl = "https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack" //请求发红包的地址 formatDate = "20060102" xmlStr = "xml" RedPacketRequestStr = "RedPacketRequest" strWeixinAppId = "wx8888888888888888" //公众账号ID strWeixinClientCertPemPath = "/home/apiclient_cert.pem" //客户端证书存放绝对路径 strWeixinClientKeyPemPath = "/home/apiclient_key.pem" //客户端私匙存放绝对路径 strWeixinRootCaPath = "/home/rootca.pem" //服务端证书存放绝对路径 ) type WeixinSendRedPacket struct { } //发红包的请求实体 type RedPacketRequest struct { ActName string `xml:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124f436af37435c5741725e443d065a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1d9abb16670b1f4607976d3dc598f7/" rel="bookmark">
			GMapping源码分析之随手笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GMapping代码分析的随手笔记记载如下： 参考博客： http://blog.csdn.net/roadseek_zw/article/details/53316177 gmapping分析
都说最好的理解就是说出来让别人听懂，所以我也写下我的分析来加深自己的理解，同时给刚刚入门的同学们带个头。这一篇是我对gmapping源码的分析与理解(刚入门，难免有错，欢迎指正，相互学习)。恩，现在还只是大概的分析，还有很多代码没有懂，由于博主不需要很深入的研究SLAM，所以只是浅浅的谈一下，不喜勿喷。
首先我们从Slam_gamping-hydro-devel包的主函数开始看起：
int main(int argc, char** argv) { ros::init(argc, argv, "slam_gmapping"); SlamGMapping gn; gn.startLiveSlam(); //这里进入slam_gammping.cpp的startLiveSlam()函数 ros::spin(); return(0); } 我们看一下startLiveSlam函数：
void SlamGMapping::startLiveSlam() { entropy_publisher_ = private_nh_.advertise&lt;std_msgs::Float64&gt;("entropy", 1, true); sst_ = node_.advertise&lt;nav_msgs::OccupancyGrid&gt;("map", 1, true); sstm_ = node_.advertise&lt;nav_msgs::MapMetaData&gt;("map_metadata", 1, true); ss_ = node_.advertiseService("dynamic_map", &amp;SlamGMapping::mapCallback, this); scan_filter_sub_ = new message_filters::Subscriber&lt;sensor_msgs::LaserScan&gt;(node_, "scan", 5); scan_filter_ = new tf::MessageFilter&lt;sensor_msgs::LaserScan&gt;(*scan_filter_sub_, tf_, odom_frame_, 5); scan_filter_-&gt;registerCallback(boost::bind(&amp;SlamGMapping::laserCallback, this, _1)); //从这里进入同一个文件的laserCallback函数 transform_thread_ = new boost::thread(boost::bind(&amp;SlamGMapping::publishLoop, this, transform_publish_period_));// line 339 } SlamGMapping::laserCallback, this, _1)); //从这里进入同一个文件的laserCallback函数 transform_thread_ = new boost::thread(boost::bind(&amp;SlamGMapping::publishLoop, this, transform_publish_period_));// line 339 } SlamGMapping::laserCallback(const sensor_msgs::LaserScan::ConstPtr&amp; scan) { laser_count_++; if ((laser_count_ % throttle_scans_) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1d9abb16670b1f4607976d3dc598f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8f2365701549d180c4f024f13446b1/" rel="bookmark">
			压测tps很低并且呈下降趋势，原因解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：我们项目测试是分为两台服务器，暂且定位A服务器和B服务器
A服务器是用来功能测试和安全测试的，B服务器是用来压力测试的。
问题：压测人员在进行项目一分钟并发测试的时候，发现tps只有20多，并且呈现持续下降现象。
原始分析：
情况一：日志输出爆满，服务器压力扛不住----------清理日志
情况二：有引用第三方接口---------第三方接口日志清理
解决：
1).首先清理压测服务器的日志，清理完之后，还是很慢呈现下降趋势。
2).清理第三方接口日志，tps提高了点，但是还是20多，并且依然呈现下降趋势。
最后解决：
将第三方接口注释掉，就可以了达到了200多
因为压测的第三方接口是在功能测试的服务器上，而功能测试服务器是不能用来压测的，所以在高并发的情况下，服务器压力持续增大，并出现饱和的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d146b569d41c83f4e12a0cca252a678/" rel="bookmark">
			数据挖掘十大经典算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十大经典算法 1）C4.5 决策树是一种依托决策而建立起来的一种树。是一种预测模型，代表的是一种对象属性与对象值之间的一种映射关系。每一个节点代表一个对象，树中的每一个分叉路径代表某个可能的属性值，而每一个叶子节点则对应从根节点到该叶子节点所经历的路径所代表的对象的值。决策树可以有单一输出，也可以有多个输出。 C4.5是一种分类决策树算法，核心算法是ID3算法，是对其的改进。 ID3（Iterative Dichotomiser 3）算法的原理是越是小型的决策树越优于大的决策树，引入信息论中的信息增益来作为判别因素的度量，也就是以信息熵的下降速度作为选取测试属性的标准，所选的测试属性是从根节点到当前节点的路径上尚未被考虑的具有最高信息增益的属性。然后继续这个过程，直到生成的决策树能够完美分类训练样例。 信息熵可以表示信息的价值。也就是衡量信息价值高低的标准。 变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。 一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。所以，信息熵也可以说是系统 有序化程度的一个度量。 C4.5继承了ID3算法的有点，并在以下一方面对ID3进行了改进： 1）用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足； 2）在树构造过程中进行剪枝； 3）能够完成对连续属性的离散化处理； 4）能够对不完整数据进行处理。 核心思想： 以信息增益率为衡量标准实现对数据归纳分类 优点：产生的分类规则易于理解，准确率较高； 缺点：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。 应用领域： 临床决策、生产制造、文档分析、生物信息学、空间数据建模等 2）K-means算法 K-means是一个聚类算法。把n个对象根据它们的属性分成k个类，k&lt;n。与处理混合正态分布的最大期望算法相似，都是试图找到数据中自然聚类的中心。它假设对象属性来自于空间向量，并且目标是使各个群组内部的均方误差总和最小。 步骤： 选择K个点作为初始质心 repeat 将每个点指派到最近的质心，形成K个簇 重新计算每个簇的质心 until 簇不发生变化或达到最大迭代次数 时间复杂度：O(tKmn)，其中，t为迭代次数，K为簇的数目，m为记录数，n为维数 空间复杂度：O((m+K)n)，其中，K为簇的数目，m为记录数，n为维数 目标函数一般为最小化对象到其簇质心的距离的平方和 K-means算法试图找到使平凡误差准则函数最小的簇。 如何确定k呢？ 大致提供几种方法： 1）与层次聚类结合： 首先采用层次凝聚算法决定结果粗的数目，并找到一个初始聚类，然后用迭代重定位来改进该聚类。 2）稳定性方法：对一个数据集进行2次重采样产生2个数据子集，再用相同的 聚类算法对2个数据子集进行聚类，产生2个具有k个聚类的聚类结果，计算2个聚类结果的相似度的分布情况。2个聚类结果具有高的相似度说明k个聚类反映了稳定的聚类结构，其相似度可以用来估计聚类个数。采用次方法试探多个k，找到合适的k值。 3）系统演化方法： 将一个数据集视为伪热力学系统，当数据集被划分为K个聚类时称系统处于状态K。系统由初始状态K=1出发，经过分裂过程和合并过程，系统将演化到它的稳定平衡状态Ki，其所对应的聚类结构决定了最优类数Ki。系统演化方法能提供关于所有聚类之间的相对边界距离或可分程度，它适用于明显分离的聚类结构和轻微重叠的聚类结构。 核心思想： 输入聚类个数k，以及包含n个数据对象的数据库，输出满足方差最小标准的k个聚类 优点： 当潜在的簇形状是凸面的，簇与簇之间区别较明显，且簇大小相近时，其聚类结果较理想。前面提到，该算法时间复杂度为O(tKmn)，与样本数量线性相关，所以，对于处理大数据集合，该算法非常高效，且伸缩性较好。 缺点： 要事先确定簇数K和对初始聚类中心敏感外，经常以局部最优结束，同时对“噪声”和孤立点敏感，并且该方法不适于发现非凸面形状的簇或大小差别很大的簇。 应用领域： 图片分割，分析商品相似度进而归类商品，分析公司的客户分类以使用不同的商业策略 3）支持向量机SVM SVM是一种监督式学习的方法，它广泛的应用于统计分类以及回归分析中。支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个相互平行的超平面。分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。 核心思想： 建立一个最优决策超平面，使得该平面两侧距离平面最近的两类样本之间的距离最大化，从而对分类问题提供良好的泛化能力 优点： 更好的泛化能力，解决非线性问题的同时避免维度灾难，可找到全局最优 缺点： 运算效率低，计算时占用资源过大 应用领域： 遥感图像分类，污水处理过程运行状态监控等 4）Apriori算法 Apriori算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，所有支持度大于最小支持度的项集称为频繁项集，简称频集。 其核心思想是通过候选集生成和情节的向下封闭检测两个阶段来挖掘频繁项集。 使用一种称作逐层搜索的迭代方法，“K-1项集”用于搜索“K项集”。 首先，找出频繁“1项集”的集合，该集合记作L1。L1用于找频繁“2项集”的集合L2，而L2用于找L3。如此下去，直到不能找到“K项集”。找每个Lk都需要一次数据库扫描。 挖掘步骤： 1.依据支持度找出所有频繁项集（频度） 2.依据置信度产生关联规则（强度） 支持度： P(A ∩ B) ，既有 A 又有 B 的概率 置信度：P(B|A)，在A发生的事件中同时发生B的概率 p(AB)/P(A) 例如购物篮分析：牛奶 ⇒ 面包 核心思想： 基于两阶段频集思想挖掘关联规则的算法 算法优点： 简单、易理解、数据要求低 算法缺点： I/O负载大，产生过多的候选项目集 应用领域： 消费市场价格分析，入侵检测，移动通信领域 5）最大期望算法（EM） 在统计计算中，最大期望（EM，Expectation–Maximization）算法是在概率（probabilistic）模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variabl）。最大期望经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。 核心思想： 通过E步骤和M步骤使得期望最大化 算法优点： 简单稳定 算法缺点： 迭代速度慢，次数多，容易陷入局部最优 应用领域： 参数估计，计算机视觉的数据集聚 6）Pagerank Pagerank是Google算法的重要内容。根据网站的外部链接和内部链接的数量和质量俩衡量网站的价值。PageRank背后的概念是，每个到页面的链接都是对该页面的一次投票，被链接的越多，就意味着被其他网站投票越多。这个就是所谓的“链接流行度”——衡量多少人愿意将他们的网站和你的网站挂钩。PageRank这个概念引自 学术中一篇论文的被引述的频度——即被别人引述的次数越多，一般判断这篇论文的权威性就越高。 核心思想： 基于从许多优质的网页链接过来的网页，必定还是优质网页的回归关系，来判定所有网页的重要性 算法优点： 完全独立于查询，只依赖于网页链接结构，可以离线计算 算法缺点： 忽略了网页搜索的时效性；旧网页排序很高，存在时间长，积累了大量的in-links，拥有最新资讯的新网页排名却很低，因为它们几乎没有in-links 应用领域：页面排序 7）Adaboost Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器 (强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权 值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。 核心思想： 针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器) 算法优点： 高精度，简单无需做特征筛选，不会过度拟合 算法缺点： 训练时间过长，执行效果依赖于弱分类器的选择 应用领域： 广泛应用于人脸检测、目标识别等领域 8）KNN K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。 核心思想： 如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别 算法优点： 简单，无需估计参数，无需训练，适合于多分类问题 算法缺点： 计算量较大；可解释性较差，无法给出决策树那样的规则 应用领域： 客户流失预测、欺诈侦测等（更适合于稀有事件的分类问题） 9）朴素贝叶斯 在众多的分类模型中，应用最为广泛的两种分类模型是决策树模型(Decision Tree Model)和朴素贝叶斯模型（Naive Bayesian Model，NBC）。朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。在属 性个数比较多或者属性之间相关性较大时，NBC模型的分类效率比不上决策树模型。而在属性相关性较小时，NBC模型的性能最为良好。 核心思想： 通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类 算法优点： 算法简单，所需估计的参数很少，对缺失数据不太敏感 算法缺点： 属性个数比较多或者属性之间相关性较大时，分类效率下降 应用领域： 垃圾邮件过滤，文本分类 10）CART：分类与回归树 CART, Classification and Regression Trees。在分类树下面有两个关键的思想。第一个是关于递归地划分自变量空间的想法；第二个想法是用验证数据进行剪枝。算法采用一种二分递归分割的技术，将当前的样本集分为两个子样本集，使得生成的的每个非叶子节点都有两个分支。因此，CART算法生成的决策树是结构简洁的二叉树。 核心思想： 以基于最小距离的尼基指数估计函数为衡量标准对数据进行递归分类 算法优点： 抽取规则简便且易于理解；面对存在缺失值、变量数多等问题时非常稳健 算法缺点： 要求被选择的属性只能产生两个子节点；类别过多时，错误可能增加的较快 应用领域： 信息失真识别，电信业潜在客户识别，预测贷款风险等等 CART与C4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d146b569d41c83f4e12a0cca252a678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4184d0f9826a9dabca43ce31e8b3167/" rel="bookmark">
			LSD(Line Segment Detector)直线提取算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LSD是2010年发表在ipol上的一篇论文提出的直线提取算法，在较短的时间内可以提取一张灰度图上所有的线段特征。 (文中提到了a contrario model 和 Helmoholtz principle，在这篇文章中并没有进行讲解) LSD算法是基于梯度的，但是为了减少梯度的依赖性，LSD算法也做了一些必要的优化措施，所以它的流程如下。 1. 首先，对图片进行一次高斯降采样，缩小图片 1.1. 降采样要解决的问题 通过降采样可以减缓或解决图像中出现的混叠与量化伪像问题（特别是阶梯效应） 混叠问题是使不同的信号成为不可区分的效果（或别名彼此的）时采样。它也指失真或伪影，其导致当从样品中重建的信号是从原始连续信号不同。 而另一个问题，阶梯效应实际上就是锯齿问题，图像在边缘处常常显示成锯齿状，所以需要通过降采样解决这个问题。 可以看到在降采样前，这两种边缘处提取的线段，第一张提取的是分段的线段，而本应是完整的一条线，而第二张则是连线段都没有提取出来。 而在降采样之后，两种线段均提取的较为正常了
1.2. LSD降采样的方法 该LSD算法中默认的降采样比例是0.8，那意味着，X轴Y轴各降采样0.8，而总像素降采样0.64。所以如果我们在计算NFA值的时候，使用的是N*M的图像的话，那么输入图像的分辨率应该是1.25N*1.25M。并且在LSD算法的降采样中，使用的是高斯降采样，通过使用高斯内核过滤图像以避免混叠然后进行次采样。公式求得的是高斯内核标准偏差，S是缩放因子。
2. 计算梯度 LSD梯度的计算利用每像素点的右边下方的四个像素进行计算。这样做，主要是尽可能少的使用其他像素，可以减少对梯度的依赖性，这样对有噪声的图像更具有鲁棒性。计算梯度是为了记录明暗变化，从而找到可能有线段边缘的地方。 图像中由明转暗和由暗转明处的线段方向是不同的，呈180度差距，那就意味着如果一张图片倒置其明暗，使用LSD算出的线段依旧是那些线段，但是头与尾是颠倒过来的。 并且因为梯度计算只用到了右下方的像素，所以计算出来的梯度并不是(x,y)点的梯度，而是(x+0.5,y+0.5)的梯度。
3. 梯度伪排序 排序算法一般最快的也是O(nlogn)时间复杂度的，但是如果我们使用伪排序就可以将时间缩短到O(n)线性时间内，而伪排序并不是真正的进行了梯度的排序，只是对梯度值按照他们的分布进行一定程度的排序。
LSD算法的排序算法基于贪心算法，先从0到最大梯度之间分成1024个等份，再从这1024个分段中每个分段取一个种子像素，以用来进行排序，因为1024已经可以将0~255分成很细的段了，所以伪排序虽然不是真正的排序，但是效率很高。
4.梯度的阈值 计算完梯度之后，会发现，如果一张图像中有些小梯度区域表现非常均匀，由于值的量化，那里的像素就会表现出更高的误差，那么设定如果梯度小于某一个阈值ρ就被抛弃并将不再用于线段区域的构建。 假设存在理想图像i和量化噪声n
我们可以观察到，当角度误差小于容忍值的时候，我们就接受这个像素，，等式的右边是容忍度，q是 |▽n| 的边界，容忍度我们用τ来表示，所以可以得到。一般来说，我们设定q = 2。 5. 区域更新 RegionGrow 我们当前像素计算完梯度之后，会得到一个像素的方向，而由像素构成的line区域也会有一个方向，我们便可以通过这两个方向之间的差距，判断该像素是否可以被纳入到直线区域中。
从排序列表中选择一个NOT USED像素作为种子点，检查在当前像素周围的领域像素内那些未使用的像素点中，LLA(Level-line-angle)和区域角度之间的差值在容忍值τ 内话，将会被加入到该line support region区域中。而区域初始角度就是种子点的LLA，每次加入一个新像素到区域中的时候，区域角度就通过下面的公式对整个直线区域更新一次(其中j是遍历时的像素下标)： 误差容忍值默认被设为22.5，那就意味着对于整个区域矩形来说，误差容忍度是45度，22.5这个值是通过实验得出的经验值。
区域更新的流程： 6. 矩形近似计算 上面在规划区域后，我们要将该区域进行矩形近似计算，以求得一个较为规整的直线区域。 一个直线段对应一个矩形，在评估line support region之前，直线对应的矩形应该被找出来，并可以用公式计算矩形的中心： G(j)是像素j的梯度值，j代表区域内的每一个像素点 矩形的角度，被设为特征向量的角度，而这个特征向量与下面M矩阵的最小特征值有关 7. NFA值计算 字面上解释，Number of False Alarms指的是误报数，也就是原本并不是直线但是被当做直线的地方。 因为矩形是有方向的，所以他们的起始点和终止点的排序实际上是有很多种可能的，这样看的话，从A点到B点，和从B点到A点实际上是不同的两个线段。所以我们要考虑到所有起始点终止点的可能性，在一张降采样后，N*M的图像上，我们的点有NM个所以就有可能有NM x NM种搭配的矩形，并且矩形线的线宽有√(NM)种。 所以我们的矩形线段就会有种可能性。
我们用二项分布来表示测试数据。 我们将p的初值设为τ/π，并用γ来表示p的不同值的可能数量。那么最终的测试数量是
我们用一个阈值ε来对NFA值进行过滤，并且如果一个矩形满足 NFA(r,i)&lt;=ε 那么这个矩形被称作ε-meaningful 矩形。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4184d0f9826a9dabca43ce31e8b3167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6705486c3519fc93576ca2a88432c08f/" rel="bookmark">
			Google KickStart的一些理解和学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google KickStart之翻煎饼
题目的大致意思就是读取一个文件,在文件的第一行输入文件的行数,然后读取这些数据,在每一行的数据中第一部分由一个由+(happy side)/-(blank side)组成的字符串,
每一行数据的第二部分为一个整型变量,表示每次可以翻面的个数,且每次翻面必须为这个个数,那么如果可以将这些煎饼全部翻面成为+(happy side)向上,则打印出需要翻面
的次数,否则打印出"IMPOSSIBLE".
官方给出的解题思路是通过判断可以选择放铲子的地方一共由N-K+1,其中N为第一行中字符串的长度,K为第一行中整数的值(即每次翻面的煎饼的个数),
在官网download了一份加拿大ACM选手的答案(C++版本,感觉做算法还是C++好),在题目中遍历的过程中遍历的取值范围即为for(j=0;j+K-1&lt;N;j++),
因为每次翻面的煎饼的个数为K,所以每次需要调整K个煎饼的状态,for(int m=0;m&lt;K;m++),这里出现了一个一开始很费解,理解之后觉得很神奇的地方:
chars[j+m] ^='-'^'+'(这里是我用Java语言复现的结果,原来版本的代码为str[i+j] ^='-'^'+'),这里利用了抑或相互抵消的原理,将原来的状态变为相反的状态;
至于在官网解析中提到的可以用一个count标志位来计数,每次计数到奇数则将count加1,如果计数到偶数,则将count减1,这个操作还是不甚理解
(通过这种方式来减少时间复杂度,原本的时间复杂度为O(n^2),改进以后为O(n)???).
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f00dbe1329840eaf9f1986c1ba8bce/" rel="bookmark">
			Thinkpad 各系列简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ThinkPad 各系列简介 如果提到商务笔记本，大家一定会想到凭借坚固和可靠的特性在业界享有很高声誉ThinkPad笔记本电脑，以及ThinkPad那经典的键盘红点设计和纯黑低调的外表。 在这里我就简单介绍一下ThinkPad的各系列产品。
Thinkpad名称来历 “ThinkPad”这个名称的灵感来自IBM的便笺簿。每一位IBM的雇员或到IBM训练中心受训的人，都会拿到一本便笺簿（“便笺簿”英文为“pad”），上面印着企业的座右铭“THINK”。在一次讨论便携式电脑产品名称的会议上，一名与会者随手将一本这样的便笺簿甩到半空然后落在了会议桌上，另一名与会者受此启发提出可以用“ThinkPad”这个名称。起初IBM高层一度反对使用这个名称，因为以前IBM一直使用数字为标识产品型号。但是“ThinkPad”这个名称受到广大雇员和客户的极大欢迎和喜爱，最终IBM高层妥协同意使用“ThinkPad”作为产品名称。
T系列 ThinkPad的旗舰机型，可以说是Thinkpad的精华所在，相当轻薄，但在追求轻薄的同时并不损失其强大的配置。因其定位为高端商务笔记本，所以在包含了ThinkPad大部分技术的同时，还专门为商务人士提供了例如指纹解锁，人脸扫描识别，双电池续航等独有技能。可以说是Thinkpad的最高品质的系列，拥有不错的配置和各种独门绝技，以及高端大气的外观成为商务精英们的宠儿。（当然价格也是ThinkPad各系列中最贵的）代表产品有 T470 T570 X系列 X系列是以极致的轻薄著称的，但与T系列不同，X系列的轻薄是以损失性能为代价的。X系列的设计是以减小体积和重量优先的，所以X系列多为12.1或13.3英寸机型标准屏，使用外置光驱，并且减少了大量接口。为了提升续航能力大多采用的是低压版的CPU，显卡也只是集成的。拥有这些特点的X系列受到那些经常在室外工作，出差较多的工作者们的青睐。 代表产品有 X260 X270 W系列 W系列定位为高端工作站机型，它搭载了最好的显卡和处理器，是性能最强的系列。曾推出过17寸机型（现已停产） 它拥有最好的性能和扩展力，适用于密集图形设计、影视特效制作等高端领域。因此这系列的机型都是专为视图设计师，图像工作者设计。代表产品有 W400 W500 E系列 由于Thinkpad出色的做工和自身定位一直很高的原因，Thinkpad的价格也一直偏高，其各系列都位于高端市场。而E系列的出现就标志着Thinkpad向低端市场的覆盖。更加接地气的价格意味着E系列无论从做工性能都不如其他系列的机型。E系列定位为中低端的入门商务本，为了降低成本采用了与传统ThinkPad的金属外壳不同的塑料外壳，散热，内部设计方面都较次，而且与同配置机型相比又大又重。（感觉我一直在吐槽E系列，但是便宜也是优点啊） 适合没有明确用途的学生党。 S系列 S系列是ThinkPad笔记本主打时尚商务的一个系列。S系列在设计上打破了ThinkPad传统的纯黑设计，推出了银色等新配色，还有360°旋转屏幕等潮流设计。S系列的定位很模糊，但是他们共同的特点是在继承ThinkPad简约高端血统的同时，抛开了ThinkPad只能商务的印象。如去年最新推出的黑将S5，就被定位为游戏本（虽然运行大型游戏还是有些吃力，我亲身体验过）价格不低但也不像T系列那么贵，性价比是ThinkPad各系列中较高的，不像其他系列那样适用人群很单一，商务办公游戏娱乐都行。 感谢各位的阅读，希望这篇博客能让你们对ThinkPad各系列有所了解，文章中有不准确的观点也请谅解，ThinkPad还有一些系列我并没有介绍，上面的T W X E S介绍的也有些简略。如果你看了我的文章后还想更多了解ThinkPad的相关消息，可以去其他地方看看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a61971703a0849a3503b807e8db644d/" rel="bookmark">
			黑群晖(XPEnology)无法启动&amp;重建系统并保留数据经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预备知识 本篇所涉及到的技术主要涉及fdisk磁盘管理、mdadm软阵列管理与lvm逻辑卷管理，不熟悉这方便知识的朋友请先打开鸟叔的Linux私房菜学习下相关知识。 鸟哥Linux私房菜 - 磁盘配额、阵列、逻辑卷管理，点击这里打开；LVM逻辑卷管理相关命令 - 点击这里打开 防爬虫专用，作者的主要博客地址：点击这里, 全路径：blog.csdn.net/littlebrain4solving。
情况说明 由于不知什么情况导致/dev/md0阵列丢失(查看下面异常图片)，而里面的磁盘内容是装着群晖的系统，群晖SHR2原理会在每个物理硬盘上分区创建一个2G的分区组成RAID1(这样每个硬盘中都会存在一份拷贝的系统)，但我没找到更好的恢复方式，查了很多方式只有手动把/dev/md0进行了重建，然后再利用群晖的Synology Assistant进行系统重装，最后恢复了系统并且磁盘其他的数据也没有丢失，虽然系统之前的预设程序和用户设置丢失了，但是总算是恢复了系统并且保留了数据。
提示：我主要查看引导U盘的syslinux.cfg发现/dev/md0作为引导进入系统设备，具体可以打开你们的U盘查看APPEND参数内容，另外引导中有些LABEL可以自定义，并且我Google看有些人好像可以在引导中隐藏U盘设置（进行到系统中后）。
步骤说明 由于我有两块硬盘，所以群晖系统各分区了/dev/sda1与/dev/sdb1进行组RAID1，当然在某种情况下我是推测的(根据所查询的资料)，我就利用以下命令，针对这两块分区进行了RAID1阵列重建,mirror表示RAID1，有多少块硬盘的话也请根据命令调整--raid-devices数量，分区数与此选项一定要一致。
mdadm --create /dev/md0 --level=mirror --raid-devices=2 /dev/sda1 /dev/sdb1 注意：执行上述命令之前，请使用一个空闲的U盘烧一个Ubuntu的live/CD,或任意一个Debian变种的live/CD即可；因为群晖也是Debian的变种之一。
然后，重启电脑利用U盘的引导系统启动，选择第一个菜单，当加载完毕之后，再打开Synology Assistant自动检测到主机，然后右键Install,输入预设密码，顺着安装原来的*.PAT即可。
注意事项 在使用Ubuntu Live/CD的时候不会自动扫描加载已存在的阵列（重要数据设备内容），因为mdadm套件没有安装，所以需要先安装然后再手动扫描已存在的历史阵列信息，参考下面命令；另外注意的是所有最终的挂载设备都是由LVM2进行管理的。
apt-get install -y mdadm mdadm -Asf &amp;&amp; vgchange -ay lvs 为了确保数据没有丢失的话，可以利用LVM2相关的命令把设备挂载到某个目录中进行查看，参考下面挂载。
lvdisplay mkdir /volume1 mount /dev/vg_volume1/volume1 /volume1 ls /volume1 结论 当熟悉了群晖的磁盘管理的方式之后（其实我想就是和群晖的reset重置功能的逻辑类似），我想其实我们可以利用这一知识对系统进行升级处理（保留原始数据盘数据），我这里由于时间的关系就不做这样的测试了。
参考资料 https://www.ibm.com/developerworks/cn/linux/l-cn-raid2/index.html https://www.ibm.com/developerworks/cn/linux/l-cn-raid/index.html http://cn.linux.vbird.org/linux_basic/0420quota.php#raid_what http://www.cnblogs.com/hzl6255/p/3341374.html
SEO synology /sbin/e2fsck exists, checking /dev/md0… 1.42.6-5565: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY. /sbin/e2fsck returns 4, move into netowrk install… Checking upgrade file Killed
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de14d7e1e2acf4df991510f477422eb/" rel="bookmark">
			Linux下权限问题：chmod -R 777 /usr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 chmod能改变权限，-R是目录下所有文件，777就是高权限（读、写、执行） chmod -R 777 * 意思就是将当前目录下所有文件都给予777权限 这个在服务器里不能随便敲的，不能在根目录下进行此命令，因为有些进程是指定权限（如755、700...）才能运行的...所以会出错. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2206495c8943b971eaea5de9a65ff319/" rel="bookmark">
			有符号整、小数的原、反、补码表示范围，及补码比原、反码多表示一位的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mark一下。 以n位机器码为例。 1. 原码： 有符号整数：[-(2^n-1), 2^n-1]; 有符号小数：[-(1-2^(-n)), 1-2^(-n)]; 2. 反码的表示范围和原码相同 3. 补码 有符号整数：[-2^n, 2^n-1]; 有符号小数：[-1, 1-2^(-n)];
从上我们可以看出，有符号数的补码要比原码和反码多表示出一位来，那么究竟是为什么呢？
补码比原码、反码多出一位的原因： 以8位机器码表示的有符号整数为例，它可以表示的原码和反码范围是[-127, 127]，而可以表示的补码范围是[-128, 127]。 原码和反码的±0是不同的表示方法，即： +0：00000000 -0 ：10000000 而反码的±0都是同一个表示方法，同样以8位机器码为例： ±0 ：00000000 因此补码中便多出了一个&lt;10000000&gt;，可以用来表示其他的数，此处即可以表示真值为-128。在最位的1，既表示负号、又表示数值位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2724f5273b06296d347daf613c10a589/" rel="bookmark">
			PC制做gif动图超简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 有时候我们在PC端需要录制桌面操作，比如操作说明，一些有趣的视频画面等。
录制成视频，保存发送很麻烦，我们希望能做成gif动图，这样既方便，占用空间还小。
具体，请继续观看下文！
工具 1.FSCapture录屏软件
强烈推荐的录屏神器，小巧方便。10几秒的视频只有200多kb。
下载链接：http://www.pc6.com/softview/SoftView_49203.html
2.video-to-gif
由于FSCapture录屏后是视频文件，不是想要的gif动图。我们需要使用工具转为gif。
不用下载多余的工具，直接网站https://ezgif.com/video-to-gifFSCapture.exe
使用教程 开启录屏功能 下载完成后，解压，运行FSCapture.exe
点击下图红框位置。
选择录屏模式 录制 点击上图左下角录制。
然后选择合适的区域，点击开始。
按Ctrl+F10停止，然后点击保存，保存到指定位置。
保存后的视频文件。
mmv格式转gif 打开网页https://ezgif.com/video-to-gif
选择刚才录制好的视频文件，点击upload上传。
设置起始时间和属性后，点击Convert to GIF！
图中就是转换后的gif格式图片了。可以右键保存到电脑，或者右键复制链接发给别人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c133cb0b6250986729bb301de7a097/" rel="bookmark">
			c&#43;&#43;使用vector来保存程序数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做图像检测，检测出角点后输出ponit（i，j），数据类型为cv::Point::Point_(int_x, int_y)，希望存入数组继续使用，使用vector来保存，主要代码如下：
...
#include &lt;vector&gt;
...
using namespace std;
...
vector&lt;int&gt; data_x;//声明变量
vector&lt;int&gt; data_y;//
data_x.push_back(i);//将数据存入数组
data_y.push_back(j);
...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c0cee8464b72178d245a4155d1524e/" rel="bookmark">
			curl 模拟表单发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 初始化一个curl
$ch = curl_init();
// 设置相应的会话选项
$url = "http://localhost/index2.php";
$postDate = array(
'title' =&gt; '哈哈哈',
'content' =&gt; '今天是周五',
);
// 设置提交的网址
curl_setopt($ch,CURLOPT_URL,$url);
// 设置数据提交方式
curl_setopt($ch,CURLOPT_POST,1);
// 设置数据
curl_setopt($ch,CURLOPT_POSTFIELDS,$postDate);
curl_exec($ch);
curl_close($ch);
参考资料 : http://www.blogfshare.com/php-curl-get-post.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5cb84752e7146708e217412de17280/" rel="bookmark">
			Adaboost人脸检测介绍（都是大白话）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
人脸检测属于计算机视觉的范畴，早期人们的主要研究方向是人脸识别，即根据人脸来识别人物的身份，后来在复杂背景下的人脸检测需求越来越大，人脸检测也逐渐作为一个单独的研究方向发展起来。目前的人脸检测方法主要有两大类：基于知识和基于统计。基于知识的方法主要利用先验知识将人脸看作器官特征的组合，根据眼睛、眉毛、嘴巴、鼻子等器官的特征以及相互之间的几何位置关系来检测人脸。基于统计的方法则将人脸看作一个整体的模式——二维像素矩阵，从统计的观点通过大量人脸图像样本构造人脸模式空间，根据相似度量来判断人脸是否存在。
基于知识的人脸检测方法：
Ø 模板匹配
Ø 人脸特征
Ø 形状与边缘
Ø 纹理特性
Ø 颜色特征
基于统计的人脸检测方法：
Ø 主成分分析与特征脸
Ø 神经网络方法
Ø 支持向量机
Ø 隐马尔可夫模型
Ø Adaboost算法
本文介绍的Haar分类器方法，包含了Adaboost算法，言归正传。
Haar特征
&gt;&gt; 最早的Haar特征由Papageorgiou C.等提出（《A general framework for object detection》）
&gt;&gt; 之后Paul Viola和Michal Jones提出利用积分图像法快速计算Haar特征的方法（《Rapid object detection using a boosted cascade of simple features》）
&gt;&gt; 之后Rainer Lienhart 和 Jochen Maydt用对角特征对Haar特征库进行了扩展（《An extended set of Haar-like features for rapid object detection》）
&gt;&gt; 目前OpenCV的Haar分类器就是基于扩展后的特征库实现的
Haar特征本身并不复杂，就是用图中白色矩形所有像素值的和减去黑色矩形所有像素值的和。目前Haar特征共有如下种：
Haar特征个数的计算
看过Rainer Lienhart文章的人知道，Rainer Lienhart在文章中给出了计算特定图像面积内Haar特征个数公式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be5cb84752e7146708e217412de17280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eaaa7a3b1569936fe370c3df3c53400/" rel="bookmark">
			linux下卸载显卡驱动以及重新安装显卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux下安装了nvidia 显卡驱动之后，遇到过开机一直是循环登录的状态，或者双屏模式只有一个主显示屏能正常启动的情况。于是决定卸载显卡驱动。
如果是循环登录的时候： 1. 进入循环登录的界面后，按住Ctrl+Alt+F1（听说F1～F6都行） 2. 进入Ubuntu命令行界面，输入用户名和密码就可以进行卸载驱动或者其他操作。
下面我们将介绍卸载驱动及重新加载驱动的过程： （默认你已经下载好了cuda_6.5.14_linux_64.run 下载CUDA 6.5）
首先，按 ctrl+alt+F1 进入tty， 登录tty后输入如下命令关闭图形界面：
sudo service lightdm stop 然后，卸载nvidia显卡驱动。注意此时千万不能重启，重新电脑可能会导致无法进入系统。
sudo apt-get remove nvidia* 然后，安装显卡驱动
sudo sh cuda_6.5.14_linux_64.run 最后，重启后安装cudnn, 进入解压后的cuda所在的目录。
sudo cp lib* /usr/local/cuda/lib64/ sudo cp cudnn.h /usr/local/cuda/include/ 参考链接： Ubuntu 解决登录界面无限循环的方法 Ubuntu 64bit + CUDA7.0卸载+ CUDA 6.5 安装配置 NVIDIA CuDNN 安装说明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e573a862496c7210542d2c53c5458a/" rel="bookmark">
			std::string replace详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string类的替换函数： std::string replace详解 string &amp;replace(int p0, int n0,const char *s); //删除从p0开始的n0个字符，然后在p0处插入串s。如果从p0开始的n0个字符已经超过了字符串的最大长度，则将字符串p0后续的所有字符都删除，然后再插入字符串s。
string &amp;replace(int p0, int n0,const char *s, int n); //删除p0开始的n0个字符，如果从p0开始的n0个字符已经超过了字符串的最大长度，则将字符串p0后续的所有字符都删除，然后在p0处插入字符串s的前n个字符。如果字符串的长度小于n，则将字符串s所有的字符插入到原始字符串中。
string &amp;replace(int p0, int n0,const string &amp;s); //删除从p0开始的n0个字符，如果从p0开始的n0个字符已经超过了字符串的最大长度，则将字符串p0后续的所有字符都删除，然后在p0处插入串s
string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n); //删除p0开始的n0个字符，如果从p0开始的n0个字符已经超过了字符串的最大长度，则将字符串p0后续的所有字符都删除，然后在p0处插入串s中从pos开始的n个字符。如果s从pos开始到结尾没有n个字符，则将s从pos开始的所有字符都插入到原始字符串中。
string &amp;replace(int p0, int n0,int n, char c); //删除p0开始的n0个字符，如果从p0开始的n0个字符已经超过了字符串的最大长度，则将字符串p0后续的所有字符都删除，然后在p0处插入n个字符c
string &amp;replace(iterator first0, iterator last0,const char *s); //把[first0，last0）之间的部分替换为字符串s。
string &amp;replace(iterator first0, iterator last0,const char *s, int n); //把[first0，last0）之间的部分替换为s的前n个字符
string &amp;replace(iterator first0, iterator last0,const string &amp;s); //把[first0，last0）之间的部分替换为串s
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e573a862496c7210542d2c53c5458a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77ed0568cff73cf47c1194dbef4be73/" rel="bookmark">
			数据库——SQL中like与通配符的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 like语法的格式是：select * from 表名 where 字段名 like 对应值（子串） 常见的通配符有%、_、[ ]、*、[^]、-、？、#、[!]等，使用时用单引号。
下表显示了使用 LIKE 关键字和 [ ] 通配符的示例
符号含义LIKE ‘5[%]’%5LIKE ‘[_]n’_nLIKE ‘[a-cdf]’a,b,c,d或fLIKE ‘[-acdf]’-,a,c,d或fLIKE ‘[ [ ]’[LIKE ‘]’]LIKE ‘abc[_]d%’abc_d和abc_deLIKE ‘abc[def]’abcd、abce 和 abcf 举例： LIKE ‘_u’ –选取名字的第一个字符之后是 “u” 的人Xu LIKE ‘Ad%’ –Ad开头 LIKE ‘%[fk]%’ –包含f或者k LIKE ‘[m-o]%’ –以m,n,o开头 LIKE ‘a[^d]%’ –以a开头，第二个字母不为d
以下是常见通配符及说明：
通配符描述%替代零个或多个字符_(下划线)替代单个字符[ ]指定范围 ([a-f]) 或集合 ([abcdef]) 中的任何单个字符[^]不属于指定范围 ([a-f]) 或集合 ([abcdef]) 的任何单个字符 还有其他常见的通配符：
通配符含义举例*多个字符,它同于DOS命令中的通配符，代表多个字符c*c代表cc,cBc,cbc,cabdfec等[*]特殊字符，代替*a[*]a代表a*a？同于DOS命令中的？通配符，代表单个字符b?b代表brb,bFb等#只能代表单个数字k#k代表k1k,k8k,k0k[!字符]字符排外[!a-z]代表9,0,%,*等[!数字]数字排外[!0-9]代表A,b,C,d等-指定一个范围中任意一个[a-z]代表a到z的26个字母中任意一个字符[范围类型]字符组合类型可和其他几种方式组合使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fdceb771885b3fe85002be0c488bbf/" rel="bookmark">
			实验一线性表的基本操作实现及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 1、熟悉掌握线性表的结构特点，掌握顺序表的基本操作。 2、巩固c++相关的程序设计方法与技术。 3、学会使用顺序表解决实际问题。 二、实验内容 1、顺序表的建立与操作实现。 三、实验步骤 1、依据实验内容分别说明实验程序中用到的数据类型的定义； 2、相关操作的算法表达； 3、完整的程序； 4、总结、运行结果和分析。 5、总体收获和不足。疑问等。 四、源代码 #include &lt;iostream&gt; using namespace std; const int MaxSize=10; class SeqList { public: SeqList() {length=10;} SeqList(int a[],int n); ~SeqList(){} void Insert(int i,int x); int Delete(int i); int Locate(int x); void PrintList(); private: int data[MaxSize]; int length; }; SeqList::SeqList (int a[],int n) { if(n&gt;MaxSize) throw"非法参数"; for(int i=0;i&lt;n;i++) data[i]=a[i]; length=n; } void SeqList::Insert (int i,int x) { if(i&lt;1||i&gt;length) throw"位置非法"; for (int j=length;j&gt;=i;j--) data[j]=data[j-1]; data[i-1]=x; length++; } int SeqList::Delete (int i) { if(i&lt;1||i&gt;length) throw"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2fdceb771885b3fe85002be0c488bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51c92eb23d77a08857a8061a94f62ec/" rel="bookmark">
			统计学简介之十——样本量的确定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 统计学简介之十——样本量的确定 一、总结 二、估计总体均值时样本量的确定 三、估计总体比例时样本量的确定 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52afe2e8afa3d8bc9f50c13a9c82fa8b/" rel="bookmark">
			React Native - 持久化存储（AsyncStorage）的使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，基本概念 1，AsyncStorage介绍 AsyncStorage 是一个简单的、异步的、持久化的 Key-Value 存储系统，它对于 App 来说是全局性的。它用来代替 LocalStorage。由于它的操作是全局的，官方建议我们最好针对 AsyncStorage 进行一下抽象的封装再使用，而且不是直接拿 AsyncStorage 进行使用。AsyncStorage 存储的位置根据系统的不同而有所差异。iOS 中的存储类似于 NSUserDefault，通过 plist 文件存放在设备中。Android 中会存储在 RocksDB 或者 SQLite 中，取决于你使用哪个。 2，相关方法 （1）根据键来获取值，获取的结果会放在回调函数中。 1 static getItem(key: string, callback:(error, result)) （2）根据键来设置值。 1 static setItem(key: string, value: string, callback:(error)) （3）根据键来移除项。 1 static removeItem(key: string, callback:(error)) （4）合并现有值和输入值。 1 static mergeItem(key: string, value: string, callback:(error)) （5）清除所有的项目 1 static clear(callback:(error)) （6）获取所有的键 1 static getAllKeys(callback:(error, keys)) （7）清除所有进行中的查询操作。 1 static flushGetRequests() （8）获取多项，其中 keys 是字符串数组，比如： ['k1', 'k2'] 1 static multiGet(keys, callback:(errors, result)) （9）设置多项，其中 keyValuePairs 是字符串的二维数组，比如： [['k1', 'val1'], ['k2', 'val2']] 1 static multiSet(keyValuePairs, callback:(errors)) （10）删除多项，其中 keys 是字符串数组，比如： ['k1', 'k2'] 1 static multiRemove(keys, callback:(errors)) （11）多个键值合并，其中 keyValuePairs 是字符串的二维数组，比如： [['k1', 'val1'], ['k2', 'val2']] 1 static multiMerge(keyValuePairs, callback:(errors)) 二、使用样例 1，效果图 （1）在文本输入框中输入姓名、电话后，点击“ 保存”按钮即可通过 AsyncStorage 存储起来。 （2）退出程序后再次打开，程序又会自动加载之前保存的信息。 （3）点击“ 清除”按钮则将本地保存的数据全部清除。 2，样例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 import React , { Component } from 'react' ; import { AppRegistry , StyleSheet , Text , View , TextInput , AsyncStorage } from 'react-native' ; //用户信息填写组件 class UserInfo extends Component { //构造函数 constructor(props) { super (props); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52afe2e8afa3d8bc9f50c13a9c82fa8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760f03ef1e708a4a26910b3595e41f33/" rel="bookmark">
			SQL Server报表服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server报表服务：基于服务器的平台，用来创建、管理和发送报表。也可以使用SQL Server创建、分发和管理报表。
1、启动SSRS服务
步骤：我的电脑-&gt;管理-&gt;服务和应用程序-&gt;Sql Server配置管理器-&gt;Sql Server服务-&gt;Sql Server(MSSQLSERVER)右键启动服务
2、创建报表服务器项目
步骤：（1）打开Microsoft SQL Server 2008 -&gt; SQL Server Business Intelligence Developement Studio 启动开发平台。
（2）文件-&gt;新建-&gt;项目-&gt;新建项目-&gt;商业智能项目-&gt;报表服务器项目-&gt;确定
3、建立数据源
步骤：视图-&gt;解决方案资源管理器-&gt;右击“共享数据源”-&gt;添加新数据源-&gt;弹出共享数据源属性-&gt;点击编辑-&gt;显示“连接属性”-&gt;在服务器名框中，用户输入要连接的数据库服务器名称（127.0.0.1,1483）-&gt;用户选择或者输入一个数据库名-&gt;测试连接-&gt;确定之后会产生DataSource1.rds文件。
4、建立报表
步骤：解决方案资源管理器-&gt;报表-&gt;右键添加新报表-&gt;下一步-&gt;在共享数据源框中，选择刚建立的数据源-&gt;下一步-&gt;点击“查询生成器”-&gt;SELECT 输入列名 FROM 输入表名-&gt;确定，下一步-&gt;弹出选择报表类型界面，用户根据所需要选择报表的生成方法（表格/矩阵）表格，下一步-&gt;下一步-&gt;下一步-&gt;输入报表名称-&gt;完成。
打开数据集-&gt;DataSet1-&gt;右键列名，字段属性-&gt;可以对列进行修改。
5、运行报表
在“解决方案资源管理器”中，点击“报表”-&gt;右键“运行”。
生成报表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173556ffb0fc79a11d30c2f8cb07788c/" rel="bookmark">
			emWin界面刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在对话框回调函数中定时重绘按键
_cbDialogHome(WM_MESSAGE* pMsg) { Switch(pMsg -&gt; MsgId){ Case WM_INIT_DIALOG: WM_CreateTimer(pMsg -&gt; hWin,0,100,0);//创建窗口定时器 Case WM_PAINT: //窗口重绘 Case WM_NOTIFY_PARENT://按键消息处理 Id = WM_GetId(pMsg -&gt; hWinSrc);//哪个按键 NCode = pMsg -&gt; Data.v;//是点击还是松开 Switch(Id){ Case ID_BUTTON_0: Switch(NCode){ Case WM_NOTIFICATION_CLICKED://点击 Case WM_NOTIFICATION_RELEASED://松开按钮 } } Case WM_TIMER: WM_RestartTimer(pMsg -&gt; Data.v,100);//重启定时器，因为窗口定时器是单次的 If( I % 10 == 0 ){ WM_InvalidateWindow(pMsg -&gt; hWin);//使窗口无效，重绘整个窗口 }else{ hItem = WM_GetDialogItem(pMsg -&gt; hWin, ID_BUTTON_0);//获取按键句柄 WM_InvalidateWindow(hItem);//使按键无效，重绘按键 } } } 2、在按键回调函数中刷新按键图片
_cbButtonStart(WM_MESSAGE* pMsg){ Switch(pMsg -&gt; MsgId){ Case WM_PAINT: WM_GetClientRect(&amp;Rect);//获取按键矩形 If(BUTTON_IsPressed(hWin)){//按键按下 }else { GUI_DrawStreamedBitmapAuto(imgLocate[IMG].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/173556ffb0fc79a11d30c2f8cb07788c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e916c040876cd1220e42756acd8075/" rel="bookmark">
			H3C交换机配置ACL禁止vlan间互访
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先把基础工作做好，就是配置VLAN，配置Trunk，确定10个VLAN和相应的端口都正确。假设10个VLAN的地址分别是192.168.10.X，192.168.20.X。。。。。。192.168.100.X，与VLAN号对应。
2、为第一个VLAN 10创建一个ACL，命令为
ACL number 2000
这个2000号，可以写的数是2000-2999，是基本的ACL定义。
然后在这个ACL下继续定义rule，例如
rule 1 deny source 192.168.20.0
rule 2 deny source 192.168.30.0
rule 3 deny source 192.168.40.0
rule 4 deny source 192.168.50.0
rule 5 deny source 192.168.60.0
rule 6 deny source 192.168.70.0
rule 7 deny source 192.168.80.0
rule 8 deny source 192.168.90.0
然后进入VLAN接口
interface vlan 10
在vlan 10接口下，启用上面定义的规则：
packet-filter outbound ip-group 2000
这应该就可以了，其它VLAN也按这个方法定义。
这一句：packet-filter outbound ip-group 2000 设备有可能不支持，那你就得换种方法定义ACL，使用3000-3999之间的扩展ACL定义：
rule 1 deny destination 192.168.20.0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68e916c040876cd1220e42756acd8075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f954be880688bf88a52c5510fb8f486/" rel="bookmark">
			Microsoft SQL Server Management Studio数据库不能附加与分离问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先提一下这个软件的安装，感觉很操蛋，跟office差不多，如果是第一次安装，那么就是傻瓜式的，如果不是第一次安装，就会存在卸载不干净的问题，这会直接导致安装失败，我这次安了整整一天，第一次双击快捷方式没等进去就报错，第二次进去之后不能创建数据库等操作，第三次狠心把所有相关的东西全部删除粉碎安装成功！
2.先说分离，分离的时候可能会报3703的错误，有看过开发文档的应该会特别留意错误码这东西，去百度了一下找到了解决办法，在删除链接的选项上选中即可
操作的结果是弹出下面的对话框
之后又用附加的方式重新添加了这个数据库，操作正常。
3.现在来说附加，这个东西就有点坑了，我刚开始还以为是自己的软件装的有问题，后来还是查错误码找到解决办法，但是我在学校机房的时候是没有做下面的操作的，具体原因还不清楚，明天去机房机子上看看
1.首先说错误码：5120错误，可以自己百度
2.打开该数据库文件的属性窗口，选择“属性”菜单-&gt;选择“安全”标签-&gt;选择“编辑”按钮。（这是我随便找的个文件截的图）
3.在选择组或用户名列表中，选择Authenticated Users，在权限列表中选中完全控制。
4.选择"确定"按钮关闭对话框
5.重新进行附加操作，测试成功。
LDF文件也这么改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dba69c8832d82ea96e97d7060c0ca0b/" rel="bookmark">
			phpcms转到https后无法注册问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		phpcms/modules/member/classes/client.class.php 中361行增加
$port = !empty($matches['port']) ? $matches['port'] : ( strtolower($matches['scheme'])=='https' ? 443 : 80 ); 中386行
$fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout); 替换为
$contextOptions = array( 'ssl' =&gt; array( 'verify_peer' =&gt; false, 'verify_peer_name' =&gt; false ) ); //如果有签名的证书 //$contextOptions = array( // 'ssl' =&gt; array( // 'verify_peer' =&gt; true, // 'cafile' =&gt; '/path/to/cacert.pem', // //'CN_match' =&gt; 'indexroot.net', // 匹配域名 // 'ciphers' =&gt; 'HIGH:!SSLv2:!SSLv3', // 'disable_compression' =&gt; true, // ) //); $context = stream_context_create($contextOptions); $fp = stream_socket_client("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dba69c8832d82ea96e97d7060c0ca0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b765d66af6268edb4aaa62a77d2fa58b/" rel="bookmark">
			sqluldr2的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击查看全文
有时候需要导出Oracle表数据到文本中用来迁移数据、异构平台或大数据的数据处理。导出方法有很多种，例如：spool、plsql-developer、utl_file方法等，除了这些方法，还有一个工具很火就是sqluldr2，老楼开发的工具。现在对这些工具做个对比和总结。 一、数据导出工具概览 1、spool spool工具在sqlplus中随时可以使用，较为灵活，通过sqlplus的格式设置处理，字段分割利用sql语句拼成，能迅速导出一些小数据量的需求。因为是配合sqlplus，它可以支持本地和客户端的数据导出，但是效率不高。 2、plsql-developer plsql-developer工具只是个代表，还有很多工具可以连接数据库，进行导出操作，从交互配置中完成需要导出的数据设置。它也可以支持本地和客户端的数据导出，效率高于spool。 3、utl_file方法 utl_file方法是oracle提供的文件读写包，该方法需要一定的编写存储过程和sql的能力，而且需要指定读写路径，因此只能在服务器本地生成文件，若大量导出，还需要完成文件的传输。 4、sqluldr2 老楼开发的软件，基于OCI，使用非常方便，就是一个可执行文件配合参数命令，类似expdp等的命令行使用方法，支持自定义sql、本地和客户端的导出，效率非常高。 前三个方法都能轻松找到使用方法，本次实测sqluldr2。 二、sqluldr2的测试使用 1、获取工具 下载：http://www.onexsoft.com/software/sqluldr2linux64.zip 上传解压即可使用 2、工具的参数 user = username/password@tnsname sql = SQL file name query = select statement field = separator string between fields record = separator string between records rows = print progress for every given rows (default, 1000000) file = output file name(default: uldrdata.txt) log = log file name, prefix with + to append mode fast = auto tuning the session level parameters(YES) text = output type (MYSQL, CSV, MYSQLINS, ORACLEINS, FORM, SEARCH).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b765d66af6268edb4aaa62a77d2fa58b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/069c47b6e315239aa8c7a0b9eb40af55/" rel="bookmark">
			vim打造成PYTHON IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VIM基础设置 1 基础学习资料2 验证vim的安装 插件管理 vim默认的插件安装方式通过插件Vundle来管理插件 界面美化文件系统与工程管理代码阅读与分析代码开发其他辅助参考资料 1. VIM基础设置 1.1 基础学习资料 vimtutor入门学习, vim用户手册与参考手册
在shell下直接运行 $ vimtutor就可以使用vimtutor来进行入门练习。vim usr_doc与reference 可以在vim命令行中使用 :help 来查询使用。
一本关于vim核心技巧的书：Vm实用技巧 (Practice Vim: Edit Text at the Speed of Thought) 包含了编辑技巧，快速移动技巧，文件管理技巧以及编程相关技巧，以vim提供的核心功能为基础，基本不涉及额外插件的使用
vi/vim使用进阶 http://easwy.com/blog/archives/advanced-vim-skills-catalog/
基础vim scripting
笨方法学Vimscript
1.2 验证vim的安装 $ vim --version VIM - Vi IMproved 7.4 (2013 Aug 10, compiled Nov 24 2016 16:42:57) Included patches: 1-52 Extra patches: 8.0.0056 Modified by pkg-vim-maintainers@lists.alioth.debian.org Compiled by buildd@ Huge version with GTK2-GNOME GUI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/069c47b6e315239aa8c7a0b9eb40af55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616de4f04634512b313c045cd567f831/" rel="bookmark">
			JavaScript——事件&#43;浏览器内置对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇JavaScript入门基础中，我已经简单介绍了JavaScript语言特性，基础语法（常量和变量），逻辑运算符，关系运算符，算术运算符，还有JavaScript的函数。
这一篇我们就来探究Javascript的事件和浏览器内置对象，在开发中我们会常用到的一些的事件，这里会举例说明，并加以解释，如有不对之处，还请各位博友留言，我们一起交流学习。
一、JavaScript事件 1.1 onClick事件 onclick事件是当鼠标点击时触发的事件，同时onclick指定的事件处理程序或代码被执行调用。
&lt;input type="button" Onclick="window.open(document.location,'big','fullscreen=yes')"&gt; &lt;input type="button" Onclick="window.close()"&gt; //juery方式 &lt;input type="button" id="show"&gt; &lt;script type="text/javascript&gt; $（"#show"）.on("click",function(){ window.close(); }) &lt;/script&gt; 1.2 onChange事件 onchange事件是当监听的内容发生改变时触发的事件，同时onchange指定的事件处理程序或代码块被执行调用。
&lt;textarea name="message" οnchange=alert("请输入留言") /&gt; 1.3 onSelect事件 onselect事件是当文本框中选中文自后，会弹出选择文字的提示对话框。
&lt;input type="text" value="" οnselect=alert("选择事件") /&gt; 1.4 onFoucs事件 当光标放在文本框上或选择文本框上时产生onFoucs事件
1.5 onload事件 当加载网页文档时，会产生该时间。onLoad事件的作用是在首次载入一个页面文件时检测cookie的值。并用一个变量为其赋值，使其可以被源代码使用
&lt;body onLoad="MM_popupMg('欢迎光临！')"&gt; 1.6 onUload事件 退出网页时触发的事件，可以用来更新cookie.
1.7 onBlur事件 失去焦点onblur事件正好与获得焦点时间相对应，当对象不再拥有焦点时触发该事件
1.8 onMouseOver事件 当鼠标移入到对象（input div select等），触发的事件
1.9 onMouseOut事件 当鼠标移出触发的事件
1.10 onDbClick事件 鼠标双击触发的事件
1.11其他事件 稍后上传文档
二 浏览器的内置对象 2.1 navigator对象 &lt;input name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/616de4f04634512b313c045cd567f831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f81d4a3baec3b1c1509147c75980db6/" rel="bookmark">
			Windows下配置VSCode编译/调试C/C&#43;&#43;：launch.json配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VSCode在windows下配置调试C/C++代码 需要的软件工具 gcc、gdb工具；推荐下载minGW编译器，安装后在minGW安装目录下的bin目录下就有gcc和gdb；VSCode-windows在VSCode中搜索安装cpptools插件安装(有些情况是不用装的，当你后面的步骤完成后仍然不能开始调试，请安装) 步骤 启动VSCode，打开你想要调试的工程或文件，然后在菜单栏中单击“调试-开始调试”(或直接按F5);此时VSCode的控制台弹出下拉选择框，询问使用哪种工具，我们选择C/C++(GDB)；选择后，VSCode提示launch.json没有配置，无法启动调试，这时在它的通知右侧单击“打开”按钮以打开launch.json文件进行配置；在launch.json中主要配置：所需要调试的文件的路径、调试时的CWD(工作路径)、调试器的路径及一些调试参数(程序启动参数等)； 详细配置文件如下(新版VSCode) { "version": "0.2.0", //不用修改 "configurations": [ { "name": "(gdb) Launch", //配置下拉菜单中显示的内容 "type": "cppdbg", //类型；不能改 "request": "launch", //可以配置为启动(launch)和附加(attach) //编译后目标的绝对路径(注意由于windows的反斜杠'\'分隔符刚好是转义字符，所以务必使用双反斜杠，否则一旦产生转义将会导致路径错误) "program": "F:\\project\\foo\\bar\\DFS.exe", "args": [], //调试时传递给程序的参数 "stopAtEntry": false, //是否需要在程序入口处自动暂停 "cwd": "F:\\project\\foo\\bar", //调试时的程序工作目录 "environment": [], //环境参数 "externalConsole": true, //调试时是否打开控制窗口 "MIMode": "gdb", "miDebuggerPath": "D:\\Dev-Cpp\\MinGW64\\bin\\gdb.exe", //minGW的gdb的绝对路径 "setupCommands": [ { "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true } ] } ] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5423c4bb6d077bf3edd615bbf36aed68/" rel="bookmark">
			Java String &#43; 与 =
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 例子1：
System.out.println("is"+ 100 + 5); System.out.println(100 + 5 +"is"); System.out.println("is"+ (100 + 5)); 输出： is1005 105is is105
例子2：
public class Test{ public static void main(String argv[]){ String str = "hello"; str += 100; // hello100 str = str+100; // hello100100 str = 100; // error: can not convert from int to String str = (String)100; // error: can not cast from int to String System.out.println(str); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95cec392475934eb26240001e107e50a/" rel="bookmark">
			弹性web UI的核心：媒体查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官方手册CSS3 media query
demo 宽度最小700px的屏幕
@media (min-width: 700px) { ... } 宽度在500px和800px之间的屏幕：
@media screen and (min-width: 500px) and (max-width: 800px) { ... } 向显示在最大宽度800px的屏幕上的文档应用样式表
&lt;link rel="stylesheet" media="screen and (max-device-width: 799px)" /&gt; 伪范式 media_query_list: &lt;media_query&gt; [, &lt;media_query&gt; ]* media_query: [[only | not]? &lt;media_type&gt; [ and &lt;expression&gt; ]*] | &lt;expression&gt; [ and &lt;expression&gt; ]* expression: ( &lt;media_feature&gt; [: &lt;value&gt;]? ) media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed media_feature: width | min-width | max-width | height | min-height | max-height | device-width | min-device-width | max-device-width | device-height | min-device-height | max-device-height | aspect-ratio | min-aspect-ratio | max-aspect-ratio | device-aspect-ratio | min-device-aspect-ratio | max-device-aspect-ratio | color | min-color | max-color | color-index | min-color-index | max-color-index | monochrome | min-monochrome | max-monochrome | resolution | min-resolution | max-resolution | scan | grid 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f631c41ea0f58550f6c743aee503516/" rel="bookmark">
			phpcms得到专题的名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 phpcms专题模版页面，如何获取当前专题名称， 对比一下，如果需要获取栏目名称可以使用 $CATEGORY获取
&lt;!-- 栏目页可以直接使用$catid --&gt; {$CATEGORYS[$catid][catname]} $CATEGORY如何定义的?
#来自caches/caches_commons目录的缓存 $CATEGORYS = getcache('category_content_'.$siteid,'commons'); 因为在这个目录有special.cache.php文件 所以可以在模版页面定义一下
&lt;!-- $specialid在专题页可以直接使用 --&gt; {php $SPECIALS = getcache('special', 'commons');} {$SPECIALS[$specialid][title]} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b8651fff3bcb27554f7301a334bc33/" rel="bookmark">
			[UOJ]#61. 【UR #5】怎样更有力气
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题面传送门
做法：做法比较暴力。先按权值把每一天排序，从小到大做生成树，每一天我们先判这条链是否已经在同一个连通块（后面说怎么判），如果是就跳过，否则我们选出链的一个端点，然后找链上不与它在同一连通块的点，为了跳过同一连通块的点，我们用并查集维护每个点一直向祖先走，只走在同一连通块的点最远走到哪，合并连通块的时候我们启发式合并，顺便维护这个信息即可（利用这个信息，整条链是否属于同一个连通块也能判了），如果找到被限制条件限住的点，我们跳过，否则我们合并这两个连通块，链上与它不在同一连通块的点都走过之后，就把这个点从链上删掉从头做，我们每次考虑一个点对的时候要么是限制条件，要么是最后求出的生成树中的边，所以是O(n+p)的，加上启发式合并等复杂度，总时间复杂度大概是O(nlogn)级别的，常数较大。（另外貌似成为了UOJ上该题的代码最短）
代码：
#include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;map&gt; using namespace std; inline int read() { int x;char c; while((c=getchar())&lt;'0'||c&gt;'9'); for(x=c-'0';(c=getchar())&gt;='0'&amp;&amp;c&lt;='9';)x=x*10+c-'0'; return x; } #define MN 300000 #define K 19 #define v(x,y) make_pair(min(x,y),max(x,y)) struct work{int x,y,w,id;}w[MN+5]; bool cmp(const work&amp;a,const work&amp;b){return a.w&lt;b.w;} int fa[K][MN+5],f[MN+5],d[MN+5],c[MN+5]; map&lt;pair&lt;int,int&gt;,bool&gt; mp[MN+5]; vector&lt;int&gt; v[MN+5],vv[MN+5]; int gf(int k){return f[k]?f[k]=gf(f[k]):k;} int lca(int x,int y) { if(d[x]&lt;d[y])swap(x,y); int i=0,p=d[x]-d[y]; for(;p;p&gt;&gt;=1,++i)if(p&amp;1)x=fa[i][x]; if(x==y)return x; for(i=K;i--;)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y]; return fa[0][x]; } void merge(int a,int b) { if(vv[a].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b8651fff3bcb27554f7301a334bc33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9fcda1b3bf7b4ce368cf3ddb7e55c7/" rel="bookmark">
			java集合之LinkList解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LinkeList是基于双向链表的实现，同时它也实现了Queue队列,Deque栈的实现,使得我们可以进行双向队列的实现,上一节java集合之ArrayList解析中说过ArrayList查询效率比较高,添加和删除集合中的元素效率比较低,而LinkList正好相反. LinkList组织结构图 LinkList继承自AbstractSequentialList(ArrayList继承AbstractList)同时实现了Serializable和Cloneable标记接口,相比于ArrayList缺少了RandomAccess，说明进行随机访问效率比较低,多了Deque及Queue可以进行栈和队列的操作.
队列Queue public interface Queue&lt;E&gt; extends Collection&lt;E&gt; { boolean add(E var1); boolean offer(E var1); E remove(); E poll(); E element(); E peek(); } LinkList实现了队列Queue,Queue扩展了Collection,队列的特点是先进先出,在尾部添加数据，在头部删除数据. 使用add,offer在尾部添加数据使用remove,poll获取头部数据，并删除头部数据，会改变队列结构使用element,peek仅仅是获取头部数据，不会改变队列结构 每种操作都有两种形式,它们的区别是什么?区别就在于针对队列特殊情况的处理上,所谓队列的特殊情况即队列满和队列空.
当队列满的时候执行add操作会抛出IllegalStateException，而offer只会返回false.
当队列空的时候执行remove和element会抛出NoSuchElementException,而poll和peek会返回null。
LinkList队列没有长度的限制,其他的特定队列是有长度的。
LinkList作为队列使用:
Queue&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); queue.offer(1); queue.offer(2); queue.offer(3); while (queue.peek()!=null){ System.out.println(queue.poll());//输出1&gt;2&gt;3 } } Deque双端队列 栈和队列都可以进行双端操作,只是栈只能操作头部,而队列可以操作头部和尾部,在尾部添加数据,在头部删除数据.
LinkList实现了栈,栈在开发中很常见,栈的特点是先进后出.Deque继承了队列Queue,它同样是个接口。
public interface Deque&lt;E&gt; extends Queue&lt;E&gt; { boolean add(E var1); boolean offer(E var1); E remove(); E poll(); E element(); E peek(); void push(E var1); E pop(); int size(); Iterator&lt;E&gt; iterator(); Iterator&lt;E&gt; descendingIterator(); void addFirst(E e); void addLast(E e); E getFirst(); E getLast(); boolean offerFirst(E e); boolean offerLast(E e); E peekFirst(); E peekLast(); E pollFirst(); E pollLast(); E removeFirst(); E removeLast(); } Deque栈扩展了队列,实现入栈和出栈操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9fcda1b3bf7b4ce368cf3ddb7e55c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4ca34d2096a3dba25638860723d71a/" rel="bookmark">
			java杂文系列(2) eclipse集成drools规则引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Drools安装使用
大环境：windows10 + eclipse4.5 + jdk8 +drools 7.3.0.Final
官网(drools官网下载)下载 dlsjbpm-tools-distribution-7.3.0.Final.zip(eclipse插件) drools-distribution-7.3.0.Final.zip(运行环境)
1.安装GEF3.4+ (高版本自带) 可通过eclipse菜单栏上的help--&gt;Installation Details 查看
2.安装droots eclipse插件， 2.1 link方式方式安装drools eclipse插件 (自行百度) 2.2 直接解压把解压后dropins和features文件拷贝到eclipse安装目录中的dropins和features文件中
3.创建运行时(eclipse添加drools运行环境), window--&gt;preference--&gt;Drools--&gt;InstallDroolsRuntimes 添加运行环境
path=F:\Demo\DroolRuntime\drools-distribution-7.3.0.Final\binaries,要选择到binaries目录（根目录下ReadMeDrools.txt文件有说明）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd1e95b562792cb5d507e0ba374981b/" rel="bookmark">
			java集合之ArrayList解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArrayList是基于动态数组实现增删改查操作,进行顺序存储的,在内存中各个元素的地 址是连续的.
ArrayList组织结构图: 根据上面的结构图知道ArrayList继承AbstractList并实现了RandomAccess,Cloneable,Serializable这三个标记接口,所以AbstractList具有如下特性: AbstractList:实现了增删改查的集合操作,并可以对集合进行迭代查询。RandomAccess:随机访问性能很高.Cloneable:ArrayList对象可以进行克隆.Serializable:ArrayList对象可以进行序列化和反序列化存储和读取. ArrayList简要基本用法: public boolean add(E var1)//在集合末尾添加数据var1
public void add(int index, E var2)//在索引位置为index的位置处插入数据var2
public E remove(int index)//删除集合中索引位置为index的元素.
public boolean remove(Object var1)//删除集合中值为var1的元素,查找元素var1是用var1的equals方法比对的,如果var1是null,就查找集合中值为null的元素并删除.(这里需要注意的是删除的元素是集合中第一个为var1或null的元素,并不是所有).
public E set(int index, E var2)//修改索引为index元素的值为var2;
public E get(int index)//获取索引index处的元素数据.
ArrayList的遍历: 增强式for循环
ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); for (Integer integer:arrayList){ System.out.println(integer); } Iterator迭代
ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator=arrayList.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); } ArrayList的元素过滤 Iterator迭代过滤
ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator=arrayList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd1e95b562792cb5d507e0ba374981b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b4b8a765d05112d7d05d4258c3b9b6/" rel="bookmark">
			linux内核态文件操作filp_open/filp_close/vfs_read/vfs_write
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统成功的关键因素之一就是具有与其他操作系统和谐共存的能力。Linux系统的文件系统由两层结构构建：第一层是虚拟文件系统（VFS），第二层是各种不同的具体的文件系统。 VFS就是把各种具体的文件系统的公共部分抽取出来，形成一个抽象层，是系统内核的一部分，它位于用户程序和具体的文件系统之间。它对用户提供了标准的文件系统调用接口，对具体的文件系统（如EXT2、FAT32等），它通过一系列的对不同文件系统公用的函数指针来实际调用具体的文件系统函数，完成实际的各有差异的操作。任何使用文件系统的程序必须经过这层接口来使用它。通过这样的方式，VFS就对用户屏蔽了底层文件系统的实现细节和差异。 在VFS的支持下，用户态进程读写任何类型的文件系统都可以使用read和write着两个系统调用，但是在linux内核中没有这样的系统调用我们如何操作文件呢？我们知道read和write在进入内核态之后，实际执行的是sys_read和sys_write，但是查看内核源代码，发现这些操作文件的函数都没有导出(使用EXPORT_SYMBOL导出)，也就是说在内核模块中是不能使用的.通过查看sys_open的源码我们发现，其主要使用了do_filp_open()函数，该函数在fs/namei.c中，而在改文件中，filp_open函数也是调用了do_filp_open函数，并且接口和sys_open函数极为相似，调用参数也和sys_open一样，并且使用EXPORT_SYMBOL导出了，所以我们猜想该函数可以打开文件，功能和open一样。使用同样的查找方法，我们找出了一组在内核中操作文件的函数，如下：
我们注意到在vfs_read和vfs_write函数中，其参数buf指向的用户空间的内存地址，如果我们直接使用内核空间的指针，则会返回-EFALUT。所以我们需要使用set_fs()和get_fs()宏来改变内核对内存地址检查的处理方式。 另外，使用vfs_read()和vfs_write()需要注意的一点是最后的参数loff_t *pos，pos所指向的值要初始化，表明从文件的什么地方开始读写。例如，可以使用 loff_t pos = fp-&gt;f_pos; 实例代码：
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/sched.h&gt; #include &lt;linux/dcache.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/err.h&gt; #include &lt;linux/string.h&gt; #include &lt;linux/errno.h&gt; #include &lt;asm/fcntl.h&gt; #include &lt;asm/processor.h&gt; #include &lt;asm/uaccess.h&gt; int __init hello_init(void) { unsigned char buf1[12]="hello world."; unsigned char buf2[12]="kernel file."; struct file *fp; mm_segment_t fs; loff_t pos; printk("hello enter\n"); fp = filp_open("/home/kernel_file", O_RDWR | O_CREAT, 0644); if (IS_ERR(fp)) { printk("create file error\n"); return -1; } fs = get_fs(); set_fs(KERNEL_DS); pos = fp-&gt;f_pos; vfs_write(fp, buf1, sizeof(buf1), &amp;pos); fp-&gt;f_pos = pos; pos = fp-&gt;f_pos; vfs_write(fp, buf2, sizeof(buf2), &amp;pos); fp-&gt;f_pos = pos; set_fs(fs); filp_close(fp, NULL); return 0; } void __exit hello_exit(void) { printk("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b4b8a765d05112d7d05d4258c3b9b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052cb0a7f44b887737bb12a65a4e16fb/" rel="bookmark">
			vim：学习资料——把vim打造成 IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总结列出一些搜集的一些资料，然后再写一个自己的 将你的Vim 打造成轻巧强大的IDE 主要对ruby http://www.open-open.com/lib/view/open1429884437588.html 从零搭建和配置OSX开发环境 http://yuez.me/cong-ling-da-jian-he-pei-zhi-osxkai-fa-huan-jing/ 1. vim for python Vim与Python真乃天作之合：打造强大的Python开发环境 https://segmentfault.com/a/1190000003962806 解释的很详细，按照需要的功能，怎么配置，装什么插件，命令是什么意思， Vim配置（python版） http://www.cnblogs.com/cjy15639731813/p/5886158.html 好像跟上面的差不多？ 用 Vim 写 Python 的最佳实践是什么？ https://www.zhihu.com/question/19655689 两个命令把 Vim 打造成 Python IDE http://python.jobbole.com/84166/ http://blog.csdn.net/alanzjl/article/details/49383943 插件 python mode 的重头戏， 2. vim for C/C++ 所需即所获：像 IDE 一样使用 vim （c/c++） https://github.com/yangyangwithgnu/use_vim_as_ide#0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2315c03835a393f448e2679fa7afd703/" rel="bookmark">
			【异步FIFO的一些小事·1】空满判断与格雷码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天经过与HR的交谈意识到自己对于异步FIFO的理解还不深，因此回来之后又其结构进行了一些理解，于此分享。
异步FIFO的设计：http://blog.csdn.net/moon9999/article/details/77822606
疑问1：进行数据空满的对比时，读写时钟域都有读写指针，此时应该怎么对比？为什么？
另外一篇博客中有这样的话：
同步rd_cntr至clk_write时钟域，再与wr_cntr进行对比来决定FIFO是否满；（判断满是wr_cntr - rd_cntr）
同步wr_cntr至clk_read时钟域，再与rd_cntr进行对比来决定FIFO是否空；（判断空是rd_cntr == wr_cntr）
这是结论，那现在我们必须要仔细的思考这句话为什么是这么做的。
首先画个示意图。
那现在我们来设想各种情况下会发生什么，在此我们暂时不考虑亚稳态的事情，认为信号通过同步模块都被采到了但是会有信号丢失。
第一种情况我们假定写时钟特别快，读时钟都采不齐写指针。
那么此时空逻辑会不会出错呢？假设写指针已经跑了1 2 3 4 5 6 7 8 9，而读时钟采到了1 2 6 8；那么如果此时读指针就在8，两边一对比发现一样（当然了这只是假设的一种情况）则会报“空”！那么实际空没空呢，没有因为我写到9了写进去了一个数，不过没关系之后必然会采到9（或者采到10一类的），状态会很快恢复正常，或者说没有空而报了空我们还可以接受，因为这样对于一个将要空的FIFO会停止读数旋即恢复正常，不会使其数据发生紊乱。那会不会有空了而报不空使得读出数据出现问题的情况呢？不会的，你想想看写指针跑的比你采样的快，是趋向与“不空”（越写数据越多嘛）的，因此不会出现这样的错误。
读指针被同步到写时钟域本身不会出现漏采的情况，因此“满”逻辑的判断不会出现问题。
第二种情况我们假定读时钟域特别快，写时钟都采不齐读指针。
此时的满逻辑会出错么？我们来看下。我们同样假设读指针从1跑到了9，而只被采样到了7。如果此时写指针也写到了7，那么二者一比较发现写“满”了，实际呢没有满，不过此时也会停止外部写入（传出了满的信号），这是不会对FIFO中的数据产生影响的，并且很快会恢复到“不满”。如果此时写指针到了5，那么二者对比会得出“不满”的逻辑传出，真实情况呢同样是不满，因为读到7就已经不满了真实情况读到了9自然更加“不满”。这样就解释清楚了。
写指针被同步到读时钟域本身不会出现漏采的情况，因此“空”逻辑的判断不会出现问题。
受到HR的点播或许我们可以选择一种记法：
“满”逻辑是要给谁的——给写信号告诉他你别写了——那么写指针能多跑出去么？跑多了不就把数据覆盖了！——所以必须在写时钟域进行对比；
“空”逻辑是要给谁的——给读信号告诉他你别读了——那么读指针能多跑出去么？跑多了不就读出来错误的数了！——所以在读时钟域进行对比；
我现在先理解到这一步吧。
疑问2：为什么要用格雷码进行同步传输？
我觉得使用格雷码的优势体现在读写时钟差异不是特别大的时候，不能一个是1000M一个是10M那谁也救不了了，无限加长FIFO深度吧。那么我们假定读写时钟频率差异没有过大，例如一个133M一个100M这样的。
我们要知道这个异步时钟采样，再不经过特殊处理的情况下采错了是在所难免的。单个信号可能采错或者没采到，那多个信号的读写指针就更加有可能出问题了。我们来看下如果此时的指针是1011（二进制=2），那么在向1100（2）跳变时候，由于信号走的距离不一样啦触发事件或者逻辑门延时不同啦等等原因，在另外一段时钟域就可能采出多种情况例如1011（2）、1110（2）、1101（2）等，总之每个信号都可能是正确值或者未跳变时候的值。那么在得到“空”“满”逻辑时候很大可能概率会出错，这个我们不能忍。过程如下图所示。
所以说我们就要选择格雷码了，来看下格雷码发生了什么事。1011（2）=1110（g）,1100（2）=1010（g），因此格雷码跳变为1110（g）-&gt;1010(g)。同样考虑采样出问题了，由于我们提前说好了读写时钟频率差距不是太大，因此采样可能得到两种情况：1110（g）和1010（g），到另外的时钟域后会转换为二进制的1011（2）和1100（2）。看到这里是不是想到了什么！你看如果得到的是1100那没问题呀，这就是真是的值。如果是得到1011呢？我实际跑到了1100你采到了1011是不是类似于上一个问题的“指针实际已经跑到了9而你只采到了7，会不会出问题”，答案是不会呀！原因就在于我们进行对比时时钟域的选择已经解决了这个问题。因此可知使用格雷码即时出现了采样错误的情况，也不会时“空满”判定出现问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d545d4bf5512ce0b3cb2fc223a35411/" rel="bookmark">
			数据结构 第3讲 顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构 第3讲 顺序表
顺序表是最简单的一种线性结构，逻辑上相邻的数据在计算机内的存储位置也是相邻的，可以快速定位第几个元素，中间不允许有空，所以插入、删除时需要移动大量元素。
顺序表可以分配一段连续的存储空间Maxsize，用elem记录基地址，用length记录实际的元素个数，即顺序表的长度，
结构体的定义：
结构体定义后，如果要定义个顺序表L，就可以写：
SqList L;
1. 顺序表初始化
初始化是指给顺序表分配一个预定义大小的空间，用基地址elem记录这段空间的首地址，里面什么都没用，元素个数为0。前面我们已经预定义好了一个最大空间数Maxsize，那么就用new分配这么大的空间，分配成功会返回空间的首地址。假设顺序表里面需要存储整型数，那么就可以这样初始化：
boolInitList(SqList &amp;L) //构造一个空的顺序表L
{ //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效
//不加&amp;内部改变，跳出函数后无效
L.elem=new int[Maxsize]; //为顺序表分配Maxsize个空间
if(!L.elem) return false; //存储分配失败
L.length=0; //空表长度为0
return true;
}
2. 顺序表创建
顺序表创建是向顺序表中输入数据，输入数据的类型要与类型定义中的类型一致。假设顺序表里面需要存储整型数，那么就可以这样创建：
boolCreateList(SqList &amp;L) //创建一个顺序表L
{ //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效
//不加&amp;内部改变，跳出函数后无效
int a,i=0；
while(a!=-1)
{
cin&gt;&gt;a;
if(L.length==Maxsize)
{
cout&lt;&lt;”顺序表已满！”
return false;
}
L.elem[i++]=a;
L.length++;
}
return true;
}
3. 顺序表取值
顺序表中的任何一个元素都可以立即找到，称为随机存取方式，例如我们我取第i个元素，只要i值是合理的（1≤i≤L.length），那么立即就可以找到该元素L.elem[i-1]：
bool GetElem(SqList L,int i,int &amp;e)
{
if (i&lt;1||i&gt;L.length) return false; //判断i值是否合理，若不合理，返回false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d545d4bf5512ce0b3cb2fc223a35411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce4b53833b5370da3c9eb5e2774eeff/" rel="bookmark">
			java中cloneable的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是java中的浅克隆和深克隆? 浅克隆:克隆对象中的变量与之前对象的值相同,并且对象中的引用类型变量仍然指向原来对象引用类型变量的地址.深克隆:克隆对象中的变量与之前对象的值相同，并且对象中的引用类型变量指向了新的对象的引用变量的地址.要想实现克隆，只需定义的类声明下cloneable这个标记性接口,并且衍生重写Object类中就有的clone()方法即可. 为什么类要首先声明cloneable标记接口，然后重写clone()方法？因为不声明cloneable调用clone()方法会抛出CloneNotSupportedException异常,源码如下:
protected Object clone() throws CloneNotSupportedException { if (!(this instanceof Cloneable)) { throw new CloneNotSupportedException("Class " + getClass().getName() + " doesn't implement Cloneable"); } return internalClone(); } /* * Native helper method for cloning. */ private native Object internalClone(); 在上一节中讲了java中Serializable与Parcelable的使用序列化与反序列化的问题。事实上利用对象输出流对对象进行序列化,利用对象的输入流对对象进行反序列化也可以实现克隆,如果对象中依赖的其他对象的引用也实现了序列化(即引用类实现了serializable标记接口)就实现了深度克隆,否则实现了浅克隆. 实现了Serializable接口的Company
public class Company implements Serializable {//Serializable接口是空的,没有声明的方法及常量 private static final long serialVersionUID = 1L; //序列化标识 private String name; private String address; public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ce4b53833b5370da3c9eb5e2774eeff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/380116abfae0f64b4fa57b495e36847f/" rel="bookmark">
			iOS UIView的圆角加阴影效果的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目的界面都要改成卡片的形式，即需要投影的效果，还要削出圆角，我们都知道削圆角一般有两种方式，一种是直接用layer.cornerRadius来设置，我们知道的一般都是下面两行代码一起使用来实现圆角：
self.layer.cornerRadius = 10; self.layer.masksToBounds=YES; 但是只要self.layer.masksToBounds=YES;有这句，投影的效果就出不来。 还有一种性能比较好的圆角设置方式，就是用UIBezierPath来设置，我试过用这个来设置圆角的话，投影一样也出不来。 还有在网上看到了加一层layer的，大体思路就是self.layer来设置圆角，新写一个layer来设置投影，然后把layer放到self.layer上，我试了之后发现没什么效果，而且偏移会很明显的看出来，但不是以投影的方式出现。 然后又找到了一篇文章，给出的方法代码如下：
@implementation TPShadowView -(instancetype)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { self.backgroundColor = kUIColorFromRGB(0x4b4773); //v.layer.masksToBounds=YES;这行去掉 self.layer.cornerRadius = 10; self.layer.shadowColor = kUIColorFromRGB1(0x000000, 1).CGColor; self.layer.shadowOffset = CGSizeMake(2, 5); self.layer.shadowOpacity = 0.5; self.layer.shadowRadius = 5; } return self; } 这个是我整理之后的写了个投影的view类，方便使用，核心就是注释着这行去掉的这个，当时看的时候，觉得有点不敢相信，但是那个博主给了投影效果，我就抱着试一下的心态写了，没想到还真的可以。。。 效果如图： 真的是万万没想到啊，万分感谢那篇文章的博主啊~~ 附上原博主的文章链接：IOS view的圆角和阴影并存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e516b83349e0961218183d7dbf2ce6c/" rel="bookmark">
			xml快速入门（tinyxml解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 xml是一种可扩展标记语言，用于传输和存储数据。
语法 1.xml必须有根节点
&lt;root&gt;
&lt;child&gt;child&lt;/child&gt;
&lt;/root&gt;
2xml节点必须有始有终（有关闭标签）
&lt;radius&gt;1&lt;/radius&gt;
3 xml标签对大小写敏感
&lt;grayscale&gt;100&lt;/Grayscale&gt;是错误的
4. xml属性值加双引号
&lt;model name="modelCircle"&gt;
5. xml注释
&lt;!--注释--&gt;
6.xml声明文件version项必须写
&lt;?xml version="1.0" encoding="utf-8"?&gt;
示例 xml文件解析库（tinyxml） tinyXML一款很优秀的操作C++类库，文件不大，但方法很丰富，可以满足绝大部分功能需要。而且它使用很简单，只需要拷贝六个文件到你的工程中就可以使用了。
TiXmlDocument ： XML文档类，它一般用于指示一个文档对象；
TiXmlDeclaration： XML标识类，也就是XML文件第一行中标注的相关信息；
TiXmlElement: XML节点类，这个类用来表示一个节点；
TiXmlText： XML节点类的文本信息类，标注了XML节点类的文本信息；
TiXmlComment: XML的注释信息类，用来标识XML文档类的注释信息；
tinyXML库的使用步骤及常用API 生成xml文件 （1）创建xml文件，生成一个文件句柄
TiXmlDocument *doc = new TiXmlDocument();
（2）添加版本及编码格式
TiXmlDeclaration *declaration= new TiXmlDeclaration("1.0", "UTF-8", "");
（3）编码格式节点加入文件
doc-&gt;LinkEndChild(declaration);
（4）创建文件唯一根节点
TiXmlElement *root= new TiXmlElement("root");
doc -&gt;LinkEndChild(root);
（5）创建一个子节点，，并且加入根节点
TiXmlElement*firstChild=newTiXmlElement("firstChild”);
root-&gt;LinkEndChild(firstChild);
（6）创建一个叶子节点，此节点为最后一次节点，
TiXmlElement *leaf= new TiXmlElement("leaf");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e516b83349e0961218183d7dbf2ce6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27476087f4a656b4a3daf9f69ca9e28/" rel="bookmark">
			删除Java代码中的所有注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源：http://blog.csdn.net/fullstack/article/details/22688777 package tools ; import java.io.BufferedReader ; import java.io.BufferedWriter ; import java.io.File ; import java.io.FileInputStream ; import java.io.FileOutputStream ; import java.io.InputStreamReader ; import java.io.OutputStreamWriter ; /** * 删除Java代码中的注释 * * @author Alive * @build 2010-12-23 */ public class DeleteComments { private static int count = 0 ; /** * 删除文件中的各种注释，包含//、/* * /等 * @param charset 文件编码 * @param file 文件 */ public static void clearComment ( File file , String charset ) { try { //递归处理文件夹 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e27476087f4a656b4a3daf9f69ca9e28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9738bd38eb46b1178657ef01d674fbbb/" rel="bookmark">
			2017 ACM-ICPC 亚洲区-banana
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Discussion Bananas are the favoured food of monkeys. In the forest, there is a Banana Company that provides bananas from different places. The company has two lists. The first list records the types of bananas preferred by different monkeys, and the second one records the types of bananas from different places. Now, the supplier wants to know, whether a monkey can accept at least one type of bananas from a place.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9738bd38eb46b1178657ef01d674fbbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905cd9e882fd0bf0c39118b0b68dcd6e/" rel="bookmark">
			pymongo报错 pymongo.errors.OperationFailure: Authentication failed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于公司的mongoDB部署在容器平台
在本地测试 没有问题 项目部署于容器平台之后 报pymongo.errors.OperationFailure: Authentication failed.
之前有人遇到同样的问题 但是 导致认证失败的原因有多个 在stackoverflow上有类似方案 但是中文博客没有 导致 还是费了一番功夫
做过的尝试：
1.修改认证机制 因为MongoDB版本为 3.4.0 所以修改为 SCRAM-SHA-1
2.使用APIconnection .api.authenticate(name.psswd)
3.升级pymongo版本
终极解决方案：
1.将pymongo版本与MongoDB版本保持一致
2.使用以下代码模板
# --coding:utf-8--
import pymongo
from urllib import quote_plus
from pymongo import MongoClient
#/?replicaSet=rs0
uri = 'mongodb://mongo-0.mongo.public,mongo-1.mongo.public,mongo-2.mongo.public,mongo-3.mongo.public,mongo-4.mongo.public:27017/log_fieldmap'
clint=MongoClient(uri)
db = clint['log_fieldmap']
db.authenticate('username, 'pwd')
coll = db['xxx.com']
result = coll.insert_one({"abc":123})
print result
clint.close()
异常原因：
在开启认证模式之后，如果将用户名密码写入url中 默认连接的数据库是admin，事实上我所连接的数据库并不是admin 所以 用户名和密码是无效的 所以导致认证失败
解决方案 在URL中指定所要连接的数据库 或者是 在 选择数据库之后 （ db = clint['log_fieldmap ']该代码之后 ） 添加认证 db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905cd9e882fd0bf0c39118b0b68dcd6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd1d19aa9e6c5c8d62be77e0f23c522/" rel="bookmark">
			Tortoise小乌龟SVN回滚到之前的提交版本，即如何撤销此次提交操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows 界面，比如桌面，新建个文件夹，先把工程从svn上拉到此文件夹中，然后右键工程--》TortoiseSVN --》show log
出现以下弹框：
比如说我要撤销刚才提交的1883这个版本，那么点击1882版本，右键--》撤销到此版本:
然后会再弹出一个框，直接点击revert确定还原就是了。完了再回到之前的文件夹界面，这事会发现工程文件名上回出现红色感叹号，这时就需要我们提交一下我们刚才的回滚操作，
注意要加注解，完了OK,
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bad5b9a2df969a37a73d63e90b7f9f/" rel="bookmark">
			网络编程中常见问题以及解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在帮老师做一个P2P的项目，客户端包含注册以及登陆功能，关于数据库的选择，尝鲜采用了最新的mongoDB，但是在运行简单的demo的时候依然出现了许多的问题。文章会逐渐跟新，在我有时间的前提下：
关于RST ACK 本地测试正常，部署到服务器发现TCP通信出现故障，本机操作系统win10，服务器内核版本如下图所示： 在windows powershell运行程序发现出现socket.send()方法的错误，凡是网络问题就少不了抓包分析了~，本机采用wireshark进行抓包如下所示： 这里可以看到本机发送SYN（请问你有空么？）立马收到了服务器的回绝RST（没有！）。服务器上采用TCPDUMP指令进行抓包的时候也发现了问题的所在，能收到WINDOWS发来的SYN包，但是立马进行了不暇思索的回绝。 我们常见发送RST的情况有以下几种： 1、服务器端口没有打开 2、超时 3、缓存区中有内容未读取完全
这里的问题很容易定位，因为包中并未包含时间异常信息，直接在Windows10 上telnet检测端口通不通就好，（然后发现不通。 SYN(有空吗？)——&gt;ACK,SYN（有空啊，你呢？）——&gt;SYN（我也有空~）
最近还有一个很坑的地方就是多线程了~多线程中1、锁与2、阻塞 都是十分重要的概念，对应于python的join()方法以及lock()锁机制。最近一个常见的EOF报错就是因为主线程线性退出，留下子线程在独自运行，获取不到读入数据。这里可以采用join()方法，将子线程加入其中：
def Send(sock): while True: data = raw_input('&gt;') sock.send(data) if data =='exit': print '连接结束' break sock.close() def Recv(sock): while True: data = sock.recv(BUFFSIZE) if data == 'exit': break print data sock.close() def main(): s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect(ADDR) ts=Thread(target=Recv,args=(s,)) ts.start() tr=Thread(target=Send,args=(s,)) tr.start() tr.join() if __name__=``` "__main__": main() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef10457f8bf050e170a5231285c9af89/" rel="bookmark">
			h5新特性localstorage的简单应用（记住登录名和密码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在制作登录界面的时候回出现一个勾选框，询问我们是否记住账号和密码，当我们勾选了之后下次进来就是上次登录的账号密码，可以直接登录。那这个功能是如何实现的呢？下面我们就是用h5的新特性localstorage来实现。
首先，我们需要了解下localstorage的含义和用法。在客户端h5提供了两种存储方式；一种是localstorage，一种是sessionstorage
下面我们详细介绍下这两种方式的优缺点。
localstorage的有点：1、拓展了cookie的4k限制2、可以将第一次接收的数据存储到本地，这个相当于5M大小的前端页面数据库，但是只能在高版本的浏览器中使用。
localstorage的局限性：1、浏览器版本不统一，localstorage只支持ie8及以上的版本2、目前浏览器只能讲localstorage的数据类型限定为strinf，对于我们现在用的JSON格式需要进行转换。3、在浏览器的隐私模式下是不可读的4、本质上是对字符串的读取，如果数量太多会造成页面的卡的情况5、不能被爬虫抓取到
localstorage与sessionstorage的本质区别是localstorage是永久存储而sessionstorage是回话存储（页面关闭数据消失）
那如何创建localstorage呢？有三种创建方法如下：
if(！window.localStorage){ alert("浏览器支持localstorage"); return false; }else{ var storage=window.localStorage; //写入a字段 storage["a"]=1; //写入b字段 storage.b=1; //写入c字段 storage.setItem("c",3); console.log(typeof storage["a"]); console.log(typeof storage["b"]); console.log(typeof storage["c"]); } 读取localstorage
if(!window.localStorage){ alert("浏览器支持localstorage"); }else{ var storage=window.localStorage; //写入a字段 storage["a"]=1; //写入b字段 storage.a=1; //写入c字段 storage.setItem("c",3); console.log(typeof storage["a"]); console.log(typeof storage["b"]); console.log(typeof storage["c"]); //第一种方法读取 var a=storage.a; console.log(a); //第二种方法读取 var b=storage["b"]; console.log(b); //第三种方法读取 var c=storage.getItem("c"); console.log(c); }修改localstorage的值 if(!window.localStorage){ alert("浏览器支持localstorage"); }else{ var storage=window.localStorage; //写入a字段 storage["a"]=1; //写入b字段 storage.b=1; //写入c字段 storage.setItem("c",3); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef10457f8bf050e170a5231285c9af89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e261c7d018fa98963ef0ea34241a63/" rel="bookmark">
			微服务的4个设计原则和19个解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载本文需注明出处：微信公众号EAWorld，违者必究。
微服务架构现在是谈到企业应用架构时必聊的话题，微服务之所以火热也是因为相对之前的应用开发方式有很多优点，如更灵活、更能适应现在需求快速变更的大环境。
本文将介绍微服务架构的演进、优缺点和微服务应用的设计原则，然后着重介绍作为一个“微服务应用平台”需要提供哪些能力、解决哪些问题才能更好的支撑企业应用架构。
微服务平台也是我目前正在参与的，还在研发过程中的平台产品，平台是以SpringCloud为基础，结合了普元多年来对企业应用的理解和产品的设计经验，逐步孵化的一个微服务应用平台。
目录：
一、微服务架构演进过程
二、微服务架构的好处
三、微服务应用4个设计原则
四、微服务架构带来的问题
五、微服务平台的19个落地实践
六、总结展望
一、微服务架构演进过程
近年来我们大家都体会到了互联网、移动互联带来的好处，作为IT从业者，在生活中时刻感受互联网好处的同时，在工作中可能感受的却是来自自互联网的一些压力，那就是我们传统企业的IT建设也是迫切需要转型，需要面向外部客户，我们也需要应对外部环境的快速变化、需要快速创新，那么我们的IT架构也需要向互联网企业学习作出相应的改进，来支撑企业的数字化转型。
我们再看一下应用架构的演进过程，回忆一下微服务架构是如何一步一步进化产生的，最早是应用是单块架构，后来为了具备一定的扩展和可靠性，就有了垂直架构，也就是加了个负载均衡，接下来是前几年比较火的SOA，主要讲了应用系统之间如何集成和互通，而到现在的微服务架构则是进一步在探讨一个应用系统该如何设计才能够更好的开发、管理更加灵活高效。
微服务架构的基本思想就是“围绕业务领域组件来创建应用，让应用可以独立的开发、管理和加速”。
二、微服务架构的好处
我们总结了四个方面的优点，分别如下：
是每个微服务组件都是简单灵活的，能够独立部署。不再像以前一样，应用需要一个庞大的应用服务器来支撑。
可以由一个小团队负责更专注专业，相应的也就更高效可靠。
微服务之间是松耦合的，微服务内部是高内聚的，每个微服务很容易按需扩展。
微服务架构与语言工具无关，自由选择合适的语言和工具，高效的完成业务目标即可。
看到这里，大家会觉得微服务架构挺不错，然而还会有一些疑问，什么样的应用算是一个微服务架构的应用？该怎样设计一个微服务架构的应用？那我们来一起看看我们推荐的微服务应用的设计原则。
三、微服务应用4个设计原则
我们总结了四个原则推荐给大家：
AKF拆分原则
前后端分离
无状态服务
Restful通信风格
1.AKF拆分原则
AKF扩展立方体（参考《The Art of Scalability》），是一个叫AKF的公司的技术专家抽象总结的应用扩展的三个维度。理论上按照这三个扩展模式，可以将一个单体系统，进行无限扩展。
X 轴 ：指的是水平复制，很好理解，就是讲单体系统多运行几个实例，做个集群加负载均衡的模式。
Z 轴 ：是基于类似的数据分区，比如一个互联网打车应用突然或了，用户量激增，集群模式撑不住了，那就按照用户请求的地区进行数据分区，北京、上海、四川等多建几个集群。
Y 轴 ：就是我们所说的微服务的拆分模式，就是基于不同的业务拆分。
场景说明：比如打车应用，一个集群撑不住时，分了多个集群，后来用户激增还是不够用，经过分析发现是乘客和车主访问量很大，就将打车应用拆成了三个乘客服务、车主服务、支付服务。三个服务的业务特点各不相同，独立维护，各自都可以再次按需扩展。
2.前后端分离
前后端分离原则，简单来讲就是前端和后端的代码分离也就是技术上做分离，我们推荐的模式是最好直接采用物理分离的方式部署，进一步促使进行更彻底的分离。不要继续以前的服务端模板技术，比如JSP ，把Java JS HTML CSS 都堆到一个页面里，稍复杂的页面就无法维护。这种分离模式的方式有几个好处：
前后端技术分离，可以由各自的专家来对各自的领域进行优化，这样前端的用户体验优化效果会更好。
分离模式下，前后端交互界面更加清晰，就剩下了接口和模型，后端的接口简洁明了，更容易维护。
前端多渠道集成场景更容易实现，后端服务无需变更，采用统一的数据和模型，可以支撑前端的web UI\ 移动App等访问。
3.无状态服务
对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。
那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。
场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。
4.Restful通信风格
作为一个原则来讲本来应该是个“无状态通信原则”，在这里我们直接推荐一个实践优选的Restful 通信风格 ，因为他有很多好处：
无状态协议HTTP，具备先天优势，扩展能力很强。例如需要安全加密是，有现成的成熟方案HTTPS可用。
JSON 报文序列化，轻量简单，人与机器均可读，学习成本低，搜索引擎友好。
语言无关，各大热门语言都提供成熟的Restful API框架，相对其他的一些RPC框架生态更完善。
当然在有些特殊业务场景下，也需要采用其他的RPC框架，如thrift、avro-rpc、grpc。但绝大多数情况下Restful就足够用了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e261c7d018fa98963ef0ea34241a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/479c4ca0241113221b99cd2c3a61c5c9/" rel="bookmark">
			I/O流--序列化流与反序列化流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是序列化流与反序列化流？ 用于从流中读取对象的操作流 ObjectInputStream 称为 反序列化流（把看不懂的乱码转化成看得懂的） 用于向流中写入对象的操作流 ObjectOutputStream 称为 序列化流（把看得懂的以乱码的形式写到文件中） 特点：用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象。 ObjectOutputStream 构造方法中的参数代表要写入的文件，也就是你将要把看得懂的转化成看不懂的乱码写入到哪个路径下 上代码：
FileOutputStream fos = new FileOutputStream("t.tmp"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeInt(12345); oos.writeObject("Today"); oos.writeObject(new Date()); oos.close(); ObjectInputStream 构造方法中的参数代表要读取的文件，也就是你将要从这个路径下的文件把看不懂的转化成看得懂的读取到内存中 上代码：
FileInputStream fis = new FileInputStream("t.tmp"); ObjectInputStream ois = new ObjectInputStream(fis); int i = ois.readInt(); String today = (String) ois.readObject(); Date date = (Date) ois.readObject(); ois.close(); 序列化对象 Person类
public class Person implements Serializable { private String name; private int age; public Person() { super(); } public Person(String name, int age) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/479c4ca0241113221b99cd2c3a61c5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c61971ea018633db230f85846cdf80/" rel="bookmark">
			java数据结构和算法 - 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据结构是对在计算机内存(硬盘)中的数据的一种安排.
2. 数据结构包括数组,链表,栈,二叉树,哈希等.
3. 数据结构的特性:
数组 (优点:插入快,如果知道下标,可以非常快的存储.缺点:查找慢,删除慢,大小固定)
有序数组 (优点:比无序数组查找快.缺点:查找慢,删除慢,大小固定)
栈 (优点:提供后进先出的存取.缺点:存取其他项很慢)
队列 (优点:提供先进先出方式的存取.缺点:存取其他项很慢)
链表 (优点:插入快,删除快.缺点查找慢)
二叉树 (优点:查找,插入,删除都快(如果数保持平衡), 缺点:删除算法复杂)
红-黑数 (优点: 查找,插入,删除都快.数总是平衡的. 缺点:算法复杂)
2-3-4树 (优点: 查找,插入,删除都快.数总是平衡的,类似的数对硬盘存储有用. 缺点:算法复杂)
哈希表 (优点: 如果关键字已知则存取极快.插入快 缺点:删除慢,如果不知道关键字则存取很慢,对存储空间使用不充分)
堆 (优点: 插入,删除快,对最大数据项的存取很快, 缺点:对其他数据项存取慢)
图 (优点: 对现实世界建模, 缺点: 有些算法慢且复杂)
4. 数据结构出来数组之外都被认为是抽象数据结构(ADT)
数组:
1.设数据有N个,则一个数据项的的平均查找的长度为N/2. 在最坏的情况下,待查的数据项在数组的最后,则需要N步才能找到.
2.删除算法中暗含一个假设,即数组中不能有洞(空单元).如果有洞,算法会要判断非空数据而变得效率低.切记不能有空单元.
3. 删除(假设数据不重复)查找平均N/2个数据项并移动剩下的N/2个数据项来填充删除而带来的洞.总共是N步.
4. 如果允许重复,则通常查找步数是N个,即全部查找. 也可以在第一次匹配成功后就停止查找.
5. 允许重复下的删除需要检查N个数据项和(可能)移动多于N/2个数据项.
6. 不管是否可以重复,插入数据只需一步.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00307677a5aac6f2248cc33c218287e/" rel="bookmark">
			unity关节（joint）讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关节
关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。
关节介绍
关节一共分为5大类：链条关节，固定关节，弹簧关节，角色关节和可配置关节。
链条关节（hinge joint）：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。
固定关节（fixed joint）：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。
弹簧关节（spring joint）：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。
角色关节（character joint）：可以模拟角色的骨骼关节。
可配置关节（configurable joint）：可以模拟任意关节的效果。
关节是一个游戏组件，在导航菜单栏中选择component——physics然后从中选择一种关节组件，即可完成关节组件的添加。
使用breakforce可设置关节断裂的力，一旦力超过它，关节将会断裂。断裂时，通过onjointbreakforce方法可监听相关事件。
下面给个实例：
using UnityEngine; using System.Collections; public class Script_06_10 : MonoBehaviour { //链接关节游戏对象 GameObject connectedObj = null; //当前链接的关节组件 Component jointComponent = null; void Start() { //获得链接关节的游戏对象 connectedObj = GameObject.Find("Cube1"); } void OnGUI() { if(GUILayout.Button("添加链条关节")) { ResetJoint(); jointComponent = gameObject.AddComponent("HingeJoint"); HingeJoint hjoint = (HingeJoint)jointComponent; connectedObj.rigidbody.useGravity = true; hjoint.connectedBody = connectedObj.rigidbody; } if(GUILayout.Button("添加固定关节")) { ResetJoint(); jointComponent =gameObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00307677a5aac6f2248cc33c218287e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0355d8d6646b679b17cef2b827832951/" rel="bookmark">
			MATLAB中如何绘制一个球
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在看到surf函数时，surf的MATLAB帮助文档中，有绘制一个球，所以想用MATLAB绘制一个球。
主要使用到sphere函数。
sphere(n);绘制球的表面图，球由n*n个面组成。
sphere;默认n=20;
[x,y,z]=sphere(n);返回三个矩阵的坐标信息，尺寸都为(n+1)*(n+1)；然后使用surf或者mesh来绘制球.
注意：sphere默认绘制的球半径都是1。
clc;clear;close all; figure(1); sphere(50);%球由50*50个面组成 [x y z]=sphere(); figure(2);5 surf(2*x,2*y,2*z);%绘制半径为2的球 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5f072bcf6ad485927f927224c830ee/" rel="bookmark">
			Logstash API Monitor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Logstash 5.0 开始，提供了输出自身进程的指标和状态监控的 API。
官方文档： https://www.elastic.co/guide/en/logstash/current/monitoring-logstash.html#monitoring
Node Info API https://www.elastic.co/guide/en/logstash/current/node-info-api.html pipeline Gets pipeline-specific information and settings. os Gets node-level info about the OS. jvm Gets node-level JVM info, including info about threads.
curl -s ‘localhost:9600/_node/pipeline’?pretty curl -s ‘localhost:9600/_node/os’?pretty curl -s ‘localhost:9600/_node/jvm’?pretty
Plugins Info API https://www.elastic.co/guide/en/logstash/current/plugins-api.html curl -s ‘localhost:9600/_node/plugins?pretty’
Node Stats API https://www.elastic.co/guide/en/logstash/current/node-stats-api.html
jvm Gets JVM stats, including stats about threads, memory usage, garbage collectors, and uptime. process Gets process stats, including stats about file descriptors, memory consumption, and CPU usage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f5f072bcf6ad485927f927224c830ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767fc40f50be54c301972ea7145874a9/" rel="bookmark">
			前端JS如何获取主域名(根域名)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击查看全文
背景 最近项目中需要获取url的主域名，比如www.baidu.com那么就需要获取baidu.com，看似简单，.号分隔，取到最后两位就行，但是坑爹的是有xxx.com.cn这类域名，还有很多日本的域名，类似toei.aichi.jp等，这些都无法通过这种简单的取最后两位的方式来获取，看来只能枚举了。
Public Suffix List 这问题肯定是早有人就遇到了，于是各路有识之士已经帮你完整得准备好了一个列表，里面全部都是那些奇葩域名，一些jp域名也是让我长见识了，不知道各位老司机在秋名山飙车的时候有没有见过这些个域名：
秋田.jp 群馬.jp 香川.jp 高知.jp 鳥取.jp 鹿児島.jp // jp geographic type names // http://jprs.jp/doc/rule/saisoku-1.html *.kawasaki.jp *.kitakyushu.jp *.kobe.jp *.nagoya.jp *.sapporo.jp *.sendai.jp *.yokohama.jp !city.kawasaki.jp !city.kitakyushu.jp !city.kobe.jp !city.nagoya.jp !city.sapporo.jp !city.sendai.jp !city.yokohama.jp // 4th level registration aisai.aichi.jp 感兴趣的朋友可以看看这个github项目：https://github.com/wrangr/psl。
这里有各种主域名的列表：https://publicsuffix.org/list/public_suffix_list.dat.
浏览器其实也有内置类似的东西，用来做域名判断，cookie存储之类的事宜。
pls的问题 问题看似好像解决了，已经有现成的脚本去获取，但是仔细一看这脚本竟然有将近200K，而我自己的脚本才10K，既然浏览器已经内置了pls，那浏览器有没有暴露内置接口呢？很遗憾，搜索了一下并没有，而且浏览器那么多，即使chrome暴露了，IE肯定没有，等等，刚刚好像我们说到浏览器用来做域名判断，cookie存储，那我们能不能用这类方式间接地去调用内置pls呢？
最终解决方案 目前想到有两种方式可以间接去调，document.doamin和document.cookie，测试一下就会发现，如果你尝试把当前域名设置为com.cn或者把cookie设置到com.cn上面，浏览器并不会生效，document.domain在第二次设置的时候，firefox会抛错，看来并不是很合适，而且可能多多少少会影响到业务，cookie设置方便，而且清除也方便，上代码：
function getMainHost() { let key = `mh_${Math.random()}`; let keyR = new RegExp( `(^|;)\\s*${key}=12345` ); let expiredTime = new Date( 0 ); let domain = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/767fc40f50be54c301972ea7145874a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951b19762f74e4ff308682c7370db0ad/" rel="bookmark">
			高可用&#43;高并发&#43;负载均衡架构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前篇：
《无限容量数据库架构设计》
《MQ消息可达性+幂等性+延时性架构设计》
都收到网友好评：
系统性，全局性看问题体会更深刻
简单易懂
本文再做总结，体系化介绍高可用，高并发，负载均衡的一些架构技术。
一、高可用
文章：《究竟什么是互联网高可用架构设计》
内容：
什么是高可用
高可用架构核心准则：冗余+故障转移
互联网分层架构，各层保证高可用的架构实践
二、高并发
文章：《究竟什么是互联网高并发架构设计》
内容：
什么是高并发
高并发架构准则：垂直扩展，水平扩展
互联网分层架构，各层保证水平扩展的架构实践
三、反向代理
文章：《究竟什么是互联网四层/七层反向代理》
内容：
什么是代理与反向代理
如何实施反向代理
什么是四层/七层，有没有二层/三层呢？
四、负载均衡
文章：《究竟什么是互联网负载均衡架构设计》
内容：
什么是负载均衡
高并发架构准则：均匀
互联网分层架构，各层保证负载均衡的架构实践
延伸阅读：《LVS为何不能取代DNS轮询》
内容：
什么是LVS，DNS轮询
LVS解决什么问题
DNS轮询解决什么问题
LVS为何不能取代DNS轮询
延伸阅读：《异构服务器负载均衡及过载保护》
内容：
如何动态标识服务的处理能力
如何实施异构服务器负载均衡
什么是过载保护
如何实施过载保护
1w字，30幅架构图，若干手绘图，不一定高深，但一定有收获，可先收藏，转发，再细细品味。
欢迎留言，有问必回。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8de02a98027306faab3732c4998cc1f9/" rel="bookmark">
			变量名的力量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 变量和变量名就本质而言是同一事物.
2. 为变量命名最重要的是,该名字要完全,准确的描述出该变量所代表的事物.
3. 对变量的描述就是最佳的变量名.
4. 一个好记的名字反应的通常都是问题,而不是解决方案.
5. 变量名平均长度在8-20之间,已确保名字含义足够清晰.
6. 把限定词(Total,Sum,Average,Max,Min)加到名字的最后,把最重要的那部分,即为这一变量赋予主要含义的部分应在最前面,还可以避免产生歧义.
7. 对仗词:(begin/end),(first/last),(locked/unlocked),(min/max),(next/previous),(old/new),(opened/closed),(visible/invisible),(source/target),(source/destination),(up/down)
8. 为一些特定类型的数据命名还要求做出一些特殊的考虑.
9. 如果一个变量在循环之外使用,就应该取一个比i,j,k有意义的名字.
10. 可以采用大小写方式命名,驼峰命名和下划线命名风格.
11. 采用任意的规则都好过没有规则.
12. 区分类和对象: 驼峰,前缀,更明确的解析.
13. 避免使用数字,避免拼错单词,避免在名字中包含容易混淆的单词,避免过于随意.
变量名包含以下三大信息:
1.变量的内容(它表示什么)
2.数据的种类(常量,简单变量,用户自定义类型,类)
3.变量的作用域(私有的,类的,包的,全局作用域)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab1db5bd721bd80c041eb90753e362a/" rel="bookmark">
			数组指针与指针数组的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组指针（也称行指针） 定义 int (*p)[n]; ()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。 如要将二维数组赋给一指针，应这样赋值： int a[3][4]; int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。 p=a; //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0] p++; //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
所以数组指针也称指向一维数组的指针，亦称行指针。
指针数组 定义 int *p[n]; []优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。 如要将二维数组赋给一指针数组: int *p[3]; int a[3][4]; p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针 for(i=0;i&lt;3;i++) p[i]=a[i] 这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2] 所以要分别赋值。
这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。 还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。 比如要表示数组中i行j列一个元素： (p[i]+j)、((p+i)+j)、((p+i))[j]、p[i][j]
优先级：()&gt;[]&gt;*
上文出处，内容更丰富
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a52424121c8ef718a10a126a29f919/" rel="bookmark">
			windows server2008R2如何安装.net framework4.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用某些软件的时候，需要在服务器安装.net framework 4.0依赖项，但是windows server 2008R2系统自带的.net framework的版本是3.5.1，而且直接安装4.0以上版本的时候会出现安装成功，但实际并不能用的情况。
解决方案：
在微软官网上下载SP1升级补丁，将2008R2系统升级成with SP1版本，
然后再安装.net 4.0以上版本即可（如果不行，尝试安装4.5版本）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86492a125badcfb0f741aad756923008/" rel="bookmark">
			ubuntu安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 踩到的坑
sudo apt-get install mysql-server-5.7 报错，各种要求依赖包。
Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming. The following information may help to resolve the situation: The following packages have unmet dependencies: mysql-server-5.7 : Depends: mysql-client-5.7 (&gt;= 5.7.17-0ubuntu0.16.04.1) but it is not going to be installed Depends: mysql-server-core-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86492a125badcfb0f741aad756923008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29c190ac0e190c93760b4be1f997112/" rel="bookmark">
			VMware共享文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用VMware共享文件夹时, 需要安装 VMware-tools, 于是将 cdrom 挂载到 /mnt, 复制出压缩包解压后进行安装, 结果总是不正常.
经过多次安装, 才注意到 vmware-install.pl 需要使用 /mnt 目录, 当挂载到 /mnt 时, vmware-install.pl 无法正常工作, 所以在运行这个脚本时, 要 umount /mnt ,卸载这个目录, 或者挂载到其他目录, 就这样吧.
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/294/">«</a>
	<span class="pagination__item pagination__item--current">295/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/296/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>