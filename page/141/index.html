<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161485978d4593aff148ab6356bb79a5/" rel="bookmark">
			ISO7816协议深度解析-简单易懂协议详解（四）-- T = 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一章链接：ISO7816协议深度解析-简单易懂协议详解（三）-- T= 0
12. 协议T=1，异步半双工字块传输
协议包含IC卡和TTL间的字组传送，以传达命令和R-APDU及控制信息（例如，确认）。数据链路层的字组帧结构，协议的时序和INF，以及协议的运用规定如下。
12.1 字组帧结构
• 强制性的组头字段
• 可选性的信息字段
• 强制性的组尾字段
前面所规定的字符帧仍是适用的，字组的结构如下所示：
12.1.1 组头字段
组头字段由3个强制性的字节组成：
• 结点地址用以标识数据块的源地址和目标地址，并提供对VPP状态控制的节点地址。
• 协议控制字节，控制数据的传送。
• 长度，指可选数据域长度。
12.1.1.1 结点地址（NAD—NODE ADDRESS）
NAD 的b1~b3位指明源节点地址（SAD—Source Node Address）,而b5~b7则指明目的节点地址（DAD—Destination Node Address）, b4和b8位未用且必须置为0。
12.1.1.2 协议控制字节（PCB-Protocol Control Byte）
协议通过PCB定义了三种基本块结构（不同类型的“块帧”）：
1）信息快（I 块）：用于传送应用层信息（APDU），及肯定或否定的确认信息。
2）接收就绪块（R块）：用于发送肯定（ACK-Acknowlegement）或否定（NAK-Negative Acknowlegement）的确认信息，其信息域（INF）不出现。
3）管理快（S块）：用于读卡器和卡之间交换控制信息，S块的信息域存在与否取决于S块控制功能的需要。
I-块和R-块会包含有“0”和“1”的序列号，序列号的初始值为“0”，重新同步之后也是再次从“0”开始，之后在“0”和“1”之间交替切换；如果一条应用数据大于数据块信息域的最大长度，则需要分割为若干个链接的数据块来传输；和T=0协议卡片发送“0x60”类似，如果卡片需要较长时间进行命令处理，可以用延长等待时间的WTX请求S-块让终端继续等待；一旦传输过程中出现错误，可以通过数据块重发、重新同步、卡片复位等动作来进行纠错。
12.1.1.3 长度（LEN-Length）
长度指明块的INF（Information Field）的长度，取值范围2~254个字节。0x00表明不存在信息域，0xFF留用。
12.1.2 信息域（INF）
信息字段是有条件的，当出现在I块中时，它传送的是应用数据；在S块中，它传送控制信息；在R块中不包含INF。
12.1.3 尾域（EDC-Error Detection Code检错码）
组尾字段包含所传送的字组的错误检测码（EDC）。当奇偶错或EDC错误发生时，字组是无效的。作为EDC在《EMV规范》中仅支持纵向冗余校验（LRC-Longitudinal Redundancy
Check）。LRC的长度是一个字节，从NAD开始到INF的最后字节在内的所有字节的“异或”值即为此字节之值。
12.1.4 块的编号
I块的编号采用了一位编码的模2数，编号系统对IC卡保持独立，而终端则作为发送方。在复位应答后，发送方传送的第一个I块的编号从0开始，而后，每传送一个I块就加1，此数由发送方在重新同步后，复位为0。
R块的编号也采用了一位编码的模2数。当用来在链接期间去确认一个I块时，R块带有所需求的下一个I块的编号。当用来请求重复某块时，R块带有所接收的I块的编号。
S块不带编号。
12.2 信息字段INF的容量和时序
12.2.1信息域大小
IFSC是IC卡所能接收的字组信息字段INF的最大长度,复位应答时,IC卡在TA3中回送的IFSI表示了IC卡的接纳的IFSC的最大长度. IFSI的取值范围为”10”至”EF”, 即IFSC的范围为16-254字节。因此,IC卡可能接收的最大块长度为(IFSC+3+1)字节,包括了头域和尾域。在复位应答中所确定的长度必须用于用卡过程中的其余部分，直至由于IC卡向终端发送S块（IFS请求）取得新的IFSC值为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/161485978d4593aff148ab6356bb79a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18e5b67a8536ce316582bda3f790db97/" rel="bookmark">
			Vue.config.js配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue.config.js是啥？ 在vue-cil创建项目时并不会创建vue.config.js文件。需要自己创建。此文件是一个可选配置文件和package.json同级的根目录中。可以用于直接编辑项目各项配置。默认配置保存在home 目录下一个名叫 .vuerc 的 JSON 文件中。也可以通过package.js使用JSON进行配置修改。至于用vue.config.js和package.json的区别暂时没研究过，可能单独配置更清晰吧。
用法： 具体的配置参数直接看官网就好：
配置参考 | Vue CLI🛠️ Vue.js 开发的标准工具https://cli.vuejs.org/zh/config/
文件位置： 具体写法:
这里拿引入sass做例子，直接导出在项目启动时会被 @vue/cli-service 自动加载。
总结: 下面是一些其他配置的详细写法还蛮详细的引过来参考一下。
https://www.jianshu.com/p/b358a91bdf2d ——配置详解
https://www.jianshu.com/p/f489e7764cb8 ——代理配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a853a0c544310c69b580135b550fea/" rel="bookmark">
			Java 命令行参数[猿教程]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://yuanjiaoc.com/tutorial/article/10188 介绍 从命令行中使用参数运行应用程序是很常见的。特别是在服务器端。通常情况下，我们不希望应用程序在每次运行时都做同样的事情：我们希望以某种方式配置其行为。
在这个简短的教程中，我们将探讨如何在Java中处理命令行参数。
在Java中获取命令行参数 由于main方法是Java应用程序的入口点，JVM通过其参数传递命令行参数。
传统的方法是使用一个String数组：
public static void main(String[] args) { // handle arguments } 然而，Java 5引入了varargs，它是披着羊皮的数组。因此，我们可以用一个String vararg来定义我们的main:
public static void main(String... args) { // handle arguments } 它们是相同的，因此选择它们完全取决于个人的品味和偏好。
主方法的方法参数包含命令行参数，其顺序与我们在执行时传递的参数相同。如果我们想访问我们得到了多少参数，我们只需要检查数组的长度。
例如，我们可以在标准输出上打印参数的数量和它们的值:
public static void main(String[] args) { System.out.println("Argument count: " + args.length); for (int i = 0; i &lt; args.length; i++) { System.out.println("Argument " + i + ": " + args[i]); } } 注意，在某些语言中，第一个参数将是应用程序的名称。另一方面，在Java中，这个数组只包含参数。
如何传递命令行参数 现在我们有了一个可以处理命令行参数的应用程序，我们急于尝试它。让我们看看我们有哪些选项。
命令行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85a853a0c544310c69b580135b550fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99668d43fc9946cafde061f6392ab7a6/" rel="bookmark">
			TFTP环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TFTP简介 TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务，端口号为69。
TFTP通常基于UDP协议而实现，但是也不能确定有些TFTP协议是基于其它传输协议完成的。TFTP协议的设计目的主要是为了进行小文件传输，因此它不具备通常的FTP的许多功能，例如，它只能从文件服务器上获得或写入文件，不能列出目录，不进行认证。
TFTP代码所占的内存较小，这对于较小的计算机或者某些特殊用途的设备来说是很重要的，这些设备不需要硬盘，只需要固化了TFTP、UDP和IP的小容量只读存储器即可。因此，随着嵌入式设备在网络设备中所占的比例的不断提升，TFTP协议被越来越广泛的使用。
二、在Ubuntu中安装TFTP命令 1、使用命令安装tftp-hpa 和 tftpd-hpa。 sudo apt-get install tftp-hpa tftpd-hpa 2、TFTP需要一个文件夹来存放文件 mkdir /home/wht/linux/tftpboot chmod 777 /home/wht/linux/tftpboot 注：要给 tftpboot 文件夹权限，否则的话 uboot 不能从tftpboot 文件夹里面下载文件。
3、配置 tftp 安装完成以后新建文件/etc/xinetd.d/tftp，如果没有/etc/xinetd.d 目录的话自行创建，然后在里面输入如下内容
server tftp { socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /home/wht/linux/tftpboot/ disable = no per_source = 11 cps = 100 2 flags	= IPv4 } 启动TFTP服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99668d43fc9946cafde061f6392ab7a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41244070c622bfa896efb7bb5bd92158/" rel="bookmark">
			mybatisplus分页查询——Page
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatisPlus分页详解 1.使用步骤(1)添加配置类2.测试分页 2.page类详解(1)page类的参数源码如下(2)各个参数的含义 1.使用步骤 (1)添加配置类 注意：一般在项目中创建一个config包，把配置类放到下面
@Configuration//标注该类是一个Spring配置类 public class MyBatisPlusConfig { @Bean//使用在方法上，标注将该方法的返回值存储到Spring容器中 public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; } } 2.测试分页 @GetMapping("/page") public R&lt;Page&gt; page(int page, int pageSize, String name) {//前端传过来分页所需要的参数 //Page类是mp提供的 // 构造分页构造器 Page pageInfo = new Page(page,pageSize); // 构造条件构造器 LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); // 添加过滤条件 queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name); // 添加排序条件 queryWrapper.orderByDesc(Employee::getUpdateTime); // 执行查询 employeeService.page(pageInfo,queryWrapper); //pageInfo中包含Page类的各个参数 return R.success(pageInfo); 2.page类详解 (1)page类的参数源码如下 private static final long serialVersionUID = 8545996863226528798L; protected List&lt;T&gt; records; protected long total; protected long size; protected long current; protected List&lt;OrderItem&gt; orders; protected boolean optimizeCountSql; protected boolean isSearchCount; protected boolean hitCount; protected String countId; protected Long maxLimit; (2)各个参数的含义 (1)records:用来存放查询出来的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41244070c622bfa896efb7bb5bd92158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c351d3e54ea386590e829fa5613314c0/" rel="bookmark">
			element-ui级联选择器Hover问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方示例：
&lt;span class="demonstration"&gt;hover 触发子菜单&lt;/span&gt; &lt;el-cascader v-model="value" :options="options" :props="{ expandTrigger: 'hover' }" @change="handleChange"&gt;&lt;/el-cascader&gt; 解决办法：
&lt;el-cascader v-model="catevalue" //把选定的值的id 双向绑定到数组中 :options="cateList" //级联选择器的样式？ :props="cateProps" //数据来源 expand-trigger="hover"//移动效果 不需要点击 @change="handleChange"//改变事件 &gt;&lt;/el-cascader&gt; 由于之前的办法已经废除了 就用了这个办法 同样是移动鼠标选择二三级菜单 不需要点击
觉得有用就点个赞吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6119dd055382c0eb14ec2e3161a90f7/" rel="bookmark">
			POJ1064Cable master题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POJ1064Cable master题解 题目链接字面描述 思路代码实现 题目 链接 http://poj.org/problem?id=1064
字面描述 Cable master
Time Limit: 1000MS Memory Limit: 10000K
Total Submissions: 97345 Accepted: 19783
Description
Inhabitants of the Wonderland have decided to hold a regional programming contest. The Judging Committee has volunteered and has promised to organize the most honest contest ever. It was decided to connect computers for the contestants using a “star” topology - i.e. connect them all to a single central hub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6119dd055382c0eb14ec2e3161a90f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595f56861bba9d4566d88c6edd058ac8/" rel="bookmark">
			编译ebpf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先升级内核:
CSDN
yum install -y centos-release-scl yum install -y devtoolset-11-gcc-c++ iperf3 wget http://repo.iotti.biz/CentOS/7/x86_64/netperf-2.7.0-1.el7.lux.x86_64.rpm rpm -ivh netperf-2.7.0-1.el7.lux.x86_64.rpm rpm -e gcc-4.8.5 gcc-c++-4.8.5 ln -s /opt/rh/devtoolset-11/root/bin/cc /usr/bin/cc ln -s /opt/rh/devtoolset-11/root/bin/c++ /usr/bin/c++ ln -s /opt/rh/devtoolset-11/root/bin/gcc /usr/bin/gcc 以下报错解决办法:
CMake Error at CMakeLists.txt:1256 (add_subdirectory): add_subdirectory given source "/opt/llvm-14.0.3.src/../third-party/benchmark" which is not an existing directory. https://github.com/llvm/llvm-project/issues/54941
从github上面看到，貌似是cmake的bug或feature
解决方案：
vi CMakeCache.txt LLVM_INCLUDE_BENCHMARKS:BOOL=OFF 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0afdf73b874a231b9b0ea0ce0e5422/" rel="bookmark">
			centos升级最新内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最新内核地址：https://cdn.kernel.org
导入key，安装elrepo的yum源 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org yum -y install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm 安装最新稳定版内核 yum -y --enablerepo=elrepo-kernel install kernel-ml* perf 查看当前的内核默认启动顺序，最新的内核在第一个位置，就是0 awk -F\' '$1=="menuentry " {print $2}' /etc/grub2.cfg 设置当前默认的启动顺序, 并重启 grub2-set-default 0 reboot 查看内核版本 uname -r 查看当前内核版本 rpm -q kernel	查看系统中已安装的内核 将老内核一个个删除 yum -y remove kernel-3.10.0-* kernel-headers-3.10.0-* reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d521cb046c3faa9cbdc0e678d69feb05/" rel="bookmark">
			SpringBoot - WebMvcConfigurer的作用是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 WebMvcConfigurer是一个接口，用于配置全局的SpringMVC的相关属性，采用JAVABEAN的方式来代替传统的XML配置文件，提供了跨域设置、静态资源处理器、类型转化器、自定义拦截器、页面跳转等能力。
WebMvcConfigurer 在 Spring Boot 2.x 中官方建议使用该接口来实现自定义配置。所以，Spring Boot 2.x 中，自定义 SpringMVC 配置可以通过实现 WebMvcConfigurer 接口来完成。
源码说明 public interface WebMvcConfigurer { // 配置路径匹配规则 default void configurePathMatch(PathMatchConfigurer configurer) { } // 内容协商 default void configureContentNegotiation(ContentNegotiationConfigurer configurer) { } // 异步调用支持 default void configureAsyncSupport(AsyncSupportConfigurer configurer) { } // 静态资源默认处理器 default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { } // 格式化器, 可以把时间转化成你需要时区或者格式，还可以将对象A转换为对象B。 default void addFormatters(FormatterRegistry registry) { } // 请求拦截器 default void addInterceptors(InterceptorRegistry registry) { } // 静态资源映射器 default void addResourceHandlers(ResourceHandlerRegistry registry) { } // 跨域设置 default void addCorsMappings(CorsRegistry registry) { } // 视图控制器 default void addViewControllers(ViewControllerRegistry registry) { } // 视图解析器 default void configureViewResolvers(ViewResolverRegistry registry) { } // 参数处理器 default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) { } // 返回值处理器 default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) { } // 信息转化器 default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d521cb046c3faa9cbdc0e678d69feb05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26c664f1a87e14bc8d25cfd4a9e21cf/" rel="bookmark">
			Charles设置代理&amp;手机和浏览器抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在Charles官网https://www.charlesproxy.com/download/下载，我这边下载的是免费体验版的，如果你英文看着费劲，网上有汉化包。
2.安装好以后打开，配置Charles证书；选择
help——SSL Proxying——install Charles Root Certificate
会出现证书安装的信息，我这边已经安装成功，第一次可能需要安装
将证书安装在“受信任的根证书颁发机构”，这步很重要
最后提示导入成功，出现如上述证书信息显示说明证书安装成功，也可在证书路径中查看证书安装结果
3.勾选Proxy——Windows Proxy
4.选择Proxy——SSL Proxy Setting，添加Location
Host和Port均设为*，
注:这个地方我设置的是*:443
5、想要对浏览器请求进行抓包，还要对浏览器的证书进行设置，如下图操作
出现如下提示信息，提示你去路径 chls.pro/ssl 下载证书,访问路径可自动下载
6、导入浏览器证书，这里以Chrome浏览器为例，打开设置 – 隐私设置和安全性 – 安全 – 管理证书
7、按如下步骤进行选择证书导入，记得第3步文件类型要选择所有，不然匹配不到pem格式的文件
8、和工具端一样，将证书存储到“受信任的根证书颁发机构”下，后面直接下一步即可
9、现在打开www.baidu.com里搜索Charles进行进行抓包测试，可以看到抓包成功
注意第5步,一定要操作,不然会unknown错误！！！，且会出现百度随便搜个啥都显示 【xxx不受信任】
注意，如果证书安装了，也添加了信任，Chrome浏览器抓包数据还是上图的unknown或者不受信任，那就是证书没装好或者装了没生效 ，重启Chrome浏览器就好了。 iPhone/ipad 代理设置 开启方法：
老版iPhone 设置”—&gt; “Wlan”—&gt; 查看WiFi详情 —&gt; “HTTp代理”改为手动—&gt; 点击保存（ios11以前貌似没有保存按钮，点击返回即保存）
iPhone11 设置 – 无线局域网 --你连的wifi，点蓝色圆圈图标 – HTTp代理 – 选 手动，填服务器和端口 – 点 存储
数据：主机名设置为代理主机的IP，端口默认是8888
安卓机 代理设置（以小米5为例） 开启方法：“设置”—&gt; “Wlan”—&gt; 查看WiFi详情 （部分手机是叫高级设置）—&gt; “代理”改为手动
数据：主机名设置为代理主机的IP，端口默认是8888
然后手机浏览器去访问 http://chls.pro/ssl 下载证书，安装并添加信任 一、iOS客户端安装证书
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d26c664f1a87e14bc8d25cfd4a9e21cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b8462740ebd620f3db8b373ba59820/" rel="bookmark">
			win10下在虚拟机中下载安装ubuntu16、下载安装Anaconda以及apt/pip/conda换源等系列操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10下在虚拟机中下载安装ubuntu16等系列操作 1）下载安装VMware workstation 1.0 下载 1.0.0进入官网下载Workstation Pro
官网：VMware 中国 - 交付面向企业的数字化基础 | CN
1.0.1点击红方框处到国外网站下载。网页下方的下载链接需要注册账号登陆。
1.0.2点击下载即可。
1.1 安装 1.1.0安装过程十分简单，可根据需要更改安装路径，其余的直接Next下一步就好了。
1.1.1 用户体验设置出不需要勾选。
1.1.3 根据习惯创建快捷方式
1.1.4 等待安装。
1.1.5 VMware workstation 需要批量授权许可证，许可证请自行搜索解决。
1.1.6 安装完后需要重启。
2）在虚拟机中安装ubuntu16系统 本节重点在于安装，下载部分稍微提一下。
2.0 下载 ubuntu官网：Download Ubuntu Desktop | Download | Ubuntu
读者在下载ubuntu的时候，请下载LTS后缀的。LTS即Long-term support 长期支持。
当然，下图是Ubuntu20的版本的，而我们需要的是ubuntu16这个版本的，所以请读者自行在官网搜索ubuntu16的下载页面。
2.1创建空白虚拟机 下载好后我们会得到一个ISO压缩文件（请勿解压）。
设置虚拟机默认路径 打开虚拟机 编辑==&gt;首选项
根据个人需求选择虚拟机的位置。
点击创建虚拟机。
注意，选择自定义(高级)这个选项
硬件兼容性，因我校机房VMware workstation为10.x版本，考虑到后续我们会将虚拟传到机房电脑中使用，为使得两者兼容，我建议将硬件兼容性设置为10.x版本的workstation。当然，没有这种顾虑的读者可忽略该操作。
先创建一个空白的虚拟机，因为是第一次装ubuntu，后续可能会有一些出人
意料的问题，我们需要调试一下，所以先装配置ubuntu系统。
因为我们要装的是ubuntu，ubuntu是Linux的分支 所以操作系统选Linux，我是64位的机器，故我选Ubuntu64，如果是32位的就选Ubuntu32
给你创建的虚拟机取个名字，路径会自动生成。
给虚拟机设置处理器和内核数量，这个要根据自己电脑的配置来。
我一般是设置2,2
给虚拟机配置内存，也是需要根据电脑硬件配置来设置的，例如我的电脑内
存是8G，那一般就分配2G内存给虚拟机。当然了，不能把8个G的内存都
分配给虚拟机。
以下4个步骤直接按照默认设置就好了。
装一个ubuntu系统大概需要7G，windows系统需要20G，考虑到我们后续在
虚拟机内要下载安装的东西比较多，所以就给虚拟机分配40G的磁盘。
另外要主要选择将虚拟磁盘拆分成多个文件，如果将虚拟磁盘储存为单个文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b8462740ebd620f3db8b373ba59820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda24662de726d1138d0197397b773c3/" rel="bookmark">
			python学习笔记--字典和集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典 添加键值对 为字典添加新的键值对很简单，直接给不存在的 key 赋值即可，具体语法格式如下：
dictname[key] = value
对各个部分的说明：
dictname 表示字典名称。key 表示新的键。value 表示新的值，只要是 Python 支持的数据类型都可以。 修改键值对 Python 字典中键（key）的名字不能被修改，我们只能修改值（value）。
字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。
是否存在指定键值对 如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。 keys()、values() 和 items() 方法 将这三个方法放在一起介绍，是因为它们都用来获取字典中的特定数据：
keys() 方法用于返回字典中的所有键（key）；values() 方法用于返回字典中所有键对应的值（value）；items() 用于返回字典中所有的键值对（key-value）。 处理上面的返回数据可以：
1) 使用 list() 函数，将它们返回的数据转换成列表， 2) 使用 for in 循环遍历它们的返回值
a = {'数学': 95, '语文': 89, '英语': 90} b = list(a.keys()) print(b) a = {'数学': 95, '语文': 89, '英语': 90} for k in a.keys(): print(k,end=' ') print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda24662de726d1138d0197397b773c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4711f6d085b294cb12429f9062fb2409/" rel="bookmark">
			vue-puzzle-vcode与vue-drag-verify纯前端的拼图人机验证、右滑拼图验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载作品！以获取原作者允许，原文地址，感觉写的比较全面，也比较实用，大家可以去看看原文章；
纯前端的拼图人机验证、右滑拼图验证
1、vue-puzzle-vcode github地址：https://github.com/javaLuo/vue-puzzle-vcode
效果图 示例 import Vcode from "vue-puzzle-vcode"; &lt;Vcode :show="isShow" :canvasWidth="400" :canvasHeight="250" :puzzleScale="1" :sliderSize="40" :range="10" :imgs="[Img1, Img2]" successText="验证成功！" failText="验证失败，请重试！" sliderText="拖动滑块验证" @success="onSuccess" @fail="onFail" /&gt; 参数 字段类型默认值说明showBooleanfalse是否显示验证码弹框canvasWidthNumber310主图区域的宽度，单位 pxcanvasHeightNumber160主图区域的高度，单位 pxpuzzleScaleNumber1拼图块(小的拼图)的大小比例，0.2 ～ 2 ，数字越大，拼图越大sliderSizeNumber50左下角用户拖动的那个滑块的尺寸，单位 pxrangeNumber10判断成功的误差范围，单位 px, 滑动的距离和拼图的距离小于等于此值时，会判定重合imgsArraynull自定义图片，见下方例子successTextString“验证通过！”验证成功时的提示文字failTextString“验证失败，请重试”验证失败时的提示文字sliderTextString“拖动滑块完成拼图”下方滑动条里的文字 事件 事件名返回值说明success偏差值验证通过时会触发，返回值是用户移动的距离跟目标距离的偏差值 pxfail偏差值验证失败时会触发，返回值同上closenull用户点击遮罩层的回调 现在这个也是支持vue3的，大家可以去github上看具体教程
2、vue-drag-verify github地址：https://github.com/AshleyLv/vue-drag-verify
效果图 示例 import dragVerify from "vue-drag-verify"; &lt;drag-verify :width="300" :height="50" text="拖拽滑块右滑验证" successText="验证成功" background="#ccc" color="#fff" progressBarBg="#ff9" completedBg="#58bc58" :circle="true" handlerIcon="el-icon-thumb" successIcon="el-icon-check" handlerBg="#F9B344" textSize="16px" @passcallback="onPasscallback" /&gt;	属性 参数类型属性说明widthNumber200组件的宽度heightNumber60组件的高度textStringswiping to the right side文本显示在组件上successTextStringsuccess文本显示何时成功backgroundString#ccc组件的背景颜色colorString#ffffff文字的颜色progressBarBgString#FFFF99进度条的背景颜色completedBgString#66cc66按钮拖到右侧时组件的背景颜色circleBooleantrue如果为真，则组件的形状为圆形handlerIconString-处理程序的图标successIconString-按钮拖到右侧时的处理程序图标handlerBgString#fff处理程序的背景颜色textSizeString20px提示信息的字体大小 事件 事件名说明passcallback通过验证时发出，处理程序拖动到右侧。 3、基于vue-drag-verify二次开发的vue组件 注意：需对父元素或html设置user-select: none
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4711f6d085b294cb12429f9062fb2409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5280980f5baa761da7ae6a652118d2b/" rel="bookmark">
			k8s 中的亲和性和反亲和性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下，Pod分配到哪些Node是不需要管理员操心的，这个过程会由scheduler自动实现，因为调度程序会自动进行合理的调度（如通过一系列的评分机制将 pods 合理分配到最优节点上，而不会将 pod 分配在没有足够资源的节点上等）。但有时，我们需要指定一些调度的限制，例如某些应用应该跑在具有SSD存储的节点上，或者将两个通信比较频繁的不同服务 pod 调度到同一个可用域等等。
labels 在 K8s 中是一个很重要的概念，作为一个标识，Service、Deployments 和 Pods 之间的关联都是通过 label 来实现的。而每个节点也都拥有 label ，通过设置 label 相关的策略可以使得 pods 关联到对应 label 的节点上。
nodeSelector 首先我们为Node规划标签，然后在创建部署的时候，通过使用nodeSelector标签来指定Pod运行在哪些节点上。
nodeSelector 是最简单的约束方式。 nodeSelector 是 PodSpec 的一个字段。
通过 --show-labels 可以查看当前 nodes 的 labels
$ kubectl get nodes --show-labels NAME STATUS ROLES AGE VERSION LABELS minikube Ready &lt;none&gt; 1m v1.10.0 beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/ hostname=minikube 如果没有额外添加 nodes labels ，那么看到的如上所示的默认标签。我们可以通过 kubectl label node 命令给指定 node 添加 labels ：
$ kubectl label node minikube disktype=ssd node/minikube labeled $ kubectl get nodes --show-labels NAME STATUS ROLES AGE VERSION LABELS minikube Ready &lt;none&gt; 5m v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5280980f5baa761da7ae6a652118d2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f18a14955adc6f53014e2b0a2d2453/" rel="bookmark">
			not executable: 64-bit ELF file 已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		not executable: 32-bit ELF file 已解决
not executable: 64-bit ELF file 已解决
如上二个问题
1，在ubuntu系统中
gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf 安装
sudo apt install arm-linux-gnueabihf会有提示
gcc-linaro-7.5.0-2019.12-i686_arm-linux-gnueabihf
方案一：用静态编译，且用交叉编译工具编译：
交叉编译工具链可以自己下载解压后使用，下载链接：https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2784aad544eb196c5b2c066aa6e484/" rel="bookmark">
			信息学奥赛一本通习题答案（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息学奥赛一本通习题答案 最近在给小学生做C++的入门培训，用的教程是信息学奥赛一本通，刷题网址为http://ybt.ssoier.cn:8088/index.php
现将部分习题的答案放在博客上，希望能给其他有需要的人带来帮助
篇幅有限，所以从分支结构开始，所有代码都可以正确提交，鉴于本人能力有限以及教学需要，部分代码写的不是那么简洁，望诸位多多指教。
以下是题号和代码
2051
#include&lt;iostream&gt; using namespace std; int main(){ int a; cin&gt;&gt;a; if(a%2 == 0) cout&lt;&lt;"yes"; } 2052
#include&lt;iostream&gt; using namespace std; int main(){ int a; cin&gt;&gt;a; if(a &gt; 1&amp;&amp;a&lt;100) cout&lt;&lt;"yes"; } 2053
#include&lt;iostream&gt; using namespace std; int main(){ int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a &lt; b){ int t = a; a = b; b = t; } if(a &lt; c){ int t = a; a = c; c = t;	} if(b &lt; c){ int t = b; b = c; c = t;	} cout&lt;&lt;a&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e2784aad544eb196c5b2c066aa6e484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b362d6018fabb427aed5ae7cdaedb0d0/" rel="bookmark">
			Error running tomcat8: Address localhost:80 is already in use错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题 针对之前暴力解决报红问题，现在80端口问题
启动Tomcat时，遇到了Error running tomcat8: Address localhost:80 is already in use的错误，查找了解决方案，并进行记录。
2.解决 2.1 由于修改是8080端口
在 E:\software\apache-tomcat-8.5.81\conf下面的server.xml文件下修改回来就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138746fb965ec9c0d49039f4727c7f6c/" rel="bookmark">
			IDEA中找不到maven插件Plugin‘ ‘ not found 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&lt;version&gt;3.8.0&lt;/version&gt;等 报红 1.1首先要找设置File--Settings--Build,..--Maven
1.2然后就继续File--Invalidata Caches 点击这个键，再开启idea然后在设置pom.xml文件的代码
&lt;!-- 插入代码--&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 演示:
​ &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;!-- 插入代码--&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; ​ 然后就OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da50424f0d2d0fa865b8993d72a3af5a/" rel="bookmark">
			Could not find artifact org.apache.tomcat.maven:tomcat7-maven-plugin:pom.....报红
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在pom.xml文件中直接暴力配置 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/shiro&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;url&gt;http://localhost:8080/shiro&lt;/url&gt; &lt;server&gt;Tomcat7&lt;/server&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e274fa7d7f7ed295f67e7e545be326/" rel="bookmark">
			MyBatis-Plus条件构造器入门学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis-Plus条件构造器入门学习 官网：https://baomidou.com/pages/10c804/#abstractwrapper
AbstractWrapper 是QueryWrapper(LambdaQueryWrapper) 和UpdateWrapper(LambdaUpdateWrapper) 的父类。
PS:入参boolean condition表示该条件是否加入最后生成的sql中，例如：query.like(StringUtils.isNotBlank(name), Entity::getName, name) .eq(age!=null &amp;&amp; age &gt;= 0, Entity::getAge, age)
allEq 方法：
allEq(Map&lt;R, V&gt; params) allEq(Map&lt;R, V&gt; params, boolean null2IsNull) allEq(boolean condition, Map&lt;R, V&gt; params, boolean null2IsNull) allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params) allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, boolean null2IsNull) allEq(boolean condition, BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, boolean null2IsNull) 使用实例：
Map map=new HashMap(); map.put("name","周杰伦9"); map.put("age",null); //方法对应生成的sql wrapper.allEq(map);//allEq({name:"周杰伦9",age:null})---&gt; name = '周杰伦9' and age is null wrapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e274fa7d7f7ed295f67e7e545be326/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2f8f0545ebf8dd1c757a7005ddb028/" rel="bookmark">
			Idea （优选）cherry-pick操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：将dev 分支的部分提交，合并到master分支
1.先牵出master分支
2.在idea 的Git上现在dev分支然后点击 优选（cherry-pick）
3.然后push就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927d9fe7421beafaa70af4e0f916599b/" rel="bookmark">
			【实战原创】Centos7下Samba服务器配置（实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了Centos7下Samba服务器配置（实战），文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧
Samba概述
Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。
一，Samba共享服务的匿名访问
1，安装Samba服务
1
[root@localhost ~]# yum install samba -y ##安装Samba服务
2，配置Samba配置文件信息
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
[root@localhost ~]# cd /etc/samba/ ##切换到Samba配置文件目录
[root@localhost samba]# mv smb.conf smb.conf.bak ##备份
[root@localhost samba]# grep -v "#" smb.conf.bak &gt; smb.conf ##重新创建一个配置文件（除去注释的）
[root@localhost samba]# vim smb.conf ##修改配置文件
[global] ##全局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/927d9fe7421beafaa70af4e0f916599b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa60f63493ce469b68e5913f9cdda622/" rel="bookmark">
			地理探测器——Geodetector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地理探测器 网址：http://www.geodetector.cn/
缘起 首先明确空间统计学与经典统计学的区别。
1、在经典统计学中，研究对象是同一类的。而空间统计学的研究对象是地理对象，是不同类的。
空间统计学的研究对象数据来源是空间数据。
2、经典统计学的第二大假设是：研究对象都是同分布的；而空间统计学中，地理学研究的对象具有区域性，规律不一样，不同区域参数不一样，变量不一样，倘若不存在地理分异，直接用时间序列做研究即可，就不会有地理学相关的研究。
空间数据的一大特性是空间自相关性，而经典的统计学的研究对象都是独立的，这是第一大假设。与我们地理学上研究的对象不符合，因此，产生了以克里金为代表的空间自相关的一套空间统计学方法。
空间数据的第二大特性是空间分异性，或者叫空间分异性、空间分层异质性、空间差异性、空间分区特性
空间分异性Spatial Stratified Heterogeneity (SSH)定义 空间分异性，在统计学上来讲是一种现象，表达的是一种层内比层间更相似的现象
空间分异性是自然的规律，在过去的地理学研究中，地理研究者通过聪明才智观察并揭示认识自然规律，并解释其归因
而今天，人们找到并使用一种机器学习的办法来研究对自然现象的规律性的认识，进而对它的的形成原因进行阐述
于是地理探测器应运而生
对于组内比组件更相似的空间分异性的阐释，除了用语言表达之外，需要对他用数学公式进行表示
地理探测器的核心公式是
关于地理探测器的使用，该工具有R语言版本以及excel宏版本两种
相关数据下载：
在excel中用宏的形式嵌入软件功能，最后在excel中形成图表形式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb027bad8ccfc653c470161e37663bc/" rel="bookmark">
			如何画一个算法流图？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、流程图的基本组成 一般由框和流程线（带箭头的直线）组成。
1.1 起止框(不可或缺) 上面的圆角矩形代表算法的开始或结束。
1.2 输入、输出框 上面的平行四边形代表算法的输入和输出。
1.3 处理框（执行框） 上面的矩形代表数据的处理和执行，一般是赋值或者计算两种类型。按照约定，赋值一般用 ← \leftarrow ←来表示，如下：
1.4 判断框 上面的菱形代表条件的判断，一般来说判断条件是：两元判断，当然也不排除有多个判断。
二、流程图的基本原则 为了增加框图的可读性，需要规定一些规则：
请使用标准的框图符号，而不是自定义符号整体绘制方向是从上到下、从左往右除了判断框外，大多数框图只有一个进入点和一个退出点判断框除了有是否两元判断还可能有多分支判断语言尽可能精炼开始框只有一个流出线，终止框只有一个流入线，输入、输出框只有一个流入线和一个流出线，判断框一般有一个流入线和两条流出现，任何时候只有一条起作用 三、一个例子 根据程序流图，程序实现就相当容易了(以C为例)：
int sumUp(int s,int e) { int sum=0; while(s&lt;=e) { sum+=s; s++; } return sum; } [1] https://wenku.baidu.com/view/bf2dde9501d276a20029bd64783e0912a2167c63.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d374ef4382db038191ae7abd0c19b9/" rel="bookmark">
			Spring5.x之@Resource原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目的 1、了解@Resource的作用
2、从源码探讨是如何工作的
3、Spring是如何找到bean哪些属性被@Resource修饰的
4、找到需要注入的属性，那属性值是又如何找到的
5、注解是JDK集成的为什么Spring要支持该注解
准备 老规矩看源码构建教程
说明 首先从@Resource的注释下手
javax.annotation.Resource
The Resource annotation marks a resource that is needed by the application.
资源注释标记应用程序所需的资源
This annotation may be applied to an application component class, or to fields or methods of the component class.
此注释可以应用于应用程序组件类，或者应用于组件类的字段或方法。
When the annotation is applied to a field or method, the container will inject an instance of the requested resource into the application component when the component is initialized.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d374ef4382db038191ae7abd0c19b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1749f250dec630dc128d2cfd5d785ef7/" rel="bookmark">
			决策树算法python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树算法Python实现 Python决策树实现一、sklearn实现决策树分类1.1 导入sklean中的tree模块1.2 使用sklean的基本流程1.3 DecisionTreeClassifier()的参数解释1.4 剪枝操作1.5绘制决策树 Python决策树实现 一、sklearn实现决策树分类 1.1 导入sklean中的tree模块 from sklean import tree 模块解释tree.DecisionTreeClassifier分类树tree.DecisionTreeRegressor回归树tree.export_graphviz将生成的决策树导出为DOT模式，画图专用tree.ExtraTreeClassifier高随机版本的分类树tree.ExtraTreeRegressor高随机版本的回归树 1.2 使用sklean的基本流程 实例化模型对象 clf = tree.DecisionTreeClassifier() 通过模型接口训练模型 clf = clf.fit(X_train,y_train) 通过测试集对模型评分（0-1） Test_score = clf,score(X_test,y_test) 1.3 DecisionTreeClassifier()的参数解释 clf = tree.DecisionTreeClassifier(criterion='entropy/gini',random_state = None,splitter='best/random') criterion criterion这个参数正是用来决定不纯度的计算方法的。skleran提供了两种选择。
输入"entropy"，使用信息熵。
输入“gini”，使用基尼系数。
对于高维数据或者噪音很多的数据，信息熵很容易过拟合，基尼系数在这种情况下效果往往会更好。
random_state random_state用来设置分支中的随机模式的参数，默认为None，在高维度时随机性会表示的更加明显。
splitter splitter也是用来控制决策树中的随机选项的，有两种输入值。
输入“best”，决策树在分支时虽然随机，但是还是会优先选择更加重要的特征进行分支；
输入"random",决策树会在分支时更加随机，树会因为含有更多的不必信息而更深更大，可能会导致过拟合问题。
当你预测到你的模型可能会过拟合，用这两个参数可以帮助你降低树建成之后过拟合的可能性。当然，树一旦建成，我们依然是使用剪枝参数来防止过拟合。
1.4 剪枝操作 max_depth(预剪枝) 限制树的最大深度，超过设定深度的树枝全部剪掉
min_samples_leaf 一个节点在分支后的每个子节点都必须包含至少min_samples_leaf个训练样本，否则分支就不会发生，或者，分支会朝着满足每个子节点都包含min_samples_leaf个样本的方向去发生。
min_samples_split 一个节点必须要包含至少min_samples_split个训练样本，这个节点才允许被分支，否则分支就不会发生。一般搭配max_depth使用，这个参数的数量设置的大小会引起过拟合，设置的太大会阻止模型学习数据。对于类别不多的分类问题，=1通常就是最佳选择。一般来说，建立从=5开始使用。如果叶节点中含有的样本量变化很大，建立输入浮点数作为样本量的百分比来使用。同时，这个参数可以保证每个叶子的最小尺寸，可以在回归问题中避免低方差，过拟合的叶子节点出现。
max_features 限制分枝时考虑的特征个数，超过限制个数的特征都会被舍弃，和max_depth相似
min_impurity_decreases 限制信息增益的大小，信息增益小于设定数值的分枝不会发生。
确认最优的剪枝参数
我们已经训练好的决策树模型 c l f clf clf，确定超参数的曲线来进行判断，超参数的学习曲线，是一条以超参数的取值为横坐标，模型的度量指标作为纵坐标的曲线，它是用来衡量不同超参数取值下模型的表现的线，我们的模型度量指标就是score。 from sklearn.tree import DecisionTreeClassifier import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1749f250dec630dc128d2cfd5d785ef7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6075af6cd9929ad6998fc47e351ebc0/" rel="bookmark">
			【初识linux命令】安装SSH/VIM服务 linux部分指令！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装ssh服务的命令：sudo apt install openssh-server
2.ssh服务的启动：service sshd start
3.mv 对文件重命名的命令
对文件进行隐藏前面加. （例：mv aaa(文件名) .aaa(文件名)） 查找隐藏文件命令： ls -al
取消隐藏文件命令： mv .fff(文件名) fff（要改的文件名；）
4.touch 创建一个空文件 （例：touch aaa.c(文件名)）
5.cp 原文件名 目的文件名 拷贝 原文件成目的文件
cp-r 原目录文件名 目的目录文件名 -r是递归的意思 -f是强制的意思（例：cp -r ./文件名/.txt ./文件名/.txt）
（cp -r ./aaa/bbb/1.txt ./fff）
6.vim 文件名(例：text.c) 如果对这个文件查询存在的话进行打开，不存在进行创建
安装vim指令：sudo apt install vim
例（1)、创建vim文件名（vim list.txt）
（2、进入vim按i,使最下方进入inser状态，可以对文本进行编辑
（3、Esc为退出编辑状态
（4、：wq为退出状态
：w 保存 ：q 退出 q!强制退出
（5、设置行号要先退出编辑状态，按shift+冒号 set nu vim的三种模式
a.命令模式/普通模式
vim打开文件时的默认模式
在此模式下输入/字符串，查找字符串，按n找一个字符串
yy 复制 数字+yy 复制多行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6075af6cd9929ad6998fc47e351ebc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ae904f98a1f953e8688178a3b5cc2e/" rel="bookmark">
			OpenSSL SSL_read: Connection was reset, errno 10054
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果账号密码没错 或者是用的token认证。 那么很有可能是因为网不好没有push上去！ 那么很有可能是因为网不好没有push上去！！ 那么很有可能是因为网不好没有push上去！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893983cbd0e6e8a2a79ce2fa3f8d451f/" rel="bookmark">
			ubuntu18.04&#43;RTX3090安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu18.04+RTX3090安装：可以参考，在安装显卡部分不需要全部做完，主要做到sudo apt-get update即可RTX3090在ubuntu18.04下安装NVIDIA驱动以及cuda与cudnn教程_weixin_45853361的博客-CSDN博客_ubuntu安装cudnn
显卡安装：
1.更新源：sudo gedit /etc/apt/sources.list
2.sudo apt-get update 注意，这个应该比较旧，因为要更新很多内容，要注意下，等更新后再执行下一步，我前面就是太着急了，没等更新结束，就按博客继续往下操作
3.nvidia-smi看下是否已经安装好了
4.也可查看：“软件和更新”--&gt;“附加驱动”--&gt;NVIDIA Corporation 有选项即可
cuda安装：Ubuntu之cuda11.4安装_恒悦sunsite的博客-CSDN博客_ubuntu安装cuda11
下面的链接在安装显卡部分不需要全部做完，主要做到sudo apt-get update即可RTX3090在ubuntu18.04下安装NVIDIA驱动以及cuda与cudnn教程_weixin_45853361的博客-CSDN博客_ubuntu安装cudnn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ac48fd08047ce2cd3636f3df013001/" rel="bookmark">
			ARMv6 ARMv7 架构 整体介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 市场应用领域市占率常见产品 架构编程模型运行状态指令集寄存器非特权级别(usr模式)下不建议访问的指令与寄存器ABI 异常模型特权级异常种类 内存模型VMSA&amp;MMU内存一致性cache debug模型External DebugSelf-hosted DebugTrace boot模型虚拟化模型安全模型 开发工具gcc toolchain &amp; gdbqemu常见开发环境(除qemu外) 软件开发裸机(baremetal)RTOSLinuxarm32-linux镜像arm32-linux boot 符号debugbootboot时的内存管理架构相关代码通用知识:如何新增一个架构 微架构 市场 应用领域 嵌入式 市占率 常见产品 架构 架构整体综述 编程模型 运行状态 armv6/v7 有两种执行状态，arm和thumb。 //cpsr 的 T // 0:arm // 1:thumb // 应该reset 是 arm 状态 // 异常时,cpsr 中的 T 被置位 0 , 也就是 进入arm state 指令集 ARM&amp;THUMB&amp;VFP&amp;SIMD指令集ARMv7/ARMv8/RV32/RV64指令集及寄存器对比 寄存器 R0-R7 R8-R12 R13-R15 及其BANK寄存器CPSRSPSR 及其BANK寄存器CP15寄存器 非特权级别(usr模式)下不建议访问的指令与寄存器 // 指令集 mcr/mrc cdp/ldc/stc mcrr/mrrc // 寄存器 协处理器寄存器 ABI arm abi : ATPCSARM 汇编 调用约定ABI与汇编语法 异常模型 特权级 7种处理器模式(SVC/ABT/UND/IRQ/FIQ &amp; USR/SYSTEM)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ac48fd08047ce2cd3636f3df013001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/391c052ea1e99aba9a87afee20f07af2/" rel="bookmark">
			【vue】报错：Error: [ElTable] prop row-key is required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错原因：row-key是必填项
解决：
1.el-table标签上添加:row-key=“getRowKey”
&lt;el-table border :data="isNext?meetingData:tableData" ref="table" v-loading="loading" @selection-change="handleSelectionChange" :row-key="getRowKey" &gt; 2.添加方法getRowKey
getRowKey(row) { return row.guid; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7f8f6f73f777db9fdc04ad3e4694a6/" rel="bookmark">
			OkHttpUtils 下载上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、使用时需要先添加依赖（build.gradle文件中）：
二、使用注意事项
三、OkHttpUtils 目前支持
3.1 统一的文件下载管理(DownloadManager)：
3.2 统一的文件上传管理(UploadManager)
四、用法
4.1 方法说明
4.2 请求文件下载
4.3 普通Post，直接上传String类型的文本
4.4.普通Post，直接上传Json类型的文本
五、请求功能的所有配置讲解
六、取消请求
封装了okhttp的网络框架，支持大文件上传下载，上传进度回调，下载进度回调，表单上传（多文件和多参数一起上传），链式调用，可以自定义返回对象，支持Https和自签名证书，支持cookie自动管理，支持四种缓存模式缓存网络数据，支持301、302重定向，扩展了统一的上传管理和下载管理功能
一、使用时需要先添加依赖（build.gradle文件中）： compile 'com.lzy.net:okhttputils:1.8.0' //可以单独使用，不需要依赖下方的扩展包 compile 'com.lzy.net:okhttpserver:1.0.2' //扩展了下载管理和上传管理，根据需要添加 或者 compile 'com.lzy.net:okhttputils:+' //版本号使用 + 可以自动引用最新版 compile 'com.lzy.net:okhttpserver:+' //版本号使用 + 可以自动引用最新版 二、使用注意事项 okhttputils使用的okhttp的版本是最新的 3.4.1 版本，和以前的 2.x 的版本可能会存在冲突。okhttpserver是对okhttputils的扩展，统一了下载管理和上传管理，对项目有需要做统一下载的可以考虑使用该扩展，不需要的可以直接使用okhttputils即可。对于缓存模式使用，需要与返回对象相关的所有javaBean必须实现Serializable接口，否者会报NotSerializableException。使用缓存时，如果不指定cacheKey，默认是用url带参数的全路径名为cacheKey。使用该网络框架时，必须要在 Application 中做初始化 OkHttpUtils.init(this)。 三、OkHttpUtils 目前支持 一般的 get,post,put,delete,head,options请求基于Post的大文本数据上传多文件和多参数统一的表单上传支持一个key上传一个文件，也可以一个Key上传多个文件大文件下载和下载进度回调大文件上传和上传进度回调支持cookie的内存存储和持久化存储，支持传递自定义cookie支持304缓存协议，扩展四种本地缓存模式,并且支持缓存时间控制支持301、302重定向支持链式调用支持可信证书和自签名证书的https的访问,支持双向认证支持根据Tag取消请求支持自定义泛型Callback，自动根据泛型返回对象 3.1 统一的文件下载管理(DownloadManager)： 结合OkHttpUtils的request进行网络请求,支持与OkHttpUtils保持相同的全局公共参数,同时支持请求传递参数支持 断点下载，支持突然断网,强杀进程后,断点依然有效支持 下载 暂停 等待 停止 出错 完成 六种下载状态所有下载任务按照taskKey区分,切记不同的任务必须使用不一样的key,否者断点会发生覆盖相同的下载url地址如果使用不一样的taskKey,也会认为是两个下载任务默认同时下载数量为3个，默认下载路径/storage/emulated/0/download，下载路径和下载数量都可以在代码中配置下载文件名可以自己定义,也可以不传,框架自动解析响应头或者url地址获得文件名,如果都没获取到,使用default作为文件名下载管理使用了服务提高线程优先级，避免后台下载时被系统回收 3.2 统一的文件上传管理(UploadManager) 结合OkHttpUtils的request进行网络请求,支持与OkHttpUtils保持相同的全局公共参数,同时支持请求传递参数上传只能使用Post, Put, Delete, Options 这四种请求,不支持Get, Head该上传管理为简单管理，不支持断点续传或分片上传，只是简单的将所有上传任务使用线程池进行了统一管理默认同时上传数量为1个,该数列可以在代码中配置修改 四、用法 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a7f8f6f73f777db9fdc04ad3e4694a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28812720843dd07a9616651f7238519b/" rel="bookmark">
			iOS livephtot获取,展示,保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做了一个壁纸类app,涉及到了livephoto相关的内容,做个记录 基本思路 livephoto实际上是由一张jpg图片和一段mov视频组成,想要从网络后台获取livephoto, 后台应该是以一张图片对应一段视频的方式存储livephoto,手机端通过网络下载好对应的图片和视频之后.利用系统Photos.framew中提供的方法将图片和视频合成PHLivePhoto,之后可以通过PhotoUI中的PHLivePhotoView来展示PHLivePhoto对象,或者通过PHAssetCreationRequest的方法保存livephoto到相册 代码实现 首先导入framework,之后引入头文件
#import &lt;Photos/Photos.h&gt; #import &lt;PhotosUI/PhotosUI.h&gt; 在下载完图片与视频并保存在本地之后,我们通过传入下载好的视频与图片的本地url来生成PHLivePhoto对象
[PHLivePhoto requestLivePhotoWithResourceFileURLs:@[self.movUrl ,imgUrl] placeholderImage:[UIImage imageWithData:[NSData dataWithContentsOfURL:imgUrl]] targetSize:self.imageView.bounds.size contentMode:PHImageContentModeAspectFill resultHandler:^(PHLivePhoto * _Nullable livePhoto, NSDictionary * _Nonnull info) { }]; 要展示livephoto, 需要创建PHLivePhotoView控件,再将上个方法得到的PHLivePhoto对象赋值给PHLivePhotoView,之后PHLivePhotoView调用播放方法就可以开始展示livephoto了
self.livePhotoView = [[PHLivePhotoView alloc] init];//创建 self.livePhotoView.livePhoto = livePhoto;// 赋值 [self.livePhotoView startPlaybackWithStyle:PHLivePhotoViewPlaybackStyleFull]; // 播放 保存livephoto到相册
[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^{ PHAssetCreationRequest * req = [PHAssetCreationRequest creationRequestForAsset]; [req addResourceWithType:PHAssetResourceTypePhoto fileURL:self.imgUrl options:nil]; [req addResourceWithType:PHAssetResourceTypePairedVideo fileURL:self.movUrl options:nil]; } completionHandler:^(BOOL success, NSError * _Nullable error) { if (success) { [self showMessage:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28812720843dd07a9616651f7238519b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f72b04682b362a464f5b9ca3fe4656/" rel="bookmark">
			[已解决] 新版Pycharm（2022）连接服务器进行上传文件报错“Command rsync is not found in PATH”，无法同步文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误 Command rsync is not found in PATH
Pycharm上进行文件上传的操作： 步骤1：点击Pycharm中的Tools选项；
步骤2：点击Deployment选项；
步骤3：点击Upload to 192.XXXXX；
如下图所示：
|
然后出现报错信息“Command rsync is not found in PATH”，如下图所示：
Command rsync is not found in PATH
翻译：在PATH中找不到rsync命令
报错信息： 解决方法 步骤 步骤1：点击Pycharm中的Tools选项；
步骤2：点击Deployment选项；
步骤3：点击Configuration选项；
步骤4：打开页面如下图所示；
步骤5：取消勾选如下图所示；
步骤6：点击“OK”进行保存。
重新同步文件，完美解决
步骤1：点击Pycharm中的Tools选项；
步骤2：点击Deployment选项；
步骤3：点击Upload to 192.XXXXX；
成功同步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b838b3c2564f0eb38de314136d4d31/" rel="bookmark">
			vue 自定义事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是自定义事件
二、自定义事件的 3 个使用步骤
2.1 声明自定义事件
2.2 触发自定义事件
2.3 监听自定义事件 3、自定义事件传参
总结
一、什么是自定义事件 在封装组件时，为了让组件的使用者可以监听到组件内状态的变化，此时需要用到组件的自定义事件。
二、自定义事件的 3 个使用步骤 在封装组件时：
① 声明自定义事件
② 触发自定义事件 在使用组件时：
③ 监听自定义事件
2.1 声明自定义事件 开发者为自定义组件封装的自定义事件，必须事先在 emits 节点中声明，示例代码如下：
2.2 触发自定义事件 在 emits 节点下声明的自定义事件，可以通过 this.$emit('自定义事件的名称') 方法进行触发，示例代码如下：
2.3 监听自定义事件 在使用自定义的组件时，可以通过 v-on 的形式监听自定义事件。示例代码如下
3、自定义事件传参 在调用 this.$emit() 方法触发自定义事件时，可以通过第 2 个参数为自定义事件传参，示例代码如下：
总结 以上就是关于VUE自定义事件的讲解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7c2b144538f2dbbc147eb596317275/" rel="bookmark">
			Gradle基础——Gradle构建的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 Gradle的核心是一种基于依赖的编程语言。在Gradle语法中，你可以定义任务和任务之间的依赖关系，Gradle保证这些任务按照依赖的顺序执行，并且每个任务只执行一次。这些任务形成一个有向无环图，一些构建工具可以在执行这些任务时构建这样的依赖关系图，Gradle在执行任何任务之前就已经构建出完整的依赖关系图。这就是Gradle的核心，让原本不可能的事情称为可能。
在Gradle中通过构建脚本来配置依赖关系图，因此严格来说他们是构建配置脚本。
二、Gradle构建的阶段 Gradle构建主要可以分为以下三个阶段：
初始化阶段（Initialization）
Gradle支持单项目构建和多项目构建。在初始化阶段，Gradle将决定哪些项目将会加入到构建中，并且为加入构建中的每一个项目创建一个 Project 实例对象。
配置阶段（Configuration）
在配置阶段，项目的 Project 实例对象将会进行配置。所有加入构建的项目的构建脚本，作为整个构建的一部分将会执行。
执行阶段（Execution）
Gradle在配置阶段创建和配置好任务子集，任务子集由传入Gradle命令的任务名称参数以及当前目录决定，在执行阶段将会控制这些任务子集中的任务按顺序逐个执行。
三、关于构建的设置文件（settings.gradle） 除了构建脚本文件之外，Gradle还定义了一个设置文件。设置文件由Gradle根据命名惯例进行命名，默认文件名为 settings.gradle。在后面，将会介绍Gradle是如何查找设置文件。
设置文件在初始化阶段中会被执行。一个多项目的构建必须在项目体系中的根项目中包含一个设置文件，之所以必须是因为设置文件中定义了那些项目将会作为添加到多项目构建中。对于单项目构建，设置文件是可选的。设置文件除了定义所包含的子项目之外，还可以定义向构建脚本类路径中添加库。设置文件的属性访问和方法调用委托给设置实例对象（也就是说在脚本配置文件或者设置文件中，可以通过设置实例对象访问属性和调用方法），关于设置实例对象相关的属性和方法定义，可以参考Gradle API文档中关于 Settings 的详细介绍。
说明：设置文件中包含各种在初始化之前就配置好的构建配置，例如项目体系根目录、构建缓存、多项目构建包含的子项目等等，可以通过此配置文件变更默认配置，有兴趣的同学可以详细阅读Gradle API文档中关于 Settings 的介绍。
四、构建的初始化阶段详解 前面提到，在Gradle构建的初始化阶段，需要先决定哪些项目会加入到构建中，而且也提到Gradle构建分为单项目构建和多项目构建两种，那么Gradle是如何知道构建是单项目还是多项目？如果你在包含 settings.gradle 文件的目录中发起多项目构建，Gradle 会根据 settings.gradle 文件来配置构建。Gradle同样允许你在多项目构建内的任意子项目内部执行构建，如果在没有 settings.gradle 配置文件的子项目中执行Gradle构建，Gradle将会通过以下途径查找 settings.gradle 文件：
Created with Raphaël 2.3.0 开始Gradle构建 当前目录不存在 settings.gradle 文件 在父目录中查找 settings.gradle 文件 父目录存在 settings.gradle 文件? 当前项目是否 settings.gradle 中的子项目 作为多项目构建执行 结束查找（继续构建项目内容） 作为单项目构建执行 yes no yes no 从前面的描述中，我们了解到查找 settings.gradle 的目的，就是为了让Gradle确定执行构建所在的项目是否为多项目构建的一个子项目。当然，如果执行构建所在的目录是多项构建的一个子项目，也只有与之相互依赖的项目会执行构建（其他无关的项目并不会构建），但是Gradle还是需要为整个多项目构建创建构建配置。如果当前项目中存在 settings.gradle 文件，构建流程会遵循以下原则：
作为单项目构建： 如果 settings.gradle 文件中没有定义多项目体系。作为多项目构建： 如果 settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd7c2b144538f2dbbc147eb596317275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6827a4e857c96b528c1dff375bea88ae/" rel="bookmark">
			linux中vim: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bash vim: command not found
1.查看系统是否安装完整vim
2.安装vim
3. 我的解决过程
解决问题步骤：
1.查看系统是否安装完整vim
执行一下命令：
rpm -qa|grep vim 如果已经正确安装的话，会显示如下三行：
vim-enhanced-7.0.109-7.el5 vim-minimal-7.0.109-7.el5 vim-common-7.0.109-7.el5 2.安装vim
如果少了其中的某一条,比如 vim-enhanced 的,就用命令 yum -y install vim-enhanced 来安裝:
yum -y install vim-enhanced 如果上面的三条一条都沒有返回, 可以直接用 yum -y install vim* 命令
yum -y install vim* 3.我的解决过程
我只查看只有一行，我直接执行了安装所有的那条命令，如下图：
再次查看，说明安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b230d2b1b70a3fedb16482dd0a5865a2/" rel="bookmark">
			利用python的requests爬取高清壁纸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明确爬取图片步骤
1. 确定网站的user-agent
进入网站右键点击 检查，可看到如下界面：
点击小wifi图标，最下面的user-agent即设为headers
2. 查看网站源码
找出图片所对应的代码块
即对应一个div列表，此时发现高清图地址位于a标签的href属性值中，所以需获取高清图地址 继而在高清图页面进行源码分析
发现地址位于a标签的href的属性中，所以我们利用xpath提取出高清图地址后在该页面进行xpath操作获取下载地址即可保存图片。
源码如下：
import requests import os from lxml import etree headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47'} def di_zhi(): list_suo = [] for i in range(1, 11): if i &gt; 1: url = f'https://wall.alphacoders.com/by_sub_category.php?id=306566&amp;name=%E5%A4%A7%E4%BE%A6%E6%8E%A2%E7%9A%AE%E5%8D%A1%E4%B8%98+%E5%A3%81%E7%BA%B8&amp;filter=4K+Ultra+HD&amp;lang=Chinese/index_{i}.html' else: url = 'https://wall.alphacoders.com/by_sub_category.php?id=306566&amp;name=%E5%A4%A7%E4%BE%A6%E6%8E%A2%E7%9A%AE%E5%8D%A1%E4%B8%98+%E5%A3%81%E7%BA%B8&amp;filter=4K+Ultra+HD&amp;lang=Chinese/index.html' response_text = requests.get(url, headers=headers, timeout=30).text tree = etree.HTML(response_text) # 提取出高清图所在页面地址 r = tree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b230d2b1b70a3fedb16482dd0a5865a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c4570f3843af82877a68cc3227bccf/" rel="bookmark">
			更改ElementPlus默认样式的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更改ElementPlus默认样式的方法 安装：
# 选择一个你喜欢的包管理器 # NPM $ npm install element-plus --save # Yarn $ yarn add element-plus # pnpm $ pnpm install element-plus 使用：
// main.js import { createApp } from 'vue' import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' import App from './App.vue' const app = createApp(App) app.use(ElementPlus) app.mount('#app') 更多详细内容移步官网
一、添加没有scoped的样式（页面中可以有多个） 需要注意的是，这里修改的样式是全局都生效的。
&lt;style lang="scss"&gt; .el-date-editor { box-shadow: none !important; } &lt;/style&gt; &lt;style lang="scss" scoped&gt; /* 其他css代码 */ &lt;/style&gt; 也可以定义公共的外部css，采用import的方式在main.js中引入即可。
import '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8c4570f3843af82877a68cc3227bccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e9a1e4c2b4dba99f63a917b0066d3a/" rel="bookmark">
			Apache HTTP Server (httpd)服务离线安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache(httpd)服务离线安装文档
目录 一、说明依赖包及下载地址依赖包描述 二、安装准备软件包上传软件包解压处理依赖关系 三、开始安装四、配置五、启动六、验证七、附 一、说明 本文依据Apache官方使用文档编写，地址：https://httpd.apache.org/docs/2.4
依赖包及下载地址 本文使用到的离线包：
apr-1.7.0.tar.gz
apr-util-1.6.1.tar.gz
pcre2-10.40.tar.gz
expat-2.1.0-14.el7_9.x86_64.rpm
expat-devel-2.1.0-14.el7_9.x86_64.rpm
httpd-2.4.54.tar.gz
官方下载地址：
apr-1.7.0.tar.gz
https://dlcdn.apache.org//apr/apr-1.7.0.tar.gz
apr-util-1.6.1.tar.gz
https://dlcdn.apache.org//apr/apr-util-1.6.1.tar.gz
pcre2-10.40.tar.gz
https://github.com/PCRE2Project/pcre2/releases/download/pcre2-10.40/pcre2-10.40.tar.gz
expat-2.1.0-14.el7_9.x86_64.rpm
http://mirror.centos.org/centos/7/updates/x86_64/Packages/expat-2.1.0-14.el7_9.x86_64.rpm
expat-devel-2.1.0-14.el7_9.x86_64.rpm
http://mirror.centos.org/centos/7/updates/x86_64/Packages/expat-devel-2.1.0-14.el7_9.x86_64.rpm
httpd-2.4.54.tar.gz
https://dlcdn.apache.org/httpd/httpd-2.4.54.tar.gz
注：以上链接会由于版本更新导致失效，建议走官网入口：
https://httpd.apache.org/
依赖包描述 相关依赖包使用关键描述（此处引用官方文档原文）：
APR and APR-Util:
Make sure you have APR and APR-Util already
installed on your system. If you don’t, or prefer to not use the
system-provided versions, download the latest versions of both APR and
APR-Util from Apache APR, unpack them into
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71e9a1e4c2b4dba99f63a917b0066d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6461501c2fef2eed0435a5986bbf00/" rel="bookmark">
			方舟综合指令代码大全系统综合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能
单机指令
服管员指令
备注
开启作弊
/管理权限
（无）
enablecheats [密码]
输入密码登入管理权限
例:enablecheats teandy
上帝(无敌)
god
admincheat god
[开/关] 某些情况依旧会死 常配合infinitestats用
建造模式
gcm
admincheat GiveCreativeMode
[开/关] 解锁印痕无敌无负重限制，获得管理员枪
给你建造
（无）
admincheat GiveCreativeModeToTarget
[对准目标]给予目标玩家建造模式
飞行模式
fly
admincheat fly
可空中移动，使用walk命令退出，遇水失效
无限状态
infinitestats
admincheat infinitestats
[开/关] 属性状态/弹药等不减
目标无限
GiveInfiniteStatsToTarget
admincheat GiveInfiniteStatsToTarget
[对准目标]使目标成为无限状态
无视模式
EnemyInvisible
admincheat EnemyInvisible [布尔]
[布尔值:true/false] 玩家被所有生物忽略
让我静静
LeaveMeAlone
admincheat LeaveMeAlone
God、InfiniteStats、EnemyInvisible组合效果
管理光环
GMBuff
admincheat GMBuff
LeaveMeAlone代码效果，并获得经验
管理员菜单
ShowMyAdminManager
ShowMyAdminManager
显示管理员菜单，大部分为英文界面
穿墙模式
ghost
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac6461501c2fef2eed0435a5986bbf00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54dc5fc09bfcf5537f0c06b636f9fa6/" rel="bookmark">
			FPGA学习笔记23之LINUX下SPI调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA学习笔记23之LINUX下SPI调试 若该文为原创文章，未经允许不得转载风释雪QQ:627833006E-mail:hn.cy@foxmail.comCSDN博客地址:https://blog.csdn.net/weixin_46718879 文章目录 FPGA学习笔记23之LINUX下SPI调试1.版本说明2.概述3.内核配置3.设备树配置4.测试demo5.软件实现 1.版本说明 DataAuthorVersion Revision2021/02/28abner1.0 初定版本 2.概述 ZYNQ/MPSOC SPI驱动和应用层调试；
3.内核配置 Device Drivers ---&gt; [*] SPI support ---&gt; &lt;*&gt; User mode SPI device driver support 3.设备树配置 &amp;spi0 { status = "okay"; spidev@0 { compatible = "rohm,dh2228fv"; spi-max-frequency = &lt;48000000&gt;; reg = &lt;0&gt;; }; }; 4.测试demo 独立编译应用
aarch64-linux-gnu-gcc spidev_test.c -o spi-tools-2.0 测试：
5.软件实现 bool CDevSPI::PolledTransfer(const uint8_t *tx, uint8_t *rx, size_t len) { int fd; int ret = 0; fd = open(sysfs_spi_path_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e54dc5fc09bfcf5537f0c06b636f9fa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f52494ad1a08e5b3bde374cac4b2cd8/" rel="bookmark">
			Security ❀ 安全设备学习规范（第二版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安全设备学习规范1、设备部署环境1.1 部署方式1.2 配置IP地址与路由1.3 设备冗余机制1.4 会话同步机制1.5 设备账户管理1.6 设备故障诊断 2、产品授权方式2.1 序列号2.2 Hash值 3、相关设备联动3.1 对接管理平台3.2 集群化部署3.3 API接口 4、防护对象确立4.1 资产的定义4.2 地址池与域名集 5、安全策略调配5.1 深度包检测技术 - DPI5.1.1 特征识别5.1.2 关联识别5.1.3 行为识别 5.2 特征识别库5.3 应用统计 6、日志审计操作6.1 安全防护日志6.2 系统运行日志 7、安全防护结构规划7.1 监控状态7.2 流量审计7.3 数据检验7.4 进出限制7.5 溯源判断7.6 日志检索7.7 冗余灾备7.8 结构稳定 安全设备学习规范 文章介绍：《安全设备学习规范》是将目前所接触到的安全产品与其所处的部署环境、功能要求、审计目标、资产管理、数据接入等众多产品相关内容进行整理、合并而进行总结的一篇文章。
文章主要分为以下内容：
设备部署环境产品授权方式相关设备联动防护对象确立安全策略调配日志审计操作 最终以 安全防护结构规划 进行整理与总结，体现出当前环境下的安全防护设备的理论结构体系。
1、设备部署环境 首先，在一个网络中将某个设备进行接入，考虑的第一要素就是位置。
1.1 部署方式 针对不同的接入位置就产生了不同的部署方式，最主要的是以下三种情况：
串联部署：安全设备使用串联方式接入现有网络，此部署方式对网络拓扑结构改动相对较大，需要对接上下联设备（常见的上联设备为核心交换机，接口模式可支持二层或三层，根据其对接设备而确定。如NIPS - 网络入侵防护系统 对接多为透传二层接入，而 NF - 下一代防火墙 对接接口多为核心交换机的三层接口） 优点：接入方式较为简单，相关配置改动需要根据接入设备而确定；缺点：网络拓扑改动较大，需要对接上下联设备。 网关部署：将安全设备作为出口设备接入网络环境，以此方式接入网络的安全设备需要承担VPN（虚拟专线，如IPSec、MPLS、GRE等常见技术）、NAT（网络地址转换，代理上网与端口映射） 优点：以网关设备进行防护，可以直接防护到边界流量，攻击流量不会进入内网；缺点：网络拓扑改动最大，需要修改整体网络边界环境。 旁路部署：以额外单独的方式接入安全设备，对网络结构不做改变，需要将流量引入到安全设备后进行转发或进行流量镜像操作（三层设备需要接入流量，二层设备大多数仅需要镜像流量即可） 优点：根据需求设计流量走向，对网络结构变动基本无影响；缺点：若接入为三层安全设备，需要对端设备进行控制列表配置，修改流量出向至安全设备转发后回流（物理旁路，逻辑串联），若接入为二层设备，需要在对端设备进行镜像流量配置，镜像流量只能做检测，不能进行防护拦截操作。 部署模式的选择针对于不同的现网环境，每种类型各有独特，务必谨慎选择。
1.2 配置IP地址与路由 配置IP地址与路由可以分为三种情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f52494ad1a08e5b3bde374cac4b2cd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1a9b85dcf0c55b387b7842d5584f850/" rel="bookmark">
			Kubernetes集群搭建Zabbix监控平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
一、检查本地k8s环境
1.检查系统pod运行状态
2.检查node节点状态
二、配置nfs共享存储
1.安装nfs
2.创建共享目录
3.配置共享目录
4.启动相关服务
5.使配置生效
6.查看nfs
7.其他节点检查nfs共享
三、安装zabbix-mysql
1.编写zabbix-mysql的yaml文件
2.创建命名空间
3.创建zabbix数据库
4.检查pod状态
四、检查zabbix数据库的service域名
1.运行测试pod
2.进入busybox的pod
3.查看域名解析
五、安装zabbix-server
1.编写zabbix_server.yaml文件
2.给node02节点打上标签
3.安装zabbix-server
4.检查pod状态
六、部署zabbix-web
1.编写zabbix_web.yaml文件
2.安装zabbix-web
3.查看pod状态
七、部署zabbix-agent
1.编辑zabbix_agent.yaml
2.安装zabbix-agent
3.查看pod状态
八、访问zabbix的web
1.查看svc
2.登录web
3.登录zabbix
4.查询zabbix-server的监控项图表
一、检查本地k8s环境
1.检查系统pod运行状态
[root@k8s-master ~]# kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE kube-system calico-kube-controllers-7bc6547ffb-2nf66 1/1 Running 1 (9m28s ago) 2d16h kube-system calico-node-8c4pn 1/1 Running 1 (9m16s ago) 2d16h kube-system calico-node-f28qq 1/1 Running 1 (9m10s ago) 2d16h kube-system calico-node-wmc2j 1/1 Running 1 (9m29s ago) 2d16h kube-system coredns-6d8c4cb4d-6gm4x 1/1 Running 1 (9m28s ago) 2d16h kube-system coredns-6d8c4cb4d-7vxlz 1/1 Running 1 (9m29s ago) 2d16h kube-system etcd-k8s-master 1/1 Running 1 (9m30s ago) 2d16h kube-system kube-apiserver-k8s-master 1/1 Running 1 (9m29s ago) 2d16h kube-system kube-controller-manager-k8s-master 1/1 Running 1 (9m30s ago) 2d16h kube-system kube-proxy-8dfw8 1/1 Running 1 (9m29s ago) 2d16h kube-system kube-proxy-ghzrv 1/1 Running 1 (9m9s ago) 2d16h kube-system kube-proxy-j867z 1/1 Running 1 (9m15s ago) 2d16h kube-system kube-scheduler-k8s-master 1/1 Running 1 (9m28s ago) 2d16h 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1a9b85dcf0c55b387b7842d5584f850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ec3b8f001dc1b82090ad812cf7ed13/" rel="bookmark">
			Java Thread.yield()方法具有什么功能呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自:
Java Thread.yield()方法具有什么功能呢？
下文讲述Thread.yield()方法的功能简介说明，如下所示:
Thread yield()方法的功能: 暂停当前线程(将当前线程重新放回CPU的调度中心) yield()方法注意事项: 此方法并不能停止线程，它只是让出CPU, 然后由其它线程和自身同时去竞争CPU 例:
package com.java265.other; public class Test6 { public static void main(String[] args) throws Exception { Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { System.out.println("i:" + i); Thread.yield(); } }); Thread t2 = new Thread(() -&gt; { for (int j = 0; j &lt; 10; j++) { System.out.println("j:" + j); Thread.yield(); } }); t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ec3b8f001dc1b82090ad812cf7ed13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90d867ad030ecb33f091517e90c6d9c/" rel="bookmark">
			C&#43;&#43; replace,replace_if和replace_copy函数用法详解(深入了解,一文学会)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ replace,replace_if和replace_copy函数用法详解目录
1 replace() 算法
2 replace_if()
3 replace_copy()
1 replace() 算法 会用新的值来替换和给定值相匹配的元素。它的前两个参数是被处理序列的正向迭代器，第 3 个参数是被替换的值，第 4 个参数是新的值。下面展示了它的用法:
#include &lt;iostream&gt; #include &lt;deque&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;list&gt; #include &lt;set&gt; #include &lt;functional&gt; #include &lt;iterator&gt; using namespace std; int main() { std::deque&lt;int&gt; data{ 10, -5, 12, -6, 10, 8, -7, 10, 11 }; std::replace(std::begin(data), std::end(data), 10, 99); // Result: 99 -5 12 -6 99 8 -7 99 11 for (int i = 0; i &lt; data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90d867ad030ecb33f091517e90c6d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/289919584b956f47b6e9f36d4911fb79/" rel="bookmark">
			win10 下 acdsee7 在普通账户下无法运行并崩溃的 BUG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 下 acdsee7 在普通账户下无法运行并崩溃的 BUG，而在管理员账户下却可以正常运行勉强可以使用的问题...
作为一款图片管理程序，虽然有一些 BUG，但却比它之后的版本要运行的快速而体积小巧的多。在全屏看图时，不会被之后版本中的 “鼠标放大图标” 与其 “双击退出功能” 互相干扰！ ACDSee Ultimate 10 就有这种令人费解的 BUG...
更令人费解的是标题栏用矩形框住的文字按钮在 acdsee7 之后再也无法 “关闭” 的 BUG，一直困扰着此款软件用户的使用观感...
ACDSee Ultimate 10 其缩略图的缩放功能似乎也不如 acdsee7 之前的好用，全屏模式时第一副图的加载时间更是让之前的使用者无法忍受！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdf0f28f05475f5577211d7905b8fb3/" rel="bookmark">
			Netty心跳机制和客户端重连的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近研究了一下Netty的心跳和重连，在此和大家分享一下。 1.Netty的心跳机制实现 实现原理：客户端每隔一段时间都会发送一个消息到服务端，以此来通知服务端我还在线，处于正常运行状态，当一段时间内，服务端没有接收到客户端的消息，则视为该客户端已经下线，断开和他的连接。 实现的核心点是通过IdleStateHandler心跳检测处理器来实现心跳检测机制的
IdleStateHandler： 服务端添加IdleStateHandler心跳检测处理器，并添加自定义处理Handler类实现userEventTriggered()方法作为超时事件的逻辑处理。
该处理器有三个核心参数
readerIdleTime： 读超时时间（服务端达到该设定时间还没有接收到客户端的消息并未执行读操作，则会触发userEventTriggered方法）
writerIdleTime： 写超时时间（服务端达到该设定时间还没有接收到客户端的消息并未执行写操作，则会触发userEventTriggered方法）
allIdleTime： 读写超时时间（服务端达到该设定时间还没有接收到客户端的消息并未执行读或写操作，则会触发userEventTriggered方法）
TimeUnit： 时间单位
下面实战代码： 1.服务端的实现 [1] 首先定义一个服务端 import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; /** * &lt;B&gt;类名称&lt;/B&gt;IntelliJ IDEA&lt;BR/&gt; * &lt;B&gt;类描述&lt;/B&gt;&lt;BR/&gt; * * @author lt * @date 2022/7/25 17:21 */ public class HeartBeatServer { int port; public HeartBeatServer(int port) { this.port = port; } public void start() { ServerBootstrap bootstrap = new ServerBootstrap(); EventLoopGroup boss = new NioEventLoopGroup(); EventLoopGroup worker = new NioEventLoopGroup(); try { bootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cdf0f28f05475f5577211d7905b8fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059831334f799bb8e7d77a68c837b8fe/" rel="bookmark">
			【Vue组件之间的三种通信】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、组件之间的关系：1、父子组件之间的传值：2、兄弟组件之间的传值:3、跨级组件之间的通信: 一、组件之间的关系： 1、父子组件之间的传值： （1）父组件向子组件传值：子组件通过props属性获取父组件中的值
a、在父组件中使用子组件时，需要通过v-bind指令绑定一个属性
b、在子组件中通过props属性,来获取父组件中v-bind指令绑定的那个属性
☀️举个例子：
Father.vue代码段：
&lt;template&gt; &lt;Son v-bind:users="arr"/&gt; &lt;/template&gt; &lt;script&gt; import Son from "./Son.vue"; export default { name: "Father", setup(){ const arr = ['大雁塔','小雁塔','兵马俑','大唐芙蓉园','乾陵'] return { arr } }, components:{ Son } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; Son.vue代码段：
&lt;template&gt; &lt;ul&gt; &lt;li v-for = "(user,index) in users" v-bind:key="index"&gt; {{ user }} &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;script&gt; export default { name: "Son", props:{ users:{ type:Array, required:true } } } &lt;/script&gt; &lt;style scoped&gt; li{ list-style-position: inside; } &lt;/style&gt; App.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/059831334f799bb8e7d77a68c837b8fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c4388de39ca4c6e82644f856bc6d22/" rel="bookmark">
			【Chrome自动更新修复】检查更新时出错：无法启动更新检查（错误代码为 4: 0x80070005 -- system level）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
无法使Chrome自动更新，每次手动下载安装包更新太麻烦，并且收藏夹可能丢失。
问题分析
没有打开Google更新服务
解决方案
打开“任务管理器”，找到“服务”，将gupdate（Google更新服务）设置为“打开服务”（注意：不是点“开始”）。
右键“属性”，将启动类型设置为“自动”即可。
于是，终于解决了困扰我多年（一直太懒不想解决）的更新问题！
最后，重启搞定！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1590ffa7891911a9e181590f441570c8/" rel="bookmark">
			Nginx 用syslog传输error.log到远程服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error_log配置syslog远程传输 error_log syslog:server=127.0.0.1:514,facility=local0,severity=info,tag=nginx error;
其中server指定传输的IP&amp;Port。为了开发方便，这里设置了本机的rsyslog服务端口。
facility指定产生日志的实体，有一些固定的选择，比如kern，mail，user，local0，local1等。
severity指定日志级别(不是nginx的日志级别)。
tag指定标识，这里设置的tag为"nginx"。
error指定了nginx的日志级别，根据需要也可以选其它级别，例如warn，info，debug等。
配置rsyslog服务 编辑/etc/rsyslog.conf，添加配置如下
#启用udp模块 module(load="imudp") #输入是udp协议，端口514 input(type="imudp" port="514") #ficility为local0的日志输出到/var/log/error.log local0.* -/var/log/error.log 这里是把facility为local0的syslog输出到本机的/var/log/error.log文件，也可以传输到远程数据库。由于手头没有数据库，不列举配置了。
配置好之后systemctl restart rsyslog就好了(具体service名字用tab补全)。
错误日志格式 示例如下
Nginx 错误日志格式，每个红框是一个字段，从左到右，从上到下依次是
syslog header中的时间，时间格式可以通过ActionFileDefaultTemplate设置
hostname，我的主机名这是的是A，不确定是hostname变量转小写了还是syslog输出转的。
tag，这里设置的值是nginx。
nginx日志时间，nginx日志默认时间精度是秒，我自己改成毫秒了，代码中修改的位置是ngx_cached_err_log_time变量赋值的部分，毫秒直接用tp-&gt;msec就好了。
[error] 是日志级别
271612#0是记录的进程PID和线程TID，用#分割
*301xxx 是连接ID
connect() failed xxxx这部分就是nginx代码里面输出的具体错误信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffda7b957ee9f863a7e5d8bd88951d8f/" rel="bookmark">
			Vue项目打包后---在nodejs环境中应用并代理跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue项目打包后—在nodejs环境中应用并代理跨域 使用koa框架部署项目 一、建立web服务文件夹 crmServer $ mkdir hrServer #建立crmServer文件夹 二、在该文件夹下，初始化npm $ npm init -y 三、安装服务端框架koa(也可以采用express或者egg) $ npm i koa koa-static 四、新建public文件夹，copy打包后的dist目录下的文件到hrServer/public下 五、在根目录下创建app.js app.js
const Koa = require('koa') const serve = require('koa-static'); const app = new Koa(); app.use(serve(__dirname + "/public")); //将public下的代码静态化 app.listen(3333, () =&gt; { console.log('CRM项目启动') }) 此时，我们可以访问，http://localhost:3333
此时页面可以出来了
补充 更改路由模式为 history模式，设置基地址 // src/router/index.js 在路由实例中添加 mode: 'history', base: '/admin/', // 配置项目的基础地址 解决history页面访问问题 安装 koa中间件 $ npm i koa2-connect-history-api-fallback 注册中间件 const Koa = require('koa') const serve = require('koa-static'); const { historyApiFallback } = require('koa2-connect-history-api-fallback'); const path = require('path') const app = new Koa(); // 这句话 的意思是除接口之外所有的请求都发送给了 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffda7b957ee9f863a7e5d8bd88951d8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a934085cc1ce53fcce8395be3eff9320/" rel="bookmark">
			R_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error Error: R_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server;
MySQL 8 has supports pluggable authentication methods. By default, one of them named is used rather than our good old (source). It should be obvious that using a crypto algorithm with several handshakes is more secure than plain password passing that has been there for 24 years!caching_sha2_passwordmysql_native_password
Now, the problem is in Node (the package you install with and use it in your Node code) doesn’t support this new default authentication method of MySQL 8, yet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a934085cc1ce53fcce8395be3eff9320/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b17187874187419b8addf93a917c7d70/" rel="bookmark">
			VUE3报错，Error: ENOSPC: System limit for number of file watchers reached
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(env) [root@VM-20-16-centos vue_test2]# npm run serve &gt; vue_test2@0.1.0 serve &gt; vue-cli-service serve INFO Starting development server... [10%] building (0/0 modules) node:internal/errors:464 ErrorCaptureStackTrace(err); ^ Error: ENOSPC: System limit for number of file watchers reached, watch '/root/work/vue3/vue_test2/public' at FSWatcher.&lt;computed&gt; (node:internal/fs/watchers:244:19) at Object.watch (node:fs:2251:34) at createFsWatchInstance (/root/work/vue3/vue_test2/node_modules/chokidar/lib/nodefs-handler.js:119:15) at setFsWatchListener (/root/work/vue3/vue_test2/node_modules/chokidar/lib/nodefs-handler.js:166:15) at NodeFsHandler._watchWithNodeFs (/root/work/vue3/vue_test2/node_modules/chokidar/lib/nodefs-handler.js:331:14) at NodeFsHandler._handleDir (/root/work/vue3/vue_test2/node_modules/chokidar/lib/nodefs-handler.js:567:19) at processTicksAndRejections (node:internal/process/task_queues:96:5) at async NodeFsHandler._addToNodeFs (/root/work/vue3/vue_test2/node_modules/chokidar/lib/nodefs-handler.js:617:16) at async /root/work/vue3/vue_test2/node_modules/chokidar/index.js:451:21 at async Promise.all (index 0) Emitted 'error' event on FSWatcher instance at: at FSWatcher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b17187874187419b8addf93a917c7d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5abe1d72188c05da1728321211c40c48/" rel="bookmark">
			阿里云服务器ECS安装Ubuntu18.04桌面图形环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器ECS安装Ubuntu18.04桌面图形环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c56d27af23c437aa0872e3cd9e3e43e1/" rel="bookmark">
			【Python基础】sorted多重排序用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因： 对于一个多维数组，如何使用sorted按照不同维度顺序进行排序 Demo： 单重排序 res = [(0, 7), (2, 6), (2, 5), (2, 4)] sorted(res,key=lambda x:x[0]) # 仅仅调用sorted函数不会直接影响到res 结果是：
[(0, 7), (2, 6), (2, 5), (2, 4)]，明显按照第一个维度进行排序，因此顺序没变
sorted(res,key=lambda x:x[1]) 结果是：
[(2, 4), (2, 5), (2, 6), (0, 7)]，按照第二个维度进行排序
多重排序 sorted(res,key=lambda x:(x[1],x[0])) 结果是：
[(2, 4), (2, 5), (2, 6), (0, 7)]，先按照第二个维度进行排序，然后不打乱第二个维度顺序的基础上，进行第一个维度的排序
sorted(res,key=lambda x:(x[0],x[1])) 结果是：
[(0, 7), (2, 4), (2, 5), (2, 6)]，同理
# 默认排序 sorted(res) 结果是：
[(0, 7), (2, 4), (2, 5), (2, 6)]，首先第一个维度排序，然后第二个维度排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c56d27af23c437aa0872e3cd9e3e43e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf725a539cc918b2c89383560a13c69/" rel="bookmark">
			Spring如何解决循环依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是循环依赖 多个bean之间相互依赖，形成了一个闭环。 比如:A依赖于B、B依赖于c、c依赖于A。
通常来说，如果问spring容器内部如何解决循环依赖， 一定是指默认的单例Bean中，属性互相引用的场景。也就是说，Spring的循环依赖，是Spring容器注入时候出现的问题。
注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。
Spring中循环依赖场景有：
（1）构造器的循环依赖
（2）field属性的循环依赖（主要是针对单例bean）
2. 怎么检测是否存在循环依赖 检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。
二、filed注入循环依赖解决方案 三级缓存 首先，Spring内部维护了三个Map，也就是我们通常说的三级缓存。
一级缓存为：singletonObjects；二级缓存为：earlySingletonObjects；三级缓存为：singletonFactories； 三个缓存分别有什么作用
「singletonObjects」：（一级缓存）它是我们最熟悉的朋友，俗称“单例池”“容器”，缓存创建完成单例Bean的地方。
「earlySingletonObjects」：
（二级缓存）映射Bean的早期引用，也就是说在这个Map里的Bean不是完整的，甚至还不能称之为“Bean”，只是一个Instance.
「singletonFactories」：
singletonFactories（三级缓存） 映射创建Bean的原始工厂
后两个Map其实是“垫脚石”级别的，只是创建Bean的时候，用来借助了一下，创建完成就清掉了。那么Spring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？如图
A 的 Bean 在创建过程中，在进行依赖注入之前，先把 A 的原始 Bean 放入缓存（提早暴露，只要放到缓存了，其他 Bean 需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时 A 的Bean 依赖了 B 的 Bean 。
如果 B 的 Bean 不存在，则需要创建 B 的 Bean，而创建 B 的 Bean 的过程和 A 一样，也是先创建一个 B 的原始对象，然后把 B 的原始对象提早暴露出来放入缓存中，然后在对 B 的原始对象进行依赖注入 A，此时能从缓存中拿到 A 的原始对象（虽然是 A 的原始对象，还不是最终的 Bean），B 的原始对象依赖注入完了之后，B 的生命周期结束，那么 A 的生命周期也能结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cf725a539cc918b2c89383560a13c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a51684ec7acf8cc5417bcf9e5df975c9/" rel="bookmark">
			【黑马-SpringCloud技术栈】【02】服务拆分及远程调用_服务提供者与消费者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持续学习&amp;持续更新中…
守破离
【黑马-SpringCloud技术栈】【02】服务拆分及远程调用_服务提供者与消费者 SpringCloud引入服务拆分及远程调用服务拆分原则服务拆分Demo导入数据库导入demo工程实现远程调用案例总结 服务提供者与服务消费者参考 SpringCloud引入 SpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloudSpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验 服务拆分及远程调用 服务拆分原则 任何分布式架构都离不开服务的拆分，微服务也是一样。
单一职责：不同微服务，不要重复开发相同业务数据独立：不要访问其它微服务的数据库面向服务：将自己的业务暴露为接口，供其它微服务调用 总结：
微服务需要根据业务模块拆分，做到单一职责,不要重复开发相同业务微服务可以将业务暴露为接口，供其它微服务使用不同微服务都应该有自己独立的数据库 服务拆分Demo cloud-demo：父工程，管理依赖
order-service：订单微服务，负责订单相关业务user-service：用户微服务，负责用户相关业务 要求：
订单微服务和用户微服务都必须有各自的数据库，相互独立订单服务和用户服务都对外暴露Restful的接口订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库 导入数据库 先分别创建cloud_order、cloud_user两个数据库，将cloud-order.sql和cloud-user.sql分别导入到mysql中，cloud-order表中持有cloud-user表中的id字段：
DROP TABLE IF EXISTS `tb_order`; CREATE TABLE `tb_order` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '订单id', `user_id` bigint(20) NOT NULL COMMENT '用户id', `name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '商品名称', `price` bigint(20) NOT NULL COMMENT '商品价格', `num` int(10) NULL DEFAULT 0 COMMENT '商品数量', PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `username`(`name`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 109 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; INSERT INTO `tb_order` VALUES (101, 1, 'Apple 苹果 iPhone 12 ', 699900, 1); INSERT INTO `tb_order` VALUES (102, 2, '雅迪 yadea 新国标电动车', 209900, 1); INSERT INTO `tb_order` VALUES (103, 3, '骆驼（CAMEL）休闲运动鞋女', 43900, 1); INSERT INTO `tb_order` VALUES (104, 4, '小米10 双模5G 骁龙865', 359900, 1); INSERT INTO `tb_order` VALUES (105, 5, 'OPPO Reno3 Pro 双模5G 视频双防抖', 299900, 1); INSERT INTO `tb_order` VALUES (106, 6, '美的（Midea) 新能效 冷静星II ', 544900, 1); INSERT INTO `tb_order` VALUES (107, 2, '西昊/SIHOO 人体工学电脑椅子', 79900, 1); INSERT INTO `tb_order` VALUES (108, 3, '梵班（FAMDBANN）休闲男鞋', 31900, 1); DROP TABLE IF EXISTS `tb_user`; CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '收件人', `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '地址', PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `username`(`username`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 109 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; INSERT INTO `tb_user` VALUES (1, '柳岩', '湖南省衡阳市'); INSERT INTO `tb_user` VALUES (2, '文二狗', '陕西省西安市'); INSERT INTO `tb_user` VALUES (3, '华沉鱼', '湖北省十堰市'); INSERT INTO `tb_user` VALUES (4, '张必沉', '天津市'); INSERT INTO `tb_user` VALUES (5, '郑爽爽', '辽宁省沈阳市大东区'); INSERT INTO `tb_user` VALUES (6, '范兵兵', '山东省青岛市'); 导入demo工程 项目结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a51684ec7acf8cc5417bcf9e5df975c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaecdabb23138385ed25bb60be775d6e/" rel="bookmark">
			微信聊天小程序——（三、获取好友列表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三、获取好友列表 步骤一、展示所有好友的推荐列表（friends页面） 具体效果：
实现思路：
我们有我们的用户数据库表即：uers循环我们的数据库用户表，达到所有的用户信息，即：userList利用云函数拿到我们的userList，赋值给data，之后再页面中显示出来显示的时候，注意用 onLoad调用，因为每次页面打开都需要加载 注意：因为好友列表在每一次打开页面的时候都要加载，所以，我们写在页面函数中。
在js文件中：
// pages/friends/friends.js Page({ /** * 页面的初始数据 */ data: { }, //在每次页面加载的时候进行调用 onLoad(options) { this.getAllUser(); }, // 功能：获取所有的用户信息 getAllUser(){ var that=this; wx.cloud.database().collection("chat_users1").get( { success(res){ console.log(res) that.setData({ userList:res.data }) } } ) } }) 在wxml文件中
&lt;button&gt;附近好友&lt;/button&gt; &lt;view &gt; &lt;button class="myfriends"&gt;我的好友&lt;/button&gt; &lt;/view&gt; //写一个block，经常用来接收一堆相同的数据 &lt;block class="list_fox" wx:for="{{userList}}"&gt; //里面的图片和文本用view标签包裹，为了view在一行显示 &lt;view class="list_item"&gt; &lt;image class="ima" src="{{item.faceImg}}"&gt;&lt;/image&gt; &lt;view class="name"&gt;{{item.nickName}}&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; 在wxss样式文件中
.myfriends{ margin-left: 10rpx; } .ima{ width: 120rpx ; height: 120rpx; border-radius: 50%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaecdabb23138385ed25bb60be775d6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc680582fe64c2ce8d706bbd1f4cf84/" rel="bookmark">
			微信聊天小程序——（四、聊天页面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四、聊天页面 步骤一、聊天页面的搭建 效果图：
思路：
聊天页面的搭建
首先在聊天页面获取我们所有的好友信息其次当点击我们对应好友，进入聊天页面
注意传递我们此时的聊天记录表id，方便之后进行添加聊天记录聊天页面下方布局发送消息
注意为传递参数的发送框获取我们发送消息，传递到我们的聊天记录表的记录中 在聊天页面中：
getChatRecord()
// 功能：当跳转到聊天页面的时候，显示聊天信息 // 思路：1.更加我们接收到的_id在聊天表中查询，返回查询值 // 2.在wxml页面进行渲染 publishChat()
// 功能：当我们发布消息的时候，更新我们的数据库表中的消息 // 思路：1.首先根据页面接收到的值，获取这条消息的_id // 2.新建一个空白数组，将我们需要记录的信息、聊天内容放到这个数组中 // 3.将这个数组放到我们存放聊天记录的record数组中 // 4.更新我们的数据库表格 // 5.更新之后，再次调用，使刚刚发送的消息出现 // 6.将我们的评论和输入消息内筒赋值为空 getInputValue(event)
// 功能：获取输入框的值 在js文件：
const app=getApp() const util= require("../../utils/utils") Page({ data: { }, onShow(){ this.setData({ userInfo: app.globalData.userInfo }) }, // 功能：当点击好友的时候，传输好友信息 onLoad(options) { console.log(options.id) this.setData({ recordId:options.id }) this.getChatRecord(); }, // 功能：当跳转到聊天页面的时候，显示聊天信息 // 思路：1.更加我们接收到的_id在聊天表中查询，返回查询值 // 2.在wxml页面进行渲染 getChatRecord(){ var that = this; wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc680582fe64c2ce8d706bbd1f4cf84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85054eefe842bdd62386c54354e5a86/" rel="bookmark">
			AndroidTV开发12——大屏TV电视及盒子Apk远程安装说明文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
大屏TV电视及盒子Apk远程安装说明文档
1.在您的电视应用市场下载一个沙发管家或者当贝市场，本文档以沙发管家为例，当贝市场的操作和沙发管家一样，这里就不重复说明了.
2.下载完成后打开沙发管家，使用遥控器移动到工具箱栏目下,找到远程推送选项,操作步骤截图如下：
2.1 移动遥控器到工具类栏目,如图2-1所示
2.2 移动遥控器到远程控制选项，如图2-2所示
2.3 移动到远程控制选项后点击遥控OK键进入远程控制界面,如图2-3所示
3.在电脑浏览器上输入图2-3上的ip地址(如10.0.1.120:8899)，这里的ip是我公司的，您需要输入自己公司的ip。(注意：您的电脑和TV需要在同一个WiFi或者局域网下才能安装)
3.1 输入您自己公司的ip后，打开如图3-1的界面
3.2 点击上传文件,选择您当前正使用apk所在的目录,apk就会上传到TV电视或者盒子上
4.apk的目录如图4-1所示(这里的目录是我电脑的apk目录，您需要选择您自己的apk目录)
4.1 您自己电脑的apk目录，如图4-1所示
5.apk应用安装成功后提示如图5-1所示
6.若apk包安装成功后，移动遥控器到打开按钮出现如图6-1的画面算是完整的apk安装流程完成.
大屏TV电视及盒子Apk远程安装说明文档 说明：由于TV开发时远程安装比较麻烦,本文是专门给测试或者运营等非开发人员进行远程安装apk一篇指导操作性文章，如果是开发人员可以忽略，开发人员可以直接使用adb安装~~
1.在您的电视应用市场下载一个沙发管家或者当贝市场，本文档以沙发管家为例，当贝市场的操作和沙发管家一样，这里就不重复说明了. 2.下载完成后打开沙发管家，使用遥控器移动到工具箱栏目下,找到远程推送选项,操作步骤截图如下： 2.1 移动遥控器到工具类栏目,如图2-1所示 图 2-1
2.2 移动遥控器到远程控制选项，如图2-2所示 图2-2
2.3 移动到远程控制选项后点击遥控OK键进入远程控制界面,如图2-3所示 图2-3
3.在电脑浏览器上输入图2-3上的ip地址(如10.0.1.120:8899)，这里的ip是我公司的，您需要输入自己公司的ip。(注意：您的电脑和TV需要在同一个WiFi或者局域网下才能安装) 3.1 输入您自己公司的ip后，打开如图3-1的界面 图3-1
3.2 点击上传文件,选择您当前正使用apk所在的目录,apk就会上传到TV电视或者盒子上 图3-2
4.apk的目录如图4-1所示(这里的目录是我电脑的apk目录，您需要选择您自己的apk目录) 4.1 您自己电脑的apk目录，如图4-1所示 图4-1
5.apk应用安装成功后提示如图5-1所示 图5-1
6.若apk包安装成功后，移动遥控器到打开按钮出现如图6-1的画面算是完整的apk安装流程完成. 图6-1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60579a645c8705b07fe62e6351e6c80/" rel="bookmark">
			SpringCloudAlibaba — — OpenFeign的简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloudAlibaba — — OpenFeign的概念及应用 1 什么是OpenFeign OpenFeign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用OpenFeign，可以做到使用HTTP请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问HTTP请求，用法其实就是编写一个接口，在接口上添加注解即可。
可以简单理解它是借鉴Ribbon的基础之上，封装的一套服务接口+注解的方式的远程调用器。
1.1 OpenFeign作用 它的宗旨是编写Java Http客户端接口的时候变得更加容易，其底层也整合了Ribbon，所以也可以支持负载均衡。
之前我们在使用Ribbon的时候，利用的是RestTemplate对Http请求进行封装处理，但是在实际开发过程中，对服务依赖的调用不可能就一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以OpenFeign在此基础上做了进一步的封装，由它帮我们定义和实现依赖服务接口的定义，我们只需要创建一个接口并使用使用的方式配置它，即可完成对微服务提供方的接口绑定，简化Ribbon的操作。
1.2 OpenFeign的使用 使用OpenFeign其实就是在消费端去远程调用，就必须要是FeignClient注解，来标注要调用的服务提供者名称，然后再通过一个接口来定义要调用的方法
2 Ribbon、Feign、OpenFeign联系 ①Ribbon
Ribbon是Netflix开源的基于HTTP与TCP等协议的负载均衡组件 ②Feign
SpringCloud组件中一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用注册中心（Nacos等）的服务Feign的使用方式：使用Feign自己的注解定义接口，然后调用这个接口就可以调用注册中心的服务Feign本身不支持Spring MVC注解，它有一套自己的注解 ③OpenFeign
OpenFeign是SpringCloud在Feign的基础上支持了SpringMVC的注解，如：@RequestMapping等OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口【通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务】注意：@RequestMapping不能在类名上与@FeignClient同时使用 3 OpenFeign实战小案例 3.1 创建一个模块cloudalibaba-provider-9003，作为消费者注册到本地Nacos上 模块结构如下：
创建好maven模块，继承父模块，并导入相关jar包：包括nacos、mybatis、mysql等
①pom.xml:
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.zi&lt;/groupId&gt; &lt;artifactId&gt;SpringCloudAlibabaAll&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.zi&lt;/groupId&gt; &lt;artifactId&gt;cloudalibaba-provider-9003&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloudalibaba-provider-9003&lt;/name&gt; &lt;description&gt;cloudalibaba-provider-9003&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b60579a645c8705b07fe62e6351e6c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5621a6fd1f7b71c5a82076a7611e201/" rel="bookmark">
			从 VLAN 到 IPVLAN: 聊聊虚拟网络设备及其在云原生中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：张伟（谢石）
由于这篇文章真的很长，大量的篇幅在讲述内核的实现，如果你对这部分不感兴趣，那么在建议你在看完第一部分的三个问题后，思考一下，然后直接跳转到我们对问题的回答。
提出问题 注：本文所有的代码均为 Linux 内核源代码，版本为 5.16.2
你听说过 VLAN 么？它的全称是 Virtual Local Area Network，用于在以太网中隔离不同的广播域。它诞生的时间很早，1995 年，IEEE 就发表了 802.1Q 标准 [ 1] 定义了在以太网数据帧中 VLAN 的格式，并且沿用至今。如果你知道 VLAN，那么你听说过 MACVlan 和 IPVlan 么？随着容器技术的不断兴起，IPVlan 和 MACVlan 作为 Linux 虚拟网络设备，慢慢走上前台，在 2017 年 Docker Engine 的 1.13.1 的版本 [2 ] 中，就开始引入了 IPVlan 和 MACVlan 作为容器的网络解决方案。
那么你是否也有过以下的疑问呢？
1. VLAN 和 IPVlan，MACVlan 有什么关系呢？为什么名字里都有 VLAN？
2. IPVlan 和 MACVlan 为什么会有各种模式和 flag，比如 VEPA，Private，Passthrough 等等？它们的区别在哪里？
3. IPVlan 和 MACVlan 的优势在哪里？你应该在什么情况下接触到，使用到它们呢？
我也曾有过一样的问题，今天这篇文章，我们就针对上面三个问题一探究竟。
背景知识 以下为一些背景知识，如果你对 Linux 本身很了解，可以跳过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5621a6fd1f7b71c5a82076a7611e201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be73044a41b673ae37f74b13ace990d/" rel="bookmark">
			【ACWing 算法基础】DFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 模板 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } 二. 总结 DFS 与 BFS 对比
剪枝：
最优性剪枝：当前的路径一定可以判断不如最优解可行性剪枝：当前的路径一定不合法 N皇后解析
三. 例题 842. 排列数字843. n-皇后问题 AC代码:
#include &lt;iostream&gt; using namespace std; const int N = 20; // bool数组用来判断搜索的下一个位置是否可行 // col列，dg对角线，udg反对角线 // g[N][N]用来存路径 int n; char g[N][N]; bool col[N], dg[N], udg[N]; void dfs(int u) { // u == n 表示已经搜了n行，故输出这条路径 if (u == n) { for (int i = 0; i &lt; n; i ++ ) puts(g[i]); // 等价于cout &lt;&lt; g[i] &lt;&lt; endl; puts("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be73044a41b673ae37f74b13ace990d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc4e9bd6372f3190be39fe6144b6755/" rel="bookmark">
			Git命令行学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git命令行学习笔记 持续更新
查看缓冲区中的文件信息 https://blog.csdn.net/qq_40021015/article/details/121741959
git ls-files 撤销已经提交的commit https://blog.csdn.net/hon_vin/article/details/122439304
https://m.php.cn/tool/git/484979.html
HEAD^ 表示上一个版本，即上一次的commit，也可以写成HEAD~1 如果进行两次的commit，想要都撤回，可以使用HEAD~2–soft 不删除工作空间的改动代码 ，撤销commit，不撤销git add file–hard 删除工作空间的改动代码，撤销commit且撤销add git reset --soft HEAD^ 用ssh公钥解决git clone太慢而失败的问题 用命令行生成一个ssh公钥
ssh-keygen -t rsa -b 4096 拷贝.ssh/id_rsa.pub中的全部内容。在github主页上点击头像打开settings，而后打开SSH and GPG keys，在SSH keys中添加新的key，可以自己设置一个名称，同时将上面提到的.ssh/id_rsa.pub文件中的内容复制到key中。
最后，在使用git clone时，切换成ssh模式，例如：
git clone --branch dev git@github.com:username/Repo.git clone某一特定分支 git clone --branch dev https://github.com/username/Repo.git 查看分支 # 查看本地分支 git branch # 查看本地和远程所有分支 git branch -a # 查看远程分支 git branch -r 查看新创建的未被追踪的文件 git status 添加文件 添加所有修改文件
git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc4e9bd6372f3190be39fe6144b6755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2868d5fb2664cfd6826e0315671f5b72/" rel="bookmark">
			CF1716 F-Bags With Balls
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CF1716 F-Bags With Balls Statement 有 n n n个互不相同的盒子, 里面有 m m m个标号依次为 [ 1 , m ] [1,m] [1,m]的球, 从这 n n n个盒子中每个盒子取出一个求. 设 F F F为取出 n n n个求的奇数标号的个数, 求所有情况的 F k F^k Fk之和. Solution 设 P = ⌈ M 2 ⌉ M P=\frac{\lceil\frac{M}{2}\rceil}{M} P=M⌈2M​⌉​, 则从一个盒子中取出奇数标号的概率为 P P P. 则有概率基本定理可知 A n s = m n ∑ i = 0 n P i ( 1 − P ) n − i C n i i k Ans=m^n\sum_{i=0}^nP^i(1-P)^{n-i}C_n^ii^k Ans=mn∑i=0n​Pi(1−P)n−iCni​ik.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2868d5fb2664cfd6826e0315671f5b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9184ae6a838b82e7e5cf43127daf7718/" rel="bookmark">
			Nacos启动失败：Nacos Server did not start because dumpservice bean construction failure:No DataSource set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：本地Docker搭建了Nacos（使用数据库），一直使用正常；突然有一天Nacos一直启动报错：“Nacos Server did not start because dumpservice bean construction failure :No DataSource set”。
原因：链接MySql数据库连接配置错误，或者使用了高版本的数据库导致的；Nacos链接数据connectTimeout默认1000毫秒、socketTimeout默认3000毫秒；Mysql链接超时，将超时时间调大。
解决：文件application.properties修改："?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000" =&gt; "?characterEncoding=utf8&amp;connectTimeout=10000&amp;socketTimeout=30000"
————————————————
版权声明：本文为CSDN博主「寻找09之夏」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_34272964/article/details/124176169
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e1f6d947f92bd1dac5bc068eaad3d2/" rel="bookmark">
			【教程】关于丝杆旋转一周前进的距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近有一个项目需要使用42步进电机连接丝杆转动，需要知道电机旋转一周时螺母座在丝杆上运动的距离询问商家得知此款丝杆的螺距是2mm，由此我推测电机旋转一周螺母座应该运动2mm实际大概测量时发现电机旋转一周螺母座运动8mm，上网查找资料发现了丝杆的螺距和导程的概念 概念 螺距：沿螺旋线方向量得的，相邻两螺纹之间的距离。一般指在螺纹螺距中螺纹上相邻两牙在中径线上对应两点间的轴向距离。导程：是螺纹上任意一点沿同一条螺旋线转一周所移动的轴向距离。 单头、双头、多头丝杆的区别：单头丝杆指丝杆上只有一条螺纹线，双头就是两条螺纹线，以此类推。 我的项目使用的是四头丝杆，也就是有四条螺纹线，而螺距是2mm，导程是4 * 2 = 8mm，所以电机旋转一周螺母座沿着一条螺纹线运动，最终是运动了8mm。
测量方法 螺距：按照概念中的测量方法即可 几头丝杆的判断方法：在丝杆截面看有多少个螺纹的“入口“，有四个”入口“就是有四条螺纹线，也就是四头丝杆 导程（丝杆旋转一周螺母座前进的距离） = 螺距 * 头数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d571d029d724f0c75b9ff43be977ec7/" rel="bookmark">
			【Mac&amp;Vue】解决在MacOS下Vue-Cli无法使用80端口的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不愿意看过程的同学点我看解决方法 背景 最近要做微信开发，前端使用了Vue。众所周知Vue Cli模式是在本地开启一个开发服务器用来开发使用的。所以对于前端页面必须要有域名才可以开发微信业务。
微信公众号开发的过程中的OAuth认证是需要先访问微信服务器，获取code后跳回到访问时传入的redirect_url。这里面有2个限制
必须为公众号设定的安全域名不能携带端口号 经过 一开始我愉快地设定好了hosts，域名指向到本机。启动vue开发服务开始调试。结果发现Vue启动的端口不能分配到80，而一直是1024！
这就导致微信跳回地址后，每次都需要手动添加端口号。严重影响了开发效率，间接的影响了我摸鱼的时间，随开始调查原因。
期初好多人都说加了sudo就好了，测试后无效。
最后看了某大佬的文章，发现需要把相关文件的所有者改为root，使用sudo才能正常使用root权限。于是就测试了一下。
解决方法 使用命令
sudo chown root &lt;vue项目文件夹路径&gt; 修改所有者为root后，使用sudo再次启动服务，授权后终于成功变成80端口，终于可以愉快地开发了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2520667c43bdde30c7433782652f427a/" rel="bookmark">
			CLIP算法的Loss详解 和 交叉熵CrossEntropy实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CLIP：Contrastive Language–Image Pre-training(可对比语言-图像预训练算法)是OpenAI提出的多模态预训练的算法，在各种各样的**样本对(图像、文本)**上训练的神经网络。
具体参考：CLIP、OpenCLIP
其中，流程：
loss_i和loss_t的具体源码如下，参考 model.py：
def forward(self, image, text): image_features = self.encode_image(image) text_features = self.encode_text(text) # normalized features image_features = image_features / image_features.norm(dim=1, keepdim=True) text_features = text_features / text_features.norm(dim=1, keepdim=True) # cosine similarity as logits logit_scale = self.logit_scale.exp() logits_per_image = logit_scale * image_features @ text_features.t() logits_per_text = logits_per_image.t() # shape = [global_batch_size, global_batch_size] return logits_per_image, logits_per_text 其中，labels是torch.arange(batch_size, device=device).long()，参考train.py，具体如下
with torch.no_grad(): for i, batch in enumerate(dataloader): images, texts = batch images = images.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2520667c43bdde30c7433782652f427a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9f9eda7da280cbedbb79f8541fba64/" rel="bookmark">
			K8S学习笔记之控制器statefulset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键概念 为了管理有状态的服务而存在（有顺序号的Pod）
有状态服务 StatefulSet是有状态的集合，管理有状态的服务，它所管理的Pod的名称不能随意变化。数据持久化的目录也是不一样，每一个Pod都有自己独有的数据持久化存储目录。比如MySQL主从、redis集群等。
无状态服务 RC、Deployment、DaemonSet都是管理无状态的服务，它们所管理的Pod的IP、名字，启停顺序等都是随机的。个体对整体无影响，所有pod都是共用一个数据卷的，部署的tomcat就是无状态的服务，tomcat被删除，在启动一个新的tomcat，加入到集群即可，跟tomcat的名字无关。
Headless Service 用来定义pod网路标识，生成可解析的DNS记录。
在用statefulset管理pod时要求pod名称必须是有序的 ，每一个pod不能被随意取代，pod重建后pod名称还是一样的。
因为pod IP是变化的，所以要用Pod名称来识别，pod名称是pod唯一性的标识符，必须持久稳定有效。这时候要用到无头服务，它可以给每个Pod一个唯一的名称。
Headless service不分配clusterIP，headless service可以通过解析service的DNS,返回所有Pod的dns和ip地址 (statefulSet部署的Pod才有DNS)，普通的service,只能通过解析service的DNS返回service的ClusterIP。
# 1.headless service会为service分配一个域名 &lt;service name&gt;.$&lt;namespace name&gt;.svc.cluster.local # 2.StatefulSet会为关联的Pod保持一个不变的Pod Name Pod的名字格式为$(StatefulSet name)-$(pod序号) # 3.StatefulSet会为关联的Pod分配一个dnsName $&lt;Pod Name&gt;.$&lt;service name&gt;.$&lt;namespace name&gt;.svc.cluster.local ## 【扩展】全质量域名：FQDN Fully Qualified Domain Name 即全限定域名：同时带有主机名和域名的名称 FQDN = Hostname + DomainName 如 主机名是 master 域名是 baidu.com FQDN= master.baidu.com ## K8s中资源的全局FQDN格式: Service_NAME.NameSpace_NAME.Domain.LTD. Domain.LTD.=svc.cluster.local VolumeClaimTemplate 有状态应用的持久化存储模板，有状态应用要求主从机器的持久化存储卷不能够是共享的（独立存储空间）。
statefulset定义中的每一个pod都不能使用同一个存储卷，这就需要使用volumeClainTemplate，当在使用statefulset创建pod时，volumeClainTemplate会自动生成一个PVC，从而请求绑定一个PV，每一个pod都有自己专用的存储卷。
资源清单解释 # kubectl explain statefulset.spec podManagementPolicy	&lt;string&gt; #pod管理策略 replicas	&lt;integer&gt; #副本数 revisionHistoryLimit	&lt;integer&gt; #保留的历史版本 selector	&lt;Object&gt; -required- #标签选择器，选择它所关联的pod serviceName	&lt;string&gt; -required- #headless service的名字【VIP】 template	&lt;Object&gt; -required- #生成pod的模板 updateStrategy	&lt;Object&gt; #更新策略 volumeClaimTemplates	&lt;[]Object&gt; #存储卷申请模板【VIP】 # kubectl explain statefulset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d9f9eda7da280cbedbb79f8541fba64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eaeaf455b1aab8ca2fb0a3631afd13d/" rel="bookmark">
			基于深度学习的时间序列预测模型论文综述An Experimental Review on Deep Learning Architectures for Time Series Forecasting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文题目：An Experimental Review on Deep Learning Architectures for Time Series Forecasting
介绍：这是一篇基于深度学习的用于时间序列预测模型综述型论文
论文：https://arxiv.org/pdf/2103.12057v2.pdf
说明：本文只是记录论文阅读中的学习笔记，整理一下，这篇综述所涉及的预测模型有七种：MLP、ERNN、LSTM、GRU、ESN、CNN、TCN，论文作者从预测精度和预测速度等方面对这其中模型进行了比较说明最后得出结论。
下面是本人在阅读论文中所做的一些总结，整理了一个思维导图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37fcf6207bb180e44618e0954f497e98/" rel="bookmark">
			网络编程（计算机网络相关）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程概述 网络编程是什么：
就是用来实现 网络互连的不同计算机上 运行的程序间可以进行 数据交换 。
网络编程的目的：
直接或间接地 通过网络协议 与其它计算机实现 数据交换，进行通讯。
网络编程中有两个主要的问题：
如何准确地定位网络上一台或多台主机，定位主机上的特定的应用
找到主机后如何可靠高效地进行数据传输
网络通信要素概述（三要素） IP、端口号
网络通信协议
通信要素1： IP和端口号 IP 地址：InetAddress 1.唯一的标识 Internet 上的计算机（通信实体）
2.本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost
3.有两种分类方式：
IP地址分类方式1：IPV4 和 IPV6
IPV4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已 经用尽。以点分十进制表示，如192.168.0.1
IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984
IP地址分类方式2：公网地址(万维网使用)和私有地址(局域网使用)。192.168. 开头的就是私有址址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用
特点：不易记忆
端口号 1.标识正在计算机上运行的进程（程序），不同的进程有不同的端口号
2.被规定为一个 16 位的整数 0~65535。
3.端口分类：
公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口 80，FTP占用端口21，Telnet占用端口23）
注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占 用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。
动态/私有端口：49152~65535。
4.端口号与IP地址的组合得出一个网络套接字：Socket。
通信要素2：网络协议 1.网络通信协议
计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。
2.通信协议分层的思想
计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩 解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？
在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常 用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与 再下一层不发生关系。各层互不影响，利于系统的开发和扩展。
TCP/IP协议簇 1.传输层协议中有两个非常重要的协议：
传输控制协议TCP(Transmission Control Protocol)
用户数据报协议UDP(User Datagram Protocol)。
2.TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37fcf6207bb180e44618e0954f497e98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027fbc0e16dae986af5a1deb5411f0c1/" rel="bookmark">
			Ubuntu上Git的简单配置及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu上Git的简单配置（使用的代码托管平台为gitee码云，github类似） 目录 Ubuntu上Git的简单配置（使用的代码托管平台为gitee码云，github类似）1、关于gitee2、Ubuntu下Git的下载及配置3、使用Git连接到远程的Gitee仓库4、常用命令 1、关于gitee Gitee(码云) 是 OSCHINA.NET 推出的代码托管平台,支持 Git 和 SVN,提供免费的私有仓库托管。致力于为国内开发者提供优质稳定的托管服务。相比于国外的github，github是全英文并且用户基数多，知名的库也多。gitee为中文版更易使用。在国内访问Github偶尔会有不稳定情况，而Gitee不会出现不稳定情况。
2、Ubuntu下Git的下载及配置 (1)、首先打开虚拟机，进入Ubuntu
(2)、下载git
打开终端命令窗口,输入：sudo apt-get install git
提示：sudo命令是用来以其他身份来执行命令，预设的身份为root,使用sudo时必须先输入密码，之后有5分钟的有限期，过期后需重新输入密码。
(3)、可以使用命令git --version查看git的版本号
(4)、设置用户名和邮箱
使用命令git config --global user.name "名称"设置用户名
使用命令git config --global user.email "邮箱"设置邮箱
(5)、查看设置的用户名和邮箱
使用命令git config --global --list
(6)、生成密钥信息
输入命令ssh-keygen -t rsa -C"youremail"
之后一直回车即可 youremail:你自己的邮箱账号 。
补充：-t:指定要创建的密钥的类型。rsa:一种加密算法。-C:添加注释
红色框框内是生成的公钥和私钥的位置
(7)、查看创建好的公钥
可使用gedit或其他工具查看生成的公钥，
以下用gedit: gedit /home/ubuntutest/.ssh/id_rsa.pub
此公钥将用gitee中SSH公钥的配置
(8)、打开gitee—&gt;设置—&gt;SSH公钥
填好标题，将刚刚的公钥复制、粘贴到公钥下面的框框里面，之后点击“确定”即可。
3、使用Git连接到远程的Gitee仓库 (1)、创建一个目录文件
(2)、在该目录下打开终端
(3)、初始化git仓库：使用命令git init
(4)、使用命令git add 文件名（ . 表示全部文件）将文件添加文件到缓存区
(5)、使用git commit -m " 提交信息"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/027fbc0e16dae986af5a1deb5411f0c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e37a75acbfe92de4cae4a604d04d735/" rel="bookmark">
			谈一谈windows剪贴板的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;小fisher首发office精英俱乐部-http://www.officefans.net/cdb/，转载请注明出处&gt;
首先，讨论一下剪贴板是什么
Windows的帮助文件中对剪贴板的描述是这样的：剪贴板是从一个地方复制或移动并打算在其他地方使用的信息的临时存储区域。可以选择文本或图形，然后使用“剪切”或“复制”命令将所选内容移动到剪贴板，在使用“粘贴”命令将该内容插入到其他地方之前，它会一直存储在剪贴板中。例如，您可能要复制网站上的一部分文本，然后将其粘贴到电子邮件中。大多数 Windows 程序中都可以使用剪贴板。
对于经常使用Ctrl+C/X、Ctrl+V的Windows用户来说，这个解释是非常易懂并且符合人们感观上的认识的。
既然我们今天讨论的话题是如何在VBA程序中通过API调用剪贴板，那就先看看微软MSDN中对于剪贴板的定义吧：剪贴板是一组用于在多个应用程序之间交换数据的函数和消息（原文：The clipboard is a set of functions and messages that enable applications to transfer data）。
呵呵，是不是有些晕？没关系，因为这句话是针对C/C++程序员给出的说明，我们仍然可以按习惯上的理解把它当做一个对象（使用过VB6的同志们可能更容易理解，因为VB6中确实有一个名字叫ClipBoard的对象，它其实是VB对windows的剪贴板API函数封装后产生的真正的对象）。
然后，再来看看这个对象有什么特点，又是如何工作的呢？概括来说，剪贴板有以下的特性（这是我个人总结的，不一定正确或精确，也不一定全面）：
公开性
剪贴板中的数据存放在全局内存中，因此大部分的windows应用程序都可以访问其中的数据，在遵守相关API函数约定的前提下，应用程序可以自由地打开剪贴板(OpenClipboard)，读取剪贴板内的数据(GetClipboardData)、或者清空剪贴板(EmptyClipboard）、然后设置剪贴板内的数据(SetClipboardData），最后关闭剪贴板(CloseClipboard)；
独占性
既然剪贴板是公开的，那么多个程序同时访问必然会导致冲突，比如数据互相覆盖。因此，Windows规定应用程序对剪贴板的访问是独占性的，当一个应用程序使用OpenClipboard打开剪贴板之后，其他程序 就不可以再访问剪贴板，直至前一程序使用CloseClipboard关闭剪贴板 。通常我们使用剪贴板的时候不会感觉受其他程序的影响，这是因为剪贴板内的数据操作都是在内存中进行的，速度非常快，对于特大块的数据，应用程序还可以选择延时处理(Delayed Rendering)机制以保证速度。但是，我们在对剪贴板编程的时候要注意以下两点：1)每次使用完剪贴板之后一定要记得使用CloseClipBoard关闭 它；2)在OpenClipboard和CloseClipboard之间不要放置耗时很长的代码，以免影响其他程序正常工作。
设置剪贴板内数据的应用程序窗口被称为剪贴板数据拥有者(ClipboardOwner)，可以通过GetClipboardOwner函数获得它的句柄。反过来说，如果一个应用程序想向剪贴板中放入数据，需要先成为ClipboardOwner。程序要成为ClipboardOwner需要先将自己的句柄传给OpenClipboard函数，如果剪贴板中已经有数据存在，还需要先调用EmptyClipboard；
多元性
剪贴板中可以同时存放多种格式的数据，各自放在全局内存的不同位置 ；剪贴板中的数据有标准格式/预定义格式的，如文本、位图、Wav声音……；也有非标准格式/用户自定义格式，比如word中的域和公式、Excel中的图表
可检索性
对于每种在剪贴板中存放过的格式，Windows都会给它分配一个独特的长整型编号，通过这个编号可以知道对应的数据格式的名称(GetClipboardFormatName)，或者 查询对应的数据在剪贴板中是否存在（IsClipBoardFormatAvailable)，如果存在，还可以通过这个编号找到对应的数据在内存中存放的位置(GetClipboardData)；
对于标准格式，这个编号是固定的，可以通过VB6自带的APIViewer查询以CF_开头的常量得到，比如：
Public Const CF_TEXT = 1
Public Const CF_BITMAP = 2
Public Const CF_METAFILEPICT = 3
Public Const CF_SYLK = 4
……
对于非标准格式，这个编号由提供此格式数据的应用程序给此格式定义一个名称，然后将此名称传递给RegisterClipboardFormat函数，如果此名称已经存在，函数将返回此名称对应的编号，如果此名称不存在，函数将返回一个之前未使用的编号，在系统关机重启之前，这个名称和编号可以一直使用下去。
可监视性
有一组特别的窗口可以持续监视剪贴板内的数据变化，这组窗口被称作剪贴板观察程序(ClipboardViewer)，由它们构成的这个小圈子叫作剪贴板观察程序链ClipBoardViewerChain，每当剪贴板内数据发生变化时，windows将向消息链中的第一个窗口发送一个WM_DRAWCLIPBOARD消息，再由它转发给第二个……直至消息到达消息链中的最后一个窗口，同样，当消息链中的成员发生变化时，每个窗口都会收到一个WM_CHANGECBCHAIN消息；
通过SetClipboardViewer函数，应用程序可以将自己的窗口句柄告诉windows，从而注册成为剪贴板观察程序链中的一员；通过ChangeClipboardChain函数，应用程序可以退出剪贴板观察程序链而不影响它后面的窗口继续接收相关消息。
希望以上文字能对大家重新认识剪贴板能够有所帮助。休息一会儿，我们再讨论剪贴板在Office VBA中的用途 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f05b0a113ac2d36dee44ae93b26fe0f/" rel="bookmark">
			神经网络是模型还是算法,神经网络模型数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络算法原理 4.2.1概述人工神经网络的研究与计算机的研究几乎是同步发展的。
1943年心理学家McCulloch和数学家Pitts合作提出了形式神经元的数学模型，20世纪50年代末，Rosenblatt提出了感知器模型，1982年，Hopfiled引入了能量函数的概念提出了神经网络的一种数学模型，1986年，Rumelhart及LeCun等学者提出了多层感知器的反向传播算法等。
神经网络技术在众多研究者的努力下，理论上日趋完善，算法种类不断增加。目前，有关神经网络的理论研究成果很多，出版了不少有关基础理论的著作，并且现在仍是全球非线性科学研究的热点之一。
神经网络是一种通过模拟人的大脑神经结构去实现人脑智能活动功能的信息处理系统，它具有人脑的基本功能，但又不是人脑的真实写照。它是人脑的一种抽象、简化和模拟模型，故称之为人工神经网络（边肇祺，2000）。
人工神经元是神经网络的节点，是神经网络的最重要组成部分之一。目前，有关神经元的模型种类繁多，最常用最简单的模型是由阈值函数、Sigmoid函数构成的模型（图4-3）。
图4-3人工神经元与两种常见的输出函数神经网络学习及识别方法最初是借鉴人脑神经元的学习识别过程提出的。
输入参数好比神经元接收信号，通过一定的权值（相当于刺激神经兴奋的强度）与神经元相连，这一过程有些类似于多元线性回归，但模拟的非线性特征是通过下一步骤体现的，即通过设定一阈值（神经元兴奋极限）来确定神经元的兴奋模式，经输出运算得到输出结果。
经过大量样本进入网络系统学习训练之后，连接输入信号与神经元之间的权值达到稳定并可最大限度地符合已经经过训练的学习样本。
在被确认网络结构的合理性和学习效果的高精度之后，将待预测样本输入参数代入网络，达到参数预测的目的。
4.2.2反向传播算法（BP法）发展到目前为止，神经网络模型不下十几种，如前馈神经网络、感知器、Hopfiled网络、径向基函数网络、反向传播算法（BP法）等，但在储层参数反演方面，目前比较成熟比较流行的网络类型是误差反向传播神经网络（BP-ANN）。
BP网络是在前馈神经网络的基础上发展起来的，始终有一个输入层（它包含的节点对应于每个输入变量）和一个输出层（它包含的节点对应于每个输出值），以及至少有一个具有任意节点数的隐含层（又称中间层）。
在BP-ANN中，相邻层的节点通过一个任意初始权值全部相连，但同一层内各节点间互不相连。
对于BP-ANN，隐含层和输出层节点的基函数必须是连续的、单调递增的，当输入趋于正或负无穷大时，它应该接近于某一固定值，也就是说，基函数为“S”型（Kosko，1992）。
BP-ANN的训练是一个监督学习过程，涉及两个数据集，即训练数据集和监督数据集。
给网络的输入层提供一组输入信息，使其通过网络而在输出层上产生逼近期望输出的过程，称之为网络的学习，或称对网络进行训练，实现这一步骤的方法则称为学习算法。
BP网络的学习过程包括两个阶段：第一个阶段是正向过程，将输入变量通过输入层经隐层逐层计算各单元的输出值；第二阶段是反向传播过程，由输出误差逐层向前算出隐层各单元的误差，并用此误差修正前层权值。
误差信息通过网络反向传播，遵循误差逐步降低的原则来调整权值，直到达到满意的输出为止。
网络经过学习以后，一组合适的、稳定的权值连接权被固定下来，将待预测样本作为输入层参数，网络经过向前传播便可以得到输出结果，这就是网络的预测。
反向传播算法主要步骤如下：首先选定权系数初始值，然后重复下述过程直至收敛（对各样本依次计算）。
（1）从前向后各层计算各单元Oj储层特征研究与预测（2）对输出层计算δj储层特征研究与预测（3）从后向前计算各隐层δj储层特征研究与预测（4）计算并保存各权值修正量储层特征研究与预测（5）修正权值储层特征研究与预测以上算法是对每个样本作权值修正，也可以对各个样本计算δj后求和，按总误差修正权值。
请问高手，神经网络模型与学习算法用什么语言编程比较好？JAVA 、C语言还是C++等。谢谢！ 神经网络、深度学习、机器学习是什么?有什么区别和联系? 深度学习是由深层神经网络+机器学习造出来的词。深度最早出现在deepbeliefnetwork（深度（层）置信网络）。其出现使得沉寂多年的神经网络又焕发了青春。
GPU使得深层网络随机初始化训练成为可能。resnet的出现打破了层次限制的魔咒，使得训练更深层次的神经网络成为可能。深度学习是神经网络的唯一发展和延续。
在现在的语言环境下，深度学习泛指神经网络，神经网络泛指深度学习。在当前的语境下没有区别。定义生物神经网络主要是指人脑的神经网络，它是人工神经网络的技术原型。
人脑是人类思维的物质基础，思维的功能定位在大脑皮层，后者含有大约10^11个神经元，每个神经元又通过神经突触与大约103个其它神经元相连，形成一个高度复杂高度灵活的动态网络。
作为一门学科，生物神经网络主要研究人脑神经网络的结构、功能及其工作机制，意在探索人脑思维和智能活动的规律。
人工神经网络是生物神经网络在某种简化意义下的技术复现，作为一门学科，它的主要任务是根据生物神经网络的原理和实际应用的需要建造实用的人工神经网络模型，设计相应的学习算法，模拟人脑的某种智能活动，然后在技术上实现出来用以解决实际问题。
因此，生物神经网络主要研究智能的机理；人工神经网络主要研究智能机理的实现，两者相辅相成。
神经网络BP模型 一、BP模型概述误差逆传播(ErrorBack-Propagation)神经网络模型简称为BP(Back-Propagation)网络模型。
PallWerbas博士于1974年在他的博士论文中提出了误差逆传播学习算法。完整提出并被广泛接受误差逆传播学习算法的是以Rumelhart和McCelland为首的科学家小组。
他们在1986年出版“ParallelDistributedProcessing，ExplorationsintheMicrostructureofCognition”(《并行分布信息处理》)一书中，对误差逆传播学习算法进行了详尽的分析与介绍，并对这一算法的潜在能力进行了深入探讨。
BP网络是一种具有3层或3层以上的阶层型神经网络。上、下层之间各神经元实现全连接，即下层的每一个神经元与上层的每一个神经元都实现权连接，而每一层各神经元之间无连接。
网络按有教师示教的方式进行学习，当一对学习模式提供给网络后，神经元的激活值从输入层经各隐含层向输出层传播，在输出层的各神经元获得网络的输入响应。
在这之后，按减小期望输出与实际输出的误差的方向，从输入层经各隐含层逐层修正各连接权，最后回到输入层，故得名“误差逆传播学习算法”。
随着这种误差逆传播修正的不断进行，网络对输入模式响应的正确率也不断提高。
BP网络主要应用于以下几个方面：1)函数逼近：用输入模式与相应的期望输出模式学习一个网络逼近一个函数；2)模式识别：用一个特定的期望输出模式将它与输入模式联系起来；3)分类：把输入模式以所定义的合适方式进行分类；4)数据压缩：减少输出矢量的维数以便于传输或存储。
在人工神经网络的实际应用中，80%～90%的人工神经网络模型采用BP网络或它的变化形式，它也是前向网络的核心部分，体现了人工神经网络最精华的部分。
二、BP模型原理下面以三层BP网络为例，说明学习和应用的原理。
1.数据定义P对学习模式(xp，dp)，p=1，2，…，P；输入模式矩阵X[N][P]=(x1，x2，…，xP)；目标模式矩阵d[M][P]=(d1，d2，…，dP)。
三层BP网络结构输入层神经元节点数S0=N，i=1，2，…，S0；隐含层神经元节点数S1，j=1，2，…，S1；神经元激活函数f1[S1]；权值矩阵W1[S1][S0]；偏差向量b1[S1]。
输出层神经元节点数S2=M，k=1，2，…，S2；神经元激活函数f2[S2]；权值矩阵W2[S2][S1]；偏差向量b2[S2]。
学习参数目标误差ϵ；初始权更新值Δ0；最大权更新值Δmax；权更新值增大倍数η+；权更新值减小倍数η-。
2.误差函数定义对第p个输入模式的误差的计算公式为中国矿产资源评价新技术与评价新模型y2kp为BP网的计算输出。
3.BP网络学习公式推导BP网络学习公式推导的指导思想是，对网络的权值W、偏差b修正，使误差函数沿负梯度方向下降，直到网络输出误差精度达到目标精度要求，学习结束。
各层输出计算公式输入层y0i=xi，i=1，2，…，S0；隐含层中国矿产资源评价新技术与评价新模型y1j=f1(z1j)，j=1，2，…，S1；输出层中国矿产资源评价新技术与评价新模型y2k=f2(z2k)，k=1，2，…，S2。
输出节点的误差公式中国矿产资源评价新技术与评价新模型对输出层节点的梯度公式推导中国矿产资源评价新技术与评价新模型E是多个y2m的函数，但只有一个y2k与wkj有关，各y2m间相互独立。
其中中国矿产资源评价新技术与评价新模型则中国矿产资源评价新技术与评价新模型设输出层节点误差为δ2k=(dk-y2k)·f2′(z2k)，则中国矿产资源评价新技术与评价新模型同理可得中国矿产资源评价新技术与评价新模型对隐含层节点的梯度公式推导中国矿产资源评价新技术与评价新模型E是多个y2k的函数，针对某一个w1ji，对应一个y1j，它与所有的y2k有关。
因此，上式只存在对k的求和，其中中国矿产资源评价新技术与评价新模型则中国矿产资源评价新技术与评价新模型设隐含层节点误差为中国矿产资源评价新技术与评价新模型则中国矿产资源评价新技术与评价新模型同理可得中国矿产资源评价新技术与评价新模型4.采用弹性BP算法(RPROP)计算权值W、偏差b的修正值ΔW，Δb1993年德国MartinRiedmiller和HeinrichBraun在他们的论文“ADirectAdaptiveMethodforFasterBackpropagationLearning：TheRPROPAlgorithm”中，提出ResilientBackpropagation算法——弹性BP算法(RPROP)。
这种方法试图消除梯度的大小对权步的有害影响，因此，只有梯度的符号被认为表示权更新的方向。
权改变的大小仅仅由权专门的“更新值”确定中国矿产资源评价新技术与评价新模型其中表示在模式集的所有模式(批学习)上求和的梯度信息，(t)表示t时刻或第t次学习。
权更新遵循规则：如果导数是正(增加误差)，这个权由它的更新值减少。如果导数是负，更新值增加。中国矿产资源评价新技术与评价新模型RPROP算法是根据局部梯度信息实现权步的直接修改。
对于每个权，我们引入它的各自的更新值，它独自确定权更新值的大小。
这是基于符号相关的自适应过程，它基于在误差函数E上的局部梯度信息，按照以下的学习规则更新中国矿产资源评价新技术与评价新模型其中0＜η-＜1＜η+。
在每个时刻，如果目标函数的梯度改变它的符号，它表示最后的更新太大，更新值应由权更新值减小倍数因子η-得到减少；如果目标函数的梯度保持它的符号，更新值应由权更新值增大倍数因子η+得到增大。
为了减少自由地可调参数的数目，增大倍数因子η+和减小倍数因子η–被设置到固定值η+=1.2，η-=0.5，这两个值在大量的实践中得到了很好的效果。
RPROP算法采用了两个参数：初始权更新值Δ0和最大权更新值Δmax当学习开始时，所有的更新值被设置为初始值Δ0，因为它直接确定了前面权步的大小，它应该按照权自身的初值进行选择，例如，Δ0=0.1(默认设置)。
为了使权不至于变得太大，设置最大权更新值限制Δmax，默认上界设置为Δmax=50.0。在很多实验中，发现通过设置最大权更新值Δmax到相当小的值，例如Δmax=1.0。
我们可能达到误差减小的平滑性能。5.计算修正权值W、偏差b第t次学习，权值W、偏差b的的修正公式W(t)=W(t-1)+ΔW(t)，b(t)=b(t-1)+Δb(t)，其中，t为学习次数。
6.BP网络学习成功结束条件每次学习累积误差平方和中国矿产资源评价新技术与评价新模型每次学习平均误差中国矿产资源评价新技术与评价新模型当平均误差MSE＜ε，BP网络学习成功结束。
7.BP网络应用预测在应用BP网络时，提供网络输入给输入层，应用给定的BP网络及BP网络学习得到的权值W、偏差b，网络输入经过从输入层经各隐含层向输出层的“顺传播”过程，计算出BP网的预测输出。
8.神经元激活函数f线性函数f(x)=x，f′(x)=1，f(x)的输入范围(-∞，+∞)，输出范围(-∞，+∞)。一般用于输出层，可使网络输出任何值。
S型函数S(x)中国矿产资源评价新技术与评价新模型f(x)的输入范围(-∞，+∞)，输出范围(0，1)。f′(x)=f(x)[1-f(x)]，f′(x)的输入范围(-∞，+∞)，输出范围(0，]。
一般用于隐含层，可使范围(-∞，+∞)的输入，变成(0，1)的网络输出，对较大的输入，放大系数较小；而对较小的输入，放大系数较大，所以可用来处理和逼近非线性的输入/输出关系。
在用于模式识别时，可用于输出层，产生逼近于0或1的二值输出。双曲正切S型函数中国矿产资源评价新技术与评价新模型f(x)的输入范围(-∞，+∞)，输出范围(-1，1)。
f′(x)=1-f(x)·f(x)，f′(x)的输入范围(-∞，+∞)，输出范围(0，1]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f05b0a113ac2d36dee44ae93b26fe0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804e79c81ce122a9909e1b78044e99c2/" rel="bookmark">
			Spring-jt-Day04-SpringMVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为CSDN博主「闪耀太阳」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_16804847/article/details/116292749
1.SpringMVC 1.1 SpringMVC框架介绍 Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts 2(一般老项目使用)等等。
小结: Spring内部整合SpringMVC(web的包)
1.2 SpringMVC入门案例 1.2.1 创建项目 1.2.2 添加依赖项 1).添加热部署/lombok包
1.2.3 检查pom.xml文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.jt&lt;/groupId&gt; &lt;artifactId&gt;springboot_demo_3&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot_demo_3&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--thymeleaf导入模版工具类--&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804e79c81ce122a9909e1b78044e99c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158dceaf3d21e24f02960ec530f5476d/" rel="bookmark">
			Android单元测试之 Mockito
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍 1.1 Mock介绍 在了解Mockito的概念之前，需要先了解Mock。
mock是在测试过程中，对于一些不容易构造/获取的对象，用一个虚拟的Mock对象来创建以便测试的测试方法。
在平时开发中，当我们开发好一个功能，但是没有需要的测试环境时，往往我们会自己带“假数据”写死，进去测试。
这样做虽然能够帮助我们找到Bug，但是“假数据”对开发来说并不友好，这使得虚拟数据与业务层耦合在一起，我们不仅需要手动加入，还要手动删除，如果遇到复杂点的对象，还要考虑如何在运行中去构建。在这些环节中如果一些细节没有处理，可能打出来的包就有问题。作为一中测试的手段，这种做法容错率低。
但是在部分情况下上述的方法效率还是很高的（我也经常这么搞）。
而Mock基本上就是对上述的手段进行了优化。解耦了虚拟数据与业务层，并且更加系统化整个测试流程。
1.2 Mock优势 它有这些好处：
团队提效
当使用mock之后，各团队之间可以不需要再互相等待对方的进度，只需要约定好相互之间的数据规范（文档），即可使用mock构建一个可用的接口，然后尽快的进行开发和调试以及自测，提升开发进度的的同时，也将发现缺陷的时间点大大提前。开启TDD（Test-Driven Development）模式，即测试驱动开发
单元测试是TDD实现的基石，而TDD经常会碰到协同模块尚未开发完成的情况，但是有了mock，这些一切都不是问题。当接口定义好后，测试人员就可以创建一个Mock，把接口添加到自动化测试环境，提前创建测试。测试覆盖率
假如有一个接口，有100个不同类型的返回，我们需要测试它在不同返回下，系统是否能够正常响应，但是有些返回在正常情况下基本不会发生，难道你要千方百计地给系统做各种手脚让他返回以便测试吗？比如，我们需要测试在当接口发生500错误的时候，app是否崩溃，别告诉我你一定要给服务端代码做些手脚让他返回500 。。。而使用mock，这一切就都好办了，想要什么返回就模拟什么返回，妈妈再也不用担心我的测试覆盖度了！隔离系统 / 依赖隔离
假如我们需要调用一个post请求，为了获得某个响应，来看当前系统是否能正确处理返回的“响应”，但是这个post请求会造成数据库中数据的污染，那么就可以充分利用Mock，构造一个虚拟的post请求，我们给他指定返回就好了。 1.3 Mock例子 一个闹钟根据时间来进行提醒服务，如果过了下午5点钟就播放音频文件提醒大家下班了，如果我们要利用真实的对象来测试的话就只能苦苦等到下午五点，然后把耳朵放在音箱旁，我们应该利用mock对象来进行测试，这样我们就可以模拟控制时间了，而不用苦苦等待时钟转到下午5点钟了。下面是代码：
public abstract class Environmental{ // 是否正在播放音频 boolean playedWav=false; // 获取当前时间 public abstract long getTime(); // 播放音频 public abstract void playWavFile(String fileName); // 音频是否在播放 public abstract boolean wavWasPlayed(); // 重置音频 public abstract void resetWav(); } 业务代码：
public class SystemEnvironment extends Environmental{ public long getTime(){ return System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158dceaf3d21e24f02960ec530f5476d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c9e0cd31ca23cc35080c2d31862d18/" rel="bookmark">
			MySQL Shell 命令介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySQL Shell 命令介绍
参数
可用主题
Shell命令
GLOBAL OBJECTS
EXAMPLES示例
MySQL Shell 命令介绍 The Shell Help is organized in categories and topics. To get help for a
specific category or topic use: \? &lt;pattern&gt;
Shell 帮助按类别和主题进行组织。 要获得特定类别或主题的帮助，请使用：\? &lt;pattern&gt;
The &lt;pattern&gt; argument should be the name of a category or a topic.
&lt;pattern&gt;参数应该是一个类别或一个主题的名称。 The pattern is a filter to identify topics for which help is required, it can
use the following wildcards:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c9e0cd31ca23cc35080c2d31862d18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cf48f69939ed73d8c7eee28c00013bc/" rel="bookmark">
			日收高权重域名交易
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日收高权重域名交易
地址：http://www.tpyjn.cn/post/4.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d78ef2125ff71e056087e77aa2467be/" rel="bookmark">
			CMAKE安装遇到的问题cannot find propriate Makefile Processor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LInux下的cmake安装问题 装cmake遇到了这个错误 Error when bootstrapping CMake: cannot find propriate Makefile Processor on this system
解决方法：
前提是先装好g++和gcc
sudo apt install build-essential 后面又遇到了 could not find OpenSSL , try to set the path to OpenSSL这个问题 ，但是我已经安装了OpenSSL
解决方法：
sudo apt install libssl-dev 最后安装成功（耗时1h)真揪心
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b5788678f8ccdbaeb57dd4d84fc769/" rel="bookmark">
			数据仓库搭建_hdfs,ACL权限认证（可以精确到个人的权限）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据仓库搭建 数据仓库搭建 前提条件，Hadoop，hive
数据仓库分层作用
1、控制数据访问权限
2、减少重复计算，减少重复开发
3、为了更好的管理数据
4、让表使用者更方便使用数据
数据规范
1、分词规范，ODS,DWD,DWS,ADS,DIM，每个公司分层的方式是不一样的，
2、命令规范，
库命名规范：每一个层对应hive中一个库，每一层对应hdfs中一个目录
表命名规范，每个定义都是由规则的，一般会使用库名作为前缀
字段命令规范
分区的命令规范
路径的命名规范
3、上调度规范
1.1、开启hdfs的权限认证， 以及ACL认证 在没有开启之前，任何用户都可以随意的删除root用户下的文件，这就可能造成了严重的安全隐患。所以我们在项目中就必须对每一层的文件设置权限
1、普通权限认证只能控制到当前用户，当前用户所属的组，其它用户，不能精确到每一个其它用户
2、ACl可以做到每一个用户权限认证，
rwx r-x r-x
第一部分是当前用户的权限
第二部分是当前用户所在组的权限
第三部分其它用户的权限
Failed to move to trash: hdfs://master:9000/data: Permission denied: user=test, access=WRITE, inode="/":root:supergroup:drwxr-xr
-x
用户test对/这个目录没有权限，需要WRITE
# 修改hdfs-site.xml文件，将权限认证打开 &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.acls.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; # 如果是分布式集群需要同步配置文件，同步到所有节点 scp hdfs-site.xml node1:`pwd` # 重启hadoop stop-all.sh start-all.sh # 增加权限的命令 hadoop dfs -chmod 755 /user 755: 其它用户可以读取，不能修改 # 将hdfstmp的目录权限给所有的用户 hadoop dfs -chmod -R 777 /tmp hadoop dfs -mkdir -p /data/gender_num hadoop dfs -chmod 700 /data/gender_num # acl设置权限 # 可以单独为每一个用户设置权限 hdfs dfs -setfacl -R -m user:test:r-x /nihao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b5788678f8ccdbaeb57dd4d84fc769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68e9216f971b6530b560d1dddd3616e/" rel="bookmark">
			Vue 报错 ：Invalid prop: type check failed for prop “defaultExpandAll“. Expected Boolean,
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE报错Invalid prop: type check failed for prop “defaultExpandAll”. Expected Boolean, got String with value “true”. 找半天defaultExpandAll找不到 后来根据true找到了
这个true不能加 直接默认为真 让他开启就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e46b6c759740af0f0631d1387fb505e/" rel="bookmark">
			Linux系统启动过程及关机、重启指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这是鄙人第一次写blog，如有不当之处，还请斧正，万分感谢！
最近正在学习Linux，对于其相关内容做了一部分整理、归纳，特此进行分享。
Linux系统启动过程 Linux系统的启动过程大致可分为五个部分：内核加载、运行init、初始化系统、用户登入、进入login shell。
一、内核加载 Linux系统开机时，BIOS(Basic Input Output System)首先会进行开机自检，待到操作系统接管硬件之后，会读入/boot目录下的内核文件。
二、运行init init进程是Linux内核启动的第一个用户级进程，它的进程编号（pid）为1，是Linux系统最基本的程序之一，init程序首先需要读取配置文件/etc/inittab。
Linux系统的七个运行级别（runlevel） 在linux开机过程中，许多程序需要启动，称为“守护进程”（daemon）。Linux有7个运行级别（0：关机、停机；1：单用户模式；2：多用户模式；3：完整的多用户模式；4：系统未使用、保留；5：图形化模式；6：重启模式）。
具体内容如下：
运行级别0：系统停机状态，系统默认运行级别不能为0，否则不能正常启动。运行级别1：单用户工作状态，root权限，用于系统的维护、阻止远程登录等，如同Windows的安全模式登录。运行级别2：多用户状态（没有NFS）。运行级别3：完全的多用户状态（有NFS），登录后进入控制台命令行模式。运行级别4：系统未使用，保留一般不使用。运行级别5：X11控制台，登录后进入图形GUI模式或者GNOME、KDE图形化界面。运行级别6：系统正常关闭并重启，系统默认运行级别不能为6，否则不能正常启动。 三、系统初始化 在Linux系统中，/etc/rc.d/rc(0~6).d/目录下的文件都是一些连接文件，真正的启动脚本存放在/etc/rc.d/init.d/目录下,rc启动脚本以K和S打头，字母S表示Start，以start为运行参数，即启动脚本；字母K表示Kill，以stop为运行参数，指明需要停止的程序。
#ls / #cd /etc/rc.d #ls rc(0~6).d #ls init.d 示例如下（以rc2.d为例）:
之后，init会打开6个终端，以便用户登录，其中用户输入的信息作为参数传给login来验证。
四、用户登入 一般的，用户登录方式有三种：
（1）命令行登录：init进程将调用getty程序，核对用户信息。
（2）ssh登录：系统调用sshd程序，取代getty和login。
（3）图形界面登录：init进程调用gdm显示管理器，核对用户信息。
五、进入login shell Linux预设提供了六个命令窗口终端机让我们来进行登录：tty1~6；
shell即命令行界面，取得bash时要完整的登录流程，称为login shell。
Linux系统启动示意图如下：
Linux关机、重启指令 halt	//关机，用于root用户，只关闭系统，而电源还在运行 halt -p	//关闭系统和电源 poweroff	//关机，用于root用户，向acpi发送关闭电源的信号 reboot	//重启，用于root用户 init	//init 0为关机，init 6为重启，用于root用户 systemctl	//systemctl (halt/poweroff/reboot) (-i),效果同上，普通用户需要加-i，root用户不用 sync	//将内存中的数据保存到硬盘中 shutdown指令是最常用到的关机重启指令，因此单独拿出来讲。
//基本格式：shutdown [类型] [时间] [警告信息] shutdown	//关机指令，默认一分钟后关机 shutdown -h now	//立即关机 shutdown -h 20:20	//最近的20:20关机 shutdown -h +10	//十分钟后关机 shutdown -r now	//立即重启 shutdown -r 20:20	//最近的20:20重启 shutdown -r +10	//十分钟后重启 shutdown -k +10 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e46b6c759740af0f0631d1387fb505e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fddd90f0c55fc3461d74a89a9e2ceb17/" rel="bookmark">
			踩坑记录 PIL与Opencv读取图像的差别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.读入的数据类型不同 PIL读入图像，以jepg为例，类型为PIL.JpegImagePlugin.JpegImageFile；
Opencv读入图像，直接就是numpy.ndarray。
2.宽、高顺序不同 PIL读入图像，顺序为：（宽，高），使用np.array()转换类型后，顺序为：（高，宽，通道数）
Opencv读入图像，顺序为：（高，宽，通道数）
3.通道顺序不同 PIL读入为R、G、B；
Opencv读入为B、G、R
4.代码验证对比 以读入该图像为例
from PIL import Image import cv2 import numpy as np print('-----PIL读取-----') pil_img = Image.open('Dog.jpeg') print('type(pil_img):', type(pil_img)) print('pil_img.size:', pil_img.size) # (宽，高) pil_img_arr = np.array(pil_img) print('pil_img_arr.shape:', pil_img_arr.shape) # (高，宽，通道数) print('-----opencv读取-----') opc_img = cv2.imread('Dog.jpeg') print('type(opc_img):', type(opc_img)) print('opc_img.size:', opc_img.size) print('opc_img.shape:', opc_img.shape) # (高，宽) print('-----通道顺序对比-----') p_r = pil_img_arr[:,:,0] p_g = pil_img_arr[:,:,1] p_b = pil_img_arr[:,:,2] o_b = opc_img[:,:,0] o_g = opc_img[:,:,1] o_r = opc_img[:,:,2] print('------') 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fddd90f0c55fc3461d74a89a9e2ceb17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0b21e39dc8b7fa7ea00205e5cf2a4f/" rel="bookmark">
			Android 常用开发框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本内容转载于：https://blog.csdn.net/IT_51888_liang/article/details/124312583
一、快速开发框架
XSnow
基于RxJava2+Retrofit2精心打造的Android基础框架，包含网络、上传、下载、缓存、事件总线、权限管理、数据库、图片加载，基本都是项目中必用功能，每个模块充分解耦，可自由拓展
2.MVPArms
一个整合了大量主流开源项目高度可配置化的 Android MVP 快速集成框架（包括Mvp、 Dagger2、RxJava、RxAndroid、Rxlifecycle、RxCache、RxPermissions、RxErroHandler、Retrofit、Okhttp、AndroidAutoSize、Gson、Butterknife、AndroidEventBus、Timber、Glide、LeakCanary）
3.Android-ZBLibrary
Android MVP快速开发框架，做国内 「Demo最全面」「注释最详细」「使用最简单」「代码最严谨」的Android开源UI框架
（包括OKHttp、UIL图片加载、ZXing二维码、沉浸状态栏、下载安装、自动缓存以及各种Base、Demo、UI、Util）
4.MVVMHabit
MVVMHabit是以谷歌DataBinding+LiveData+ViewModel框架为基础，整合Okhttp+RxJava+Retrofit+Glide等流行模块，加上各种原生控件自定义的BindingAdapter，让事件与数据源完美绑定的一款容易上瘾的实用性MVVM快速开发框架。
5.AndroidFire
AndroidFire，一款新闻阅读 App框架，基于 Material Design + MVP + RxJava + Retrofit + Glide，基本涵盖了当前 Android 端开发最常用的主流框架，基于此框架可以快速开发一个app。
二、网络相关
1.okhttp
功能强大的网络请求框架
2.retrofit
基于OKhttp的网络请求框架，配合Rxjava使用，逻辑非常简洁
3.okhttp-OkGo
该库是基于 Http 协议，封装了 OkHttp 的网络请求框架，比 Retrofit 更简单易用，支持 RxJava，RxJava2，支持自定义缓存，支持批量断点下载管理和批量上传管理功能
4.retrofit + rxjava案例RxJavaSamples
5.rxjava生命周期管理RxLifecycle
6.运行时权限申请 RxPermissions
三、注解与事件总线
1.注解框架butterknife
编译时注解框架，提供view和点击事件的绑定
2.注解框架 dagger
不仅可以view绑定，还可以提供对象绑定
3.事件总线EventBus
Event bus for Android and Java that simplifies communication between Activities, Fragments, Threads, Services, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0b21e39dc8b7fa7ea00205e5cf2a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e725456e01ff901e0bd5e63d19a311/" rel="bookmark">
			Linux 下使用 cron 定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		crontab命令 – 管理定时计划任务 crontab命令来自于英文词组“cron table”的缩写，其功能是管理定时计划任务。定时计划任务，故名意思就计划好的任务，到了时间就会自动执行，在Linux系统中的crond是一个定时计划任务服务，用户只要能够按照正确的格式（分、时、日、月、星期、命令）写入到配置文件中，那么就会按照预定的周期时间自动的执行下去，而crontab命令则是用于配置的工具名称。
语法格式：crontab [参数]
常用参数：
-e编辑任务-l列出任务-r删除任务-u指定用户名字--help显示帮助信息 参考实例
1.管理当前用户的计划任务： root@server01:~# crontab -e * * * * * command 选择编辑器，选2（bash） 回车即可：
特殊符号：
特定时间执行命令：
2.测试 1.# 创建一个定时任务，每分钟往hello.txt 输入信息 root@server01:~# crontab -e */1 * * * * echo "hello,world" &gt;&gt; /root/hello.txt crontab: installing new crontab 2.# 查看当前用户的已有计划任务列表： root@server01:~# crontab -l 3.# 观察结果 root@server01:~# tail -f hello.txt hello,world hello,world hello,world hello,world 创建定时任务时确保你的脚本命令尽量使用全路径，有些环境变量没配的话是执行不起来的，比如
vim cron.sh
/usr/bin/tar -zcPf /data/keymanTech/factorybi-backup/fbi_$(date +"%Y-%m-%d-%H:%M").tar.gz /data/keymanTech/factorybi-backup &gt;&gt; /dev/null 2&gt;&amp;1 &amp;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e725456e01ff901e0bd5e63d19a311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368ceb5eebb26030c0c2483632085999/" rel="bookmark">
			supervisor 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #停止所有进程 supervisorctl stop all #停止程序 func 所有进程 supervisorctl stop func:* #停止程序 func:nn_0 的进程 supervisorctl stop func:nn_0 #启动所有进程 supervisorctl start all #启动程序 func 所有进程 supervisorctl start func:* #启动程序 func:nn_0 的进程 supervisorctl start func:nn_0 #重启所有进程 supervisorctl restart all #重启程序 func 所有进程 supervisorctl restart func:* #重启程序 func:nn_0 的进程 supervisorctl restart func:nn_0 #更新新的配置到supervisord ##新增配置并加载,不会重启原来已运行的程序;如果更改原有配置中的进程数,将会把之前的进程都重启掉 supervisorctl update #重新启动配置中的所有程序 supervisorctl reload #更新 func 程序中的进程数(numprocs),并且新增、减少进程数,都不会影响到之前的进程数 supervisorctl grace_update func 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f9d91d37150e2c685c77322aefb0d2/" rel="bookmark">
			Swin-Transformer论文解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Swin-TransformerAttention机制的发展历程Attention中Q、K、V的概念Attention的计算过程swin-transformer 与VIT的区别swin-transformer整体架构Patch MergingSwin-transformer BlockSwin-transformer中的掩码机制自注意力的复杂度计算Swin-Transformer的详细架构效果比较ImageNet数据集COCO数据集语义分割数据集ADE20K Swin-Transformer Swin Transformer: Hierarchical Vision Transformer using Shifted Windows.
Ze Liu, Yutong Lin, Yue Cao, Han Hu, Yixuan Wei, Zheng Zhang Stephen Lin, Baining Guo
Computer Vision and Pattern Recognition (2021)
Microsoft Research Asia
https://github.com/microsoft/Swin-Transformer
Swin: Shifted Windows
swin-transformer是什么？
swin-transformer是可以用于计算机视觉任务的通用主干网络，可以用于图像分类、图像分割、目标检测等一系列视觉下游任务。
下面是swin-transformer在各个领域的一些应用
解决了什么问题？
与NLP领域不同，视觉领域同类的物体，在不同图像上/同一图像上的尺度会相差巨大；相较于文本，图像的尺寸过大，计算复杂度较高； 优点是什么？
提出了一种层级式网络结构，解决视觉图像的多尺度问题；提出Shifted Windows，极大降低了transformer的计算复杂度；可以广泛应用到所有计算机视觉领域； 结论是什么？
Transformer完全可以在各个领域取代CNN
效果怎么样？
在ImageNet上并非SOTA，仅与EfficientNet的性能差不多
swin-transformer的优点不是在于分类，在分类上的提升不是太多，而在检测、分割等下游任务中，有巨大的提升.
在目标检测数据集COCO上，比当时的SOTA提高了2.7点左右的mAP
下面是paper with code上的最新截图，几乎全是Swin-Transformer的变体
在语义分割数据集ADE20K上，比当时的SOTA提高了3.2点左右的mAP
下面是paper with code上的最新截图，也几乎全是Swin-Transformer的变体
Attention机制的发展历程 Bengio团队于2014年提出Attention机制，用于机器翻译中，使模型自动寻找原文本中与预测目标单词相关的内容
Bahdanau D, Cho K, Bengio Y.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f9d91d37150e2c685c77322aefb0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a570c77885a9bde0bee316840e3f6ec/" rel="bookmark">
			小程序笔记3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自定义组件 1.创建组件
在项目的根目录中，鼠标右键，创建 components -&gt; test 文件夹在新建的 components -&gt; test 文件夹上，鼠标右键，点击“新建 Component”键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json，.wxml 和 .wxss 2.引用组件
局部引用：组件只能在当前被引用的页面内使用
在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”
“usingComponents”: {
“my-test1”: “/components/test/test”,
}
全局引用：组件可以在每个小程序页面中使用
app.json引用
“usingComponents”: {
“my-test1”: “/components/test/test”,
}
3.组件和页面的区别
从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同：
组件的 .json 文件中需要声明 “component”: true 属性组件的 .js 文件中调用的是 Component() 函数，app.js(App()),页面Page(）组件的事件处理函数需要定义到 methods 节点中 4.自定义组件样式
组件样式隔离（组件之间或者组件和页面之间样式互不影响，只针对样式选择器）
组件样式隔离的注意点
app.wxss 中的全局样式对组件无效只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响 修改组件的样式隔离选项
Component({ options: { styleIsolation: 'shared' }） 页面给组件传值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a570c77885a9bde0bee316840e3f6ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d681d5030e3e3ef082c5cca28ec69bc5/" rel="bookmark">
			《大话通信》阅读笔记整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本人从事的是卫星物联网行业，平时接触的更多的是卫星通信应用层方面。但是其实卫星通信和地面通信系统是有很多相似之处的，在我们去考虑物联网的行业上的应用时，需要先了解完整的通信体系是什么样的。当然，包括我自己在内容的大部分人都不是通信专业的，我们不用去深入底层了解所有的机制和原理，更多的是了解完整的体系，知道他们区别和价值，这样才能够了解最新的技术和行业方向。本文只是对书籍、文章的知识整理，如果你不想看那几百几千页的书籍，你可以看看这篇简单的文章，对此有一个大致的了解。但是我还是强烈建议，找几本不错的书籍好好看看。本人看的主要是大话书籍系列，这个系列的书籍我很喜欢。还有其他一些讲述物联网和5G,卫星网络的数据文章。本文中的原始材料以及图片等都是来自这些书籍和文章，文档正文不再一一说明。本文理解能力有限，如有不正确的地方还请指出。
1.数字通信系统 移动通信在最初的时候，可没有考虑数据业务，而是为了解决通话和短信，也就是早期的GSM系统，至于我们说的2G是在后面再加进去的。在看具体的移动通信系统之前，我们需要先看看从声音道电磁波的整个框架，之后，才开始进入到完整的通信系统。
在无线通信之前，大家都知道有线通信，但是有线通信是将声音转为电信号通过线缆进行传输的。电磁波出现之后，才有了无线通信。无线通信，需要处理的便是数字信号。不过需要注意的是，模拟通信并没有被完全替代，它是有它的优点的。不过对于我们普通的通信体系，数字通信之所以能够替代模拟通信，主要是由于远距离传输中的噪声处理。
如下图所示的数字通信系统框图：
信源与输入变化器以及信源与输出变化器是声信号和电信号之间的相互转化，此时的电流信号依旧是模拟信号。
信源编码则是将电流模拟信号转为数字信号，其流程经过抽样，量化，编码，得到我们熟悉的比特流数据了。
信道编码是以提高信息传输的可靠性为目的的编码，通俗讲就是用来判断数据的对错。比如串口通信中的奇偶校验位。
调制是频谱的搬移，是将低频信号嫁接到高频信号上进行传输。
信道传输，就是涉及到复杂的通信系统了。
以上每一点展开讲也是很复杂的，我本人也不是通信专业，也不可能通过几本书就能全部明白，只是知道大概，但是对于我们应用来说已经够了。
这个流程图不仅仅适用于地面移动通信，同样适用于卫星通信，我们平时做的卫星数据收发几乎是一样的，主要区别还是在信道，也就是空中传播不一样。
2.通信频率的使用 在具体讲述各个通信系统前，需要先明白四个概念，空分，频分，时分，码分。这些概念的提出目的都是一样的，解决频率资源有限的问题。其中码分比较特殊，在讲WCDMA时再进行说明。卫星的资源其实是更加紧张的。电磁波的范围是很大的，但是适合移动通信组网的频段不多，主要是微波的300MHz~3GHz,
不要觉得这个范围很大，三大运营商每一家分配的到的也只有几十MHz的带宽范围。没办反，适合通信的电磁波范围很少，还需要考虑上下行以及干扰等问题，剩下的也就那么点了。1MHz带宽的频率范围价值都是超过10亿美金的，国外运营商是真的花这么多钱买的！国内则有国家分配。
有限的电磁波就带了很大的问题，我们这么多人通信，每个人通信假设需要25KHz的带宽，电信的带宽也就几十MHz,肯定是不够用的。空分，频分，时分以及码分就是为了处理这个问题的。
2.1 空分复用 空分复用，是指降低发射塔的发射功率，缩小覆盖半径。这样可以让同一个频段在不同的空间内得到重复利用，称之为空分复用。
举个例子，广电的无线电视，一个城市，只有一个发射塔。因为电视信号是单向的，只有下行，没有上行。并且电视台的数目是有限的，也就几十个，多了也看不过来。假设电视台拥有100Mhz ~ 150Mhz的频率范围，一个电视台需要25kHz的带宽，那么第一个电视台100100.025MHz的范围，第二个电视台就是100.025100.50，依次累加，肯定是足够看的。
但是手机通信不一样，手机通信时双向的，而且手机通信的用户非常多。假设一个城市还是只有一个发射台，还是100~150MHz的频率范围，那么也就是50MHz带宽，假设一个人通信需要25KHz,但是由于上下行，频率需要错开，所以一个人就要占用50KHz的带宽，一个发射塔，只能2000个人使用，在考虑到干扰等因素，可能也就只能1500个用于使用。中国电信的CDMA2000只分配了上下行15MHz的频宽，肯定是不够的的。
空分复用是降低每一个发射塔的功率，缩小一个发射塔的覆盖半径。但是增加发射塔的数量，这样每一个塔范围下都可以使用同一个频段，并且互不干扰，发射塔其实就是基站。到这里就需要额外说的是，基站发射的信号覆盖范围呈六边形，一个个的基站组成起来，就成了蜂窝网了。
2.2 频分 频分很好理解，就是就是把一段频谱切成N块，每块分给一个载波，让这个载波去承载用户。就像上面说的，中国电信有15MHz的频宽，肯定不是给一个用户使用，每个用户只能分配到200KHz的频宽。
2.3 时分 有了频分和空分，依旧是不够用户使用的。一个基站也只有15MHz/200KHz=75个用户，算上干扰，更少了。于是便有了时分的概念。频分是从频宽行进行分割，时分是从时间上进行分割。也就是说，200KHz的带宽，7个人轮着使用。夸张一点，一人使用1S，轮流占用。不过实际的时分不过这么长时间的，只有几毫秒，这么短的时间间隔，对于通信人是感觉不出来的。
3.GSM 全球移动通信系统 相比较于WCDMA、TD_SCDMA、CDMA2000、LTE等，GSM相对而言好理解些，毕竟GSM不涉及码分的概念。
GMS 网络图如下所示：
基站（BTS），每一个基站覆盖一片区域，其功能有三点，和手机进行通信，进行功率控制，基站之间的切换。
移动交换中心（MSC），负责基站之间的数据交互。
基站控制器（BSC），管理基站。
归属位置寄存器（HLR），里面存储了开卡信息，包含用户的姓名，电话号码，开户地以及动态信息，也就是现所在地。
拜访位置寄存器（VLR），存储了一个用户具体在哪一个BSC的下。
鉴权中心（AuC）,用于盈利和加密。
其中，MSC和VLR是合在一起的，HLR/Auc是合在一起的。
在GSM系统图中，只有手机和基站是无线传播的，其他设备都是线缆通信。需要注意的是，这个系统只能完成电话和短信，至于想上互联网，还得升级下才行。那么这个系统如何实现通信的呢。实现通信，又有四个核心问题，广播，寻呼，切换，鉴权与加密。这四个概念在WCDMA、TD-SCDMA、cdma2000以及LTE都是适用的。说的通俗点，就是制订一套通信流程和通信协议，实现电话和短信的需求。
3.1广播 从图上直观的就能看到，和手机直接产生通信的，是各个基站。那为什么要这么多基站呢。这就是上面提到的空分概念，频谱资源有限，一个基站不够大家使用。所以每个基站负责一小块区域，各个基站都是用相同的频率范围，但是互不干扰。GSM系统相邻的两个基站使用的其实是不同的频率，依次错开的，能更好的防止干扰，这个干扰指的是基站和基站之间的干扰。
手机打电话时，首先需要知道自己在哪个基站下，这样才好和所处的基站通信。而手机是如何实时知道自己所处的基站呢，这就是通过广播来实现的。基站会一直广播一些身份信息，手机也会一直接收这样的信息，从而早知道自己处于哪一个基站之下。
基站广播的内容有基站的标识，空中接口的结构参数（频率，位置区等参数）。虽然一个区域由一个基站负责，但这是理想状态，实际情况两个基站之间肯定有信号相交区的。这时候手机会根据广播信号找到信号最好的基站去通信。
3.2寻呼 广播是手机去寻找自己所处的基站，寻呼是基站去找手机。手机拨号后，告诉所处的基站找谁进行通信，可是基站这么多，用户也那么多，怎么去找对端手机呢。
GSM是将一个城市的无线网络划成若干个位置区，并分位置区广播自己的位置区消息。 手机通过侦听广播信息得知自己所在的位置区，如果发现自己的位置区发生了变化，则主动 联系无线网络，上报自己所在的位置。系统收到手机发来的位置变更消息后，就把它记载在 数据库里，这个数据库就是图中的位置寄存器。等通信系统收需要对该手机的请求时，就首先查找位置寄存器，确定手机当前所处的位置区，再将被叫的请求发送到该位置区的所有基 站，由这些基站对手机进行寻呼。
在图中，有一个归属位置寄存器，HLR，这个设备是在运营商的核心网中。运营商给每个用户开卡时，会分配一个电话号码和一个IMSI号。
静态信息是不变的，但是动态信息怎么获取呢。就是上面说的寻呼，当手机通过广播发现自己的位置改变了，就会主动上报给本地MSC，本地MSC会通知开户的MSC更改信息。
图中，还有一个拜访位置寄存器，这个设备是存储用户具体在哪一个BSC下的。
用户拨号时，首先根据号码去判断这个号码的是那个地方的，从而去寻找所属地的HLR，在从中获取HLR，这样就能知道当前对方所在地。
我们的手机号码也不是随便编的，我们的手机号码叫做移动台的国际ISDN号码。
MSISDN = CC + NDC + SN
CC代表国家码，比如中国的是86.
NDC代表国内目的地码，就是平时号码的前三位。中国移动134139,150152,157~159。我们经常用的天通号码是174。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d681d5030e3e3ef082c5cca28ec69bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3034fbca998769b5e73c965aa3ec6b/" rel="bookmark">
			属于程序猿的浪漫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中华儿女的七夕节，还是单身的小伙伴赶紧拿着代码表白试试，不是单身的小伙伴可以给女朋友一个不一样的惊喜哦~！
废话不多说 看图！
可以自行根据注释修改参数哦！
代码
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; &lt;html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;给你的一封信&lt;/title&gt;	&lt;link type="text/css" rel="stylesheet" href="./file/default.css"&gt; &lt;script type="text/javascript" src="./file/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./file/jscex.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./file/jscex-parser.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./file/jscex-jit.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./file/jscex-builderbase.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./file/jscex-async.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./file/jscex-async-powerpack.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./file/functions.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./file/love.js" charset="utf-8"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div id="error"&gt;本页面采用HTML5编辑，目前您的浏览器无法显示，请换成谷歌(&lt;a href="http://www.google.cn/chrome/intl/zh-CN/landing_chrome.html?hl=zh-CN&amp;brand=CHMI"&gt;Chrome&lt;/a&gt;)或者火狐(&lt;a href="http://firefox.com.cn/download/"&gt;Firefox&lt;/a&gt;)浏览器，或者其他游览器的最新版本。&lt;/div&gt; &lt;div id="wrap"&gt; &lt;div id="text"&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a3034fbca998769b5e73c965aa3ec6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89473a39296e839e6483ecd20e35aa56/" rel="bookmark">
			CentOS 7 离线安装Python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7 离线安装Python 一 安装准备1.1 依赖下载1.2 删除CentOS 7自带的Python2软链接1.3 上传解压 二 安装2.1 安装编译Python所需的依赖2.1.1 gcc2.1.2 zlib2.1.3 bzip22.1.4 openssl2.1.5 ncurses2.1.6 sqlite2.1.7 readline2.1.8 tk(需要有tcl)2.1.9 libffi2.1.10 git 2.2 安装Python2.3 配置软链接2.4 验证是否安装成功 三 更改受影响配置 一 安装准备 1.1 依赖下载 Python 3.9.9 官网下载地址
1.2 删除CentOS 7自带的Python2软链接 cd /usr/bin rm python 1.3 上传解压 # 先创建文件夹 mkdir /usr/local/python3 cd /usr/local/python3 # 上传python安装包到此目录下,解压 tar -xvJf Python-3.6.6.tar.xz 二 安装 2.1 安装编译Python所需的依赖 2.1.1 gcc CentOS 7 gcc下载地址,下载图中gcc所示需要的依赖
# 1 依赖列表 cpp-4.8.5-39.el7.x86_64.rpm gcc-4.8.5-39.el7.x86_64.rpm glibc-devel-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89473a39296e839e6483ecd20e35aa56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c789a9612be1f95e2a4057fd93879048/" rel="bookmark">
			【Vue项目复习笔记】商品数据的展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、商品数据的请求
要展示商品数据，我们最先要做的就是要先把数据请求下来
因为我们的TabControl中有三个数据，所以我们请求数据的时候也分为三大类
保存商品的数据结构：
goods:{流行[]/新款[]/精选[]}它对应的每一个都是数组，每一个数组可能保存30条，60条，90条等，它会有上拉加载更多，到时候保存的数据量是不一样的。还会出现，我流行的数据已经加载到第8页，新款加载到第5页，而精选也才加载到第三页的情况，这时，我们就需要设计数据结构了
goods:{ 'pop':{page: 1,list:[]},//默认page是第一页，流行对应的pop里的数据都存放在list里面，page是用来记录我当前加载数据，加载到第几页 'news':{page: 1,list:[]}, 'sell':{page: 1,list:[]} 在data中
goods: { 'pop':{page:0,list:[]}, 'new':{page:0,list:[]}, 'sell':{page:0,list:[]}, }, 先请求数据：在home.js中
export function getHomeGoods(type, page) { return request({ url: "/home/data", params: { type, page, }, }); } 导入到Home.vue中
import {getHomeMultidata,getHomeGoods} from '@/network/home'; 什么时候发送请求呢？我们可以在我们的组件创建之后就立即发送请求，所以我们在created中
created(){ //请求商品的多个数据 this.getHomeGoods('pop') this.getHomeGoods('new') this.getHomeGoods('sell') } 但是此时created()里面放的东西太多了，我们此时再抽取一层，存放主要逻辑，将这一抽取的内容放入到methods中，此时的代码就变成了
created() { //组件创建完以后，赶紧发送网络请求，请求多个数据 // create里面的this就是我们当前的组件对象 this.getHomeMultidata() //网络请求相关(请求商品数据) this.getHomeGoods('pop') this.getHomeGoods('new') this.getHomeGoods('sell') }, methods: { getHomeMultidata() { getHomeMultidata().then(res =&gt; { // console.log(res); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c789a9612be1f95e2a4057fd93879048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d14962dcffb574844a13adb3b5a964/" rel="bookmark">
			html&#43;css&#43;jQuery写的选择题答题页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免费分享：百度云盘
链接：https://pan.baidu.com/s/1WfDYP9ModMCiFpYDfMNdag?pwd=zg00 提取码：zg00
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8543486158dcaa93589308d1fffcfc77/" rel="bookmark">
			【Java】节点流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		节点流 文件节点流 FileInputStream和FileOutputStream是文件字节流，是一种节点流
文件字节输入流的构造方法：
FileInputStream(“文件名称”)，如果文件不存在则FileNotFoundExceptionFileInputStream(File)
文件字节输出流的构造方法:FileOutputStream(“文件名称”) 如果文件不存在则新建文件，如果文件存在则覆盖文件内容FileOutputStream(String name文件名称, boolean append是否采用追加方式)
FileReader和FileWriter类似 FileInputStream和FileOutputStream两个类属于结点流，第一个类的源端和第二个类的目的端都是磁盘文件，它们的构造方法允许通过文件的路径名来构造相应的流。
如：
FileInputStream infile = new FileInputStream(“myfile.dat”);
FileOutputStream outfile = new FileOutputStream(“results.dat”);
要注意的是，构造FileInputStream, 对应的文件必须存在并且是可读的，而构造FileOutputStream时，如输出文件已存在，则必须是可覆盖的。
要求：将d盘上的TestFile.java拷贝到e盘，并命名为dd.txt
try (InputStream is = new FileInputStream("d:/TestFile.java"); OutputStream os=new FileOutputStream("e:\\dd.txt"); ) { byte[] buffer=new byte[8192]; int len=is.read(buffer); while(len&gt;0){ os.write(buffer,0,len); len=is.read(buffer); } }catch(IOException e){ e.printStackTrace(); } 构造输出文件流时可以使用两种不同的方式 OutputStream os=new FileOutputStream("e:\\dd.txt"); 如果文件不存在则自动创建；如 果文件存在则进行覆盖 OutputStream os=new FileOutputStream("e:\\dd.txt",true),这里的boolean类型参数 表示是否采用追加的方式写入文件 需求1：拷贝c:\windows到d:\ddd文件夹
需求2：设计程序将aa.java和bb.java两个文件合并成一个文件，命名为cc.txt。
需求3：设计程序将cc.txt按尺寸等分拆分成两个文件c1.txt和c2.txt。
内存数组节点 如果文本则使用char[]，如果二进制则使用byte[]
构造器方法
CharArrayReader(char[] buf)其中char[]就是数据的来源，也就是说Reader就是从char[]中读取数据CharArrayRead(char[] buf, int offset, int length)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8543486158dcaa93589308d1fffcfc77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5db5523312ebbbee59ca0038012c239/" rel="bookmark">
			python setup.py install安装setuptools，pip踩坑记录（下载，配置环境变量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因：pip升级报错
F:\F_software\Anaconda\python.exe -m pip install --upgrade pip
错误：
ValueError: Unable to find resource t64.exe in package pip._vendor.distlib
如下图：
之后卸载 setuptools
python -m pip uninstall pip setuptools 准备升级 setuptools
pip install --upgrade setuptools
发现报错了：
之后打算安装setuptools和pip，借鉴了PYTHON2.7安装SETUPTOOLS和PIP及卸载
注意如果提示："xxx"不是内部或外部命令，也不是可运行的程序 或批处理文件，就去检查环境变量path是否配置了Python
下载链接：https://pypi.org/project/setuptools/
解压后发现输入python setup.py install没反应，借鉴了手动安装pip,输入python setup.py install没反应解决方法
这才意识到应该配置环境变量（可看：python环境变量如何配置），最后成功安装setuptools 63.2.0（注意setuptools 63.2.0这个文件本身也要在环境变量里）
开始下载：
下载完成后
用相同的方法安装pip
下载链接：https://pypi.org/project/pip/#files
开始下载：
下载完成后：
这样就可以了
最后简述一下python setup.py install的过程：
python setup.py install是我们用来安装下载的python包或者自己按照python官方规范开发的扩展包的常用指令。
通过这个命令，这个python包就会被安装系统或者你指定用户的python库里
python setup.py install包括两步：
python setup.py build
python setup.py install
这两步，可分开执行， 也可只执行python setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5db5523312ebbbee59ca0038012c239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9ab7ca0c44c7d283dc5660d2f52abf3/" rel="bookmark">
			uni-app 之生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用的生命周期
onlaunch 当uni-app初始化完成时触发
onshow 当uni-app启动时
onhide 当uni-app进入后台时
onerror 当uni-app报错时
onUniNViewMessage 对 nvue 页面发送的数据进行监听
onUnhandledRejection 对未处理的 Promise 拒绝事件监听函数
onPageNotFound页面不存在监听函数
onThemeChange监听系统主题变化
页面的生命周期
oninit 监听页面初始化
onload 监听页面加载
onshow 监听页面显示
onready 监听页面初次渲染完成
onhide 监听页面隐藏
onunload 监听页面卸载
onresize 监听窗口尺寸变化
onPullDownRefresh 下拉刷新
onReachBottom 触底加载更多
onTabItemTap 点击tab时触发
onShareAppMessage 分享
onPageScroll 监听页面滚动
组件的生命周期 （和vue一样）
beforecreate created beforemount mounted beforeupdate updated beforedestroy destroyed
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9c5adca13fd16cb9009b452d74abb3/" rel="bookmark">
			TCP和UDP的C/S模型的Socket编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是文章出处地址的超链接 感谢作者传授知识 Socket定义
是对网络的不同主机上的应用进程之间进行双向通信的端点的抽象，一个套接字就是一个网络端口应用程序使用网络协议进行通信的接口 组成部分
TCP/IP协议IP地址：网络中不同计算机的通信地址端口：区分主机的不同应用程序，客户端在49152 ~ 65535中动态选择端口号，服务器使用0 ~ 49151
套接字Socket = （主机IP地址， 端口号） 两种通信方式
TCP是可靠地面向连接的通信过程，含有三次握手四次挥手的机制。UDP是不可靠的无连接的通信过程，客户端只管发，不管服务端有没有接受到 实现步骤：
创建Server和client的ServerSocket和Socket。打开链接到Socket的输入输出流按照协议对Socket进行读取操作关闭输入输出流、关闭Socket。 1、基于TCP的socket通信
我们拿男孩做客户端，女孩因为有很多人追求，所以做服务端，一个服务端可被多个男孩客户端请求表白。我们这里先看女孩服务端的具体步骤：
（1）创建ServerSocket对象，绑定监听端口。
（2）通过accept()方法监听客户端请求
（3）连接建立后，通过输入流读取客户端的数据
（4）通过输出流，向客户端回应信息
OK，基本的步骤就是这，我们就看一下代码。
具体的步骤已经很清晰了，我们再来看看男孩客户端的步骤：
（1）创建Socket并指定端口
（2）通过输出流向服务端发送一个请求
（3）等待服务端的回应 获取输入流，读取客户端信息(将字节流转化为字符流)，并保存在缓冲区中
（4）关闭资源
下面同样使用java代码来演示一下。
这就是男孩追求女孩的代码示例，说起来也很简单。如果我们之前学习过socket编程，可能上述的这些代码难不倒我们，不过如果从基础开始入门学习，还是有必要对其两个类进行说明一下。高手可跳过：
第一个：Socket
当我们想要在Java中使用TCP/IP通过网络连接到服务器时，就需要创建Socket对象并连接到服务器。在服务端的Socket对应着连接的一个个客户端。
第二个：ServerSocket
用ServerSocket实现java服务通过TCP/IP监听客户端连接，他只存在于服务端。
2、基于UDP的Socket通信
UDP的通信模式其实是无连接的不可靠的通信协议，举个例子，花心男孩向女孩表白，就给女孩写了一封情书，然后不管女孩有没有收到情书，自己继续向其他女孩表白。我们这里还是以女孩为服务端。
我们首先来看一下服务端的步骤：
接收客户端发送的数据
（1）创建服务器端DatagramSocket指定端口
（2）创建数据报DatagramPacket，接收客户端发送的数据
（3）接收客户端发送的数据
（4）读取数据
向客户端响应数据
（1）定义客户端的地址、端口号、数据
（2）创建数据报，包含响应的数据信息
（3）响应客户端
（4）关闭资源
具体代码来演示一下。
然后再来看一下客户端的请求：
向服务器端发送数据
（1）定义服务器的地址、端口号、数据
（2）创建数据报，包含发送的数据信息
（3）创建DatagramSocket对象
（4）向服务器端发送数据报
接收服务器端响应的数据
（1）创建数据报DatagramPacket，用于接收服务器端响应的数据
（2）接收服务器响应的数据
（3）读取数据
（4）关闭资源
我们再使用java语言来演示一下客户端代码
OK，以上就是socket通信的两种基本方式，这里只是给出了一个最最简单的例子演示，这也是最基础的代码，后续文章会继续加深难度。我们现在来总结一下这个Socket通信
从上面我们可以看到Java提供了非常易用的网络API，调用这些API我们可以很方便的通过建立TCP/IP或UDP套接字，在网络之间进行相互通信，但是其中TCP要比UDP更加常用。但是在一些场景下面。使用无连接的UDP要优于TCP。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/140/">«</a>
	<span class="pagination__item pagination__item--current">141/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/142/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>