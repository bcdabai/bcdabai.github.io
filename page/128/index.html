<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7451b142c80eaa586abf41230ac79f/" rel="bookmark">
			DM-DM DBLINK使用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单介绍 DM-DM DBLINK支持3种连接方式创建，分别是：dmmal、dpi、odbc。
其中dpi、odbc属于第三方接口，dmmal属于原生接口。dpi类型dblink为新版本新添加支持，以前版本中不支持。
环境说明 （1）数据库版本：
DM Database Server 64 V8
DB Version: 0x7000c
03134283904-20220714-165042-20005
（2）数据库信息
本地：端口 5236，实例名DMSERVER01，字符集GB18030
远端：端口 5237，实例名DMSERVER02，字符集GB18030
（3）已配置LD_LIBRARY_PATH环境变量
echo /usr/local/lib &gt; /etc/ld.so.conf.d/libodbc.conf echo /home/dmdba/dm128/bin &gt; /etc/ld.so.conf.d/dm8.conf ldconfig 使用配置 dmmal方式 dmmal类型dblink，需要两端数据库设置dm.ini参数MAL_INI=1，并配置相同的dmmal.ini文件，重启数据库服务生效。
创建语法：
---方式1 ---mal_inst_host/mal_inst_port create link "链接名" connect 'DAMENG' with "用户名" identified by "密码" using '实例IP地址/实例端口号'; ---方式2 ---mal_host/mal_port create link "链接名" connect 'DAMENG' with "用户名" identified by "密码" using 'MAL IP地址/MAL 端口号'; ---方式3 ---mal_inst_name create link "链接名" connect 'DAMENG' with "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7451b142c80eaa586abf41230ac79f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cdfa5b976b80704b64ca5b54705d5b2/" rel="bookmark">
			使用mybatis-plus批量插入遇到的两个问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近应用系统适配时，使用mybatis plus遇到的两个问题记录。
环境说明 Mybatisplus：3.1.1
DM数据库：DM V8 03134283890-20220518-160920-10045
DM数据库兼容性参数设置：COMPATIBLE_MODE=4
问题1：使用mybatis-plus批量插入保存报错 报错信息：
Java.lang.RuntimeException：index out of range
解决办法：
当前程序使用DmJdbc驱动包版本比较旧（8.1.1.49），更换为较新版本（2021年下半年以后的驱动包版本）解决。
问题2：使用mybatis-plus批量插入报错“月份必须介于1和12之间”和“字符串截断” 该问题在问题1处理之后出现。根据应用后台打印输出发现批量插入的数据并没有问题，但是后台会出现下面两个报错。
两个报错信息：
“月份必须介于1和12之间”
“字符串截断”
原因排查：
使用同一套代码连接另外的数据库实例（该数据库实例初始化参数、表对象等均相同）执行上述操作正常。通过比对dm.ini参数文件，发现执行报错环境数据库dm.ini参数文件中BATCH_PARAM_OPT=1，而执行正常的环境数据库dm.ini中该参数为0(默认值)。修改BATCH_PARAM_OPT参数为0后执行正常。
解决办法：
修改数据库dm.ini参数BATCH_PARAM_OPT=0
（1）SP_SET_PARA_VALUE(2,’BATCH_PARAM_OPT’,0);
（2）重启数据库服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2832f5a82eba2c7823b56174c43a9fe6/" rel="bookmark">
			深度学习中的backbone、head、neck等名词解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		backbone： 翻译为主干网络，大多时候指的是提取特征的网络，其作用就是提取图片中的信息，供后面的网络使用。
这些网络经常使用的是resnet、VGG等，而不是我们自己设计的网络，因为这些网络已经证明了在分类等问题上的特征提取能力是很强的。在用这些网络作为backbone的时候，都是直接加载官方已经训练好的模型参数，后面接着我们自己的网络。让网络的这两个部分同时进行训练，因为加载的backbone模型已经具有提取特征的能力了，在我们的训练过程中，会对他进行微调，使得其更适合于我们自己的任务。
head： head是获取网络输出内容的网络，利用之前提取的特征，head利用这些特征，做出预测。
neck: 是放在backbone和head之间的，是为了更好的利用backbone提取的特征。
bottleneck: 瓶颈的意思，通常指的是网网络输入的数据维度和输出的维度不同，输出的维度比输入的小了许多，就像脖子一样，变细了。经常设置的参数 bottle_num=256，指的是网络输出的数据的维度是256 ，可是输入进来的可能是1024维度的。
GAP： 在设计的网络中经常能够看到gap这个层，即Global Average Pool全局平均池化，就是将某个通道的特征取平均值，经常使用AdaptativeAvgpoold(1),在pytorch中，这个代表自适应性全局平均池化，即将某个通道的特征取平均值。
self.gap = nn.AdaptiveAvgPool2d(1) Embedding: 深度学习方法都是利用使用线性和非线性转换对复杂的数据进行自动特征抽取，并将特征表示为“向量”（vector），这一过程一般也称为“嵌入”（embedding）
pretext task和downstream task： 用于预训练的任务被称为前置/代理任务(pretext task)，用于微调的任务被称为下游任务(downstream task)
temperature parameters 在论文中经常能看到这个温度参数的身影，那么他都有什么用处呢？比如经常看到下面这样的式子：
里面的beta就是temperature parameter，起到平滑softmax输出结果的作用，举例子如下：
import torch x = torch.tensor([1.0,2.0,3.0]) y = torch.softmax(x,0) print(y) x1 = x / 2 # beta 为2 y = torch.softmax(x1,0) print(y) x2 = x/0.5 # beta 为0.5 y = torch.softmax(x2,0) print(y) 输出结果如下：
tensor([0.0900, 0.2447, 0.6652]) tensor([0.1863, 0.3072, 0.5065]) tensor([0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2832f5a82eba2c7823b56174c43a9fe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210d30f12cbd994067aabc55da975c69/" rel="bookmark">
			如何清除（登录）缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何清除（登录）缓存
1、进入开发者调试框，点击Application,依次右击clean如图标识：Local Storage、Session Storage、Cookies。clean清除完之后，刷新页面，则之前的数据就被清除了。
谢谢！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f82fc4e09fa8ac7c0bb3eff41dd5b75/" rel="bookmark">
			前端如何开发一个简单nodejs服务器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步： npm install -y 是用npm初始化一下项目
第二步： npm i koa koa-static 下载这个插件
第三步： 将你的前端项目打包后生成的文件夹，复制到当前项目中的根目录下
第四步：上代码 // 开发一个nodejs服务器 // 可以提供页面服务, 支撑打包后的 dist 文件代码 // 引入库 const Koa = require("koa"); const serve = require("koa-static"); const { historyApiFallback } = require("koa2-connect-history-api-fallback"); const proxy = require("koa2-proxy-middleware"); // 创建服务器实例 const app = new Koa(); // 在创建实例之后, 提供页面服务之前 // 处理 history 模式带来的刷新问题 app.use(historyApiFallback()); // 处理生产环境请求转发的问题 也就是跨域的问题（根据自己项目实际情况来看） app.use( proxy({ targets: { // 这里面可以放规则对象 "/prod-api/(.*)": { target: "http://xxx.xxx.xxx", changeOrigin: true, // 我们配对的是 prod-api 这是生产环境变量配置导致的 // 但是服务器不一定认这个请求, 服务器认 /api pathRewrite: { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f82fc4e09fa8ac7c0bb3eff41dd5b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4595a34afc6d400e54a187bca538a98/" rel="bookmark">
			SpringSecurity-从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringSecurity从入门到精通 课程介绍 0. 简介 ​ Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。
​ 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。
​ 一般Web应用的需要进行认证和授权。
​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户
​ 授权：经过认证后判断当前用户是否有权限进行某个操作
​ 而认证和授权也是SpringSecurity作为安全框架的核心功能。
1. 快速入门 1.1 准备工作 ​ 我们先要搭建一个简单的SpringBoot工程
① 设置父工程 添加依赖
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ② 创建启动类
@SpringBootApplication public class SecurityApplication { public static void main(String[] args) { SpringApplication.run(SecurityApplication.class,args); } } ③ 创建Controller
import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4595a34afc6d400e54a187bca538a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b31fe6bf93c01ecfe8a18d35191b30/" rel="bookmark">
			el-table 树类型的表格数据和右侧内容切换，点击父节点会折叠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element ui 里面有支持树类型的表格数据展示，
我想要实现的效果如图，所示：
既可以展示树形数据，有父节点和子节点，点击子节点后可以切换右侧内容，并展示子节点的详细数据，点击父节点，会折叠收起。整体效果是如编辑器里的文件夹一样。上图只是一个演示，凑合看啦。
目录
效果展示：
1.html
2.js
3.css 效果展示： 真正实现的如下图所示，用的是Vue3里的element组件
1.html 这个部分有两个结构组成左侧的树形表格和右侧的表单
&lt;template&gt; &lt;div class="record"&gt; &lt;div class="record-tree"&gt; &lt;el-table :data="treeData" border size="medium" default-expand-all highlight-current-row :props="defaultProps" :row-key="getRowKeys"// 重要 style="width: 95%" :tree-props="{ children: 'children', hasChildren: 'hasChildren' }" //树形结构 @row-click="clickTable" ref="treeTable" //重要 &gt; &lt;el-table-column prop="label" :label="title"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;div class="record-from"&gt; &lt;formPage v-if="allTableCol.length &gt; 0" :title="title2" :table-col="allTableCol" :table-data="allTableDate" :label="label" :table-id="tableId" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 2.js 首先就是数据，我模拟的数据如下：
this.treeData = [ { GROUP_VALUE: '肿瘤科 2022-10-15', children: [], id: 1, label: '肿瘤科 2022-10-15' }, { GROUP_VALUE: '消化内科 2022-10-08', children: [ { EXTERNAL_KEY: 'VISIT_ID', EXTERNAL_KEY_VALUE: 'VI26A0BE26F96C', EXTERNAL_TABLE: 'TMED_MR_CLINIC_VISIT_RECORD', RECORD_TITLE: '门诊记录单', id: 202, label: '门诊记录单 2022-10-08' } ], id: 2, label: '消化内科 2022-10-08' }, { GROUP_VALUE: '泌尿科 2022-10-05', children: [], id: 3, label: '泌尿科 2022-10-05' }, { GROUP_VALUE: '急诊内科 2022-10-05', children: [ { EXTERNAL_KEY: 'VISIT_ID', EXTERNAL_KEY_VALUE: 'VID31B0DFA222C', EXTERNAL_TABLE: 'TMED_MR_CLINIC_VISIT_RECORD', RECORD_TITLE: '门诊记录单', id: 144, label: '门诊记录单 2022-10-08' } ], id: 4, label: '急诊内科 2022-10-08' } ] 获取数据之后，点击左侧的树形结构的表格时有个点击事件，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b31fe6bf93c01ecfe8a18d35191b30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87724efa6c6be8c002d656750caaa316/" rel="bookmark">
			git与gitee指南详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文作为git入门指南，比较详细的介绍了git的使用，帮助读者可以更快的上手git,文章采用大白话形式，方便理解，文中若有不恰当或者可以改进的地方请与我进行联系或者在下面留言。感谢大家的信赖！
1.git基础 git是什么？ Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。
下载地址 点击这里下载Git 注：一直点击默认配置即可
后续的操作都用git bash here
点击进入。输入命令git -v查看版本信息
出现对应的版本信息，就说明安装成功了
工作流程 git仓库暂存区工作目录用于存放提交记录临时存放被修改文件被Git管理的项目目录 这里做一下简要说明，方便大家理解：
git仓库：可以理解为本地仓库，当你本地代码确定无误之后就可以上传到git仓库中，可以理解为代码的最终提交场所。
暂存区：设想一下如果你想加一个新功能，但是又怕功能没加成功，之前的代码还不能运行，为了防止这种情况你是不是会备份当前的文件，暂存区就是这个功能，可以暂时存储当前状态的代码，当你需要可以恢复到任意时刻之前的状态。
工作目录：当你使用git init进行初始化后，当前目录就处于git托管状态，当前的所有文件就处在工作目录下。
方便理解：可以这样比喻，第一步先在工作目录编辑文件，第二步上传到暂存区，第三步确认无误提交到git仓库。
git使用 当你第一使用git需要对git进行配置，告诉git你的名字还有你的邮箱。配置命令如下：
配置提交人姓名：git config --global user.name 提交人姓名配置提交人邮箱：git config --global user.email 提交人邮箱查看配置信息是否正确：git config user.name / git config user.email 注意：
1.只需要配置一次，以后不再需要配置
2.若发现配置信息出错，重复使用1和2进行配置即可
提交步骤 step1. git初始化：git init
step2.查看文件状态：git status
step3:提交到暂存区:git add 文件名
step4:提交到git仓库：git commit -m 提交注释
step5:查看提交记录：git log
这里也做一下解释，方便理解：
首先切记首先要进行git初始化，如果不进行初始化，后续操作都会报错。查看文件状态是为了查看当前有哪些文件没有被git管理。git commit -m 后面的注释一般会写第几次提交。
撤销 用暂存区中的文件覆盖工作目录中的文件： git checkout 文件
将文件从暂存区中删除： git rm --cached 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87724efa6c6be8c002d656750caaa316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e28dc532ec9bd3fefe8ad73a3f90cfc/" rel="bookmark">
			Linux设置静态IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux设置静态IP 使用ip addr查看ip，如下所示就是动态IP
1、什么是静态IP？ 静态ip就是固定的ip，需要手动设置。静态IP地址（又称固定IP地址）是长期分配给一台计算机或网络设备使用的 IP 地址。一般来说，一般是特殊的服务器或者采用专线上网的计算机才拥有固定的 IP 地址而且需要比较昂贵的费用。静态IP是二级路由必须用到的。静态IP是可以直接上网的IP段，该IP在ISP装机时会划分一个IP地址给你，让盘算机在衔接网络时不再主动获取网络地址，避免了网络衔接上的困扰，宽带运营商会供给一根一个IP地址、子网掩码、网关和DNS服务器地址给用户。在未应用路由器的情形下，只须要把这根入户网线衔接到电脑上，并且手动设置电脑上的IP地址，这样电脑能力上网。静态IP地址不会转变，并且重要用于互联网上的网站运用或服务。
2、静态IP的优点 由于静态IP的IP地址不会改变，故而其稳定性极高。
大家都知道，像我们访问网站，一般都是在浏览器中输入域名回车就行了。浏览器其实之所以能找到此网站的服务器是因为有一个域名解析系统将网站的域名和网站服务器的IP进行了绑定，通过域名就能找到服务器IP进而访问它。如果IP地址变化了，那我们就需要重新解析了，在解析没有成功之前，你的网站是无法访问的，这就会造成用户的体验感很差，而且每次操作都比较麻烦。
3、Linux设置静态IP 1.设置网络 命令： vi /etc/sysconfig/network-scripts/ifcfg-ens33
代码：
TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static # 设置为静态IP DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=eeac2fc2-e829-43a4-8349-8e0fc5ba628d DEVICE=ens33 ONBOOT=yes ZONE=public IPADDR=192.168.181.128 # 静态IP NETMASK=255.255.255.0 # 子网掩码 GATEWAY=192.168.181.100 # 网关 DNS=8.8.8.8 # DNS服务器 2.重启网络 命令：systemctl restart network 3.使用 ip addr 查看IP 可以看到我们的ip已经变成静态IP了，并且也是我们刚才设置的静态IP，此时我们的IP还不能使用，我们还需要进行下一步操作。
4.设置虚拟网络编辑器 在vmware 中： 编辑——虚拟网络编辑器——NAT模式——NAT设置——网关
设置子网IP
设置网关IP 重启网络 命令：systemctl restart network 使用 ip addr 查看IP 5、使用Xshell工具连接Linux 至此我们的静态ip地址就设置成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403879c15039fec332e95b9ecacb9274/" rel="bookmark">
			图像重映射算法浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者|三井寿 编辑|3D视觉开发者社区
在CV领域，常常会涉及到图像的重映射操作，典型应用场景为：
已知某个相机的内参和几何畸变模型，需要对其采集到的实际图片进行去畸变处理，从而恢复图像中的几何信息；双目视觉系统经过标定后，需对图片进行变换，实现极线对齐，从而支持沿图像X方向的一维匹配操作。 为了方便描述，我们在接下来的说明部分以图像去畸变为例，向大家介绍如何实现高效的实现图像重映射。
基于pinhole camera model和central projection，我们可以通过下面公式描述相机对三维点成像的过程：
x − i ∼ K ∗ ∗ L ( [ R ∣ t ] ∗ X − w / d ) \mathrm{x}_{-} \mathrm{i} \sim \mathrm{K}^{*}{ }^{*} \mathrm{~L}\left([\mathrm{R} \mid \mathrm{t}]{ }^{*} \mathrm{X}_{-} \mathrm{w} / \mathrm{d}\right) x−​i∼K∗∗ L([R∣t]∗X−​w/d)
其中：
X_w 为三维点在世界坐标系中的位置，而且为了方便运算，我们使用homogeneous coordinates来表达 X_w，这样 X_w 是一个4 x 1的列向量，且最后一个元素值等于1；R 和 t 分别是3 x 3旋转矩阵和3 x 1平移向量，用来将三维点从世界坐标系转到相机坐标系下；标量 d 是三维点在相机坐标系下的深度，即三维点在相机坐标系Z轴上的位置。通过除以深度 d，[R|t] * X_w / d
的结果是一个3 x 1的向量，且最后一个元素值等于1，这就是我们通常所说的normalized camera coordinates，即归一化相机坐标系下的点坐标；L()描述的是相机几何畸变模型，也就是我们通常所说的畸变模型。由此可以看出，畸变模型是定义在归一化相机坐标系下的，即畸变会改变视线方向。这会导致三维点在图像上的投影点，偏离由三维点与相机中心所定义的直线。因此也就无法由投影点与相机中心回溯三维点所在的真正方位。K 是相机的3 x 3内参矩阵，一般包含用像素值所表达的镜头焦距：如果考虑X和Y方向像素尺寸的非一致性，用 f_x 和 f_y 分别表示镜头焦距在X和Y方向的像素值；此外还包含 principal point，即图像主点在图像坐标系下的位置；如果考虑像素倾斜，还会再额外包含 skewness；x_i 是三维点在图像上投影点的位置，为了方便运算，同样使用homogeneous coordiantes来进行表达。在射影几何中，我们一般不关心实体的缩放，即 x_i 和 x_i 乘以某个系数 c为等效实体，因此我们用相似性符号 ~ 来表达，x_i 和 K * L([R|t] * X_w / d) 仅区别于某个特定系数这一事实。 在去畸变时，我们需要从 x_i 中恢复出无畸变坐标 x’_i：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/403879c15039fec332e95b9ecacb9274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65089a897634a4e08a74f5481dc0c354/" rel="bookmark">
			javascript基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript基础知识 参考自：网址
1 JS的调用方式与执行顺序 1.1 使用方式 HTML页面中的任意位置加上&lt;script type="module"&gt;&lt;/script&gt;标签即可。
常见使用方式有以下几种：
直接在&lt;script type="module"&gt;&lt;/script&gt;标签内写JS代码。
直接引入文件：&lt;script type="module" src="/static/js/index.js"&gt;&lt;/script&gt;。
将所需的代码通过import关键字引入到当前作用域。
例如：
/static/js/index.js文件中的内容为：
let name = "acwing"; function print() { console.log("Hello World!"); } export { name, print } &lt;script type="module"&gt;&lt;/script&gt;中的内容为：
&lt;script type="module"&gt; import { name, print } from "/static/js/index.js"; console.log(name); print(); &lt;/script&gt; 1.2 执行顺序 类似于HTML与CSS，按从上到下的顺序执行；
事件驱动执行；
1.3 HTML, CSS, JavaScript三者之间的关系 CSS控制HTML
JavaScript控制HTML与CSS
为了方便开发与维护，尽量按照上述顺序写代码。例如：不要在HTML中调用JavaScript中的函数。
2 变量与运算符 2.1 let与const 用来声明变量，作用范围为当前作用域。
let用来定义变量；
const用来定义常量；
例如：
let s = "acwing", x = 5; let d = { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65089a897634a4e08a74f5481dc0c354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3287997306cf171b7c822cf7db7c914c/" rel="bookmark">
			Java 实现替换文本某处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.背景介绍 有时候在实际开发的过程需要只替换整个文件的某处，我这里实现的方法是替换内容输出另一个新文件。
2.需要的依赖 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.0.M2&lt;/version&gt; &lt;/dependency&gt; 3.代码实现 //sourcePath 要替换的文件路径 newPath 生成的新文件路径 public static void repale(String sourcePath,String newPath){ File file = new File(sourcePath); String s1="要替换的字符串"; String s2="新的字符串"; List&lt;String&gt; strings = FileUtil.readLines(file, CharsetUtil.CHARSET_UTF_8); List&lt;String&gt; contonts=new ArrayList&lt;&gt;(); for (String s : strings) { if (s1.equals(s.trim())){ contonts.add(s2); }else { contonts.add(s); } } FileUtil.writeLines(contonts,newPath,CharsetUtil.CHARSET_UTF_8); } //方法测试 public static void main(String[] args) { String path="C:\\Users\\Administrator\\Desktop\\maoming\\area\\test.text"; String path1="C:\\Users\\Administrator\\Desktop\\maoming\\area\\test1.text"; repale(path,path1): } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07bef2f2208dbe8f79996aadc6a0902c/" rel="bookmark">
			【最全】you-get和youtube-dl的安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、ffmpeg、you-get、youtube-dl简介二、ffmpeg、you-get、youtube-dl安装2.1 安装2.2 配置 三、you-get使用四、youtube-dl使用4.1 常用选项● 获取视频格式列表●下载指定格式（format）视频●保存到指定位置 4.2 综合使用 五、附录：youtube-dl参数及说明5.1帮助内容原文：5.2帮助内容译文： 5.21常规选项 5.22网络选项 5.23地理区域限制 5.24视频选择 5.25下载选项 5.26文件系统选项 5.27缩略图选项 5.28 详细程度/模拟选项 5.29工作环境选项 5.30视频格式选项 5.31字幕选项 5.32身份验证选项 5.33Adobe 通行证选项 5.34后处理选项 一、ffmpeg、you-get、youtube-dl简介 直接在github上搜索这些项目也可以查看简介、下载等。
you-get:
You-Get 是一个小型命令行实用程序，用于从 Web 下载媒体内容（视频、音频、图像）。
youtube-dl:
youtube-dl 是一款基于 Python 的小型命令行工具，允许从 YouTube、Dailymotion、Google Video、Photobucket、Facebook、Yahoo、Metacafe、Depositfiles、Bilibili 和类似网站下载视频。 它是用 pygtk 编写的，需要 Python 解释器来运行，它不受平台限制，可以在任何 GNU/Linux、Windows 或 macOS 系统上运行。
youtube-dl 还允许选择特定的可用视频质量格式进行下载，或让程序本身自动从网站下载更高质量的视频。它还支持特定的播放列表下载，在下载的视频文件中添加自定义或原始标题的选项，并支持proxy等。
ffmpeg:
FFmpeg 是处理多媒体内容（例如音频、视频、字幕和相关元数据）的库和工具的集合。FFmpeg 是处理多媒体内容（例如音频、视频、字幕和相关元数据）的库和工具的集合。
在这里使用ffmpeg的原因是：you-get和youtube-dl下载的内容可能是音视频分开下载的（某些分辨率或者某些站点），用视频剪辑软件合并又要浪费一定的时间，而安装ffmpeg之后，则可以自动合并（merge）。
二、ffmpeg、you-get、youtube-dl安装 2.1 安装 直接在github上搜索，安装项目里面的说明下载安装。通常是使用pip或者conda来安装。下载exe版本，我已经放在我的仓库里面了（也可以github或者gitee上搜索下载）。 下载链接。
2.2 配置 配置很简单，添加到环境变量(Path)就可以了。
其中，ffmpeg不是单独的可执行文件，把文件夹中的bin文件夹添加到环境变量就可以了。
如下是我的设置：
配置好之后，在命令行即可使用对应命令：
三、you-get使用 详细的使用见文章：You-get &amp;&amp; FFmpeg，由于某种原因，翻译成英文才发布成功，不过不难读懂。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07bef2f2208dbe8f79996aadc6a0902c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7fe6625632cc189b75c2148c4bc91a2/" rel="bookmark">
			git submodule update --init --recursive失败的处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
1 clone事例
2 Failed to clone
3 假象clone的处理方法
4 网络问题
总结
前言 由于国内网络环境的影响，我们从 github clone 代码时，总是会出现 clone 失败的情况。当 clone失败时，我们怎么处理解决呢？以下总结了三种解决办法，仅供参考交流。
1 clone事例 这里，我以获取乐鑫提供的软件库文件 ESP-IDF 仓库。作为 clone 的事例，具体讲解当 clone 失败时，怎么解决问题。
获取 ESP-IDF 的本地副本：打开终端，切换到要保存 ESP-IDF 的工作目录，使用 git clone 命令克隆远程仓库。
打开终端，输入以下命令：
mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git ​
ESP-IDF 将下载至 ~/esp/esp-idf。
2 Failed to clone 受到网络环境的影响，代码一次性克隆成功，基本属于中彩票。经常会出现子模块 clone 失败的情况。即报错：Failed to clone...
这种问题，大多由于网络不稳定或者无法访问 github 子模块网络，我们首先多尝试 clone几次（说不定网络稳定一会儿，就能 clone 成功），具体步骤如下：
(1) 切换到 esp-idf 代码目录下；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7fe6625632cc189b75c2148c4bc91a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b6a1e3c02dbf7961c2920396d31bda/" rel="bookmark">
			数组元素的区间删除PTA（数据结构20分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个顺序存储的线性表，请设计一个函数删除所有值大于min而且小于max的元素。删除后表中剩余元素保持顺序存储，并且相对位置不能改变。
函数接口定义： int Delete( int A[], int L, int minA, int maxA ); 其中A是整型数组，存储原始线性表的元素；L是表长，即A中元素的个数；minA和maxA分别为待删除元素的值域的下、上界。函数Delete应将A中所有值大于minA而且小于maxA的元素删除，同时保证表中剩余元素保持顺序存储，并且相对位置不变，最后返回删除后的表长。
#include &lt;stdio.h&gt; #define MAXN 20 int Delete( int A[], int L, int minA, int maxA ); int main() { int A[MAXN], L, minA, maxA, i; scanf("%d", &amp;L); for (i=0; i&lt;L; i++) scanf("%d", &amp;A[i]); scanf("%d %d", &amp;minA, &amp;maxA); L = Delete(A, L, minA, maxA); for (i=0; i&lt;L; i++) printf("%d ", A[i]); printf("\n"); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： 10 4 -8 2 12 1 5 9 3 3 10 0 4 输出样例： 4 -8 12 5 9 10 代码实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b6a1e3c02dbf7961c2920396d31bda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2915c59770f2e617735fe504513dfc/" rel="bookmark">
			瑞吉外卖全方位总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.使用的技术栈 1). 用户层
本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI等技术。而在构建移动端应用时，我们会使用到微信小程序。
2). 网关层
Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现。
3). 应用层
SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开发。
Spring: 统一管理项目中的各种资源(bean), 在web开发的各层中都会用到。
SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成。
SpringSession: 主要解决在集群环境下的Session共享问题。
lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法。
Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。
4). 数据层
MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。
MybatisPlus： 本项目持久层将会使用MybatisPlus来简化开发, 基本的单表增删改查直接调用框架提供的方法即可。
Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存(降低数据库访问压力, 提供访问效率), 在后面的性能优化中会使用。
5). 工具
git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。
maven: 项目构建工具。
junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。
6). pom文件
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de2915c59770f2e617735fe504513dfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271b613f0ed8e7d6fd88b39416c3af79/" rel="bookmark">
			图像分割(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像分割 1、阈值分割1.1、确定阈值1.2、自定义函数1.3、Opencv函数 2 、基本区域生长2.1 、自定义函数 3、区域分裂与合并3.1、自定义函数 4、分水岭算法4.1、Opencv函数4.2、自定义函数 图像分割根据目标与背景的先验知识将图像表示为物理上有意义的连通区域的集合，即对图像中的目标、背景进行标记、定位，然后将目标从背景或其他伪目标中分离出来。 1、阈值分割 若图像中目标和背景具有明显不同的灰度集合，且两个灰度集合可用一个灰度级阈值T进行分割，那么可以用阈值分割灰度级的方法在图像中分割出目标区域和背景区域。
设图像为f(x,y)，其灰度集范围是[ Z 1 Z_1 Z1​, Z k Z_k Zk​]，在 Z 1 Z_1 Z1​和 Z k Z_k Zk​之间选择一个合适的灰度阈值T，则
g a ( x , y ) = { Z E , f ( x , ) ≥ T Z B , f ( x , ) &lt; T ga(x,y)=\begin{cases} Z_E, \ \ f(x,)\ge T\\ Z_B, \ \ f(x,)&lt; T \end{cases} ga(x,y)={ZE​, f(x,)≥TZB​, f(x,)&lt;T​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/271b613f0ed8e7d6fd88b39416c3af79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3240bd1752aace08edd95ee5c77d4af/" rel="bookmark">
			笔记本关机后耗电严重问题怎么解决？一秒快速解决笔记本电脑关机掉电快的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 或许许多使用笔记本的朋友都会遇到一个很头疼的问题，那就是笔记本关机放一段时间后（一周以内或者几个小时），电池电量消耗非常大。那么到底是什么原因导致笔记本关机后耗电快呢？如何解决耗电快的问题呢？下面详细讲述问题点及其解决方法。
几个问题点 网络唤醒 网络唤醒功能是网卡的一项通过网络唤醒计算机的功能，此功能需要网卡一直保持上电状态，一般可以在连接的路由器等设备看到对应网口是连接状态的，一般显示10Mbps速率。此时笔记本本的耗电量是比较大的。
USB充电 usb充电功能也是笔记本电脑的一个特色功能，就是笔记本在关机状态下，任然可以使用对应usb口给连接的设备供电，如果笔记本的USB充电口有连接设备，则笔记本电池就也处于耗电状态。
快速启动 快速启动是windows10的一项新技术，可以在系统关机后再次启动时快速地从内存中启动系统，不需要花费十来秒的等待时间，而且某些应用的运行状态也可以恢复，但是这项技术是依赖对内存数据的不断刷新的，即需要保持电脑的内存不断电才能正常实现快速启动，所以如果开启此功能，也是需要耗费大量的电池电量的。
解决方法 以上就是几种主要的笔记本电脑关机后耗电严重的问题点，那么下面就来讲解如何解决耗电问题。
关闭网络唤醒 网络唤醒功能可以关闭，网上有不少教程，这里不再详细说明。
关闭快速启动 快速启动功能也可以关闭，网上也有不少教程，不再详细说明。
断开USB外设 即在关闭笔记本电脑后把对应USB接口的设备拔除即可。
关机前拔掉充电器 此种方法亲测有效，可以轻松解决大部分因为设置带来的系统耗电问题，其原理是笔记本电脑在开机状态下拔掉充电器后，电脑自动进入电池供电电源模式，而Windows系统默认的电源模式电池供电和充电器供电的耗电设置是不同的，一些持续耗电的设置被关闭，所以关机后耗电量就会相应减少。
总结 综合以上所述，笔记本耗电严重最简单有效的解决办法就是，笔记本关机前先拔下充电器，关机后拔下所有的USB插口设备，当然此方法也只是最简单且有效的方法，并不是会保证系统完全不耗电，不同的耗电问题还是得用不同的方法解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a5f77f2bf789075435daa391f03e9f/" rel="bookmark">
			宽字节注入%df的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 宽字节注入是sql注入的一种手段，利用mysql使用GBK编码（因为GBK占用2个字节，而ascii占用1个字节），将两个字符看作一个汉字，从而消除转义字符\。（当某字符的大小为一个字节时，称其字符为窄字节当某字符的大小为两个字节时，称其字符为宽字节。所有英文默认占一个字节，汉字占两个字节。）
以下是个人总结对%df的理解
为什么使用%df
不一定使用%df，但前一个字节ascii码要大于128才到汉字的范围。
为什么那么多人都用%df
and被php转义后就是%df
逃逸过程
php.ini中有一个get_magic_quotes_gpc功能，在开启时所有的 ' (单引号), " (双引号), \ (反斜线) and 空字符会自动加上转义符\。
以'单引号为例，如何使\'中的'逃逸出来：
?id=1%df' and 1=1--+ %df'=&gt;%df\'（单引号会被加上转义字符\）
%df\'=&gt;%df%5c'（\的十六进制为%5c）
%df%5c'=&gt;縗'（GBK编码时会认为这时一个宽字节）
'成功逃逸，sql语法正确
sqlmap中同时也存在宽字节绕过的脚本unmagicquotes.py，使用方式如下
sqlmap -u "ip" --tamper="unmagicquotes.py" --batch 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04628a5feb82f0f50ac49ebc706704c0/" rel="bookmark">
			PHP开发的在线版网恋照妖镜源码使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初衷还是为了避免网恋翻车，毕竟网络世界里 谁也不知道和你相聊甚欢的对象是不是一个抠脚大汉呢？！
其原理：对方点击该链接并确认授权后 网页会自动调用前置摄像头抓拍照片，然后通过前面设置的密码就可以查看到刚刚抓拍的照片。具体步骤看下图
PHP开发的在线版网恋照妖镜 &gt;&gt;&gt;&gt;&gt; 点我测试效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d316d7bf4a851d363b21cd4dfdd5163/" rel="bookmark">
			1024，新的起点，加油
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从仰望的想象力，到落地的创造力。开发者用专业改变时代，以热爱书写未来。他们用一行行代码传递温暖，让无数的不现实，开始实现；让所有的不可能，开始可能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a304521a0053da5bbd7fecfba6653e5a/" rel="bookmark">
			安卓IPC机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPC机制的简介 IPC是Inter-Process Communication的缩写，含义是进程间通信，用于两个进程之间进行数据交互的过程，任何操作系统都有IPC机制，但不同的操作系统有着不同的通信方式，Android系统是一种基于Linux内核的移动操作系统，Linux的跨进程通信主要通过管道、共享内存、内存映射等实现的，但Android有自己的进程间通信机制，最具代表性的就是Binder。
线程：CPU调度的最小单元，是一种有限的资源。
进程：是指一个执行单元，PC和移动设备上指一个应用或程序，一个进程可以包含多个线程。
在安卓里主线程也叫UI线程，在UI线程里才能操作界面元素。
Android中的多线程模式 指的是指定应用内部开启多进程模式，只有一中方法，给四大组件在AndroidMenifest中指定android：process属性。如下图方式：
process有两种写法
第一种以“：”开头的，“：”的含义是要在当前的进程的前面附加上当前包名的一个缩写，是当前应用的私有进程，其他应用不能和他跑在同步一个进程。
第二种 包含“.”的，是完整的命名方式，属于全局进程，其他应用通过ShareUID方式可以和他跑在同一个进程种。
UID:是Android系统为每一个应用程序分配的用户身份证明来区分不同的应用。
具有相同UID的应用能共享数据（可以互相访问对方的私有数据data目录、组件信息等）
跑在同一进程需要相同的UID+相同的签名（还可以访问共享内存数据）
相同UID的应用实现资源共享： 首先需要在两个应用的AndroidManifest.xml中都定义相同的sharedUserId，如：android:sharedUserId=“com.test”。
同应用开启不同的线程后就运行在不同的虚拟机里面，不同的虚拟机在内存分配上有不同的地址空间，造成的问题：
1.静态成员和单例模式失效
2.SharePreferences的可靠性下降(底层是通过XML文件实现的，不支持两个进程同时读写数据，会丢失数据)
3.线程的同步机制失效
4.Application会多次创建。因为系统要为新建的线程分配独立的虚拟机，这个过程就是启动新的应用的过程，相当于系统又要把这个应用重新启动一边导致重建新的Application。运行在同一个进程的组件属于同一个虚拟机和Application。
利用跨进程通信解决上述问题 简单来说就是：通过使用数据持久化存储在设备上来传输数据。
需要通过Serializable接口/Parcelable接口来完成对象的序列化，在通过Intent和Binder传输数据或者通过Serializable将对象持久化到存储设备上或者网络传输给其他应用。
Serializable:是JAVA的序列化接口,使用起来简单开销很大
Parcelable:Android中的序列化方式，使用麻烦但是效率很高。
不参加序列化的
1.静态变量，2.transient相关标记的成员变量。
Serialization接口，基于JVM上的持久化数据 Java提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化。
Serializable使用IO读写存储在硬盘上。序列化过程使用了反射技术，并且期间产生临时对象。Serializable在序列化的时候会产生大量的临时变量,从而引起频繁的GC。优点代码少。
使用方法：在需要序列化的类里面实现Serializable接口并声明一个标识serialVersionUID 如
public class User implements Serializable { //可以不写，系统根据结构计算当前类的hash值自动分配，增加或删除结构从新计算会hash值会不一致，导致反序列化失败程序crash。 //手动指定，最大程度反序列化成功，建议用插件自动生成。 private static final long serialVersionUID =463442362345654634L; ... ... } 剩下的工作系统会自动完成，进行序列化和反序列化的方法：采用ObjectOutputStream和ObjectInputStream。
//序列化过程 User user = new User("chou",27,man)； ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("cache.tex")); out.writeObject(user); out.close; //反序列化过程 ObjectInputStream in = new ObjectInputStream(new FileInputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a304521a0053da5bbd7fecfba6653e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08dedaf680da9995ac37b255d50b0f5/" rel="bookmark">
			@Autowired注解的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Autowired注解可以被标注在构造函数、属性、setter方法或配置方法上，用于实现依赖自动注入。
这里对@Autowired注解底层进行源码分析
参考：https://blog.csdn.net/One_L_Star/article/details/114829247
@Autowired注解的作用是由AutowiredAnnotationBeanPostProcessor实现的，查看该类的源码会发现它实现了MergedBeanDefinitionPostProcessor接口，进而实现了接口中的postProcessMergedBeanDefinition方法，@Autowired注解正是通过这个方法实现注入类型的预解析，将需要依赖注入的属性信息封装到InjectionMetadata类中，InjectionMetadata类中包含了哪些需要注入的元素及元素要注入到哪个目标类中，在Spring容器启动的过程中初始化单例bean的时候通过populateBean方法实现对属性的注入。
public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) { if (beanType != null) { InjectionMetadata metadata = this.findAutowiringMetadata(beanName, beanType, (PropertyValues)null); metadata.checkConfigMembers(beanDefinition); } } public class InjectionMetadata { private static final Log logger = LogFactory.getLog(InjectionMetadata.class); private final Class&lt;?&gt; targetClass; private final Collection&lt;InjectedElement&gt; injectedElements; private volatile Set&lt;InjectedElement&gt; checkedElements; Spring对autowire注解的实现逻辑位于类:AutowiredAnnotationBeanPostProcessor#postProcessProperties之中，——&gt;findAutowiringMetadata——&gt;buildAutowiringMetadata，核心代码就在buildAutowiringMetadata方法里面
private InjectionMetadata buildAutowiringMetadata(Class&lt;?&gt; clazz) { if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) { return InjectionMetadata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08dedaf680da9995ac37b255d50b0f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ec13ac6f1d3890b6d512f5b3773d12/" rel="bookmark">
			Autowired实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、认识@Autowired
@Autowired
替换：autowire属性,自动装配（按照类型装配，通过set方法，且方法可以省略）
位置：修饰属性，set方法
语法：@Autowired(required="true")
注意：1.如果容器中没有一个可以与之匹配且required属性为true则会报异常
NoSuchBeanDefinitionException
2.如果容器中有多个可以类型可以与之匹配，则自动切换为按照名称装配
3.如果容器中有多个可以类型可以与之匹配，则自动切换为按照名称装配，如果名称也没有匹配，则报异常 NoUniqueBeanDefinitionException
@Autowired提供required的属性，用来处理当注入的Bean实例不存在的情况。
required为true时，如果注入的Bean实例不存在，程序会抛出异常；
required为false时，如果注入的Bean实例不存在，程序会忽略。
二、@Autowired的操作思路：
解析谁要进行注入==》查找依赖的来源==》注入的一个对象。 从源码中看到它可以被标注在构造函数、属性、setter方法或配置方法上，用于实现依赖自动注入。
@Autowired注解的作用是由AutowiredAnnotationBeanPostProcessor实现的，查看该类的源码会发现它实现了MergedBeanDefinitionPostProcessor接口，进而实现了接口中的postProcessMergedBeanDefinition方法，@Autowired注解正是通过这个方法实现注入类型的预解析，将需要依赖注入的属性信息封装到InjectionMetadata类中，InjectionMetadata类中包含了哪些需要注入的元素及元素要注入到哪个目标类中，在Spring容器启动的过程中初始化单例bean的时候通过populateBean方法实现对属性的注入。
Spring容器在启动的时候会执行AbstractApplicationContext类的refresh方法，在refresh方法执行的过程中先注册AutowiredAnnotationBeanPostProcessor，然后在对非延迟初始化的单例bean进行初始化时，会间接调用。
refresh方法中registerBeanPostProcessors(beanFactory)完成了对AutowiredAnnotationBeanPostProcessor的注册，当执行finishBeanFactoryInitialization(beanFactory)方法对非延迟初始化的单例bean进行初始化时，会执行到AbstractAutowireCapableBeanFactory类的doCreateBean方法
在这段代码中会执行applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)，深入到这个applyMergedBeanDefinitionPostProcessors方法中
查看postProcessMergedBeanDefinition方法的具体实现类，会发现这里调用的是AutowiredAnnotationBeanPostProcessor类的postProcessMergedBeanDefinition方法，也就是开头介绍的在这个方法中完成了对注入元素注解的预解析。
同样，在doCreateBean方法中执行populateBean方法实现对属性的注入。
metadata.inject(bean, beanName, pvs)代码的执行会进入如下inject方法中，在这里完成依赖的注入。
InjectedElement有两个子类，分别是AutowiredFieldElement和AutowiredMethodElement。Spring的优秀不仅在抽象封装上，连命名都是那么的出色。从类名上可以很容易的看出，AutowiredFieldElement用于对标注在属性上的注入，AutowiredMethodElement用于对标注在方法上的注入。两种方式的注入过程都差不多，根据需要注入的元素的描述信息，按类型或名称查找需要的依赖值，如果依赖没有实例化先实例化依赖，然后使用反射进行赋值。
总结：@Autowied是spring的重要注解，虽然理解困难，但是它的本质永远是new对象，因为spring的核心思想就是IOC，程序员不需要new对象，只是将控制权给了spring框架，由它在底层通过注解或者配置文件帮我们new对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760abd5de8af8ca989060bbd3d27492f/" rel="bookmark">
			Java获取当前时间的前一天时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java获取当前时间的前一天时间 引入相关包具体代码实现结果 引入相关包 // 引入日期处理的相关jar包 import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; 具体使用方式可能涉及到开发过程当中，定时任务更新，获取前一天时间点到现在时间点的业务，可能会使用到以下代码。
具体代码 //将时间格式化成yyyy-MM-dd HH:mm:ss的格式 SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = new Date(); String nowTime = format.format(date); Calendar calendar = Calendar.getInstance(); calendar .setTime(date); calendar .add(Calendar.DATE, -1); String beforeDay = format.format(calendar .getTime()); System.out.println("当前时间:"+nowTime); System.out.println("前一天时间:"+beforeDay); 实现结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b81c75a3c5250ecc007239bd62af6e/" rel="bookmark">
			Bash cp 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Bash cp 命令详解 cp 命令语法和简单使用cp 命令的选项说明及示例按照是否复制文件的内容进行分类文件属性的控制创建文件的软硬链接目标文件或文件夹存在创建父目录其它几个选项比较简单 Bash cp 命令详解 cp 是 “copy” 的缩写。该命令的功能是复制文件和目录。可以把源文件（SOURCE）复制到目标文件（DEST），或者把多个源文件（SOURCEs）或目录复制到目录（DIRECTORY）中。
cp 命令语法和简单使用 语法：
cp [OPTION]... [-T] SOURCE DEST cp [OPTION]... SOURCE... DIRECTORY cp [OPTION]... -t DIRECTORY SOURCE... 在第一种格式中，如果提供了两个参数，第一个参数是源文件，第二参数是目标文件（可以不存在），cp 命令把源文件(SOURCE)复制到目标文件(DEST)中。
如果指定了 -T 选项，则第二参数只能是文件，不能是目录。
]# cp foo.txt bar.txt ]# ls -l total 8 -rw-r--r--. 1 root root 13 Oct 21 19:39 bar.txt -rw-r--r--. 1 root root 13 Oct 21 19:38 foo.txt 在第二种格式中，拷贝多个源文件到一个目录中。这种格式最后的参数必须是一个目录，不然，多个源文件复制到哪里去？
]# ls file1 file2 file3 file4 file5 file6 # 可以使用通配符匹配多个文件 ]# cp file* backup/ ]# ls backup/ file1 file2 file3 file4 file5 file6 第三种格式与第二格式相似，只不过通过一个选项 -t, --target-directory 来指定目标目录，并把所有源文件放在后面而已。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b81c75a3c5250ecc007239bd62af6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa21b0528a1b21c3320fd390f2eb695/" rel="bookmark">
			MD5加密后为0e开头的字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QNKCDZO 0e830400451993494058024219903391
s878926199a 0e545993274517709034328855841020
s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371a33afb85455b9416cde023f2d60c2/" rel="bookmark">
			依赖报错：While resolving: @vue/eslint-config-standard@6.1.oFound: eslint-plugin-vue@8.7.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目前一天晚上运行的还好好的，结果第二天打开一看我都傻眼了
满屏幕的爆红
说找不到less依赖，但是less依赖早已下载好并且投入使用了。就像删除重新下载，结果就连删除都失败了，于是换了一种下载方式：使用yarn
全局安装yarn
npm install -g yarn
下载yarn
yarn install 结果出现了以下错误： 解决方法：删除了package.lock.json
重新下载
又出现了更多错误，顺着报错去找，npm没有换源 运行
npm config set registry https://registry.npm.taobao.org
重新下载，success！项目重新正常运行！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46cd0b62750e4d97b6b2d66779b63e8c/" rel="bookmark">
			docker常用操作命令。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker是一款基于Linux之上的容器，由于它的抽象层比虚拟机少，而且利用的是主机内流，不需要价值操作系统的内核，所以它比传统的虚拟机更快，所以越来越多的人选择用docker了，今天我要和大家分享的就是docker的常用操作命令。
我们都知道，docker中常用的几个类型有帮助启动类命令、镜像命令和容器命令，接下来我就将自己总结的命令给大家一一展示。
一、帮助启动类命令。
1、启动，命令：systemctl start docker
2、停止，命令：systemctl stop docker
3、重启，命令：systemctl restart docker
4、查看docker状态，命令：systemctl status docker
5、开机启动，命令：systemctl enable docker
6、查看docker概要信息，命令：docker info
7、查看docker整体帮助文档，命令：docker --help
8、查看docker命令帮助文档，命令：docker 具体命令 --help
二、镜像命令。
1、列出本地主机上的镜像，展示的是一个列表，表头含义如下：
repository：表示镜像的仓库源
tag：镜像的标签
images ID：镜像ID
created：镜像创建时间
size：镜像大小
命令：docker images
-a：列出本地所有镜像（包括历史镜像）
-q：只显示镜像ID
2、某个×××镜像名字，展示的是一个列表，表头含义如下：
name：镜像名称
description：镜像说明
stars：点赞数量
official：是否是官方的
automated：是否是自动构建的
命令：docker search
--limit：只列出N个镜像，默认为25个
--limit 5 redis：只列出5个redis
3、下载镜像，命令：docker pull 某个×××镜像名字，有两种命令：
a.docker pull 镜像名字[:TAG]
b.docker pull 镜像名字 没有tag就是最新版，等价于。
4、查看镜像/容器/数据卷所占的空间，命令：docker system df
5、删除某个×××镜像名字ID（这里就不展示删除了），命令：docker rmi
删除单个，命令：docker rmi -f 镜像ID
删除多个，命令：docker rmi -f 镜像名1：TAG镜像名2：TAG
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46cd0b62750e4d97b6b2d66779b63e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a45bdaddafe90036901ae6c2202fe4b/" rel="bookmark">
			python 文件读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 文件读写 文章目录 python 文件读写1. 打开文件2. 文件模式3. 文件缓冲区4. 文件读取5. 文件写入 1. 打开文件 读写文件是最常见的IO操作。Python内置了读写文件的函数，方便了文件的IO操作。文件读写之前需要打开文件，确定文件的读写模式。open函数用来打开文件，
语法如下：
open(name[.mode[.buffering]]) open函数使用一个文件名作为唯一的强制参数，然后返回一个文件对象。模式（mode）和缓冲区（buffering）参数都是可选的，默认模式是读模式，默认缓冲区是无。
假设有个名为qiye.txt的文本文件，其存储路径是c：\text（或者是在Linux下的~/text），那么可以像下面这样打开文件。在交互式环境的提示符“&gt;&gt;&gt;”下，输入如下内容：
&gt;&gt;&gt; f = open(r'c:\text\qiye.txt') 如果文件不存在，将会看到一个类似下面的异常回溯：
Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; IOError: [Errno 2] No such file or directory: 'C:\\qiye.txt' 2. 文件模式 下面主要说一下open函数中的mode参数（如表1-1所示），通过改变mode参数可以实现对文件的不同操作。
这里主要是提醒一下‘b’参数的使用，一般处理文本文件时，是用不到‘b’参数的，但处理一些其他类型的文件（二进制文件），比如mp3音乐或者图像，那么应该在模式参数中增加‘b’，这在爬虫中处理媒体文件很常用。参
数‘rb’可以用来读取一个二进制文件。
3. 文件缓冲区 open函数中第三个可选参数buffering控制着文件的缓冲。如果参数是0，I/O操作就是无缓冲的，直接将数据写到硬盘上；如果参数是1，I/O操作就是有缓冲的，数据先写到内存里，只有使用flush函数或者close函数才会将数据更新到硬盘；如果参数为大于1的数字则代表缓冲区的大小（单位是字节），-1（或者是任何负数）代表使用默认缓冲区的大小。
4. 文件读取 文件读取主要是分为按字节读取和按行进行读取，经常用到的方法有read（）、readlines()、close()。
在“&gt;&gt;&gt;”输入f=open（r‘c：\text\qiye.txt’）后，如果成功打开文本文件，接下来调用read（）方法则可以一次性将文件内容全部读到内存中，最后返回的是str类型的对象：
&gt;&gt; f.read() "qiye" 最后一步调用close（），可以关闭对文件的引用。文件使用完毕后必须关闭，因为文件对象会占用操作系统资源，影响系统的IO操作。
&gt;&gt;&gt; f.close() 由于文件操作可能会出现IO异常，一旦出现IO异常，后面的close（）方法就不会调用。所以为了保证程序的健壮性，我们需要使用try...finally来实现
try: f = open(r'c:\text\qiye.txt','r') print f.read() finally: if f: f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a45bdaddafe90036901ae6c2202fe4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f85fa0944a29bffce5313e6ec3c556/" rel="bookmark">
			java IO流进阶 模拟上传头像系统详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言： 二、思路:
PS：直接看代码中的注释也可以.
①分析：
②总结:
三、代码：
①准备工作：
②代码演示:
③运行效果: 四、撒❀：
一、前言： 这篇文章是对之前java IO流基础 万字详解的补充。我们试着用java IO流 来模拟一个独立的头像上传系统。看本篇分享需要有一定的javaSE基础，特别是IO流基础和File文件类基础，因为本篇就是对File类和IO流知识综合的一个小应用。基础好的同学也可以直接看代码。代码中做了非常详细的注释。
二、思路: PS：直接看代码中的注释也可以. ①分析： 1.要上传头像，多少要有一个保存所上传头像的目录，up以头像文件夹作为演示，如图:
即，演示中我们所上传的头像，都会保存在“头像” 这个文件夹里头。当然，因为是新建的文件夹做演示用的，所以一开始头像文件夹内容为空，如图:
2.既然是用到了IO流的知识，那IO流肯定是“上传头像”这具体一过程用到了，也就是字节流拷贝头像嘛，但是，我们如何获取用户想要上传的头像? 这里我们考虑选择Scanner类的nextLine（）方法，让用户输入要上传头像的路径（因为该路径之后是可以作为IO流拷贝中数据源文件路径的）。
3.收到用户输入的路径后，应该立刻判断该文件后缀名是否属于图片的格式，如果不是，应该提示用户录入的不是图片，要重新录入。
4.如果路径符合图片的格式，就要进行二次判断了，判单传入的路径是否合法，以及是否是文件，如果路径非法，或者传入的是个名字叫xxx.png之类的文件夹而不是文件，就提示用户录入的路径不合法，要重新录入。最后就是要判断该图片是不是已经在头像文件夹中存在了，如果存在，应该提示用户要上传的头像已经存在了，无需再次上传，如果不存在，就准备进行上传工作。
5.最后一步就是正式的上传工作了，使用高效字节流拷贝图片，直接搞定。 ②总结: 经过上述的简略分析，我们大致确定要定义三个函数，
第一个函数用于实现获取用户头像的功能，且要进行判断，判断是否为图片，且是否为合法路径。
第二个函数用于判断要上传的头像是否已经存在，即是否已经上传过了。
第三个函数用于执行确定的上传操作。
三、代码： ①准备工作： up也有个毛病就是演示教学的时候往往过于认真，所以更注重实操效果。因此我们要上传的头像就随便找了。如下是up随便找的几张普普通通的插图：
🆗，小伙伴儿将就一下吧，毕竟是演示，图片不需要华丽。up将这三张图片放在了桌面上的csdn文件夹中作为备用。如图： 为了测试我们的系统，我特意将三张图片的格式分别设置为了.png .jpg 和 .bmp格式，注意看，第一个文件夹我故意给它起名字为Fake.png，测试一下能否混淆视听。 ②代码演示: package knowledge.simulation; import java.io.File; import java.util.Arrays; import java.util.Scanner; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.IOException; import java.io.FileInputStream; import java.io.FileOutputStream; /* * java进阶之利用IO流模拟用户上传头像的功能。 * 假设所有的用户头像都应该上传到 D:\JAVA\IDEA\file\头像 文件夹中 */ /* 思路分析： ①前言:既然要以IO流上传头像，很明显要用到我们的字节流拷贝头像。 但肯定是确定了要上传时，才开始拷贝，不会盲目拷贝的。 ②因此我们需要先确定要上传的头像，即你想要上传哪个头像？ 并且如果这个头像已经上传过了，就没必要再上传了，直接用就可以了。 ③所以我们至少需要自定义三个独立的函数。 第一个函数负责获取用户要上传的头像。 第二个函数负责判断获取的头像是否已经上传。 第三个函数负责将确定上传的头像进行上传工作。 */ public class HeadPortrait { public static void main(String[] args) throws IOException { //以下步骤是仅是main方法中的执行流程，具体实现要定义的函数放在了main函数的下方。 //一.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9f85fa0944a29bffce5313e6ec3c556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dfd4c56d3449f66abac3c9e9cb83a7e/" rel="bookmark">
			Harbor离线安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Docker离线安装 下载地址：https://download.docker.com/linux/static/stable/x86_64/
tar -zxvf docker-20.10.9.tgz mv docker/* /usr/bin/ vi /etc/systemd/system/docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd --selinux-enabled=false ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target chmod +x /etc/systemd/system/docker.service systemctl daemon-reload systemctl start docker systemctl status docker systemctl enable docker.service 2、安装docker-compose（v2.11.2） 下载地址：https://github.com/docker/compose/releases mv docker-compose-linux-x86_64 /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose 3、安装harbor 下载harbor离线安装包harbor-offline-installer-v2.4.3.tgz
下载地址https://github.com/goharbor/harbor/releases
（1）解压
tar -xzf harbor-online-installer-v2.4.3.tgz mkdir /opt/harbor mv harbor/* /opt/harbor/ （2）修改配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dfd4c56d3449f66abac3c9e9cb83a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbf08d488251792dda2e2a066ad9d23/" rel="bookmark">
			一文获悉组件通信之——发布-订阅模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用“发布-订阅”模式驱动数据流 “发布-订阅”模式可谓是解决通信类问题的“万金油”，在前端世界的应用非常广泛，比如：
前两年爆火的 socket.io 模块，它就是一个典型的跨端发布-订阅模式的实现；
在 Node.js 中，许多原生模块也是以 EventEmitter 为基类实现的；
不过最为熟知的，应该还是 Vue.js 中作为常规操作被推而广之的“全局事件总线” EventBus。
这些应用之间虽然名字各不相同，但内核是一致的，也就是下面要讲到的“发布-订阅”模型。
理解事件的发布-订阅机制 发布-订阅机制早期最广泛的应用，应该是在浏览器的 DOM 事件中。 相信有过原生 JavaScript 开发经验的同学，对下面这样的用法都不会陌生：
target.addEventListener(type, listener, useCapture); 通过调用 addEventListener 方法，可以创建一个事件监听器，这个动作就是“订阅”。比如我可以监听 click（点击）事件：
el.addEventListener("click", func, false); 这样一来，当 click 事件被触发时，事件会被“发布”出去，进而触发监听这个事件的 func 函数。这就是一个最简单的发布-订阅案例。
使用发布-订阅模式的优点在于，监听事件的位置和触发事件的位置是不受限的，只要它们在同一个上下文里，就能够彼此感知。这个特性，太适合用来应对“任意组件通信”这种场景了。
发布-订阅模型 API 设计思路 通过前面的讲解，不难看出发布-订阅模式中有两个关键的动作：事件的监听（订阅）和事件的触发（发布），这两个动作自然而然地对应着两个基本的 API 方法。
addListener()：负责注册事件的监听器，指定事件触发时的回调函数。
emit()：负责触发事件，可以通过传参使其在触发的时候携带数据 。
最后，只进不出总是不太合理的，还要考虑一个 removeListener() 方法，必要的时候用它来删除用不到的监听器：
removeListener()：负责监听器的删除。 发布-订阅模型编码实现 在写代码之前，先要捋清楚思路。这里把“实现 EventEmitter ”这个大问题，拆解为 3 个具体的小问题，下面逐个来解决。
问题一：事件和监听函数的对应关系如何处理？ 提到“对应关系”，应该联想到的是“映射”。在 JavaScript 中，处理“映射”大部分情况下都是用对象来做的。所以说在全局需要设置一个对象，来存储事件和监听函数之间的关系：
class EventBus { constructor() { // events 用来存储事件和监听函数之间的关系 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bbf08d488251792dda2e2a066ad9d23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed36b56936f442d3af31d2ce5d0a1f8/" rel="bookmark">
			ubuntu nfs 客户端挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装客户端 sudo apt-get install nfs-common 查看服务端共享目录 showmount -e “ip(服务端ip)” 进行挂载 mount 192.168.3.6:/data /data/share mount ip:共享目录 挂载目录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64523087af65e943e5a9110637a2fe2/" rel="bookmark">
			【微信小程序】安卓兼容问题，scroll-view上拉导致input输入框上移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在一个超一屏的scroll-view标签中的input表单聚焦的时候，输入光标会随着键盘弹出导致向上偏移，但是输入框的本体(背景色，边框)还是留在原位置
问题原因 原因大概率是由于给scroll-view设置了整屏高度(100vh)，导致在输入框聚焦时，上移高度计算出现问题，猜测底层对scroll-view里面input焦点定位时只计算了固定高度的值。
解决方案 只要不给scroll-view设置整屏高度，就可以避免这个bug，或者使用height: calc(100vh - 1px);也可以避免这个问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0061d2a748cc74868cca9af7259656fb/" rel="bookmark">
			用js做一个可显示可拖动的缩放数值条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：可拖拽数值条进行值的变化；单击缩放按钮则+1（可设定）；长按则持续+5（可设定）；点击恢复则返回到最初值（可设定）；值的范围为0~100（可设定），超出则按0/100作为最终值；zoom.value内存放着值，可进行传参，应用于你的程序。
用js制作缩放拖动条
controlCamera.js
/*用于云台控制界面 * 主要功能有：	* 传递方向控制参数、传递缩放参数（值为zoom.value内的值） * 缩放点击效果（点击加1，长按连续加5） * * */ var oldvalue='';//为存放当前操作的id let time="";//延时时间初始化 let lock=true;//锁，防止单击与长按相互冲突 var minvalue=0;//设定范围最小值 var maxvalue=100;//设定范围最大值 var inivalue=50;//设定范围最初值 var short=1;//短按增（减）量 var long=5;//长按增（减）量 //减小数值，单击减1 function minus(){ if(lock){ var num=document.getElementById("zoom").value; if(num==minvalue){ num=minvalue; } else{ num=Number(num)-short; } document.getElementById("zoom").value=num; document.getElementById("showZoom").innerHTML=num; } } //减小数值，长按1s持续减5	function downMinus(){ time=setInterval(()=&gt;{ lock=false; var num=document.getElementById("zoom").value; num=Number(num)-long; if(num&lt;minvalue){ num=minvalue; } document.getElementById("zoom").value=num; document.getElementById("showZoom").innerHTML=num; },1000) }	//恢复默认值	function repeat(){ var num=inivalue; document.getElementById("zoom").value=num; document.getElementById("showZoom").innerHTML=num; } //增加数值，单击加1	function plus(){ if(lock){ var num=document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0061d2a748cc74868cca9af7259656fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d7e97cbd61d69aaf4dc633fc5d0bb6/" rel="bookmark">
			【WSL2启用systemd支持(一个配置即可)】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、systemd是什么？二、备份数据1.归档2.备份分支 三、准备工作1.内核升级 四、修改配置总结 前言 很长一段时间WSL2的启动方式并不是systemd，由于ubuntu、debian、centos等一众分支都切换到systemd了，导致使用起来有些不方便，之前一个大神演示了wsl2上启用systemd，我按照他说的做成功了，但是这个方法并不完美，它会导致wsl-gui不能使用，要知道wsl2的一个重磅功能就是gui，有没有方法能既使用systemd，又保留systemd呢？别急，两行配置叫你解决，请仔仔细细看完，最好不要跳过，不然可能引发不可挽回的错误。
一、systemd是什么？ systemd即为system daemon,是linux下的一种init软件,由Lennart Poettering带头开发,并在LGPL 2.1及其后续版本许可证下开源发布,开发目标是提供更优秀的框架以表示系统服务间的依赖关系，并依此实现系统初始化时服务的并行启动，同时达到降低Shell的系统开销的效果，最终代替常用的System V与BSD风格init程序。
与多数发行版使用的System V风格init相比，systemd采用了以下新技术： (1) 采用Socket激活式与总线激活式服务，以提高相互依赖的各服务的并行运行性能； (2) 用Cgroups代替PID来追踪进程，因此即使是两次fork之后生成的守护进程也不会脱离systemd的控制。
二、备份数据 这个不用我多说了吧，数据无价，一旦操作失误可能数据就永远丢了。这里有两种方法教你备份数据。
1.归档 这是最简单的方法了，但是绝对有效。使用tar+gzip或者zip等工具将数据归档压缩并拷贝出来。或者直接干脆只归档不压缩。
tar -zcf backup.tar.gz &lt;你的目录&gt; 2.备份分支 这个方法我在我的另一篇博客里详细介绍了，将整个分支备份还原。优点是两句话搞定，数据和系统配置原封不动保存下来，推荐这个方法。
WSL2备份还原
方法很多，这里介绍最简单常用的方法，主要还是备份，切记！！！
三、准备工作 我先贴出我的内核版本，我这个内核版本成功了，其它的由于时间问题没有一一尝试，如果有问题可以在下面评论，我们一起看下。
Linux DESKTOP-G21E46A 5.15.68.1-microsoft-standard-WSL2 #1 SMP Mon Sep 19 19:14:52 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux 我习惯性地把内核版本升级到最新，所以很多测试都是基于内核最新版的。
1.内核升级 如果和我的内核一样就不用这个步骤了，如果不一样就按照下面的操作来。
wsl --shutdown #杀死分支 接下来的操作需要administrator权限（俗称管理员权限），先使用管理员权限打开一个powershell,然后输入下面的指令等待升级完成，如果失败检查网络问题，或者多试几次。
wsl --update 四、修改配置 在/etc/下面增加一个wsl.conf文件，这个操作需要sudo权限，文件里面输入下面的内容：
[boot] systemd=true 保存退出，并执行wsl --shutdown，重新进入wsl
切记一个字都不要错，否则可能导致wsl进不去，所以备份很重要
是不是感到一种亲切感涌上心头，接着我们测试下gui还能不能正常使用，打开gedit：
好了，systemd和gui都正常，这才是真正的linux。
总结 方法蛮简单的，主要是微软和systemd的开发团队合作之后新增的功能，配置也极为简单。之前某大神也搞出来一个教程，但是会导致gui失效，我没有找出来解决方法，就废弃了那个方法。
这个方法目前来看应该是完美方案了，不过细化的功能我没有来得及测试，感兴趣的可以都测试下，有问题欢迎讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf537b046bf77f7007dfaf61e4bab094/" rel="bookmark">
			Liunx安装docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看liunx 的版本
之前使用的CentOS8由于停止维护了，这意味着无法再使用新版本的软件包更新了，由于Docker 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。
查看内核命令 uname -r 2.查看防火墙 关闭
#常见的两种防火墙 service iptables status firewall-cmd --state 3.手动安装Docker分三步：卸载、设置仓库、安装。
4.自动安装
3.1 .卸载（可选）
如果之前安装过旧版本的Docker，可以使用下面命令卸载： yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ docker-ce 3.2 设置仓库
首先需要大家虚拟机联网，安装yum工具 yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 --skip-broken 然后更新本地镜像源：
# 设置docker镜像源 阿里云 yum-config-manager \ --add-repo \ https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf537b046bf77f7007dfaf61e4bab094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add20721182a84f2e162c4658fe05a1e/" rel="bookmark">
			如何用c语言打印hello world
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
int main()
{
printf("hello world");
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e23a169652aaf95ce80da844f3df0d/" rel="bookmark">
			Elasticsearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 初识ElasticSearch 1.1 基于数据库查询的问题 查询效率低，模糊查询数据库不会使用索引查询的准确率不高 1.2 倒排索引 倒排索引：将文档进行分词，形成词条和id的对应关系即为反向索引。
以唐诗为例，所处包含“前”的诗句
正向索引：由《静夜思》–&gt;窗前明月光—&gt;“前”字
反向索引：“前”字–&gt;窗前明月光–&gt;《静夜思》
反向索引的实现就是对诗句进行分词，分成单个的词，由词推句，即为反向索引
“床前明月光”–&gt; 分词；将一段文本按照一定的规则，拆分为不同的词条（term）
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eo4YB0Nr-1663903327650)(img/1580887683510.png)]
倒排索引中的Value通常是文档的唯一标识（ID）
1.3 ES存储和查询的原理 index（索引）：相当于mysql的库
映射：相当于mysql 的表结构
document(文档)：相当于mysql的表中的数据
数据库查询存在的问题：
性能低：使用模糊查询，左边有通配符，不会走索引，会全表扫描，性能低功能弱：如果以”华为手机“作为条件，查询不出来数据 Es使用倒排索引，对title 进行分词
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tuoVuU8B-1663903327652)(img/1581143412491.png)]
使用“手机”作为关键字查询
生成的倒排索引中，词条会排序，形成一颗树形结构，提升词条的查询速度
使用“华为手机”作为关键字查询
华为：1,3
手机：1,2,3
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-apwYhX1D-1663903327652)(img/1581143489911.png)]
1.4 ES 概念详解 ES是一个基于Lucene的搜索服务器
ES是一个分布式、高扩展、高实时的搜索与数据分析引擎
ES基于RESTful web接口
Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎
官网：https://www.elastic.co/
应用场景
海量数据的查询/搜索日志数据分析实时数据分析 2. 安装ElasticSearch 下载地址：https://www.elastic.co/cn/downloads/elasticsearch
3. ElasticSearch核心概念 索引（index）
ElasticSearch存储数据的地方，可以理解成关系型数据库中的数据库概念。
映射（mapping）
mapping定义了每个字段的类型、字段所使用的分词器等。相当于关系型数据库中的表结构。
文档（document）
Elasticsearch中的最小数据单元，常以json格式显示。一个document相当于关系型数据库中的一行数据。
倒排索引
一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，对应一个包含它的文档id列表。
类型（type）
一种type就像一类表。如用户表、角色表等。在Elasticsearch7.X默认type为_doc
ES 5.x中一个index可以有多种type。 ES 6.x中一个index只能有一种type。 ES 7.x以后，将逐步移除type这个概念，现在的操作已经不再使用，默认_doc 4. 脚本操作ES 4.1 RESTful风格 REST（Representational State Transfer），表述性状态转移，是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。就是一种定义接口的规范。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e23a169652aaf95ce80da844f3df0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab694d696bcedf4341805811341bf81c/" rel="bookmark">
			Visual Studio下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. Visual Studio下载 下载地址：https://visualstudio.microsoft.com/zh-hans/
选择版本，如：Community 2022
2. 安装Visual Studio 2022 双击运行VisualStudioSetup.exe
勾选”使用C++的桌面开发“
修改安装目录
启动Visual Studio
创建新项目
调试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1f992f336905eae1c6d5568a832af0/" rel="bookmark">
			vue前端设置跨域操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、跨域问题产生二、傻瓜式解决1.前端操作2.后端设置 前言 记录VUE+Springboot项目请求跨域操作要点，在学习过程中不断补充。
一、跨域问题产生 1、当前网页URl与请求的URL地址不同域名。
2、当前网页URl与请求的URL相同域名，不同端口。
3、当前网页URl与请求的URL不同协议。
即域名、端口和协议必须一样，不然就属于跨域请求
具体内部技术原因待学习，看了一些仍旧不太了解。
跨域 + devServer.proxy
二、傻瓜式解决 1.前端操作 使用代理服务器
（1）vue.config.js
在项目根目录下（与src文件夹同级）创建vue.config.js文件来修改默认的配置：
module.exports = { devServer: { proxy: { //名字可以自定义，这里我用的是api '/api': { target: 'http://127.0.0.1/',//设置你调用的接口域名和端口号（目标IP：端口） changeOrigin: true, pathRewrite: { '^/api': '' } } } } }; （2）main.js
axios.defaults.baseURL = '/api'; //调用axios时前端加上默认路由/api （3）调用示例
this.axios.post('/php/select.php').then((response) =&gt; { }).catch((err) =&gt; { }) 2.后端设置 springboot解决CORS 跨域问题，options请求出现403
请求是跨域，所以会先发一个options看看支不支持跨域，如果服务器支持跨域才会发原来的请求。
将后端的Controller类上加一个注解
@CrossOrigin(origins = "http://127.0.0.1:8080") //origins ="允许跨域访问的协议+ip+端口" //如果想设置所有地址都可以跨域设置成origins ="*" 中间有个细节就是本地测试的时候前端网址如果ip是localhost的话，后端注解origins的值必须是“localhost”。
疑问：为什么我之前只是后端设置跨域，前端修改请求头，并没有使用代理服务器也可以正常使用？详情代码为之前的vue
D:\Program\WebStormProjects\VueDemo(request+header)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba2c61693fd07cfedd3738af436be4d/" rel="bookmark">
			Beyond Compare 4密钥解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲测好用，其他方法删除文件夹方法无效（删除后启动会自动生成）
修改注册表
1、在搜索栏中输入 regedit ，打开注册表
2、删除项目CacheId ：
HKEY_CURRENT_USER\Software\Scooter Software\Beyond Compare 4\CacheId
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e5375eb477fe4f1e1997ae3933bef8/" rel="bookmark">
			利用qtdesigner完成文字与图片切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：
之前使用qtdesigner时总对信号/槽产生困惑，不太明白它的使用方式，后来不单纯弄界面了，同事要求还要搞一些动作，比如：文字图片切换、文字变换、利用键盘输入使界面变化等等，逐渐掌握了信号/槽的用法。下面就用一个小例子来说明下它的用法
python切换文字与图片
1.创建ui文件（cutshow.ui）
1.1新建窗体
选择WIdget，点击创建。
1.2拖入组件
需要拖入：2个radiobutton（进行选择）、1个stacked widget（用来显示）、2个label。Label需拖到stacked widget中，另一个点stacked widget上的黑箭头拖入进去。
1.3进行布局
按住ctrl，选择两个radiobutton组件，点击右键选择“布局”---&gt;“垂直布局”
完成后：
在对象查看器中找到对象“Form”，点击右键选择“布局”---&gt;“水平布局”
这样一个简单的布局就完成了。
1.4添加文字及图片
双击即可修改文字
选中打算插入图片的label，在属性编辑器中找到pixmap，选择文件。
插入成功！
1.5修改对象名
为了之后使用的方便，建议修改对象名。修改方法：双击对象名即可
2.创建py文件（main.py）
2.1新建文件并引用ui文件
引用部分详见我的另一篇文章：
https://blog.csdn.net/qq_44878999/article/details/127245501
2.2加入信号/槽
最终代码为：
from PySide2.QtUiTools import QUiLoader from PySide2.QtWidgets import QApplication class Cutshow: def __init__(self): self.ui = QUiLoader().load("cutshow.ui") # 信号/槽的使用 self.ui.btnpic.clicked.connect(self.showpic) self.ui.btntext.clicked.connect(self.showtext) # 修改 stacked widget组件的当前显示页 def showpic(self): self.ui.stacked.setCurrentIndex(1) def showtext(self): self.ui.stacked.setCurrentIndex(0) if __name__ == "__main__": # 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行 app = QApplication() # 设置窗口图标 # 初始化 myWin = Cutshow() # 将窗口控件显示在屏幕上 myWin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e5375eb477fe4f1e1997ae3933bef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e74cfac0a75fffdaec8b7ed399fbdd/" rel="bookmark">
			C&#43;&#43; STL容器---vector常用方法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. vector基本概念2. vector构造函数3. vector赋值操作4. vector容量和大小5. vector插入和删除6. vector数据存取7. vector互换容器8. vector预留空间 1. vector基本概念 vector数据结构和数组非常相似，也称为单端数组不同之处在于数组是静态空间，而vector可以动态扩展这里的动态拓展并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间（因此应该提前估计数据大小，避免频繁地拷贝和释放原空间）vector容器的迭代器是支持随机访问的迭代器（数组当然可以随机访问） 2. vector构造函数 vector&lt;T&gt; v; : 采用模板实现类实现，默认构造函数
vector&lt;int&gt; v; vector&lt;T&gt; v(int cap); : 指定容器容量, 创建10个默认值为0的容器
vector&lt;int&gt; v(10); vector(v.begin(), v.end()); : 将另外一个vector v[begin(), end())区间中的元素拷贝给本身
vector&lt;int&gt; v1; v1.push_back(1); v1.push_back(2); vector&lt;int&gt; v2(v1.begin(),v1.end());	vector(n, elem);: 构造函数将n个elem拷贝给本身
vector&lt;int&gt; v(3,6);//6 6 6 vector(const vector &amp;vec); : 拷贝构造函数
vector&lt;int&gt; v1(3,6); vector&lt;int&gt; v2(v1); 3. vector赋值操作 vector&amp; operator=(const vector &amp;vec);: 重载等号操作符, 可以将另外一个vector赋值给自身
vector&lt;int&gt; v1(3,6); vector&lt;int&gt; v2=v1; assign(beg, end); : 将[beg, end)区间中的数据拷贝赋值给本身
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e74cfac0a75fffdaec8b7ed399fbdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da9d578e609374dab867d2066379e33/" rel="bookmark">
			Linux脚本练习之script092- 判断输入的是否为IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		script092 题目 注：题目来源于 SHELL16 判断输入的是否为IP地址 。
写一个脚本统计文件nowcoder.txt中的每一行是否是正确的IP地址。
如果是正确的IP地址输出：yes如果是错误的IP地址，四段号码的话输出：no，否则的话输出：error 假设 nowcoder.txt 内容如下：
192.168.1.1 192.168.1.0 300.0.0.0 123 你的脚本应该输出：
yes yes no error 脚本一 循环读取文件中的每一行，通过 awk 命令编程来判断 IP 地址是否正确。首先 -F "." 表示按照点号进行分割，NF 是 awk 命令的内置变量，表示分割后字段域的个数，如果不足四个，则应该输出 "error" 表示错误的。如果字段域的个数是四个，则需要判断每个字段的值是否在 [0, 255] 范围内，如果四个字段的值都在这个范围内则表示是正确的 IP 地址则输出 "yes"；只要有一个字段的值不在这个范围内则表示是错误的 IP 地址则输出 "no"。
#!/bin/bash # 循环读取文件每一行 while read line; do # 用点号分割每一行的内容 echo "${line}" | awk -F "." '{ # 如果切割后的字段域个数不是四个则输出 "error" if(NF!=4){ print "error" } # 如果字段域的个数是四个，则判断 IP 地址是否正确 else{ # 循环每一个字段 for(i=1;i&lt;=NF;i++){ # 判断该字段的范围是否在 [0, 255] 范围内，如果是则进行计数 if($i&gt;=0&amp;&amp;$i&lt;=255){ count++ } } # 最后判断计数变量 count 是否等于 4，如果是则表示该 IP 地址是正确的，否则不正确 if(count==4){ print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da9d578e609374dab867d2066379e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8225023b97ef1243886d6de4a4b3c08a/" rel="bookmark">
			Linux脚本练习之script091-统计VSZ,RSS各自总和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		script091 题目 注：题目来源于 SHELL34 ps分析-统计VSZ,RSS各自总和。
假设命令运行的结果我们存储在 nowcoder.txt 里，格式如下：
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 37344 4604 ? Ss 2020 2:13 /sbin/init root 231 0.0 1.5 166576 62740 ? Ss 2020 15:15 /lib/systemd/systemd-journald root 237 0.0 0.0 0 0 ? S&lt; 2020 2:06 [kworker/0:1H] root 259 0.0 0.0 45004 3416 ? Ss 2020 0:25 /lib/systemd/systemd-udevd root 476 0.0 0.0 0 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8225023b97ef1243886d6de4a4b3c08a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e600f138e4d29fa4b603842152fb7c/" rel="bookmark">
			Ubuntu报错please run Package Manager from the right-click menu or apt-get in a terminal to see
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu系统报错：
解析：
当你尝试通过终端在apt系统上安装某些东西时，会发生这种情况，并且安装失败，没有任何明显的问题。这个问题不仅限于任何一个特定的程序，但它可能会发生在相当多的程序。这是因为问题出在apt系统上，而不是你要安装的程序上。解决这种bug的问题方法有很多，但以下可能是比较快速的解决办法，因此推荐你使用
备份：
在用以下方法解决问题时，你应该使用以下两个命令对两个文件进行备份，以免在过程中出现错误而无法恢复，你可以在顺利解决这个问题后删除备份文件。
备份sources.lis文件sudo cp /etc/apt/sources.list /etc/apt/sources.list.original
备份status文件sudo cp /var/lib/dpkg/status /var/lib/dpkg/status.original 解决办法：
第一步：用Ctrl + Alt + T打开命令行
第二步：输入并执行sudo apt-get install -f 第三步：完成第二步后再输入并执行sudo dpkg --configure -a，然后重复执行一次第二步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8f25c363c6c4f2b0712cabab993ded/" rel="bookmark">
			https到底加密了什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国庆期间闲来无事，写了一个简单的小程序，小程序名称叫做 IT藏经楼。目的是分享这些年自己积累的一些学习材料，方面大家查找使用，包括电子书、案例项目、学习视频、面试题和一些PPT模板。里面所有材料都免费分享。目前小程序中只发布了非常小的一部分，后续会陆续上传分享。当前版本的小程序页面也比较简单，还在逐渐的优化中。
问题描述 都说https是在http和tcp两层之间加密，针对的是传输过程，只有客户端和服务端才能解密，变成明文。但是又有很多人说，https协议下，用get请求不加密，需要用post才会加密，而且这么说的人很多。
我的疑惑就是，如果把整个数据都加密了，是不是无论get和post都是一样的？
因为不懂抓包技术，所以比较好奇。https传输下，抓包者抓到的都是乱码？能抓到URL，或者header之类的信息嘛？
另外再补充一个问题哈，网上还有一种中间人抓包模式？
如果有人在我和服务器之间抓包，伪造证书，搞这个中间人模式，那么浏览器是不是直接提示证书不安全？
如果浏览器也分辨不出来的话，是不是ssl证书质量不过关？
如果ssl证书质量过关，浏览器还无法分辨的话，那https岂不是一点用没有？该抓还抓，该截还截？
正文 首先直接说结论，https安全通信模式，是使用TLS加密传输所有的http协议
通常将TLS加密传输http这个通信过程称为https，如果使用协议封装的逻辑结构来表达就是：
IP + TCP + TLS +【HTTP】，其中用【】括起来的http是完全被加密保护起来的。
既然http被完全加密起来了，那使用https加密传输信息，途径互联网的时候，互联网上的第三方可以知道我们在访问什么网站吗？
可以的！你可能会很惊奇，既然http已经被完全加密了，怎么第三方还会知道我们访问什么网站？
我们在访问一个网站时，比如www.zhihu.com，首先会使用DNS将网站的域名解析成IP地址，然后才可以使用IP地址来网站建立TCP连接、TLS安全连接。由于DNS是不加密的，所以第三方只要通过读取明文的DNS查询与响应报文，就可以知道我们再访问哪些网站。
读者会心生一计，如果我将域名与IP地址的对应关系，保存在本地的host文件里，那么下次就不需要发送DNS查询报文了，那么第三方就无法知道我们在访问什么网站了，对吗？
好主意！但是第三方可以通过服务器的IP地址，使用DNS反向解析得到服务器的域名。
像知乎这样的网站通常会使用边缘加速，一个边缘加速服务器IP地址会host成千上百个网站，使用DNS反向解析会返回上千个域名，对吗？
对的！但是我们与服务器TLS握手时，会在Client Hello报文的“TLS Extension”里携带一个明文的“Server Name Indication”用于指示边缘服务器我们真正要访问哪个网站，第三方读取一下SNI就会得到答案。
即使我们的浏览器有点古老，不支持SNI扩展，第三方就没有办法知道我们访问哪个网站了？
当然可以知道，因为TLS握手时，服务器推送过来的Server Hello里会携带明文的证书，证书里会清清楚楚地标明客户端正要访问什么网站。
现在互联网上大体有以下三种通信模式：
不安全通信
不完全安全通信
安全通信
HTTPS到底加密了什么？ 上面谈到了浏览器访问三种不同的模式，对于不安全通信、安全通信其实非常好理解，它们分别对应http与https。
http的协议封装的逻辑架构是这个样子的：IP + TCP + HTTP
https的协议封装的逻辑架构是这样的：IP + TCP + TLS +【HTTP】
两者都使用http协议通信，只是由于后者有TLS的撑腰（安全加密），才使得https通信安全。
不完全安全通信又代表什么呢？
https+ http
读者会很纳闷，如下图所示，访问微信公众平台明明使用https://的协议前缀（Prefix），应该全部使用https完全安全通信，而不会使用https+ http混合通信，对吗？
理论上是这样的，但现实有时却偏离理论。理想是丰满的，现实却是骨感的。
当我们使用https访问https://www.example.com时，服务器返回的内容是https加密的，这一点问题没有，当浏览器准备显示的时候，发现要显示的内容是一个链接资源，而这个资源的链接地址是：http:// www.example.com，于是浏览器使用不加密的http，去访问服务器，将链接所对应的资源拉下来，然后显示在浏览器上。
最终，我们看到的页面由两部分组成：https的安全页面 + http的不安全页面，我们称之为混合页面（Mixed Content）
为何会产生混合页面？
最早的服务器提供的是http服务，很多资源的链接地址无意中使用了绝对路径，比如“http://www.example.com”,在这个绝对路径中，不仅仅包含了路径“www.example.com/*****”，同时还包含了访问协议类型“http”。
这种绝对路径在http通信用的好好的，用于指示浏览器使用TCP 80端口访问服务器。
当https慢慢成为主流通信方式，越来越多的公司开始从http向https的迁徙，很多服务器跑在了有TLS保护的443端口。
当我们访问“https:// www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b8f25c363c6c4f2b0712cabab993ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1aa26bfee7fa949c4728788c64f6a7/" rel="bookmark">
			CSS&amp;HTML结合案例 - 注册页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;style&gt; *{ margin: 0px; padding: 0px; box-sizing: border-box; } body{ background: url("img/register_bg.png") no-repeat center; padding-top: 150px; background-size:cover; } .rg_layout{ width: 900px; height: 500px; border: 8px solid #eeeeee; background-color: white; /*让div水平居中显示*/ margin: auto; margin-bottom: 100px; box-sizing: border-box; } .rg_left{ /*border: 1px solid red;*/ float: left; margin: 15px; } .rg_left &gt; p:first-child{ color: #ffd026; font-size: 20px; } .rg_left &gt; p:last-child{ color: #a6a6a6; font-size: 20px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1aa26bfee7fa949c4728788c64f6a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df232156e4107a1d5c2ee1ac7bac2d4e/" rel="bookmark">
			STA系列 - 芯片的鲁棒性OCV之set_time_derate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景例子如何实现什么是early？什么是late？建立时间的OCV分析OCV for hold check参考文章 背景 芯片制造过程中，MOS间差异必然存在。library中的cell delay是在某个固定的PVT（operating condition）下仿真得出的。而实际上在芯片内部由于工艺偏差、电压降、温度变化，cell的delay并不是一个固定值，而是一个随机值，遵循高斯分布或门特卡洛分布，在STA中用OCV来模拟这一特征。OCV全称on chip variation，用于描述不同管子间由于工艺偏差、电压降、温度变化引起的delay变化，也用于描述工艺偏差引起的net厚度宽度的变化从而导致net的RC变化。
————————————————
(on-chip variation) 是指在同一个芯片上，由于制造工艺和环境等原因导致芯片上各部分特征不能完全一样，从而造成偏差，对时序分析造成影响。这些偏差对互连线和cell的延时都是有影响的。 由于 OCV 对时钟和数据路径的影响可能不同，时序验证可以通过使发射和捕获路径的 PVT 条件略有不同来模拟 OCV 效应。 STA 可以通过 减免（derate） 特定路径的延迟来包含 OCV 效应，也就是说，通过使这些路径更快或更慢，然后使用这些变化来验证设计的行为。单元延迟或线延迟或两者都可以降额以模拟 OCV 的影响。
time derate（时序增减因子），在芯片生产过程中，由于刻蚀，不同点的温度，金属不均匀，串扰，晶体管沟道长度等影响因素，导致片上各个位置单元延迟不一样。因此我们需要一个缩放因子来让设计更加严格。
timing derate 是计算OCV的一种简单方法，在某单一条件(BC-WC)下，把指定path的delay放大或者缩小一些，这个比率就是derate。
best-case worse-case简称BC WC mode。
需要注意的是：考虑time derate需要在某个单一条件下，比如说BC或者WC条件下，把指定path的延迟再放大或者缩小一点，要么是BC，要么是WC，不要把BC和WC混在一起，再OCV，那样太过于悲观。
————————————————
例子 如上图所示，因为在芯片中，由于工艺制成，有可能绿色路径的buffer延时有一些不可控的变动因素，在棕色的路径中的延时也有一些不可控的变动因素，所以为了和实际吻合，我们在分析setup的时候，在同一个工艺库中，绿色的部分，用最大的延时，而在棕色部分，用最小的延时。这样对setup的check也是非常严苛的。
如何实现 如上图所示，使用
set_timing_derate -early 0.8 set_timing_derate -late 1.1 也就是说，0.8代表缩小20%，late代表增加10%
什么是early？什么是late？ 如何选取path?
对于setup Analysis:
Launch clock : late pathData path : late pathCapture clock : early path 因为launch clock+Data path 我们都希望为latest（越晚OCV越糟糕）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df232156e4107a1d5c2ee1ac7bac2d4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85864282754ea6e2c87fb44afb40709/" rel="bookmark">
			Microsoft Office无法验证此应用程序的许可证怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Office无法验证此应用程序的许可证怎么解决 症状 启动 Microsoft Office 应用程序（如 Outlook、Word、Excel 或 PowerPoint）时，您可能会收到以下错误消息：
Microsoft Office无法验证该产品的许可证，请使用控制面板修复Office程序 解决方法 1.选择开始，输入 regedit，打开注册表
2.导航到
HKEY_USERS\S-1-5-20 3.右键属性，选择 权限，添加 everyone
​ 对everyone用户添加所有权限
重新打开offices就会发现没有提示，问题就解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a829ad9eb133106d8f64433245a60179/" rel="bookmark">
			实验四 Python字典和集合的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
1．掌握字典和集合的使用和允许操作。
2．熟悉在不同情况下如何选用合适的数据类型。
二、实 验 内 容
1.创建由’Monday’~’Sunday’7个值组成的字典，输出键列表，值列表以及键值列表，运行效果如图。
代码：
#创建7个值组成的字典，输出键列表，值列表以及键值列表，运行效果如图。 dict={1:'Mon',2:'Tues',3:'Wed',4:'Thur',5:'Fri',6:'Sat',7:'Sum'} for keys in dict.keys(): print(keys,end=' ',) print() for values in dict.values(): print(values,end=' ') print() for items in dict.items(): print(items,end=' ') 结果：
2. 学生基本信息存放在如下字典中：DictStudent = {"郭靖": ["男", 19], "黄蓉": ["女", 18], "杨康": ["男", 18], "李莫愁": ["女", 20], "穆念慈": ["女", 19], "瑛姑": ["女", 19]}。
请分别统计男、女生人数，并查找所有年龄超过18岁学生的姓名。
代码：
DictStudent = {"郭靖": ["男", 19], "黄蓉": ["女", 18], "杨康": ["男", 18], "李莫愁": ["女", 20], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a829ad9eb133106d8f64433245a60179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3aef1d260f77cd4d28a8acbb89bfbef/" rel="bookmark">
			【Windows安装WSL】WSL中安装Ubuntu发行版，提示占位程序接收到错误数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在管理员终端输入wsl --install命令，如果提示“无法解析服务器的名称或地址”，则输入 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 如果wsl命令仍然不能使用，则需要配置DNS，在网络和共享设置里，选择当前连接，设置IPv4的属性，更改DNS服务器
之后在尝试即可
3. 在 WSL 中安装 Debian 发行版，首先打开 Microsoft Store，搜索 Ubuntu 22.04，点击Get
4. 安装完成之后打开，创建用户。进入系统以后，可以在 WSL 中运行 cat /etc/issue 命令来确认安装的系统版本：
子系统中和发行版中都提示占位程序有问题
首先从设置-应用中卸载所有和WSL相关的软件，包括Ubuntu发行版，然后重启电脑。
利用管理员模式CMD，输入“wsl --update"更新内核，然后”wsl --list --online“列出可下载版本，最后”wsl --install --d Ubuntu-20.04"下载发行版，完全安全好后提示我要加一个unix user name，这里我在CMD中输入“netsh winsock reset”，重启系统，再开机就可以正常进入Ubuntu了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af496090ed3e03397abdbc4e509b22a3/" rel="bookmark">
			Java：Java中方法的定义和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、方法的定义、介绍、定义 1. java中的方法：就相当于c语言中的函数
什么是方法？
方法就是一段代码片段，这个片段可以完成特定的功能，并且可以重复利用。
从入口程序那里开始调用，一掉就开始执行指定的方法。
可以使用如下的语法完成
public static 返回类型 方法名称([参数类型 变量, ......]) { 方法体代码; [return [返回值];] } 2. 在定义方法的时候对于方法的返回值有一下的两类：
void：没有返回值；
数据类型（基本类型，引用类型）。
范例： 定义一个没有返回值，没有参数的方法
public class TestDemo { public static void main(String[] args) { print();	//主方法里面直接调用方法 } public static void print() { System.out.println("Hello	World!"); //定义方法 } } 范例： 定义一个有参数无返回值的方法
public class TestDemo { public static void main(String[] args) { print("Hello");	//主方法里面直接调用方法 print("	world"); print("!"); } public static void print(String msg) {	//定义方法 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af496090ed3e03397abdbc4e509b22a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee2dced50b5d01f85f986a45b6bdeed9/" rel="bookmark">
			28nm Memory Compiler开发（一）OpenRAM论文阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract 内存设计的可用性常常抑制了计算机系统的研究。现有的流程设计套件（PDK）经常缺少存储器编译器，而昂贵的商业解决方案仅提供具有不变单元，有限配置和限制性许可证的存储器模型。手动创建内存可能既费时又乏味，而且设计通常不够灵活。本文介绍了OpenRAM，一种开放源代码的内存编译器，它提供了一个平台，用于跨各种技术，大小和配置生成，表征和验证可构造内存设计。它可以进行计算机体系结构，片上系统设计，存储器电路和器件研究以及计算机辅助设计的研究。
Introduction 静态随机存取存储器（SRAM）已成为嵌入在所有片上系统（SoC），专用集成电路（ASIC）和微处理器设计中的标准组件。它们的广泛应用导致对电路设计和存储器配置的各种要求。但是，手动设计非常耗时。内存的规则结构很好地导致了自动化，该自动化迅速产生了大小和配置变化，但是要使用多种技术和工具方法来开发这种结构则具有挑战性。此外，存储器设计在总体系统性能和成本中起着重要作用，因此优化很重要。因此，内存编译器是至关重要的工具。
大多数学术IC的设计方法受到存储器可用性的限制。代工厂和供应商可提供许​​多标准单元工艺设计套件（PDK），但这些PDK通常不随存储器阵列或存储器编译器一起提供。如果内存编译器是免费提供的，则它通常仅支持不可制造的通用处理技术。由于学术经费的限制，商业行业的解决方案通常对研究人员不可行。另外，这些商业解决方案在定制存储器大小和存储器的特定组件方面受到限制。 PDK可能具有请求“黑匣子”存储模型的选项，但它们也不可修改且可用配置有限。这些限制和许可问题使得无法对真实世界的记忆进行比较和试验。
学术研究人员能够设计自己的自定义存储器，但这可能是一项繁琐且耗时的任务，并且可能不是该研究的预期目的。通常，存储器设计是研究项目所需的最基本的要求，因此，存储器设计通常较差且未进行优化。在存储器研究中，比较存储器性能和密度时通常不考虑外围电路。缺少可定制的编译器，使得研究人员难以对单行或一列存储单元以外的电路和方法进行原型设计和验证。
OpenRAM项目旨在为内存提供一个开放源代码的内存编译器开发框架。它以通用的45nm技术和可制造的可扩展CMOS（SCMOS）提供参考电路和物理实现，但也已使用一个简单的技术文件将其移植到了多个商业技术节点上。 OpenRAM还包括一种特性分析方法，因此它不仅可以生成电路和布局，还可以生成时序和功率特性结果，而又与特定的商用工具无关。最重要的是，OpenRAM完全可以由用户修改，因为所有源代码都是开源的：
https://openram.soe.ucsc.edu/
本文的其余部分安排如下：第2节提供了有关先前内存编译器的背景知识。第3节介绍了OpenRAM中的参考存储器体系结构。第4节专门介绍了OpenRAM存储器编译器的实现和主要功能。在第5节中，显示了针对不同大小和技术的存储器的面积，时序和功耗的分析。最后，本文在第6节中进行了总结。
Background 存储器编译器已被用于电子设计自动化（EDA）设计流程中，以缩短设计时间，远远早于当代的编译器[2，9]。但是，这些编译器通常不可移植，因为它们不过是帮助设计人员的快速脚本。移植到新技术本质上需要重写脚本。但是，在不同技术之间移植设计时，设计生产率的提高导致了对内存阵列编译器的更多研究。
随着技术进入深亚微米（DSM）时代，由于降低了静态噪声裕量（SNM），增加了制造变异性并增加了泄漏功耗，存储器设计已成为电路设计中最具挑战性的部分之一。由于必须适应不断变化的技术，这极大地增加了内存编译器的复杂性。同时，设计方法从硅编译器转变为需要大型优化库的标准单元布局和布线方法。在这段时间内，工业界开始使用标准单元库和内存编译器的第三方供应商，这些供应商允许其重复使用以摊销开发成本。这些下一代存储器编译器提供了硅验证功能，使设计人员可以专注于他们的新设计，而不是诸如存储器生成之类的耗时任务。
现代内存编译器已被业界广泛使用，但是内部操作通常是隐藏的。几家著名的公司和代工厂都向其客户提供了内存编译器。这些存储器编译器通常允许客户在签署许可协议后查看前端仿真，时序/功率值和引脚位置。诸如布局之类的后端功能通常直接提供给晶圆厂，并且仅向用户收取许可费。
具体来说，Global Foundries免费提供前端PDK，但不提供后端详细视图[6]。 Faraday Technologies提供了一个“黑匣子”设计套件，使用户不知道内部存储器设计的详细信息[5]。 Dolphin Technology提供了可以为多种技术创建RAM，ROM和CAM的闭源编译器[4]。这些大多数商业编译器不允许客户更改基本设计，受公司许可的限制，并且通常需要付费。这使得它们实际上不可用，对于许多学术研究项目没有用处。
除了行业提供的内存编译器之外，各种研究小组还发布了用于生成内存的脚本。但是，这些设计未经硅验证，通常仅由简单的结构组成。例如，FabMem能够创建小型阵列，但高度依赖于Cadence设计工具[15]。脚本不提供任何表征功能，并且不能轻松地与商业布局和路线工具集成。
Synopsys通用内存编译器（GMC）是学术界最近另一个有希望的解决方案[7]。该软件提供了示例通用库，例如​​Synopsys的32 / 28nm和90nm抽象技术，并且可以为这些技术生成整个SRAM。 GMC生成GDSII布局数据，SPICE网表，Verilog和VHDL模型，时序/电源库以及DRC / LVS验证报告。但是，不建议将GMC用于制造，因为它支持的技术不是真实的。其唯一目的是帮助VLSI课程的学生学习在设计流程中使用内存的知识。
学术界已经进行了多种尝试来实现不受限制的存储器编译器：微电子研究所的SRAM IP编译器[22]，东南大学电子科学与工程学院的存储器IP编译器[11]和清华大学的低功耗SRAM编译器[21]。这些都是内存编译器的所有方法和设计流程，但没有公开发布。
Architecture OpenRAM SRAM体系结构基于一组带有外围电路和控制逻辑的存储单元，如图1所示。这些进一步细分为八个主要模块：位单元阵列，地址解码器，字线驱动器，列多路复用器，预充电电路，读出放大器，写驱动器和控制逻辑。
位单元阵列：在OpenRAM的初始版本中，6T单元是默认存储单元，因为它是SRAM器件中最常用的单元。 6T单元与相邻的字线和位线平铺在一起以构成存储阵列。使用多列数据字使位单元阵列的长宽比尽可能为正方形。存储单元是针对每种技术的定制设计的库单元。其他类型的存储单元（例如7T，8T和10T单元）可以用作6T单元的替代方案。
地址解码器：地址解码器将行地址位作为输入，并声明适当的字线，以便可以从中读取或写入正确的存储单元。地址解码器位于内存阵列的左侧，并横跨该阵列的垂直长度。可以使用不同类型的解码器，例如附带的动态NAND解码器，但OpenRAM的默认选项是分层CMOS解码器。
字线驱动器：字线驱动器作为缓冲区插入到地址解码器和内存阵列之间。字线驱动器的大小取决于存储器阵列的宽度，以便它们可以驱动位选择器阵列上的行选择信号。
列多路复用器：列多路复用器是一个可选块，使用低位地址位选择一行中的关联字。列复用器是动态生成的，可以省略，也可以有2或4个输入。较大的列复用器是可能的，但在存储器中并不经常使用。也有用于多级树复用器的选项。
位线预充电：该电路在时钟的第一阶段为读操作预充电位线。预充电电路位于存储阵列中每一列的顶部，并均衡位线电压，以便读出放大器可以感测两条位线之间的电压差。
读出放大器：差分读出放大器用于在执行读取操作时感测存储单元位线之间的电压差。读出放大器使用位线隔离技术来提高性能。如果不使用列多路复用器，则将读出放大器电路放置在列多路复用器或存储器阵列下方。每个输出位都有一个读出放大器。
写驱动器：写驱动器将输入数据信号发送到位线上以进行写操作。写驱动器为三态，因此可以将它们放置在列多路复用器/存储器阵列与读出放大器之间。每个输入数据位都有一个写驱动器。
控制逻辑：OpenRAM SRAM体系结构使用系统时钟（clk）合并了标准同步存储器接口。控制逻辑使用外部提供的低电平有效输出使能（OEb），芯片选择（CSb）和写使能（WEb）将多个SRAM组合为更大的结构。在内部，OpenRAM编译器可以具有1、2或4个存储库，以分摊控制逻辑和外围电路的面积/功耗。
所有输入控制信号均使用主从（MS）触发器（FF）存储，以确保信号在整个时钟周期内均有效。在读取操作期间，如图2（a）所示，在负时钟沿（周期的后半部分）之后可以使用数据。为了避免死循环而降低性能，在OpenRAM时序中使用了零总线周转（ZBT）技术。由于没有等待状态，因此ZBT可以实现更高的内存吞吐量。在ZBT写期间，数据在负时钟边沿之前设置，并在负边沿捕获。图2（b）显示了写操作期间输入信号的时序。
内部控制信号是使用复制位线（RBL）结构生成的，用于读出放大器使能和输出数据存储[1]的时序。在低于100nm的技术中，由于存在工艺可变性，RBL会在准确的时间打开检测放大器。
Implementation OpenRAM的方法是使用Python编程语言中的面向对象方法实现的。 Python是一种简单但功能强大的语言，易于学习且非常易读。而且，Python使得可移植到大多数操作系统。除DRC / LVS工具外，OpenRAM没有其他依赖项，但是如果工具不可用，则会禁用警告并被禁用。除了系统可移植性之外，OpenRAM还可以跨多种处理技术进行转换。这是通过使用通用例程基于所有技术的通用功能来生成内存来实现的。为了促进用户修改和技术互操作性，OpenRAM提供了45nm FreePDK45的参考实现[17]和使用MOSIS可扩展CMOS（SCMOS）设计规则的可制造选项[13]。 FreePDK45使用现代技术中存在的许多设计规则，但是不可制造，而SCMOS可以使用MOSIS铸造服务来制造设计。 SCMOS不是机密信息，并且包含使用它的实现，但是，它不包含许多高级DSM设计规则。
OpenRAM也已移植到其他商业技术，但是由于许可问题，这些技术未直接包含在内。 OpenRAM的框架分为“前端”和“后端”两种方法，如图3所示。前端具有编译器和特征描述器。编译器根据用户输入生成SPICE模型及其GDSII布局。表征器调用SPICE仿真器以产生时序和功率结果。后端使用从GDSII布局中提取的spice网表，用于生成带注释的时序和功率模型。
基本数据结构 OpenRAM中的设计模块是从设计类（design.py）派生的。design类具有名称，SPICE模型（网表）和layout。 SPICE模型和layout都从分层类继承其功能。design类还提供继承的功能，以对任何子设计执行DRC和LVS验证，以进行分层调试。
design类从spice类（hierarchy spice.py）派生而来，该类具有维护电路层次结构的数据结构。此类维护design实例，它们的引脚，它们的连接以及辅助功能，以维护电路层次结构的结构和连通性。
design类还派生自布局类（层次结构layout.py）。此类包含布局中子模块的物理实例的列表，以及用于简单对象（例如当前层次结构级别中的形状和标签）的结构。此外，还有一些辅助功能可以维护物理布局结构。 OpenRAM具有集成的自定义GDSII库，用于读取，写入和操作GDSII文件。该库最初称为GdsMill [20]，现已针对OpenRAM进行了修改，调试和扩展。授予了将GdsMill源包含在OpenRAM中的全部权利，但是为了使接口更容易并且可以移植到其他物理布局数据库，OpenRAM实现了抽象GdsMill库的几何包装类（geometry.py）。
工艺和工具的可移植性 通过使用包含工艺特定信息，规则和库单元的工艺目录，Open RAM可以做到独立于工艺。需要诸如设计规则检查（DRC）规则和GDS层映射之类的工艺参数，以确保动态生成的设计是DRC clean的。定制设计的库单元（例如存储单元和读出放大器）也放置在此目录中。一个非常简单的设计规则参数文件具有用于构造基本互连和晶体管器件的最重要的设计规则。提供了FreePDK45和SCMOS参考技术。
OpenRAM使用一些自定义设计的库原语作为工艺输入。由于密度非常重要，因此每种工艺都预先设计了以下单元：6T单元，读出放大器，主从触发器，三态门和写驱动器。所有其他单元都是使用可参数化的晶体管和栅极图元即时生成的。
OpenRAM可用于各种技术，因为它创建了这些技术通用的内存设计的基本组件。对于具有特定设计要求的技术，例如特殊的井接触，用户可以在工艺目录中include 回调函数。这样做是为了使主编译器不依赖于特定工艺。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee2dced50b5d01f85f986a45b6bdeed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d28800a0cf72a594114e90323375bd3/" rel="bookmark">
			达梦数据库to_date报错：“非法的时间日期类型数据”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 最近在数据库升级后，发现有个语句使用to_date(‘2022-01-11 11:22:33’,‘yyyy-mm-dd’)这样格式报错：”非法的时间日期类型数据“。
原因分析 通过查看两个对应版本的手册，查找发现在新版本中对于to_date转换的字符串数据的默认处理比较严格。通过DATETIME_FAST_RESTRICT参数来控制date的格式为FAST格式时，to_date中字符串是否允许带时间。默认该参数不允许带时间，带时间会报错。
以前这块处理比较宽松，新的版本中DATE默认FAST格式（默认年月日），字符串转为date的时候，要求更严格，默认为1，不允许年月日字符串带时间。设置为0之后，允许带时间，可以支持to_date(‘2021-11-16 11:15:00’,‘yyyy-mm-dd’) 这种格式的语句
处理办法 修改DATETIME_FAST_RESTRICT参数值为0。语句如下：
sp_set_para_value(1,‘DATETIME_FAST_RESTRICT’,0);
总结 1、在老版本特别是2021年4月之前的版本，在进行版本升级时需要注意一下可能会遇到这个问题。
2、在从MySQL迁移到达梦的系统，也需要关注下这个参数，可以调整为0。
当然，如果业务系统使用过程中没有遇到问题，可以不用修改该参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b012c091f8235173f2b3e7d351904782/" rel="bookmark">
			mybatis plus &#43; shardingsphere读写分离&#43;分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求场景 在实际业务中，高并发的数据库中，单个数据库性能受限，尤其是在有读写夹杂在一起的时候。我们都知道，系统中大部分都是读操作，写操作是占用比较小的部分的，所有就有了读写分离的操作，读可以专门读的数据库，而写操作（CUD）就专门在主数据库中进行。
而分表则是为了避免单个的表的数据量太大，根据ali开发规范来说，一个表的上限是2G，数据量上限为500w，但是通常来说虽然我们不一定完全遵循，但是2000w条数据，对于系统来说也是比较大了，而2000w数据来说是非常正常的，一些比如日志表啥的，动不动是10G+以上的数据，所以分表也是非常必要的。
方案 仅仅是主从分离的话，可以使用mybatis plus系列的dynamic-datasource，参考data-source来实现主从分离，非常方便，但是暂时没有分表功能。所以我们使用mybaits plus + shardingsphere方案
方案特点dynamic-datasource简单方便，支持开发指定从库的数据查询 ，不支持分表shardingshpere功能强大，比较复杂，支持分表，暂时不支持指定库操作 什么是mybatis plus mybatis plus是国内基于mybatis做出一个开源工具包，
是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。
简单来说就是代替mybatis的一个orm访问工具，但是功能更强大，这里不多赘述，因为我们就是用它的orm功能，其他的查看文档。
官方文档
什么是shardingsphere 官方文档
Apache ShardingSphere 是一款分布式的数据库生态系统， 可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强。
Apache ShardingSphere 设计哲学为 Database Plus，旨在构建异构数据库上层的标准和生态。 它关注如何充分合理地利用数据库的计算和存储能力，而并非实现一个全新的数据库。 它站在数据库的上层视角，关注它们之间的协作多于数据库自身。
shardingSphere的功能非常强大，但是我们暂时只需要使用到sharding-jdbc，sharding-jdbc时什么呢？
ShardingSphere-JDBC 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务
我的理解就是jdbc api的重写和封装。
系统结构 spring bootmybatis plusshardingsphere
maven依赖如下： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!-- &lt;version&gt;8.0.21&lt;/version&gt; 版本Spring-Boot-Parent中已带 --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b012c091f8235173f2b3e7d351904782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774f091edde0e976c476d4d6fa8621ef/" rel="bookmark">
			rosrun tf view_frames编译时出现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Listening to /tf for 5.0 seconds
Done Listening
b'dot - graphviz version 2.43.0 (0)\n'
Traceback (most recent call last):
File "/opt/ros/noetic/lib/tf/view_frames", line 119, in &lt;module&gt;
generate(dot_graph)
File "/opt/ros/noetic/lib/tf/view_frames", line 89, in generate
m = r.search(vstr)
TypeError: cannot use a string pattern on a bytes-like object
解决方法：在终端中输入：
sudo gedit /opt/ros/noetic/lib/tf/view_frames 然后在打开的文档中按CTRL+F查找 m = r.search(vstr)
在其上方加上：vstr=str(vstr)
保存，重新运行rosrun tf view_frames命令，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16ad29be78ec74fc187252ccd5b449d/" rel="bookmark">
			01_Linux 下的应用程序是如何调用驱动程序的?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux 下的应用程序是如何调用驱动程序的 Linux 应用程序对驱动程序的调用如下图所示：
在 Linux 中一切皆为文件，驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过对这个名为“/dev/xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。比如现在有个叫做/dev/led 的驱动文件，此文件是 led 的驱动文件。应用程序使用 open 函数来打开文件/dev/led，使用完成以后使用 close 函数关闭/dev/led 这个文件。open 和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取 led 灯的状态，就用 read 函数从驱动中读取相应的状态。
应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开/dev/led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间陷入到内核空间，这样才能实现对底层驱动的操作。open、close、write 和 read 等这些函数是有 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分。当我们调用 open 函数的时候流程如下图所示：
其中关于 C 库以及如何通过系统调用陷入到内核空间这个我们不用去管，我们重点关注的是应用程序和具体的驱动，应用程序使用到的函数在具体驱动程序中都有与之对应的函数，比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数。每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 include/linux/fs.h 中有个叫做 file_operations 的结构体，此结构体就是 Linux 内核驱动操作函数集合，内容如下所示：
struct file_operations { struct module *owner;//owner 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。 loff_t (*llseek) (struct file *, loff_t, int);//llseek 函数用于修改文件当前的读写位置。 ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);//read 函数用于读取设备文件。 ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);//write 函数用于向设备文件写入(发送)数据。 ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); unsigned int (*poll) (struct file *, struct poll_table_struct *);//poll 是个轮询函数，用于查询设备是否可以进行非阻塞的读写。 long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);//unlocked_ioctl 函数提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。 long (*compat_ioctl) (struct file *, unsigned int, unsigned long);//compat_ioctl 函数与 unlocked_ioctl 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是unlocked_ioctl。 int (*mmap) (struct file *, struct vm_area_struct *);//mmap 函数用于将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。 int (*open) (struct inode *, struct file *);//open 函数用于打开设备文件。 int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *);//release 函数用于释放(关闭)设备文件，与应用程序中的 close 函数对应。 int (*fsync) (struct file *, loff_t, loff_t, int datasync);//fsync 函数用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。 int (*fasync) (int, struct file *, int);//fasync 函数与 fsync 函数的功能类似，只是fasync 是异步刷新待处理的数据。 int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *); #endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t, u64); ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *, u64); } __randomize_layout; 在字符设备驱动开发中最常用的就是上面这些函数，关于其他的函数大家可以查阅相关文档。我们在字符设备驱动开发中最主要的工作就是实现上面这些函数，不一定全部都要实现，但是像 open、release、write、read 等都是需要实现的，当然了，具体需要实现哪些函数还是要看具体的驱动要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4640c271abfde990a826ef19a02016/" rel="bookmark">
			00_Ubuntu系统入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Ubuntu系统安装
1.1 VMware15安装虚拟机不兼容，无法打开
1.2 Ubuntu联网问题
二、Ubuntu系统入门
2.1 Ubuntu系统初体验
2.2 Ubuntu终端操作
2.3 shell操作
2.3.1 shell简介
2.3.3 常用shell命令
2.4 APT下载工具
2.5Ubuntu 下文本编辑
2.5.1 安装 VIM 编辑器:
2.5.2 vim编辑器的使用
2.6 Linux 文件系统
2.6.1 Linux 文件系统简介以及类型
2.6.2 Linux 文件系统结构
2.6.3 文件操作命令
2、文件夹创建命令—mkdir
2.6.4 命令行进行文件的压缩和解压缩
2.6.5 文件查询和搜索（没怎么用过）
2.6.6文件类型
2.7 Linux 用户权限管理
2.7.1Ubuntu 用户系统
2.7.2权限管理
2.7.3 权限管理命令
2.8 Linux磁盘管理
2.8.1 Linux磁盘管理基本概念
2.8.2 磁盘管理命令
三、Linux C 编程入门
3.1 Hello World！
3.1.1编写代码
3.1.2 编译代码
3.2 GCC编译器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a4640c271abfde990a826ef19a02016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce1961c9866adb962d11b5a04ebd17a/" rel="bookmark">
			envi神经网络分类原理,ENVI神经网络分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、envi 中几种分类方法的参数怎么设置？ envi 中几种分类方法的参数设置方法如下：
1、平行六面体
（1）在主菜单中，选择Classification-&gt;Supervised-&gt;Parallelpiped，在文件输入对话框中选择TM分类影像，单击OK按钮打开Parallelpiped参数设置面板。
（2）SelectClasses from Regions：单击Select All Items按钮，选择全部的训练样本。
（3）Set Max stdev from Mean：设置标准差阈值，有三种类型：
l None：不设置标准差阈值；
l Single Value：为所有类别设置一个标准差阈值；
l Multiple Values：分别为每一个类别设置一个标准差阈值。
选择Single Value，值为3。
（4）单击Preview，可以在右边窗口中预览分类结果，单击Change View可以改变预览区域。
（5）选择分类结果的输出路径及文件名。
（6）设置Out Rule Images为Yes，选择规则图像输出路径及文件名。
（7）单击OK按钮执行分类。
2、最小距离
（1）在主菜单中，选择Classification-&gt;Supervised-&gt; Minimum Distance，在文件输入对话框中选择TM分类影像，单击OK按钮打开Minimum Distance参数设置面板。
（2）SelectClasses from Regions：单击Select All Items按钮，选择全部的训练样本。
（3）Set Max stdev from Mean：设置标准差阈值，有三种类型：
l None：不设置标准差阈值；
l Single Value：为所有类别设置一个标准差阈值；
l Multiple Values：分别为每一个类别设置一个标准差阈值。
选择Single Value，值为4。
（4）Set Max Distance Error：设置最大距离误差，以DN值方式输入一个值，距离大于该值的像元不被分入该类（如果不满足所有类别的最大距离误差，它们就不会被归为未分类类(unclassified)）。也有三种类型，这里选择None。
（5）单击Preview，可以在右边窗口中预览分类结果，单击Change View可以改变预览区域。
（6）选择分类结果的输出路径及文件名。
（7）设置Out Rule Images为Yes，选择规则图像输出路径及文件名。
（8）单击OK按钮执行分类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce1961c9866adb962d11b5a04ebd17a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e2f00431bb634373eaacbf4ebd9daa/" rel="bookmark">
			获取JSON数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一、使用JSON工具将对象序列化成Json，常用工具有Jackson,fastjson,gjson,然后利用HttpServletResponse获取response.getOutputStream(),或者PrintWriter()fhf接输出
以Jackson为例：
引包
&lt;!-- json依赖包 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.4&lt;/version&gt; &lt;/dependency&gt; 前端：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="${path}/resource/js/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function(){ $(".testJson").click(function(){ var url=this.href; alert(url) var args={}; //ajax,url:目标地址 ; args:带出去的参数 ;data:目标方法返回的值 $.post(url,args,function(data){ for(var i=0; i&lt;data.length;i++){ var userid=data[i].id; var username=data[i].name; alert(userid+":"+username); } }); return false; }); }); &lt;/script&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;testJson&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;a class="testJson" href="${path}/getJson"&gt;传统方式获取json数据测试&lt;/a&gt; &lt;br&gt;&lt;br&gt; &lt;a class="testJson" href="${path}/getJson2"&gt;MVC方式获取json数据测试&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 后台：
import java.io.PrintWriter; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4e2f00431bb634373eaacbf4ebd9daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43778f22806c492fcace7bc85e8cb984/" rel="bookmark">
			【测试面试】2022年软件测试面试题大全（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言1、提交一个bug后开发说这不是bug你会怎么处理？2、你会使用什么缺陷管理工具？3、测试过程中遇到哪些阻力？4、开发人员压缩了我们测试的时间怎么办？5、产品人员经常变更需求该怎么办？6、需求评审有哪些人员参加？7、测试计划是谁编写的？8、你觉得怎么样才能写好测试用例？9、接口测试用例的设计要点有哪些？10、post和get有什么区别？11、你会使用哪些抓包工具？12、使用抓包工具做什么？13、怎么判断一个bug是前端问题还是后端问题？14、总结 前言 没点真本事真技术，没点面试经验，不了解点职场套路，如何过五关斩六将？
如何打败面试官？
如何拿下那梦寐以求的offer？
考核你能力的标准面试就是第一道关
如果你的跳槽意向已经很确定，那么请往下看！……跳槽最重要的一步自然是面试
1、提交一个bug后开发说这不是bug你会怎么处理？ 这个问题其实只要依据我们测试的需求文档来回答就可以了，因为需求文档上如果写的很明确那么开发就无法反驳。
但是有时候需求文档也没明确说明，那么这时候我们就需要让产品人员来进行需求的确认，所以不需要和开发人员进行争辩，我们本着实事求是的态度就好。
2、你会使用什么缺陷管理工具？ 缺陷的常用管理工具有很多，比如:禅道、TAPD、jira、Mantis等等，但是对于大部分测试人员而言不可能每个都熟悉。
所以我们在回答的时候就说我们最熟悉的那个就好，因为无论是什么缺陷管理工具它对缺陷管理的流程都是相同的，所以测试人员都能很快上手使用。
3、测试过程中遇到哪些阻力？ 在测试中肯定会遇到各种阻力，比如开发人员修复bug的时间比预期的要长然后压缩了我们测试的时间，再或者产品人员经常进行需求的变更导致进度缓慢，这时候面试官肯定会问那遇到这种情况你们是怎么处理的？
4、开发人员压缩了我们测试的时间怎么办？ 这种情况在很多公司都很常见，其实作为一个有预见性风险意识的测试负责人应该在做计划的时候就要预估到这种情况，那么在计划的时候就要为测试争取尽量多的测试时间，有多余的时候那么我们的空间也大些。
很多人觉得实在没办法了那就只能让测试人员加班，其实很多大公司遇到这种情况都可以推迟上线的，因为要保障产品的质量。
5、产品人员经常变更需求该怎么办？ 这是大部分中小型公司测试人员遇到最头痛的问题，因为这意味着你的很多工作都可能被推翻了都要重新开始做，这时候我们和开发人员是同一战线的。
最好的处理办法个人认为是制定一套需求变更流程，然后在时间充足的前提下需要经过开发、测试的同意才能进行需求变更，负责我们总是给产品擦屁股，这样有了规范的流程产品人员在设计需求的时候就会经过深思熟虑了。
6、需求评审有哪些人员参加？ 听很多小伙伴说他们公司开需求评审会议的时候都不叫我们测试一起的，那说明公司对测试真的不够重视。
需求评审是开发和测试最早接触和熟悉项目的机会，所以测试、开发都必须参加的，甚至大版本更新的评审会议经理、总监都需要参加。
7、测试计划是谁编写的？ 不少小伙伴为了给面试官一个良好的印象就直接回答我写的或者我们经理写的，但是公司里面其实都是该项目的测试负责人(一般都是测试组长)写的
8、你觉得怎么样才能写好测试用例？ 1、充分熟悉需求文档
2、使用各种测试方法设计用例
3、考虑到各种异常情况
4、保证功能点100%覆盖
5、编写时语言精简
6、考虑到相关联的一些功能
9、接口测试用例的设计要点有哪些？ 对于这个问题我们可以从接口的组成来进行分析，一个接口主要有请求地址、请求方法、请求参数，其中请求地址和方法都是固定的，
所以我们主要应该从请求参数入手，主要可以从以下几个方面考虑:
1、参数字段个数：必填字段和可选填
2、参数合法性：输入输出合法、非法参数
3、边界：请求参数边界值等
4、容错能力：大容量数据、频繁请求、重复请求（如：订单）、异常网络等的处理
5、响应数据校验：断言、数据提取传递到下一级接口
6、逻辑校验：如两个请求的接口有严格的先后顺序，需要测试调转顺序的情况
7、性能：对接口模拟并发测试，逐步加压，分析瓶颈点
8、安全性：构造恶意的字符请求，如：SQL注入、XSS、敏感信息、业务逻辑（如：跳过某些关键步骤；未经验证操纵敏感数据）
10、post和get有什么区别？ 这个问题应该是每一个做接口测试人员都能回答的问题，但是要注意说到重点：
1、get方法的参数是在URL中，post的参数是在body中 (本质区别)
2、get的参数是不加密的，post的是加密的
3、get方法的安全性没post的高
4、get方法能被缓存而post不可以
5、GET请求在URL中传送的参数是有长度限制的，而POST没有。
当然还有其他的很多区别，但是回答这几个主要的就差不多了。
11、你会使用哪些抓包工具？ 抓包工具有很多种，但是我们技术人员最常用的不外乎就是Fiddler、青花瓷、F12这几种，所以选一个你自己最常用的就可以了。
当然面试官接下来的问题多半会问你为什么会用抓包工具？公司不是有接口文档吗？
12、使用抓包工具做什么？ 对于中大型公司里面的开发人员都会编写好有完整的接口文档，那我们做接口测试的时候对照接口文档不就可以了吗？
所以对于还没有真正接口项目经验的小伙伴就不知所措了。那么我们测试人员抓包其实一般都是为了验证我们测试的数据在接口传递过程中是否正常或者为了判断某个问题是前端问题还是后端问题。
13、怎么判断一个bug是前端问题还是后端问题？ 这是很多面试官都会问到的问题，而且在工作中为了防止前端开发和后端开发人员相互踢皮球也是我们测试人员必须要掌握的知识点。
其实很容易判断，我们可以先抓包看请求报文，对着接口文档，看请求报文有没问题，有问题就是前端发的数据不对，请求报文没问题，那就看返回报文，返回的数据不对，那就是后端开发的问题，这样我们测试人员才能有自己的判断，而不是任由开发相互扯皮。
14、总结 只要你有能力去做的事就一定要去做，不要给自己留下任何遗憾，人生最重要的不是所站的位置，而是所朝的方向。
生于忧患，死于安乐。如果你想跨越自己目前的成就，就不能画地自限，而是要勇于接受挑战。对畏畏缩缩的人来说，真正的危险正在于不敢冒险！
为明天做准备的最好方法就是集中你所有智慧，所有的热忱，把今天的工作做得尽善尽美，这就是你能应付未来的唯一方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1cb7430205be7c6ec1ca3e2cd9d974/" rel="bookmark">
			泛型的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛型的讲解 一、什么是泛型二、引出泛型三、泛型类的使用3.1 语法3.2 示例3.3 类型推导(Type Inference)3.4 裸类型(Raw Type) （了解） 四、泛型如何编译的4.1 擦除机制4.2 为什么不能实例化泛型类型数组 五、泛型的上界5.1 语法5.2 示例5.3 复杂示例5.4 总结 六、泛型方法6.1 定义语法6.2 示例6.3 使用示例-不使用类型推导6.4 使用示例-可以类型推导 七、通配符7.1 通配符解决什么问题7.2 通配符上限7.3 通配符下界 八、 包装类8.1 基本数据类型和对应的包装类8.2 装箱和拆箱8.3 自动装箱和自动拆箱8.4 包装类常用方法 一、什么是泛型 一般的类和方法，只能使用具体的类型: 要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。
----- 来源《Java编程思想》对泛型的介绍。
泛型是在JDK1.5引入的新的语法，通俗讲，泛型：就是适用于许多许多类型。从代码上讲，就是对类型实现了参数化。
二、引出泛型 实现一个类，类中包含一个数组成员，使得数组中可以存放任何类型的数据，也可以根据成员方法返回数组中某个下标的值？
思路：
我们以前学过的数组，只能存放指定类型的元素，例如：int[] array = new int[10]; String[] strs = new String[10];所有类的父类，默认为Object类。数组是否可以创建为Object? 代码示例：
问题：以上代码实现后 发现
任何类型数据都可以存放1号下标本身就是字符串，但是确编译报错。必须进行强制类型转换：
虽然在这种情况下，当前数组任何数据都可以存放，但是，更多情况下，我们还是希望他只能够持有一种数据类型。而不是同时持有这么多类型。所以，泛型的主要目的：就是指定当前的容器，要持有什么类型的对象。让编译器去做检查。此时，就需要把类型，作为参数传递。需要什么类型，就传入什么类型。
上述代码进行改写如下：
我们发现创建数组时报错了！修改如下：
代码解释：
类名后的 &lt;T&gt; 代表占位符，表示当前类是一个泛型类。
了解： 【规范】类型形参一般使用一个大写字母表示，常用的名称有： E 表示 ElementK 表示 KeyV 表示 ValueN 表示 NumberT 表示 TypeS, U, V 等等 - 第二、第三、第四个类型 不能new泛型类型的数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d1cb7430205be7c6ec1ca3e2cd9d974/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7482ef8a88a4a93238e86ffc0c45441e/" rel="bookmark">
			【Spring Boot】整合Mybatis与Mybatis-plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、整合mybatis 博主之前也写过Spring整合Mybatis相关的博客
【Spring】spring整合mybatis
那么Spring Boot框架是如何整合Mybatis的呢？
我们直接去Mybatis的git官网地址：https://github.com/mybatis
进入spring-boot-starter这个模块，然后切换Tag到最新的，进入mybatis-spring-boot-starter这个模块
接着就可以在pom文件中找到这个启动类的坐标信息了
首先引入启动器相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 然后我们还是照惯例分析一下相关的自动配置类MybatisAutoConfiguration
可以发现除了基本的配置绑定类（配置项以mybatis开头）等相关信息之外
这个类还完成了SqlSessionFactory和SqlSessionTemplate的自动配置
另外还引入了一个类AutoConfiguredMapperScannerRegistrar，它会自动扫描@Mapper标注的接口，将这些接口认定是操作mybatis的接口
@Configuration @ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class}) @ConditionalOnSingleCandidate(DataSource.class) @EnableConfigurationProperties({MybatisProperties.class}) @AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class}) public class MybatisAutoConfiguration implements InitializingBean { ... // 自动注入SqlSessionFactory这个bean @Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); } ... // 自动注入SqlSessionTemplate，它组合了SqlSession @Bean @ConditionalOnMissingBean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) { ExecutorType executorType = this.properties.getExecutorType(); return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7482ef8a88a4a93238e86ffc0c45441e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e988869cfad837667bd840a9db3650d3/" rel="bookmark">
			HAL库中断方式控制LED灯亮灭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、中断介绍1.中断的定义2.中断过程执行示意图3.中断的作用4.中断优先级5.中断响应过程6.GPIO引脚的外部中断触发方式7.HAL库的中断处理流程 二、STM32CubeMX工程创建1.新建项目2.芯片选择3.参数设置4.引脚设置5.开启中断6.配置时钟7.生成项目 三、程序编写及编译1.代码编写2.代码编译及hex文件创建 四、电路连接及烧录运行1.电路连接2.程序烧录3.运行结果 四、总结五、参考链接 一、中断介绍 1.中断的定义 中断是由内核外部产生的,一般由硬件引起，比如外设中断和外部中断等。
中断全过程：
中断发生（当CPU在处理某一事件A时，发生了另一事件B，请求CPU迅速去处理）
中断处理（CPU暂停当前的工作，转去处理事件B）
中断返回（当CPU将事件B处理完毕后，再回到事件A中被暂停的地方继续处理事件A）
整个过程称为中断
2.中断过程执行示意图 3.中断的作用 （1）速度匹配 可以解决快速的CPU与慢速的外部设备之间传送数据的矛盾
（2）分时操作 CPU可以分时为多个外部设备服务，提高计算机的利用率
（3）实时响应 CPU能够及时处理应用系统的随机事件，增强系统的实时性
（4）可靠性高 CPU可以处理设备故障及掉电等突发事件，提高系统可靠性
4.中断优先级 处理器根据不同中断的重要程序设置不同的优先等级。不同优先级中断的处理原则是：高级中断可以打断低级中断；低级中断不能打断高级中断
中断嵌套：
5.中断响应过程 （1）中断源发出中断请求
（2）判断处理器是否允许中断，以及该中断源是否被屏蔽
（3）中断优先级排队
（4）处理器暂停当前程序，保护断点地址和处理器的当前状态，根据中断类型号,查找中断向量表，转到对应的中断服务程序
（5）执行中断服务程序
（6）恢复被保护的状态,执行中断返回指令,回到被中断的程序
6.GPIO引脚的外部中断触发方式 上升沿触发、下降沿出发、双边沿触发
7.HAL库的中断处理流程 （1）中断程序的编程步骤
设置中断触发条件→设置中断优先等级→设能外设中断→清除中断标志→编写中断服务程序
（2）HAL库对中断的封装处理
①统一规定处理各个外设的中断服务程序HAL_PPP_IRQHandler（PPP代表外设名称）
②在中断服务程序HAL_PPP_IRQHandler完成了中断标志的判断和清除
③将中断中需要执行的操作以回调函数（由外设初始化、中断、处理完成/出错触发的函数）的形式提供给用户
（3）由CubeMX生成的MDK工程中与中断相关的编程文件
①启动文件：startup_stm32fxxx.s
◉该文件存放在MDK-ARM组中。在该文件中，预先为每个中断编写了一个中断服务程序，只是这些中断服务程序都是死循环，目的只是初始化中断向量表；
◉中断服务程序的属性定义为“weak”。weak属性的函数表示：如果该函数没有在其他文件中定义，则使用该函数；如果用户在其他地方定义了该函数，则使用用户定义的函数。
②中断服务程序文件：stm32fxxx_it.c
◉该文件存放在User组中，用于存放各个中断的中断服务程序；
◉在使用CubeMX软件进行初始化配置时，如果使能了某一个外设的中断功能，那么在生成代码时，相对应的外设中断服务程序HAL_PPP_IRQHandler就会自动添加到该文件中，用户只需要在该函数中添加相应的中断处理代码即可。
二、STM32CubeMX工程创建 1.新建项目 打开STM32CubeMX主界面，点击“ACCESS TO MCU SELECTOR”,创建新项目
2.芯片选择 在“Commerical Part Number”里面选择自己需要的芯片，点击信息栏中的具体芯片信息选中，再点击“Start Project”
3.参数设置 （1）先点击System Core将其展开，再点击RCC，将HSE设置为Crystal/Ceramic Resonator
（2）点击SYS，将Debug设置为Serial Wire
4.引脚设置 （1）点击GPIO，点击PA4，将其设置为GPIO_Output，再根据自己需要设置User Label（也可以不设置），我这里设置的是LED
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e988869cfad837667bd840a9db3650d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e627ce5131c28d3cccf74e57f83648/" rel="bookmark">
			Sql中多表连接查询详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多表连接查询 讲师：尚硅谷-宋红康（江湖人称：康师傅）
官网：http://www.atguigu.com
多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。
前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。
1. 一个案例引发的多表连接 1.1 案例说明 从多个表中获取数据：
#案例：查询员工的姓名及其部门名称 SELECT last_name, department_name FROM employees, departments; 查询结果：
+-----------+----------------------+ | last_name | department_name | +-----------+----------------------+ | King | Administration | | King | Marketing | | King | Purchasing | | King | Human Resources | | King | Shipping | | King | IT | | King | Public Relations | | King | Sales | | King | Executive | | King | Finance | | King | Accounting | | King | Treasury | .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e627ce5131c28d3cccf74e57f83648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c3bd509fd30f9567c2297c6a6bcfe6/" rel="bookmark">
			队列的基本操作（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.实现功能
2.建队列
3.进队列
4.打印队列信息
5.队列的判空
6.求队列的长度
7.求队尾元素
8.删除队列元素同时返回队尾元素的值
9.求队头元素
10.输入队列元素
11.摧毁一个队列
12.请空队列
13.switch case选择
14.全部代码内容
15.运行图片
本帖可以实现的功能
1.实现功能 void pro() { printf("0.退出\n"); printf("1.建立一个新队列\n"); printf("2.按照输出方式打印队列信息\n"); printf("3.求队列长度\n"); printf("4.获取对头元素\n"); printf("5.获取队尾元素\n"); printf("6.删除对头元素\n"); printf("7.判断队列是否为空\n"); printf("8.在队尾插入一个数\n"); printf("9.清空一个队列\n"); printf("10.摧毁一个队列\n"); } 2.建队列 void InitQueue(LinkQueue &amp;Q) { //建立链队列 Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); Q.front = Q.rear; if (!Q.front) printf("开辟空间失败\n"); Q.front-&gt;next = NULL; printf("链式队列存储空间开辟完成\n"); // Q.front-&gt;next=Q.rear-&gt;next; } 3.进队列 Status EnQueue(LinkQueue &amp;Q, int e) { //在队列的尾部插入元素 QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); p-&gt;data = e; p-&gt;next = NULL; Q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c3bd509fd30f9567c2297c6a6bcfe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c206265125f5ea37b4ed9b0812e3608/" rel="bookmark">
			读写分离中间件案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
二、Robustdb 原理
三、性能
参考
公司 DBA 一直埋怨 Atlas 的难用，希望从客户端层出一个读写分离的方案。开源市场上在客户端做读写分离的开源软件基本上没有。业务方利用 Spring 自带的路由数据源能实现部分读写分离的功能，但是功能不够完善。部分参考 Sharing-JDBC 源码思想，利用部分业余时间，写了这个 Robustdb，总共只使用了十多个类，两千多行代码左右。
一、背景 随着业务量的增长，所有公司都不是直接选择分库分表设计方案的。很长一段时间内，会采用 库垂直拆分和分区表 来解决库表数据量比较大的问题，采用读写分离来解决访问压力比较大的问题。我们公司也是一样。目前绝大部分业务还是使用读写分离的方案。我相信很多公司和我们公司的架构一样，采用中间代理层做读写分离。结构如下：
第一层是 VIP 曾。通过 VIP 做中间映射层，避免了应用绑定数据库的真实 IP，这样在数据库故障时，可以通过 VIP 飘移来将流量打到另一个库。但是 VIP 无法跨机房，为未来的异地多活设计埋下绕不过去的坎。
VIP 下面一层是读写分离代理，我们公司使用的是 360 的 Atlas。Atlas 通过将 SQL 解析为 DML（Data Modify Language）和 DQL（Data Query Language），DML 的请求全部发到主库，DQL 根据配置比例分发到读库（读库包括主库和从库）。
使用 Atlas 有以下不足：
Altas 不再维护更新，现存一些 bug，bug 网上很多描述；
Altas 中没有具体应用请求 IP 与具体数据库 IP 之间的映射数据，所以无法准确查到访问DB的请求是来自哪个应用；
Altas 控制的粒度是 SQL 语句，只能指定某条查询 SQL 语句走主库，不能根据场景指定；
DB 在自动关闭某个与 Altas 之间的连接时，Altas 不会刷新，它仍有可能把这个失效的连接给下次请求的应用使用；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c206265125f5ea37b4ed9b0812e3608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f3ced8aa8506407d9ca2d33e974de1/" rel="bookmark">
			Sql中in和exists详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		in和exists的转换 1 结论 in()适合子查询结果集比外表查询结果集小的情况（子表查询结果集的记录数决定了数据库的交互次数）exists()适合子查询结果集比外表查询结果集大的情况（外表查询结果集的记录数决定了数据库的交互次数）当外表查询结果集与子查询结果集数据一样大时，in与exists效率差不多,可任选一个使用小表驱动大表（更准确的说是查询结果集小的驱动查询结果集大的）IN查询在内部表和外部表上都可以使用到索引。Exists查询仅在内部表上可以使用到索引。表的规模不是看内部表和外部表记录数的，而是外部表和子查询结果集中记录数的大小 2 in和exists的区别 2.1 in的性能分析 select * from A where id in(select id from B) 上述sql会先执行括号内的子查询,再执行主查询,因此相当于以下过程：
for select id from B for select * from A where A.id = B.id 以上查询使用了in语句,in()只执行一次,它查出B表中的所有id字段并缓存到内存中之后,检查A表的id是否与B表中的id相等,如果相等则将A表的记录加入结果集中,直到遍历完A表的所有记录.
它的查询过程类似于以下过程
List resultSet=[]; Array A=(select * from A); Array B=(select id from B); for(int i=0;i&lt;A.length;i++) { for(int j=0;j&lt;B.length;j++) { if(A[i].id==B[j].id) { resultSet.add(A[i]); break; } } } return resultSet; 分析：
当前的in子查询是B表驱动A表mysql先将B表的数据一次性查出来存放于内存中，B表的记录数决定了数据库的交互次数遍历B表的数据，再去查A表（每次遍历都是一次连接交互，这里会耗资源）假设B有100000条记录，A有10条记录，会交互100000次数据库；再假设B有10条记录，A有100000记录，只会发生10次交互。 结论:
in()适合B表比A表数据小的情况
2.2 Exists的性能分析 select a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6f3ced8aa8506407d9ca2d33e974de1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ea73ac5eb3a5522929daa825ed8d27/" rel="bookmark">
			SpringBoot整合MongoDB 及 基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.MongoDB基本介绍
2.MongoDB的特点
3.MongoDB的体系结构 4.MongoDB的数据类型
5.SpringBoot整合MongoDB **
1.导入依赖
2.启动MongoDB数据库
3.编写启动类
4.编写实体类（基本操作 每一个表都对应一个实体）
5.测试 增删改查（API）
1.MongoDB基本介绍 MongoDB介绍_30岁老阿姨的博客-CSDN博客_mongodb介绍
MongoDB是一个文档数据库，MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，数据格式是BSON，一种类似JSON的二进制形式的存储格式，简称Binary JSON ，和JSON一样支持内嵌的文档对象和数组对象，因此可以存储比较复杂的数据类型。
对于数据量大而言，显然不能够使用关系型数据库和内存数据库进行存储，我们需要通过MongoDB进行存储
2.MongoDB的特点 MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。
具体特点总结如下：
面向集合存储，易于存储对象类型的数据
模式自由
支持动态查询
支持完全索引，包含内部对象
支持复制和故障恢复
使用高效的二进制数据存储，包括大型对象（如视频等）
自动处理碎片，以支持云计算层次的扩展性
支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl及C++语言的驱动程 序， 社区中也提供了对Erlang及.NET 等平台的驱动程序
文件存储格式为 BSON（一种 JSON 的扩展）
3.MongoDB的体系结构 MongoDB 的逻辑结构主要由：数据库(database)、 集合(collection)、文档(document)这三部分组成的。
MongoDB 的文档（document），相当于关系数据库中的一行记录。
多个文档组成一个集合（collection），相当于关系数据库的表。
多个集合（collection），逻辑上组织在一起，就是数据库（database）。
一个 MongoDB 实例支持多个数据库（database）。 文档(document)、集合(collection)、数据库
SQL和MongoDB对比
RDBMSMongoDBdatabase(数据库)database（数据库）table （表）collection（ 集合）row（ 行）document（ BSON 文档）column （列/字段）field （字段）index（唯一索引、主键索引）index （支持地理位置索引、全文索引）join （主外键关联）MongoDB不支持primary key(指定某个列做主键)primary key (不需要指定 固定 _id 字段做为主键 自带的) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ea73ac5eb3a5522929daa825ed8d27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff08aacf76f68baeb75c5bd716227dfd/" rel="bookmark">
			RabbitMQ--基础--7.5--工作模式--主题模式(Topic)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ–基础–7.5–工作模式–主题模式(Topic) 代码位置 https://gitee.com/DanShenGuiZu/learnDemo/tree/master/rabbitMq-learn/rabbitMq-03 1、介绍 topic类型的交换机 实际上是 direct类型的交换机的一种 都将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中topic 在匹配规则上进行了扩展。使用了通配符 工作流程 消息生产者生产消息，把消息交给交换机 exchange交换机 exchange 根据 key 的规则模糊匹配到对应的队列，由队列的监听消费者接收消息消费 1.1、匹配规则 1.1.1、RoutingKey 为一个点号 “.” 分割的字符串，被点号 “.” 分割开的每一段独立的字符串成为一个单词。举例：com.rabbitmq.client、java.util.concurrent 1.1.2、BindingKey RountingKey一样，也是点号 “.” 分割的字符串BindingKey存在两种特殊的字符串，用于做模糊匹配 “*” ：用于匹配一个单词“#” ：用于匹配多个单词(可以是零个)。 1.1.3、BindingKey模糊匹配案例 com.#：可以匹配：com.zzc.java、com.zzc等com.*：可以匹配：com.zzc、com.java 等 1.2、Topic 模型 路由键为 com.rabbitmq.client 的消息，会同时路由到 Q1、Q2、Q3路由键为 com.hidden.client 的消息，会路由到 Q2、Q3路由键为 com.hidden.demo 的消息，会路由到 Q3路由键为 java.util.concurrent 的消息，会被丢弃或者返回给生产者，因为，它没有匹配任何路由键 1.3、和路由模式区别 绑定键 BindingKey 中带有模糊匹配路由键 RoutingKey 由多个单词构成 2、MQ实现 Topic 在 direct 模式上面进一步筛选 2.1、创建队列 topic_queue1 topic_queue2 topic_queue3 2.2、新建一个交换机 新建一个交换机类型为 topic topic_exchange 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff08aacf76f68baeb75c5bd716227dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e33fa087cd8f937b97fb3c9edbb16f/" rel="bookmark">
			附录二 windows上直接安装uwsgi(不可行)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 使用pip直接安装
2 使用gz文件安装
2.1 解决os的uname问题
2.2 解决C的编译问题
2.3 解决sys.socket.h问题
2.4 解决不了net/if.h问题
1 使用pip直接安装 输入 pip install uwsgi可以安装uWSGI
在linux输入后就可成功安装，在windows中会出现 AttributeError: module 'os' has no attribute 'uname' 的错误
2 使用gz文件安装 先复制这里的链接把tar.gz文件下载下来
2.1 解决os的uname问题 下载好后进行解压，解压后找到 uwsgiconfig.py
错误的原因是windows的os没有uname()方法，所以我们将所有的os.uname()改为platform.uname()
之后用anaconda prompt激活环境，之后cd到安装包的目录下，然后输入python setup.py install
2.2 解决C的编译问题 发现出现了编译问题，提示我需要C的编译器去搞uWSGI
在windows上MinGW可以编译C
我看别人有装在其他盘符中的，装在哪一个盘应该都可以 等待进度条滚动到头后，点击Continue
点击前面的条目前的方块然后点击Mark for installation可以将其勾选上
勾选下图这两个就行了
点击Installation中的Apply Changes
点击Apply
点击后会自动进行下载
下载后会自动进行应用
Close亮了后点close
添加上刚刚下载的位置
将所有窗口都点击确定后重新启动计算机
2.3 解决sys.socket.h问题 重启后依然报错
编辑uwsgi.h
找到文件第172行,将#include &lt;sys/socket.h&gt;改为#include &lt;winsock.h&gt;
2.4 解决不了net/if.h问题 保存后再次运行，发现缺少net/if.h
之后我将MinGW的所有基础的东西都装上了，发现在安装目录下的include中并没有net这个文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7e33fa087cd8f937b97fb3c9edbb16f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2681217879342db2ad1b65a1e53d0732/" rel="bookmark">
			STM32CUBEIDE----配置输出串口中文和文本大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32CUBEIDE----配置输出串口中文和文本大小 概述配置编码格式重定向修改字体大小 概述 TM32CubeIDE是一体式多操作系统开发工具，是STM32Cube软件生态系统的一部分。
STM32CubeIDE是一种高级C/C++开发平台，具有STM32微控制器和微处理器的外设配置、代码生成、代码编译和调试功能。它基于Eclipse®/CDT™框架和用于开发的GCC工具链，以及用于调试的GDB。它支持集成数以百计的现有插件，正是这些插件使Eclipse® IDE的功能趋于完整。
STM32CubeIDE集成了STM32CubeMX的STM32配置与项目创建功能，以便提供一体化工具体验，并节省安装与开发时间。在通过所选板卡或示例选择一个空的STM32 MCU或MPU，或者预配置微控制器或微处理器之后，将创建项目并生成初始化代码。在开发过程的任何时间，用户均可返回外设或中间件的初始化和配置阶段，并重新生成初始化代码，期间不会影响用户代码。
STM32CubeIDE包含相关构建和堆栈分析仪，能够为用户提供有关项目状态和内存要求的有用信息。
STM32CubeIDE还具有标准和高级调试功能，其中包括CPU内核寄存器、存储器和外设寄存器以及实时变量查看、串行线传输监测器接口或故障分析器的视图。
配置编码格式 关于STM32CUBEIDE无法通过串口打印中文字符，需要更改编码配置。
点击proiect-&gt;Properties
编码格式输入GMK。
重定向 此时就可以正确输出中文字符。
#ifdef __GNUC__	#define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&amp;huart2 , (uint8_t *)&amp;ch, 1, 0xFFFF); return ch; } 修改字体大小 在编辑器右键-&gt;preferences
选择General-&gt;Appearance-&gt;Colors and Fonts-&gt;Text Font-&gt;Edit
在这就可以修改字体大小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35f8ed202c97a676676fc0a09b2bf93/" rel="bookmark">
			HIVE教育大数据分析平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 《HIVE数据仓库应用》（mysql-sqoop-hive-sqoop-mysql-finebi） 1.Sqoop部署成功 2. MySQL中的时间数据类型timestamp,datetime迁移到Hive中可以用string或者bigint代替。 3.Sqoop迁移数据报错，运行4遍成功。ERROR tool.ImportTool: Import failed: Import job failed! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e7dddceda67058b98daba5f4804685/" rel="bookmark">
			Linux系统中为MySql设置主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySql设置主从复制 一、数据库主从复制的意义二、MySql主从复制的原理三、MySql主从复制的配置步骤0. 配置-前置条件1. 配置-主库Master第一步：修改MySql数据主库Master的配置第二步：重启MySql服务第三步：在Master的服务中为Slave创建一个用户，设置响应权限第四步：登录MySql数据库，查看主库状态，记录下结果中的File和Position值 2. 配置-从库Slave第一步：修改从库的配置文件第二步：重启MySql服务第三步：登录MySql Slave，修改其Master第四步：登录MySql数据库，查看从数据库的状态 3. 测试 一、数据库主从复制的意义 避免单一数据库硬盘损坏导致数据丢失可以将查询请求中读操作和写操作的压力，分担到不同的数据库服务器上，降低单台数据库服务器的压力 二、MySql主从复制的原理 MySql的主从复制是基于MySql数据库自带的二进制日志功能（binary log），是一个异步的复制过程。
一台或多台数据库从库（slave）从一台MySql主库（master）进行二进制日志的复制，然后再进行日志的解析并应用到自身，最终实现从库的数据库和主库的数据保持一致。
MySql主从复制的过程分三步：
master将改动记录到二进制日志（binary log）slave将master的binary log拷贝到它的中继日志（relay log）slave重做中继日志中的事件，将改变应用到自己的数据库中 三、MySql主从复制的配置步骤 0. 配置-前置条件 提前准备好两台服务器，分别安装MySql并启动服务成功
e.g.:
主库Master 192.168.119.129从库Slave 192.168.119.128 可以使用两台虚拟机或云服务器，之后用FinalShell之类的连接工具进行控制。推荐使用虚拟机，一台虚拟机完成MySql的安装和配置后，完全克隆一下就行。不建议使用Docker，在实际的生产流程里，数据库不太可能安装在容器中，真这么干可能会被人打死。容器的销毁，比之服务器的物理损坏，要容易得多。
1. 配置-主库Master 第一步：修改MySql数据主库Master的配置 修改MySql数据库的配置文件 /etc/my.cnf
[mysqld] log-bin=mysql-bin #[必须]启用二进制日志 server-id=100 # [必须]服务器唯一ID 第二步：重启MySql服务 Bash命令：systemctl restart mysqld
配置修改完成后，重启对应服务器的MySql服务使配置生效，如果没报错，基本就是重启成功了。
第三步：在Master的服务中为Slave创建一个用户，设置响应权限 登录MySql后执行以下语句，“%”意为允许所有IP访问。
GRANT REPLICATION SLAVE ON *.* to 'xiaoming'@'%' identified by 'Root@123456'; PS：这一SQL语句的作用是创建一个用户xiaoming，密码为Root@123456，并且xiaoming用户授予REPLICATION SLAVE权限，这一权限常被用于建立主从复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。
第四步：登录MySql数据库，查看主库状态，记录下结果中的File和Position值 show master status； 其中File为日志文件的名称，Position为当前改动的位置。
File：mysql-bin.000002
Position：441
注意在显示了这里的状态栏之后，不要再在主库中进行任何操作，否则日志文件的名称和位置都会发生改变。
2. 配置-从库Slave 第一步：修改从库的配置文件 修改MySql Slave的配置文件 /etc/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e7dddceda67058b98daba5f4804685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b9da8a324a66f1f8afa1cc23fc1988/" rel="bookmark">
			NextCloud 最新官方源代码安装包及客户端下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官方搬运 服务端(源代码安装包) 大版本小版本V13V13.0.5下载V14V14.0.1下载V15V15.0.4下载V15V15.0.5下载V15V15.0.7下载V16V16.0.0下载V16V16.0.1下载V16V16.0.2下载V16V16.0.4下载V17V17.0.0下载v18V18.0.0下载v18V18.0.1下载v18V18.0.2下载v19V19.0.0下载v19V19.0.1下载v21V21.0.1下载v21V21.0.2下载v23V23.0.2下载 客户端 平台版本安卓V3.6.0下载安卓V3.8.0下载安卓V3.8.1下载安卓V3.10.1下载安卓V3.12.1下载安卓V3.16.0下载安卓V3.16.0下载安卓V3.19.0下载WindowsV2.5.2下载WindowsV2.5.3下载WindowsV2.6.0下载WindowsV2.6.2下载WindowsV2.6.2下载WindowsV2.6.3下载WindowsV2.6.4下载WindowsV2.6.5下载WindowsV3.1.3下载(最后支持win7的版本)Windows10V3.2.1下载Windows10V3.4.3下载Windows10V3.4.4下载Windows10V3.5.0下载Windows10V3.5.1下载Windows10V3.5.4下载Windows10V3.6.1下载LinuxV2.5.2下载LinuxV2.5.3下载LinuxV2.6.0下载LinuxV2.6.3下载LinuxV2.6.4下载LinuxV2.6.5下载LinuxV3.2.1下载LinuxV3.4.3下载LinuxV3.4.4下载LinuxV3.5.1下载LinuxV3.5.2下载LinuxV3.5.4下载LinuxV3.6.1下载MACOSMACOS10+V2.5.2下载MACOSMACOS10+V2.5.3下载MACOSMACOS10+V2.6.0下载MACOSMACOS10+V2.6.2下载MACOSMACOS10+V2.6.3下载MACOSMACOS10+V2.6.4下载MACOSMACOS10+V2.6.5下载MACOSMACOS10+V3.2.1下载MACOSMACOS10+V3.4.4下载 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b602ab04894f1a013ad138ac1c4fbdc9/" rel="bookmark">
			算法设计 排序算法实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法C++ 实验一 分治策略
一、实验目的和要求
理解分治法的算法思想，阅读实现书上已有的部分程序代码并完善程序，加深对分治法的算法原理及实现过程的理解
内容：
一、用分治法实现一组无序序列的两路合并排序和快速排序。要求清楚合并排序及快速排 序的基本原理，编程实现分别用这两种方法将输入的一组无序序列排序为有序序列后输出。
二、采用基于“五元中值组取中值分割法”(median-of-median-of-five partitioning)的线性 时间选择算法，找出 N 个元素集合 S 中的第 k 个最小的元素，使其在线性时间内解决。(参 考教材 5.5.3 节)
二、实验环境(实验设备)
硬件：微型计算机
软件：Windows 操作系统、Microsoft Visual C++6.0
三、实验原理及内容
实验原理：
分治法得基本思想是将一个规模为n的问题分解为k个规模为m的相互独立且与原问题解法相同的子问题，然后将子问题的解合并得到原问题的解。由此可见，分治法设计出的程序一般是递归算法，设解决一个规模为1的问题需要1个单位时间，再设将k个子问题的解合并为原问题的解所需时间为f(n),则递归算法的时间复杂度为：
两路合并排序是一类时间复杂度为O(nlogn)的排序方法。基本思想为将有n个元素的序列看成是n个长度为1的有序序列，然后两两合并序列，得到 n/2个长度为2或1的有序序列，然后在进行两两合并，直到得到一个长度为n的有序序列。
先将无序序列利用二分法划分为子序列，直至每个子序列只有一个元素(单元素序列必有序)，然后再对有序子序列逐步(两两)进行合并排序。合并方法是循环的将两个有序子序列当前的首元素进行比较，较小的元素取出，置入合并序列的左边空置位，直至其中一个子序列的最后一个元素置入合并序列中。最后将另一个子序列的剩余元素按顺序逐个置入合并序列尾部即可完成排序。
快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。最好时间复杂度为：O(nlogn)，最坏时间复杂度为：O(n^2)，平均时间复杂度为O(nlogn)。
快速排序的三个步骤：
(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 "基准"（pivot）
(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大
(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。
实验内容：
排序是数据处理中常用手段，是指将一个元素序列调整为按一定顺序排列的有序序列，用分治策略解决排序问题的思想是将序列按照某方式分成数个子序列，再分别进行排序，再将已经排序的子序列合并成一个有序序列。两路合并排序和快速排序都是符合分治策略的。
两路合并排序： void mergeSort(int* arr, int lo, int hi) { //0 &lt;= lo &lt; hi &lt;= size
if (hi - lo &lt; 2) return;
//将数组分为两部分
int mid = (lo + hi) / 2; //以中点为界限 mergeSort(arr, lo, mid); //左侧子数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b602ab04894f1a013ad138ac1c4fbdc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669d39b646e8796e67355347091b83b2/" rel="bookmark">
			mysql中autocommit，start transaction和begin/commit的异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.相同点：这三个关键字都与mysql的事务相关，直接操纵事务的语句，
2.不同点：
（1）他们的作用范围不一样。
AUTOCOMMIT是数据库innodb引擎级别的属性，对于start transaction和begin/end而言是全局的，一旦使用SET AUTOCOMMIT=0 禁止自动提交，则在这个数据库内部的所有事务都不会自动提交，除非你手动的为每一个事务执行了commit或者rollback语句；而start transaction和begin/commit只能控制某一个事务。
（2）优先级不同。存在一种set autocommit = 1/0 但是 对于某一个sql语句使用了 begin/commit的原子性操作，那么mysql会优先使用begin/commit命令控制被这组命令修饰的事务；，这一点比较重要，因为之前很多的博主都说要先设置set autocommit = 0关闭掉事务的自动提交属性才能使用 begin/commit或者begin/rollback的原子性操作，这是错误的。关于这一点，mysql官方文档做了详细的解释，
下面是我引用的官方文档中的最重要的一句话
A session that has autocommit enabled can perform a multiple-statement transaction by starting it with an explicit START TRANSACTION or BEGIN statement and ending it with a COMMIT or ROLLBACK statement.
3. 至于start transaction 和 begin的区别：
两者的作用一摸一样，只是在begin可能成为关键字的时候，使用start transaction 可以 避免这种情况，start transaction或者begin开启一个事务，然后使用commit提交事务或者ROLLBACK回滚事务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d116c47d97e955dd8988ac593d88dcfc/" rel="bookmark">
			SSH服务配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SSH基础
什么是SSH服务器？
SSH数据传输原理
SHH客户端：
SHH服务器：
OpenSSH
配置OpenSSH服务端
1、sshd_config配置文件的常用选项设置
ssh原理
公钥传输原理
ssh远程登录格式
服务端配置
常用配置项：
SSH基础 什么是SSH服务器？ SSH（Secure Shell）是一种安全通道协议，主要用来实现字符界面的远程登录、远程 复制等功能。SSH 协议对通信双方的数据传输进行了加密处理，其中包括用户登录时输入的用户口令，SSH 为建立在应用层和传输层基础上的安全协议。对数据进行压缩，加快传输速度。
SSH客户端&lt;--------------网络----------------&gt;SSH服务端
优点：
数据传输是加密的，可以防止信息泄漏
数据传输是压缩的，可以提高传输速度
SSH数据传输原理 SSH客户端与服务端是通过网络来进行数据文件传输的，数据传输是加密的，可以防止信息泄露，（并不安全）数据传输是压缩的，可以提高传输速度。
SHH客户端： Putty、 Xshell、CRT
SHH服务器： OpenSSH OpenSSH是实现SSH协议的开源软件项目，适用于各种UNIX、Linux 操作系统。
Centos 7系统默认已安装openssh相关软件包，并将sshd 服务添加为开机自启动。
执行"systemctl start sshd" 命令即可启动sshd服务
sshd服务默认使用的是TCP的22端口，安全协议版本sshv2，出来2之外还有1(有漏洞)
sshd服务的默认配置文件是/etc/ssh/sshd_ config
ssh_ config和sshd_ config（服务端比较多） 都是ssh服务器的配置文件，二者区别在于前者是针对客户端的配置文件，后者则是针对服务端的配置文件。
ssh服务端主要包括两个服务功能ssh远程链接和sftp服务
远程管理linux系统基本上都要使用到ssh，原因很简单：telnet、FTP等传输方式是?以明文传送用户认证信息，本质上是不安全的，存在被网络窃听的危险。SSH（Secure Shell）目前较可靠，是专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题，透过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。
配置OpenSSH服务端 1、sshd_config配置文件的常用选项设置 vim /etc/ssh/sshd_config ssh原理 公钥传输原理 客户端发起链接请求
服务端返回自己的公钥，以及一个会话ID（这一步客户端得到服务端公钥）
客户端生成密钥对
客户端用自己的公钥异或会话ID，计算出一个值Res，并用服务端的公钥加密
客户端发送加密值到服务端，服务端用私钥解密，得到Res
服务端用解密后的值Res异或会话ID，计算出客户端的公钥（这一步服务端得到客户端公钥）
最终：双方各自持有三个秘钥，分别为自己的一对公、私钥，以及对方的公钥，之后的所有通讯都会被加密
（1）对称加密 1、概念 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用
2、常用算法 在对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d116c47d97e955dd8988ac593d88dcfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/419aa73004872cd8f0743508a3e73455/" rel="bookmark">
			yaml文件配置读取不到on： true，结果是yaml的语法忘记了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接说结果
有被自己蠢到 太久没用yaml了，语法都忘了
在yaml里，用on、1、true来表示true，off、0、false来表示false
问题：
本来是发现日志文件无法生成，后来一路debug
从viper跑到yaml的unmarshal方法，又继续往底层跑，追溯到读取文件去了也不知道问题怎么解决
viper
在根据配置文件类型读取时，我当前使用的是yaml文件类型，
当调用yaml的unmarshal方法时
内部（应该是链表式）的读取文件的内容 从到 log下的 file_writer 下的 on：true 的时候，读成了true：true 。
整了半天没整出来为什么on会变成true，结果突然想到会不会是yaml的语法，结果还真是，emo了
有被自己蠢到 太久没用yaml了，语法都忘了
在yaml里，用on、1、true来表示true，off、0、false来表示false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d553aad7913c0b6433a8bd657c2f34a/" rel="bookmark">
			RFSoC应用笔记 - RF数据转换器 -13- RFSoC多块同步功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用概述 本文概述了如何在系统中使用RFSoC 射频数据转换器的多块同步功能。
文章目录 应用概述多块同步（MTS）详细说明同步步骤确定性多图块同步 API 使用SYSREF 信号要求SYSREF 频率计算示例PL SYSREF 捕获 数字特征同步模拟同步模拟 SYSREF 捕获/接收模拟 SYSREF 交流和直流耦合 MTS Sequencing用例 1：使用带有 AC 或 DC 耦合的单个设备的 SYSREF 同步数字功能用例 2：使用带有直流耦合的多个器件的 SYSREF 同步数字功能 使用实时信号门控模拟 SYSREF（第 3 代） 多块同步（MTS） RFSoC 具有非常灵活的时钟和数据接口，可在同一器件中实现多种不同的应用。 每个 RF-ADC/RF-DAC 块都有自己独立的时钟和数据基础设施，允许每个块以单独的采样率和 PL 数据字宽驱动。 单个 tile 中的转换器共享时钟和数据基础设施，因此采样率和延迟是固定的。 但是，某些应用可能需要多个块，甚至多个RFSoC 才能一起使用。 对于这些应用程序，跨图块匹配转换器延迟至关重要。 多块同步 (MTS) 功能可用于实现相对和确定的多块和多设备对齐。
详细说明 在任何具有多个独立转换器和时钟结构的系统中，都有几个潜在的延迟不确定性来源，例如时钟分频器相位、NCO 相位、FIFO 延迟、时钟偏移和数据偏移。 分立转换器已标准化 JESD204B SYSREF 方案的同步使用，因此，RFSoC 已使用 SYSREF 实施了一个互补的简化方案。
RFSoC 中的转换器集成消除了用于数据通信的串行收发器链路。 然而，为了为 PL 设计提供灵活的时钟和数据字数，每个 RF-ADC 和 RF-DAC 都包含独立的FIFO。 这些 FIFO 允许在 PL 时钟域和转换器采样时钟域之间传输数据，但这会导致不确定的延迟，也必须使用 SYSREF 进行测量和校正。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d553aad7913c0b6433a8bd657c2f34a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcbe147173b39de0e5436c3ec118d572/" rel="bookmark">
			重复性的计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、重复性和一致性区别 重复性：相同测量条件下，对同一被测量进行连续多次测量所得结果之间的一致性。（个人理解测试工具一直是A，A连续测试多次，其评估的是A连续测量误差）。
一致性：一般用于评估样本之间的关联程度。（个人理解是分别采用测试工具A、B、C等，测得的样品数据。其评判的是A、B、C等工具之间的差异化程度）。
重复性计算公式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66badc5075d524bc647739d6f31c6816/" rel="bookmark">
			C/C&#43;&#43;编程：前置声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是前置声明 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.
一般的前置函数声明 #include &lt;iostream&gt; using namespace std; void fun(char ch, int *pValue, double dValue); void main() { int nValue = 100; double dValue = 111.22; fun('a', &amp;nValue, dValue); system("pause"); } void fun(char ch, int *pValue, double dValue) { return; } 自定义类型的前置声明 声明一个将稍后在此作用域定义的类类型。直到定义出现前，此类名具有不完整类型。这些类之间允许彼此引用：
class Vector; // 前置声明 class Matrix { // ... friend Vector operator*(const Matrix&amp;, const Vector&amp;); }; class Vector { // ... friend Vector operator*(const Matrix&amp;, const Vector&amp;); }; 自定义类型的前置声明，由于编译器不知道类型的大小，所以不可以声明类型的对象。只可以利用类型声明指针和引用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66badc5075d524bc647739d6f31c6816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1382625e55d1312af416c01b57c0a8a0/" rel="bookmark">
			Java八股文大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进大厂必备的Java八股文大全（2022最强精简易懂版，八股文中的八股文）备战秋招，赶快转发收藏起来吧~_十八岁讨厌Java的博客-CSDN博客_java八股文
本篇是八股文中的八股文，博主纯手打，十分精炼，每天背诵一个小时，一个星期就能熟练背诵，那么下面，我们就开始吧！
目录
一、Java基础篇
1.接口和抽象类的区别
2.重载和重写的区别
3.==和equals的区别
4.异常处理机制
5.HashMap原理
6.想要线程安全的HashMap怎么办？
7.ConcurrentHashMap原如何保证的线程安全？
8.HashTable与HashMap的区别
9.ArrayList和LinkedList的区别
10.如何保证ArrayList的线程安全？
11.String、StringBuffer、StringBuilder的区别
12.hashCode和equals
13.面向对象和面向过程的区别
4.深拷贝和浅拷贝
15.多态的作用
16.什么是反射？
17.Java创建对象得五种方式?
二.Java多线程篇
1.进程和线程的区别，进程间如何通信
2. 什么是线程上下文切换
3.什么是死锁
4.死锁的必要条件
5.Synchrpnized和lock的区别
6.什么是AQS锁?
8.有哪些常见的AQS锁
10.yield()和join()区别
11.线程池七大参数
12.Java内存模型 13.保证并发安全的三大特性？
14.volatile
15.线程使用方式
16.ThreadLocal原理
17.什么是CAS锁
18.Synchronized锁原理和优化
19.如何根据 CPU 核心数设计线程池线程数量
三.JVM篇
1.JVM运行时数据区（内存结构）
2.什么情况下会内存溢出？
3.JVM有哪些垃圾回收算法？
4.GC如何判断对象可以被回收？
5.典型垃圾回收器
6.类加载器和双亲委派机制
7.JVM中有哪些引用？
8.类加载过程
9.JVM类初始化顺序
10..对象的创建过程
11.对象头中有哪些信息
12.JVM内存参数
13.GC的回收机制和原理
四.Mysql篇
1.MyIAm和InnoDB的区别
2.mysql事务特性
3.事务靠什么保证
4.事务的隔离级别
5.什么是快照读和当前读
6.MVCC是什么
7.MySQL有哪些索引
8.聚簇索引和非聚簇索引的区别
9.B和B+数的区别，为什么使用B+数
10.MySQL有哪些锁
11.MySQL如果做慢查询优化
12.为什么要用内连接而不用外连接？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1382625e55d1312af416c01b57c0a8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d2e2ef25260306784942cda01f4ad0/" rel="bookmark">
			centos安装hadoop环境（编写中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 服务集群机器 描述：使用Oracle VM VirtualBox搭建部署的五台虚拟机，使用系统Centos(2009)
192.168.1.11 bigdata1
192.168.1.12 bigdata2
192.168.1.13 bigdata3
192.168.1.14 bigdata4
192.168.1.15 bigdata5
ssh免登录的设置 在每台机器上分别执行ssh-keygen -t rsa，一直按住回车键。
在bigdata 192.168.1.11的机器上进行公钥的追加操作 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
将其他机器上生成的公钥拷贝到192.168.1.11的~/.ssh目录，生成id_rsa.pub12至15的文件
scp -r ~/.ssh/id_rsa.pub root@192.168.1.11:~/.ssh/id_rsa.pub12 scp -r ~/.ssh/id_rsa.pub root@192.168.1.11:~/.ssh/id_rsa.pub13
scp -r ~/.ssh/id_rsa.pub root@192.168.1.11:~/.ssh/id_rsa.pub14
scp -r ~/.ssh/id_rsa.pub root@192.168.1.11:~/.ssh/id_rsa.pub15
执行上面命令后在bigdata1的~/.ssh目录下ls，可看到如下文件
把相关文件追加到authorized_keys后，再进行分发。
cat id_rsa.pub12 &gt;&gt; authorized_keys
cat id_rsa.pub13 &gt;&gt; authorized_keys
cat id_rsa.pub14 &gt;&gt; authorized_keys
cat id_rsa.pub15 &gt;&gt; authorized_keys
chmod 600 authorized_keys （设置读写的权限）
进行分发的操作
scp -r ~/.ssh/authorized_keys root@192.168.1.12:~/.ssh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d2e2ef25260306784942cda01f4ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42726aab056ece6efa4929ba624b676c/" rel="bookmark">
			深度学习之物体检测算法yolov3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 yolov3网络结构
首先回顾下激活函数Relu
Relu函数将输入矩阵x内所有负值都设置为0，其余值不变
在Relu的基础上，引入LeakyRelu
对比Relu，LeakyRelu将负值以一个较小斜率保留下来了
再了解上采样(upsampling)的概念
简单的说就是把图片进行放大了，图片放大一般采用内插值方法，即在原有图像像素点之间采用合适的算法插入新的元素。
对应Pytorch函数，
torch.nn.Upsample(size, # 指定输出tensor大小
scale_factor, # 输出放大的倍数
mode, # 上采样算法，‘nearest’ 最近邻点插值法，‘linear’, ‘bilinear’,’trilinear’ 线性，双线性，三线性，插值法
align_corners # 如果为True表示输出tensor和原有tensor边角是对齐相等的)
使用方式，
import torch.nn as nn
m = nn.Upsample(scaler_factor=2, model=‘bilinear’, align_corners=True)
m(input)
yolov3完整网络结构图如下，结构图来源网上
从上图可以看出，
yolo系列的模型将(卷积+BN+LeakyRelu激活函数)一起作为单元组件CBL
class Conv(nn.Module):
def __int__(self, c1, c2, k=1, s=1):
super(Conv, self).__int__()
self.conv = nn.Conv2d(in_channels=c1, out_channels=c2, kernel_size=k, stride=s)
self.bn = nn.BatchNorm2d(num_features=c2)
self.act = nn.LeakyRelu(0.1)
def forward(self, x):
return self.act(self.bn(self.conv(x)))
yolov3借鉴Resnet的残差结构，由(2个单元组件+残差)构成基础组件ResUnit
class Bottleneck(nn.Module):
def __int__(self, c1, c2, shortcut=True, e=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42726aab056ece6efa4929ba624b676c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe38f873b27d72fc00de8a3fd729eff4/" rel="bookmark">
			达梦DBLINK之DM访问Oracle配置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		达梦通过DBLINK访问Oracle数据库有两种方式一种是通过Oracle oci接口，一种是通过ODBC数据源的方式。
推荐达梦DBLINK使用Oralce OCI的方式去访问Oracle数据库。
推荐达梦DBLINK使用Oralce OCI的方式去访问Oracle数据库。
推荐达梦DBLINK使用Oralce OCI的方式去访问Oracle数据库。
一、下载Oracle客户端驱动（Instant Client） 下载地址：Oracle Instant Client Downloads
目前Oracle Instant Client驱动包已经支持ARM架构平台环境。
选择对应平台的Basic和ODBC驱动包：
Basic Package（instantclient-basic） *必须
ODBC Package （instantclient-odbc）*可选
另外，还需要注意Oracle Instant Client高版本包对glibc版本有要求，需要glibc 2.14或者以上环境
本次测试环境：
操作系统版本：Centos 7
Oracle数据库版本：Oracle 11.2.0.4
DM数据库版本：DM V8 1-2-70 ENT
Oracle Instant Client包版本：19.13
数据库字符集：Oracle ZHS16GBK，DM GB18030
二、查看系统环境 1、检查glibc版本
[root@localhost ~]# rpm -qi glibc Name : glibc Version : 2.17 Release : 307.el7.1 Architecture: x86_64 Install Date: Mon 02 Aug 2021 03:28:10 PM CST Group : System Environment/Libraries Size : 14100570 License : LGPLv2+ and LGPLv2+ with exceptions and GPLv2+ Signature : RSA/SHA256, Sat 04 Apr 2020 04:52:25 AM CST, Key ID 24c6a8a7f4a80eb5 Source RPM : glibc-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe38f873b27d72fc00de8a3fd729eff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db552110b5075c80277c8cda5ed9b337/" rel="bookmark">
			R语言基础数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言基础数据类型 R语言主要有三种基本的数据类型，分别是数值型（Numeric）、整型（integer）以及字符型（character）。
一、数据类型 1.数值型（Numeric） 数值型（Numeric）分为双整型（double）和整型（integer）两种
（1）双整型（double） 双整型数据，可正可负，可大可小，可含小数可不含。
R中键入的任何一个数值都默认以double型存储。可以使用typeof() 函数进行查看数据类型
&gt; typeof(1)#查看“1”的数据类型 [1] "double" #输出结果为双整型 （2）整型（integer）
顾名思义，只能用来储存整数。
在计算机内存中，整型的定义方式要比双整型更加准确（除非该整数非常大或非常小）
&gt; typeof(1L)#在数字后面加大写字母L，申明该数字以整型方式储存。 [1] "integer" &gt; as.integer(-3.14)#将双整形转换为整型 [1] -3 &gt; as.integer(-3.99)#只取整数部分，不会进行四舍五入 [1] -3 2.字符型（character） 字符型向量用以储存一小段文本，在R中字符要加双引号表示
字符型向量中的单个元素被称为“字符串（string）”，注意：字符串不仅可以包含英文字母，也可以由数字或符号组成
&gt; typeof("Hello world") #字符型要加双引号表示 [1] "character" 字符串常用函数举例
&gt; a&lt;-"Hello world"#赋值 &gt; nchar(a)#计算字符串长度 [1] 11 #大小写转换 &gt; toupper(a) [1] "HELLO WORLD" &gt; tolower(a) [1] "hello world" #字符转连接 &gt; paste("hello","world",sep="_") [1] "hello_world" 3.逻辑型（logical） 用以储存TRUE（真）和FALSE（假），在实际使用过程中，可以简写成T/F。
逻辑判断中TRUE相当于数字1，FALSE相当于数字0。
&gt; typeof(T) [1] "logical" &gt; as.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db552110b5075c80277c8cda5ed9b337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98dc920d68a54a1239780d25557294de/" rel="bookmark">
			python的基本语法规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本须知
注释方法：
运行方式：
变量
输入输出方式
输入方式
输出方式
判断语句if
循环
for循环
while循环
对字符串的操作
主要内容：基本注释、运行、变量、输入、输出、条件语句、循环语句、字符转操作。 python是一门语法简洁优雅的语言，在这里我总结了一些python的基本语法规则。因为我刚刚学完c语言，所以本文会有一点体现出我对c语言的python的对比。 基本须知 每一条命令后面不需要加分号（c语言需要加）不区分单双引号，三引号可换行（如下） '''引号与内容的冲突 有时候print中的语句带单/双引号，可能会被编译器”误会“，如下有一些解决方法''' #print('I'm lovely') print('I\'m lovely')#在前面加上斜杠，这样就好了 #print("He said"I love you"")这种可能会有冲突 print("He said \"I love you\"")#前面加上斜杠就不会冲突了 print('\\') #print('\')这个是错的，需要一个斜杠引一个斜杠输出斜杠 注释方法： #单行注释，不可换行 '''多行注释 可以换行''' 表达是非：True/非0表示是，0/False表示非（注意大小写）。 运行方式： 上方工具栏Run中运行 ctrl+shift+F10
右上角点击运行
注意：切换运行代码的时候注意右上角是否是当前运行程序'''
变量 非常简单粗暴，可以直接进行定义，不需要加任何数据类型修饰
a=1 b='a' c="我是猫" 输入输出方式 目前输入和输出方式我只学到一种，若有不足还请指教
输入方式 #a=数据类型（input（提示输入内容）） 一般a得到的默认为字符串类型，想要其他数据类型必须强制转换。（下面是一个简单的小测试，大家可以自己尝试一下。） a=input('任意输入一个数字') print(type(a)) a=int(input('任意输入一个数字')) print(type(a)) #type函数可以测试变量的数据类型 输出结果如图所示：
输出方式 使用函数print。（c语言中是printf，勿混淆） #两个print函数之间默认的间隔方式为换行，有需要可以手动调整：，end=”间隔方式“ print（”我是猫“，end=” “） #以空格隔开 print（”hello world“） print("1","2","3") #正常情况，两输出内容之间会自动用空格隔开 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98dc920d68a54a1239780d25557294de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857eff119958d41ed0e03a71c70561b7/" rel="bookmark">
			我与IT的那些事儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; int main(int argc, const char * argv[]) { printf("Hello, World!"); return 0; } 时光如梭，转眼之间已经进入IT行业7年。这7年虽然没有什么伟大的成就，但是看到自己的成果并且能够一直坚持没有放弃，我还是很满足的，因为真心地喜欢热爱，所以才能够一直坚持不放弃。在此简单聊一些关于我与IT的那些事儿吧！
最初印象 回想起IT对于我的最初印象，还记得那是高中时期，电视上经常能够看到的关于IT行业的广告：学IT，当白领，拿高薪！那时对于这样的广告，对于没什么见识的我来说是完全不懂的，对于IT，对于白领完全没有概念。
擦肩而过 后来高中毕业后才知道计算机专业就是做IT的，但那时候听的最多的有关信息就是说很多专科学校和三本专业都是计算机的，并且学计算机需要很贵的学费，所以对于这个行业也就擦肩而过，直接从我的选择中pass掉了。因为视野的狭窄，见的少，懂的少，接触的少，这也算是我人生中的一个小遗憾的事吧！
再次遇见 再次听到关于IT的信息是在大学时候，还记得那时候加入了一个社团，进入了新闻网络部。一开始都是做一些活动记录和策划之类的琐碎的工作，后来由于社团想要建设一个网站，刚好我们部门有个软件学院的同学，会长让他做了一个单机版的网站，让我来进行测试，那时候的我对于IT的认识就以为学IT就是做网站的，那算是我第一次距离这个行业最近的时候吧！虽然那时候已经有了笔记本电脑，但是也只是拿来办公、看视频、玩游戏了。不过在大学期间学会了装系统，并且还给好几个同学都装了纯净版的Win7，还是挺有成就感的。
真正了解 对于IT的真正了解就到了毕业之后了。还记得那是毕业后工作一年多的时候，突然听到身边有人转行做了IT，并且还有同学对我劝说几次。因为真的不了解，所以不敢轻易尝试，但是随着身边的例子越来越多，并且有个同学是我怎么都不会想到他会转IT的他居然也转了，那时我心动了，我开始主动地了解IT，向身边的朋友了解，在网上搜索了解，通过看视频开始慢慢自学，我发现我喜欢上了这个行业。
正式入行 在做出要转行的决定后，我辞去了稳定的工作，从上海进入北京开始学习，虽然那段时间很苦，每天基本上都是十二点之后睡的，并且早上七点多就起床，中午也不睡午觉，但是我很开心，因为可以做自己真心喜欢的事。从那时开始，我很少玩游戏了，基本上忘记了那时最爱的dota，但是我每天还是很开心。学习结束之后开始正式进入IT，虽然一开始不是特别顺利，但是我还是坚持了下来，并且一直走了下来。
不忘初心 虽然今年到了我与IT的七年之痒，但我不会放弃，我会一直坚持下去，因为这是我真心喜欢热爱的行业！不忘初心，一路前行！
希望朋友们都能够在对的时间遇见对的事！相信明天会更好！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2de4a32d8e16e8d2290c9cb0845da92/" rel="bookmark">
			【闲趣】如何用C语言画出一棵圣诞树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		圣诞节快乐！今天教你用C语言画出一棵圣诞树
下面的是我尝试尽量用最少代码来画一个抽象一点的圣诞树，因此树干都没有。然后，我尝试用更真实一点的风格。因为树是一个比较自相似的形状，这次使用递归方式描述树干和分支。
附上代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char* argv[]) { int n= argc &gt; 1? atoi(argv[1]) : 4; for (int j= 1;j &lt;=n; j++) { int s= 1&lt;&lt; j,k=(1&lt;&lt; n)-s,x; for (int y=s -j; y&gt;= 0; y--, putchar('\n')) { for(x=0;x&lt;y+k; x++) printf(" "); for(x=0;x+y&lt;s;x++) printf("%c ", '!'^y &amp; x); for(x=1;x+y&lt;s;x++) printf("%c ",'!' ^y &amp;(s-y-x-1)); } } } 然后…其他方法：
#include &lt;math.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define PI 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2de4a32d8e16e8d2290c9cb0845da92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d327076dff866f39e4ac0b7acceeb7f1/" rel="bookmark">
			Visual C&#43;&#43;6.0运行执行link.exe出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行 link.exe 时出错.
解决方法如下： project---设置---连接（选项卡）--工程（选项）往下滑有一段
/subsystem:windows /incremental:yes 改为/subsystem:console/incremental:yes就ok了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7949826d78d79e76564810794b2963/" rel="bookmark">
			ebpf中的bpf_probe_read_kernel和pt_regs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行队列 // 获取运行队列长度 // SEC("kprobe/update_rq_clock") int update_rq_clock(struct pt_regs *ctx) { u32 key = 0; u32 rqKey	= 0; struct rq *p_rq = 0; p_rq = (struct rq *)rq_map.lookup(&amp;rqKey); if (!p_rq) { // 针对map表项未创建的时候，map表项之后会自动创建并初始化 return 0; } bpf_probe_read_kernel(p_rq, sizeof(struct rq), (void *)PT_REGS_PARM1(ctx)); u64 val = p_rq-&gt;nr_running; runqlen.update(&amp;key, &amp;val); return 0; } bpf_probe_read_kernel long bpf_probe_read_kernel(void *dst, u32 size, const void *unsafe_ptr) Description Safely attempt to read size bytes from kernel space address unsafe_ptr and store the data in dst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7949826d78d79e76564810794b2963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34dda053e9223b85884a9059bfd02ab7/" rel="bookmark">
			【Java】获取目录下文件信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Java】获取目录下文件信息 需求 输入路径，列出该路径下的是目录还是普通文件、文件名、大小及修改时间，统计文件与文件夹个数，前面标上序号
效果 代码 package com.cxl; import java.io.File; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Scanner; //输入路径，列出该路径下的是目录还是普通文件、文件名、大小及修改时间，统计文件与文件夹个数，前面标上序号 public class Demo28_Filelist { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print("请输入路径名:"); String path = sc.nextLine(); //创建文件对象 File src = new File(path); //输出结果 System.out.println(src.getAbsolutePath()+"下的文件信息显示如下"); System.out.print("序号\t\t"); System.out.print("文件类型\t\t"); System.out.print("文件名\t\t\t\t\t\t\t"); System.out.print("文件大小（字节）\t\t"); System.out.println("最后修改时间"); System.out.println("==================================================================================================="); //调用获取文件信息方法 fileInfo(path); } //获取文件信息 private static void fileInfo(String path) { int fileNum = 0; int dirNum = 0; //时间输出模板 SimpleDateFormat format = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34dda053e9223b85884a9059bfd02ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3849a9ee8701545a2ef928f7fd60cd/" rel="bookmark">
			ZYNQ-7000概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 Xilinx推出的ZYNQ-7000被称为全可编程片上系统（SOC），它由FPGA与ARM组合构成，硬件可编程，软件也可编程，在众多应用场合有一定优势。本文根据Xilinx官网的介绍并结合ZYNQ-7000的多份数据手册总结了此产品的一些基本信息，包括产品简介、资源概览、速度等级、温度等级、命名规则、架构概览等，为大家入门ZYNQ提供帮助。
关键词：ZYNQ；SOC；PL；PS；片上系统
一. SOC简介 参考：Xilinx自适应SOC简介
SOC：System On Chip，也称为All Programmable SOC，称为全可编程片上系统.。.
Xilinx的SOC有4个系列：
ZYNQ-7000，此系列是Xilinx于2015年发布的第一代SOC架构的芯片，也是世界上首个SOC芯片系列ZYNQ UltraScale+ MPSoC，性能强劲ZYNQ UltraScale+ RDSoC，性能强劲Versal ACAP，Xilinx最新发布的芯片，性能也最强 SOC内部集成了单/多个ARM处理器核心与1个FPGA，将软件可编程的硬核处理器与硬件可编程的FPGA集成在一个芯片中。软硬件均可编程也是SOC被称为全可编程片上系统的原因。
SOC中的ARM处理器被称为PS（Processing System，处理系统），而FPGA被称为PL（Progarmmable Logic，可编程逻辑）。SOC = PS + PL，其中，PS为主，与单独的ARM芯片（如ST公司的STM32系列）一样，PS配备了多个外设，如串口，CAN口，GPIO等，PL部分可以看做是PS的一个"可编程外设"。
有人也许有疑问，既然SOC = PS + PL，那么用一个ARM芯片和一个FPGA组合的方式，不考虑面积成本等问题，在性能方面是不是就和SOC一样了呢？答案是不行，因为在同一芯片中，ZYNQ中PS与PL可进行低延时高速片内通信，而两个芯片间的片间通信就难以实现低延时和高速，这是SOC的主要优势之一。
SOC的优点：1.灵活，2.成本低（一个芯片比两个芯片便宜）
SOC的缺点：1.开发难度大，开发人员最好同时会FPGA和ARM
二. ZYNQ-7000系列产品简介 参考：Xilinx ZYNQ-7000产品简介与技术文档
2.1 7000S与7000的区别 ZYNQ-7000 SOC分为ZYNQ-7000S 与 ZYNQ-7000两类产品，7000S中的S是Single（单个）的缩写，指的是7000S芯片中只集成了一个A9核，而7000是两个。
2.2 资源概览 参考：ZYNQ-7000产品选型手册.pdf
可见7000系列芯片不同型号间的主要区别在于：1.处理器核心数，2.处理器主频，3.PL资源，而外设没区别。
2.3 速度等级与温度等级 可见，速度等级共分3级，-1最慢，-2中等，-3最快。带L表示Low Power（低功耗）
温度等级共分3级：
C，Commerical，商业级，0~85℃
E，Extended，扩展级，0~100℃
I，Industrial，工业级，-40~+100℃
2.4 芯片命名规则 如 XC7Z020-2CLG484I，表示芯片是ZYNQ-7020，速度等级-2，封装CLG484的工业级芯片。
三. ZYNQ-7000数据手册：概览 参考：ds190 ZYNQ-7000-概览.pdf
3.1 ZYNQ-7000描述 Zynq-7000系列基于Xilinx的第一代SoC架构。这些产品在单个设备中集成了功能丰富的基于双核或单核ARM Cortex-A9的处理系统（PS）和28nm Xilinx可编程逻辑（PL）。ARM Cortex-A9 CPU是PS的核心，此外还包括片上存储器，外部存储器接口以及丰富的外围接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b3849a9ee8701545a2ef928f7fd60cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0266fae6dd8b9a6e901843025f6199/" rel="bookmark">
			ZYNQ7000-AXI GPIO详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 AXI GPIO是ZYNQ的一个IP核，它能够将PS侧的AXI4-Lite接口转成PL侧的IO口，可解决PS侧IO口不够用的问题。本文就AXI GPIO的概念、作用、配置与使用做了详细说明，展示了示例的Vivado工程和AXI GPIO输入、输出与中断配置的代码。
关键词：AXI GPIO；ZYNQ；AXI4-Lite；GPIO；中断
前言 本文参考：PG144 - AXI GPIO v2.0 Product Guide (v2.0)
一. AXI GPIO的概念与作用 AXI GPIO是ZYNQ PL部分的一个IP软核，此IP核提供AXI-Lite Master接口转GPIO的功能，且一个AXI-Lite Master通过AXI interconnect可以与多个AXI GPIO IP核相连，如下图所示。也就是说PS部分通过GP接口以及AXI GPIO IP核可实现多个GPIO，一个GP接口最多可以接几个AXI GPIO IP核我不知道，手册中没写，我这里接了4个没什么问题。.
我们知道ZYNQ的PS可通过EMIO来使用PL部分的引脚实现GPIO功能，但当使用的引脚很多时，PS程序中控制引脚方向、中断等将变得繁琐，这时如果使用PS的GP接口（AXI3 Master）接口通过AXI Interconnect连接AXI GPIO IP核，就可以在PS部分通过更简单的程序方便地控制众多PL引脚实现GPIO功能。
所以，从功能上来说，PS通过EMIO还是AXI GPIO来实现GPIO没有区别，都能输入/输出以及产生中断，但AXI GPIO在多引脚时在程序的复杂度方面有一定优势。
二. AXI GPIO IP核设置与使用 2.1 AXI GPIO的最大工作时钟频率 需要注意，AXI GPIO的AXI-Lite接口的时钟频率，超频可能会导致此IP核无法正常工作。
2.2 AXI GPIO设置 AXI GPIO IP核默认为单通道，可选GPIO宽度为1~32，可设置GPIO方向（注意如果在这里设置了All Input/Output，那么在PS程序中就无需再设置GPIO方向，设置了也无效，建议不要在这里设置，通过PS程序去设置，保持灵活性），可设置输出默认值与三态默认值。
可勾选Enable Dual Channel，打开双通道。
可勾选Enable Interrupt，打开GPIO中断功能，此中断属于PL对PS的中断，所以需要连接到ZYNQ7核的IRQ_F2P端口，如下图所示。
因为使用了AXI接口，我们知道AXI是读写数据的，它必须对应存储器（RAM，DDR等），所以在设置好IP核并连线完成后，需要对每个AXI GPIO的S_AXI进行存储器地址映射，规定S_AXI去读写哪个地址段。
打开Address Editor窗口，右击选择Assign All即可。
效果如下图。
这里需要说明，因为在PS的库函数中对多个AXI GPIO的情况是有排序的（在xparameters.h中每个AXI GPIO对应不同的ID，如下图），我们需要知道PL的Block Design中哪个AXI GPIO对应PS库中的AXI GPIO 0，哪个对应AXI GPIO 1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a0266fae6dd8b9a6e901843025f6199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dbb0bef97d1c6703ab7f84a1fe922d4/" rel="bookmark">
			Manjaro系统配置Chisel开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Manjaro系统上配置Chisel开发环境 1. 安装依赖sbtChisel 2. Chisel工程创建3. Hello Chisel踩坑记录 1. 安装依赖 sbt sbt是scala的构建工具，大概相当于Java中的Maven。Arch系系统上可以一键安装
yay -S sbt 配置sbt国内镜像源：建立~/.sbt/repositories, 填写以下内容（按照这篇博客）
[repositories] #本地源 local #兼容 Ivy 路径布局 apache-ivy: https://repo1.maven.apache.org/maven2/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext] #apache maven apache-mvn: https://repo1.maven.apache.org/maven2/ #国内源，aliyun aliyun: https://maven.aliyun.com/nexus/content/groups/public/ #添加国外源备用 typesafe: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly sonatype-oss-releases maven-central sonatype-oss-snapshots Chisel FIRRTL是Chisel到Verilog的中间语言，Verilator是仿真器，可以一键安装
yay -S chisel firrtl verilator 2. Chisel工程创建 vscode装Scala(Metals)插件，新建scala-helloworld工程
创建好的hello-world项目长这个样子
编辑build.sbt文件，加入以下内容以支持Chisel
addCompilerPlugin("edu.berkeley.cs" % "chisel3-plugin" % "3.5.4" cross CrossVersion.full) libraryDependencies += "edu.berkeley.cs" %% "chisel3" % "3.5.4" // We also recommend using chiseltest for writing unit tests libraryDependencies += "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dbb0bef97d1c6703ab7f84a1fe922d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0b15db2be10932d7f57ff634b200b2/" rel="bookmark">
			ZYNQ7000-MIO与EMIO详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文参考芯片手册详细介绍了ZYNQ7000芯片的信号、接口与引脚，结合芯片封装说明了引脚的类别与分布，并说明了MIO与EMIO的区别。
关键词：ZYNQ；信号；引脚；MIO；EMIO；Bank
前言 了解ZYNQ7000的基础知识可参考我的另一篇博客：
传送门：ZYNQ-7000概述
一. ZYNQ7000的信号、接口与引脚 参考：UG585 - Zynq-7000 SoC Technical Reference Manual (v1.12.2) 42~59页–Ch2: Signals, Interfaces, and Pins。
1.1 ZYNQ7000引脚分组 下图展示了ZYNQ7000信号、接口与引脚的大致分组。
可见，ZYNQ7000分为PS与PL两部分，信号、接口和引脚也分属这两部分。
PS部分：
分类名称说明PS信号与接口PS_CLKPS侧专用时钟引脚，为CPU工作提供外部时钟POR_RST_N
SRST_Npower on reset 上电复位
外部输入的同步复位DDR Memory连接DDR的接口USB连接USB的接口Quad-SPI连接FLASH的接口NAND, NOR/SRAM连接SRAM的接口PS Power PinsPS Power PinsPS电源引脚，提供多种电平的电源Boot Mode MIOBoot Mode MIOPS侧的启动模式引脚，控制ZYNQ的启动模式MIO Pins,
EMIO SignalsGigE, SDIO, SPI, I2C,
CAN, UART, GPIO, TTC, SWDTPS侧多种外设，既可以使用MIO引脚，
也可以使用EMIO引脚JTAGJTAGPS与PL共有的JTAG引脚，
烧写与调试PS/PL程序 PL部分：
分类名称说明PL SignalsUser SelectIOPL为FPGA，用户可更加需要任意指定信号对应的引脚XADCPL部分的ADC，对应引脚为固定的ADC专用引脚MGTX只所示这几种芯片才有的MGTX专用引脚PL Power PinsPL Power PinsPL供电引脚，提供多种PL电平 PS-PL交互部分（交互在芯片内部，故只存在接口与信号，不存在引脚）：
分类名称说明AXI InterfacesM_AXI_GP × 22组AXI GP主机接口S_AXI_GP × 22组AXI GP从机接口S_AXI_HP × 44组AXI HP从机接口S_AXI_ACP1组AXI ACP从机接口Misc（杂项）,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0b15db2be10932d7f57ff634b200b2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/127/">«</a>
	<span class="pagination__item pagination__item--current">128/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/129/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>