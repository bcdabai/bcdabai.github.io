<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0fb80715c12f6e398a4b80a63866ac/" rel="bookmark">
			JS获取动态添加的元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在页面的渲染中,我们经常用遇到动态添加的DOM元素,那么在获取这些元素的时候或则为这些DOM元素的时候,我们有下面三种处理方法:
// 1. 在模板引擎里面添加行内事件 // 2. 利用事件的委托获取(常用) // 3. 在ajax的监听响应完成函数后面获取 一 在模板引擎里面添加行内事件
添加行内事件就是在标签里面添加事件,这样就可以直接获取到动态添加的元素.
&lt;!-- 1.准备一个模板 --&gt; &lt;script id="tpl-table" type="text/html"&gt; {{ each rows value key }} &lt;tr&gt; &lt;td&gt; &lt;button type="button" onclick="updateUser({{ value.id }} {{@ ','}} {{value.isDelete}})" id="btn-status" &gt;按钮&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; {{ /each }} &lt;/script&gt; //事件函数,书写在单独的JS文件中 //带有参数,参数是模板传递过来的 function updateUser (id,isDelete){ //doSomething......... } 上面使用的模板是art-template,在模板里面我们给button标签注册了点击事件onclick,但是事件函数却是一个带参数的函数.当点击这个按钮的时候,就会触发点击事件,进而调用updateUser()函数.
二. 利用事件的委托获取(常用)
事件的委托可以为动态添加的元素绑定事件.
//同样以上面的代码为例,tr最后是添加到table中,那么将点击事件委托给table $('table').on('click','tr #btn-status',function(){ //doSomething........ }) 上面的代码意思是,将点击事件绑定给table元素,但是我们点击的是table里面的button按钮,此时事件的冒泡起作用,向外冒泡遇到父元素table也有点击事件,那么就会去执行这个事件.
三 在ajax的监听响应完成函数后面获取
当我们把模板渲染出来的时候,此时页面上已经是最新的动态元素了,DOM也已经重绘完成,此时再去获取动态元素.
$.ajax({ url : 'text.php', dataType : 'json', success : function(obj){ //渲染动态元素到页面上 var trHTML = template('tpl-table',obj); $('table').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a0fb80715c12f6e398a4b80a63866ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6ad499a2f49bd1272f9b13c6ff2bc0/" rel="bookmark">
			如何备份以及恢复Windows系统的环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【时间】2018.10.14
【题目】如何备份以及恢复Windows系统的环境变量
概述 备份Windows系统环境变量有两种办法，一种方法是直接备份环境变量注册表（使用regedit打开注册表编辑器），另一种是使用set命令。
一、备份环境变量注册表 Win+R打开运行，在搜索输入框里输入regedit，回车打开注册表编辑器。
环境变量在下面两个位置：
系统环境变量：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment 用户环境变量：HKEY_CURRENT_USER\Environment 分别定位到系统环境变量和用户环境变量的位置，鼠标右键Export导出即可备份。
【注意】使用注册表导出功能备份的环境变量，如果变量类型为REG_EXPAND_SZ等类型时，导出格式为16进制。
二、用命令中的set命令备份 在命令行下执行：
set &gt;&gt; d:\tmp\environment.txt
就可以把环境变量备份到文件。
【注意】d:\tmp\environment.txt是保存的备份文件的路径及名字，必须保证路径d:\tmp\存在，否则会报以下错误：
三、恢复环境变量（仅限注册表恢复） 双击导出的REG文件以导入。但极有可能因为环境变量保存位置的不同使环境变量无法使用。所以在导入前，最好能查找一下当前系统中环境变量的保存位置，再用“记事本”打开REG文件，将键值更改为当前环境变量保存位置的键值（如图6）。导入后，重启系统就可以了。
参考文献：
https://blog.csdn.net/arxi/article/details/47171623#commentBox
https://blog.csdn.net/gotohailang/article/details/19476655
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/805e9b0d31ab61fbbd91020efa0d5a69/" rel="bookmark">
			Servlet/Jsp学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先先明确servlet是用来处理客户端请求的
servlet的作用： 1.获取表单数据
2.获取浏览器附加信息
3.处理数据（在servlet中调用其它的处理数据方式来完成，如jdbc rpc等）
4.给客户端产生一个响应
5.在响应中添加附加信息
浏览器与服务器会话状态信息
cookie: 分为 会话cookie（随浏览器关闭而结束） 和 持久化cookie（持久化到本地，可以通过cookie.setMaxAge(2000)设置有效时长）
存在于客户端浏览器，每一次请求都会将有效的cookie发送给服务器 所以cookie有数量限制（具体数量与不同浏览器有关）
session: 分为两部分 sessionid与session（键值对的关系） 存在服务器端，服务器通过cookie将sessionid发送给浏览器，
所以可以在不同请求间传递信息 1.关闭tomcat 2.reload web应用 3.session时间到 （在web.xml中配置）4invalidate session（方法调用强制失效
servlet的实例化： 容器利用Java反射实例化servlet对象
类反射加载机制：Class clazz=Class.forName("类名") 或者用一个实例对象getClass（）方法 加载类
进行了IO类加载以及静态成员初始化操作
Servlet obj=clazz.newInstance（）在堆内存完成所有成员变量初始化创造对象
obj.init();
servlet 生命周期 servlet生命周期是由容器管理
分为三个阶段： init初始化 service 服务 destroy 销毁
当客户端浏览器第一次请求该servlet时，Tomcat会立即创建该servlet对象，并立即调用init（）完成初始化 并且在新的线程中调用service（）方法。
Tomcat会对已经实例化的servlet对象进行缓存，当有客户端浏览器再次请求该servlet，容器不会再次创建servlet对象，而是在一个新的线程中调用service（）方法。
在容器关闭时， 容器会在servlet对象销毁之前调用一次destroy（）方法
//servlet可以在web.xml中配置，使其在容器启动时初始化，不必依赖于请求而创建
cookie和session： HTTP是无连接的不能记录状态信息，而在一些场景下需要这些状态信息（记住用户名，验证是否已经登陆，验证码等信息）
所以记录客户端状态，识别请求状态需要cookie session
cookie: 分为 会话cookie（随浏览器关闭而结束） 和 持久化cookie（持久化到本地，可以通过cookie.setMaxAge()设置有效时长 单位为Second秒）
存在于客户端浏览器，每一次请求都会将有效的cookie发送给服务器 所以cookie有数量限制（具体数量与不同浏览器有关）
session: 分为两部分 sessionid与session（键值对的关系） 存在服务器端，服务器通过cookie将sessionid发送给浏览器， 所以可以在不同请求间传递信息 session失效方法：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/805e9b0d31ab61fbbd91020efa0d5a69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d44a5cb5820b492c1744868d179f02a/" rel="bookmark">
			机器学习：Multinoulli分布与多项式分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习深度学习时遇见multinoulli分布，在此总结一下机器学习中常用的multinoulli分布与多项式分布之间的区别于关系，以便更好的理解其在机器学习和深度学习中的使用。
首先介绍一下其他相关知识。
Bernoulli分布 （两点分布） Bernoulli分布是单个二值随机变量的分布。它由单个参数控制，给出了随机变量等于1的概率。
二项分布（n重Bernoulli分布） 二项分布（binomial distribution）用以描述N次独立的伯努利实验中有m次成功（即x=1）的概率，其中每次伯努利实验成功的概率为。
多项分布 若将伯努利分布由单变量扩展为d维向量，其中且,并假设取1的概率为,，则将得到离散概率分布
在此基础上扩展二项分布则得到多项分布（nultinomial distribution），它描述了在N次独立实验中有次的概率。 multinoulli分布（范畴分布、分类分布(categotical distribution)） mutinoulli分布是指在具有k个不同状态的单个离散型随机变量上的分布，其中k是一个有限值。 mutinoulli分布由分布向量参数化，其中每一个分量表示第i个状态的概率。最后的第k个状态的概率可以通过给出。注意我们必须限制。mutinoulli分布经常用来表示对象分类的分布，所以我们很少假设状态1具有数值1之类的。因此我们通常不需要去计算mutinoulli分布的随机变量的期望和方差。
mutinoulli分布是多项式分布的一个特例。多项式分布是中的向量的分布，用于表示当对mutinoulli分布采样n次时k个类中的每一个被访问的次数。很多文章使用“多项式分布”而实际上说的是mutinoulli分布，但是他们并没有说是对（一次实验）的情况，这点需要注意。大概意思就是说multinouli分布进行一次实验，得到了各个状态k的概率分布p，多项分布是重复对multinoulli分布进行n次采样实验，看k个类中每一个被采样到的次数。我觉得很像bernoulli分布与二项分布的关系。（大家有不同想法的可以留言讨论！）
参考文献：
《概率论与数理统计》韩旭里，谢永钦
《机器学习》周志华
《深度学习》Ian GoodFellow
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b750a2869dcaebb832cf658fcd2e261c/" rel="bookmark">
			【技巧】谷歌Chrome浏览器清理缓存的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：执行图示操作
第二种：使用调试面板
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a6c402e55df859f6ca650882f41634/" rel="bookmark">
			阿里云无法从外网访问某端口-端口被禁止访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家关注我的公众号，会不定期更新一些开发与测试的一些技术文章。
一、新购买的阿里云服务器，配置好后，localhost是可以正常访问项目的，但是无法从外网访问，这就说明端口被禁止访问了。解决此问题的方法如下：
1、登录阿里云的管理控制台，找到实例：
2、在实例右边的操作选项里，选择“更多”，选择“安全组配置”：
3、进入“安全组配置”后，点击“配置规则”：
4、选择“入方向”，点击“添加安全组规则”：
5、如果是80端口无法访问，就按照如下设置：
6、如果是8080端口无法访问，就如下设置：
根据个人所需设置好端口后，再访问服务器IP，网站就正常显示了！
参考：https://www.cnblogs.com/klmei/p/7055571.html
欢迎大家关注我的公众号，会不定期更新一些开发与测试的一些技术文章。
本篇完。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31db1be78687d20c1f377733c917e851/" rel="bookmark">
			JSP页面出现Invalid location of tag (div)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		意为:不合法的标签标记
原因是我使用标签的方法不对
把table标签删除就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530e1fd7b464e7098e4086d70ad82047/" rel="bookmark">
			sklearn 神经网络MLPclassifier参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class sklearn.neural_network.MLPClassifier(hidden_layer_sizes=(100, ), activation=’relu’, solver=’adam’, alpha=0.0001, batch_size=’auto’, learning_rate=’constant’, learning_rate_init=0.001, power_t=0.5, max_iter=200, shuffle=True, random_state=None, tol=0.0001, verbose=False, warm_start=False, momentum=0.9, nesterovs_momentum=True, early_stopping=False, validation_fraction=0.1, beta_1=0.9, beta_2=0.999, epsilon=1e-08, n_iter_no_change=10)[source] 参数备注hidden_​​layer_sizestuple，length = n_layers - 2，默认值（100，）第i个元素表示第i个隐藏层中的神经元数量。激活{‘identity’，‘logistic’，‘tanh’，‘relu’}，默认’relu’ 隐藏层的激活函数：‘identity’，无操作激活，对实现线性瓶颈很有用，返回f（x）= x；‘logistic’，logistic sigmoid函数，返回f（x）= 1 /（1 + exp（-x））；‘tanh’，双曲tan函数，返回f（x）= tanh（x）；‘relu’，整流后的线性单位函数，返回f（x）= max（0，x）slover{‘lbfgs’，‘sgd’，‘adam’}，默认’adam’。权重优化的求解器：'lbfgs’是准牛顿方法族的优化器；'sgd’指的是随机梯度下降。'adam’是指由Kingma，Diederik和Jimmy Ba提出的基于随机梯度的优化器。注意：默认解算器“adam”在相对较大的数据集（包含数千个训练样本或更多）方面在训练时间和验证分数方面都能很好地工作。但是，对于小型数据集，“lbfgs”可以更快地收敛并且表现更好。alphafloat，可选，默认为0.0001。L2惩罚（正则化项）参数。batch_sizeint，optional，默认’auto’。用于随机优化器的minibatch的大小。如果slover是’lbfgs’，则分类器将不使用minibatch。设置为“auto”时，batch_size = min（200，n_samples）learning_rate{‘常数’，‘invscaling’，‘自适应’}，默认’常数"。 用于权重更新。仅在solver ='sgd’时使用。'constant’是’learning_rate_init’给出的恒定学习率；'invscaling’使用’power_t’的逆缩放指数在每个时间步’t’逐渐降低学习速率learning_rate_， effective_learning_rate = learning_rate_init / pow（t，power_t）；只要训练损失不断减少，“adaptive”将学习速率保持为“learning_rate_init”。每当两个连续的时期未能将训练损失减少至少tol，或者如果’early_stopping’开启则未能将验证分数增加至少tol，则将当前学习速率除以5。learning_rate_initdouble，可选，默认为0.001。使用初始学习率。它控制更新权重的步长。仅在solver ='sgd’或’adam’时使用。power_tdouble，可选，默认为0.5。反缩放学习率的指数。当learning_rate设置为“invscaling”时，它用于更新有效学习率。仅在solver ='sgd’时使用。max_iterint，optional，默认值200。最大迭代次数。solver迭代直到收敛（由’tol’确定）或这个迭代次数。对于随机解算器（‘sgd’，‘adam’），请注意，这决定了时期的数量（每个数据点的使用次数），而不是梯度步数。shufflebool，可选，默认为True。仅在solver ='sgd’或’adam’时使用。是否在每次迭代中对样本进行洗牌。random_stateint，RandomState实例或None，可选，默认无随机数生成器的状态或种子。如果是int，则random_state是随机数生成器使用的种子;如果是RandomState实例，则random_state是随机数生成器;如果为None，则随机数生成器是np.random使用的RandomState实例。tolfloat，optional，默认1e-4 优化的容忍度，容差优化。当n_iter_no_change连续迭代的损失或分数没有提高至少tol时，除非将learning_rate设置为’adaptive’，否则认为会达到收敛并且训练停止。verbosebool，可选，默认为False 是否将进度消息打印到stdout。warm_startbool，可选，默认为False，设置为True时，重用上一次调用的解决方案以适合初始化，否则，只需擦除以前的解决方案。请参阅词汇表。momentumfloat，默认0.9，梯度下降更新的动量。应该在0和1之间。仅在solver ='sgd’时使用。nesterovs_momentum布尔值，默认为True。是否使用Nesterov的势头。仅在solver ='sgd’和momentum&gt; 0时使用。early_stoppingbool，默认为False。当验证评分没有改善时，是否使用提前停止来终止培训。如果设置为true，它将自动留出10％的训练数据作为验证，并在验证得分没有改善至少为n_iter_no_change连续时期的tol时终止训练。仅在solver ='sgd’或’adam’时有效validation_fractionfloat，optional，默认值为0.1。将训练数据的比例留作早期停止的验证集。必须介于0和1之间。仅在early_stopping为True时使用beta_1float，optional，默认值为0.9，估计一阶矩向量的指数衰减率应为[0,1)。仅在solver ='adam’时使用beta_2float，可选，默认为0.999,估计一阶矩向量的指数衰减率应为[0,1)。仅在solver ='adam’时使用epsilonfloat，optional，默认值1e-8, adam稳定性的价值。 仅在solver ='adam’时使用n_iter_no_changeint，optional，默认值10,不符合改进的最大历元数。 仅在solver ='sgd’或’adam’时有效 属性备注classes_array or list of array of shape （n_classes，）每个输出的类标签。loss_float,使用损失函数计算的当前损失。coefs_list，length n_layers - 1,列表中的第i个元素表示对应于层i的权重矩阵。intercepts_list，length n_layers - 1,列表中的第i个元素表示对应于层i + 1的偏置矢量。n_iter_int，迭代次数。n_layers_int,层数。n_outputs_int,输出的个数。out_activation_string，输出激活函数的名称。 方法备注fit（X，y）使模型适合数据矩阵X和目标y。get_params（[deep]）获取此估算器的参数。predict（X）使用多层感知器分类器进行预测predict_log_proba（X）返回概率估计的对数。predict_proba（X）概率估计。score（X，y [，sample_weight]）返回给定测试数据和标签的平均准确度。set_params（** params）设置此估算器的参数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f127256e29eb7b304ecd534ddaf827cd/" rel="bookmark">
			自己是笨呢?还是笨呢?(第一次使用markdown,发布都不会,总显示不能使用默认标题,终于解决了.)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次使用markdown 竟然连发布都不会,总是提示不能使用默认标题. 解决方案:眼神好一点…再好一点…
浏览器最上面一行是标题,改变即可 查了几篇博客,竟然回答的高深莫测,驴头不对马嘴…
多态,其实就是人类和美国人,中国人的区别,总的来说本质没有区别,只是精神上有些互相歧视,肉体有些为适应环境所具有的些微差距.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84dd2a8138679c5d36f84b7164751e08/" rel="bookmark">
			Android Studio 真机调试与虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机调试： 1.创建一个简单的hello world例子（支持C++）
2.SDK manager（根据个人需要选择安装 勾选并点击右下角apply即会自动安装）
3.AVD manager
4.运行android程序
弹出选择设备框时有可能无法查到创建的虚拟设备
此时打开SDK manager 查看sdk路径
cmd命令行到（比如： G:\Android\Sdk\platform-tools）路径下
#adb kill-server
#adb start-server
如果上述方法不行，任务管理器-&gt;详细信息 查看adb.exe 的PID
#taskkill /f /pid 963
#adb start-server
**
真机调试 **
1.SDK manager查看USB Driver是否安装
2.开发者选项(开启) -&gt;USB调试（开启）
3.Edit Configurations 设置USB Device 选项
如果出现没有找到设备，参照上面虚拟机调试时进行处理
查看真机手机具体arm版本 （真机已经连接的时候）
cmd命令行到adb.exe 路径 （注：G:\Android\Sdk\platform-tools是我adb.exe所在目录）
G:\Android\Sdk\platform-tools&gt; adb shell getprop ro.product.cpu.abi
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55d731dc5668363a9bc8df859e75eb4/" rel="bookmark">
			add_axes()——python绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		add_axes新增子区域 add_axes为新增子区域，该区域可以座落在figure内任意位置，且该区域可任意设置大小
可以用来做一些子图，图中图
考虑如下代码：
import numpy as np
import matplotlib.pyplot as plt
#新建figure
fig = plt.figure()
#定义数据
x = [1, 2, 3, 4, 5, 6, 7]
y = [1, 7, 15, 24, 30, 50, 55]
#新建区域ax1
#figure的百分比,从figure 10%的位置开始绘制, 宽高是figure的80%
left, bottom, width, height = 0.1, 0.1, 0.8, 0.8
#获得绘制的句柄
ax1 = fig.add_axes([left, bottom, width, height])
ax1.plot(x, y, ‘r’)
ax1.set_title(‘area1’)
#新增区域ax2,嵌套在ax1内，看一看图中图是什么样，这就是与subplot的区别
left, bottom, width, height = 0.2, 0.6, 0.25, 0.25
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55d731dc5668363a9bc8df859e75eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d384d91b9fd593cf19a6010870c8cf/" rel="bookmark">
			bar()函数——python绘制柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绘制柱状图，我们主要用到bar()函数。 只要将该函数理解透彻，我们就能绘制各种类型的柱状图。
我们先看下bar()的构造函数：bar(x，height， width，*，align=‘center’，**kwargs) x 包含所有柱子的下标的列表 height 包含所有柱子的高度值的列表 width 每个柱子的宽度。可以指定一个固定值，那么所有的柱子都是一样的宽。或者设置一个列表，这样可以分别对每个柱子设定不同的宽度。 align 柱子对齐方式，有两个可选值：center和edge。center表示每根柱子是根据下标来对齐, edge则表示每根柱子全部以下标为起点，然后显示到下标的右边。如果不指定该参数，默认值是center。 其他可选参数有：
color 每根柱子呈现的颜色。同样可指定一个颜色值，让所有柱子呈现同样颜色；或者指定带有不同颜色的列表，让不同柱子显示不同颜色。 edgecolor 每根柱子边框的颜色。同样可指定一个颜色值，让所有柱子边框呈现同样颜色；或者指定带有不同颜色的列表，让不同柱子的边框显示不同颜色。 linewidth 每根柱子的边框宽度。如果没有设置该参数，将使用默认宽度，默认是没有边框。 tick_label 每根柱子上显示的标签，默认是没有内容。 xerr 每根柱子顶部在横轴方向的线段。如果指定一个固定值，所有柱子的线段将一直长；如果指定一个带有不同长度值的列表，那么柱子顶部的线段将呈现不同长度。 yerr 每根柱子顶端在纵轴方向的线段。如果指定一个固定值，所有柱子的线段将一直长；如果指定一个带有不同长度值的列表，那么柱子顶部的线段将呈现不同长度。 ecolor 设置 xerr 和 yerr 的线段的颜色。同样可以指定一个固定值或者一个列表。 capsize 这个参数很有趣, 对xerr或者yerr的补充说明。一般为其设置一个整数，例如 10。如果你已经设置了 yerr 参数，那么设置 capsize 参数，会在每跟柱子顶部线段上面的首尾部分增加两条垂直原来线段的线段。对 xerr 参数也是同样道理。可能看说明会觉得绕，如果你看下图就一目了然了。 error_kw 设置 xerr 和 yerr 参数显示线段的参数，它是个字典类型。如果你在该参数中又重新定义了 ecolor 和 capsize，那么显示效果以这个为准。 log 这个参数，我暂时搞不懂有什么用。 orientation 设置柱子是显示方式。设置值为 vertical ，那么显示为柱形图。如果设置为 horizontal 条形图。不过 matplotlib 官网不建议直接使用这个来绘制条形图，使用barh来绘制条形图。 下面调用 bar 函数绘制一个简单的柱形图。
import matplotlib.pyplot as plt import numpy as np # 创建一个点数为 8 x 6 的窗口, 并设置分辨率为 80像素/每英寸 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01d384d91b9fd593cf19a6010870c8cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e04ef1285d92a684dfdc871e0dc4447/" rel="bookmark">
			mysql时间加减
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql时间加减
DATE_SUB()和DATE_ADD()函数，实现日期增减
DATE_SUB(NOW(),INTERVAL 30 MINUTE) 当前时间减30分钟
DATE_SUB(NOW(),INTERVAL 1 day) 当前时间减1天
DATE_SUB(NOW(),INTERVAL 1 hour) 当前时间减1小时 DATE_SUB(NOW(),INTERVAL 1 second) 当前时间减1秒
DATE_SUB(NOW(),INTERVAL 1 week) 当前时间减1星期
DATE_SUB(NOW(),INTERVAL 1 month) 当前时间减1个月 DATE_SUB(NOW(),INTERVAL 1 quarter) 当前时间减1季度
DATE_SUB(NOW(),INTERVAL 1 year) 当前时间减1年
相对DATE_ADD()是加时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a856e2288e69756391c5a618faa534a2/" rel="bookmark">
			[NOIP 2013普及组 No.3] 小朋友的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NOIP 2013普及组 No.3] 小朋友的数字 【题目描述】 有n个小朋友排成一列。每个小朋友手上都有一个数字，这个数字可正可负。规定每个小朋友的特征值等于排在他前面（包括他本人）的小朋友中连续若干个（最少有一个）小朋友手上的数字之和的最大值。
作为这些小朋友的老师，你需要给每个小朋友一个分数，分数是这样规定的：第一个小朋友的分数是他的特征值，其它小朋友的分数为排在他前面的所有小朋友中（不包括他本人），小朋友分数加上其特征值的最大值。
请计算所有小朋友分数的最大值，输出时保持最大值的符号，将其绝对值对p取模后输出。
【输入格式】 第一行包含两个正整数n、p，之间用一个空格隔开。
第二行包含n个数，每两个整数之间用一个空格隔开，表示每个小朋友手上的数字。
【输出格式】 输出只有一行，包含一个整数，表示最大分数对p取模的结果。
【样例输入1】 5 997 1 2 3 4 5 【样例输出1】 21 【样例输入2】 5 7 -1 -1 -1 -1 -1 【样例输出2】 -1 【提示】 样例1小朋友的特征值分别为1、3、6、10、15，分数分别为1、2、5、11、21，最大值21对997的模是21。
样例2小朋友的特征值分别为-1、-1、-1、-1、-1，分数分别为-1、-2、-2、-2、-2，最大值-1对7的模为-1，输出-1。
对于50%的数据，1≤n≤1,000，1≤p≤1,000所有数字的绝对值不超过1000；
对于100%的数据，1≤n≤1,000,000，1≤p≤10^9，其他数字的绝对值均不超过10^9。
转载于:https://www.cnblogs.com/ningnoip/p/9772758.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69682b8c0cf0cf55350b255eaabc5ca0/" rel="bookmark">
			mysql Date类型与String类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Date ——&gt; String 使用的函数：DATE_FORMAT(date,format) date:需要转换的日期 format:格式化的样式
format样式整理：
年： %Y 显示四位 ： 2015 %y 只显示后两位 ：15
月： %M 月份的英文显示：October %m 月份的阿拉伯显示：01-12 %b 月份的英文缩略显示：Oct %c 月份的阿拉伯显示：1-12
日： %d 阿拉伯显示：00-31 %D 带有英文后缀：1st-31th %e 阿拉伯显示：1-31 %j 年的天：001-366 时： %H ：00-23 %h:01-12 %I:01-12 %k:0-23 %l:1-12
分： %i：00-59
秒： %S：00-59 %s:00-59
微妙： %f
AM/PM:%p
12小时制时间：%r: 02:02:44 PM
24小时制时间： %T： 14:02:44
周： %W：周的英文显示 %w 周的阿拉伯显示 ：0（星期日）-6（星期六） %a 周的英文缩略显示：Mon-
eg:DATE_FORMAT(now(),"%Y-%m-%d %T") 2015-09-01 17:10:52
DATE_FORMAT(now(),"%Y-%m-%d %H:%i:%s %p") 2015-09-01 17:10:52 PM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69682b8c0cf0cf55350b255eaabc5ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29029cf169ef073bc8340b542a1f3296/" rel="bookmark">
			Android Studio Run &#39;app&#39;安装APK到设备的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/u011967006/article/details/78158257
1.AndroidStudio 点击Run ‘app’。
2.点击Run ‘app’就会将所有.class文件用SDK工具集处理成.dex，
用SDK工具集将图片/资源/布局文件/AndroidManifest等等/dex文件，最后全部统一打包成.apk文件。
3.将打包好的xxx.apk文件,推送到Device中，并启动安装程序去执行安装。
4.释放xxx.apk文件目录到/data/data/项目的唯一包名packageName （现在知道为什么包名必须唯一了吧）。
5.文件资源释放成功后，还会将xxx.apk文件，载入到/data/app/xxx.apk。
还需要知道的是：我们开发的应用程序为普通应用程序，系统应用程序在系统目录中。
普通应用程序目录为：data/app/
系统应用程序目录为：system/app/
--------------------- 作者：刘德利_Android 来源：CSDN 原文：https://blog.csdn.net/u011967006/article/details/78158257?utm_source=copy 版权声明：本文为博主原创文章，转载请附上博文链接！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aaea8eb6d8974777a05d48ac69cd736/" rel="bookmark">
			什么是磁盘碎片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际上，磁盘碎片应该称为文件碎片，因为文件会分别保存到整个磁盘的不同位置，而不是连续保存在磁盘的连续群集中。
当应用程序所需的物理内存不足时，通常操作系统会在硬盘上生成临时交换文件。此临时交换文件占用的磁盘空间用于形成虚拟内存。虚拟内存的管理程序将经常在硬盘上读写并产生大量碎片。这是硬盘碎片化的主要原因。除此之外，系统中的临时文件会导致很多碎片。当IE浏览器浏览信息或用户直接设置它们时生成临时文件。频繁的磁盘碎片整理可以提高计算机硬盘的服务效率。
定义 磁盘碎片是指在读写硬盘过程中产生的不连续文件。写在硬盘上的非连续文件可能会产生碎片，碎片会延长硬盘寻道时间并影响系统性能。例如，如果虚拟内存占用磁盘，则硬盘驱动器上将存在磁盘碎片。
产生原因 在文件操作过程中，Windows系统可能会调用虚拟内存来同步管理程序。这将使许多程序在硬盘上频繁读写。另一种情况是，在删除中间的集群（由扇区组成）的内容之后，将较小的新文件写入磁盘。这两个文件的两侧都会有一些空间。此时，写入另一个文件，但这两个空间的任何部分都无法保存此文件。该文件将分为两部分。碎片再次产生。
下载像电影这样的大文件是最常见的。在下载过程中，人们通常会处理其他事情。下载的电影文件被强制分成几个片段并存储在硬盘上。因此，下载是碎片化的重要原因。更重要的是，频繁删除和添加文件也是碎片化的原因。如果保存这些文件的空间不够大，将生成大量磁盘碎片。随着频繁删除文件，这种情况将变得越来越严重。
虽然磁盘碎片不会影响正常工作，但它会显着降低硬盘的运行速度。这主要是因为硬盘在读取文件时需要在多个部分之间跳转。等待盘旋转到指定扇区并寻找头切换轨道时间的延迟增加。
计算机使用很长时间后，磁盘会保存很多文件。这些文件不会保存在连续的磁盘空间中，而是单独保存在某些位置。这些碎片文件称为“磁盘碎片”。这些部分将降低Windows的整体性能。每次读取和写入文件时，磁盘联系都需要来回移动。这是浪费时间。因此，Windows提供了一个碎片整理程序。
运营原则 在了解磁盘碎片的原因后，我们还需要在程序运行时知道磁盘读写操作。通常，当我们运行一个程序时，磁盘驱动程序的头部将执行以下工作：搜索运行此程序所需的文件，读取数据，执行读取处理以及将数据传输到磁盘缓存和内存。搜索时间称为硬盘性能指标的平均搜索时间。它以毫秒（ms）为单位指定。磁盘的平均查找时间小于9.5毫秒。如果应用程序的相关文档可以放在连续的磁盘空间中，则磁头的搜索时间会减少很多。阅读也一样。磁盘读取磁头下方扇区所需的时间仅为将磁头移动到另一个位置然后读取相同数据所需时间的1/5。读取磁盘时，系统将检查数据是否在缓存中。如果是，他们将被直接阅读;如果没有，将访问磁盘。这称为读取磁盘。当需要多次读取相同的数据时，缓存起着很大的作用。但是如果第一次读取文件，缓存就无法做任何事情。搜索时间和读取时间很大程度上影响程序执行的效率。
我们为什么要对磁盘进行碎片整理？我们进行磁盘碎片整理，因为Windows系统不能按照减少磁头搜索时间的原则将每个文件放在磁盘的适当位置。因此，Microsoft将“磁盘碎片整理”添加到Windows，并提供“任务监视器”来跟踪程序启动期间的磁盘活动。跟踪磁盘活动使“磁盘碎片整理”有效工作。
任务监视器仅在程序加载过程中搜索文件信息。它将根据程序的加载频率调整和优化顺序。这意味着最常使用的软件将得到最佳优化。但是，如果用户更改常用软件，例如将WinZip更改为ZipMagic，那么很长一段时间，磁盘碎片整理仍会将与WinZip相关的文件而不是ZipMagic移动到连续空间。除非ZipMagic的加载时间超过WinZip的加载时间。要解决此问题，用户可以删除“Winzip32.lgx”。如果日志文件不存在，则磁盘碎片整理不会对其进行优化。
外部碎片和内部碎片 很多人会对文件碎片和集群的概念感到困惑。实际上，对于Windows系统，硬盘上的每个分区都由最小的存储单元 - 集群组成。这就像是通过转动一个街区组成一面墙。格式化分区时，用户可以定义群集的大小。它通常是几KB的大小，例如8 KB。例如，我有一个文件，其大小为800 MB点1 KB（1 MB = 1000 KB）。 800 MB等于80,001 KB。其中80,000 KB占用10,000个集群。其余的1 KB也必须占用1个集群。但是，没有使用7 KB的空间。并且其他文件不能占用未充分使用的此群集。这会造成一点浪费的空间。许多人称浪费7 KB空间作为磁盘上的内部碎片。但是，用户可以更改群集大小以充分利用磁盘空间。
外部碎片（通常称为磁盘碎片。磁盘碎片整理工具只能清除硬盘上的外部碎片。除非你更改硬盘上的分配单元，即文件系统的簇大小使其成为文件大小的整数倍）表示一个文件占用的非连续簇。这相当于文件被分割并分别保存在不连续的簇段上。根据文件分成的部分数量将有几个部分。因此，碎片实际上是指文件碎片。这可以理解为文件已被分解成碎片。有时，文件片段之间的序列是无序的。例如，有时在硬盘上由“后向文件片段”占用的簇段可能位于“前文件片段”簇段的前排。结果，文件将以混乱的顺序存储在硬盘上。
破坏硬盘 必要性
实际上，毫无疑问我们需要定期对硬盘进行碎片整理。如果硬盘碎片整理真的会损坏硬盘驱动器，经过多次碎片整理后会损坏它。如果硬盘已经使用了很长时间，文件的存储位置将变得碎片化——文件内容将分散在硬盘上的不同位置。这些碎片文件的存在将降低磁盘的工作效率，并增加数据丢失和数据损坏的可能性。碎片整理程序收集这些碎片并将它们作为一个整体保存在磁盘上。
整理周期
个人用户每三个月一次。
企业用户和政府用户每月一次。
执行磁盘碎片整理时，必须关闭屏幕保护程序，不得在计算机上执行其他操作，例如听音乐和玩游戏。您应该让计算机仅运行磁盘碎片整理程序以防止丢失数据。同时，不建议频繁对硬盘进行碎片整理，因为在这种情况下，硬盘不会停止读写。这会影响硬盘的使用寿命。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7455f571767054a366b66c77758f6c4f/" rel="bookmark">
			Java编程语言实现1!&#43;2!&#43;3!&#43;4!&#43;5!&#43;6!&#43;7!&#43;8!&#43;9!&#43;10!的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public class FactorialTest { public static void main(String[] args) { //键盘输入10即可，当然也可以输入其他数值 Scanner sc = new Scanner(System.in); int num = sc.nextInt(); BigDecimal result =new BigDecimal(0); BigDecimal sum = new BigDecimal(0) ; for(int i=1;i&lt;=num;i++){ result = factorial(i);//返回每个阶乘的值 sum = sum.add(result);//将返回的值进行相加 } System.out.println(sum); } //每个数的阶乘求值方法 public static BigDecimal factorial(int n){ BigDecimal result = new BigDecimal(1); BigDecimal a; for(int i = 2; i &lt;= n; i++){ a = new BigDecimal(i);//将i转换为BigDecimal类型 result = result.multiply(a);//不用result*a，因为BigDecimal类型没有定义*操作 } return result; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89ecf7ce76a5c942215385fde393257/" rel="bookmark">
			传球游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。
游戏规则是这样的：nn个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。
聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了mm次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学11号、22号、33号，并假设小蛮为11号，球传了33次回到小蛮手里的方式有11-&gt;22-&gt;33-&gt;11和11-&gt;33-&gt;22-&gt;11，共22种。
输入输出格式 输入格式： 一行，有两个用空格隔开的整数n,m(3≤n≤30,1≤m≤30)。
输出格式： 11个整数，表示符合题意的方法数。
输入输出样例 输入样例： 3 3
输出样例： 2
说明 40%的数据满足：3≤n≤30,1≤m≤20
100%的数据满足：3≤n≤30,1≤m≤30
2008普及组第三题
解析 定义dp[i][j]表示花j轮时间到i的方法数，状态转移方程：dp[i][j]=dp[i-1][j-1]+dp[i+1][j-1];
（即左右的人花一轮到达他，所以方法数为左右的人的上一轮方法数的和）
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; long long dp[35][35]; memset(dp,0,sizeof(dp)); dp[2][1]=1; dp[n][1]=1; for(int i=2;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { if(j==1) dp[j][i]=dp[n][i-1]+dp[j+1][i-1]; else if(j==n) dp[j][i]=dp[j-1][i-1]+dp[1][i-1]; else dp[j][i]=dp[j-1][i-1]+dp[j+1][i-1]; } } cout&lt;&lt;dp[1][m]; return 0; } 题目链接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f7085ae19628445c9b33ec21f25dba/" rel="bookmark">
			【Oracle RAC】JDBC连接oracle RAC数据库配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 生产上线系统，未能及时识别到Oracle数据库是RAC环境，上线时，Druid数据源配置按照单实例数据库配置，导致系统无法建立数据库连接，系统无法启动。
补充说明：数据连接池使用的是Alibaba的Druid。
临时解决方案 将原有数据库整库导出，在备机上创建单实例数据库，将生产库导入备机，之后启动系统，正常运行。 一个原则：保证业务能够正常实施！
最终解决方案 按照真实环境部署一套Rac测试环境，修改jdbc.url进行测试！
普通配置：
jdbc.url=jdbc\:oracle\:thin\:@127.0.0.1\:1521\:svr_name RAC下的url配置：
jdbc.url=jdbc\:oracle\:thin\:@(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = host_ip1)(PORT = 1521)) (ADDRESS = (PROTOCOL = TCP)(HOST = host_ip2)(PORT = 1521)) (LOAD_BALANCE = yes)(failover=on)(connect_data= (service_name = oratest))) 其中：
host_ip1、host_ip2为你的rac数据库的两个甚至多个节点的ip地址（据说配置到/etc/hosts下也可以为服务id）
service_name 为你的数据库实例名
RAC特性 RAC 同时具备HA(High Availiablity) 和LB(LoadBalance)，而其高可用性的基础就是Failover(故障转移).。它指集群中任何一个节点的故障都不会影响用户的使用，连接到故障节点的用户会被自动转移到健康节点，从用户感受而言， 是感觉不到这种切换。
Oracle 10g RAC 的Failover 可以分为3种：
Client-Side Connect time FailoverTAFService-Side TAF Client-Side Connect time Failover 第一种Client-Side Connect time Failover的特点：只在建立连接那一时刻起作用。也就是说，这种Failover方式只在发起连接时才会去感知节点故障，如果节点没有反应，则自动尝试地址列表中的下一个地址。一旦连接建立之后，节点出现故障都不会做处理，从客户端的表现就是会话断开了，用户程序必须重新建立连接。启用这种Failover的方法就是在客户端的tnsnames.ora中添加FAILOVER=ON 条目，这个参数默认就是ON，所以即使不添加这个条目，客户端也会获得这种Failover能力。
TAF 第二种TAF的特点：建立连接以后，应用系统运行过程中，如果某个实例发生故障，连接到这个实例上的用户会被自动迁移到其他的健康实例上。对于应用程序而言，这个迁移过程是透明的，不需要用户的介入，当然，这种透明要是有引导的，因为用户的未提交事务会回滚。 相对于Client-Side Connect Time Failover的用户程序中断，抛出连接错误，用户必须重启应用程序，TAF 这种方式在提高HA上有了很大的进步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62f7085ae19628445c9b33ec21f25dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9db19cd73314ae61fecbe3a24f439b/" rel="bookmark">
			spring中过滤器（filter）、拦截器（interceptor）和切面（aop）的执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.程序执行的顺序是先进过滤器，再进拦截器，最后进切面。注意：如果拦截器中preHandle方法返回的为false时，则无法进入切面，例子如下 @RestController @RequestMapping("/user") public class UserController { @GetMapping("/{id:\\d+}") @JsonView(User.UserDetailView.class) public User getInfo(@PathVariable String id) { User user = new User(); user.setUsername("tom"); return user; } } 编写方法的过滤器：
@Component public class TimeFilter implements Filter { /* (non-Javadoc) * @see javax.servlet.Filter#init(javax.servlet.FilterConfig) */ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println("time filter init"); } /* (non-Javadoc) * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain) */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a9db19cd73314ae61fecbe3a24f439b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b1c128b0630a1708fdb46619fa6750/" rel="bookmark">
			《数据结构》01-复杂度1	最大子列和问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定K个整数组成的序列{ N 1 _1 1​, N 2 _2 2​, …, N k _k k​}，“连续子列”被定义为{ N ​ i _{​i} ​i​​​ , N ​ i + 1 _{​i+1} ​i+1​​ , …, N j _j j​​​ }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。
本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：
数据1：与样例等价，测试基本正确性；数据2：10 2 ^2 2个随机整数；数据3：10 3 ^3 3个随机整数；数据4：10 4 ^4 4个随机整数；数据5：10 5 ^5 5个随机整数； 输入格式:
输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。
输出格式:
在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。
输入样例:
6
-2 11 -4 13 -5 -2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b1c128b0630a1708fdb46619fa6750/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5182feb5df486dec54361d43ab49bb7d/" rel="bookmark">
			巨人网络 Unity面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一面
面试官是做C++的很无奈
1.STL了解吗？vector底层？
2.C++如何做内存管理？
3.二叉排序树找出前5个最小的数
4.Dijkstra算法和A*算法
5.C# GC和 Lua GC机制
6.做过哪些Shader，如何实现广告牌效果？
7.红黑树特点、应用、为什么快？
8.B+树特点
9.有没有Linux下C++编程经验
10.PBS光照模型
二面
二面的面试官是人工智能事业部的，面试官比较注重学习能力
1.简单介绍一下你自己
2.Socket用的TCP还是UDP？TCP和UDP有什么区别遇到过什么问题？
3.如何做性能优化？具体从各个方面说？
4.模型面数多会出现什么问题？CPU压力更大还是GPU？
5.shader如何实现透明效果？
6.透明度混合会出现什么问题？
7.透明度混合渲染顺序？如何解决错误排序？
8.顶点动画和纹理动画？
9.如何实现描边效果？（边缘检测我用的是卷积算法）
10.透明度混合如何做性能优化
10.高斯滤波？高斯模糊？
11.对深度学习有没有了解过？
12.图像识别你学过哪些？
13.有没有兴趣做人工智能？
HR
感觉HR面的超级快，当时晚上有百度笔试赶着回去做题所以面的一般
1.自我介绍
2.为什么选择游戏？
3.为什么选择巨人？
4.对游戏制作感兴趣，为什么要选择研发不去做一个制作人
5.还有没有什么想问的？
面完之后好像还是来不及做笔试了，然后晚上又去找了二面的面试官聊天，感觉人特别好。
二面面试官说比较看重我的学习能力所以问我愿不愿意去做人工智能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7879baebef018c114c0531afbb91dc1c/" rel="bookmark">
			基于朴素贝叶斯手写数字的识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贝叶斯分类器也广泛应用于分类的实现。特别是文本的识别。本次主要介绍用朴素贝叶斯，在独立检验的条件下实现手写数字的识别。
基本原理：
计算当前图片类别占总类别的概率，从中找到占比最大的，就认定该图片从属于这个类。
代码：
构造分类器，并存储文件为bayes.py。
# -*- coding: utf-8 -*- """ Created on Mon Oct 8 15:27:37 2018 @author: Administrator """ from numpy import * class Bayes(): def __init__(self): self.length = -1 self.label = dict() self.vector = dict() def fit(self, train_data:list, labels:list): if (len(train_data) != len(labels)): raise ValueError('测试数组与类别数组长度不一致') self.length = len(train_data[0]) #测试数据特征值长度 labels_num = len(labels) #所有数据量 classes = set(labels) #不重复的标签 for item in classes: #当前类别占总类别比例 this_labels = item self.label[this_labels] = labels.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7879baebef018c114c0531afbb91dc1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a68f8abe3692794036ef00f1032fedc/" rel="bookmark">
			zsh: command not found: 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路：把 bash shell 中.bash_profile 全部环境变量加入zsh shell中
第一步：open .zshrc 第二步：添加 source ~/.bash_profile 第三步执行：source .zshrc 复制代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48998656ab55e74d8e28f9428e89c527/" rel="bookmark">
			谈谈源码泄露 · WEB 安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、漏洞成因 在 WEB 安全体系当中，可能你对 SQL 注入，XSS 跨站一些漏洞已经耳熟于心了，而源码泄露问题对于大部分开发者来说就相对陌生了 , 而源码泄露导致的问题却并不少见，在过往的泄露案例当中，不仅是小网站有此问题，在一些大的厂商同样出现不少，并因此拿到 webshell。
比如在一些小型企业，可能公司并没有专门的服务器，而是把网站部署在某一个虚拟主机上面，代码文件比较多的时候 FTP 上传是比较慢的，于是开发者把代码先打包压缩后再上传，上传成功后再去服务器解压，这有虽然解决了上传速度慢的问题，不过却留下了一些安全隐患。
压缩包解压后如果没有删除，当攻击者发现后就可以把代码压缩包下载；因为部署到服务器上的都是源代码，这个时候攻击者就可以通过代码进一步挖掘一些安全漏洞：文件上传，SQL 注射等。
二、GIT 源码泄露 1. 漏洞成因 当在一个空目录执行 git init 时，Git 会创建一个 .git 目录。 这个目录包含所有的 Git 存储和操作的对象。 如果想备份或复制一个版本库，只需把这个目录拷贝至另一处就可以了。
该目录的结构如下所示：
HEAD config* description hooks/ info/ objects/ refs/
在这些结构中 description 文件仅供 GitWeb 程序使用，我们可以无需关心。
config 文件包含项目特有的配置选项；
info 目录包含一个全局性排除（global exclude）文件，用以放置不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）；
hooks 目录包含客户端或服务端的钩子脚本（hook scripts）。
而在剩下的四个条目很重要：
HEAD 文件指示目前被检出的分支；
index 文件保存暂存区信息；
objects 目录存储所有数据内容；
refs 目录存储指向数据（分支）的提交对象的指针。
而在发布代码的时候，如果没有把 .git 这个目录删除，直接发布到了运行目录中。攻击者就可以通过这个文件夹，可以用来恢复源代码。
http://www.localhost.test/.git/config
通常会用到的利用工具 GitHack ，这个工具下载下来之后操作也特别简单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48998656ab55e74d8e28f9428e89c527/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc9429752e88c585aa834f2d61d87d6b/" rel="bookmark">
			Web测试与App测试的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天一个测试妹纸问我，web测试与app测试到底有啥区别呢，这个问题尤其是很多初入行的测试经常会问的。
其实，不管是什么类型的测试，测试方法都是类似的，这里说到的web与app之间的测试区别，主要在于应用场景的差异性。如果单单看功能测试，那么web测试与app测试我觉得是一样的，因为方法和策略都是一样的。那么他们之间的主要区别到底在哪里呢，下面将它们列出来：
app测试中IOS和Android测试的区别：
1、Android长按home键呼出应用列表和切换应用，然后右滑则终止应用；
2、多分辨率测试，Android端20多种，ios较少；
3、机操作系统，Android较多，ios较少且不能降级，只能单向升级；新的ios系统中的资源库不能完全兼容低版本中的ios系统中的应用，低版本ios系统中的应用调用了新的资源库，会直接导致闪退（Crash）；
4、操作习惯：Android，Back键是否被重写，测试点击Back键后的反馈是否正确；应用数据从内存移动到SD卡后能否正常运行等；
5、push测试：Android：点击home键，程序后台运行时，此时接收到push，点击后唤醒应用，此时是否可以正确跳转；ios，点击home键关闭程序和屏幕锁屏的情况；
6、安装卸载测试：Android的下载和安装的平台和工具和渠道比较多，ios主要有app store，iTunes和testflight下载；
7、升级测试：可以被升级的必要条件：新旧版本具有相同的签名；新旧版本具有相同的包名；有一个标示符区分新旧版本（如版本号），对于Android若有内置的应用需检查升级之后内置文件是否匹配（如内置的应用市场）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933029ed1b181dd362054a36924fb3b9/" rel="bookmark">
			一波三折：一次CPU使用率过高故障分析SQL优化解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注我们获得更多内容
作者 | 罗贵林： 云和恩墨技术工程师，具有8年以上的 Oracle 数据库工作经验，曾任职于大型的国家电信、省级财政、省级公安的维护，性能调优等。精通 Oracle 数据库管理，调优，问题诊断。擅长 SQL 调优，Oracle Rac 等维护，管理。
1.问题描述
2018年9月13日一大早接到客户电话说核心数据库RAC两主机CPU使用很高，90%以上，系统操作缓慢，需要马上紧急处理。
2.把问题想清楚
CPU使用高一般有几种原因？可以从哪些方面入手分析？客户系统情况，故障是高峰期累积的还是突发的？
一般CPU占用高是由排序、SQL解析、执行计划突变、全表扫描、会话阻塞等，可能的原因较多，需要抽丝剥茧，逐步定位根因；
分析方法主要由主机top/topas占CPU高的进程查询相应SQL、会话增长趋势、阻塞分析、ASH/AWR报告分析、SQL执行时间/执行计划变化等；
需要询问客户业务场景，业务上有没有变更，例如开发功能变更、业务使用量增加等，是当前突发的，还是持续了一段时间的问题。
经询问，本次故障是三天前突发的，问题已持续了三天时间。
3.分析：问题逐步排查
3.1. 主机topas信息
本次通过AIX主机topas信息看到进程使用CPU都很平均，无法直接定位是某个进程某个SQL引起的CPU使用过高的问题，如果可以直接明显看出资源过高损耗，定位可用以下方法：
--找到占用系统资源特别大的Oracle的Session及执行的SQL语句(根据进程号查找)
select a.username,a.machine,a.program,a.sid,a.serial#,a.status,c.piece,c.sql_text from v$session a, v$process b,v$sqltext c
where b.spid=&amp;pid and b.addr=a.paddr and a.sql_address=c.address(+) order by c.piece;
--根据sid查找session的执行语句
select sid,sql_text from v$session s,v$sql q
where sid = &amp;sid and (q.sql_id=s.sql_id or q.sql_id = s.prev_sql_id);
3.2. 会话的增长趋势 通过查询V$SYSMETRIC_HISTORY视图（记录了上一小时里每1分钟的指标信息，上3分钟里每15s的指标信息），可以得出每分钟内会话数的增长趋势：
select begin_time,trunc(value) from V$SYSMETRIC_HISTORY where metric_name='Average Active Sessions' and group_id=2 order by begin_time;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/933029ed1b181dd362054a36924fb3b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9100203a9e18d771ee1de7e736e4b071/" rel="bookmark">
			Logstash 参考指南（File输出插件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File输出插件 插件版本：v4.2.5发布于：2018-06-28更新日志 其他版本，请参阅版本化的插件文档。
获取帮助 有关插件的问题，请在讨论论坛中打开一个主题，对于bug或特性请求，在Github中打开一个issue，关于Elastic支持的插件列表，请考虑Elastic支持矩阵。
描述 该输出将事件写入磁盘上的文件，你可以使用事件中的字段作为文件名和/或路径的一部分。
默认情况下，该输出以json格式为每行写入一个事件，你可以使用类似的line编解码器定制行格式：
output { file { path =&gt; ... codec =&gt; line { format =&gt; "custom format: %{message}"} } } File输出配置选项 这个插件支持以下配置选项以及后面描述的通用选项。
设置输入类型要求create_if_deletedbooleanNodir_modenumberNofile_modenumberNofilename_failurestringNoflush_intervalnumberNogzipbooleanNopathstringYeswrite_behaviorstringNo 还可以查看所有输出插件支持的通用选项列表。
create_if_deleted
值类型为boolean默认值为true 如果已配置的文件被删除，但是插件处理了一个事件，插件将重新创建该文件，Default ⇒ true。 dir_mode
值类型为number默认值为-1 要使用的目录访问模式，注意，由于jruby系统中的bug，linux上忽略了umask：https://github.com/jruby/jruby/issues/3426，将其设置为-1使用默认OS值，示例：“dir_mode”=&gt; 0750。 file_mode
值类型为number默认值为-1 要使用的文件访问模式，注意，由于jruby系统中的bug，linux上忽略了umask：https://github.com/jruby/jruby/issues/3426，将其设置为-1使用默认OS值，示例："file_mode" =&gt; 0640。 filename_failure
值类型为string默认值为"_filepath_failures" 如果生成的路径无效，事件将被保存到这个文件中并且在定义的路径中。 flush_interval
值类型为number默认值为2 刷新写入日志文件的刷新间隔（以秒为单位），0将刷新每个消息。 gzip
值类型为boolean默认值为false 在写入磁盘之前，Gzip输出流。 path
这是必需的设置值类型为string此设置没有默认值要写入的文件的路径，这里可以使用事件字段，像/var/log/logstash/%{host}/%{application}，还可以使用path选项通过joda时间格式进行基于日期的日志循环，这将使用事件时间戳，如：path =&gt; "./test-%{+YYYY-MM-dd}.txt"来创建./test-2013-05-29.txt。如果使用绝对路径，则不能从动态字符串开始，如：/%{myfield}/、/test-%{myfield}/不是有效路径。 write_behavior
值类型为string默认值为append 如果append，文件将被打开以追加并且每个新事件将被写入文件的末尾，如果overwrite，文件将在写入之前被截断，并且只有最近的事件才会出现在文件中。 通用选项 所有输出插件都支持以下配置选项：
设置输入类型要求codeccodecNoenable_metricbooleanNoidstringNo codec
值类型为codec默认值为"json_lines" 用于输出数据的编解码器，输出编解码器是一种方便的方法，可以在数据离开输出之前对其进行编码，而不需要在你的Logstash管道中使用单独的过滤器。 enable_metric
值类型为boolean默认值为true 为这个特定的插件实例禁用或启用指标日志记录，默认情况下，我们记录了所有我们可以记录的指标，但是你可以禁用特定插件的指标集合。 id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9100203a9e18d771ee1de7e736e4b071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a25e0deaa6fb6b4fc0a68f1882f4f1c2/" rel="bookmark">
			pickle.dump和pickle.load
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。
基本接口：
pickle.dump(obj, file, [,protocol]) 注解：将对象obj保存到文件file中去。
protocol为序列化使用的协议版本，0：ASCII协议，所序列化的对象使用可打印的ASCII码表示；
1：老式的二进制协议；2：2.3版本引入的新二进制协议，较以前的更高效。其中协议0和1兼容老版本的python。protocol默认值为0。
file：对象保存到的类文件对象。file必须有write()接口， file可以是一个以’w’方式打开的文件或者一个StringIO对象或者其他任何实现write()接口的对象。如果protocol&gt;=1，文件对象需要是二进制模式打开的。
pickle.load(file) 注解：从file中读取一个字符串，并将它重构为原来的python对象。
file:类文件对象，有read()和readline()接口。
举例说明
#使用pickle模块将数据对象保存到文件 import pickle data1 = {'a': [1, 2.0, 3, 4+6j], 'b': ('string', u'Unicode string'), 'c': None} selfref_list = [1, 2, 3] selfref_list.append(selfref_list) output = open('data.pkl', 'wb') # Pickle dictionary using protocol 0. pickle.dump(data1, output) # Pickle the list using the highest protocol available. pickle.dump(selfref_list, output, -1) output.close() #使用pickle模块从文件中重构python对象 import pprint, pickle pkl_file = open('data.pkl', 'rb') data1 = pickle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a25e0deaa6fb6b4fc0a68f1882f4f1c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/214b163fce305e78c01ded535b949e78/" rel="bookmark">
			HTTP协议状态码详解（HTTP Status Code）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用php或者javascript都会用到http的不同状态，一些常见的状态码为： 200 – 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务不可用 所有状态解释：
1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明 100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功） 表示成功处理了请求的状态代码。 代码 说明 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 代码 说明 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2363cd72db844fe68232b17ac95dd508/" rel="bookmark">
			Python读取、写入txt文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件的打开的两种方式
f = open("data.txt","r") #设置文件对象 f.close() #关闭文件 #为了方便，避免忘记close掉这个文件对象，可以用下面这种方式替代 with open('data.txt',"r") as f: #设置文件对象 str = f.read() #可以是随便对文件的操作 一、读文件
1.简单的将文件读取到字符串中
f = open("data.txt","r") #设置文件对象 str = f.read() #将txt文件的所有内容读入到字符串str中 f.close() #将文件关闭 2.按行读取整个文件
#第一种方法 f = open("data.txt","r") #设置文件对象 line = f.readline() line = line[:-1] while line: #直到读取完文件 line = f.readline() #读取一行文件，包括换行符 line = line[:-1] #去掉换行符，也可以不去 f.close() #关闭文件 #第二种方法 data = [] for line in open("data.txt","r"): #设置文件对象并读取每一行文件 data.append(line) #将每一行文件加入到list中 #第三种方法 f = open("data.txt","r") #设置文件对象 data = f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2363cd72db844fe68232b17ac95dd508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d41484c80a0e9db166ca7be464be25b/" rel="bookmark">
			java 原码反码及补码 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考： http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html http://blog.csdn.net/liushuijinger/article/details/7429197#comments 数值在计算机中是以补码的方式存储的，在探求为何计算机要使用补码之前， 让我们先了解原码， 反码和补码的概念。
对于一个数， 计算机要使用一定的编码方式进行存储。 原码， 反码， 补码是计算机存储一个具体数字的编码方式。
一个数在计算机中的二进制表示形式， 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号， 正数为0， 负数为1。比如，十进制中的数 +2 ，计算机字长为8位，转换成二进制就是[00000010]。如果是 -2 ，就是 [10000010] 。因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 [10000010]，其最高位1代表负，其真正数值是 -2 而不是形式值130（[10000010]转换成十进制等于130）。所以将带符号位的机器数对应的真正数值称为机器数的真值。
原码就是符号位加上真值的绝对值， 即用第一位表示符号， 其余位表示值。反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上， 符号位不变，其余各个位取反。补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上， 符号位不变， 其余各位取反， 最后+1。 (即在反码的基础上+1) 首先，根据运算法则减去一个正数等于加上一个负数， 即: 1-1 = 1+(-1)， 所以计算机被设计成只有加法而没有减法， 而让计算机辨别”符号位”会让计算机的基础电路设计变得十分复杂，于是就让符号位也参与运算，从而产生了反码。 用反码计算， 出现了”0”这个特殊的数值， 0带符号是没有任何意义的。 而且会有[0000 0000]和[1000 0000]两个编码表示0。于是设计了补码， 负数的补码就是反码+1，正数的补码就是正数本身，从而解决了0的符号以及两个编码的问题: 用[0000 0000]表示0，用[1000 0000]表示-128。 注意-128实际上是使用以前的-0的补码来表示的， 所以-128并没有原码和反码。使用补码， 不仅仅修复了0的符号以及存在两个编码的问题， 而且还能够多表示一个最低数。 这就是为什么8位二进制， 使用补码表示的范围为[-128， 127]。
转载于:https://www.cnblogs.com/zhang188660586/p/9752394.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6af2cd4c8f2f6b2b99b97ec59fc47d/" rel="bookmark">
			使用conda安装glog库后无法导入的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【时间】2018.10.07
【题目】使用conda安装glog库后无法导入的解决办法。
【问题描述】：使用conda安装glog库后，导入glog库仍然提示没有该模块，在python库的安装目录Anaconda3\Lib\site-packages下也没有找到该库，但是通过conda list查询发现有该库
使用conda list查询：
在Anaconda目录下查找glog,结果如下：
【解决方法】
之后通过使用pip安装解决了问题，指令为 pip install glog，这时可以正常导入glog了，并且在Anaconda3\Lib\site-packages下可以找到该库，库名为glog-0.3.1.dist-info。
【问题分析】可能是glog库的版本问题。使用pip安装的库的版本是0.3.1，而conda安装的库版本为0.3.5。
【基本测试】
代码：
import glog as log
log.info('HelloWord!')
运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0637bef2c5cf78f6b1ace7af468bcf52/" rel="bookmark">
			nvidia-msi命令解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nvidia-msi 或者
watch -n 1 nvidia-smi 打印出表格中：
第一栏的Fan：N/A是风扇转速，从0到100%之间变动，这个速度是计算机期望的风扇转速，实际情况下如果风扇堵转，可能打不到显示的转速。有的设备不会返回转速，因为它不依赖风扇冷却而是通过其他外设保持低温（比如我们实验室的服务器是常年放在空调房间里的）。
第二栏的Temp：是温度，单位摄氏度。
第三栏的Perf：是性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能。
第四栏下方的Pwr：是能耗，上方的Persistence-M：是持续模式的状态，持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态。
第五栏的Bus-Id是涉及GPU总线的东西，domain?device.function
第六栏的Disp.A是Display Active，表示GPU的显示是否初始化。
第五第六栏下方的Memory Usage是显存使用率。
第七栏是浮动的GPU利用率。
第八栏上方是关于ECC的东西。
第八栏下方Compute M是计算模式。
下面一张表示每个进程占用的显存使用率。
转载于:https://www.cnblogs.com/vercont/p/10210216.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4042721253d8df2aa73dca2400405658/" rel="bookmark">
			C语言利用栈的操作实现判断字符串中的括号是否匹配（只考虑半角括号：( ) { } [ ]）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言利用栈的操作实现判断字符串中的括号是否匹配（只考虑半角括号：( ) { } [ ]） 题目均在sdibt acm oj上AC，参考《深入浅出数据结构和算法》教材，逐个复制即可运行，欢迎评论指正！ Description 输入一串字符串，编写算法判断字符串中的括号是否匹配，如果匹配，输出1，否则输出0。
注： 只考虑半角括号：( ) { } [ ]，不考虑全角括号：（ ） 【 】
例如：{ab123[(3*6-(4+3)) {223}[999]hhh}
字符串中的括号匹配。
{323[ab]()(123}
字符串中的括号不匹配。
提示：利用栈实现。
Input 输入可以包含各种括号、数字、字母等符号的字符串。
Output 括号匹配输出1，否则输出0。
Sample Input sample 1: {ab123[(3*6-(4+3)){223}[999]hhh} sample 2: {323 Description 输入一串字符串，编写算法判断字符串中的括号是否匹配，如果匹配，输出1，否则输出0。
注： 只考虑半角括号：( ) { } [ ]，不考虑全角括号：（ ） 【 】
例如：{ab123[(3*6-(4+3)) {223}[999]hhh}
字符串中的括号匹配。
{323[ab]()(123}
字符串中的括号不匹配。
提示：利用栈实现。
Input 输入可以包含各种括号、数字、字母等符号的字符串。
Output 括号匹配输出1，否则输出0。
Sample Input sample 1: {ab123[(3*6-(4+3)){223}[999]hhh} sample 2: {323[ab]()123} Sample Output sample1: 0 sample2: 1 ab]()123} Sample Output sample1: 0 sample2: 1 设计栈（顺序栈）和相关头文件以及宏定义如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4042721253d8df2aa73dca2400405658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68069db66a997c0b2efa481edc7b0fc1/" rel="bookmark">
			（算法）通俗易懂的字符串匹配KMP算法及求next值算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大多数据结构课本中，串涉及的内容即串的模式匹配，需要掌握的是朴素算法、KMP算法及next值的求法。在考研备考中，参考严奶奶的教材，我也是在关于求next值的算法中卡了一下午时间，感觉挺有意思的，把一些思考的结果整理出来，与大家一起探讨。
本文的逻辑顺序为
1、最基本的朴素算法
2、优化的KMP算法
3、应算法需要定义的next值
4、手动写出较短串的next值的方法
5、最难理解的、足足有5行的代码的求next值的算法
所有铺垫为了最后的第5点，我觉得以这个逻辑下来，由果索因还是相对好理解的，下面写的很通俗，略显不专业…
一、问题描述 给定一个主串S及一个模式串P，判断模式串是否为主串的子串；若是，返回匹配的第一个元素的位置（序号从1开始），否则返回0；如S=“abcd”，P=“bcd”，则返回2；S=“abcd”，P=“acb”，返回0。
二、朴素算法 最简单的方法及一次遍历S与P。以S=“abcabaaaabaaacac”,P="abaabcac"为例，一张动图模拟朴素算法：
这个算法简单，不多说，附上代码
#include&lt;stdio.h&gt; int Index_1(char s[],int sLen,char p[],int pLen){//s为主串，sLen为主串元素个数，p为模式串，pLen为模式串的个数 if(sLen&lt;pLen)return 0; int i = 1,j = 1; while(i&lt;=sLen &amp;&amp; j&lt;=pLen){ if(s[i]==p[j]){i++;j++;} else{ i = i-j+2; j = 1; } } if(j&gt;pLen) return i-pLen; return 0; } void main(){ char s[]={' ','a','b','c','a','b','a','a','a','a','b','a','a','b','c','a','c'};//从序号1开始存 char p[]={' ','a','b','a','a','b','c','a','c'}; int sLen = sizeof(s)/sizeof(char)-1; int pLen = sizeof(p)/sizeof(char)-1; printf("%d",Index_1(s,sLen,p,pLen)); } 三、改进的算法——KMP算法 朴素算法理解简单，但两个串都有依次遍历，时间复杂度为O(n*m)，效率不高。由此有了KMP算法。
一般的，在一次匹配中，我们是不知道主串的内容的，而模式串是我们自己定义的。
朴素算法中，P的第j位失配，默认的把P串后移一位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68069db66a997c0b2efa481edc7b0fc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daeefd0f53edb1c3effaec5c605613f4/" rel="bookmark">
			Dubbo的详细介绍、设计思路、以及4大适用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; Dubbo
Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。
简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）。
其核心部分包含:
远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。
集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。
Dubbo的架构设计
Dubbo框架具有极高的扩展性，主要采用微核+插件体系，并且文档齐全，很方便二次开发，适应性极强。
Dubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。
Dubbo框架设计一共划分了10个层：
服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。
配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。
服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。
服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。
集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。
监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。
远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。
信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。
网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。
数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。
Dubbo与HSF的区别
Dubbo比HSF的部署方式更轻量 HSF要求使用指定的JBoss等容器，还需要在JBoss等容器中加入sar包扩展，对用户运行环境的侵入性大，如果你要运行在Weblogic或Websphere等其它容器上，需要自行扩展容器以兼容HSF的ClassLoader加载，而Dubbo没有任何要求，可运行在任何Java环境中。
Dubbo比HSF的扩展性更好，很方便二次开发 一个框架不可能覆盖所有需求，Dubbo始终保持平等对待第三方理念，即所有功能，都可以在不修改Dubbo原生代码的情况下，在外围扩展，包括Dubbo自己内置的功能，也和第三方一样，是通过扩展的方式实现的，而HSF如果你要加功能或替换某部分实现是很困难的，比如支付宝和淘宝用的就是不同的HSF分支，因为加功能时改了核心代码，不得不拷一个分支单独发展，HSF现阶段就算开源出来，也很难复用，除非对架构重写。
HSF依赖比较多内部系统 比如配置中心，通知中心，监控中心，单点登录等等，如果要开源还需要做很多剥离工作，而Dubbo为每个系统的集成都留出了扩展点，并已梳理干清所有依赖，同时为开源社区提供了替代方案，用户可以直接使用。
Dubbo比HSF的功能更多 除了ClassLoader隔离，Dubbo基本上是HSF的超集，Dubbo也支持更多协议，更多注册中心的集成，以适应更多的网站架构。
Dubbo的使用场景
RPC分布式服务 当网站变大后，不可避免的需要拆分应用进行服务化，以提高开发效率，调优性能，节省关键竞争资源等。
比如：为了适用不断变化的市场需求，以及多个垂直应用之间数据交互方便，我们把公共的业务抽取出来作为独立的模块，为其他的应用提供服务，系统逐渐依赖于抽象和rpc远程服务调用。
配置管理 当服务越来越多时，服务的URL地址信息就会爆炸式增长，配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。
服务依赖 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。
服务扩容 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？等等……
在遇到这些问题时，都可以用Dubbo来解决。
转载于:https://my.oschina.net/u/3778090/blog/2222853
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721c59d149a867a680feddafe8140a68/" rel="bookmark">
			网站中的验证码，JAVA代码（javax.script.ScriptEngineManager)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个包不经常用，需要手动导入，具体代码如下：
public BufferedImage createCode(User user, long goodsId) { if(user==null||goodsId&lt;=0) { return null; } int width=80; int height=32; //创建一个图片 BufferedImage image=new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g=image.getGraphics(); //设置背景颜色 g.setColor(new Color(0xDCDCDC)); g.fillRect(0, 0, width, height); //画边框 g.setColor(Color.black); g.drawRect(0, 0, width-1, height-1); //创建一个随机序列填充点 Random rdm=new Random(); //做50个干扰点 for (int i = 0; i &lt; 50; i++) { int x=rdm.nextInt(width); int y=rdm.nextInt(height); g.drawOval(x, y, 0, 0); } //填充随机代码 String verifyCode=appendCode(rdm); g.setColor(new Color(0,100,0)); g.setFont(new Font("Candara",Font.BOLD,24)); g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/721c59d149a867a680feddafe8140a68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b318d4f1310067b877a3ad8fa01a0d/" rel="bookmark">
			操作系统-第二章-进程管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 程序的顺序执行
概述：一个程序由若干程序段组成，它们必须按照某种先后顺序执行，仅当前一个操作执行完毕之后才能执行后续操作，这就是程序的顺序执行过程
程序顺序执行时的特征
顺序性：每一个操作必须在下一个操作开始之前结束
封闭性：程序一旦开始运行，就不受外界干扰，因为程序运行时独占系统的各种资源，只有本程序才能改变
可再现性：只要程序的初始条件和执行环境相同，重复执行的结果是相同的
点击下载 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b220abc1f73881e120364bf7fcf0f6/" rel="bookmark">
			Parallel.for性能问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		parallel.for一定是用来处理计算限制的操作的，其中涉及到线程同步和委托调用等的性能损耗。所以，对于一个数组中的元素进行简单操作却使用parallel必然会导致性能下降。
如：
public static void MultiplicateArrayParallel(double[] array,double factor){
Parallel.For(0,array.Length,i=&gt;
{
array[i] = array[i]*factor;
});
}
public static void MultiplicateArraySingle(double[] array,double factor){
for(int i =0;i&lt;array.Length;i++)
{
array[i] = array[i]*factor;
}
}
PLINQ以及TPL中的自定义分区
为了并发处理数据集合中的元素，一个有效的措施是对数据集合并行分组，然后并发处理多个分组。PLINQ和TPL（Task Parallel Library）
在内部也会对数据源进行分组，将数据源均分成cpu数量的分数，进行并发处理，当某个线程提前处理完后，会协助别的线程进行处理，
知道所有数据都处理完成，这其中不可避免会涉及线程同步问题而造成性能问题，但是默认分组并非总是最优的，为了更优越的性能，
我们可以自己对数据源进行分组。
一般来讲最有效的数据分组方式是利用多线程协作顺序处理原集合，而不是把原集合分成几个子集合再单独处理。
对于已知长度的集合（如定长数组）最优的方法是范围分区
比如：一个数据有100
个元素，对于一个拥有四个处理器的机器来说，最好的办法是开辟四个线程，第一个线程处理0～24的元素，第二个线程处理25～49的元素，
第三个线程处理50～74的元素，第四个线程处理75～99的元素，而不是将100个元素的数据先分成4个25个元素的子数组，然后再单独处理
这四个字数据。
这样分组的一个不好的地方就是，如果一个线程提前完成了任务，它不会去帮助没完成任务的线程去完成任务。
对于变长集合，如（可变数组）最优的方法是块分区。
块分区中，每个线程或任务会处理一个块中的部分数据，处理完成后，再去获取新的待处理元素。
分区器会保证所有的元素都被处理，不会遗漏也不会重复。每个块的大小也不确定。
一般来讲，范围分区只有在委托执行时间不太长且集合元素很多，且每个分区的工作量差不多时才会加快集合的处理速度。
块分区在大多数情况下都会提升性能，对于元素数量不太多，或者委托执行时间很长的数据源，块分区和范围分区的性能事是差不多的。
TPL分区器也支持动态分区，可以在运行时产生新的分区。此特性允许分区器随着foreach循环的增减而增减。动态分区器内部是负载均衡的。
所以当你创建一个自定义的分区器时，要让动态分区器能被ForEach循环使用
为PLINQ配置负载均衡的分区器
Partitioner.Create 方法支持为一个array或IList数据源创建一个分区器并指定是否支持内部线程的负载均衡。当分区器被配置为
支持负载均衡时将会应用块分区，当请求发生时，元素会被以小块的形式传递给每个分区。此方法保证每个分区都有元素处理，知道所有
数据被处理完成之前。
另外一个重载形势能为所有的IEnumerable数据源提供负载均衡分区器。
通常，负载均衡需要分区不断的向分区器请求元素。相比之下，实现静态分区的分区器能一次性完成分区器的元素分配工作，这并不使用
范围分区和块分区。这比负载均衡需更节省开销，但是会因为线程间的工作量不同造成有的线程早就完成了工作但是有的却花费很长的时间完成工作
而花费更多的执行时间。默认情况下，当传递IList或array，PLINQ总是使用范围分区而不考虑负载均衡。为了使用负载均衡，可以使用
Partitioner.Create方法
// Static partitioning requires indexable source. Load balancing
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56b220abc1f73881e120364bf7fcf0f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268124615a3cd3645fe00356dd790db1/" rel="bookmark">
			MySQL 8.0 自带的4个系统数据库介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自带的4个系统数据库：information_schema、mysql、performance_schema、sys； information_schema：这个数据库保存了mysql服务器所有数据库的信息。比如数据库的名、数据库的表、访问权限、数据库表的数据类型，数据库索引的信息等等。performance_schema：主要用于收集数据库服务器性能参数，可用于监控服务器在一个较低级别的运行过程中的资源消耗、资源等待等情况。链接：performance_schema全方位介绍sys：库中所有的数据源来自：performance_schema。目标是把performance_schema的把复杂度降低，让DBA能更好的阅读这个库里的内容。让DBA更快的了解DB的运行情况。链接： MYSQL的SYS数据库mysql：mysql的核心数据库，类似于sql server中的master表，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7237922e56dd8ebe287917c97d82e1f/" rel="bookmark">
			Java：线程：CPU核心数目 与 多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.多线程的几个状态？以及何时处于这个状态？
开始（创建）：在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
就绪：当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
运行：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
阻塞： 线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。
结束：如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。
2.时间片的概念是什么？
时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。 ================================================================================
一直以来有这样的疑惑，在现如今多核多线程的电脑处理器之下，一个进程中的几个线程是 怎么运行的呢？（是经系统和JVM分配少量的资源 最后轮流切换 时间调度？还是这几个线程分配到不同的核上同时运行？）
今天就这一问题查了一些资料，现整理如下：
单个CPU一个时刻只能运行一个线程？ 单核CPU电脑同一时间内只能执行一个线程，首先了解一下，CPU执行的过程 ，它是把时间分成若干个小时间段，这些时间段很小的，系统中有很多进程，每个进程中又包含很多线程，在同一 时间段 内，电脑CPU只能处理一个线程（线程A），而下一个 时间段 就不一定是上一个时间段内执行的那个线程（线程A）了，可能是别的线程（线程B 吧）
CPU采用的是类似于时间片轮转的机制，也就是说同一时间一条进程提出执行请求时，其他进程只能等待它执行完毕，CPU才会处理其他请求。其他进程相当于在排队等待中。当然了，为了避免某条进程无限制时间的执行，一般会限定一个时间，超时 的话，CPU根据一定的线程调度算法来切换线程。可以看做很多线程在并发执行。其实还是在某一个时间点上只有一个线程在运行罢了。
多核的话，每个核心都是同样的原理。但是两个核心就可以通过系统分配资源，同时执行不同的进程，这个就更复杂了。
每条进程都有CPU分配的进程号的。避免混乱。
一个核心就是实实在在的一个cpu处理设备 线程的概念可以理解成电脑处理信息的通道 既一个线程一个通道 一般来说一个cpu核心处理一个通道的信息 但也不是绝对 因特尔支持超线程技术的cpu每个核心可以处理两个或多个通道的信息 这就可以形容为超线程（既多出来的通道的处理能力）但前提是软件也必须的支持超线程才行 否则单核双线程或多线程也只能有单个通道工作 从某种意义上来说cpu的能力被浪费了 所以网友一般就会说 真正的核心数（通道） 比虚拟出来的核心（通道）来个更实在。最后 线程数决定这CPU能同时处理几件事情，在没有超线程技术的情况下核心数等於线程数。
java线程调度 CPU对于各个线程的调度是随机的（分时调度），在Java程序中，JVM负责线程的调度。 线程调度是指按照特定的机制为多个线程分配CPU的使用权，也就是实际执行的时候是线程，因此CPU调度的最小单位是线程，而资源分配的最小单位是进程。
JVM调度的模式有两种：分时调度和抢占式调度。
分时调度 是所有线程轮流获得CPU使用权，并平均分配每个线程占用CPU的时间;
抢占式调度 是根据线程的优先级别来获取CPU的使用权。JVM的线程调度模式采用了抢占式模式。既然是抢占调度，那么我们就能通过设置优先级来“有限”的控制线程的运行顺序，注意“有限”一次。
CPU核数 跟多线程 的关系 要说多线程就离不开进程，进程和线程的区别在这里就不详细说了，只将关键的几点：
a)进程之间是 相互独立的，不共享 内存和数据，线程之间 的内存和数据是 公用的，每个线程只有自己的一组CPU指令、寄存器和堆栈，对于线程来说只有CPU里的东西是自己独享的，程序中的其他东西都是跟同一个进程里的其他线程共享的。
b)操作系统创建进程时要分配好多外部资源，所以开销大。（这个跟操作系统有关，有人做过实验，window创建进程的开销大，Linux创建进程的开销就很小。）
再来说一下CPU，过去单CPU时代，最先是单任务阶段 在一个时间点 只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。而现在多核CPU的情况下，同一时间点可以执行多个任务(并行)，具体到这个任务在CPU哪个核上运行，这个就跟操作系统和CPU本身的设计相关了。
我们假设一个极端的情况：在一台单核计算机上只运行2个程序，一个是我们的程序A，另一个是操作系统的程序B，每个程序是一个进程。单核CPU的时候，A和B在CPU上交替运行，具体的分配方式由操作系统来判断，我这里猜测应该跟A和B的线程数有关，因为线程是CPU级别的，如果A有5个线程，B也有5个线程，那么CPU分配给A和B的时间应该是1：1的；如果A增加到15个线程，CPU分配给A和B的时间应该是3：1的比例。所以此时如果A的线程数多，那么获得的CPU执行次数就多，处理的速度也就快了。以上假设的前提是：①A和B的优先级相同，②A和B都是只消耗CPU资源的程序。
如果相同的情况用一个双核的计算机来处理又会是什么结果呢？假设这个双核的计算机和操作系统比较傻，把A进程分配到核1上，B进程分配到核2上，那不管A有几个线程，都是用核1来处理，那么时间肯定是一样的。不过现实中应该不会有这么傻的CPU和操作系统吧。所以赶紧还是会根据线程来进行处理，当A的线程比B多时，会占用核2来处理A的线程。
刚才说的是只消耗CPU资源的程序，但这样的程序在实际应用中基本上是没有的，总会有跟资源打交道的。比如读个文件，查个数据库，访问一个网络连接等等。这个时候多线程才真正体现出优势，在一个进程中，线程a去读文件，线程b去查数据库，线程c去访问网络，a先用一下CPU，然后去读文件，此时CPU空闲，b就用一下，然后去查数据库，……，相对于读文件、查数据库、访问网络来说CPU计算的时间几乎可以忽略不计，所以多线程实际上是计算机多种资源的并行运用，跟CPU有几个核心是没什么关系的。
https://my.oschina.net/xiaotian120/blog/196201 (java线程调度)
http://blog.csdn.net/ziwen00/article/details/38097297（这篇写的也不错）
原文参考：https://blog.csdn.net/qq_33530388/article/details/62448212
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42eb4ab30a23bb9202788fa9ed5da40/" rel="bookmark">
			如何将视频中的某一段截取制作gif动图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们有时看到一些好玩的视频片段，会选择将其转换成GIF，制作成好玩搞笑的GIF动态图片，那么如何将视频转换成GIF呢，视频转换成GIF又有哪些方法呢？其实视频转GIF还是比较简单的，下面小编便来教大家如何使用该款软件将视频转换成GIF。
使用方法
一、将视频转换成GIF，我们可以选择从视频中截取一些搞笑的片段来转换，截取视频就需要用到一些工具，所以首先便是打开工具栏中提到GIF制作软件。然后我们点击启动屏幕录制的这一功能。
二、当视频窗口录制框弹出后，我们将其对准我们要截取的那个视频文件，准备好后，我们点击开始录制，当视频片段截取完成后，我们点击停止，来完成录制。
三、当截取的视频导入完成了，我们在图像编辑器可以对其进行美化和编辑，具体的功能在下图所示的上方面板中，利用这些功能，我们可以将其制作成好玩的GIF动态图片。
四、当这个视频片段编辑好了，我们就导出它，将其制作成GIF格式的动态图片，首先点击导出GIF，然后将下图所示的文件类型设置成GIF格式的，最后点击应用，便可以导出视频并将其转换成我们的GIF图片了。
五、我们刚才导出的GIF图片，如果需要查看可以在右下方弹出的编码器弹框中查看，点击查看的按钮便可以查看。
以上便是小编使用GIF制作工具将视频转换成GIF动态图片的全部步骤了，还是比较简单的，小编建议大家在选择视频素材的时候，可以选择些综艺节目或者动漫，搞笑的画面比较好，比较的好玩和可爱。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c147be3d456e756481d6287b895208/" rel="bookmark">
			Peppa配置中心设计-第一篇：设计概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述：
为多个应用提供生产、测试、联调、开发环境的配置，使应用无状态化。
隔离性：多个应用配置隔离；生产、测试、联调、开发环境隔离；
配置推送延时：秒级推送。
颗粒度：细致到单机配置推送。
提供配置管理控台，权限控制、配置CURD。
支持多种数据存储方式：zookeeper、redis、mysql；
高可用性：进程内存、本地文件、远程数据存储，即使配置中心中断服务也不影响应用运行；
高性能：标准虚机（4C8G），10w+ TPS。
提供yuanzi框架整合适配。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b282bb99f59ece10fc709b32646f5f3/" rel="bookmark">
			Java 委托模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。
简单的Java例子 在这个例子里，类模拟打印机Printer拥有针式打印机RealPrinter的实例，Printer拥有的方法print()将处理转交给RealPrinter的方法print()。
class RealPrinter { // the "delegate" void print() { System.out.print("something"); } } class Printer { // the "delegator" RealPrinter p = new RealPrinter(); // create the delegate void print() { p.print(); // delegation } } public class Main { // to the outside world it looks like Printer actually prints. public static void main(String[] args) { Printer printer = new Printer(); printer.print(); } } 复杂的Java例子 通过使用接口，委托可以做到类型安全并且更加灵活。在这个例子里，类别C可以委托类别A或类别B，类别C拥有方法使自己可以在类别A或类别B间选择。因为类别A或类别B必须实现接口I规定的方法，所以在这里委托是类型安全的。这个例子显示出委托的缺点是需要更多的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b282bb99f59ece10fc709b32646f5f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aadc16bdf59867e4dd8cdae40192009/" rel="bookmark">
			mysql保存表情问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天进行微信绑定时，数据库一直报下面这个错误：
java.sql.SQLException: Incorrect string value: '\xF0\x9F\x8C\x99' for column 'f0014' at row 2 查询资料发现是因为表情导致的问题，现提供两个解决方法：
一、修改数据库的编码集。 1.一般数据的编码集是utf-8，但是utf-8不能保存表情，需要将utf8修改成utf8mb4的编码格式，并需要将表保存表情的字段修改为utf8mb4_general_ci。
my.ini作如下修改：
[mysqld]
character-set-server=utf8mb4
[mysql]
default-character-set=utf8mb4
修改后重启Mysql
或者使用工具只修改单个表的编码格式也可以。
2.在java链接数据库的时候不要加characterEncoding参数。
这样问题就解决了，但不知道为什么这个一直不行，所以可以尝试下面一个方法，过滤掉表情。
二、字符串中过滤掉表情 import org.apache.commons.lang3.StringUtils; /** * 表情替换 * * @param sourceStr 原字符串 * @param slipStr emoji表情替换成的字符串 * @return 过滤后的字符串 */ public static String filterEmoji(String sourceStr,String slipStr) { if(StringUtils.isNotBlank(sourceStr)){ return sourceStr.replaceAll("[\\ud800\\udc00-\\udbff\\udfff\\ud800-\\udfff]", slipStr); }else{ return sourceStr; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f3ef2e90421c894f7fb9abb6fae78e/" rel="bookmark">
			2018 抖音热门歌曲大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年的抖音呀，简直是火到发烫。
不得不说抖音上真的有好多脍炙人口，让人怎么听都听不腻的歌曲。
从幼儿园的小朋友到广场舞的大妈都在跟着里面的热歌摇摆，摇摆。
这个社交软件不仅充实了人们的生活，更带火了一大批抖音神曲，今天我们一起来盘点抖音上最火的首歌，看看你们都听过几首。
如果你全部听过，那就是一个深度的抖音控啦~
以下就是 2018 抖音最热歌曲大全，快来拿走，不谢！
DISC-01 01.走马 02.可能否 03.嘴巴嘟嘟 04.Something Just Like This 05.Nevada 06.Aloha Heja He 07.陷阱 08.往后余生 09.我的将军啊 10.Stay With Me 11.Havana 12.Solo Dance 13.让我做你的眼睛 14.再也不会遇见第二个 15.浪人琵琶 16.卡布奇诺 17.Please Don't Go 18.Let Her Go DISC-02 01.That Girld 02.答案 03.爱你 04.讲真的 05.学猫叫 06.Seve 07.What Are Words 08.纸短情长 09.不仅仅是喜欢 10.9277 11.Superstar 12.We Don't Talk Anymore 13.带你去旅行 14.平凡之路 15.男孩 16.BOOM 17.痴情玫瑰花 18.我的秘密 DISC-03 01.3an 02.BINGBIAN 病变（女声版） 03.体面 04.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f3ef2e90421c894f7fb9abb6fae78e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4637b2ec0e79d2afe26375c10511e7/" rel="bookmark">
			HCNA存储 (二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第七章： 存储可靠性技术
传统RAID技术：
RAID:（Redundant array of independent disks）独立硬盘冗余阵列 高效的数据组织：条带化和并行访问
数据保护：奇偶校验和热备用
实现方法：硬件RAID ----应用：RAID卡（RAID 1技术 ）厂商：LSI
软件RAID-----应用：LVM(Linux) 逻辑卷，带区卷（window）
RAID技术出现的初衷是把多个小容量的硬盘组合起来， 现在：数据保护相关
物理设备失效， RAID能防止数据的丢失，提高性能。
主要功能：1、数据进行条带化，实现对数据成块存取、减少寻道时间，提高数据读取速度。 条带化---分区
2、一阵列中的几块硬盘同时读取（并行访问），减少寻道时间，提高存取速度。
RAID的数据组织形式：1、条带（strip）：硬盘单个或多个连续的扇区构成一个条带，数据读写的最小单元 组成分条的元素 2、分条（stipe）：同一硬盘阵列中的多个硬盘驱动器上相同 “位置”（或者说是相同编号）的条带。
分条分为：宽度：指在一个分条中数据成员盘的个数
深度：指一个条带的容量大小
保护方式： 1、镜像（备份） 2、奇偶校验算法（XOR）----数据丢失可以通过这个算回来
应用：数字电子、计算机
算法：相同为假、相异为真 RAID级别：RAID0、 RAID1、 RAID3、RAID5、RAID6、RAID10、RAID50.
RAID优势： 1 多个硬盘合成一个逻辑盘组-----更大容量
2 数据分割数据块 -----------提高访问速度
3 镜像/奇偶校验------容错
RAID组硬盘大小不同，以性能最差的为准
RAID 0：(条带化RAID) ----缓存
硬盘数最少2块 将数据以512倍数的数据存入硬盘中
数据块， RAID0组的写入性能与硬盘的数量成正比。
特点： 一个单一的大容量的硬盘。 还具备快速I/O
JBOD是存储领域中一类重要的存储设备。
RAID 1------镜像 （高安全性的RAID级别）
最少二块硬盘，一块为单个硬盘容量----另一块保存的是数据的副本。
总容量 ：n分之一 ， （N表示硬盘）
一个RAID 1 的性能是单个硬盘的写性能
RAID 1 读取数据时，会同时读取数据盘和镜像盘，提高性能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca4637b2ec0e79d2afe26375c10511e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ab66c8c7b2de959a866cf7cfd423e4/" rel="bookmark">
			两个div之间互换位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div id="divs"&gt;
&lt;div class="b-1"&gt;111111&lt;/div&gt;
&lt;div class="b-2"&gt;222222&lt;/div&gt;
&lt;div class="b-3"&gt;333333&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
// 方法一
$(document).ready(function(){
var arr = $('#divs').find('div').toArray();// 把三个div放进数组里面
var temp;
// 1 3对调
temp = arr[0];
arr[0] = arr[2];
arr[2] = temp;
$('#divs').html(arr)
});
// 方法二
window.onload = function() {
changeDiv(0,2)
}
function changeDiv(firstIndex,secondIndex){
var $divs = $('#divs').find('div');
var firstDiv = $divs.eq(firstIndex);
var secondDiv = $divs.eq(secondIndex);
var temp;
temp = firstDiv.html();
firstDiv.html(secondDiv.html());
secondDiv.html(temp);
}
// 方法三
$(document).ready(function(){
var $div1 = $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ab66c8c7b2de959a866cf7cfd423e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0466bb6085f6566b04058c61aac79c29/" rel="bookmark">
			win10与Ubantu双系统：Linux下开启FTP服务器与创建无线热点（实现文件共享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在博客有一篇文章解决16GB入门级IPAD或IPHONE容量的尴尬，多种扩容方式探讨（无线硬盘/直接访问）
写的是如何在win系统下使用filelizza这个软件搭建FTP服务器，然后建立一个无线局域网，让平板终端连接以后，访问电脑硬盘的文件。
如果是只在win7环境下，一切都很简单，按照上文提供的教程就可以实现。
但是上个月升级了笔记本，用的是华硕S4000UA，i7处理器。Intel对win7 不再更新驱动，找了很久也没有合适的驱动。所以干脆就用win10系统，觉得win10还是非常好用的，除了不够稳定以外，其他都可以接受，况且应用商店还可以听Podcast，各种国外原滋原味的广播，学习英语正好，素材丰富，这个win7是没有的。win8的情况，和win10一样，网卡不稳定，平板连上以后频繁掉线。所以想起来看看是否可以在Linux系统下实现，虽然耗费了一番周折，但结果终究是圆满的。
今天想对前三天的工作做个总结，：
Day one：在win10的环境下安装Linux系统，版本是Ubantu 17.04。Day two：在Ubantu系统下开启FTP服务器，设置访问文件的权限。Day three：在Ubantu系统下创建Android可用的热点，搭建无线局域网。 一、win10下安装Ubantu双系统 这个在网上有许多教程，可以找一篇照着做。我的做法，笔记本是固态+机械双硬盘，机械硬盘是为了增加笔记本容量，后来加上去的，1T的容量。在安装过程中，建议卸载掉。固态硬盘完全是用来给双系统服务的，100G给了win10，70G给了Ubantu，剩下70G留着存些文件。做了一个Linux的U盘启动盘，这里有一个插曲，用大白菜制作启动U盘的时候，忘了还连接着移动硬盘，结果把移动硬盘识别为U盘，格式化了，好在移动硬盘只是备份的数据，损失不大，重新下载即可。把两个系统全部安装在一个磁盘上的考虑也是如此，担心安装系统，不小心把硬盘格式化了。这样就相当于将系统和文件分开了。
安装过程中还有一个问题，选择安装选项的时候，不要选第一个，与win10共存。选最后一个，其他选项，然后自行分区。如果看不到可用的容量，只要删除分区，就变成可用容量了，然后点击左下角下面的+号，开始分区，后面的安装就很简单了。有教程提示，安装完再进win10系统，用easyBCD引导。其实，我安装完以后，直接就是grub引导的界面，可以选择win10还是Ubantu。
二、在Ubantu系统下开启FTP服务器，设置访问文件的权限 这里也参考前面两篇文章：
Ubuntu下搭建FTP服务器图解Ubantu搭建ftp服务器产生错误：550 Failed to change directoryd的解决方法 第一篇文章应该已经解决了FTP的问题，第二篇文章是因为我的机械硬盘访问不了，所以需要更改下权限。
三、在Ubantu系统下创建Android可用的热点，搭建无线局域网 一、网卡选择 不同于windows上，大部分的网卡都支持软AP ，linux下的网卡需要支持mode master的才可以做软AP 。具体识别方法如下
1、iwconfig识别
[root@localhost ~]$ sudo iw list ........略........................ Supported interface modes: * IBSS * managed * AP * AP/VLAN 如果「Supported interface modes」中有「AP」的话，那么恭喜你，你的无线网卡可以架设虚拟AP 。如果没有则不支持。
[root@localhost ~]$ sudo ethtool -i wlan0 driver: iwlagn version: 3.0-ARCH firmware-version: 8.83.5.1 build 33692bus-info: 0000:03:00.0supports-statistics: nosupports-test: nosupports-eeprom-access: nosupports-register-dump: no 例如上面的示例中使用的驱动为iwlagn，通过http://wireless.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0466bb6085f6566b04058c61aac79c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef529957b0016425305e17e9001c03d/" rel="bookmark">
			判断金额在1~100范围之内，可以为小数，且保留小数点后三位-------------Js 和 Java中的 正则表达式：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Js 和 Java中的 正则表达式： 项目当中遇到需要使用正则表达式的问题 需求比较简单，如下： 判断金额在1~100范围之内，可以为小数，且保留小数点后三位。 开发环境： java、angular | js 举例说明： 后端 //比较三个字符串：
String str = "999"; String str1 = "99.9999"; String str2 = "99.999"; //以上三个字符串只是举例说明，正常开发一般是方法中传过来的对象活参数
//正则表达式：
String regExp = "^0\\.\\d[1-9]$|^0\\.[1-9]\\d$|^[1-9](\\.\\d{1,2})?$|^[1-9]\\d(\\.\\d{1,3})?$"; //表达式特殊处理：
Pattern p = Pattern.compile(regExp); //处理后的正则表达式与字符比较
Matcher m = p.matcher(str2); //判断比较结果 ： str与 str1 均不符合正则条件
if(!m.matches()){ throw new AppException("erro messages"); } else { XXXDao.insert(str2); } 前端： //&lt; input /&gt;
&lt;input type="number" name="percent" [(ngModel)]="entity.percent" #name="ngModel" class="form-control" (blur)="blur()"&gt; //js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ef529957b0016425305e17e9001c03d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2311f54f0f10843554126e341379817/" rel="bookmark">
			eclipse 安装java ee插件（java se升级到java ee）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来安装的java se，后需要开发java ee程序，走了些弯路才安装成功。如下是步骤
1.打开eclipse，help-&gt;About Eclipse IDE，看好我下图红线圈出的地方，也就是版本号
2.help-&gt;install New Software,在Work with的框里填 http://download.eclipse.org/releases/+步骤一中的版本号（也可能是英文名），回车，等待加载出内容，选择Web，XML,Java EE and OSGi。。。这一项，然后就是一直next即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfa5dc9d854823daa8fb3ce2845c681/" rel="bookmark">
			JavaScript中的onmouseover事件和onmouseout事件实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
JavaScript事件
onmouseover事件
onmouseout事件：
onmouseover和onmouseout事件结合案例：
HTML部分
CSS部分
javascript部分
最终效果：
JavaScript事件 事件可以是浏览器行为，也可以是用户行为！
网页中的每个元素都可以产生某些可以触发 JavaScript 函数的事件。比方说，我们可以在用户点击某按钮时产生一个 onClick 事件来触发某个函数。事件在 HTML 页面中定义。
JavaScript中的 事件类型有很多种，比如：
1、按钮的单击事件。
2、鼠标悬浮在某个图片上，有着特殊效果。
3、鼠标离开某个图片上，效果消失。
4、使用键盘上某个键，后出现效果。
5、等等……
onmouseover事件 onmouseover事件：指鼠标移动都某个指点的HTML标签上，会出现什么效果。 例如： var p = document.getElementById("p") /*获取id名字为p的标签*/ /* 给获取到的id添加事件 */ p.onmouseover = function (){ alert("鼠标已经移动上来！"); } onmouseout事件 onmouseout事件：指鼠标移出某个指点的HTML标签后，会出现什么效果。 例如： var p = document.getElementById("p") /*获取id名字为p的标签*/ /* 给获取到的id添加事件 */ p.onmouseout = function (){ alert("鼠标已经移出！"); } onmouseover和onmouseout事件结合案例： HTML部分 &lt;!-- 按钮 --&gt; &lt;label id="info"&gt; &lt;input type="checkbox" /&gt;免登录十天 &lt;/label&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cfa5dc9d854823daa8fb3ce2845c681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac080cf75612867fc981f5100cc1dfdb/" rel="bookmark">
			isNotEmpty和isNotBank区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先isNotEmpty和isNotBank都是判断字符是否为空，它是属于org.apache.commons.lang包下的（当然你可以可以采用其他包下的，或则自己造轮子）
这里再说下俩者的区别，isNotEmpty是当字符对象null或则是""时判定字符对象为空，isNotBlank也是当字符对象null或则是""时判定字符对象为空，它还多一种情况判断，当字符对象为" "这种空白字符串(只有空格)也是判定为空
isNotEmpty源码
public static boolean isNotEmpty(String str) { return !isEmpty(str); } // 判断字符是否为空，即是否为null或"" public static boolean isEmpty(String str) { return str == null || str.length() == 0; } isNotBlank源码
public static boolean isNotBlank(String str) { return !isBlank(str); } public static boolean isBlank(String str) { int strLen; // 若字符串为null或则字符串为"",则判断为空，否则继续判断是否为空白字符串 if (str != null &amp;&amp; (strLen = str.length()) != 0) { // 遍历字符串中的字符，只有有一个字符不是空白字符，则判定该字符不为空 for(int i = 0; i &lt; strLen; ++i) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac080cf75612867fc981f5100cc1dfdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4504cdb092164f8cb2896d59d01f98b9/" rel="bookmark">
			前端Vue框架(过滤器使用，生命周期，拦截器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记：
过滤器的应用1.时间 2.货币需要加￥符号
过滤器有两种：全局和局部
一.拦截器的使用
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;ceshi&lt;/title&gt;
&lt;script src="vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="box"&gt;
{{msg | accpName | jiaName}}
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
//全局拦截器
//过滤器的应用1.时间 2.货币需要加￥符号
//过滤器有两种：全局和局部
accpName过滤器的名称，后面的是方法
Vue.filter("accpName",function(val){
return "ACCP"+val;
});
//jiaName过滤器的名称，后面的是方法
Vue.filter("jiaName",function(val){
return val+"广州豪哥";
});
var vm = new Vue({
el:"#box",
data:{
msg:"jw"
}
});
结果：
拦截器案例：通过过滤器+零售价和打折，货币符号+￥
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;ceshi&lt;/title&gt;
&lt;script src="vue.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.bootcss.com/axios/0.18.0/axios.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
&lt;ul&gt;
&lt;li v-for="item in products"&gt;
{{item.name}}--{{item.price | discount(125) | myCurrency("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4504cdb092164f8cb2896d59d01f98b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3128693b27ecc3dda95afa2f964a4b42/" rel="bookmark">
			Failed to configure a DataSource: &#39;url&#39; attribute is not specified and no embedded datasource could
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习Spring boot的时候遇到 这样一个错误(编程工具:IDEA)
Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.
中文翻译:
配置数据源失败：未指定“URL”属性，无法配置嵌入式数据源。
百度了一通,找到了这篇:https://blog.csdn.net/coyotess/article/details/80637837
在程序的入口处添加:
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
代码如下:
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 然后重新运行,上述这个问题得到了合理的解决, 至于为什么会产生这个问题了,别人的代码没有加上这一段程序依然可以运行,而自己的程序却非要加上这个?
关于这个问题,不好意思,我也是刚学不久,没有对其进行深究,如果有知道的,可以告知一下!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfce0a6b6bff90d217431771eb1eeeb/" rel="bookmark">
			摄影成像原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://www.sohu.com/a/191146657_690175 摄影成像原理
照相机是个什么样的仪器？为什么可以把外界景物浓缩到一张小小的照片上？观察手中的照相机，就会感到这么多按钮、数字、开关，一定十分复杂。其实再高级的相机都是由镜头和机身这两样最基本的部件组成，它的成像原理都一样。
1、“小孔成像”
用一个带有小孔的板遮挡在屏幕与物之间，屏幕上就会形成物的倒像，我们把这样的现象叫小孔成像。前后移动中间的板，像的大小也会随之发生变化。这种现象反映了光沿直线传播的性质。
2、在照相机被发明之前，人们就已经开始利用“小孔成像”原理制造各类光学成像装置，这种装置被称为“Cameraobscura（暗箱）”。19世纪上半叶，人们终于找到了固定保存暗箱中投影面上光学图像的方法与介质，照相机工业由此发端，因此Camera obscura被认为是照相机的祖先；而“Camera”则成了照相机的英文名称。
Camera obscura 暗箱
暗箱使用示意图
3、照相机的发明
1839 年法国画家达盖尔根据小孔成像的原理发明了被称为“西洋镜”的世界第一台照相机。不过当时的相机令现代人无法想象，暗箱大得像个小房子，拍摄时间至少三十分钟，以至于不得不将被摄的人头部固定在事先预制好的卡箍里，而且得到的只是一张笨重的铜版正像。当时有报社记者评述：“就像在马路上拿着一面镜子，周围的景物极细地反映出来，然后把镜子带回家。”
1841 年英国科学家、化学家塔尔博特发明了底片技术，不是“把影像印在笨重的铜版上带回家”，而是把影像通过底片印在造价低廉的纸上，大大降低了成本，出现了可供普通人拍照留影的商业相机。尽管它当时还比较粗糙和简陋，但已经具备了现代相机的基本性能。从此，摄影技术在世界各地广泛传播，摄影器材不断完善。
经过一百七十多年的历史演变，照相机逐步由体积庞大的“西洋镜”发展成为小巧玲珑、操作简便、性能优良的精密仪器，并且开始向全自动、多功能、高清晰度的趋势发展
1839 年法国画家达盖尔根据小孔成像的原理发明了被称为“西洋镜”的世界第一台照相机
照相机基本部件
照相机就像一个神秘的箱子，它像我们人的眼睛一样，可以看清外界的景物，同时又可以把看到的景物印映在底片上。仔细观察手中的照相机，就会发现无论高级相机还是普及相机都是由机身、镜头、光圈、快门、取景器五部分组成，如果使用胶片相机还有输片机构。照相机是集光学、机械和电子为一体的精密仪器。数码相机具有有全自动操作功能，如自动聚焦、自动曝光等。简单机械的相机只有一个快门按钮和电源开关。
一、机身
当我们拿起一架照相机，首先看到一个不透光的暗箱，我们称它为机身。机身是连接照相机光学、机械、电子三大部分的总载体。它的前端安装照相机镜头。
数码相机机身里装有图像感应器、数字影像处理器和图像存储器等电子元件。传统胶片照相机的机身暗箱里面装有胶卷，胶卷中间装有各种光学、机械、电子元件，使相机成为一个整体。此外，各种摄影附件和辅助器材，在使用中也要与机身连接。因此，照相机机身一般由金属或经过加工强度较高的注塑材料制成。
二、镜头
镜头又称摄影物镜。镜头的功能是使外界景物在照相机暗箱内的胶卷平面处形成清晰的影像。就好像我们人类的眼睛能够把看到的景物清晰地映印在眼睛球体上的视网膜上的作用一样。镜头是照相机的重要部分，同学们要像爱护自己的眼睛一样爱护镜头。
如果你仔细观看，会发现镜头里有好几片凸凹不同的镜片，我们称之为正、负透镜。正（凸）透镜使光线会聚，产生实像，负（凹）透镜使光线散射，不产生实像。正负透镜结合可以使形成的影像不仅清晰还可以减弱像差，提高成像质量。因此，所有的照相机镜头都由数量不等的正负透镜组成。越高级的镜头透镜片数越多。镜头一般至少由4片3 组透镜组成。镜片通常由研磨精细的光学玻璃制成，并且在镜片表面进行镀膜处理。
现代照相机镜头有很多种类，数码相机通常使用带马达的EF电子变焦镜头，自动调整镜头焦距，极大地方便了摄影者创作，满足不同摄影题材的需要。
镜头剖面示意图
形形色色的镜头
三、光圈
光圈是安装在照相机镜头中直径可以伸缩的光孔，俗称“光圈”。在传统的胶片照相机里光圈一般由数量不等的月牙形薄金属片制成。光圈的作用是与快门配合，控制外界景物反射光线进入暗箱的多少，使胶卷能够正确曝光。光圈的另一个作用是调节被摄景物的景深的大小。像可伸缩的“光闸”，如同我们人类眼睛的瞳孔，为了适应外界景物亮度的变化，要不断调节眼睛瞳孔大小。
转动照相机镜头上的光圈调节环，可以改变光孔直径，控制光量进入暗箱。假如我们把暗箱比作是一个密不透光的屋子，屋子只开一个可以透光的窗子，这个窗子开得大透光就多，开得小透光就少。这个“窗子”就好像镜头中的光圈。光圈大小用光圈系数“f ”表示，一般标志在镜头筒上。 光圈系数在国际上是统一标定的。不论哪种相机的镜头，只要光圈系数相同，它们的透光量就完全相同。
四、快门
快门是安装在照相机镜头与胶卷平面之间的“光闸”。快门与光圈配合，随着快门开启时间的不同，控制胶片曝光时间的长短。操纵快门开启的按钮一般安装在照相机机身上方便于操作的地方，也有的快门按钮安装在镜头附近。调节快门速度盘，可以改变快门开启时间，控制胶片的曝光量，使胶片得到适合的曝光值。就好比我们在一间只有一扇窗子的黑屋子里，打开窗子的时间长与短，得到的光量数是不同的。各种相机的快门速度都是一样的，不论哪种相机，只要数值相同，快门速度完全相同。
目前，常用照相机快门有焦平面式快门和中心式快门两种类型。快门操作上有机械操作和电子操作两种方式。数码照相机的快门速度是由电子程序控制的，速度可以高达1/8000秒。
快门和光圈是一对“好兄弟”，摄影创作中根据摄影内容需要相互配合，才能得到预期效果。
五、取景器
取景器是供摄影者观察被摄景物，确定取景范围的机构。设置在机身上部便于观看的部位。现代照相机的取景器一般兼有测光、测距和指示光圈大小、快门速度等数据的显示功能。
电子技术的飞速发展，数码照相机大部分采用LCD宽视角液晶屏的取景方式，有的液晶屏还可以旋转，极大地方便了摄影者创作的需要。
传统胶片机械照相机的取景器分为旁轴取景器和同轴取景器两大类。旁轴取景器的取景光路不通过照相机镜头，而是由一个单独的光学系统完成的，因此存在视差现象。也就是取景范围和实际拍摄的范围不完全一样。现代中、高档相机多采用同轴取景器，取景光路与摄影光路同用一个照相机镜头，不会产生视差现象。这种方式又称为单镜头反光取景器。同轴取景器仍有不足之处，由于外界景物是通过一个45度的反光镜折射到取景窗内的。当快门开启的瞬间，反光镜弹起，使摄影光路到达了胶片平面，这时取景光路阻塞，取景器视场全部变黑，摄影者在这一瞬间看不到取景范围，容易在动体摄影或较长时间曝光摄影时造成失误。目前，国外已出现了克服这一缺点的新机种。采用固定式半透明、半反射的反光镜，其中被摄景物的光线1/3反射到取景器用于取景，2/3 光线透过反光镜，到达胶片平面上用于摄影曝光，而且不存在震动现象，拍摄中始终可以看到被摄景物。
单反专用外接液晶取景器
照相机的种类
照相机是光学、电子、机械三方面结合的综合体，除了具备以上基本部件外，每架照相机都有各自的特点。少年朋友在了解照相机主要部件性能的基础上，应当更多地学习些新的照相机知识。选择好适合自己需要的相机，并且熟练掌握手中的相机，才会在摄影创作中更好地发挥照相机的作用。
走进照相机商店，少年朋友一定会被琳琅满目的相机世界弄得眼花缭乱，不知选择什么样的相机更适合自己使用。这里向少年朋友简单介绍选择照相机应该具备的常识，以便选择适合自己使用的照相机。
目前，照相机的品种大致有两类，一类是普遍使用的小型数码照相机，俗称“傻瓜”相机，一般价钱比较便宜。另一类是专业单反照相机。电子技术的不断进步，数码专业单反照相机已经成为摄影工作者的主要机种。但是，由于传统胶片摄影作品具有细腻、胶片宽容大、色彩还原逼真、照片细腻、色彩还原逼真，还可以放大制作等优点，仍然是摄影工作者在特定题材创作时使用的机种。
一、小型数码照相机
小型数码照相机在照相机家族中是个“小弟弟”，俗称“傻瓜”相机。由于该机轻巧、方便，受到普遍欢迎。这种相机的取景器采用LCD宽视角液晶屏的取景方式，安装在机身后面。取景光路由一个单独的取景光学系统完成，液晶屏明亮，直接可以观察和选择被摄景物。拍摄时，按动快门按钮的声音极轻。没有机械式快门翻动快门的噪声。小型数码相机使用方便，操作简单，常常是“咔嚓”一声就能拍出较满意的照片。可以满足少年朋友最初学习摄影的要求。随着少年朋友摄影技艺逐步提高，这种“傻瓜”相机带给少年朋友固定的程序模式就不能满足少年朋友的需要了。况且，摄影是技艺的结合，选择合适的光圈快门组合、营造不同的影调气氛是摄影创作的主要手段。大凡优秀的摄影家都喜欢用胶片摄影方式，人工调节操作相机来拍摄不同风格的作品。
小型数码照相机
二、专业单反照相机
电子技术飞速发展，专业数码单反照相机实现了高度的全自动化，出现了自动调焦自动变焦等更为简便操作方式的AF全自动相机。这种相机通过机内发出的红外线光束测量与被摄主体的距离，自动调焦驱动镜头调焦环，达到正确调整聚实焦距的目的。操作时只需按快门，有的相机镜头还可以改变焦距，一般变焦范围为28毫米至85 毫米，通过机内微型马达驱动，改变拍摄范围的大小，大大方便了摄影者选择画面的需要。有的相机还根据摄影需要换用不同焦距的的镜头。完全改变了手动机械式相机的操作时的麻烦，把原来难度较大的操作变成了简单的程序化方式。这种相机还具有自动白平衡、自动曝光、自动控制闪光灯自动除尘等功能，大大减轻了摄影者负担。
传统胶片单镜头反光相机根据摄影需要可以换用不同焦距的长焦距、广角或变焦距镜头。这种相机以焦平面式快门居多。快门速度现在已经达到了1/8000秒至1 秒，并有长时间曝光用的“B” 门功能，完全可以满足摄影创作的要求。
600万级专业数码相机
同学们学习摄影的过程是为了增长知识，增长知识的途径主要是要通过动手动脑，同学们的着眼点应该放掌握技能和提高创作水平上。有一架单镜头反光式相机当然是较为理想的，但从偏高的价格考虑，一时难以接受。在选择相机时，我想，宁可少一点自动功能，也不能没有基本的手动调节功能。多一些动手机会，才能在实践中摸索、提高掌握知识和技能。建议同学们学习摄影最好使用具有手动功能的照相机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d53521de13cf06e290401822e92b63e/" rel="bookmark">
			Linux系统安装RabbitMQ详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装Erlang
安装类库
yum -y install ncurses-devel yum -y install openssl-devel yum -y install unixODBC-devel yum -y install gcc-c++ 准备安装包otp_src_18.2.1.tar.gz，解压，配置、编译并安装
./configure --prefix=/hwd/software/erlang make make install 配置环境变量
export ERLANG_HOME=/hwd/software/erlang export PATH=$ERLANG_HOME/bin:$PATH 测试
2、安装RabbitMQ
准备安装包rabbitmq-server-generic-unix-3.6.9.tar.xz，解压
xz -d rabbitmq-server-generic-unix-3.6.9.tar.xz tar -xvf rabbitmq-server-generic-unix-3.6.9.tar 启动插件
./rabbitmq-plugins enable rabbitmq_management
启动服务
./rabbitmq-server -detached
关闭防火墙，否则非本地设备无法访问RabbitMQ服务
systemctl status firewalld systemctl stop firewalld 添加用户
./rabbitmqctl add_user root 123456
设置用户角色
./rabbitmqctl set_user_tags root administrator
查看用户
./rabbitmqctl list_users
设置用户权限
./rabbitmqctl set_permissions -p / root "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d53521de13cf06e290401822e92b63e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37170729c767ea1ab61e994b64254f38/" rel="bookmark">
			前端---js中onmouseover和onmouseout事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网页浏览中我们可以发现在有些页面的部分当我们鼠标移动到某个板块的时候会发现它弹出一个新的板块并且当鼠标移出后又自动隐藏,是因为在改板块中使用了javascript中的onmouseover和onmouseout这两个事件来实现的操作. 1.onmouseover定义和用法 onmouseover 事件会在鼠标指针移动到指定的对象上时发生。
语法 οnmοuseοver="SomeJavaScriptCode" 参数描述SomeJavaScriptCode必需。规定该事件发生时执行的 JavaScript。 支持该事件的 HTML 标签： &lt;a&gt;, &lt;address&gt;, &lt;area&gt;, &lt;b&gt;, &lt;bdo&gt;, &lt;big&gt;, &lt;blockquote&gt;, &lt;body&gt;, &lt;button&gt;, &lt;caption&gt;, &lt;cite&gt;, &lt;code&gt;, &lt;dd&gt;, &lt;dfn&gt;, &lt;div&gt;, &lt;dl&gt;, &lt;dt&gt;, &lt;em&gt;, &lt;fieldset&gt;, &lt;form&gt;, &lt;h1&gt; to &lt;h6&gt;, &lt;hr&gt;, &lt;i&gt;, &lt;img&gt;, &lt;input&gt;, &lt;kbd&gt;, &lt;label&gt;, &lt;legend&gt;, &lt;li&gt;, &lt;map&gt;, &lt;ol&gt;, &lt;p&gt;, &lt;pre&gt;, &lt;samp&gt;, &lt;select&gt;, &lt;small&gt;, &lt;span&gt;, &lt;strong&gt;, &lt;sub&gt;, &lt;sup&gt;, &lt;table&gt;, &lt;tbody&gt;, &lt;td&gt;, &lt;textarea&gt;, &lt;tfoot&gt;, &lt;th&gt;, &lt;thead&gt;, &lt;tr&gt;, &lt;tt&gt;, &lt;ul&gt;, &lt;var&gt; 2.onmouseout定义和用法 onmouseout 事件会在鼠标指针移出指定的对象时发生。
语法 οnmοuseοut="SomeJavaScriptCode" 参数描述SomeJavaScriptCode必需。规定该事件发生时执行的 JavaScript。 支持该事件的 HTML 标签： &lt;a&gt;, &lt;address&gt;, &lt;area&gt;, &lt;b&gt;, &lt;bdo&gt;, &lt;big&gt;, &lt;blockquote&gt;, &lt;body&gt;, &lt;button&gt;, &lt;caption&gt;, &lt;cite&gt;, &lt;code&gt;, &lt;dd&gt;, &lt;dfn&gt;, &lt;div&gt;, &lt;dl&gt;, &lt;dt&gt;, &lt;em&gt;, &lt;fieldset&gt;, &lt;form&gt;, &lt;h1&gt; to &lt;h6&gt;, &lt;hr&gt;, &lt;i&gt;, &lt;img&gt;, &lt;input&gt;, &lt;kbd&gt;, &lt;label&gt;, &lt;legend&gt;, &lt;li&gt;, &lt;map&gt;, &lt;ol&gt;, &lt;p&gt;, &lt;pre&gt;, &lt;samp&gt;, &lt;select&gt;, &lt;small&gt;, &lt;span&gt;, &lt;strong&gt;, &lt;sub&gt;, &lt;sup&gt;, &lt;table&gt;, &lt;tbody&gt;, &lt;td&gt;, &lt;textarea&gt;, &lt;tfoot&gt;, &lt;th&gt;, &lt;thead&gt;, &lt;tr&gt;, &lt;tt&gt;, &lt;ul&gt;, &lt;var&gt; 在接下来我们用一个实例来进行讲解这两个事件的作用:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37170729c767ea1ab61e994b64254f38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64263789d46b783f6905257b52c7ff7/" rel="bookmark">
			初等行变换不改变列向量组的线性关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		${初等行变换不改变列向量组的线性关系}$
列向量组之间的线性关系可以通过：
$\sum_{i=1}^n a_ix_i=0$
中系数$x_i$的情况表达，即
$Ax=0$
的解的情况，线性相关等价于有非零解，线性无关等价于只有0解；
而初等行变换不改变解，因此$a_i$的线性关系在初等行变换下不变，考察部分$a_i$组成如上方程组，
则得到任意部分向量组的线性关系在初等行变换下保持不变；
转载于:https://www.cnblogs.com/mathlife/p/9710755.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1d2591c2ae6a76e110e3db1d8e7de0/" rel="bookmark">
			批量读取文件名和批量改写文件名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bat命令批量获取和修改文件名 如图所示：
1、批量提取
（1）新建文本文档在文本文档里输入：
dir /a-d /b *.mp4&gt;src.txt
echo 收集文件名成功！
pause
（2）保存为“createsrc.bat”。
文件名字被提取到当前文件夹的 src.txt 里面了！也可以提取某类型的文件比如*.mp3 或者a*.mp3。
（3）运行 createsrc.bat 程序，
生成 src.txt ，其内容如下：
第四季01_真相只有一个.mp4
第四季02_谁说我有病.mp4
第四季03_以父之名.mp4
第四季04_翻滚吧！展博.mp4
第四季05_盗梦空间.mp4
第四季06_壮志凌云.mp4
第四季07_一条大河.mp4
第四季08_非诚勿扰.mp4
第四季09_冷战风云.mp4
第四季10_我是励志师.mp4
第四季11_土豪我们做朋友.mp4
第四季12_闪婚行动.mp4
第四季13_兄弟守则.mp4
第四季14_疯狂话剧（上）.mp4
第四季15_疯狂话剧（下）.mp4
第四季16_超级英雄.mp4
第四季17_放飞吧单身周末-上.mp4
第四季18_放飞吧单身周末-下.mp4
第四季19_女神的圣诞士.mp4
第四季20_当幸福来撬门（上）.mp4
第四季21_当幸福来撬门（下）.mp4
第四季22_曙光女神的宽恕.mp4
第四季23_回首又见他（上）.mp4
第四季24_回首又见他（下）.mp4
2、批量重命名
（1）新建文本文档在文本文档里输入：
@for /f %%s in (src.txt) do ( if exist %%s for /f %%d in (dest.txt) do ( ren %%s %%d.mp4) ) echo 操作成功！ pause （2）保存为“rename.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1d2591c2ae6a76e110e3db1d8e7de0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5634292a19230cab221fcdb0539dbd/" rel="bookmark">
			求1 &#43; 2！ &#43; 3！ &#43; 4！ &#43; 5！&#43;.....的阶乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是一道很简单的题目了。就是用递归的思想。像我这种菜鸟一下就能写出来，
我码的代码
//算法：递归 #include &lt;iostream&gt; using namespace std; //求阶乘函数 int Factorial(int n) { if(n == 1) return 1; else return (n * Factorial(n - 1)); } int main() { int t; int sum = 0; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) { sum += Factorial(i); } cout &lt;&lt; sum &lt;&lt; endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe25dc897cc6918465d8b629ee582528/" rel="bookmark">
			tomcat面向接口的java反射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//Propertise 存储浏览器路径与servlet对应关系
Propertise pro = new Propertise();
//通过key获取value值
String classServletName = pro.getProperty(requestPath);
//反射机制创建对象
Class c = Class.forName(classServletName);
//面向接口强转
Servlet servlet = (Servlet)c.newInsatance();
//调用servlet接口方法。
servlet.service();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5252ef06b12d6919cf3dced707bca034/" rel="bookmark">
			clone()方法有什么作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、先了解值传递和引用传递2、深复制和浅复制的区别： 1、先了解值传递和引用传递 Java在处理基本数据类型（例如int、char、double等）时，都是采用值传递（传递的是输入参数的副本）的方式执行，除此之外的其它类型（对象啊，String类型等）都是按引用传递（传递的是对象的一个引用）的方式执行。对象除了在函数调用时是引用传递，在使用“=”也是采用引用传递
class Obj { private int i = 0; public int getI() { return i; } public void setI(int i) { this.i = i; } public void changeI() { this.i = 1; } } public class LianXi { public static void main(String[] args) { Obj a = new Obj(); Obj b = a; b.changeI(); System.out.println("a:"+a.getI()); System.out.println("b:"+b.getI()); } } 运行结果：
a:1 b:1 在实际编程中，经常需要从某个已知对象A创建出另一个与A具有相同状态的对象B，并且对B的修改不会影响到A的状态，但从上面的实例中，我们会发现仅仅通过简单的赋值操作显然是无法达到这个目的的（b对象对i的修改影响到了a对象中的i），所以Java提供了一个简单有效的clone()方法来满足这个需求。
Java中所有的类都默认继承自Object类，而Object类中提供了一个clone()方法，这个方法的作用是返回一个Object对象的复制，这个复制方法返回的是一个新的对象而不是一个引用。以下是使用clone()方法的步骤：
实现clone的类首先需要继承Cloneable接口（Cloneable接口实质是一个标识接口，没有任何的接口方法）在类中重写Object类中的clone()方法在clone()方法中调用super.clone()。无论clone类继承结构是什么，super.clone()会直接或间接java.lang.Object类中的clone()方法。把浅复制的引用指向原型对象新的克隆体。 上面的例子引入clone()方法后代码：
class Obj implements Cloneable { private int i = 0; public int getI() { return i; } public void setI(int i) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5252ef06b12d6919cf3dced707bca034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7619f92811d85ac1814005000ea28d/" rel="bookmark">
			Vue项目部署tomcat，刷新报错404解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue创建项目使用脚手架有两种方式：
1，vue init webpack my
这种方式的项目打包，需要找到config/index.js文件将build中的assetsPublicPath: '/',修改成 assetsPublicPath: './',
build: { // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: './', ，然后执行npm run build,会在根目录下生成dist文件夹
将dist下的文件扔到你的tomcat的webapps文件夹的项目下即可。
2、vue init webpack-simple my
这种情况下的项目没有config，这时候就不需要配置1中的index.js文件了，直接执行npm run build ,同样会生成dist文件夹，但是这种情况下dist下面没有index.js ，所以需要你手动将dist下的文件个index.js文件，一同复制到tomcat的webapps项目下，也会有1中的效果。
如果没有意外，这时候项目应该可以访问了，但是当你选择单页面路由的时候，再刷新页面会出现404，这种情况肯定是要修复的，这时候就需要在tocmat的webapps下的项目中创建WEB-INF文件夹，在文件夹中创建文件web.xml。格式如下：
web.xml内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1" metadata-complete="true"&gt; &lt;display-name&gt;Router for Tomcat&lt;/display-name&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/index.html&lt;/location&gt; &lt;/error-page&gt; &lt;/web-app&gt; 重启，刷新，完美修复。
转载请标明出处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118000064371a3dc0956b2e299d37a45/" rel="bookmark">
			基于web的家庭理财系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub下载地址：https://github.com/mdxiaohu/familyFinanceSystem 理财管理项目开发文档 一．项目介绍 个人理财管理系统是典型的管理信息系统(MIS)，其开发主要包括后台数据库的建立和维护以及前端应用程序的开发两个方面。对于前者要求建立起数据一致性和完整性强、数据安全性好的库。而对于后者则要求应用程序功能完备,易使用等特点。开发的功能主要包括：通过计算机管理个人财产，实现无纸化理财，通过查询分析，统计出各项数据，分析出生活中的浪费和节约的地方，通过强大的查询和索检高效的索检出数据，提高办事效率。
二．系统功能描述 1.用户管理 在这一功能模块中，主要针对的是用户管理。需要实现新用户的创建，用户的登陆以及删除功能。用户只有在登陆后才能进行其他的操作。
2.账户管理 在这一功能模块中，主要是针对用户的多银行账户情况，其中可以添加、删除（注销）账户，可以实现账户间的转账，同时也可以分别查询每个账户的不同收支情况和转账情况。
3.收支管理 在这一功能模块中，主要功能有针对债务管理、个人贷款、物品管理模块中的支出的一个总揽。
4.债务管理 在这一功能模块中，主要是针对用户的债务关系，同样可以实现添加（借入）、删除（还款）、修改和检索债务等功能，这些数据的更新也会上传到收支管理和账户管理中去
5.收支预算 在这一功能模块中，主要是用于用户的每年和每月的一个收支预算，可以实现添预算、删除预算、修改（更新）预算和根据预算得到收支分析对比功能。
6.基础数据管理 在这一功能模块中，主要对上述应用的数据类别中的一些数据进行更新，包括银行类型、物品类别和收入与支出类别等。
三．开发环境 操作系统 -- Windows
开发工具 -- eclipse jdk8
数据库 -- MySQL
Web容器 -- Tomcat7
浏览器 -- Chrome
四．使用技术 Struts2 + hibernate5 + spring + mysql + jquery + easyui
五．项目展示 1.包结构
2.登录页面展示
3.管理员展示
4.用户页面展示
六．运行 1.安装开发工具
2.安装数据库，导入数据表
3.附件中，找到db_licai.sql，保存到本地D盘根目录，windows+R,输入cmd，打开dos命令窗口，连接数据库服务，创建数据库（数据库名称 = library），切换到该数据库，执行sql还原命令，见下图：
4.数据库还原后
5.修改项目中配置文件的信息
6.启动服务器，浏览器访问地址：http://localhost:8080/licai/，还有可能是8088接口，自测。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c944936082900ddb70be15b4cb734741/" rel="bookmark">
			OCR如何读取皱巴巴的文件？深度学习在文档图像形变矫正的应用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里妹导读：OCR作为智能审核的重要环节，其识别准确率影响着最终审核效果的好坏，而来自扫描仪、智能手机的文档图像多存在卷曲、折叠。本文旨在利用深度学习算法对文档图像的形变进行矫正，从而提高OCR识别效果，为智能审核保驾护航。
一、背景 随着集团业务的高速发展以及集团对用户群体信用要求的提高，证件审核成为业务中必不可少的一个环节。譬如：支付宝需要对用户的身份证信息进行审核，1688需要对卖家的营业执照进行审核。此外，还有一些业务涉及的是需要专业人士才有足够能力进行审核的信用证和保单。
近年来，人工智能在越来越多的任务中的表现已经超过了人类。如果能将AI引入审核场景，实现智能审核，将大大提高审核的效率。智能审核相比人工审核具有以下优势：
而要做到高水平的智能审核，难度颇大，需要做好以下几点：
要让机器代替人去做证件审核乃至于文本审核，首先需要让机器看到人所能看到的（OCR：将文本图像转化成文本），而后才是理解人所能看到的（NLP：如纠错分词／文本分类等）。作为后面一切算法的源头，OCR算法在智能审核中起着至关重要的角色。除却算法本身，图像质量乃是影响OCR识别准确率的最大因素。一般从三个方面来衡量图像的质量：倾斜、清晰度、扭曲。而本文的目的则在于如何通过算法使得扭曲的文档图像变得平整，从而改善扭曲文档图像的OCR识别准确率，为智能审核保驾护航。
二、相关工作 2.1 传统方法 当前针对扭曲文档图像的矫正算法主要有以下三类：
基于硬件的扭曲文档矫正
该类方法通常使用特制的硬件设备扫描纸张的三维形状信息。比如采用结构光源来对文档进行扫描从而获取文档的三维信息即深度信息，然后根据深度信息对文档图像进行矫正。
基于3D模型重建的文档矫正算法
该类方法主要从造成文档扭曲的因素出发，包括文档及其摆放角度、光源方向、图像获取设备特征等因素。通过对文档进行3D建模，并利用已有的数学知识对扭曲进行矫正。
基于内容切分的文档矫正算法
该类算法摈弃对扭曲的几何模拟与3D建模，直接对文档图像进行分析，包括倾斜角、文本行、字符或词组特征等，然后设计出一种不受文档图像以外因素影响的扭曲矫正算法。此类算法的优点在于不需要清楚地知道扭曲造成的原因。
三类算法各有优点，但也都有各自的局限性，可总结为：
可以看出，传统方法多是针对特定场景进行建模，而一旦跳出当前场景，模型就无法起作用。随着深度学习的兴起，有学者提出用深度学习相关算法对扭曲文档图像进行矫正。
2.2 深度学习方法 随着深度学习近几年的兴起，有学者提出用语义分割相关的模型对扭曲文档图像进行建模，将像素级的分类问题转化为像素级的回归问题，实现扭曲文档图像的矫正，模型具有一定的泛化能力，可针对复杂场景下的扭曲或折叠图像进行矫正。
在刚刚结束不久的CVPR 2018中，Ke ma等人提出一种基于语义分割中U-net模型[1]，利用图形学方法生成逼近真实场景的扭曲文档图像，通过这些样本集训练出可实现端到端矫正的Stacked U-net网络。
深度学习的优势在于如若有足够丰富和质量高的训练样本集，其深层网络结构令其具有一定的泛化能力，可针对多种扭曲实现矫正，跳出传统方法的场景限制。考虑到实际业务的复杂性，传统方法无法胜任，因此本文结合深度学习语义分割领域的相关知识，针对现有方法的不足提出优化方案，实现扭曲文档的矫正。
三、数据集生成 对机器学习或深度学习有一定了解的人都知道，很多时候，数据决定着你的模型能做到什么程度。而关于扭曲文档复原，一方面当前的开源数据集较少；另一方面，我们的目标是要建立能够实现像素级别回归任务的神经网络结构，这下子，开源且标注好的数据集几乎就是没有。因此，我们参考文献[1]中的方法，自行生成数据集。
3.1 扭曲文档图像生成 扭曲又分为折叠和卷曲，利用图形学相关知识，我们通过以下步骤实现了文档的折叠和卷曲：
其中，卷曲和折叠的区别是的计算公式的差异：
卷曲：
折叠：
而通过调整超参数的大小，可实现不同程度的扭曲变换，如下图所示：
3.2数据集生成过程的问题解决 当然，在进行数据集生成的时候，也是遇到了很多的问题，比如：
样本集的标签如何生成？
生成图片时遇到空点如何处理？
首先，是样本的标签问题，我们要实现像素集的回归，则每个像素都必须有一个标签，而如何设计标签才能让网络结构更好的完成该任务呢？
我们是这么设计的：
首先对比扭曲变换后的图像和原图像，得到折叠变换后的图像上的每个像素点所应该移动的位移大小和方向，然后构造一个3维的矩阵，一维用于存扭曲变换后的图像灰度值信息，另外两维用于存在x轴和y轴方向所应该移动的位移大小和方向，这样就实现了样本和标签的构造。
此外，在变换过程中，我们还发现生成的图像有一些会带有黑点或黑线，如下图所示：
上图中三幅小图分别代表变换过后的图像以及每个像素点的标签图像。我们通过分析发现，其之所以会存在黑点，是因为这个坐标下的像素是空的，而像素是空的原因是因为我们在进行变换的过程中，其实有一个取整操作，而这样的取整操作可能让原本相邻的两列像素点中间空出一列，如下示意图所示：
后来，我们通过最近邻插值解决了这个问题，上述存在黑点的图经过插值后得到如下变换图像：
当然，也可通过其他插值或修复方法修复这样的空白点。
解决了数据集问题，相当于解决了模型的食粮问题。那我们的模型具体长什么样呢？莫慌，下面我们将为你细细道来。
四、模型构建与优化 4.1基于U-net的扭曲文档矫正复原 我们一开始选用的是在语义分割中最为常用的U-net模型，其网络架构如下图所示[2]：
其网络架构形如字母“U”，因此被称为U-net，可以将此类神经网络理解为一个Encoder-Decoder结构，其中Encoder是收缩路径，主要是由卷积层和池化层组成，主要目的在于实现特征的提取或者说捕捉语义，而Decoder是扩展路径，主要通过转置卷积和跳跃连接实现，其主要目的是为了实现上采样，由于Pooling操作进行了下采样导致图像维度减小，而转置卷积可以让feature map的维度变大，从而恢复到原图的大小，从而实现像素级回归。但是这样得到的结果是很粗糙的，所以一般还通过跳跃连接将浅层的特征concat到upsampling之后的feature map中以实现精准定位。
但是，基于U-net模型的效果并不如我们预料的那般好：
主要是会出现诸如文字扭曲变形和行间扭曲错位这样的现象，严重的时候甚至可能出现图片撕裂现象：
为了对模型进行优化，我们需要定位问题出在哪里，因此，我们对模型的预测结果进行可视化，得到如下图：
可以发现，预测出来的标签和真实的标签虽然大体的趋势是差不多的，但都是以团状形式出现，无法像真实标签那样精确，即：分辨率不够或者说定位精度不够。因此，我们从三个角度进行模型的优化：
改变模型的结构：从U-net变成Stacked U-net，以提高分辨率
修改损失函数：使得模型在优化过程中让原本相邻的像素点之间的距离与预测结果差别不要太大，以改善文字扭曲变形的现象
对预测结果进行后处理，以改善噪点现象
下面，将详细介绍每个优化步骤。
4.2基于StackedU-net的扭曲文档矫正复原 （1）修改网络结构：U-net —&gt; Stacked U-net
stacked u-net网络结构如上所示，我们参考了论文中的Stacked结构，考虑到分辨率的问题并对其进行了改进，其堆叠了两个u-net，目的先利用第一个U-net得到一个粗粒度的预测结果，并可将其视为一种先验，而后再将预测结果和原始扭曲图concat后，再放入第二个U-net中进行实现，目的在于结合深层抽象低分辨率的特征和浅层原始高分辨率的特征，以实现细粒度的预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c944936082900ddb70be15b4cb734741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/012ac2927a4955c0796915e4fe0c88f1/" rel="bookmark">
			Swoole 源码分析——进程管理 Swoole_Process
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 swoole-1.7.2 增加了一个进程管理模块，用来替代 PHP 的 pcntl 扩展。
PHP自带的pcntl，存在很多不足，如
pcntl 没有提供进程间通信的功能 pcntl 不支持重定向标准输入和输出 pcntl 只提供了 fork 这样原始的接口，容易使用错误 swoole_process 提供了比 pcntl 更强大的功能，更易用的 API，使 PHP 在多进程编程方面更加轻松。 swoole_process::__construct 创建子进程 在进程初始化的时候，首先要判断当前的环境：
非 CLI 模式下不能使用在 server master 进程下并且已经启动了 server 后是不能创建进程的，因为此时 master 进程已经创建了 多个 reator 线程，fork 后会将多线程也复制下来。同样的道理，使用了异步的 AIO 的进程使用了线程池，fork 会出现非常复杂的带线程 fork 问题。 如果当前环境可以创建进程，那么需要初始化以下属性：
process-&gt;id：如果是普通的客户端进程，或者是 master 进程未启动 server 的状态， php_swoole_worker_round_id 就是创建的 process 进程数量，此时只需要递增即可；如果 server 已启动，那么 php_swoole_worker_round_id 还要加上所有 worker 进程的数量。 php_swoole_worker_round_id 递增就是 process-&gt;id。设置重定向，让进程的输入输出与主进程管道相关联 swPipeUnsock_create 函数新建管道 static PHP_METHOD(swoole_process, __construct) { zend_bool redirect_stdin_and_stdout = 0; long pipe_type = 2; zval *callback; //only cli env if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/012ac2927a4955c0796915e4fe0c88f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbfa1a1f7f2d6780423c6ce88396174/" rel="bookmark">
			锚点定位的三种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为在项目中遇到锚点定位的问题，觉得有必要单独成文，来介绍锚点定位的解决办法。
一 学习锚点定位之前的知识储备:
1.1 #号的作用
#代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print
就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。
为网页位置指定标识符，有两个方法:
一是使用锚点，比如&lt;a name="print"&gt;&lt;/a&gt;， 二是使用id属性，比如&lt;div id="print"&gt;。 HTTP请求不包括#.
2.2 a元素与URL对象
URL对象是浏览器的原生对象，可以用来构造、解析和编码 URL。一般情况下，通过window.URL可以拿到这个对象。
&lt;a&gt;元素和&lt;area&gt;元素都部署了这个接口。这就是说， 它们的 DOM 节点对象可以使用 URL 的实例属性和方法。 关于URL实例化对象的属性与方法请参考:
全文地址请点击：
https://blog.csdn.net/weixin_42839080/article/details/82714503?utm_source=copy
例如:我们利用a标签来获取一些东西
// &lt;a href="#box1"&gt;我跳到box1&lt;/a&gt; // 上面时html代码 var a = document.querySelector('a'); console.log(a.href); //返回整个 URL console.log(a.hash); //返回片段识别符，以井号#开头 console.log(a.hostname); //返回域名 console.log(a.search); //返回查询字符串，以问号?开头 二 锚点定位的介绍：
锚点其实就是可以让页面定位到某个位置上的点。在高度较高的页面中经常见到。
// 锚点跳转有两种形式： *1. a标签 + name / href 属性 *2. 使用标签的id属性 2.1 第一种锚点定位的方法:
&lt;a href="#box1"&gt;我跳到box1&lt;/a&gt; &lt;a href="#" name="#box2"&gt;我跳到box2&lt;/a&gt; &lt;div id="box1"&gt;&lt;/div&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fbfa1a1f7f2d6780423c6ce88396174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e7c04d93345490a7e7640d3e9c6475/" rel="bookmark">
			数据结构|一道还蛮有意思的链表题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在二刷数据结构，也偶尔去刷一下Leetcode上的算法题，不过感觉自己还是太菜了，一道题经常憋半个小时一个小时，有时候也有用例死活过不去的情况（手动狗头），还是要多学习多看书多刷题，有机会也会把自己的一些刷题心得放在上面。
前几天把以前做过的一些数据结构题又拿出来看了一下，有这么一道题：
/*键盘输入英语单词的个数n及n个单词，编一程序，建立一个单向链表，实现： （1）如果单词重复出现，则只在链表上保留一个。 （2）除满足（1）的要求外。链表结点还应有一个计数域，记录该单词重复出现的次数，然后输出出现次数最多的前k(k&lt;=n，需键盘输入)个单词。 注：次数并列的情况考虑、不考虑均可。*/ 思路还是比较清晰的，就是每出现一个新的单词，就在链表中生成一个新的结点，否则令其设置的计数域+1，对于（2）根据计数域对单词排序，输出前k个
这里贴出代码：
#include"stdio.h" #include"string.h" #include"stdlib.h" typedef struct LinkNode { char word[20]; struct LinkNode *next; int count; }LinkNode; /* *定义链表中的结点，包括单词，指针，与出现的次数count */ LinkNode *wordCheck(LinkNode *head, char word[]) { LinkNode *p; if(head==NULL) return NULL; p=head-&gt;next; while(p!=NULL) { if(strcmp(p-&gt;word, word)==0) return p; else p=p-&gt;next; } return NULL; } /* * 定义函数wordCheck，在当前链表查找有无重复单词，如果有重复则返回该单词的指针 * 如果没有重复返回NULL */ LinkNode *createLinkList() { int n; char word[20]; LinkNode *head; LinkNode *p1; LinkNode *p2; LinkNode *word_isnull; head=(LinkNode*)malloc(sizeof(LinkNode)); if(head==NULL) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e7c04d93345490a7e7640d3e9c6475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a07d5b83c6c20086fb7b98441d3342/" rel="bookmark">
			NOIP2006开心的金明（普及组T2）————动态规划，01背包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题解：本题主要考查动态规划，属于01背包。
代码如下：
#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int total,n,i; int dp[505000],m[550],y[550]; int main() { cin&gt;&gt;total&gt;&gt;n; for(i=1;i&lt;=n;i++) { cin&gt;&gt;m[i]&gt;&gt;y[i]; y[i]=y[i]*m[i]; } for(i=1;i&lt;=n;i++) for(int c=total;c&gt;=1;c--) { if(c&gt;=m[i]) { dp[c]=max(dp[c],dp[c-m[i]]+y[i]); } } cout&lt;&lt;dp[total]; return 0; } ps：NOIP2005采药（普及组T3）与NOIP2001装箱问题（普及组T4）与本题相似就不写了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd23170164f7f990e4af0c18d09ad20/" rel="bookmark">
			Angular——Module not found Error: Can&#39;t resolve..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 小编最近在进行一个angular项目的时候出师不利，碰到了一个这样的错误，让小编很是难受啊，下面就跟小编一起看看这个错误是什么吧
错误日志如下
错误大致内容是“无法找到这个模型，不能解析这个东西”
什么鬼？昨天还好好的，怎么今天就不行了？这一宿，他到底经历了什么？
算了，出错了，那就重装喽，按照以前的经验，出错重装一般是可以解决的，安装命令npm install bootstrap --save ，安装完，启动项目发现，并没有什么不同，哎呦，这是咋么了，竟然不好使了，没事，百度搜去。。
经过小编的两个多小时的搜索和尝试，发现并没有自己想要的理想的内容，而且都快不知道往哪方面找了，哇，难受啊，算了，还是找个前端玩的溜的来看看吧，海云兄（前端架构组的），就你了
还是人家专业啊，过来以后我把情况跟他说了一下，他看了几分钟，就开始倒腾，重装不好使，看相关引用等等，发现都没有问题，项目启动还是报错，然后你猜他干了啥，他把我的node库卸载了。。然后重装，命令如下
npm install rimraf -g //安装删除指令 rimraf node_modules //卸载node库 npm install //重装 重新启动项目，哎呦我去，好了，所以这次的解决方案就是重装node库了，问题是解决了，但是出错原因是什么呢？我问了问海云兄，他说你一开始用的是cnpm安装的，那个有时候会有问题，以后尽量用npm来安装吧。希望这个解决方案对你的项目也能起作用
总结 自己尝试解决问题是一个很棒的习惯，但是自己尽力了，找不到解决方案而且还没有头绪的时候，不放找个这方面了解比较多的人来咨询一下，兴许你扣了半天的问题，人家一眼就找到根源了，但是前提是你自己已经努力的寻找过解决方案了，在问问题的时候可以注意下自己的方式，自己的问题是什么，推测问题的原因是什么，自己做过哪些尝试，尝试的结果等等，这些东西有助于帮你解决问题的人更好的发现问题的原因，而且还可以节省双方的时间，最重要的是不至于讨人厌。（相对于出错了看都不看就喊人来帮忙来说的）
本篇博客到此结束，感谢您的阅读。希望对您有所帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b0c2b0a5edbc11ab8e04b46f62adeb/" rel="bookmark">
			java使用org.json解析josn字符串与json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备org.json.jar 一、最近做项目需要操作json，趁着这次机会就好好总结一下。本次使用的是org.json提供的jar包，下载地址为mvnrepository(jar包仓库，开发所需的jar包都可以在上面下载)。
二、在eclipse上导入外部jar文件，方法：选中项目右击 -&gt; Build Path -&gt; Configure Build Path -&gt; 选择Libraries -&gt; 点击Add JARs… -&gt; 选择下载的jar包，点击“OK”并应用
创建Json字符串与test.json文件 创建要操作的json字符串：
String jsonStr = "{\"name\":\"小明\",\"information\":{\"sex\":\"man\",\"hobby\":\"sing\"},\"pwd\":\"666\",\"parents\":[{\"father\":\"大明\",\"job\":\"farmer\"},{\"mother\":\"明\",\"job\":\"engineer\"}]}"; 创建test.json文件，文件内容为：
{ "name":"小红", "pwd":"123", "information":{ "sex":"woman", "hobby":"swim" },"parents":[ { "father:":"大红", "job":"coder" },{ "mother":"红", "job":"engineer" } ] } 正式解析 import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; import org.json.JSONArray; import org.json.JSONObject; import org.json.JSONTokener; public class Test { public static void main(String[] args) throws IOException { String jsonStr = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b0c2b0a5edbc11ab8e04b46f62adeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb0bf08b6aae9e51b4b4857b5124cb8/" rel="bookmark">
			hybrid技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hybrid是什么？hybrid译为中文是“混合”的意思，是一种原生APP和HTML5混合开发的技术。
在前端移动端开发中，到现在阶段主要有三大潮流
原生APP开发(以Android和iOS为主导)HTML5 webAPP开发原生APP和HTML5混合开发，也就是这里的hybrid技术 今天我们就来聊一聊hybrid技术
首先，为什么要有这个hybrid技术，当然是原生APP开发和web开发暴露出了问题。
对于原生APP开发，开发成本高，周期长，维护成本高，并且当今社会处于高速信息发展时期，产品必须快速迭代，而且原生的APP都需要经过应用商店审核才能够上线，那么这对于企业来说，尤其是创业公司来说是不可以接受的，时间代表着金钱。对于以HTML5主导的webAPP开发，优点就是开发成本低，可以快速迭代，但是缺点也是相当明显，每次切换一个页面都要发送一次http(https)请求，从系统架构软件质量属性的性能来说，它是不可接受的，用户体验及其不友好。于是乎，基于原生APP和前端页面的hybrid技术火了起来。 那么hybrid技术是如何工作的呢？ 首先，我们必须理解如下三个协议： file协议：用于打开本地文件，特点当然就是速度快。https协议：http+ssl协议，这个协议需要发送一次网络请求，当然相对于file协议就慢的很多了。schema协议：用于客户端和前端通讯的协议。微信部分schema协议如下(大家经常玩的朋友圈里面的链接打开的其实就是网页)：
其次，大家还要理解webview的概念。 那么什么是webview呢？其实就是一个用来存放文件的容器，我用下面图片的形式展示给大家：
红色框里的内容就是存放前端内容的容器，而红色框外面的为原生APP的东西。
好了，假如我在webview容器里直接通过file协议调用前端页面是不是比用HTML5发送HTTPS协议要快的多了呢。
那么接下来就是客户端如何和前端页面进行交互了，这就是前面的schema协议了。
这时候有的小伙伴可能就会问了，我用的hybrid技术开发的APP一天迭代一百次，怎么让用户同步更新呢？如下图所示：
我们可以用原生APP的API来发送一次网络请求来获取我们服务端页面的内容，这时小伙伴可能会有疑问了，你用HTML5不也是发送一次HTTPS请求吗，这样不也是很慢吗？NoNoNo，大家不要忘记JavaScript是一种解释型的语言，你请求来js文件之后还要解释执行。而你通过原生的APP可以在打开APP的同时就把服务器的页面请求过来然后再去执行本地js文件就OK了。
当然，这里的请求也是有技巧的，不是每一次打开APP都去服务端请求新的东西，只有服务端有新的东西变化时才去请求，这样又可以提高一部分效率了。
实现思路可以参考如下：只有用户版本号和服务器版本号不一致的时候才去请求。
好了，我简单的阐述完了混合APP内部是如何执行的以及原生APP和服务端之间的通信，估计也能够解决大家在打开原生APP发现切换页面的时候会有HTML5页面切换的疑问了。
当然hybrid技术也并不是完美的，就像“没有免费的午餐定理”一样，这个社会就是在矛盾中发展的，hybrid技术需要懂得原生APP开发、前端开发、后台开发才能进行完成，因此开发成本高、维护成本也高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972356d0de31ee998986a91b62322a00/" rel="bookmark">
			解决win10 nodejs环境 c&#43;&#43; 组件未能加载的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：win10 nodejs环境 c++ 组件未能加载的问题
查看链接：
https://cnodejs.org/topic/510a98acdf9e9fcc58ee157b
解决链接
https://github.com/nodejs/node-gyp/issues/307#issuecomment-240556824
解决代码：
以管理员身份运行cmd
npm install --global --production windows-build-tools 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9faf06259d60e27c9d3c0eb0740ddbb/" rel="bookmark">
			【vue】mac上 vue: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要进行环境变量配置
启动终端，可以在Spotlight中搜索“终端”
一.进入home目录
cd ～
二.更新.bash_profile文件
注意：有一种情况是.bash_profile不存在
需要先通过 touch .bash_profile创建一个 具体更新步骤：
(1)vim .bash_profile
通过vim编辑器编辑
(2)点击键盘上i，编辑
(3)在.bash_profile中添加
PATH=$PATH:/usr/local/mysql/bin:/usr/local/Cellar/node/10.3.0/bin/
export
注意上边红色的配置的地址在你建立工程之后就能看到，复制一下就可以 ，“：”表示地址的自增，相当往环境变量数组中不断添加元素，$PATH表示引用以前写过的地址
(4)按esc sheft + :,输入wq退出
三、运行刚刚修改的脚本
source .bash_profile
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2baf50af71e5aa832f3728b031dd8522/" rel="bookmark">
			codeforces 1051d D. Bicolorings  (dp)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接： http://codeforces.com/contest/1051/problem/D
思路： 因为每一行最多只有2个，所以我们可以用01 分别表示白黑，那么对于每一列 直接dp dp[ i ][ j ][ k ] 表示当前是第i 列，现在有j个联通分量，k标志最后一列的状态，只有4种 分别为 00 01 10 11
代码：
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll mod=998244353; int n,K; ll dp[1005][2005][4]; int main() { cin&gt;&gt;n&gt;&gt;K; dp[1][1][0]=1; dp[1][2][1]=1; dp[1][2][2]=1; dp[1][1][3]=1; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=2*n;j++){ for(int k=0;k&lt;=3;k++) dp[i][j][k]%=mod; dp[i+1][j][0]+=dp[i][j][0]; dp[i+1][j+1][1]+=dp[i][j][0]; dp[i+1][j+1][2]+=dp[i][j][0]; dp[i+1][j+1][3]+=dp[i][j][0]; dp[i+1][j][0]+=dp[i][j][1]; dp[i+1][j][1]+=dp[i][j][1]; dp[i+1][j+2][2]+=dp[i][j][1]; dp[i+1][j][3]+=dp[i][j][1]; dp[i+1][j][0]+=dp[i][j][2]; dp[i+1][j+2][1]+=dp[i][j][2]; dp[i+1][j][2]+=dp[i][j][2]; dp[i+1][j][3]+=dp[i][j][2]; dp[i+1][j+1][0]+=dp[i][j][3]; dp[i+1][j+1][1]+=dp[i][j][3]; dp[i+1][j+1][2]+=dp[i][j][3]; dp[i+1][j][3]+=dp[i][j][3]; } } ll ans=0; for(int i=0;i&lt;=3;i++){ ans+=dp[n][K][i]; ans%=mod; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2baf50af71e5aa832f3728b031dd8522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d3b591b77ba5c2559d37b79c450a09/" rel="bookmark">
			C#中如何把int转换成char（数字转换成字符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里讨论的是把数字1转换成字符 '1' ，而不是得到ASCII码为1的字符。
int num = 1;
char ch;
ch = char.Parse( num.ToString() );
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d266912d5b3825fd9335e91dcd7f6c1/" rel="bookmark">
			JAVA知识复盘004——构造方法能不能被重载，构造方法能不能被重写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在回答这两个问题之前，首先先回顾：什么是构造方法？构造方法的特点是什么？
概述：构造方法存在于类中，给对象数据（属性）初始化；
特点：方法名与类名一样；无返回值无void;
默认构造方法：我们不创建一个构造方法时，系统默认提供一个无参构造；当我们创建一个构造方法时，系统不再提供无参构造，所以在实际项目中，全部手动给出无参构造
其次什么是重载？什么是重写？ 重载：存在于在一个类中，方法名相同，方法参数的类型或个数不同
重写：存在于子父类中，方法名、方法参数、返回值全部相同
所以：构造方法可以重载，不能重写
在一个类中，可以有多个构造方法（方法参数不同） ，即重载，来实现对象属性不同的初始化；
但是子类中不能定义一个方法无void无返回值的方法，编译错误，即子类无法继承构造方法，但是子类的构造器中可以调用父类的构造方法（默认自动调用无参构造）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a013b63a3d057c4d0f2c5dc8b1d47a9/" rel="bookmark">
			form表单中的label标签的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 释义： label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。
如果你在 label标签内点击文本，就会触发此控件。
就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上
（就自动选中和该label标签相关连的表单控件上）
注意：标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。
语法： &lt;label for="控件id名称"&gt; 例子： &lt;form&gt; &lt;label for="male"&gt;男&lt;/label&gt; &lt;input type="radio" name="gender" id="male" /&gt; &lt;br /&gt; &lt;label for="female"&gt;女&lt;/label&gt; &lt;input type="radio" name="gender" id="female" /&gt; &lt;label for="email"&gt;输入你的邮箱地址&lt;/label&gt; &lt;input type="email" id="email" placeholder="Enter email"&gt; &lt;/form&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8462f90137bfeed6801eebb669aede7/" rel="bookmark">
			LeetCode38. 报数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报数序列是指一个整照其中的整数的顺序进数序列，按行报数，得到下一个数。其前五项如下：
1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作 "one 1" ("一个一") , 即 11。
11 被读作 "two 1s" ("两个一"）, 即 21。
21 被读作 "one 2", "one 1" （"一个二" , "一个一") , 即 1211。
给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
注意：整数顺序将表示为一个字符串。
示例 1:
输入: 1 输出: "1" 示例 2:
输入: 4 输出: "1211" 思路：
class Solution { public String countAndSay(int n) { if(n==1){ return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8462f90137bfeed6801eebb669aede7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437edfd2929a3e93e1b133caee52cda3/" rel="bookmark">
			用captcha.image下的 ImageCaptcha 生成字符验证码图片,只需三行代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用captcha.image下的 ImageCaptcha 生成字符验证码图片,只需三行代码
#导入captcha包下的image文件中的ImageCaptcha类,使用之前先实例化 from captcha.image import ImageCaptcha ic = ImageCaptcha() ic.write('1a8c', '1a8c' + '.png', format='png') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b47350701b06720efb345957b69c267/" rel="bookmark">
			centos7里面用docker-compose快速搭建php7&#43;nginx&#43;mysql5.7&#43;redis环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装docker及docker-compose centos7安装docker及docker-compose
2.docker-compose常用命令 # 在含有 docker-compose.yml 的文件夹下 构建容器 # 如有使用 Dockerfile 在修改 Dockerfile 文件之后再次执行如下即可应用修改 docker-compose up -d # 停止 docker-compose.yml 里面的所有容器 docker-compose stop # 删除 docker-compose.yml 里面的所有容器 docker-compose rm # 查看 docker-compose.yml 里面 nginx 的日志 docker-compose logs -f nginx # 重启 docker-compose.yml 里面的某一个容器 docker-compose restart nginx #### start 启动 stop 停止 ##### 3.docker-compose.yml文件内容 因为我宿主机上面已经安装 mysql redis php nginx 所以下面的端口都不是默认的端口
version : '2' services : mysql : build : ./mysql # 使用Dockerfile文件 ports : - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b47350701b06720efb345957b69c267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/105573c0108f7e6bc2dc070f1985aaea/" rel="bookmark">
			nvdla  vcs 编译出错 ld undefined reference to __cxa_throw_bad_array_new_length
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		__cxa_throw_bad_array_new_length was added in GCC 4.9. That's what the @CXXABI_1.3.8version suffix means. You can look up those version codes here:https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html
This error means that you are trying to link an object file /usr/lib64/vtk/libvtkCommonDataModel.so.1 compiled by GCC 4.9 or later with libstdc++.so or libsupc++.so from GCC 4.8 or earlier. Either rebuild libvtkCommonDataModel.so with GCC 4.8, or link against the correct libstdc++.so.
还是在一个神奇的网址 stackoverflow.com上找到答案：
意思是通过makefile生成的动态链接库 libnvdla_cmod.so使用gcc版本，和vcs编译其他的一些dpi c++程序使用的gcc版本不一致导致的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed037023f2d7acc888556cdac427bf4/" rel="bookmark">
			CMake使用总结，不断更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用C++11 CMake 3.1或者更高版本
set(CMAKE_CXX_STANDARD 11) 更低版本
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11") 生成可执行文件 set(SOURCE_FILES main.cpp xxx.cpp) add_executable(project_name ${SOURCE_FILES}) 这里的SOURCE_FILES是源文件列表
生成动态链接库 # 需要打入动态链接库的源文件 set(SOURCE_FILES_FOR_SHARED aaaa.cpp bbbb.cpp) # add_library(library-name SHARED ${SOURCE_FILES_FOR_SHARED}) 注意，在MacOS生成的是.dylib文件，在Linux上生成的是.so文件，在windows中是.dll
连接三方库 首先设置动态链接库的目录，以及头文件目录
set(INC_DIR include) set(LINK_DIR lib) 加入头文件目录、库所在目录、库名称
include_directories(${INC_DIR}) link_directories(${LINK_DIR}) link_libraries(library_name) 以上这两个应该在add_executable之前设置好
在add_executable之后，还需要在连接动态库
target_link_libraries(project_name library_name) 完成之后，cmake代码如下：
cmake_minimum_required(VERSION 3.6) project(project_name) set(CMAKE_CXX_STANDARD 11) set(SOURCE_FILES main.cpp) set(INC_DIR include) set(LINK_DIR lib) include_directories(${INC_DIR}) link_directories(${LINK_DIR}) link_libraries(library_name) add_executable(project_name ${SOURCE_FILES}) target_link_libraries(project_name library_name) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ff3f498abc0e7a19e1414d22ee9fe2/" rel="bookmark">
			Parse error: syntax error, unexpected &#39;&amp;&#39;解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用PHP5.4及以上版本时，在调用函数时，使用引用符号&amp;时，会出现Parse error: syntax error, unexpected '&amp;'或PHP Fatal error: Call-time pass-by-reference has been removed者，这是由于在函数调用时通过引用传递参数已被弃用，因为它影响了代码的整洁，如果函数的参数没有声明作为引用传递，那么它可以以无文档的方式修改它的参数。为了防止副作用，最好在函数声明中指定哪些参数是通过引用传递的。所以PHP核心配置allow_call_time_pass_reference在PHP5.4被移除，在调用的函数定义中参数为引用参数时，可直接通过传入参数，而不用通过引用符号“&amp;”加参数的方式。
比如一个函数定义在PHP5.4之前为foo($arg1,$arg2)，如果想要第二个参数在调用时进行引用传递，在调用时应为foo($v1,&amp;$v2)。而在PHP5.4之后想要进行引用传递，则需要在定义函数时指定哪个参数进行引用传递，如foo($arg1,&amp;$arg2)，而在调用时则直接进行调用即可：foo($v1,$v2)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f2eadbefc99fd430bf4f9c9c671e44/" rel="bookmark">
			java异步延迟任务执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天遇到一个奇怪的需求：需要在某个操作后，延迟10min执行另一个操作。
一 新建线程 首先想到的方法便是新建一个线程完成此操作：
输出
看起来这个操作没有问题 ，但是现在项目中就有问题了。
这是阿里代码检查工具的提示。
试想一下，每次进行这种操作便新建线程是不可取的，如果这个操作执行多次，便会创建大量线程，对虚拟机运行造成巨大的压力。
二 使用线程池 输出结果
在项目中当然也可以将线程池交给spring进行维护
三 spring线程池 接下来就是项目中注入并使用这个threadPool对象了
spring中还有一个ThreadTask，有时间的朋友可以去研究研究。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211840c9d2e13481d48ddab87dd93c40/" rel="bookmark">
			RedHat7.0 (Linux) 安装mysql（亲测，亚马逊）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载出处：https://blog.csdn.net/qq_32223565/article/details/79894037 RedHat7.0 (Linux) 安装mysql (mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar)
网上有很多资料关于安装的，但由于版本问题，困扰许久本文提供 readHat7.0及相应的mysql，可到相应的百度云盘下载https://pan.baidu.com/s/15dPTThydeJOLOreMWVeaCQ* 提取密码：34hr 安装步骤如下： 在 /home下新建 mysql目录。将 mysql压缩包传入到该文件下。可通过WinSCP 传入到该文件夹下(不再赘述)!
首先先查看是否已经安装了mysql ，执行命令 rpm -qa|grep mysql
如果什么都没显示说明没有安装过，如果已经安装了Mysql就先卸载执行命令 rpm -e –nodeps xxxxxxxx(xxxxxx为已经安装的rpm)
查看是否安装mariadb 系统自带的,之前安装的时候和mysql冲突，所有不用这个数据库的话也可以卸载,查看是否安装rpm -qa|grep mariadb,卸载执行rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64接下里进入 /home/mysql 命令：cd /home/mysql解压 tar tar -xf mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar演示图 解压之后又很多文件，我们只需要安装 命令如下：(因为包的依赖管理，注意要按上面的顺序执行) rpm -ivh mysql-community-common-5.7.10-1.el7.x86_64.rpm 安装到server包需要安装两个依赖包 yum install libaio，yum install perl，yum -y install numactl
….
修改mysql配置文件 sudo find / -name my.cnf 查找文件在什么位置
找到“[mysqld]”设置项，添加代码：
#开启查询缓存 explicit_defaults_for_timestamp=true 使用一个普通用户进行启动mysqld 。这个用户必须是属于mysqld用户组，且在my.cnf文件中。使用 vi /etc/my.cnf 加上user=mysql 进行指定mysql用户来启动mysql服务。这样是最好的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/211840c9d2e13481d48ddab87dd93c40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfc36eb676432442b29fe39eabd8453/" rel="bookmark">
			MacBook 快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。Command-A：全选各项。Command-F：查找文稿中的项目或打开“查找”窗口。Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。Command-O：打开所选项，或打开一个对话框以选择要打开的文件。Command-P：打印当前文稿。Command-S：存储当前文稿。Command-T：打开新标签页。Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。Option-Command-Esc：强制退出应用。Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。）Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。Control-Command-F：全屏使用应用（如果应用支持）。空格键：使用快速查看来预览所选项。Command-Tab：在打开的应用中切换到下一个最近使用的应用。Shift-Command-3：拍摄整个屏幕的屏幕快照。Shift-Command-N：在“访达”中创建一个新文件夹。Command-逗号 (,)：打开最前面的应用的偏好设置。 2，睡眠、退出登录和关机快捷键 在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样可以避免您无意中启用快捷键。
电源按钮或触控 ID 传感器：按下可打开 Mac 电源或将 Mac 从睡眠状态唤醒。当 Mac 处于唤醒状态时，按住这个按钮 1.5 秒钟会让 Mac 进入睡眠状态。继续按住则会强制您的 Mac 关机。Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。Control–电源按钮*或 Control–Media Eject（Control–介质推出键）：显示一个对话框，询问您是要重新启动、睡眠还是关机。Control–Command–电源按钮*：强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。Control–Command–Media Eject（Control–Command–介质推出键）：退出所有应用，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。Control–Option-Command–电源按钮*或 Control–Option–Command–Media Eject（Control–Option–Command–介质推出键）：退出所有应用，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 *不适用于带有触控栏的键盘。
3，访达和系统快捷键 Command-D：复制所选文件。Command-E：推出所选磁盘或宗卷。Command-F：在“访达”窗口中开始“聚焦”搜索。Command-I：显示所选文件的“显示简介”窗口。Shift-Command-C：打开“电脑”窗口。Shift-Command-D：打开“桌面”文件夹。Shift-Command-F：打开“我的所有文件”窗口。Shift-Command-G：打开“前往文件夹”窗口。Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。Shift-Command-I：打开 iCloud 云盘。Shift-Command-K：打开“网络”窗口。Option-Command-L：打开“下载”文件夹。Shift-Command-N：新建文件夹。Shift-Command-O：打开“文稿”文件夹。Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。Shift-Command-R：打开“隔空投送”窗口。Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本）Shift-Command-U：打开“实用工具”文件夹。Option-Command-D：显示或隐藏“程序坞”。Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。Option-Command-P：隐藏或显示“访达”窗口中的路径栏。Option-Command-S：隐藏或显示“访达”窗口中的边栏。Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。Command-J：显示“显示”选项。Command-K：打开“连接服务器”窗口。Command-L：为所选项制作替身。Command-N：打开一个新的“访达”窗口。Option-Command-N：新建智能文件夹。Command-R：显示所选替身的原始文件。Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。Command-Y：使用“快速查看”预览所选文件。Option-Command-Y：显示所选文件的快速查看幻灯片显示。Command-1：以图标方式显示“访达”窗口中的项目。Command-2：以列表方式显示“访达”窗口中的项目。Command-3：以分栏方式显示“访达”窗口中的项目。Command-4：以封面流方式显示“访达”窗口中的项目。Command–左中括号 ([)：前往上一文件夹。Command–右中括号 (])：前往下一个文件夹。Command–上箭头：打开包含当前文件夹的文件夹。Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。Command–下箭头：打开所选项。右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。Command-Delete：将所选项移到废纸篓。Shift-Command-Delete：清倒废纸篓。Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。Command–调高亮度：开启或关闭目标显示器模式。Command–调低亮度：当您的 Mac 连接到多台显示器时，开启或关闭视频镜像。Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。Option–“调度中心”：打开“调度中心”偏好设置。Command–“调度中心”：显示桌面。Control–下箭头：显示最前面的应用的所有窗口。Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。连按 Command 键：在单独的标签页或窗口中打开文件夹。按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。按住 Option-Command 键拖移：为拖移的项目制作替身。拖移项目时指针会随之变化。按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。了解如何使用 Command 或 Shift 在“访达”中选择多个项目。点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 4，文稿快捷键 这些快捷键的行为可能因您使用的应用而异。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfc36eb676432442b29fe39eabd8453/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9381a548760c80197a7871ad5bf50ce6/" rel="bookmark">
			Android跳转跳到打开百度地图、高德地图等第三方地图导航，最新最全2020
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现打开第三方的教程五花八门，遂记之 高德：打开高德地图API&gt;开发支持&gt;点击开发文档（居然可以点击...）&gt;高德地图手机版（在"其他"类下）&gt;左侧路径规划直达链接 简单举例：
Uri uri = Uri.parse("amapuri://route/plan/?dlat="+"目的地lat"+"&amp;dlon="+"目的地lng"+"&amp;dname="+"目的地名称"+"&amp;dev=0&amp;t=0"); Activity.startActivity(new Intent(Intent.ACTION_VIEW, uri)); 可以额外拼的参数：
百度：打开百度地图API&gt;开发文档&gt;地图调起API&gt;左侧接口说明&gt;Android端&gt; 2.3.2路线规划（约网页的1/3处）直达链接 简单举例：
Uri uri = Uri.parse("baidumap://map/direction?destination=latlng:"+"目的地lat"+","+ "目的地lng"+"|name:"+"目的地名称"+"&amp;mode=driving"); Activity.startActivity(new Intent(Intent.ACTION_VIEW, uri)); 可额外拼的参数：
如果想直接导航而不让用户选择（就是打开直接就“导航开始...”取消就退出的那种），请在直达链接里找到“导航”这一项，按照教程填写即可（感觉这种操作实在反人类，此处就不多说了）。
只能帮你们到这了
转载请注明出处：王能的博客https://blog.csdn.net/weimingjue/article/details/80493969
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40fa12cb92d6806c6aa1d4a56619177/" rel="bookmark">
			微信小程序：动画效果集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Life is like riding a bicycle.To keep your balance you must keep moving.
生活就像骑自行车。为了保持平衡，你必须不断前进。
微信小程序：心跳动画 https://blog.csdn.net/wtdask/article/details/82734944
文字跑马灯效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1038 触摸水波涟漪效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1350 下拉菜单效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1875 五星评分效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1876 数字累加，动态效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1694 星战字幕效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1689 动画卡片效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2193 列表项左滑删除效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2189（更多左滑删除效果请直接在论坛内搜索“左滑”即可） 图片的滤镜效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=3949 黑客帝国metrix效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4670 CSS3动画效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4628 仿直播点赞气泡效果：http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2833 文字弹幕效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4713 仿UC宣传页面的简单动画效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4266 发短信验证码倒计时： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1671 弹出菜单特效： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1659 滚动动画： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1538 实时圆形进度条： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1456 遮罩层： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=3617 仿Table效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1038 操作按钮悬浮固定在底部： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1029 支付倒计时效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=890 文字单行背景自适应带角标： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=636 侧边栏滑动特效 http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1202 顶部导航效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1665 弹出和隐藏动画： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1449 切换动画： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1113
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae32d87af9c593cb6bbc9515c465d7f/" rel="bookmark">
			严重: testWhileIdle is true, validationQuery not set   使用Druid连接池报错处理【无Spring框架，使用的JDK9，MYSQL8版本】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明；使用的JDK9， MYSQL8版本数据库，1.0.9Druid的jar包；
使用druid-1.0.9.jar ，报错如下；
这两行报错，是因为没有SpringBoot框架xml配置，在不使用框架的情况下；怎么解决呢；
①先解决第一行报错；严重: testWhileIdle is true, validationQuery not set 原来properties文件配置如下；
driverClassName = com.mysql.cj.jdbc.Driver url = jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;characterEncoding=utf-8&amp;useSSL=false username = root password = root 在properties配置文件下添加一些配置；
filters=stat initialSize=2 maxActive=300 maxWait=60000 timeBetweenEvictionRunsMillis=60000 minEvictableIdleTimeMillis=300000 validationQuery=SELECT 1 testWhileIdle=true testOnBorrow=false testOnReturn=false poolPreparedStatements=false maxPoolPreparedStatementPerConnectionSize=200 再次运行；
报错2；
信息: {dataSource-1} inited
这是日志信息，没有错Druid采用了日志打印机制，这不是报错；
连接池采用了懒加载，真正用到的时候才初始化；
附上一些名词解释；
validationQuery = "SELECT 1" 验证连接是否可用，使用的SQL语句
testWhileIdle = "true" 指明连接是否被空闲连接回收器(如果有)进行检验.如果检测失败,则连接将被从池中去除.
testOnBorrow = "false" 借出连接时不要测试，否则很影响性能
timeBetweenEvictionRunsMillis = "30000" 每30秒运行一次空闲连接回收器
minEvictableIdleTimeMillis = "1800000" 池中的连接空闲30分钟后被回收,默认值就是30分钟。
numTestsPerEvictionRun="3" 在每次空闲连接回收器线程(如果有)运行时检查的连接数量，默认值就是3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ae32d87af9c593cb6bbc9515c465d7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070674c790f0516db74634e61e99a999/" rel="bookmark">
			惯导SLAM中IMU预积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RGBD-SLAM受视野范围影响，双目SLAM结构较为复杂，还是看看单目SLAM吧，但是由于单目SLAM的深度不确定性，因此还是先研究下IMU．．．．．．
由于公式太多，还是直接给出网址大家去看原始文章吧．
这两篇博客写的很清楚
https://blog.csdn.net/wangshuailpp/article/details/80647621
https://blog.csdn.net/wangshuailpp/article/details/78461171
泡泡机器人上这四篇推导也很清楚
https://mp.weixin.qq.com/s?__biz=MzI5MTM1MTQwMw==&amp;mid=2247497730&amp;idx=1&amp;sn=424c1527065cc9cf0a79dc160b988ab3&amp;chksm=ec134606db64cf10a7b3e0672f4b8de6a3a4055cb21e3468d8a415134fed3d8595da2c330fd8&amp;mpshare=1&amp;scene=23&amp;srcid=0727D0CPZkL2oaQDh4upwu9B#rd
https://mp.weixin.qq.com/s?__biz=MzI5MTM1MTQwMw==&amp;mid=2247497758&amp;idx=1&amp;sn=3bf50d78c3a0b2490220553de4436e2c&amp;chksm=ec13461adb64cf0ceeb8c79a922799079a940ee8762f9047829576e4c717ea0fffd24a6e9d38&amp;mpshare=1&amp;scene=23&amp;srcid=0727RcCJzPyHivFkq8xlSqDI#rd
https://mp.weixin.qq.com/s?__biz=MzI5MTM1MTQwMw==&amp;mid=2247497777&amp;idx=1&amp;sn=0b2bc1bbe95d3a40b4f8cd2b403fbb8d&amp;chksm=ec134635db64cf23fcc2b8f13670a9b1c7081fa0d0c618a53aac0dcc4ab97092b2c459d40a10&amp;mpshare=1&amp;scene=23&amp;srcid=0727ofEY4AqrOCbZrbEYLnbk#rd
https://mp.weixin.qq.com/s?__biz=MzI5MTM1MTQwMw==&amp;mid=2247497852&amp;idx=1&amp;sn=984a7e422639e6ba818dfa97abcb5236&amp;chksm=ec134678db64cf6e516fc67a46cd0aeecf094d36ba1eb4a209c2f5bf2efc2cea86d101b187cd&amp;mpshare=1&amp;scene=23&amp;srcid=0730Jp7pvYQQgMKTdGOEgeQx#rd
一共四篇，讲的还是很不错的，推导很清楚．
还有知乎上一篇文章也不错
https://zhuanlan.zhihu.com/p/38009126
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd7b1942303e69b349676c77f9fcd91/" rel="bookmark">
			TensorFlow API之tf.estimator.Estimator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tfestimatorEstimator 属性方法 tf.estimator.Estimator Estimator class训练和测试TF模型。Estimator对象封装好通过model_fn指定的模型，给定输入和其它超参数，返回ops执行training, evaluation or prediction. 所有的输出(包含checkpoints, event files, etc.)被写入model_dir。
属性 config 传入 model_fn,如果 model_fn有参数named “config” model_dirmodel_fn The model_fn with following signature: def model_fn(features, labels, mode, config)params 方法 __init__ __init__( model_fn, model_dir=None, config=None, params=None # 将要传入model_fn的超参数字典 ) evaluate 对训练模型评价
evaluate( input_fn, # 输入函数，返回元组features和labels steps=None, hooks=None, # List of SessionRunHook subclass instances checkpoint_path=None, # if none, 用model_dir中latest checkpoint name=None ) export_savemodel 导出inference graph作为一个SavedModel export_savedmodel( export_dir_base, # 目录 serving_input_receiver_fn, # 返回ServingInputReceiver的函数 assets_extra=None, as_text=False, checkpoint_path=None ) get_variable_names
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fd7b1942303e69b349676c77f9fcd91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282e0db39aeb281c749ba66a051a2799/" rel="bookmark">
			java 时间戳和PHP时间戳 的转换 php time()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在弄discuz,数据库mysql,时间类型int 10
总结一下java 时间戳和PHP时间戳 的转换问题： 由于精度不同，导致长度不一致，直接转换错误。 JAVA时间戳长度是13位，如：1294890876859 PHP时间戳长度是10位， 如：1294890859 主要最后三位的不同，JAVA时间戳在PHP中使用，去掉后三位，如：1294890876859-&gt; 1294890876 结果:2011-01-13 11:54:36
echo date(‘Y-m-d H:i:s’,’1294890876’); 复制代码 PHP时间戳在JAVA中使用，最后加三位，用000补充,如：1294890859-&gt;1294890859000 结果:2011-01-13 11:54:19 SimpleDateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); String dateTime = df.format(1294890859000L); System.out.println(df); 复制代码 总结一下java时间戳和PHP时间戳 的转换问题： 由于精度不同，导致长度不一致，直接转换错误。 JAVA时间戳长度是13位，如：1294890876859 PHP时间戳长度是10位， 如：1294890859 主要最后三位的不同，JAVA时间戳在PHP中使用，去掉后三位，如：1294890876859-&gt; 1294890876 结果:2011-01-13 11:54:36 echo date(‘Y-m-d H:i:s’,’1294890876’); PHP时间戳在JAVA中使用，最后加三位，用000补充,如：1294890859-&gt;1294890859000 结果:2011-01-13 11:54:19 SimpleDateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); String dateTime = df.format(1294890859000L); System.out.println(df);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed10478f126902f7ffa8dfc5f399e9c1/" rel="bookmark">
			windows10, 自带的OpenSSH, key权限问题, 文件权限问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 windows10现在有了自带的openssh, 可以打开“设置-&gt;应用-&gt;管理可选功能”来安装或卸载 可执行文件的位置在“C:\Windows\System32\OpenSSH”
错误现象 用下面的命令远程登录时 ssh -p 22 -i D:\key.pem root@192.168.99.99 有可能会有下面的 key.pem 文件权限问题错误提示导致不能登录
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions for 'D:\\key.pem' are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Load key "D:\\key.pem": bad permissions root@192.168.99.99: Permission denied (publickey). 这时需要修改 key.pem 文件的权限
key.pem 文件权限的修改方法 右键key.pem-&gt;属性-&gt;安全-&gt;高级 1.把所有者改为当前用户(如果是当前用户就不用管了) 2.禁用继承-&gt;从此对象中删除所有已继承的权限 3.添加当前用户, 并设置访问类型为完全控制 最终的效果如截图 这样就可以正常远程登录了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed10478f126902f7ffa8dfc5f399e9c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0125ec498c207959bb708670f2856baf/" rel="bookmark">
			Python做一个最简单的推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过各自电影评分的情况，计算用户之间的相似度（欧氏距离、皮尔逊相似度）
#!/usr/bin/env python3 # -*- coding: utf-8 -*- ''' @Time : 2018/9/15 8:19 @Author : Negen @Site : @File : recommend.py @Software: PyCharm ''' from math import sqrt from colorama import Fore import numpy as np """ 建立影评评分字典 六种电影类型：a,b,c,d,e,f 七个用户：Cathy,Sophie,Susie,Antonio,Marco,Jack,Leo """ critics={'Cathy':{'a':2.5,'b':3.5,'c':3,'d':3.5,'e':2.5,'f':3}, 'Sophie':{'a':3,'b':3.5,'c':1.5,'d':5,'e':1.5,'f':3}, 'Susie':{'a':2.5,'b':3,'d':3.5,'f':4}, 'Antonio':{'b':3.5,'c':3,'d':4,'e':2.5,'f':4.5}, 'Marco':{'a':3,'b':4,'c':2,'d':3,'e':2,'f':3}, 'Jack':{'a':3,'b':4,'d':5,'e':3.5,'f':3}, 'Leo':{'b':4.5,'d':4,'e':1.0}} def sim_distance(prefs, person1, person2): """ 计算相似度（欧氏距离） :param prefs: :param person1: :param person2: :return: person1和person2的基于距离的相似度 """ si = {item : 1 for item in prefs[person1] if item in prefs[person2]} if len(si) == 0: return 0 sum_of_squares = sum([pow(prefs[person1][item] - prefs[person2][item], 2) for item in si]) # sum_of_squares= sum([pow(prefs[person1][item]-prefs[person2][item],2) # for item in prefs[person1] if item in prefs[person2]]) # print(sum_of_squares) return 1/(1+sqrt(sum_of_squares)) sim_dis = sim_distance(critics, 'Cathy', 'Antonio') #基于欧氏距离的相似度 print(Fore.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0125ec498c207959bb708670f2856baf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d482154f990bee8e48c9f5f1fc39fd/" rel="bookmark">
			better-scroll的中文文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		better-scroll的中文文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c49bec8f954bb975ba828b0cf1af1eb/" rel="bookmark">
			ORB-SLAM2中ROS&#43;RGBD运行实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近想实现基于ROS+RGBD相机的ORB-SLAM2,刚好手上有个kinect,虽然是V1版本的,不过有玩的就好了O_O
(1)在ubuntu上安装kinectV1相关驱动文,参考文章https://blog.csdn.net/Felaim/article/details/79579973
驱动安装成功之后就可以使用kinectV1了。
(2)ORB-SLAM2(ROS+RGBD)运行
首先成功编译ORB-SLAM2,网上很多教程,这里就不多说了给出一个比较完整的地址.
https://blog.csdn.net/qq184861643/article/details/53519714
运行可以采用两种方式
方式一: roscore roslaunch freenect_launch freenect-registered-xyzrgb.launch 备注:这条命令输入后可以打开终端使用命令 rqt 看到kinect相关图像(深度图和rgb图等) rosrun ORB_SLAM2 RGBD ~/catkin_ORB/src/ORB_SLAM2/Vocabulary/ORBvoc.bin ~/catkin_ORB/src/ORB_SLAM2/Examples/RGB-D/my.yaml 其中my.yaml 根据自己的kinectVI参数设置,博主直接使用传统的相机标定方法标定了一下,幸运的的是可以使用
方式二: roslaunch kinect_orbslam2.launch 其中kinect_orbslam的内容如下,红色部分是需要修改的路径.
&lt;launch&gt; &lt;param name="orb_use_viewer" value="false"/&gt; &lt;node pkg="ORB_SLAM2" type="RGBD" name="ORB_SLAM2" args="/home/hahaha/catkin_ORB/src/ORB_SLAM2/Vocabulary/ORBvoc.txt /home/hahaha/catkin_ORB/src/ORB_SLAM2/Examples/RGB-D/my.yaml" cwd="node" output="screen"/&gt; &lt;include file="$(find freenect_launch)/launch/freenect.launch"&gt; &lt;!-- use device registration --&gt; &lt;arg name="depth_registration" value="true" /&gt; &lt;arg name="rgb_processing" value="true" /&gt; &lt;arg name="ir_processing" value="false" /&gt; &lt;arg name="depth_processing" value="false" /&gt; &lt;arg name="depth_registered_processing" value="true" /&gt; &lt;arg name="disparity_processing" value="false" /&gt; &lt;arg name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c49bec8f954bb975ba828b0cf1af1eb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/280/">«</a>
	<span class="pagination__item pagination__item--current">281/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/282/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>