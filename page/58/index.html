<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62541d2716cae3e47b90af04bdd6a373/" rel="bookmark">
			STM32芯片烧录的三种方式介绍，串口、STM32 ST-LINK Utility以及STM32CubeProgrammer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32芯片烧录的三种方式介绍，串口、STM32 ST-LINK Utility以及STM32CubeProgrammer 1 概述1.1资源概述1.2 STM32串口烧录方式(ISP)-FLYMCU 2.KEIL软件下载介绍(内部集成STLINK)3 STM32 ST-LINK Utility介绍3.1 windows操作系统3.1.1 软件烧录3.1.2 stlink对芯片的部分Sector进行擦除 3.2 Linux操作系统中烧录（STLINK）3.2.1 软件安装3.2.2 命令行软件烧录（ST-FLASH）3.2.3 使用GUI界面进行烧录（STLINK）3.2.4 更多详细信息 4 STM32CubeProgrammer4.1 使用STLINK进行下载4.2 使用串口进行下载（ISP）4.3 使用DFU模式（USB） 5 官方正版STLINK仿真器5.1 STLINK V3 mini下载器5.2 集成在官方开发板上的STLINK 6 连接异常处理6.1 能连接但下载报错解决方案6.2 特殊IO口使用导致烧录一次程序后SWD口不能用6.3 能识别到芯片，但是下载时弹出报错对话框 1 概述 1.1资源概述 开发板：正点原子STM32F103 Nano开发板
STM32 ST-LINK Utility版本：V4.5.0.0
STM32CubeProgrammer版本：V2.4.0
MDK版本：V5.23
主控芯片型号：STM32F103RBT6
1.2 STM32串口烧录方式(ISP)-FLYMCU 启动模式说明说明，我们选择系统存储器启动。
内嵌的自举程序存放在系统存储区，由ST在生产线上写入，用于通过可用的串行接口对闪存存储器进行重新编程： ● 对于小容量、中容量和大容量的产品而言，可以通过USART1接口启用自举程序。串口烧录的原理就是利用这个自举程序读取串口的数据，对内部Flash进行擦写，实现程序的烧录。
使用串口进行烧录，上位机可采用FLYMCU，然后通过USB转串口线（或者板）给目标设备进行烧录。需要注意的是，如果是M3内核非互联网型的板子这里的串口必须是串口1，对应为GPIO9和GPIO10。如果是M4内核，可以是下述端口。
● USART1(PA9/PA10)
● USART3（PB10/11 和 PC10/11）
● CAN2(PB5/13)
● USB OTG FS(PA11/12) 从设备模式（DFU：器件固件升级）。
BOOT1设为0，BOOT0设为1，按复位键即可进入串口下载模式，打开FLYMCU软件，选择正确的串口，点击读器件信息，显示连接成功。
打开所需要下载的HEX文件，这里由于电路上没有自动复位进BOOT区的电路（正点原子部分高级一点的板子有），我们选择不使用RTS和DTR。点击开始编程。直至下载成功。
下载完成后，将BOOT0跳线跳到0，按一下Reset键，程序即可正常运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62541d2716cae3e47b90af04bdd6a373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a93c7e71a0a13b96ad190ff3f4ff38e/" rel="bookmark">
			【python函数】torch.nn.Embedding函数用法图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习SAM模型的时候，第一次看见了nn.Embedding函数，以前接触CV比较多，很少学习词嵌入方面的，找了一些资料一开始也不是很理解，多看了两遍后，突然顿悟，特此记录。
SAM中PromptEncoder中运用nn.Embedding：
point_embeddings = [nn.Embedding(1, embed_dim) for i in range(self.num_point_embeddings)] torch.nn.Embedding官方页面
1. torch.nn.Embedding介绍 （1）词嵌入简介 关于词嵌入，这篇文章讲的挺清楚的，相比于One-hot编码，Embedding方式更方便计算，例如在“就在江湖之上”整个词典中，要编码“江湖”两个字，One-hot编码需要 [ l e n g t h , w o r d _ c o u n t ] {[length, word\_count]} [length,word_count] 大小的张量，其中 w o r d _ c o u n t {word\_count} word_count 为词典中所有词的总数，而Embedding方式的嵌入维度 e m b e d d i n g _ d i m {embedding\_dim} embedding_dim 可远远小于 w o r d _ c o u n t {word\_count} word_count 。在运用Embedding方式编码的词典时，只需要词的索引，下图例子中： “江湖”——&gt;[2, 3]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a93c7e71a0a13b96ad190ff3f4ff38e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dbfe6b21c3732edfcd454b068a31567/" rel="bookmark">
			多分类的 准确率 召回率代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from sklearn.metrics import classification_report,confusion_matrix # 准确率 召回率 F1 每个类的数据量 precision_recall_report = classification_report( y_true=all_groundtruth_list, y_pred=all_predict_list, labels=list(range(0,len(all_label_list))), target_names=all_label_list) print(precision_recall_report) # 混淆矩阵 matrix = confusion_matrix( y_true=all_groundtruth_list, y_pred=all_predict_list, labels=list(range(0,len(all_label_list)))) print(matrix) 输出多分类中每一类的准确率（该类正确的数/该类总数），也可以直接调用包
from sklearn.metrics import confusion_matrix, f1_score, classification_report 其中多分类的pre和该类的准确率等价？ def getACC(Y_test,Y_pred,n): acc =[] con_mat = confusion_matrix(Y_test,Y_pred) for i in range(n): number = np.sum(con_mat[:,:]) tp = con_mat[i][i] fn = np.sum(con_mat[i,:])- tp fp = np.sum(con_mat[:,i])- tp tn = number - tp - fn - fp acc1 =(tp+tn)/(number) acc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dbfe6b21c3732edfcd454b068a31567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8871d6daada85483d7561a317eb723/" rel="bookmark">
			美团2024届秋招笔试第一场编程 【小美的树上染色】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 小美拿到了一棵树，每个节点有一个权值。初始每个节点都是白色。
小美有若干次操作，每次操作可以选择两个相邻的节点，如果它们都是白色且权值的乘积是完全平方数，小美就可以把这两个节点同时染红。
小美想知道，自己最多可以染红多少个节点？
开始看到这个题的时候，已经下意识认定这是一道树形DP，状态定义大概是f[i][0],f[i][1],分别表示
i节点是白色情况下，i子树内包含的红节点最大数；i节点是红色情况下，i子树内包含的红节点最大数。f[i][0]的求法还是比较好求的：假设i的儿子是j，则f[i][0]+=max(f[j][0],f[j][1])。但求f[i][1]的时候好像卡住的，有点想法，不知道对不对。 然后我把题给旁边一佬看了，结果令我没想到的是，他看到这个题，首先就是一种贪心（在输入的时候处理答案，对输入的俩个节点，如果它们权值相乘能凑成平方数就标记，也就是不建树)然后给我过了样例。当时听完之后，想了想【啊哈，这种题不建树是能写出来的吗，不过想了一些样例，好像确实是这样】。再想了几分钟之后，感觉不对啊，于是搞了个样例，它的解法是依赖输入的顺序的。【虽然他的解法有缺陷，但我发现我这固定思维是个很大缺点哪，一眼DP（虽然dp和贪心还是有很大关联)，根本没往其它方向想】 这让我有了个认识【哪怕你AC了一道题，也要有看题解或者别人代码的必要，可以发散思维】
之后结合他的想法，发现这个题确实可以不用dp，建树完之后从叶子节点一直往上贪心。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; typedef long long LL; const int N=1e5+10; vector&lt;int&gt;g[N]; int n; int st[N]; int ans; LL w[N]; bool fun(LL x) { LL d=sqrt(x); return d*d==x; } void dfs(int u,int fa) { for(auto x:g[u]){ if(x==fa)continue;//保证不往回走,确保时间复杂度O(N) dfs(x,u); if(fun(w[u]*w[x])&amp;&amp;(!st[x]&amp;&amp;!st[u])){ ans+=2; st[x]=1; st[u]=1; } } } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i]; for(int i=0;i&lt;n-1;i++){ int u,v; cin&gt;&gt;u&gt;&gt;v; g[u].push_back(v); g[v].push_back(u); } dfs(1,-1); cout&lt;&lt;ans&lt;&lt;endl; return 0; } 【很充实的一天，下午到晚上，听了一节3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da8871d6daada85483d7561a317eb723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f3c7464ec36dcb34c472ca62d1de07/" rel="bookmark">
			AD9833学习使用及程序代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：AD9833介绍与应用（C语言实现）_蜕变℡的博客-CSDN博客
程序对应模块：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14414e4fe0df482f7731052e883ab3e/" rel="bookmark">
			【C&#43;&#43; Exceptions】exception specifications的利与弊、非预期异常的预防与处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		exception specifications利与弊 漂亮的注释；编译器有时能在编译过程中，检测到与exception specifications不一致的行为，这时unexpected会默认调用terminate，terminate默认调用abort，程序被中止； 该情况极易发生：
编译器仅作局部检验，未检测到的是：
一个函数调用另外一个函数 ，后者可能违反调用端函数的exception specifications eg. extern void f1();	//可以抛出任何一种异常 void f2() throw(int);//只能抛出int类型异常 void f2() throw(int) { ... f1();	//即使f1可能抛出非int异常也合法 ... } 会造成“当一个较高层次的调用者已经准备好要处理发生的exception时，unexpected函数却被调用”的现象。 class Session { public: ~Session(); ... private: static void logDestruction(Session* objAddr) throw(); }; Session::~Session() { try{ logDestruction(this); } catch(...) { } } //假设logDestruction调用的函数抛出异常，而logDestruction没拦住 //当非预期异常传到logDestruction，unexpected函数被调用，程序终止 //Session析构函数的catch块尚未执行程序就已经中止了 //所以将logDestruction的exception specifications去掉 事先预防unexpected exceptions的方法 避免让模板和exception specifications放在“需要类型自变量”的模板身上，最好是不要让模板和异常规格混用；如果A函数内调用了B函数，而B函数无exception specifications，那么A函数本身也不要设定exception specifications（极易忽略的一种情况：允许用户注册回调函数的时候）；处理“系统”可能抛出的exception （最常见的就是bad_alloc，当内存分配失败的时候它被operator new和operator new[ ]抛出）。 直接处理unexpected exceptions的方法 C++允许以不同类型的异常替换非预期的异常；把非预期的异常转换成已知类型方法来替换unexpected，重新抛出当前异常，所有异常将被替换成bad_exception,这个异常替代原来的异常继续传递。 1. class UnexpectedException{};	//所有的非预期异常都被它取代 void covertUnexpected()	//如果一个非预期异常抛出，便调用此函数 { throw UnexpectedException(); } //并以covertUnexpected取代默认的unexpected函数 set_unexpected(covertUnexpected); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14414e4fe0df482f7731052e883ab3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9499759eee37c866beae226b4fa17d/" rel="bookmark">
			关于格式工厂转换成MP4报错问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格式工厂升级到5.15之后，如果转换MP4时调整了音量大小，就会报这个错：
Unrecognized option 'vol'. Error splitting the argument list: Option not found 通过查询报错信息可知出错的地方在于ffmpeg，再查了一下发现，这个问题出现在格式工厂5.14之后，也就是ffmpeg换成6.0的版本之后才出现的，由此可知，应该是ffmpeg6.0的问题。
于是果断找了个5.1.2的ffmpeg，问题果然解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b7236238c4d1e13a46c6b987723f5f/" rel="bookmark">
			vscode插件报错error while fetching extensions xhr failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载版本不对，不要下载user版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c50788c1e8dce4b9aec946b5bce919e/" rel="bookmark">
			拓竹科技跨境电商运营校招一面面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享下 拓竹科技 的面经，在 SSP面试笔记 网站看了很多面经，感谢前辈的分享：
1、自我介绍
2、英文能力如何
3、用英文介绍在校经历
4、介绍下上一段实习经历
5、你觉得国内和海外的电商有什么区别
6、你觉得店铺旗舰店的购物体验有什么优势
7、说说你的优缺点
8、你对我们公司的了解，对产品的了解
9、说说你觉得我们公司的产品有哪些缺点
10、职业规划
11、反问
作者：谷梁大山
内容来源：SSP面试笔记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c0fbb24d751191557ce440ba7d400e/" rel="bookmark">
			基于Java的超市商品管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术：Java等
摘要：
作为超市商品和货物的管理的重要控制部分，超市商品的管理系统影响着销售的本身的方便性及本地管理的规范性。随着信息时代的发展人们对效率的要求日益提高，软件控制管理已经取代了传统方式。超市商品管理该系统特点大致如下：商品要求种类全面，进出货操作关系简单，操作人数不多。从软件方面看，数据少，对存储以及交互速度要求不太高。因为员工较少，所以必须使用软件控制。
本项目基于JAVAEE，主要实现了用户管理、供应商管理、商品类别管理、商品管理、商品入库管理、商品出库管理、商品库存管理、销售报表统计等功能。使用工具有SQL Server 2000、Eclipse 等。
随着超市规模的发展在不断的扩大，不同商品的数量急剧在增加，超市的商品的各种信息量也随着成倍增长。超市的系统里面都需要对商品里面的全部的各种信息进行详细的统计分析。而大型的超市商品管理的系统其中功能过于强大反而就会造成操作繁琐降低了小型超市的工作效率。超市商品管理系统是目前的市场上最流行的超市里面采用的常用的系统之一，它主要包含以下几个模块：权限设定、原始数据录入、数据的汇总及查询等。从而就可以对实现对进货、库存、销售等实现体现了全面、动态、及时的管理。本文的系统分析了软件开发的背景以过程，首先介绍了软件的开发环境，其次介绍了本软件的详细设计过程，数据库的设计、各个模块的设计和实现，以及具体界面的设计和功能。
关键词：微型超市；商品管理
目录：
1 绪论 1
1.1 项目研究目的 1
1.2 项目研究意义 1
1.3 本课题在国内外的发展 2
1.4 目标 2
2 系统开发工具及技术介绍 4
2.1开发工具 4
2.2应用技术 4
2.2.1 SQL Server 2000 4
2.2.2 JavaEE技术 5
2.2.3 MVC设计模式 5
2.2.4 Struts2框架 7
3 系统需求分析 9
3.1 功能需求 9
3.2 项目运作可行性分析 10
3.2.1 技术可行性 10
3.2.2 经济可行性 10
3.2.3 操作可行性 10
3.3 项目优势 10
3.4 系统的设计思想 11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c0fbb24d751191557ce440ba7d400e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e3b3bc251cbce422a30968087e83197/" rel="bookmark">
			（附12306抢票脚本）国庆长假马上来啦，Python分析【去哪儿旅游攻略】数据，制作可视化图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言环境使用模块使用数据来源分析 代码实现导入模块请求数据解析保存 数据可视化导入模块、数据年份分布情况月份分布情况出行时间情况费用分布情况人员分布情况 前言 2023年的中秋节和国庆节即将来临，好消息是，它们将连休8天！这个长假为许多人提供了绝佳的休闲机会，让许多人都迫不及待地想要释放他们被压抑已久的旅游热情，所以很多朋友已经开始着手规划他们的旅游行程。
今天我们来分析下去哪儿的旅游攻略数据，看看吃、住、游玩在价位合适的情况下，怎样才能玩的开心
环境使用 Python 3.8
Pycharm
模块使用 requests
parsel
csv
数据来源分析 明确需求
这次选的月份为10 ~ 12月，游玩费用为1000 ~ 2999这个价位
抓包分析 按F12，打开开发者工具，点击搜索，输入你想要的数据
找到数据链接
https://travel.qunar.com/travelbook/list.htm?page=1&amp;order=hot_heat&amp;&amp;month=10_11_12&amp;avgPrice=2 代码实现 导入模块 import requests import parsel import csv 请求数据 模拟浏览器: &lt;可以直接复制&gt;
response.text 获取响应文本数据
response.json() 获取响应json数据
response.content 获取响应二进制数据
我们使用requests.get()方法向指定的URL发送GET请求，并获取到响应的内容
url = f'https://travel.qunar.com/travelbook/list.htm?page=1&amp;order=hot_heat&amp;&amp;month=10_11_12&amp;&amp;avgPrice=2' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36' } response = requests.get(url, headers=headers) 解析 先取响应文本数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e3b3bc251cbce422a30968087e83197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66efea838c4739e826a363971e00ec9e/" rel="bookmark">
			【Modbus通信实验一】查表法实现CRC16校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRC：Cyclic Redundant Check（循环冗余校验） 在数据链路层中，对于通信传输的差错检测一般有两种：使用纠错码（error-correcting code，又称前向纠错/FEC(Forward Error Correction )）或检错码，前者可用来检测哪些比特位有误，而后者只能用来检测传输的整体上是否出错，若出错则需请求重传。
典型的纠错码包括汉明码、二进制卷积码、里德所罗门码以及低密度奇偶校验码（LDPC）等等。而检错码的代表则有奇偶校验码、校验和（checksum）以及循环冗余校验。
循环冗余校验（CRC）是奇偶校验码的改进，又称为多项式编码，其原理为：发送方与接收方约定一个相同的多项式（POLY），如多项式x6+x4+x2+x+1对应的二进制码为1010111，然后将发送报文对改二进制码进行异或运算（即做除法），得到的余数则为CRC校验码，并附带在发送报文之后。接收方再将收到的报文对该二进制数进行异或运算，若没有余数（即能整除）则说明传输无误，否则需要重传。
CRC的多项式可以自由选择或者使用国际通行标准，一般按照多项式的阶数m，将CRC算法称为CRC-m，比如CRC-16、CRC-32，其中CRC-16被用于Modbus RTU通信协议中。
http://www.ip33.com/crc.html中可以计算包括Modbus在内的不同规则下的CRC校验码结果：
查表法计算CRC校验码 1.生成CRC16表 对于较长的报文，连续进行异或运算会消耗太多计算资源，特别是在性能受限的下位机上，因此计算CRC码一般不用直接计算法而是采用查表法。CRC16的表为0x00到0xff的256个整数，与多项式0x8005通过上述计算方式提前算好并生成，以便计算机在后续环节可以直接调用算好的数据，节省时间。
生成好的表如下：
const UINT16 auchCRC[256] = { 0x0000,0xC0C1,0xC181,0x0140,0xC301,0x03C0,0x0280,0xC241,0xC601,0x06C0,0x0780,0xC741,0x0500,0xC5C1,0xC481,0x0440,0xCC01,0x0CC0,0x0D80,0xCD41,0x0F00,0xCFC1,0xCE81,0x0E40,0x0A00,0xCAC1,0xCB81,0x0B40,0xC901,0x09C0,0x0880,0xC841,0xD801,0x18C0,0x1980,0xD941,0x1B00,0xDBC1,0xDA81,0x1A40,0x1E00,0xDEC1,0xDF81,0x1F40,0xDD01,0x1DC0,0x1C80,0xDC41,0x1400,0xD4C1,0xD581,0x1540,0xD701,0x17C0,0x1680,0xD641,0xD201,0x12C0,0x1380,0xD341,0x1100,0xD1C1,0xD081,0x1040,0xF001,0x30C0,0x3180,0xF141,0x3300,0xF3C1,0xF281,0x3240,0x3600,0xF6C1,0xF781,0x3740,0xF501,0x35C0,0x3480,0xF441,0x3C00,0xFCC1,0xFD81,0x3D40,0xFF01,0x3FC0,0x3E80,0xFE41,0xFA01,0x3AC0,0x3B80,0xFB41,0x3900,0xF9C1,0xF881,0x3840,0x2800,0xE8C1,0xE981,0x2940,0xEB01,0x2BC0,0x2A80,0xEA41,0xEE01,0x2EC0,0x2F80,0xEF41,0x2D00,0xEDC1,0xEC81,0x2C40,0xE401,0x24C0,0x2580,0xE541,0x2700,0xE7C1,0xE681,0x2640,0x2200,0xE2C1,0xE381,0x2340,0xE101,0x21C0,0x2080,0xE041,0xA001,0x60C0,0x6180,0xA141,0x6300,0xA3C1,0xA281,0x6240,0x6600,0xA6C1,0xA781,0x6740,0xA501,0x65C0,0x6480,0xA441,0x6C00,0xACC1,0xAD81,0x6D40,0xAF01,0x6FC0,0x6E80,0xAE41,0xAA01,0x6AC0,0x6B80,0xAB41,0x6900,0xA9C1,0xA881,0x6840,0x7800,0xB8C1,0xB981,0x7940,0xBB01,0x7BC0,0x7A80,0xBA41,0xBE01,0x7EC0,0x7F80,0xBF41,0x7D00,0xBDC1,0xBC81,0x7C40,0xB401,0x74C0,0x7580,0xB541,0x7700,0xB7C1,0xB681,0x7640,0x7200,0xB2C1,0xB381,0x7340,0xB101,0x71C0,0x7080,0xB041,0x5000,0x90C1,0x9181,0x5140,0x9301,0x53C0,0x5280,0x9241,0x9601,0x56C0,0x5780,0x9741,0x5500,0x95C1,0x9481,0x5440,0x9C01,0x5CC0,0x5D80,0x9D41,0x5F00,0x9FC1,0x9E81,0x5E40,0x5A00,0x9AC1,0x9B81,0x5B40,0x9901,0x59C0,0x5880,0x9841,0x8801,0x48C0,0x4980,0x8941,0x4B00,0x8BC1,0x8A81,0x4A40,0x4E00,0x8EC1,0x8F81,0x4F40,0x8D01,0x4DC0,0x4C80,0x8C41,0x4400,0x84C1,0x8581,0x4540,0x8701,0x47C0,0x4680,0x8641,0x8201,0x42C0,0x4380,0x8341,0x4100,0x81C1,0x8081,0x4040 }; 表的生成算法可以参考：https://blog.csdn.net/m0_57585228/article/details/125088520
代码：
#define POLY 0xA001 // 生成多项式Ox8005的反序，即1000000000000101→1010000000000001，即A001 unsigned short auchCRC[256]; // CRC表 void make_crc_table(void) // 生成CRC表的函数 { unsigned short c; int i, j; for (i = 0; i &lt; 256; i++) { c = i; for (j = 0; j &lt; 8; j++) { if (c &amp; 0x1) // 如果最低位为1，则右移一位并与生成多项式异或（商1） c = (c &gt;&gt; 1) ^ POLY; else // 如果最低位为0，则只右移一位，无需异或（商0） c = c &gt;&gt; 1; } auchCRC[i] = c; // 将计算出的CRC校验码存入表中 } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66efea838c4739e826a363971e00ec9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29048bce758e5970b16a5e414de6018/" rel="bookmark">
			（Go语言）使用两个协程按顺序交替打印 1 - n ,一个协程打印偶数，一个协程打印奇数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言使用两个协程按顺序交替打印 1 - n ,一个协程打印偶数，一个协程打印奇数 方法一：使用两个缓冲为1的channel + sync.WaitGroup 为什么需要使用有缓冲的channel？
因为如果不使用带缓冲的channel会导致死锁问题，死锁的原因是当其中一个协程打印结束后，即执行完以后，另外一个协程就不能在向channel写数据了，导致死锁。
例如：
n = 3时，
打印奇数的协程先打印1打印偶数的协程打印2，然后该协程执行完了打印奇数的协程打印3，然后再向channel写数据时
报错：fatal error: all goroutines are asleep - deadlock!
（对于无缓冲的通道，能够向通道写入数据的前提是必须有另外一个协程在读取通道） func printNumber(n int) { c1 := make(chan bool, 1) c2 := make(chan bool, 1) wg := sync.WaitGroup{} wg.Add(2) go func(n int) { defer wg.Done() for i := 2; i &lt;= n; i += 2 { &lt;-c1 fmt.Println(i) c2 &lt;- true } }(n) go func(n int) { defer wg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a29048bce758e5970b16a5e414de6018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa2396b4842a96a42daa47cf7020831/" rel="bookmark">
			嵌入式相机开发常见术语汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分辨率（Resolution）：分辨率指图像的像素数量，通常以宽度 x 高度的形式表示，例如1920x1080。更高的分辨率意味着图像具有更多的像素，可以呈现更多的细节和更高的图像质量。
帧率（Frame Rate）：帧率指每秒显示的图像帧数，以“帧/秒”（fps）为单位。较高的帧率可以实现更流畅的视频播放或动态图像捕捉。
码率（Bit Rate）：码率指每秒传输或存储的数据量，通常以“位/秒”（bps）为单位。对于视频，更高的码率意味着更高的数据量，可以实现更高质量的视频图像，但也需要更多的存储空间或带宽。
白平衡（White Balance）：白平衡是调整图像中的色彩平衡，以使白色在各种光源下看起来真实且中性。白平衡可以根据光源类型自动调整，也可以手动设置。
色温（Color Temperature）：色温是用来描述光源色彩品质的物理量，通常以单位开尔文（Kelvin，K）表示。较低的色温（如2700K）表示暖色调（如黄色），而较高的色温（如6500K）表示冷色调（如蓝色）。调整色温可以改变图像的整体色彩效果。
色调（Hue）：色调指的是颜色的基本属性，用于描述颜色在色轮上的位置。调整色调可以改变图像的整体色彩偏向，例如将图像偏向红色或蓝色。
EV（Exposure Value）：EV是一个用于衡量曝光量的指标，代表了相机所接收到的光线的数量。较高的EV值表示相机所接收到的光线更多，图像更亮，而较低的EV值表示相机所接收到的光线较少，图像较暗。通过调整曝光值（如快门速度、光圈大小、增益等），可以改变图像的亮度和曝光效果。
快门（Shutter Speed）：快门速度指相机的曝光时间，即相机的快门打开的时间长度。较快的快门速度可以冻结快速运动的物体，而较慢的快门速度可以捕捉到更多的光线和运动模糊效果。
ISO：ISO是表示图像传感器感光度的参数，通常以ISO数字表示。较低的ISO值（如ISO 100）表示较低的感光度，适用于明亮的场景，而较高的ISO值（如ISO 1600）表示较高的感光度，适用于暗光环境。提高ISO值可以增加图像的亮度，但同时也会增加图像噪点的产生。
传感器（Sensor）：传感器是嵌入式相机的核心组件，用于将光线转换为电信号。常见的传感器类型包括CMOS（Complementary Metal-Oxide-Semiconductor）和CCD（Charge-Coupled Device）。
图像处理（Image Processing）：图像处理涉及对捕捉到的图像进行处理和增强，例如去噪、锐化、色彩校正等。图像处理可以通过软件算法或硬件加速器来实现。
HDR（High Dynamic Range）：高动态范围图像是通过在不同曝光条件下拍摄多张图像，并将它们合并成一张图像来捕捉较宽动态范围的场景。HDR图像具有更丰富的细节和更广阔的亮度范围。
ISP（Image Signal Processor）：图像信号处理器是一种专用芯片或模块，用于对传感器输出的图像信号进行处理，例如去噪、锐化、色彩校正、白平衡等。ISP在嵌入式相机中起着重要的作用。
RAW格式（RAW Format）：RAW格式是一种未经压缩和处理的图像文件格式，直接保存传感器捕捉到的原始图像数据。它提供更高的图像质量和灵活性，但文件大小更大。
编解码器（Codec）：编解码器用于对图像和视频进行压缩和解压缩。常见的编解码器包括JPEG、H.264、H.265等。
图像传输接口（Image Interface）：用于将图像数据传输到其他设备或存储介质的接口，常见的图像传输接口包括MIPI CSI（Mobile Industry Processor Interface Camera Serial Interface）和USB（Universal Serial Bus）。
图像格式（Image Format）：图像格式指定图像数据的排列方式和编码方式。常见的图像格式包括RGB（Red Green Blue）、YUV（Luminance and Chrominance）、Bayer等。
自动对焦（Auto Focus）：自动对焦是相机功能之一，通过调整镜头的焦距来实现图像的清晰度和锐度。自动对焦算法可以根据场景中的对焦目标自动调整焦距。
图像稳定（Image Stabilization）：图像稳定技术用于抵消相机晃动或运动造成的图像模糊。常见的图像稳定技术包括光学防抖（Optical Image Stabilization）和电子防抖（Electronic Image Stabilization）。
视频流（Video Stream）：视频流是一系列连续的图像帧组成的视频数据流。视频流可以通过视频编码器进行压缩，并通过网络传输或存储在设备中。
鱼眼校正（Fisheye Correction）：鱼眼校正是一种图像处理技术，用于去除鱼眼镜头产生的畸变，使图像更符合真实场景的视觉效果。
实时操作系统（Real-Time Operating System，RTOS）：实时操作系统是一种专门设计用于嵌入式系统的操作系统，具有实时性和可预测性，常用于处理实时任务和控制系统。
"三A"（3A）在嵌入式相机领域指的是自动对焦（Auto Focus）、自动曝光（Auto Exposure）和自动白平衡（Auto White Balance）。这是相机系统中的三个重要功能，用于实现图像的清晰对焦、正确曝光和准确的色彩平衡。自动对焦（Auto Focus）：自动对焦是相机根据被摄物体距离的远近自动调节镜头焦距，以获得清晰的图像。相机通常使用对焦传感器或对比度检测等技术来确定焦点位置，并自动调整镜头以实现清晰对焦。自动对焦功能使得拍摄者无需手动调节对焦，更方便地获得清晰的图像。自动曝光（Auto Exposure）：自动曝光是相机根据当前环境光线的亮度自动调节曝光参数，以获得适当的图像亮度和对比度。相机通过测量光线水平来确定最佳曝光值，以避免图像过曝（过亮）或欠曝（过暗）。自动曝光功能使得相机能够根据环境条件自动调整曝光，以获得最佳的图像质量。自动白平衡（Auto White Balance）：自动白平衡是相机根据当前环境的光照条件自动调整图像的色温，以使得图像中的白色物体看起来真实无色偏。相机通过测量场景中的光源颜色温度，并调整图像的色彩平衡来消除色偏。自动白平衡功能使得相机能够在不同的光照条件下自动调整色彩，以保持图像的自然和真实性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3240e8851aed6b52a517f41513a001/" rel="bookmark">
			java实现的树形结构工具类TreeUtil
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Comparator; import java.util.List; import java.util.Map; import java.util.Objects; import java.util.stream.Collectors; /** * @author xiaozhongyu * @description 树形结构工具 * @createTime 2023年09月19日 15:57:00 */ public class TreeUtil { public abstract static class ITree&lt;ID&gt; { /** * id */ protected ID id; /** * 父Id */ protected ID parentId; /** * 排序字段（默认从小到大排序） */ protected Integer sort = 0; /** * 所有的子集列表 */ protected List&lt;ITree&lt;ID&gt;&gt; children; public ID getId() { return id; } public void setId(ID id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc3240e8851aed6b52a517f41513a001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbdc419268c30953fb3ae10313beeddd/" rel="bookmark">
			离线安装mysql5.7(shell脚本自动安装2022-02-06更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：有时候自己搭建集群或者测试MySQL的时候，需要经常安装MySQL，之前写过离线的安装文档，但还是感觉不太方便，每次都会花费很长时间，现在改成shell脚本自动安装MySQL，直接配置好新密码和远程访问，整个过程只需要几分钟就搞定 MySQL的相关依赖包： 百度网盘中也上传了安装包，可以直接提取 2022-02-06添加
链接：https://pan.baidu.com/s/1XhrxmldLGrW9xCVRYlrUEA?pwd=ye4f
提取码：ye4f
在我的CSDN上下载也可以：
https://download.csdn.net/download/qq_38220334/79442586?spm=1001.2014.3001.5501
这些是MySQL的相关依赖包 shell脚本介绍： 1.建立临时文件夹
2.解压zip文件
3.删除centos7自带的MySQL
4.按顺序安装MySQL相关的依赖包
5.修改MySQL的密码（自己用的话可以设置简单的密码，生产上用建议用复杂密码）
6.配置MySQL可以被远程访问（实际开发中也是，有些机器需要有访问这个机器MySQL的权限）
#!/bin/bash #第一步、创建一个临时的文件夹 mkdir mysql_soft #第二步、把新上传的MySQL的安装包移动到mysql_soft下 mv mysql57.zip mysql_soft #进入到mysql_soft目录下，开始执行下面的操作 cd mysql_soft #解压MySQL的安装包，在当前目录下 unzip mysql57.zip #查看集群上现有的MySQL，需要删除掉 mysql_old=`rpm -qa | grep mariadb` echo -e "当前centos中MySQL版本是： ${mysql_old}" #删除自带的MySQL rpm -e --nodeps ${mysql_old} #验证旧版本的MySQL是否被删除掉 mysql_validate=`rpm -qa | grep mariadb` echo -e "验证旧版的MySQL是否被删除干净： ${mysql_validate}" #开始安装MySQL，注意：这些包安装是有顺序的 rpm -ivh libaio-0.3.109-13.el7.x86_64.rpm #判断安装的过程是否成功 if [ $? == 0 ];then echo -e "安装------libaio-0.3.109-13.el7.x86_64.rpm -- 第1个包------- 成功"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbdc419268c30953fb3ae10313beeddd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787ccef650887fb0c0f1949599b75829/" rel="bookmark">
			Linux中软连接详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux中软连接详解 软连接是linux中一个常用命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。换句话说，也可以理解成Windows中的快捷方式。
linux创建软连接命令： ln -s target source target：是真实文件夹，即源文件，通过软链接访问之后真正到达的目录 source：表示当前目录的软链接名称，即被创建出来的软连接名称以及放置在何处。 例如：ln -s /data/xxx/dir1 /data/xxx/dir2
dir1是真实的文件夹，dir2是dir1的软链接。
软链接可以理解为，dir2是dir1的快捷方式，进入了dir2，就会自动进入dir1。
软链接的删除
rm -rf dir2/ 会删除文件夹下的所有内容，但是没有删除这个链接； rm -rf dir2 则是仅删除这个软链接，不会删除下面的内容。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3aaae89acea3a6cae41a12acf428f7/" rel="bookmark">
			mac电脑部署安装powershell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署安装powershell 要在mac部署安装powershell，可以使用homebrew来进行部署安装，故其步骤如下：
安装homebrew /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 利用brew部署安装powershell brew install --cask powershell
验证powershell是否安装成功 pwsh
卸载powershell brew uninstall --cask powershell
参考资料 Installing PowerShell on macOS - PowerShell | Microsoft Learn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92288c5d6c361e58e54d5997bcec7bbb/" rel="bookmark">
			Linux文件出现“M-oM-；M-?” ^M 等情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、当在编辑linux系统的文件时，会出现如下情况： 解决方法：单个文件可以使用vim 进行修改，shift + :， 然后 set nobomb
2、当文件出现每一行末尾^M的情况： 解决方法：使用vi的替换功能。启动vi，进入命令模式 shift + :，输入以下命令:
去掉行尾的^M %s/^M$//g 去掉所有的^M %s/^M//g 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553bc4b2c685877b976f3ef41c79afa4/" rel="bookmark">
			gdb调试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以gdb.c为例子
1.编译需要带-g
gcc gdb.c -o gdb -g
2.进入与退出
进入（前面的gdb是命令，后面的gdb是gdb程序）
gdb gdb
退出
quit
3.运行和逐步，逐过程
run 运行
step 逐语句 （进入命令函数内部运行）
next 逐过程 （直接运行该命令）
until n 运行至函数指定行
4.list + N 从n为中间开始显示10行代码
5.打断点
b N 某一行上打断点
b FuncName 函数起始打断点
info b 显示所有断电信息
d N 删除第n处断点
enable b N 启动第N处断点
disable b N 禁止第N处断点
6.
finish 结束
continue 运行到下一个断点
bt 查看堆栈情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bb86a820d6fbff7dc75eb8067de8423/" rel="bookmark">
			Lc.exe已退出代码为-1问题解决⽅法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c.exe已退出代码为-1问题解决⽅法
对于⽤vs作为开发⼯具的同学来说，可能常常会碰到“Lc.exe已退出代码为-1”的问题，造成这个结果的⼀般是因为加⼊了第三⽅的插件程序造成的，今天记录下如何解决。
在多⼈进⾏程序开发的过程中，可能由于版本问题，会导致“Lc.exe已退出代码为-1”问题的出现。
解决⽅法1：（针对项⽬中有licenses.licx⽂件）
查看加载的程序项⽬，找到Properties⽂件夹licenses.licx⽂件，然后右键选择删除就可以了，调试运⾏正常了。
解决⽅法2：（针对项⽬中没有licenses.licx⽂件）
打开你的项⽬的根⽬录，不知道在哪⾥的话，可以选择右键打开，
找到你系统的*.csproj⽂件，这个⽂件是加载项⽬⽂件。
可以使⽤⽂本编辑器打开上述⽂件，也可以使⽤其它的编辑器，在⽂件中查找licenses.licx字样，删除对应节点。
重新运⾏⼀下程序，⼀切正常了。
解决⽅法3：上述⽅法不能够解决时
⼀般就是Properties⽂件夹下已经没有licenses.licx⽂件了，程序还是报这个错，这个时候你只需要重命名⼀个空的txt⽂件为
licenses.licx再放⼊Properties⽂件夹，问题也可解决。
————————————————
版权声明：本文为CSDN博主「candydxj」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/candydxj/article/details/126939436
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a555c02cf83bab060bfa09d06ab2a9e2/" rel="bookmark">
			亚马逊有多个店铺的卖家，一定要注意这个问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亚马逊开多个店铺的时候，记得要注意店铺关联问题。
在防关联方面，卖家们可以寻求专业工具的帮助，比如使用指纹浏览器。
指纹浏览器可以模拟不同的浏览环境，从而防止亚马逊通过浏览器指纹识别出账号关联。云登浏览器就是可实现账号防关联的指纹浏览器。
云登浏览器（点击注册）
云登浏览器可以让你在同一台电脑上同时打开多个浏览器窗口，每个窗口都可以设置独立的指纹环境，cookie，本地存储、其他缓存和 IP 地址，从而避免账号之间的关联风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8cc9981da8879331c56f580665f9de4/" rel="bookmark">
			vite项目配置postcss-plugin-px2rem、lib-flexible postcss-pxtorem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 postcss-pxtorem//不支持 使用postcss-plugin-px2rem //项目版本 "postcss-plugin-px2rem": "^0.8.1", "vue": "^3.3.4", "vite": "^4.4.5" //vite.config.js import postcssPluginPx2rem from "postcss-plugin-px2rem"; //引入插件 //配置参数 const px2remOptions = { rootValue: 192, //换算基数， 默认100 ,也就是1440px ，这样的话把根标签的字体规定为1rem为50px,这样就可以从设计稿上量出多少个px直接在代码中写多少px了 unitPrecision: 5, //允许REM单位增长到的十进制数字，其实就是精度控制 // propWhiteList: [], // 默认值是一个空数组，这意味着禁用白名单并启用所有属性。 // propBlackList: [], // 黑名单 // exclude:false, //默认false，可以（reg）利用正则表达式排除某些文件夹的方法，例如/(node_module)/ 。如果想把前端UI框架内的px也转换成rem，请把此属性设为默认值 // selectorBlackList: [], //要忽略并保留为px的选择器 // ignoreIdentifier: false, //（boolean/string）忽略单个属性的方法，启用ignoreidentifier后，replace将自动设置为true。 // replace: true, // （布尔值）替换包含REM的规则，而不是添加回退。 mediaQuery: false, //（布尔值）允许在媒体查询中转换px minPixelValue: 0 //设置要替换的最小像素值(3px会被转rem)。 默认 0 } //css预处理中引入 注意层级 export default defineConfig({ plugins：[], resolve:{}, server:{}, css: { postcss: { plugins: [postcssPluginPx2rem(px2remOptions)] } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50c19d02e171c2228ebfe7661a91ab6a/" rel="bookmark">
			《Python趣味工具》——自制emoji3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日目标
在上次，我们绘制了静态的emoji图。并且总结了turtle中的常用函数。
本次我们将尝试制作一个动态的emoji，让你的表情包动起来！
文章目录 一、动画原理：二、制作动画：1. 修改eyes_black()函数：2. 绘制表情包文字：3. 定义emoji函数（汇合所有函数）：4. 动画切换：`update()``tracer(0)` 三、完整源码：四、拓展讲解：1. Python模块的安装：2. turtle模块和函数的用法总结：模块的导入方法：turtle的角度： 一、动画原理： 动画的原理简单来说就是一张张图片快速切换而成。
要在turtle中实现动画的效果，同样可以通过图片快速切换的方式来实现。
二、制作动画： 那怎么制作动画呢？我们通过对比观察两张图片，发现唯一的不同点是黑眼珠的位置不同。
而修改眼珠的位置，只需要修改绘制时移动的步数就可以了，然后不断的动可以看作循环打印，即循环调用绘制函数就好啦！
下面我们来对原来的函数进行一定的修改：
1. 修改eyes_black()函数： 我们上次已经绘制好了一侧的眼球：详见《Python趣味工具》——自制emoji2
而我们在绘制另一侧眼珠时，只需要修改移动步数——也就是将forward(6)，改为forward(60)即可。（这里具体的移动大小可以自己预先算出来，包括后面的每一步都一样）
下面我们修改eyes_black()函数，为它设置一个参数x，代表移动的步数。
# TODO 定义一个eyes_black()函数绘制黑眼珠，参数为x def eyes_black(x): # 使用seth()函数将角度设置为0 seth(0) # 使用forward()函数前进x步 forward(x) # 使用pendown()函数落笔 pendown() # 使用pensize()函数设置画笔粗细为15 pensize(15) # 使用pencolor()函数设置画笔颜色为"black" pencolor("black") # 使用circle()函数绘制一个半径为5，圆心角为360度 circle(5,360) # 使用penup()函数抬笔 penup() # 使用forward()函数前进110步 forward(110) # 使用pendown()函数落笔 pendown() # 使用circle()函数绘制一个半径为5的圆 circle(5,360) # 使用hideturtle()函数隐藏画笔 hideturtle() 2. 绘制表情包文字： 接下来我们需要制作表情包文字。
步骤如下：
用input函数邀请用户输入自定义文字内容。定义一个write_emoji()函数书写文字内容。
具体怎么输出文字我们在《Python趣味工具》——自制emoji（1）绘制爱心应援牌❤️里已经讲过了，大家可以自行参考。
# 使用input()函数引导用户输入表情包语录 # 文案内容为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50c19d02e171c2228ebfe7661a91ab6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43eaef6b754b160c434363584dfcfd92/" rel="bookmark">
			解决报错：npm ERR! code 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是 npm install --legacy-peer-deps 成功了
解决方案：
升级swiper库：你可以尝试升级你的项目中的swiper库到5.2.0或更高版本，以满足vue-awesome-swiper的需求。你可以使用以下命令来进行升级：
npm install swiper@latest 注意，这可能会带来一些新的问题，因为swiper的新版本可能包含一些不兼容的改动。
2. 使用 --force 或 --legacy-peer-deps 标志：你可以尝试使用以下命令来强制npm接受这个不正确的依赖关系：
npm install --force 或者
npm install --legacy-peer-deps 但是请注意，这可能会导致你的项目在运行时出现错误，因为依赖关系并没有实际解决。
3. 检查其他依赖项：如果上述方法都不能解决问题，你可能需要检查你的项目中的其他依赖项，看看是否有其他的版本冲突。你可以使用以下命令来查看你的项目的依赖树：
npm ls 这将显示你的项目及其所有依赖项的完整列表。在这个列表中，你可以查找是否有其他的版本冲突。
报错内容：
npm ERR! code 1
npm ERR! path D:\1taichu\1-project\yunnan\yunnan-yzm\node_modules\node-sass
npm ERR! command failed
npm ERR! command C:\WINDOWS\system32\cmd.exe /d /s /c node scripts/build.js
npm ERR! Building: D:\3node\node.exe D:\1taichu\1-project\yunnan\yunnan-yzm\node_modules\node-gyp\bin\node-gyp.js rebuild --verbose --libsass_ext= --libsass_cflags= --libsass_ldflags= --libsass_library=
npm ERR! gyp info it worked if it ends with ok
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43eaef6b754b160c434363584dfcfd92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35845fab16dbaf2d0f89df257ad07808/" rel="bookmark">
			JUC（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JUC JUC是java.util.conccurent包的简称，juc提供了很多关于线程安全的集合实现，以及各种锁的实现。
juc视频教程
二、多线程相关知识 1.并发 同一台处理器上 “同时” 处理多个任务，为什么同时需要打引号呢？因为实际上同一时刻实际上只有一个事件在发生。处理器是通过不断切换占用cpu时间片的任务来实现同时处理多个任务的。
2.并行 多台处理器同时处理多个任务，同一时刻，每个处理器都在处理不同的任务。
3.进程 是并发执行的程序在执行过程中系统分配和管理资源的基本单位
4.线程 包含在进程中，是cpu调用的最小单元，也称轻量级进程
5.管程 实际上指的是锁（monitor），管程只会允许一个线程进入去获取共享资源
6.进程VS线程 内存空间及系统资源
进程之间拥有独立的空间、系统资源，同一个进程中的线程则是共享进程的内存空间、系统资源健壮性
一个进程崩溃之后不会影响其它进程，同一个进程中的线程崩溃后会导致进程中的其它线程受到影响。 7.用户线程 一般情况下不做特殊说明，线程默认都是用户线程
8.守护线程 守护线程是一个服务线程，他服务于用户线程，如果用户线程结束了，守护线程也就结束了。
在java中，jvm的gc垃圾回收线程就是守护线程，当主线城结束后，垃圾回收线程也会结束。
下面用一个例子来演示守护线程：
创建一个线程类，在其中执行打印操作1-100
/** * @author Watching * * @date 2023/4/29 * * Describe: */ public class MyThread extends Thread{ @Override public void run() { for(int i = 1;i&lt;= 100;i++){ System.out.println(getName()+" helloWord " + i); } } } main方法，创建两个线程，一个女神线程，一个舔狗线程，女神先开始打印，1s后舔狗开始打印
/** * @author Watching * * @date 2023/4/29 * * Describe: */ public class ThreadDemo { public static void main(String[] args) throws InterruptedException { MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35845fab16dbaf2d0f89df257ad07808/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b9aaa76d173d023d27e69fde584f49c/" rel="bookmark">
			nacos的各个客户端的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两个依赖都与Nacos配置中心的集成有关，但是功能和作用略有不同。
1. `com.alibaba.nacos:nacos-client`：这是Nacos的Java客户端库，用于与Nacos服务器进行通信。它提供了与Nacos的各种功能交互的API，例如获取配置、注册服务、发现服务等。这个依赖是必需的，因为它提供了与Nacos服务器进行通信的核心功能。
2. `com.alibaba.boot:nacos-config-spring-boot-starter`：这个依赖是Spring Boot的集成模块，用于将Nacos配置中心的配置值注入到Spring Boot应用程序中。它提供了`@NacosValue`注解，可以将Nacos配置中心的值注入到应用程序的属性中。这个依赖是可选的，如果需要在Spring Boot应用程序中使用`@NacosValue`注解来注入Nacos配置值，则需要引入这个依赖。
总结起来，`com.alibaba.nacos:nacos-client`是Nacos的核心客户端库，用于与Nacos服务器进行通信，而`com.alibaba.boot:nacos-config-spring-boot-starter`是Spring Boot的集成模块，用于在Spring Boot应用程序中注入Nacos配置中心的配置值。这两个依赖通常一起使用，以实现与Nacos配置中心的集成。
这个依赖是用于在Spring Boot应用程序中集成Nacos服务发现功能的。它提供了与Nacos服务注册中心进行通信的功能，以便在应用程序中注册和发现服务。
具体来说，`com.alibaba.boot:nacos-discovery-spring-boot-starter`依赖包含了以下功能：
1. 与Nacos服务注册中心通信：它提供了与Nacos服务器进行通信的API，用于注册和注销服务。
2. 服务发现：它提供了在应用程序中发现已注册的服务的功能。通过使用`@NacosInjected`注解和`NacosServiceDiscovery`类，可以轻松地在应用程序中发现和使用其他服务。
3. 高可用性：它支持在集群中使用多个Nacos服务器，以提供高可用性和负载均衡。
总结起来，`com.alibaba.boot:nacos-discovery-spring-boot-starter`依赖是用于在Spring Boot应用程序中集成Nacos服务发现功能的。它提供了与Nacos服务注册中心通信、服务发现和高可用性等功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5ca9d7724d2c9dc1d34a797f5c53c5/" rel="bookmark">
			Spring Cloud中的网关与API管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud中的网关与API管理 一、简介二、API 管理的作用和应用场景三、API 网关的类型四、API 的核心特性1. 动态路由2. 过滤器3. 监控和告警4. 统一异常处理 五、API 管理的意义和应用场景1. API 管理的定义和本质2. API 管理的应用场景 六 、Spring Cloud中的API管理方案1. 基于Spring Cloud Netflix Eureka和Swagger的方案2. 基于Spring Cloud Consul和OpenAPI的方案3. 基于Spring Cloud Gateway和Spring Cloud Config的方案 八、实践案例1. 使用基于Spring Cloud Netflix和Swagger的API管理2. 使用基于Spring Cloud Gateway和Spring Cloud Config的API管理 一、简介 Spring Cloud 是一个基于 Spring Boot 实现的用于构建分布式系统的框架，它提供了一整套微服务应用开发的工具，简化了在构建分布式系统所需的冗余代码开发工作。
API 管理是对 API 的发布、生命周期管理以及服务监控与分析的统称，它被广泛应用于微服务架构中。
二、API 管理的作用和应用场景 API 管理的定义和作用：API 管理是一种集成、管理和监控应用程序接口（API）的解决方案，包括 API 注册、API 鉴权、API 流控、API 监控等功能，可以简化 API 的开发、部署和维护。API 管理的应用场景：API 管理适用于需要管理多个 API 的场景，如 B2B 对接、移动后端服务、互联网金融等。 三、API 网关的类型 基于 Zuul1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b5ca9d7724d2c9dc1d34a797f5c53c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f956ba8c3248d27c273ee0c408b318/" rel="bookmark">
			【网络】HTTP报文信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报文： 用于HTTP协议交互的信息称之为报文。它是由多行数据构成的字符串文本。
请求报文： 客户端的HTTP报文。
响应报文： 服务器端的HTTP报文。
请求报文&amp;响应报文 报文结构 请求报文： 响应报文： 概念阐述 请求行：包含请求的方法，用于请求URI和HTTP版本。状态行：包含表明响应结果的状态码、原因短句、HTTP版本。首部字段：包含表示请求和响应的各种条件和属性的各类首部。 一般有各种首部：通用首部、请求首部、响应首部、实体首部。 编码 HTTP有两种传输数据的方式：
按照数据原貌直接传输 效率慢 传输过程中通过编码提高效率 效率高但是会消耗更多的CPU资源 报文主体&amp;实体主体 报文：
HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输。
实体：
作为请求或响应的有效载荷数据被传输。内容由实体首部和实体主体构成。
HTTP报文主体：用于传输请求或者响应的实体主体。
📎 一般来说 报文主体 == 实体主体 。但是当传输过程中进行编码操作时，实体主体的内容发生变化，会导致和报文主体产生差异。
内容编码 指明应用在实体内容上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码。
常见编码格式： gzipcompressdeflateidentity 分块传输编码 在传输大的数据时，通过把数据分成多块，让浏览器逐步显示页面
步骤：
将实体主体分为多个部分，每一块用16进制标记块的大小。最后一块用0(CR+LF) 来标记。客户端负责解码，恢复到编码前的实体主体。 多部分对象集合 可以发送多种数据：
multipart/form-data： 用于表单文件上传。
multipart/byteranges： 响应报文包含了多个范围的内容时使用。
步骤：
报文中使用多部分对象集合时，要在首部字段加上Content-type，使用boundary字符串划分多部分对象集合指明的各类实体。 获取部分内容的范围请求 ❓ 场景：下载中断，如何从之前下载中断处恢复下载？ 要实现该场景需要指定下载的实体范围。
范围请求： 指定范围发送的请求
执行范围请求时，用到首部字段Range指定资源的byte范围。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ce64229b4b4a0734e0113d84ea6d7f/" rel="bookmark">
			用JAVA程序计算1！&#43;2！&#43;3！&#43;........&#43;10!的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public class 阶乘 { // 用JAVA程序计算1！+2！+3！+........+10!的和 public static void main(String args[]){ int i,j,n,sum; sum=0; for(i=1; i&lt;=10;i++){ n=1; for(j=1;j&lt;=i;j++){ n=n*j; } sum=sum+n; } System.out.print("1!+2!=3!+............+10!="+sum) ; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b91c3b548f11227c4157d44781f153/" rel="bookmark">
			通过Sealos 180秒部署一套K8S集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过Sealos 180秒部署一套K8S集群 一、主机准备 1.1 主机操作系统说明 序号操作系统及版本备注1CentOS7u9 1.2 主机硬件配置说明 k8s集群CPU及内存最低分别为2颗CPU、2G内存，硬盘建议为100G+
需求CPU内存硬盘角色主机名值8C8G1024GBmasterk8s-master01值8C8G1024GBmasterk8s-master02值8C8G1024GBmasterk8s-master03值8C16G1024GBworker(node)k8s-worker01值8C16G1024GBworker(node)k8s-worker02 1.3 主机配置 1.3.1 主机名配置 由于本次使用5台主机完成kubernetes集群部署，其中3台为master节点,名称分别为k8s-master01、k8s-master02、k8s-master03;其中2台为worker节点，名称分别为：k8s-worker01及k8s-worker02
master节点 # hostnamectl set-hostname k8s-master01 master节点 # hostnamectl set-hostname k8s-master02 master节点 # hostnamectl set-hostname k8s-master03 worker01节点 # hostnamectl set-hostname k8s-worker01 worker02节点 # hostnamectl set-hostname k8s-worker02 1.3.2 主机IP地址配置 k8s-master01节点IP地址为：192.168.10.140/24 # vim /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE="Ethernet" PROXY_METHOD="none" BROWSER_ONLY="no" BOOTPROTO="none" DEFROUTE="yes" IPV4_FAILURE_FATAL="no" IPV6INIT="yes" IPV6_AUTOCONF="yes" IPV6_DEFROUTE="yes" IPV6_FAILURE_FATAL="no" IPV6_ADDR_GEN_MODE="stable-privacy" NAME="ens33" DEVICE="ens33" ONBOOT="yes" IPADDR="192.168.10.140" PREFIX="24" GATEWAY="192.168.10.2" DNS1="119.29.29.29" k8s-master02节点IP地址为：192.168.10.141/24 # vim /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE="Ethernet" PROXY_METHOD="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b91c3b548f11227c4157d44781f153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37186d923f85cb46ca4810a7a57f0cf/" rel="bookmark">
			深度学习：pytorch nn.Embedding详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 nn.Embedding介绍
1.1 nn.Embedding作用
1.2 nn.Embedding函数描述
1.3 nn.Embedding词向量转化
2 nn.Embedding实战
2.1 embedding如何处理文本
2.2 embedding使用示例
2.3 nn.Embedding的可学习性
1 nn.Embedding介绍 1.1 nn.Embedding作用 nn.Embedding是PyTorch中的一个常用模块，其主要作用是将输入的整数序列转换为密集向量表示。在自然语言处理（NLP）任务中，可以将每个单词表示成一个向量，从而方便进行下一步的计算和处理。
1.2 nn.Embedding函数描述 nn.Embedding是将输入向量化，定义如下：
torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None, _freeze=False, device=None, dtype=None) 参数说明：
num_embeddings ：字典中词的个数embedding_dim：embedding的维度padding_idx（索引指定填充）：如果给定，则遇到padding_idx中的索引，则将其位置填0（0是默认值，事实上随便填充什么值都可以）。 注：embeddings中的值是正态分布N(0,1)中随机取值。
1.3 nn.Embedding词向量转化 在PyTorch中，nn.Embedding用来实现词与词向量的映射。nn.Embedding具有一个权重（.weight），形状是(num_words, embedding_dim)。例如一共有100个词，每个词用16维向量表征，对应的权重就是一个100×16的矩阵。
Embedding的输入形状N×W，N是batch size，W是序列的长度，输出的形状是N×W×embedding_dim。
Embedding输入必须是LongTensor，FloatTensor需通过tensor.long()方法转成LongTensor。
Embedding的权重是可以训练的，既可以采用随机初始化，也可以采用预训练好的词向量初始化。
2 nn.Embedding实战 2.1 embedding如何处理文本 在NLP任务中，首先要对文本进行处理，将文本进行编码转换，形成向量表达，embedding处理文本的流程如下：
（1）输入一段文本，中文会先分词（如jieba分词），英文会按照空格提取词
（2）首先将单词转成字典的形式，由于英语中以空格为词的分割，所以可以直接建立词典索引结构。类似于：word2id = {'i' : 1, 'like' : 2, 'you' : 3, 'want' : 4, 'an' : 5, 'apple' : 6} 这样的形式。如果是中文的话，首先进行分词操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d37186d923f85cb46ca4810a7a57f0cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d83d2bb95e16dabfd9f72cac37149d4/" rel="bookmark">
			Oracle mysql 达梦 大金仓 hive 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Oracle数据库：
优点： 能够处理大量的数据和高并发的事务处理。提供丰富的内置函数和分析工具。具备高级的安全性和数据完整性。缺点： 商业版的Oracle数据库较为昂贵。部署和管理较为复杂，需要专业知识。需要较高的硬件资源。 MySQL数据库：
优点： 开源免费且易于安装和使用。适用于小到中等规模的应用和简单查询。快速和高效的性能。缺点： 处理大规模复杂查询和高并发时性能可能有限。对复杂数据类型的支持较弱。安全性相对较低。 达梦数据库：
优点： 可以与Oracle数据库基本兼容，易于迁移。具备较好的性能和扩展性。提供针对国内市场的本地化支持。缺点： 较少的第三方工具和社区支持。非商业版可能功能较为受限。在国际市场上知名度较低。 大金仓数据库：
优点： 具备较好的性能和稳定性。表与字段名称长度限制较大。提供与Oracle语法兼容的模式。缺点： 社区支持相对较少。在国际市场上知名度较低。需要购买商业授权来解锁所有功能。 Hive数据库：
优点： 适合处理大规模数据和离线分析。可以通过Hadoop平台实现分布式存储和计算。提供类似SQL的查询语言HiveQL，易于开发和学习。缺点： 不适合实时查询和事务处理。相对于关系型数据库，性能较慢。对于少量数据的查询，不如专门为关系型数据库设计的解决方案。 相同点：
Oracle、MySQL、达梦和大金仓都是关系型数据库，使用SQL进行数据查询和操作。它们都可以处理事务处理和复杂查询的需求。 不同点：
这些数据库之间在数据模型、SQL方言、性能特点等方面存在差异。Oracle和MySQL在市场知名度和生态系统支持方面较强。达梦和大金仓在国内市场有较大份额，提供本地化支持。Hive数据库通过Hadoop平台处理大规模数据和离线分析，适用于大数据场景。 sql区别：
数据类型：
Oracle：支持VARCHAR2、NUMBER、DATE、CLOB等数据类型。MySQL：支持VARCHAR、INT、DATE、BLOB等数据类型。达梦：与Oracle兼容，支持VARCHAR2、NUMBER、DATE、CLOB等数据类型。大金仓：支持VARCHAR、INT、DATE、BLOB等数据类型。Hive：支持常见数据类型，如STRING、INT、DATE、BINARY等。 字符串拼接：
Oracle：使用双竖线符号 (||) 进行字符串拼接。MySQL：使用CONCAT函数或者直接使用“+”符号进行字符串拼接。达梦：与Oracle兼容，使用双竖线符号 (||) 进行字符串拼接。大金仓：使用“+”符号进行字符串拼接。Hive：使用CONCAT函数进行字符串拼接。 分页查询：
Oracle：使用ROWNUM进行分页查询。MySQL：使用LIMIT进行分页查询。达梦：与Oracle类似，可以使用ROWNUM进行分页查询。大金仓：使用LIMIT进行分页查询。Hive：使用LIMIT进行分页查询。 日期函数：
Oracle：具有丰富的日期和时间函数，如TO_DATE、SYSDATE、EXTRACT等。MySQL：具有一些常用的日期和时间函数，如DATE_FORMAT、NOW、DATE_SUB等。达梦：与Oracle语法兼容，具有类似的日期和时间函数。大金仓：提供了一些日期和时间函数，如DATE_FORMAT、CURDATE等。Hive：具有一些常见的日期和时间函数，如DATE_FORMAT、FROM_UNIXTIME等。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/017eedf4baee6bd0d5a24108d5f97dd5/" rel="bookmark">
			vscode插件开发 悬浮，ctrl点击 自动补全提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ctrl点击跳转
const jumpDisposable = vscode.languages.registerDefinitionProvider('vue', { provideDefinition, }); context.subscriptions.push(jumpDisposable); /* * @Author: hongbin * @Date: 2023-09-15 10:54:43 * @LastEditors: hongbin * @LastEditTime: 2023-09-15 21:23:22 * @Description:ctrl 跳转组件 */ import * as vscode from 'vscode'; import * as path from 'path'; import * as fs from 'fs'; import { docs as DOCS } from './docs'; import { getProjectPath } from './utils'; export function provideDefinition( document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken ): vscode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/017eedf4baee6bd0d5a24108d5f97dd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e8c19288f8e0f36131611161afeec7/" rel="bookmark">
			Autosar-OS软件概述和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Autosar OS目录 一、为什么需要OSOS的功能实时操作系统OSEK OS 二、Autosar OSAutosar OS可裁剪类型 三、OS配置OS ApplicationCountersAlarmsTask ManagementResource ManagementISRsScheduleTablesHook 函数和错误处理 一、为什么需要OS 为什么汽车电子ECU需要使用OS(Operation System)呢，它的必要性在哪里？
随着车载系统需求越来越复杂化，需要用到模块化设计方法以及多任务编程思想，为此减少后期软件升级维护成本。采用传统的计数器与状态机来实现简单多个任务的调度，无法满足多个任务之间的状态切换，优先级，现场保护，执行时间控制等各个方面。
此时迫切需要一种机制来替我们完成各个任务之间的调度功能，使得开发人员能够更关注于应用软件的开发，提高软件开发效率，为此OS便应运而生！
OS的功能 ①改变各任务的执行频率；
②改变各任务的执行时间；
③设定各任务的优先级，保证高优先级任务能够及时执行；
④任务调度、切换时的现场保护与恢复；
⑤共享资源的安全访问机制等；
在一个单核系统中，多任务只能并发执行，通过时间片轮转法来切换任务，通过时钟中断或者软中断的方式来触发一次任务的切换，从而打断当前执行任务，调度器抢夺CPU控制器，来进行任务调度并切换至新任务开始执行。
实时操作系统 实时操作系统（RTOS-Real Time Operating System）中实时（Real Time）指的是任务（Task）或者说实现一个功能的线程（Thread）必须在给定的时间(Deadline)内完成。
系统可以大致分为四个部分：硬件（Hardware），操作系统（operating system），应用程序（application programs），使用者（user）。
目前比较流行的实时操作系统包括Linux，黑莓QNX，RTOS（例如uCOS FreeRTOS,以及一些商用的认证SafeRTOS等），AUTOSAR OS(基于OSEK/VDX OS)，RT-Thread，华为的鸿蒙等
提示：FreeRTOS的官网地址：https://www.freertos.org/
OSEK OS OSEK是德文“Offene Systeme und deren Schnittstellen für die Elektronik im Kraftfahrzeug”的缩写，译为汽车电子开放系统及接口。OSEK OS是一个为满足汽车电子可靠性、实时性、成本敏感性等需求而打造的实时单核操作系统(RTAOS)。
类别OSEK OS基本特性①操作系统中任务、资源、服务静态配置；②支持在只读存储器上运行；③应用中的任务具备较好的可移植性；④操作系统所定义的动作可预见且可记录基本服务①任务管理：包括任务激活与终止以及任务的切换；②同步服务：主要通过资源调度和事件控制来实现；③中断服务程序：包括Catogory I与Category II两类中断；④Alarm机制：主要包括相对Alarm与绝对Alarm；⑤ 进程通信：主要用于进程间数据交互；⑥错误处理：支持各类错误的处理 osek已经被iso标准化，ISO17356，有兴趣的可以私聊小编获取。
二、Autosar OS AUTOSAR OS是基于OSEK OS继承发展而来，所以上述的OSEK OS的基本特点在AUTOSAR OS都能够得到满足，所以AUTOSAR OS是向后兼容的，也就意味着在OSEK OS上能够运行的应用程序同样也可以在AUTOSAR OS上运行。
AUTOSAR OS继承OSEK OS，在OSEK OS的基础上又特别明确了一些AUTOSAR OS需要提供的系统服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e8c19288f8e0f36131611161afeec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f3d9cfc8857407dbff2799c4320c16/" rel="bookmark">
			SpringBoot ＋MyBatis批量插入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💍 背景介绍 在最近的开发过程中，遇到了往数据库中表中插入大量的数据。有一个全国银行各分行的信息，共计148032条数据
文件有8.45MB，因为考虑到数据量比较大，就想着导入到MySQL看一看需要多长时间。
💍 方案一：用 for语句循环插入（不推荐） 使用for循环语句将，将数据一条条插入。
insert into t_bank values (?, ?, ?, ?, ?) /** * 导入银行信息 * * @param bankList * @return java.lang.String */ @Override public String importBank(List&lt;TBank&gt; bankList) { if (StringUtils.isNull(bankList) || bankList.size() == 0) { throw new CustomException("导入用户数据不能为空！"); } long start = System.currentTimeMillis(); for (int i = 0; i &lt; bankList.size(); i++) { tBankMapper.insertTBank(bankList.get(i)); } long end = System.currentTimeMillis(); log.info("数据总耗时：" + (end-start) + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f3d9cfc8857407dbff2799c4320c16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa6067657a993db34cb3210963c65cf/" rel="bookmark">
			国密算法 ZUC流密码 祖冲之密码 python代码完整实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此前发布了包含SM2公钥密码、SM3杂凑算法和SM4分组密码的国密算法完整工具包，其实还是有些不完整，因为没有流密码。今天把我们国家自己的流密码——ZUC祖冲之密码算法补充上。介绍其他国密算法的链接如下：
SM2：国密算法 SM2 公钥加密 非对称加密 数字签名 密钥协商 python实现完整代码_qq_43339242的博客-CSDN博客_python国密sm2
SM3：国密算法 SM3 消息摘要 杂凑算法 哈希函数 散列函数 python实现完整代码_qq_43339242的博客-CSDN博客
SM4：国密算法 SM4 对称加密 分组密码 python实现完整代码_qq_43339242的博客-CSDN博客_sm4代码python
对上述几个算法和实现不了解的，建议点进去看看。下面这篇文章是对上述的汇总：
国密算法 SM2公钥密码 SM3杂凑算法 SM4分组密码 python代码完整实现
所有代码托管在码云：hggm - 国密算法 SM2 SM3 SM4 python实现完整代码: 国密算法 SM2公钥密码 SM3杂凑算法 SM4分组密码 python代码完整实现 效率高于所有公开的python国密算法库 (gitee.com)
废话多了。上ZUC的代码：
from array import array _ZUC_D = [0x44D700, 0x26BC00, 0x626B00, 0x135E00, 0x578900, 0x35E200, 0x713500, 0x09AF00, 0x4D7800, 0x2F1300, 0x6BC400, 0x1AF100, 0x5E2600, 0x3C4D00, 0x789A00, 0x47AC00] _ZUC_S0 = bytes([ 0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54, 0x98, 0x09, 0xB9, 0x6D, 0xCB, 0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D, 0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90, 0x4D, 0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48, 0x8B, 0x29, 0x6E, 0xAC, 0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69, 0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38, 0x76, 0x7D, 0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21, 0x06, 0x55, 0x9B, 0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4, 0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C, 0x4A, 0x16, 0xD5, 0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01, 0xD3, 0xAD, 0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F, 0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8, 0xB1, 0xB4, 0x37, 0xF7, 0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96, 0x56, 0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE, 0xBC, 0x26, 0x95, 0x88, 0x8A, 0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D, 0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12, 0xF5, 0x74, 0x9C, 0xAA, 0x23, 0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02, 0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1, 0xF6, 0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6, 0x40, 0xC4, 0xE2, 0x0F, 0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F, 0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65, 0x8D, 0x27, 0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE, 0x78, 0x34, 0x60]) _ZUC_S1 = bytes([ 0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA, 0x5B, 0x29, 0xAA, 0xFD, 0x77, 0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A, 0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42, 0x44, 0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7, 0x8B, 0x39, 0x43, 0xE1, 0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3, 0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48, 0xDD, 0x20, 0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69, 0xF5, 0xD4, 0x87, 0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC, 0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB, 0x2B, 0x53, 0xD8, 0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73, 0x08, 0x09, 0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E, 0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9, 0xAD, 0xF1, 0xAE, 0x2E, 0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1, 0xE9, 0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D, 0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89, 0x01, 0xB6, 0xBD, 0x58, 0x24, 0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4, 0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0, 0x02, 0x4A, 0x79, 0xC3, 0xDE, 0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B, 0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21, 0x5A, 0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A, 0xBA, 0x7E, 0x0E, 0x34, 0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60, 0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28, 0x64, 0xBE, 0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12, 0x03, 0xE2, 0xF2]) _ZUC_S = array('H') for byte1 in _ZUC_S0: # 构造两字节的S盒变换表 byte1 &lt;&lt;= 8 _ZUC_S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faa6067657a993db34cb3210963c65cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d76b2378e59f93d3fac3c04daa675a93/" rel="bookmark">
			python读取tif文件，tif文件包括多页时的处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python利用plt读取tiff图像(多个页面)_iamge.open python tif_Li_Yurun的博客-CSDN博客
学习以上blog
首先执行seek 再读取数据
from paddleocr import PaddleOCR, draw_ocr import paddle import paddleocr import time from PIL import Image import numpy as np import os # paddleocr.DEFAULT_OCR_MODEL_VERSION = 'PP-OCRv4' if __name__ == '__main__': # paddle.device.set_device("gpu:1") # print(paddle.device.get_device()) #os.environ['CUDA_VISIBLE_DEVICES']='1' ocr = PaddleOCR(use_angle_cls=True, lang="ch",ocr_version="PP-OCRv4",gpu_id=1) img = Image.open('00000001.tif').convert('RGB') img2 = Image.open('00000001.tif') nframesNum = img2.n_frames print(nframesNum) for i in range(nframesNum): print(i) start = time.time() # result = ocr.ocr(np.array(img), cls=True) img2.seek(i) result = ocr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d76b2378e59f93d3fac3c04daa675a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4098237a02bc991235baaafb921ab1db/" rel="bookmark">
			vue如何引入高德地图插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最简单的方法
使用vue-amap 一套专门用于vue的高德地图插件 安装：npm install vue-amap --save在main.js中插入 其中key从应用中自己设置添加即可我的应用 | 高德控制台高德开放平台官网控制台提供了高德开发者Key管理，Key可视化分析等功能。https://console.amap.com/dev/key/app import AMap from 'vue-amap' Vue.use(AMap) // 初始化地图 AMap.initAMapApiLoader({ key: '自己的key', plugin: ['AMap.Autocomplete', 'AMap.PlaceSearch', 'AMap.Scale', 'AMap.OverView', 'AMap.ToolBar', 'AMap.MapType', 'AMap.PolyEditor', 'AMap.CircleEditor'] // 插件集合 }) 在组件中直接调用插件中封装好的组件就可以，给个高度 &lt;template&gt; &lt;div class="hh"&gt; &lt;el-amap vid="amapDemo" &gt;&lt;/el-amap&gt; &lt;/div&gt; &lt;/template&gt; &lt;style lang='scss'&gt; .hh{ height: 100vh; } &lt;/style&gt; 但是如果写完后发现要是报错例如图片这样
首先，你可以尝试执行以下步骤：
安装 @types/vue-amap 声明文件： npm install --save-dev @types/vue-amap 确保你的 TypeScript 配置文件（通常是 tsconfig.json）中具有以下配置项： { "compilerOptions": { "types": ["node", "vue-amap"] } } 如果上述步骤仍然无法解决问题，那么可能需要额外的操作。以下是一些备选方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4098237a02bc991235baaafb921ab1db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7e8dfccae0106a68bdf33b9477ff4b/" rel="bookmark">
			JDK8新特性(六)：JDK 8 可重复注解 与 类型注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自从 Java 5 中引入注解依赖，注解开始变得非常流行，并在各个框架和项目中被广泛使用。
不过注解有一个很大的限制：在同一个地方不能多次使用同一个注解。为了解决这个问题，JDK 8 引入了可重复注解的概念，允许在同一个地方多次使用同一个注解。 在 JDK 8 之前，注解只能用在各种程序元素（定义类、定义接口、定义方法、定义成员变量…）上。为了解决这个问题， JDK8 引入了类型注解，类型注解可以使注解用在任何地方。
1.可重复注解 在 Java 8 之前我们不能在同一个类、同一方法上重复使用同一个注解
@PropertySource("classpath:config1.properties") @PropertySource("classpath:config2.properties") public class AnnotationDemo{ //代码部分 } 上面的代码无法在 Java 7 下通过编译，错误是: Duplicate annotation。在 JDK 8 中引入了一个注解 @Repeatable 来标识某个注解是可被重复使用的，但是需要一个容器注解。可重复注解的使用步骤如下：
1.1定义可重复的注解容器注解 @Retention(RetentionPolicy.RUNTIME) @interface MyTests {//这是重复的容器注解 MyTest[] value(); } 1.2定义一个可以重复的注解 @Retention(RetentionPolicy.RUNTIME) @Repeatable(MyTests.class) @interface MyTest{ String value(); } 1.3配置多个重复的注解 @MyTest("mt1") @MyTest("mt2") @MyTest("mt3") public class annotationDemo { @Test @MyTest("ms1") @MyTest("ms2") public void test(){ } @Test @MyTest("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7e8dfccae0106a68bdf33b9477ff4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/200edffe7e7d369e3e68affbe0bf0495/" rel="bookmark">
			Qt样式表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、QT样式表简介 1、QT样式表简介
QSS的主要功能是使界面的表现与界面的元素分离，使得设计皮肤与界面控件分离的软件成为可能。
QT样式表是允许用户定制widgets组件外观的强大机制，此外，子类化QStyle也可以定制widgets组件外观。QT样式表的概念、术语、语法很大程度上受到了CSS层叠样式表的影响。
样式表是使用QApplication::setStyleSheet()设置在应用程序或是使用QWidget::setStyleSheet()设置在具体组件及其子对象的文字说明。
例如，以下样式表指明QLineEdit使用黄色作为背景色，QCheckBox使用红色作为文本颜色。
QLineEdit { background: yellow } QCheckBox { color: red } 对于这种定制，样式表比QPalette更强大。例如，要获取一个红色的按钮，可以设置QPushButton的QPalette::Button角色为红色。然而，这并不保证对所有的样式有效，因为样式的构造者会被不同平台的原则和本地的主题引擎所限制。
样式表可以实现那些很难或是不可能使用QPalette实现的所有定制。
如果想要某些强制字段为黄色背景，按钮为红色文字，或是绚丽的复选框，样式表可以完成。
本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（Qt实战项目，C++语言基础，C++设计模式，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓
2、QT样式表编程
A、在代码中直接设置QSS
QPushButton *button = new QPushButton(this); button-&gt;setText("hello"); button-&gt;setStyleSheet("QPushButton{background-color:red; color:blue}"); B、通过文件设置QSS
将QSS代码写入.qss文件
将.qss文件加入资源文件qrc.qrc中
在代码中读取QSS文件设置组件QSS
QPushButton *button = new QPushButton(this); button-&gt;setText("hello"); QFile file(":/qss/dev.qss"); file.open(QIODevice::ReadOnly); QString stylesheet = QLatin1String(file.readAll()); button-&gt;setStyleSheet(stylesheet); file.close(); 二、QT样式表语法 QT样式表的术语和语法规则与HTML CSS很相似。
1、样式规则 样式表由样式规则序列组成。样式规则由选择器和声明组成。选择器指定了那些组件受规则影响，声明指定了组件设置了哪些属性。例如：
QPushButton { color: red } 以上样式规则中，QPushButton是选择器，{ color: red }是声明。样式规则指定了QPushButton及其子类应使用红色作为前景色。
QT样式表大小写不敏感，除了类名、对象名、QT属性名是大小写敏感的。
多个选择器可以指定同一个声明，使用逗号分隔选择器。例如以下规则：
QPushButton, QLineEdit, QComboBox { color: red } 等效于三个规则：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/200edffe7e7d369e3e68affbe0bf0495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfd9249db5ad85f56505679b22af7976/" rel="bookmark">
			虚拟机上安装镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机上安装镜像 参考网址https://zhuanlan.zhihu.com/p/317188273 镜像下载（桌面版本） ubuntu镜像下载：20.版本清华 中科16版本
windows: 直接官网下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97abf1b57cc5247e3abd2fd81ea9b55/" rel="bookmark">
			Nacos 启动常见错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Could not find or load main class Error: Could not find or load main class
Caused by: java.lang.ClassNotFoundException:
解决办法：
x JAVA_OPT_EXT_FIX="-Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext"
√ JAVA_OPT="${JAVA_OPT} -Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext"
x echo "$JAVA $JAVA_OPT_EXT_FIX ${JAVA_OPT}"
√ echo "$JAVA ${JAVA_OPT}"
x echo "$JAVA $JAVA_OPT_EXT_FIX ${JAVA_OPT}" &gt; ${BASE_DIR}/logs/start.out 2&gt;&amp;1 &amp;
x nohup "$JAVA" "$JAVA_OPT_EXT_FIX" ${JAVA_OPT} nacos.nacos &gt;&gt; ${BASE_DIR}/logs/start.out 2&gt;&amp;1 &amp;
√ echo "$JAVA ${JAVA_OPT}" &gt; ${BASE_DIR}/logs/start.out 2&gt;&amp;1 &amp;
√ nohup $JAVA ${JAVA_OPT} nacos.nacos &gt;&gt; ${BASE_DIR}/logs/start.out 2&gt;&amp;1 &amp;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97abf1b57cc5247e3abd2fd81ea9b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ec99f2214ef56fa2845003a2e18ab7/" rel="bookmark">
			内网穿透的应用-Cloudreve搭建云盘系统，并实现随时访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、前言2、本地网站搭建2.1 环境使用2.2 支持组件选择2.3 网页安装2.4 测试和使用2.5 问题解决 3、本地网页发布3.1 cpolar云端设置3.2 cpolar本地设置 4、公网访问测试5、结语 1、前言 自云存储概念兴起已经有段时间了，各互联网大厂也纷纷加入战局，一时间公有云盘遍地开花。但一段时间后，公有云盘潜在的安全问题也暴露出来，原有的共有云盘用户纷纷转为搭建私有云盘，也带动了群晖等一众私有云盘供应商的发展。可群晖硬件动辄数千，让个人消费者难以招架，是否能将个人电脑改造为私有云盘呢？答案自然是肯定的，今天我们就为大家介绍，如何使用Cpolar与Cloudreve，在个人Windows电脑上搭建一个强大的PHP云盘系统。
2、本地网站搭建 2.1 环境使用 Cloudreve是一个网页程序，由于其运行在本地电脑上，因此需要一个虚拟运行环境，这里我们使用的是PHPStudy这款软件。由于PHPStudy是独立软件，因此只需要在PHPStudy下载完成后，双击安装包内的安装程序，依照软件提示即可完成安装。
2.2 支持组件选择 与常见的网页程序一样，Cloudreve也是以PHP为基础，加上其文件传输功能，因此需要PHP、MySQL、Nginx、FTP、FileZilla、SQL-Front几个程序的支持。好在PHPStudy提供了这些支持软件的安装，省去了我们不少麻烦。
2.3 网页安装 在PHPStudy软件准备好后，我们就可以开始安装Cloudreve网页。在Cloudreve官网下载网页包（官网网页被挂在GitHub，网页打不开常态，可以从其他渠道下载）
网页压缩包下载完毕后，将Cloudreve压缩包解压至PHPStudy的WWW文件夹下，作为网页的根目录。本例中PHPStudy安装在D盘下，因此路径为此电脑 – D盘 – PHPStudy pro – WWW。
接着返回PHPStudy主界面的“网站”页面，点击该页面左上角的“创建网站”，开始对Cloudreve网页运行环境进行设置。
在“创建网站”页面，我们需要对网站运行环境进行几项基本设置，包括：
域名：本地访问网站的域名；端口：本地网页的输出端口号；根目录：即网页文件存放的路径，可以通过栏位右侧的“浏览”按钮进行选择；创建FTP和数据库：勾选这两项会弹出新窗口进行设置，设置内容主要为用户名、密码、名称几项；PHP版本：通常这项不必单独选择，PHPStudy会自动选择较高版本，但为避免安装后网站打开错误，最好选择7.2X版本的PHP。 在完成各项设置后，就可以点击页面下方的“确认”按钮，将这些配置保存下来。接着在浏览器地址栏中输入(localhost:80/cloudreveinstaller)，进入网页安装程序。在这一步，Cloudreve会对运行环境和支持功能进行检查，只有必要项目自检通过，才能进行下一步部署。
下一步安装工作，主要是对数据库信息进行填写，我们只需要依照之前设定的数据库信息填入即可。
设置完数据库信息后，点击页面下方的“开始安装”，只需等待很短时间，Cloudreve就能安装完成。在网页安装完成页面，会给出Cloudreve后台地址、管理员登录信息和安全注意事项。
2.4 测试和使用 接着我们在浏览器地址栏中输入localhost:80（端口号需要根据实际设定输入，在这个例子中，我们使用的端口号为80），就能使用本地电脑上的Cloudreve网盘系统。
2.5 问题解决 在Cloudreve安装过程中，最容易出的一个问题，就是环境检查中URL Rewrite项目错误，这个问题解决方法也很简单，只要对网页进行伪静态设置即可。
首先我们打开PHPStudy，在Cloudreve网站条目右侧，点击“管理”选项，从中找到“伪静态”按钮，点击进入伪静态设置页面。
在伪静态设置框内，输入以下命令：
location / { if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } 输入完成后，点击下方的“确认”进行保存，再刷新一次安装页面，就能看到原本报错的URL Rewrite项目已经通过检查，我们就能继续进行下一步安装。
3、本地网页发布 3.1 cpolar云端设置 在Cloudreve网页安装完成后，我们就可以着手将位于本地电脑上的Cloudreve云盘，通过Cpolar创建的内网穿透数据隧道，将这个云盘发布到公共互联网上，在限定范围内接受注册用户（或分发已注册用户信息）访问该云盘。首先访问cpolar的官网，在官网页面，能找到cpolar客户端的下载按钮，我们可以先将cpolar下载至本地，等到对数据隧道关联本地网站时再进行安装。
Cpolar客户端下载完成后，先不着急离开官网页面，我们需要在官网页面预留一条空白数据隧道，用以承载本地Cloudreve。在以用户登录cpolar官网后，在“仪表盘”页面左侧点击“预留”按钮，进入cpolar云端空白数据隧道的预留设置页面。
在这个页面，我们可以选择预留“二级子域名”、“自定义域名”、“TCP地址”、“FTP地址”等多个项目（需要注意的是，云端保留各种数据隧道为高级功能，需要将cpolar升级至基础版及以上才能使用），对于Cloudreve网页来说，我们可选择“保留二级子域名”或“保留自定义域名”。其中“保留自定义域名”需要从域名供应商处购买域名，并对CNAME进行设置，为避免混淆，我们以“保留二级子域名”进行演示。
在“保留二级子域名”栏位，我们需要对拟保留的二级子域名进行简单设置，设置内容包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6ec99f2214ef56fa2845003a2e18ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc8659790501a009e9e2bbb540bc123/" rel="bookmark">
			npm报错Failed at the electron-chromedriver@1.8.0 install script.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 Electron+vue 项目 npm install 报错Failed at the electron-chromedriver@1.8.0 install script.
解决方案： 方法一：vue-cli 脚手架的一个 bug，原因是 chromedriver 的部分文件被国内网络给墙掉了，执行以下命令： npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver 方法二：以管理员权限运行，如果报错则尝试方法三 sudo npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver 方法三：确保添加–ignore-scripts后缀以禁止npm里第三方依赖包的预先安装脚本或者安装后脚本被执行 npm install --ignore-scripts npm install 我是用方法三解决了问题。
参考文章：
npm报错Failed at the chromedriver@2.46.0 install script
当运行npm install 命令的时候带上ignore-scripts，会发生什么？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce91d64385b1622695e588401399d6b7/" rel="bookmark">
			Kingbase ES函数参数模式与Oracle的异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章概要： 本文对主要就KES和Oracle的PLSQL中关于存储过程参数模式异同进行介绍，列举和验证了存在的差异
(如果想直接看差异的结论可直接跳到末尾)。
一，存储过程的三种参数模式 重新回顾一下，PLSQL中存储过程的三种参数模式IN、OUT、INOUT
1，IN参数模式，也是默认的模式，在存储过程运行的时候就应该具有值
2，OUT参数模式，定义的参数只能在存储过程体内部赋值，表示该参数可以将某个值传递到外部调用处。
3，IN OUT简单来说就是存储过程调用处传递的实参，在过程体内会被接收到，并且在存储过程体内为形参赋的值也会被传递到存储过程调用处。
二，IN模式 共同点：
1，IN模式是参数的默认模式，且可以不写IN，
2，应该在程序运行的时候已经具有值
3，可以设置默认值
差异点：
Oracle--》参数不可以在程序体内重新赋值，即只能传入给程序使用
KES-----》参数可以在程序体内重新赋值
对差异点进行验证
--测试用例1：
--存储过程in_proc create or replace procedure in_proc ( p_a in number , p_b number --默认为IN模式 )as begin p_a := 10 ; --实参被传递进来以后，在这个程序体中Oracle不支持修改，KES支持修改 p_b := 20 ; dbms_output.put_line(p_a); dbms_output.put_line(p_b); end ; --测试存储过程 declare va int; vb int; begin va := 11; vb := 12; call in_proc(va,vb); end --oracle编译存储过程直接报错：
Procedure IN_PROC 已编译 LINE/COL ERROR --------- ------------------------------------------------------------- 6/5 PLS-00363: 表达式 'P_A' 不能用作赋值目标 6/5 PL/SQL: Statement ignored 7/5 PLS-00363: 表达式 'P_B' 不能用作赋值目标 7/5 PL/SQL: Statement ignored 错误: 查看编译器日志 --KES结果,正常输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce91d64385b1622695e588401399d6b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/235d069c5620ced56fc7062f148f3f00/" rel="bookmark">
			css3动画基础详解（@keyframes和animation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动画是使元素从一种样式逐渐变化为另外一种效果，CSS3动画的生成，主要依赖@keyframes定义动画，animation执行动画。
@keyframes 通过 @keyframes 规则创建动画。
@keyframes keyframes-name {keyframes-selector {css-styles;}}
keyframes-name 帧列表的名称。 名称必须符合 CSS 语法中对标识符的定义。
keyframes-selector 动画时长的百分比。合法值：
0-100%
from 等效于 0%
to 等效于 100%
css-styles 需要改变的css样式，支持多属性
animation animation 是一个简写的属性，用于设置6个动画属性：
animation-name：这个就是使用@keyframes定义的动画名称；animation-duration：动画执行的时间，以秒为单位animation-delay：规定动画开始之前的延迟animation-iteration-count：规定动画应该播放的次数,n(次数) | infinite(无限次)animation-direction：规定是否应该轮流反向播放动画animation-timing-function：规定动画的速度曲线 @keyframes changeSize { 0% { transform: scale(0.8); } 50% { transform: scale(1.2); } 100% { transform: scale(0.8); } } .demo { animation-name: changeSize; animation-duration: 2s; animation-iteration-count:infinite; } animation-timing-function 这里说下复杂属性，第一个是animation-timing-function：规定动画速度的曲线
值说明ease默认，低速开始，然后加快，结束前变慢linear从头到尾速度相同ease-in以低速度开始，先慢后快ease-out以低速结束，先快后慢ease-in-out以低速开始和结束cubic-bezier(x1,y1,x2,y2)在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 cubic-bezier：三次赛贝尔曲线函数，前面的几个预设函数都可以通过它来实现。 通过控制曲线上的四个点（起始点(0,0)、终止点(1,1)以及两个相互分离的中间点）来绘制一条曲线并以曲线的状态来反映动画过程中速度的变化。可以访问 cubic-bezier.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/235d069c5620ced56fc7062f148f3f00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da57108291c7f53a894f1d710fb17f5/" rel="bookmark">
			Centos nginx 安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装gcc #查询gcc版本 gcc -v yum -y install gcc pcre、pcre-devel安装 pcre是一个perl库，包括perl兼容的正则表达式库，nginx的http模块使用pcre来解析正则表达式，所以需要安装pcre库。
#安装命令 yum install -y pcre pcre-devel zlib安装 zlib库提供了很多种压缩和解压缩方式nginx使用zlib对http包的内容进行gzip，所以需要安装。
#安装命令 yum install -y zlib zlib-devel 安装openssl openssl是nginx安全通信的基石。
#安装命令 yum install -y openssl openssl-devel 安装nginx 下载nginx安装包
wget http://nginx.org/download/nginx-1.9.9.tar.gz 解压压缩包至/data/tools
tar -zxvf nginx-1.9.9.tar.gz -C /data/tools 切换到cd /data/tools/nginx-1.9.9/下面
#之后执行以下三个指令 添加ssl ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module make make install 切换到/usr/local/nginx安装目录
配置nginx的配置文件nginx.conf文件，主要也就是端口
启动服务
cd /usr/local/nginx/sbin #执行启动命令 ./nginx #查看启动是否成功 ps -ef | grep nginx 访问ip，查看nginx服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1121d126511ab2a6cb37720999100ad5/" rel="bookmark">
			JS实现深拷贝的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要给大家介绍了关于JS实现深拷贝的4种方式,深拷贝是指将一个对象完整地拷贝一份,不受原对象影响,文中通过示例代码介绍的非常详细,需要的朋友可以参考下
概念 深拷贝：在堆内存中重新开辟一个存储空间，完全克隆一个一模一样的对象；
浅拷贝：不在堆内存中重新开辟空间，只复制栈内存中的引用地址。
本质上两个对象（数组）依然指向同一块存储空间在这里插入代码片
1、递归方式（推荐，项目中最安全最常用） 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
//使用递归的方式实现数组、对象的深拷贝
export function deepClone (obj) {
let objClone = Array.isArray(obj) ? [] : {};
if (obj &amp;&amp; typeof obj === "object") {
for (var key in obj) {
if (obj.hasOwnProperty(key)) {
//判断ojb子元素是否为对象，如果是，递归复制
if (obj[key] &amp;&amp; typeof obj[key] === "object") {
objClone[key] = deepClone(obj[key]);
} else {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1121d126511ab2a6cb37720999100ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afceed527f50a6a7f523d6c3b35b69e4/" rel="bookmark">
			华为云OBS连接Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接华为云OBS需要使用OBS Java SDK，具体步骤如下：
下载OBS Java SDK，并将SDK添加到项目中。
创建OBSClient对象，以便与OBS服务器交互。
// 初始化OBSClient对象 String endPoint = "obs.cn-north-4.myhuaweicloud.com"; String ak = "AccessKeyId"; String sk = "SecretAccessKey"; ObsClient obsClient = new ObsClient(ak, sk, endPoint); 使用OBSClient对象进行操作，例如上传文件到OBS。 // 上传文件到OBS String bucketName = "my-bucket"; String objectKey = "path/to/my/object"; File file = new File("path/to/local/file"); PutObjectRequest request = new PutObjectRequest(bucketName, objectKey, file); obsClient.putObject(request); 关闭OBSClient对象。 // 关闭OBSClient对象 obsClient.close(); 以上就是连接华为云OBS的基本步骤，具体操作还需根据需求进行相应调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1269ce30a3be2fcc0de989b3cff6a9cf/" rel="bookmark">
			python selenium如何带cookie访问网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python selenium如何带cookie访问网站 要使用Python的Selenium库带有cookie访问网站，你可以按照以下步骤进行操作：
一、流程介绍 安装Selenium库（如果尚未安装）：
pip install selenium 导入Selenium库并启动一个浏览器会话（比如Chrome或Firefox）：
from selenium import webdriver # 使用Chrome浏览器 driver = webdriver.Chrome() # 或者使用Firefox浏览器 # driver = webdriver.Firefox() 使用driver.get()方法打开要访问的网站：
driver.get("https://example.com") 创建一个Cookie字典，将要添加的cookie信息添加到字典中：
# 创建一个Cookie字典 cookie = { 'name': 'cookie_name', 'value': 'cookie_value', 'domain': 'example.com', # 替换为实际的域名 'path': '/', # 替换为实际的路径 } 使用driver.add_cookie()方法将Cookie添加到浏览器会话中：
driver.add_cookie(cookie) 刷新页面以使Cookie生效：
driver.refresh() 现在，你可以使用带有添加的Cookie的浏览器会话访问网站。确保替换上述代码中的示例域名、路径以及Cookie名称和值为实际的值。
二、完整示例代码 from selenium import webdriver # 启动Chrome浏览器 driver = webdriver.Chrome() # 打开网站 driver.get("https://example.com") # 创建Cookie字典 cookie = { 'name': 'cookie_name', 'value': 'cookie_value', 'domain': 'example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1269ce30a3be2fcc0de989b3cff6a9cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd3e6621c3dbfbfd41289c0c9525d3e/" rel="bookmark">
			nacos服务端--切换数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos服务端版本：2.3.0-SNAPSHOT
在nacos的服务端，需改application.properties文件
#*************** Config Module Related Configurations ***************# ### Deprecated configuration property, it is recommended to use `spring.sql.init.platform` replaced. # spring.datasource.platform=mysql # nacos.plugin.datasource.log.enabled=true spring.sql.init.platform=mysql ### Count of DB: db.num=1 ### Connect URL of DB: db.url.0=jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC db.user=root db.password=root ### the maximum retry times for push nacos.config.push.maxRetryTime=50 Nacos默认提供Derby以及MySQL的实现。根据使用的数据库类型，可以在Nacos GitHub存储库的conf目录中找到相应的脚本。
nacos-db.sql和derby-schema.sql都是用于创建Nacos数据库表结构的SQL脚本，但它们针对的是不同的数据库。
nacos-db.sql：这个脚本用于创建Nacos数据库表结构的MySQL版本。它包含了创建Nacos所需的所有表和索引的SQL语句，以及一些初始化数据。
derby-schema.sql：这个脚本用于创建Nacos数据库表结构的Derby版本。Derby是一种嵌入式数据库，因此不需要单独的数据库服务器。这个脚本与nacos-db.sql类似，但使用了Derby特定的语法和数据类型。
根据您使用的数据库类型，您可以选择使用相应的脚本来创建Nacos数据库表结构。如果您使用的是MySQL，则应使用nacos-db.sql。如果您使用的是Derby，则应使用derby-schema.sql。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f18e5c59af685df53a3b36e548f9958/" rel="bookmark">
			【知识分享】Modbus通信协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、协议 这里分两部分，Modbus和协议，首先什么是协议？百度解释下就是：意思是共同计议，协商；经过谈判、协商而制定的共同承认、共同遵守的文件。比如大学毕业找工作的时候，一般要签一份叫“三方协议”的，三方指自己、校方、企业，这份协议里规定了三方需要遵守的一些事项。
二、通信协议 那通信协议又是什么呢？通信就是双方或多方的交流，通信协议就是规定双方或多方需要共同遵守的交流方式。比如现在规定两个人需要用数字来代表文字，目前只定义了1表示“我”，2表示“你”，3表示“他”，然后现在两个人中有个人说了1，另一个立即就知道说的是“我”，但假如有个人不按规定来说话，说了一个4，那另一个人就不明白他在说什么了。这个例子里面，定义的1、2、3的表示，就是一份简单的通信协议。一般的通信协议，如TCP/IP、蓝牙协议等比Modbus复杂，但万变不离其宗。
三、Modbus 3.1 概述 接下来就是重头戏了，Modbus通信协议。
Modbus是一种串行通信协议，是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而发表。Modbus已经成为工业领域通信协议的业界标准（De facto），并且现在是工业电子设备之间常用的连接方式。--摘自百度百科
Modbus是一种一主一从的一对一通信方式（主机发一帧，从机回一帧的形式），当然也一主多从，但实际也是一对一通信，同一时刻只能有一个从机进行响应。如果需要和多个从机同时通信，这里也支持使用广播，即主机发送指令，所有从机接收指令并执行，但不进行应答。可以参考国际标准（以下简称国标），GBT 19582-2。
当进行一主多从通信时，主机通过从机ID号来区分要通信的从机设备。从机ID范围为1~247，0为广播地址，248~255为用户自定义地址。
3.2 通信形式 目前总共有4种通信形式，RTU、ASCII、TCP、Plus。
3.2.1 RTU RTU是一种远程终端控制系统，这里指的是Modbus的一种通信形式。一般是基于串口进行通信。其报文格式是十六进制的，由Slave ID+数据+CRC校验三部分组成。数据部分详见上面报文解析。剩下的就是数据校验了，这里用的是CRC校验（循环冗余校验，Cyclic Redundancy Check，简称CRC）。要注意的是，数据部分高位数据在前，低位数据在后，而CRC校验则是低位在前，高位在后。
名称 从机ID
数据部分
CRC低位
CRC高位
长度1字节n字节1字节1字节 CRC校验
CRC（Cyclic Redundancy Checksum）是一种纠错技术，代表循环冗余校验和。CRC的计算原理这里就不讲了，直接上代码。
C语言实现--摘自FreeModbus里的实现
static const UCHAR aucCRCHi[] = { 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40 }; static const UCHAR aucCRCLo[] = { 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40 }; USHORT usMBCRC16( UCHAR * pucFrame, USHORT usLen ) { UCHAR ucCRCHi = 0xFF; UCHAR ucCRCLo = 0xFF; int iIndex; while( usLen-- ) { iIndex = ucCRCLo ^ *( pucFrame++ ); ucCRCLo = ( UCHAR )( ucCRCHi ^ aucCRCHi[iIndex] ); ucCRCHi = aucCRCLo[iIndex]; } return ( USHORT )( ucCRCHi &lt;&lt; 8 | ucCRCLo ); } 帧的完整性判断
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f18e5c59af685df53a3b36e548f9958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109b49760cbae1d7265dc334d02e9986/" rel="bookmark">
			Navicat历史版本下载及地址组成分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载地址组成 https://download3.navicat.com/download/navicat161_premium_cs_x64.exe
地址逻辑：前缀 + 版本 + 类型 + 语言 + 位数
前缀: http://download.navicat.com/download/navicat版本: 三位数，前两位是大版本，后一位是小版本，如161代表16.1版本类型: premium 代表豪华版, 其他如mysql等语言: cs代表简体中文，en代表英文位数: x86代表32位 ，x64代表64位，一般下载64位即可 中文版本 http://download.navicat.com/download/navicat100_premium_cs.exehttp://download.navicat.com/download/navicat110_premium_cs_x86.exehttp://download.navicat.com/download/navicat110_premium_cs_x64.exehttp://download.navicat.com/download/navicat120_premium_cs_x86.exehttp://download.navicat.com/download/navicat120_premium_cs_x64.exehttp://download.navicat.com/download/navicat121_premium_cs_x86.exehttp://download.navicat.com/download/navicat121_premium_cs_x64.exehttps://download.navicat.com/download/navicat150_premium_cs_x64.exehttps://download.navicat.com/download/navicat150_premium_cs_x86.exehttps://download.navicat.com/download/navicat160_premium_cs_x64.exehttps://download.navicat.com/download/navicat161_premium_cs_x64.exehttps://download.navicat.com/download/navicat162_premium_cs_x64.exe 英文版本 http://download.navicat.com/download/navicat100_premium_en.exehttp://download.navicat.com/download/navicat110_premium_en_x86.exehttp://download.navicat.com/download/navicat110_premium_en_x64.exehttp://download.navicat.com/download/navicat120_premium_en_x86.exehttp://download.navicat.com/download/navicat120_premium_en_x64.exehttp://download.navicat.com/download/navicat121_premium_en_x86.exehttp://download.navicat.com/download/navicat121_premium_en_x64.exehttps://download.navicat.com/download/navicat150_premium_en_x64.exehttps://download.navicat.com/download/navicat150_premium_en_x86.exehttps://download.navicat.com/download/navicat160_premium_en_x64.exehttps://download.navicat.com/download/navicat161_premium_en_x64.exehttps://download.navicat.com/download/navicat162_premium_en_x64.exe 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db2aea0e976fc05f410bead0761a78b/" rel="bookmark">
			golang入门笔记——viper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Viper是golang的一个管理配置文件的工具，它支持JSON、TOML、YAML、HCL、envfile、Java properties。它支持以下特性：
设置默认值 从JSON、 TOML、 YAML、 HCL、INI、 envfile和 Java properties格式的配置文件读取配置信息 实时监控和重新读取配置文件(可选) 从环境变量中读取 从远程配置系统(etcd或Consul) 读取并监控配置变化 从命令行参数读取配置 从buffer读取配置 显式配置值 Viper优先级：
显示调用 Set设置值 命令行参数 (flag) 环境变量 配置文件 key/value存储 默认值 注意：
viper是大小写敏感的 把
Viper库的安装：
go get github.com/spf13/viper viper的简单使用：
func ReadFromConfig() { config := viper.New() //创建一个viper文件 config.AddConfigPath("./config") //配置文件所在目录 //config.SetConfigFile("./config.yaml") // 指定配置文件路径 //config.AddConfigPath("$HOME/.appname") // 多次调用以添加多个搜索路径 config.SetConfigName("account") //文件名 config.SetConfigType("json") //文件类型，配置文件的后缀 if err := config.ReadInConfig(); err != nil { if _, ok := err.(viper.ConfigFileNotFoundError); ok { panic("找不到配置文件") } else { panic(err) } } //读取配置 user1 := config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db2aea0e976fc05f410bead0761a78b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5fbf58f6bcd57b8dedf4f93acf8c3df/" rel="bookmark">
			iphone11/14 爱思助手导出照片显示“当前照片还没有从苹果照片流服务器下载,不能预览及导出”以及照片大小0KB的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况：拍了很多（几千张）照片，想用爱思助手批量导出，显示的是未下载，点开显示“当前照片还没有从苹果照片流服务器下载,不能预览及导出”，在手机查看照片详细信息显示大小是0kb,过一会就有显示大小了
图1：
原因：一般就是打开了iCloud的同步照片，但是我没有啊，而且我拍照的手机没有插卡也没有联网，为什么还会？原来是苹果很恶心，默认都会打开了iCloud云备份的，只要打开了iCloud云备份，不管你的云空间够不够，有没有网络都会“帮你”预备份照片，所以就会这样。
这是苹果官网的云备份解释：
也就说明：照片都还是在本地的，只是被“预处理”了，只要逼他交出来就可以了。
爱思给的解决办法是一张一张打开一次，数量不多的话确实可以，几千张的话手都点麻了
解决方法：全选照片-选项：把所有数据选上（不选应该也可以）-隔空投送，选一个设备，就会进入“正在准备“ （相册：把数据给我还原回来，不然拿什么投送？？），，等准备完在取消就可以了，刷新一下爱思，就全部都出来了。
所有iphone有这个情况的应该都是这个原理的，直接试一下。
没什么技术，记录一下，希望可以帮到有需要的朋友，喜欢的评论支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc46e51f4a9950a7f892cd52ab00d5a/" rel="bookmark">
			基于Unity的VR迷宫游戏项目技术分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目重述 项目重述如下：
在移动端设计一个可参与的创作平台，结合计算机视觉相关技术，获取物理空间中的迷宫设计图；将移动端获得的迷宫数据转换为三维虚拟场景，并在VR端呈现；开发基于Unity 3D的双人体验系统，并实现用户在虚拟迷宫中的漫游和交互；要求实现“VR + VR”形式： 两名用户佩戴 VR头盔进行漫游并协作；要求采用的VR交互技术：人体运动跟踪、控制用户在虚拟场景中漫游、手势交互等。 三、项目核心技术与亮点 系统完整地达到了实验的所有要求，具有完整的用户体验，涉及多种技术栈，达到了多通道交互的效果，基本上达到了自然和谐的人机交互体验 基于原生Android与OpenCV，高精度识别物理空间中的迷宫布局；手绘迷宫识别错误率趋近0%，实际应用环境迷宫识别错误率约5%；VR端场景较为恰当，组件多样；既可以单人体验，也可以多人交互，动作捕捉较为灵敏准确，使用方式灵活可靠。利用Spring Boot和Vue的架构、基于HTTP的统一通讯手段，建立起了强数据一致性的服务控制端，可以实时更改迷宫布局，增加了游玩的趣味性。 四、系统架构概述 4.1 设备与开发环境 使用交互设备：Android智能手机（Android 6.0 及以上）、爱奇艺小阅s VR眼镜盒子、Kinect、笔记本电脑（Windows 10 及以上）；开发平台：Unity2021.3、Android studio 2021、Visual Studio 2020、IntelliJ IDEA 2021；开发过程中使用的SDK：OpenCV for Android SDK、GoogleVRForUnity_1.200.1、 Kinect for windows SDK v2.0； 4.2 系统架构 4.2.1 系统架构简述 移动端：输入一张图片，经过算法的处理，输出迷宫的结构，用简短的数据结构来描述迷宫数据，最终完成向服务器的数据传输。VR端：此部分放在VR眼镜盒子里供用户体验，需要根据服务器数据，向用户展示三维空间景象。服务器端：服务器端负责连接Kinect、识别用户动作、并且发送到VR端，控制端负责实时更新迷宫的状态，并且把最新的布局反映到VR端。 4.2.2 系统架构图 ­主要功能模块图示：
五、项目需求与可行性分析 5.1 移动端需求与可行性分析 5.1.1 用户界面设计 在界面设计中，我们希望设计的界面符合课上讲述的各类 GUI 设计原则的要求：
桌面隐喻：桌面隐喻是一种用于设计图形用户界面的技术，它将计算机界面模拟成一个现实生活中的办公桌面。在这个桌面上，用户可以看到和操作各种图标、文件夹和工具栏等，就像在现实中使用一件物品一样。直接操作：直接操作是一种用户与计算机交互的方式，它允许用户直接通过物理手势或触控来操作界面元素，而不是通过命令或鼠标指针等间接的方式。这种方式可以让用户更快速、直接地完成任务，并且更容易理解系统的反馈。所见即所得：所见即所得是一种界面设计的原则，它允许用户在编辑器中看到最终的输出结果。 5.1.2 图像获取方式 在实验中，我们需要获取场景中已经标记好的迷宫，需要通过拍照实现。除此以外，我们还希望可以上传图片的方式进行处理，从而应对实验环境中没有已标记迷宫的问题。
5.1.3 图像处理流程 我们希望能使用OpenCV完成图像的处理，识别图像中的迷宫，并生成格式化的迷宫数据。OpenCV是一个用于计算机视觉和机器学习的库，可以用来进行文件扫描和图像处理。下面是使用OpenCV进行处理的主要流程：
导入必要的SDK并获取文件列表；对图像进行预处理；对处理后的图像进行分析；图像透视变换与直线识别；模糊处理；结果输出。 5.1.4 数据约定与数据传输 由于需要将迷宫识别的结果发送给服务器，我们在开发前约定了传输的数据格式：通过40位长的01字符串，按照行优先的顺序对应到迷宫的每一条边上，以此表示迷宫的结构。
5.2 VR与服务器端需求与可行性分析 5.2.1 控制平台设计及三维虚拟场景呈现 创作平台的设计需要简单易用，同时还要保证其能够获取物理空间中的设计图，这需要使用相应的技术实现图像识别和数据采集。将物理空间中的设计图转换为三维虚拟场景需要使用三维建模技术，同时需要确保转换后的虚拟场景与原图的精度和比例一致，否则可能会影响用户的使用体验。在VR端呈现虚拟场景需要使用VR技术，包括虚拟现实设备、渲染引擎、交互技术等，同时需要注意性能和体验的平衡，以确保用户可以流畅地体验虚拟场景。 5.2.2 双人体验系统设计及虚拟迷宫转换 双人体验系统需要支持两名用户的佩戴VR头盔进行漫游和协作，这需要使用实时通信实现用户间的数据传输和场景同步。将二维迷宫转换为三维虚拟迷宫需要使用三维建模技术和数据转换技术，同时需要注意迷宫的设计精度和用户可操作性，以确保用户可以顺畅地进行漫游和交互。实现用户在虚拟迷宫中的漫游和交互需要使用虚拟现实技术，包括头部追踪、手部追踪、碰撞检测、物理模拟等，同时需要注意用户体验和场景性能的平衡，确保用户可以愉悦地探索虚拟迷宫。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc46e51f4a9950a7f892cd52ab00d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80caa91764709b1067061709380c898f/" rel="bookmark">
			Kafka/Spark消费topic到写出到topic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Kafka的工具类 1.1 从kafka消费数据的方法 消费者代码 def getKafkaDStream(ssc : StreamingContext , topic: String , groupId:String ) ={ consumerConfigs.put(ConsumerConfig.GROUP_ID_CONFIG , groupId) val kafkaDStream: InputDStream[ConsumerRecord[String, String]] = KafkaUtils.createDirectStream(ssc, LocationStrategies.PreferConsistent, ConsumerStrategies.Subscribe[String, String](Array(topic), consumerConfigs)) kafkaDStream } 注意点 consumerConfigs是定义的可变的map的类型的，具体如下 private val consumerConfigs: mutable.Map[String, Object] = mutable.Map[String,Object]( // kafka集群位置 ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG -&gt; MyPropsUtils(MyConfig.KAFKA_BOOTSTRAP_SERVERS), // kv反序列化器 ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG -&gt; "org.apache.kafka.common.serialization.StringDeserializer", ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG -&gt; "org.apache.kafka.common.serialization.StringDeserializer", // groupId // offset提交 自动 手动 ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG -&gt; "true", //自动提交的时间间隔 //ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG // offset重置 "latest" "earliest" ConsumerConfig.AUTO_OFFSET_RESET_CONFIG -&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80caa91764709b1067061709380c898f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5ea157088df8bef1802641a232a8ea/" rel="bookmark">
			基于Android Studio的日记App课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、课程设计介绍
二、系统模块介绍及展示
1.系统目录结构图
2.数据库设计
3.系统模块测试
（1）用户认证模块测试
（2）日记管理模块测试
（3）清单管理模块测试
（4）个人信息模块测试
三、代码展示
一、课程设计介绍 在这样的背景下，开发一个基于Android的生活记事本APP具有重要的研究意义和实际应用价值。
首先，该APP可以提供更加丰富多样的内容记录方式。除了文本输入外，还支持图片和视频的添加，使用户可以更加直观地记录生活中的点滴瞬间。这不仅满足了个人情感表达的需要，还可以帮助用户更好地回忆和分享生活中的重要时刻。
其次，该APP的开发过程将涉及到Android平台的应用开发技术，包括UI设计、多媒体处理、数据存储与管理等方面的知识。通过参与该项目，研究人员和开发者可以掌握和运用这些技术，提升自己的实际应用能力和解决问题的能力。
此外，通过研究和开发该APP，还可以挖掘用户对多媒体记录的需求和习惯，为未来智能手机应用的改进提供参考。通过用户使用数据的分析，可以了解用户对不同类型多媒体内容的喜好程度，从而优化APP的功能设计，更好地满足用户的需求。
最后，该APP还可以作为社交平台的一个重要组成部分。用户可以将记录下的生活片段分享给他人，与朋友们一起回忆和交流。这不仅可以增进人与人之间的情感，还可以促进社交网络的建立和扩大。
二、系统模块介绍及展示 1.系统目录结构图 基于Android的生活记事本APP 目录结构
文件夹
文件夹
子文件
用处
备注
manifest
AndroidManifest.xml
入口文件
java
Adapter
DiaryRecyclerAdapter
存放适配器
bean
BaseBean
数据基础类
ChecklistItem
清单实体类
Diary
日记实体类
User
用户实体类
data
(impl)DiaryDataSourceImpl
数据存储
DiaryDataSource
数据源
处理数据（如增删改查）
db
DbHelper
日记列表数据库
存放数据库的操作数据（创建一张日记表）
DatabaseHelper
清单列表数据库
ui
BaseActivity
返回页面
ChecklistActivity
清单列表页面
DiaryBrowseActivity
日记详情页面
DiaryEditActivity
发布日记页面
DiarylistActivity
日记列表页面
MainActivity
登录页面
MineActivity
个人信息页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db5ea157088df8bef1802641a232a8ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba4b55236c8f7a42541e46117b6c59b/" rel="bookmark">
			解决MySQL8.0本地计算机上的MySQL服务启动后停止没有报告任何错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.启动MySQL的错误信息如下 （1）“本地计算机上的MySQL服务启动后停止。某些服务在未由其他服务或程序使用时将自动停止。”
（2）又在PowerShell中运行"net start MySQL"，服务启动失败。“MySQL 服务无法启动。服务没有报告任何错误。”
最粗暴的解决方法就是将服务卸载重新安装。也可以参考如下的解决方法：
2.解决方法 解决方法可能为如下的一种，寻找自己MySQL的问题，并做修改
2.1 修改my.ini编码为ANSI （1）在服务中右击属性，可查看my.ini文件的位置
（2）将原文件重命名为my.ini.bak，并用记事本打开。
（3）
（4）保存时可能会提示含有Unicode字符，直接点确定。
（5）完成后在PowerShell中运行"net start MySQL"，或者直接在服务中启动等待时间较长，但服务成功启动。
2.2 MySQL服务可执行文件的路径不正确 （1）查看可执行文件的路径
控制面板-管理工具-服务-&gt;选中mysql服务-&gt;右键-&gt;属性，就是我们想要修改的MySQL服务可执行文件的路径内容，但是无法直接编辑
（2）修改可执行文件的路径
①快捷键WIN+R，输入regedit，回车打开注册表编辑器
②根据路径HKEY_LOCAL_MACHINE -&gt; SYSTEME -&gt; CurrentControlSet -&gt; services
，例如我的是mysql57
③选中ImagePath右键 -&gt;修改 -&gt; 修改mysqld.exe和my.nini自己配置文件所在正确路径
这是我的路径，可做参考：
“D:\DBSoftWare\mysql\mysql8\bin\mysqld.exe” --defaults-file=“D:\DBSoftWare\mysql\mysql8\my.ini” MySQL
④修改ImagePath值后，回到mysql服务-&gt;右键-&gt;属性 -&gt;常规 ，查看发现可执行文件的路径并没有被更新
⑤此时进入到mysql安装目录bin目录，找到mysqld.exe；双击mysqld.exe，此时服务属性中的"可执行文件的路径"配置才
会被更新成注册表中的。
⑥更新配置后需要通过任务管理器-&gt;mysqld.exe-&gt;右键-&gt;结束mysqld.exe进程，否则后续可能启动不了mysql服务
⑦重启mysql服务。快捷键WIN+R，输入cmd，重启mysql命令net start mysql
2.3 关闭系统管理中的mysql80服务 （1）点击服务和应用程序，找到服务中的MySQL80
（2）右击MySQL80，点击停止
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8636798fc87eecac31c376f8317d00be/" rel="bookmark">
			MySQL中如何为字段设置默认值？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中，我们可以为表的字段设置默认值，以确保在插入新记录时，如果没有为该字段指定值，将使用默认值。这在许多情况下都非常有用，特别是当我们希望在插入数据时自动填充某些字段，或者当我们想要为字段提供一个通用的默认值。
要为MySQL表中的字段设置默认值，我们可以在创建表时或者在已存在的表上使用ALTER TABLE语句进行修改。下面将展示两种设置默认值的方法。
方法一：创建表时设置默认值
在创建表时，可以使用DEFAULT关键字为字段设置默认值。以下是一个示例：
CREATE TABLE my_table ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, age INT DEFAULT 18 ); 在上面的示例中，age字段被设置为默认值18。如果在插入新记录时没有为age字段提供值，将默认为18。
方法二：使用ALTER TABLE语句修改默认值
如果表已经存在，我们可以使用ALTER TABLE语句来修改字段的默认值。以下是一个示例：
ALTER TABLE my_table ALTER COLUMN age SET DEFAULT 18; 上述语句将更改现有表my_table中的age字段的默认值为18。之后，如果在插入新记录时没有为age字段提供值，将使用默认值18。
注意事项：
如果要删除字段的默认值，可以使用ALTER TABLE语句，并将DEFAULT关键字与NULL关键字一起使用，示例如下：
ALTER TABLE my_table ALTER COLUMN age DROP DEFAULT; ``` 上述语句将删除`my_table`表中`age`字段的默认值。 默认值可以是常量、表达式或函数调用。例如，可以将字段的默认值设置为当前日期：
ALTER TABLE my_table ALTER COLUMN created_at SET DEFAULT CURRENT_DATE; ``` 上述语句将为`my_table`表中的`created_at`字段设置默认值为当前日期。 通过以上两种方法之一，我们可以在MySQL中为字段设置默认值。这使得插入新记录时更加方便，同时确保数据的完整性和一致性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6327c7525fe1e9e0b4d84580f194521f/" rel="bookmark">
			ESP-IDF学习——1.环境安装与hello-world
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP-IDF学习——1.环境安装与hello-world 0.前言一、环境搭建1.官方IDE工具2.vscode图形化配置 二、示例工程三、自定义工程四、点灯五、总结 0.前言 最近在学习freertos，但由于买的书还没到，所以先捣鼓捣鼓ESP-IDF，因为这个比Arduino更接近底层，并且也是基于FreeRTOS实现的，所以先熟悉一些相关基础功能。
一、环境搭建 ESP-IDF支持windows、linux、MacOS，但总体比较起来，windows下安装似乎更加方便，所以笔者就以windows作为开发环境。Linux和MacOS用户可以参考官方安装教程。
windows下的安装也可以分为官方IDE和vscode开发环境两种：
1.官方IDE工具 可以直接进入官方的下载链接进行下载和安装。除此之外，还需要安装python3，安装完成后即可通过桌面installer快捷方式中的命令行进行一系列的配置和编译。
2.vscode图形化配置 官方ide是基于eclipse界面做的，并且编译和下载还需要执行idf.py命令，比较繁琐，所以笔者更喜欢使用vscode图形化界面进行开发，还可以使用ai代码工具辅助开发，更加方便。
在vscode中安装Espressif IDF插件：
然后会跳转到配置界面，如果没有跳转，在vscode的命令行中输入 ESP-IDF: Configure ESP-IDF extension即可进入配置界面，进入express即可配置：
download server可以选择github(需要网络环境)，也可以选择Espressif(乐鑫国内下载地址)，如果事先有安装官方ide和python，则version可以选择从本地查找，如果未安装，则可以选择一个release version，然后在下方选择一个安装地址，点击install即可在线安装(建议有良好的网络环境)。
二、示例工程 安装完成后，在vscode命令行中输入ESP-IDF：New Project，即可新建工程：
选择如下选项即可加载示例的hello_world工程：
编译之前需要在menuconfig中选择芯片flash大小，打开图形化工具，搜索flash设置即可编译和烧录。示例工程的功能为启动后打印一次hello world，然后十秒后重启板子。
三、自定义工程 在创建工程时选择sample project即可创建空白项目：
将FreeRTOS的头文件包含进来，即可使用相关api。这里有两个地方需要注意，如果使用printf时未添加换行符，则需要使用fflush(stdout)将缓冲区中的数据打印出来。另外vTaskDelay(1000)函数的延时为1000个时钟tick，所以想要延时1s，需要除以当前的时间周期，在menuconfig中查找tick即可配置相关参数。
程序的结果即为每隔一秒打印一次hello world。
四、点灯 笔者的板子上有两颗LED灯，就从简单的led闪烁开始。
main.c
#include &lt;stdio.h&gt; #include "freertos/FreeRTOS.h" #include "freertos/task.h" #include "driver/gpio.h" uint32_t led_staus = 0; void app_main(void) { //GPIO初始化 gpio_reset_pin(GPIO_NUM_12); gpio_set_direction(GPIO_NUM_12, GPIO_MODE_OUTPUT); gpio_reset_pin(GPIO_NUM_13); gpio_set_direction(GPIO_NUM_13, GPIO_MODE_OUTPUT); for(;;) { //设置引脚输出电平 gpio_set_level(GPIO_NUM_12, led_staus); gpio_set_level(GPIO_NUM_13, !led_staus); led_staus = !led_staus; vTaskDelay(1000 / portTICK_PERIOD_MS); } } 编译烧写后即可看见LED闪烁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6327c7525fe1e9e0b4d84580f194521f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83afb91a574bba2383be20fabd0109f5/" rel="bookmark">
			c语言每日一练(15)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
每日一练系列，每一期都包含5道选择题，2道编程题，博主会尽可能详细地进行讲解，令初学者也能听的清晰。每日一练系列会持续更新，上学期间将看学业情况更新。
五道选择题： 1、程序运行的结果为（）
#include&lt;stdio.h&gt; int main() { int pad = 0; int pAd = 0; int sum = 5; pad = 5; pAd = (sum++,pAd++, ++pAd); printf("%d %d\n", pAd,pad); } A、1,5 B、2,5 C、1,6 D、2,6
解析：首先定义sum和pad为5，接着是一串逗号表达式，从左往右进行，最后的值为最后一个表达式，我们可以走一下，sum++，令sum为6，pAd++，令pAd=1（注意：这里不用什么前置后置，你可以把逗号表达式之间的表达式看作一个单独的区块，计算机会执行完这个区块的内容才去执行别的），最后一步可以看作pAd=(++pAd)，独立区块++pAd先执行，令pAd为2，，pad一直为5，所以最后打印出来的结果为，2，5，选B
前置后置结果一致 ,证明可以看作独立区块
2、程序运行的结果为（）
#include &lt;stdio.h&gt; int sum(int a) { int c = 0; static int b = 3; c += 1; b += 2; return (a + b + c); } int main() { int i; int a = 2; for (i = 0; i &lt; 5; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83afb91a574bba2383be20fabd0109f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0046a0a10d411a645d25dc1975d1246/" rel="bookmark">
			SkyWalking快速上手（一）——安装单机版SkyWalking、使用SkyWalking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是SkyWalking为什么选择SkyWalking安装步骤前置条件环境要求下载 SkyWalking 配置 SkyWalkingSkywalking 使用Agent 配置Collector 配置 启动 SkyWalking配置SkyWalking代理 SkyWalking的监控功能分布式调用链追踪性能指标监控告警和报警 总结 什么是SkyWalking SkyWalking是一个开源的分布式系统跟踪、监测和分析工具。它可以帮助我们实时了解分布式系统的性能指标、追踪调用链以及分析问题根因。SkyWalking支持多种语言和框架，可以与Java、.NET、Node.js等应用程序集成，并提供丰富的监控和分析功能。
为什么选择SkyWalking 分布式追踪：SkyWalking可以跟踪分布式系统中不同服务之间的调用关系，帮助我们定位性能瓶颈和故障根源。性能监测：SkyWalking可以监控关键性能指标，如请求响应时间、吞吐量等，帮助我们评估系统的性能状况。告警和报警：SkyWalking支持设置告警规则，并在达到指定条件时发送报警通知，帮助我们及时发现和解决问题。易于集成：SkyWalking提供了与多种常见技术栈的集成方案，可以快速将其集成到我们的应用程序中。 安装步骤 前置条件 在开始安装 SkyWalking 之前，确保满足以下前置条件：
Java 运行环境已经安装并配置好。确定要监控的应用程序已经部署并运行。 环境要求 ● JDK 版本：JKD8 ~ JDK17 之间
● 端口：
○ 11800：后端监听 gRPC API 的端口
○ 12800：后端监听 HTTP REST API 的端口
○ 8080：web UI 界面端口
# Linux / macOS netstat -an | grep 8080 # windows netstat -ano | findstr 8080 下载 SkyWalking 首先，从 SkyWalking 的官方网站（https://skywalking.apache.org/downloads/ ）下载最新的发布版本。选择适合你系统的压缩包，并解压到你希望安装的目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0046a0a10d411a645d25dc1975d1246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066513955a9a21870a18b3dcd230ac7e/" rel="bookmark">
			云计算平台运维与开发（初级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云计算概述 1、云计算特点被普遍接受的云计算特点如下：2、云计算服务形式PaaS的主要作用是将一个开发和运行平台作为服务提供给用户，而IaaS的主要作用是提供虚拟机或者其他资源作为服务提供给用户。接下来，将在七个方面对PaaS和IaaS进行比较：3、云计算的应用基于Vmware部署centos操作系统1、环境准备2、环境部署1）点击新建虚拟机2）点击自定义3）默认，下一步4）稍后安装操作系统5）选择客户机操作系统（Linux centos 64）6）更改虚拟机名称（不安装在C盘）7）默认8）分配虚拟机内存9）选择网络类型10)选择I/0控制器类型11)选择磁盘类型12）选择磁盘13）选择磁盘容量14）下一步，完成15）添加镜像16）开启虚拟机17）鼠标光标选中第一行18）进入安装操作系统界面（点击continue继续）19）进入安装部署界面（时区选择中国上海）done（完成）自动分区手动分区1手动分区2手动分区3手动分区4手动分区5 20）选择网络21）创建用户密码22）完成重启虚拟机 使用终端连接虚拟机通过finalshell 连接到虚拟机双击host1 ，接收并保存密码 1、云计算特点 云计算是通过使计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将与互联网更相似。这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。
好比是从古老的单台发电机模式转向了电厂集中供电的模式。它意味着计算能力也可以作为一种商品进行流通，就像煤气、水电一样，取用方便，费用低廉。最大的不同在于，它是通过互联网进行传输的。
被普遍接受的云计算特点如下： 1.超大规模。“云”具有相当的规模，Google云计算已经拥有100多万台服务器， Amazon、IBM、微软、Yahoo等的“云”均拥有几十万台服务器。企业私有云一般拥有数百上千台服务器。“云”能赋予用户前所未有的计算能力。
2.虚拟化。云计算支持用户在任意位置、使用各种终端获取应用服务。所请求的资源来自“云”，而不是固定的有形的实体。应用在“云”中某处运行，但实际上用户无需了解、也不用担心应用运行的具体位置。只需要一台笔记本或者一个手机，就可以通过网络服务来实现我们需要的一切，甚至包括超级计算这样的任务。
3.高可靠性。“云”使用了数据多副本容错、计算节点同构可互换等措施来保障服务的高可靠性，使用云计算比使用本地计算机可靠。通用性。云计算不针对特定的应用，在“云”的支撑下可以构造出千变万化的应用，同一个“云”可以同时支撑不同的应用运行。
4.高可扩展性。“云”的规模可以动态伸缩，满足应用和用户规模增长的需要。按需服务。云”是一个庞大的资源池，你按需购买；云可以像自来水，电，煤气那样计费。
5.极其廉价。由于“云”的特殊容错措施可以采用极其廉价的节点来构成云，“云”的自动化集中式管理使大量企业无需负担日益高昂的数据中心管理成本，“云”的通用性使资源的利用率较之传统系统大幅提升，因此用户可以充分享受“云”的低成本优势，经常只要花费几百美元、几天时间就能完成以前需要数万美元、数月时间才能完成的任务。
6.潜在的危险性。云计算服务除了提供计算服务外，还必然提供了存储服务，并且云计算服务当前垄断在私人机构（企业）手中，他们仅能提供商业信用。对于政府、银行这样持有敏感数据的机构，如果使用云服务，必然存在潜在的危险。
2、云计算服务形式 任何一个在互联网上进行提供服务的公司，都可称之为云计算公司。而云计算提供的服务，我们可以将其分成以下几个层次：
Infrastructure-as-a-Service (基础设施即服务，简称IaaS)
Platform-as-a-Service（平台即服务，简称PaaS）
Software-as-a-Service（软件即服务，简称SaaS）
基础设施在最下端，平台在中间，软件在顶端。别的一些“软”的层可以在这些层上面添加。
IaaS: Infrastructure-as-a-Service（基础设施即服务）
最下面的一层叫IaaS，有时也叫Hardware-as-a-Service。在云计算之前，如果用户想运营自己的网站或者是应用程序，必须购买服务器等高昂的硬件来运行网站或程序。
但是现在云计算有了IaaS，用户就可以直接租用IaaS提供的场外服务器，存储和网络硬件等设施，节省了维护成本和办公场地，用户可以在任何时候利用这些硬件来运行其应用。
一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat。不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。
PaaS: Platform-as-a-Service（平台即服务）
中间这一层就是所谓的PaaS，是指将软件研发的平台作为一种服务，提供给用户。你公司所有的开发都可以在这一层进行，节省了时间和资源。
PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。
一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的有AppFog 、 Mendix 、 Standing Cloud
SaaS: Software-as-a-Service（软件即服务）
最上一层就是SaaS。它是一种通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件，来管理企业经营活动。
这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行。
一些用作商务的SaaS应用包括Citrix的GoToMeeting，Cisco的WebEx，Salesforce的CRM，ADP，Workday和SuccessFactors。
Iaas和Paas之间的比较
PaaS的主要作用是将一个开发和运行平台作为服务提供给用户，而IaaS的主要作用是提供虚拟机或者其他资源作为服务提供给用户。接下来，将在七个方面对PaaS和IaaS进行比较： 开发环境：PaaS基本都会给开发者提供一整套包括IDE在内的开发和测试环境，而IaaS方面用户主要还是沿用之前比较熟悉那套开发环境，但是因为之前那套开发环境在和云的整合方面比较欠缺，所以使用起来不是很方便。
2)
支持的应用：因为IaaS主要是提供虚拟机，而且普通的虚拟机能支持多种操作系统，所以IaaS支持的应用的范围是非常广泛的。但如果要让一个应用能跑在某个PaaS平台不是一件轻松的事，因为不仅需要确保这个应用是基于这个平台所支持的语言，而且也要确保这个应用只能调用这个平台所支持的API，如果这个应用调用了平台所不支持的API，那么就需要对这个应用进行修改。
3)
开放标准：虽然很多IaaS平台都存在一定的私有功能，但是由于OVF等协议的存在，使得IaaS在跨平台和避免被供应商锁定这两面是稳步前进的。而PaaS平台的情况则不容乐观，因为不论是Google的App
Engine，还是Salesforce的http://Force.com都存在一定的私有API。 4)
可伸缩性：PaaS平台会自动调整资源来帮助运行于其上的应用更好地应对突发流量。而IaaS平台则需要开发人员手动对资源进行调整才能应对。 5) 整合率和经济性： PaaS平台整合率是非常高，比如PaaS的代表Google App
Engine能在一台服务器上承载成千上万的应用，而普通的IaaS平台的整合率最多也不会超过100，而且普遍在10左右，使得IaaS的经济性不如PaaS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/066513955a9a21870a18b3dcd230ac7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b87ccfa46a42e5206b476cf0f7fd9b/" rel="bookmark">
			【计算机视觉】Vision Transformers算法介绍合集（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Transformer in Transformer二、Bottleneck Transformer三、Pyramid Vision Transformer v2四、Class-Attention in Image Transformers五、Co-Scale Conv-attentional Image Transformer六、XCiT七、Focal Transformers八、CrossViT九、ConViT十、CrossTransformers十一、nnFormer十二、VATT十三、Convolution-enhanced image Transformer十四、DeepViT 一、Transformer in Transformer Transformer 是一种最初应用于 NLP 任务的基于自注意力的神经网络。 最近，提出了纯基于变压器的模型来解决计算机视觉问题。 这些视觉转换器通常将图像视为一系列补丁，而忽略每个补丁内部的内在结构信息。 在本文中，我们提出了一种新颖的 Transformer-iN-Transformer (TNT) 模型，用于对块级和像素级表示进行建模。 在每个 TNT 块中，外部变压器块用于处理补丁嵌入，内部变压器块从像素嵌入中提取局部特征。 像素级特征通过线性变换层投影到补丁嵌入的空间，然后添加到补丁中。 通过堆叠 TNT 块，我们构建了用于图像识别的 TNT 模型。
二、Bottleneck Transformer Bottleneck Transformer (BoTNet) 是一种图像分类模型，它结合了多种计算机视觉任务的自注意力，包括图像分类、对象检测和实例分割。 通过仅在 ResNet 的最后三个瓶颈块中将空间卷积替换为全局自注意力，并且没有其他任何更改，该方法在实例分割和对象检测方面显着改进了基线，同时还减少了参数，并且延迟开销最小。
三、Pyramid Vision Transformer v2 Pyramid Vision Transformer v2 (PVTv2) 是一种用于检测和分割任务的 Vision Transformer。 它通过多项设计改进对 PVTv1 进行了改进：(1) 重叠补丁嵌入，(2) 卷积前馈网络，以及 (3) 与 PVTv1 框架正交的线性复杂性注意层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b87ccfa46a42e5206b476cf0f7fd9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5afac8887425639a1c571710ed5d3a2/" rel="bookmark">
			解决django.core.exceptions.ImproperlyConfigured: Requested setting LOGGING_CONFIG, but settings...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发Django项目时，调整了django文件目录结构
同时配置完自己的配置文件路径后
在终端执行python manage.py runserver命令启动django项目时，报以下错误：
django.core.exceptions.ImproperlyConfigured: Requested setting LOGGING_CONFIG, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings. 解决办法 依次点击File -&gt; Settings -&gt; Build, Execution,Deployment -&gt; Console -&gt; Django Console 然后新增环境变量：
DJANGO_SETTINGS_MODULE = luffy项目.settings.develop 同理 若点击pycharm中的绿色小三角启动django项目也报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b526908f9e761e3c05a8fdef031ac5/" rel="bookmark">
			SpringBoot启动过程深度解析——BeanDefinition创建-ConfigurationClassPostProcessor执行详细流程解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot启动过程深度解析——BeanDefinition创建-ConfigurationClassPostProcessor执行详细流程解析 BeanDefinition是什么？ BeanDefinition 是Spring框架对 Bean 定义的配置元信息接口，Bean的创建依靠的是BeanDefinition的信息，BeanDefinition包含以下功能： Bean 的类名、父 bean 名称、是否为 primary、 Bean 行为配置信息，作用域、自动绑定模式、生命周期回调、延迟加载、初始方法、销毁方法等 Bean 之间的依赖设置，dependencies 构造参数、属性设置 Spring启动过程中，Bean类是怎么被检测到并且生成对应的BeanDefinition的？ ConfigurationClassPostProcessor执行详细流程图 如何创建自定义BeanDefinition并且交给容器创建Bean？ 前提：需要在Spring统一创建Bean之前，创建好BeanDefinition并注册到Spring容器中 手动注册的方法：实现BeanDefinitionRegisterPostProcessor接口，在实现的方法中可以通过扫描一些指定的类，或直接创建指定类的BeanDefinition注册到容器 自动注册的方法：通过@Configuration配置类，声明@Import类或@Bean方法。Spring启动过程会进行自动装配 Spring启动过程中BeanDefinition创建流程-源码 SpringBoot启动
@SpringBootApplication public class Main { public static void main(String[] args) { new SpringApplication(Main.class).run(); } } 调用AbstractApplicationContext#refresh方法
public class AbstractApplicationContext{ public void refresh() throws BeansException, IllegalStateException { //... //... //... // Invoke factory processors registered as beans in the context. // 调用各种beanFactory处理器 invokeBeanFactoryPostProcessors(beanFactory); //... //... //... } } 调用AbstractApplicationContext#invokeBeanFactoryPostProcessors方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28b526908f9e761e3c05a8fdef031ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70dddab9f85436c9c046431139ec489/" rel="bookmark">
			微信小程序 动漫游戏资讯推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置文件 (自动编号、配置参数名称、配置参数值)；
系统的设计与实现采用Spring、SpringMVC和MyBatis作为主体框架,系统设计遵循界面层、业务逻辑层和数据访问层的Web开发三层架构。采用B/S结构,使得系统更加容易维护。系统的设计与实现主要实现角色有管理员和用户,管理员在后台管理用户模块、用户表模块、推荐信息模块、token表模块、收藏表模块、新闻资讯模块、留言板模块、类型模块、个人推荐模块、推荐信息评论表模块、配置文件模块。使用Spring作为项目管理工具对系统的设计与实现各个模块进行管理,优化代码结构。后台采用Java语言开发,前台页面和后台管理页面使用Bootstrap,JSP,JavaScript,HTML,CSS等技术开发,使用MySql作为数据持久化存储工具对系统的设计与实现的用户等角色权限对应的功能等进行存储
推荐信息评论表 (自动编号、创建时间、用户id、用户名、回复内容、关联表id、评论内容)；
个人推荐 (自动编号、推荐编号、个人账号、发布日期、审核回复、相关图片、姓名、是否审核、用户id、创建时间、推荐原因、推荐名称、推荐内容)；
类型 (自动编号、创建时间、类型)；系统具有良好的集成性，提供标准接口，以实现与其他相关系统的功能和数据集成。开放性好，便于系统的升级维护、以及与各种信息系统进行集成。功能定位充分考虑平台服务对象的需求。
一个微信小程序由.js、.json、.wxml、.wxss四种文件构成：
.js：js脚本逻辑文件，跟我们以前写的js一样。
.json：json配置文件，以json格式存储一些配置。
.wxml：wxml模板文件，跟HTML类似。
.wxss：wxss样式文件，对比css，用来调整页面样式。
JSON配置
一个基本的程序包含app.json、project.config.json、logs.json三个json文件，它们分别有不同的用途：
app.json：对当前小程序的全局配置，包括小程序的所有页面路径、界面表现、网络超时时间、底部tab等。（详细内容参考小程序的app.json）
project.config.json：通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当换了另外一台电脑重新安装工具的时候，还要重新配置。
考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，我们在工具上做的任何配置都会写入到这个文件，当重新安装工具或者换电脑工作时，只要载入同一个项目的代码包，开发者工具就自动会帮恢复到当时开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。
page.json：这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。
如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。
前端技术：nodejs+vue+elementui
留言板 (自动编号、回复内容、创建时间、用户名、留言内容、留言人id)；
新闻资讯 (自动编号、标题、图片、内容、创建时间、简介)；
收藏表 (自动编号、收藏id、收藏图片、创建时间、表名、收藏名称、用户id)；
token表 (自动编号、表名、角色、用户名、新增时间、过期时间、密码、用户id)；
推荐信息 (自动编号、发布日期、相关图片、赞、类型、推荐名称、姓名、推荐原因、推荐内容、踩、创建时间、推荐编号、个人账号)；
用户表 (自动编号、新增时间、角色、用户名、密码)；
用户 (自动编号、邮箱、手机号码、相片、性别、创建时间、姓名、个人账号、密码)；
目 录
摘 要 I
Pick to I
1绪论 1
1.1项目研究的背景 1
1.2开发意义 1
1.3项目研究现状及内容 1
1.4论文结构 2
2开发技术介绍 2
2.2 java简介 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e70dddab9f85436c9c046431139ec489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcf4c9109cb585acc2d86362053771af/" rel="bookmark">
			Rocky Linux 安装图解（替代centos）服务器&#43;桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos自从20年底转变为不稳定版本后，有很多替代方案
经过近3年的发展，rocky linux算是一个比较好的选择，一是依照red hat企业版来做，二是rocky的发起者也是centos的创始人
如果想安装debian，可以参考：debian图解安装
如果想安装ubuntu，可以参考：ubuntu图解安装
2023.9.17更新教程，rocky版本9.2
一、下载烧录镜像 1.下载 下载rocky linux镜像
官方: rocky linux
如果下载较慢，复制链接到下载工具
用作服务器的，下载minimal最合适
如果用作桌面的，下载DVD的选项，大概8.8g左右，如果下载最小的，则没有桌面环境
2.烧录 如果使用虚拟机安装，就不需要烧录到U盘了
可以使用rufus烧录镜像
官方: rufus
选择下载的.ios镜像，选择烧录到的U盘，开始，中间如果杀毒软件报警，请放行。
所有都选默认即可，如果烧录的时候提示下载额外组件，请务必确定。
选择gpt分区类型和uefi引导类型
二、开机和设备启动 虚拟机安装直接挂载.ios文件即可
1.插入U盘 将U盘在开机前插入usb接口。
不同主板引导选择界面不同，通常是detele、f10、f11、f2几个中的一个（开机时通常也会提示）
这几个，在开机的时候会提示。我演示的这个是超微的，f11进入选择
2.使用U盘进行引导 rocky linux默认用uefi引导，推荐用这种方式（如果是debian的话可以选择传统方式）
三、安装 1.直接选择第一个 Install Rocky Linux 9.2 如果安装桌面版的，可以尝试第二个，进入桌面环境然后安装
2.安装过程中语言选择 服务器建议选择English
桌面默认的中文即可，这个只是安装过程的，后面可以加语言。
3.设置root密码和创建用户 设置root密码，允许ssh登录
这个后期可以改，先允许，方便初期的维护。设置完成后左上角done
设置普通用户
建议设置，如果设置了root，也可以省略这一步
4.设置分区 我这里是2块硬盘+1个安装U盘，选择需要分区的硬盘，选择手动分区，然后done
注意一点，rocky的默认文件系统是xfs，也可以选择ext4
注意，如果有多个硬盘，可以一并勾选，这样可以一次性分区完成，进入系统后就不用再分区或者挂载了
删除旧分区
我这里原本装的有系统，所以先删除原来的分区（如果之前没装过系统，就跳过这一步）
会提示是否删除所有分区，直接点是，原来系统的分区就不见了
创建分区
如果是安装桌面的，直接使用自动分区即可，分的很合理。
桌面端最大的分区为/home,这个分区用来放各种用户数据
除了/boot和/boot/efi分区，其余都可以进行encrypt加密，默认不加密，建议不熟悉的不要加密
如果是服务器用户，建议手动调整
关于分区，简单说一下，/boot引导分区和/根分区是必须要有的，其它的不分会挂载在/根分区下。
swap类似于windows的虚拟内存，我这台是128g内存，就给swap 32g吧（不分也行）
/var通常作为服务器存放数据的地方（每个人的习惯不同，但是通常在这个目录），所以剩余的空间都给/var（如果是桌面的，就分给/home），使用默认的lvm即可，这样后面可以方便扩容。当然也可以用非lvm模式
注意：lvm是逻辑磁盘，如果想要了解使用可以看这篇：lvm和raid，我这里不再说明
提示是否应用修改
5.选择安装类型 如果是桌面端，选择workstation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcf4c9109cb585acc2d86362053771af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed0a28c9fe4274c7a091b5e049a4968/" rel="bookmark">
			如何实现Web应用、网站状态的监控？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何实现Web应用、网站状态的监控？ 关键词：网站监控,服务器监控,页面性能监控,用户体验监控本文通过代码分析、网站应用介绍网站状态监控的方式下文主要分为网站应用、技术实现两部分 一、网站应用 现在网络上已经存在一些Web网站监控的服务，虽然功能五花八门，但限制较大，需付费使用本文介绍的技术运行网站见下方地址，不会关闭，可以直接使用一个朴实无华且免费的WEB网站监控工具先看下效果
1. 打开网站 【传送门】 https://www.xujian.tech/monitor 2. 微信扫码登录 这里通过微信扫码取得小程序openid，利用openid标记用户，不涉及隐私
扫码完成后会自动跳转到系统 3. 进入监控表 进入系统后，选中左侧菜单进入监控表页面
4. 添加监控器 监控器支持POST、GET两种请求方式GET请求时，如有参数，请直接放置在地址中POST请求时，如有参数，请在表单中填写JSON键值对对象Header如果有需要，也可按JSON对象方式填写仅需如下三步，即可完成设置提交后，点击刷新即可在页面上看到监控器记录（此时还未执行）
5. 说明和操作 5.1 关于成功率 初次时显示“未执行”，执行正确计算 5.2 关于监控频率 每次执行完成计算下一次执行时间，默认30分钟一次（免费用户暂不支持自定义频率）计时器每5分钟执行一次，发现监控器执行时间小于当前时间的，就执行请求所以监控频率并非严格按照30分钟一次 5.2 相关操作 新增/编辑监控器后，可以点击“立即执行”进行一次请求，观察设置是否正确需要修改时，可点击“编辑”按钮对监控器内容进行修改点击运行记录，可查看近期运行的情况运行记录中，点击结果复制，可以复制运行的结果（当返回内容大于512b的时候，只存储前512个内容）需要邮件通知的用户，可点击右上角头像设置邮箱，在系统异常的时候，会通过邮件进行提示，邮件内容如下：
6. 功能拓展 如果有更多建议、合作，请在本文下方留言或按网站提示添加作者 二、技术实现 1. 技术栈 实现一个监控器需前端、后端、数据库、缓存等技术本站主要应用了以下技术： 序号技术所属端1VUE前端2Vue Element Admin前端3Java后端4MySQL 数据库后端5Redis缓存后端6Nginx运维7MyBaits-plus后端 2. 核心代码 实现web应用监控的核心是定期按规则进行请求，并将结果记录，遇到错误时发送邮件提醒本文以在Spring Boot中实现为例，除Spring Boot基础依赖外，还需添加如下依赖 &lt;!--发送邮件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--糊涂工具，实现网络请求、工具类等--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.0&lt;/version&gt; &lt;/dependency&gt; 2.1 监控器实体 记录监控器基本属性、执行时间、统计结果等下方代码含实体和下次执行时间计算方法 @Data @Builder @TableName("m_monitor") public class MMonitor { @JsonFormat(shape = JsonFormat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ed0a28c9fe4274c7a091b5e049a4968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764b716b8cda8fdad2858cf4a9a6746f/" rel="bookmark">
			《Python趣味工具》——自制emoji2（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，我们将会完成以下2个内容：
绘制静态emoji总结turtle中常用的绘图函数 文章目录 一、绘制静态emoji：:sparkles: 画脸：:sparkles:绘制嘴巴：:sparkles:绘制眼白：绘制眼白-Part1：绘制眼白—part2： :sparkles:绘制黑眼珠： 三、完整代码：四、函数函数总结：运动控制命令：画笔控制命令：全局控制命令： 一、绘制静态emoji： 绘制方法：拆解绘制法
将绘图步骤拆解完成后，标记出各个部分的起始坐标点位，方便后面绘图。
✨ 画脸： 首先我们绘制圆脸部分，主要步骤是：
1.定义一个绘制圆脸的函数
2.用黑色画笔画圆
3.用金色填充圆的内部
示例代码如下：
# 从turtle模块中导入所有函数 from turtle import * # 定义draw_face()函数绘制脸部 # 首先，定义一个draw_face()函数绘制脸部 def draw_face(): # 进入函数的主体部分后，第一步需要将小乌龟放置到我们期待的位置：(-120,0) # 抬起画笔 penup() # 移动到坐标点为(-120,0)的地方 goto(-120,0) # 落笔 pendown() # 将画笔颜色设置为黑色"black" pencolor("black") # 将画笔粗细设置为4 pensize(4) # 调整海龟朝向-90度方向 seth(-90) # 开始填充颜色 begin_fill() # 画圆，圆的半径为130，圆心角为360度 circle(130,360) # 填充颜色为"gold" fillcolor("gold") # 停止填充颜色 end_fill() 相关步骤如下：
1.定义函数，设置初始位置
为了避免留下小乌龟从初始位置移动到(-120,0)的轨迹，我们可 以：
🐢penup()抬起小乌龟
🐢goto()把小乌龟移动到目标位置
🐢再使用pendown()放下小乌龟
2.设置颜色、大小和朝向
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764b716b8cda8fdad2858cf4a9a6746f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd529064f93f5ee2ed6f0501babc89b7/" rel="bookmark">
			Java实现远程文件复制(基于SCP命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是SCP命令1. SCP命令的基本语法2. 从本地复制到远程3. 从远程复制到本地 Java实现远程文件复制步骤1：准备环境步骤2：创建代码步骤3：运行代码结论 本文主要介绍SCP命令以及如何使用Java在不同的远程服务器之间使用SCP命令（安全复制协议）复制文件/文件夹。
什么是SCP命令 SCP是Secure Copy的简写，用于在Linux下进行远程拷贝文件的命令。它的主要优点是可以在不泄露敏感信息的情况下在远程服务器计算机之间传输文件。因为是基于SSH协议的，所以具有很强的安全性。
1. SCP命令的基本语法 SCP命令的基本语法如下：
scp [参数] [源文件] [目标路径] 其中：
参数：可以是一些选项，例如-r表示层级复制文件夹。源文件：要复制的文件或文件夹的路径。目标路径：文件复制到的目标路径，可以是远程服务器的路径，格式为[用户名]@[远程服务器IP]:[目标路径]。 参数说明：
-1： 强制scp命令使用协议ssh1-2： 强制scp命令使用协议ssh2-4： 强制scp命令只使用IPv4寻址-6： 强制scp命令只使用IPv6寻址-B： 使用批处理模式（传输过程中不询问传输口令或短语）-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p：保留原文件的修改时间，访问时间和访问权限。-q： 不显示传输进度条。-r： 递归复制整个目录。-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式。-P port：注意是大写的P, port是指定数据传输用到的端口号。-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 2. 从本地复制到远程 在本地服务器上将/opt/files目录下所有的文件传输到服务器192.168.158.128的/opt目录下，命令为：
scp -r /opt/files root@192.168.158.128:/opt/ 3. 从远程复制到本地 在本地服务器上操作，将服务器192.168.158.128上/opt目录下所有的文件全部复制到本地的/opt/files目录下，命令为：
scp -r root@192.168.158.128:/opt /opt/files/ Java实现远程文件复制 步骤1：准备环境 确保开发环境中安装了以下工具和库：
Java开发环境JSch库：用于连接和执行SCP命令 &lt;!-- jcraft JSch --&gt; &lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.53&lt;/version&gt; &lt;/dependency&gt; 因为命令执行的原因，需要确保服务器已经安装sshpass，主要用于自动化SSH密码输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd529064f93f5ee2ed6f0501babc89b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3fa71b9380e6af3e894b2b938d77440/" rel="bookmark">
			利用FreeRTOS在STM32中进行多线程操作（HAL库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、当我们移植了FreeRTOS之后，接下来就是该如何使用操作系统给我们带来的神奇操作了，首先我使用了四个线程，同时进行串口打印，按键操作以及温湿度的打印。 第一步，线程的创建，可以在main.c中直接创建，但我习惯新建一个文件夹，我在新建的creatTask.c文件中创建了这些线程 DHT11_Data_TypeDef DHT11_Measure; TaskHandle_t xHandleTask1; TaskHandle_t xHandleTask2; TaskHandle_t xHandleTask3; TaskHandle_t xHandleTask4; void Task1Function(void *param) { while(1) { printf("11111"); //HAL_Delay(2000); vTaskDelay(2000); } } void Task2Function(void *param) { while(1) { if(key_scan(1)==1) { printf("按键操作"); vTaskDelay(2000); } else{ printf("无按键操作"); vTaskDelay(2000); } } } void Task3Function(void *param) { //printf("333"); if(DHT11_Init()) { printf("DHT11 Init ERROR"); } while(1) { if(DHT11_Get_TemperAndHumi(&amp;DHT11_Measure) == 1) {	printf("\r\nDHT11: 温度%d℃,湿度: %d%%\r\n",DHT11_Measure.temp_int,DHT11_Measure.humi_int); vTaskDelay(2000); } } } void Task4Function(void *param) { while(1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3fa71b9380e6af3e894b2b938d77440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc7b02dd67f6f5b8c7ca860f11647a7/" rel="bookmark">
			翻转二叉树、还原二叉树、最近公共祖先
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻转二叉树： 若树为空树，那么返回；
若不为空，则先递归翻转左右子树，然后再将左右子树的结点互换。
void revert(int root){ if (root == -1){ return; } revert(nodes[root].left); revert(nodes[root].right); swap(nodes[root].left,nodes[root].right); } 先序中序还原二叉树、后序中序还原二叉树、层序中序还原二叉树 两个序列一个提供根结点，另一个用来划分左右子树
以先序中序还原二叉树为例，先序的第一个元素为该树的根结点，通过该根结点的编号，便可以将中序和先序的元素划分左右子树。左右子树的根结点就是该树的左右结点，同时该树的根结点又有可能是其父亲结点的左右孩子。
#include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; pre,in_; const int N = 55; struct binaryTree{ int left; int right; }nodes[N]; int buildTree(int preL,int preR,int inL,int inR){ /* 整个思路很简单，通过先序序列找出该子树的根结点 然后根据中序序列通过根结点root再将子树分为左子树和右子树。 返回根结点 */ if (preL &gt; preR)return -1; int root = pre[preL]; int rootindexofin;//找到root在中序序列中的位置 for (int i=inL;i&lt;=inR;i++){ if (in_[i] == root){ rootindexofin = i; break; } } // root的左子节点就是其左子树的根结点，反之其也可能是其父亲结点的左子节点/右子节点 int countof_LeftTree = rootindexofin - inL;//其左子树的结点数 nodes[root].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc7b02dd67f6f5b8c7ca860f11647a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337afea403db6df9e340c9db810a2276/" rel="bookmark">
			FreeRTOS的移植到STM32的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、利用Cubemx配置FreeRtos 第一步：点击ACCESS TO MCU SELECTOR 第二步：在Commerical Part Number中选择自己的开发板型号，我的是stm32vet6，搜索到之后，点击右下角的选择 第三步，我们就进入了配置页面，首先在System Core配置中断时钟等等，我们点击一下System Core 第四步，在System Core 中配置RCC 第五步，在System Core 中配置 SYS 这样我们的基础配置就配置结束了，大多时候利用cubemx去配置我们的开发版都是类似的基本操作，好，接下来我们配置FreeRTOS
第五步，点击Middleware，会发现有一个FREERTOS，我们点击它，在interface中选择CMSIS_V2 第六步，FreeRTOS的基础配置，这些根据不同的需求进行使能就可以了，基本咱们默认就可以了 第七步，创建线程，我们点击Tasks and Queues，点击Add，添加线程 第八步，配置线程，基本默认就行。 第九步，配置我们的始终，点击页面中，Clock Configuration，进入这个界面，我们直接在HCLK（MHZ），将这个拉到最高，也就是72，不同的开发板可能不同，然后回车，就会发现其他的都会自动配置好。 第十步，就是配置我们的文件名了，需要选择文件路径，文件名，还要将Toolchain /IDE选为 MDK-ARM，最后点击右上角CENERATE CODE，这样我们的cubemx配置FreeRtos配置就完成了。 二、直接将FreeRTOS的官网中下载的官方文件移植到我们的例程中 官网：FreeRTOS - Market leading RTOS (Real Time Operating System) for embedded systems with Internet of Things extensions
或者进入QQ群766566980，里面会提供免费的配置文件
第一步，我们可以自己新建一个文件夹，将配置文件全部放进去，一下是移植所需的所有代码 第二步，打开我们的例程，新建一个文件夹工程，将刚才我们所说的所有文件全选后，放进去。 第三步，引入我们相关的头文件，以下就是所需头文件的所在位置，路径可由自己定义的来寻找。 第四步，我们插入了头文件之后，编译一下，会出现报一些错误，其中大多数是FreeRTOSConfig.h文件打不开，是因为我们没有这个文件，这个文件在官方提供的文件Demo中有，我们可以直接复制粘贴过来过添加，我们选择自己的开发板型号和软件，我的开发板是stm32F103，软件是keil5，我们点击打开，会有一个FreeRtosConfig.h，我们可以复制粘贴到我们的工程下，也可以直接找到这个路径添加进去，就像我们上一步的方法添加头文件
第五步，我们添加后，配置发现还有一个error，这个错误在FreeRtosconfig.h,修改如下成如下配置。 这样我们的两种配置方法就完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99bfe5cc020cbc91ef66efff60cb4e9e/" rel="bookmark">
			使用Arcpy时发生“RuntimeError: ERROR 999998: Unexpected Error“错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：http://t.csdn.cn/hvfFq
此问题为内存不足，先提供两种解决办法：
1.修改环境设置，将处理的范围缩小至需要区域，减少内存需要(推荐）
import arcpy # Set the extent environment using a keyword arcpy.env.extent = "MAXOF" # Set the extent environment using the Extent class arcpy.env.extent = arcpy.Extent(-107.0, 38.0, -104.0, 40.0) # Set the extent environment using a space-delimited string arcpy.env.extent = "-107.0 38.0 -104.0 40.0" # Set the extent environment using a feature class arcpy.env.extent = "C:/data/StudyArea_perim.shp" # Set the extent environment using a raster arcpy.env.extent = "C:/data/StudyArea.tif" 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99bfe5cc020cbc91ef66efff60cb4e9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4386e34a85a6809c1be7032cbe14ea4/" rel="bookmark">
			yarn下载某个包时卡住手动下载解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手动下载依赖包： 如果你知道特定依赖包的 URL，你可以尝试手动下载该包并将其放置在 Yarn 的缓存目录中。然后再运行 yarn install。
Yarn 的缓存目录通常位于用户的主目录下的 .yarn-cache 文件夹中。具体的路径取决于操作系统。以下是一些常见操作系统的缓存目录路径示例：
在 macOS 上： 缓存目录位于用户主目录下的 ~/.yarn-cache。
在 Windows 上： 缓存目录通常位于用户主目录下的 C:\Users\&lt;YourUsername&gt;\.yarn-cache，其中 &lt;YourUsername&gt; 是你的用户名。
在 Linux 上： 缓存目录通常位于用户主目录下的 ~/.yarn-cache。
要手动查找缓存目录，你可以使用文件浏览器或终端来导航到相应的路径。一旦找到了缓存目录，你可以查看其中的内容，清除不需要的缓存文件，或手动添加依赖包到该目录中，以便 Yarn 在安装时不需要重新下载。但请注意，手动操作缓存目录需要谨慎，以免意外删除或破坏文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec3b53c9a7ea580f93fc707b1644032c/" rel="bookmark">
			如何冻结模型，避免 model.train() 改变模型部分模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何永久冻结参数
for name, param in self.llm_model.named_parameters(): param.requires_grad = False 虽然以上代码可以冻结模型参数，但无法保证冻结整个模型。
model.train() 会导致部分仍处于激活状态。
重写 model.train 来保证 model.train() 并不会改变模型的任何模块：
def disabled_train(self, mode=True): """Overwrite model.train with this function to make sure train/eval mode does not change anymore.""" return self model = your_model freeze_model = True if freeze_model: for _, param in self.llm_model.named_parameters(): param.requires_grad = False model.eval() model.train = disabled_train 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96fbe67569be8ae95a5aa505018397eb/" rel="bookmark">
			计算机网络(第八版)-第二章课后习题参考答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本答案制作并非完整来自该教材的习题辅导书，作者融合自己的学习理解，参考其他的文献，对答案略有删改，因此答案不具有权威性，还希望读者批判性的阅读，欢迎提出疑问，我会一一解答，一起加油吧，伙计们。
T2-01 物理层要解决哪些问题？物理层的主要特点是什么？
1.物理层要解决什么问题?
（1）物理层要尽可能地屏蔽掉物理设备和传输媒体，通信手段的不同，使数据链路层感觉不到这些差异，只考虑完成本层的协议和服务。
（2）给其服务用户（数据链路层）在一条物理的传输媒体上传送和接收比特流（一般为串行按顺序传输的比特流）的能力，为此，物理层应该解决物理连接的建立、维持和释放问题。
（3）在两个相邻系统之间唯一地标识数据电路
2.物理层的主要特点是什么？
（1）由于在 OSI 之前，许多物理规程或协议已经制定出来了，而且在数据通信领域中，这些物理规程已被许多商品化的设备所采用，加之，物理层协议涉及的范围广泛，所以至今没有按 OSI 的
抽象模型制定一套新的物理层协议，而是沿用已存在的物理规程，将物理层确定为描述与传输媒体接口的机械，电气，功能和规程特性。
（2）由于物理连接的方式很多，传输媒体的种类也很多，因此，具体的物理协议相当复杂。
T2-02 规程和协议有什么区别?
规程专指物理层的协议，而协议则泛指所有层上的协议。
T2-03 试给出数据通信系统的模型并说明其主要组成构建的作用。
1个典型的数据通信系统可以划分为三大部分，分别是发送系统、传输系统和接收系统，如下图:
其中，发送系统由源点和发送器 组成；接受系统由接收器和终点组成。
①源点：源点设备产生要传输的数据。源点又称为源站。
②发送器：通常源点生成的数据要通过发送器编码后才能在传输系统中进行传输。
③接收器：接收传输系统传送过来的信号，并将其转换为能够被目的设备处理的信息。
④终点：终点设备从接收器获取传送过来的信息，终点又称为目的站传输系统。
T3-04 试解释以下名词：数据，信号，模拟数据，模拟信号，基带信号，带通信号，数字数据，数字信号，码元，单工通信，半双工通信，全双工通信，串行传输，并行传输。
1.数据: 运送信息的实体 。
这话说得着实不好理解哈，其实 “实体” 是“具体化的东西”，而“信息”是抽象的，笼统的。再反过头来看定义，“运送消息的实体”，那么就是“消息”具体化后的东西咯，具体化有哪些东西？无非是音频、视频、文本等等。
而这些东西要能够在计算机中进行传输，使用，还要进行数字化，因此数据还有另外一个解释可以是“数字化的信息”。
2.信号:
则是数据的电气的或电磁的表现。可参考如下理解
3.模拟数据:
运送信息的模拟信号。
4.模拟信号:
连续变化的信号,可参考上图
5.数字信号:
取值为有限的几个离散值的信号,可参考上图。
6.数字数据:
取值为不连续数值的数据。
7.码元(code):
在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。
8.单工通信:
即只有一个方向的通信而没有反方向的交互。
9.半双工通信:
即通信和双方都可以发送信息，但不能双方同时发送（当然也不能同时接收）。这种通信方式是一方发送另一方接收，过一段时间再反过来。
10.全双工通信:
即通信的双方可以同时发送和接收信息。
11.基带信号
来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。
12.带通信号
把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。
T3-05 物理层的接口有哪几个方面的特性？个包含些什么内容？
（1）机械特性: 指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。
（2）电气特性: 指明在接口电缆的各条线上出现的电压的范围。
（3）功能特性: 指明某条线上出现的某一电平的电压表示何意。
（4）规程特性: 说明对于不同功能的各种可能事件的出现顺序。 说明对于不同功能的各种可能事件的出现顺序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96fbe67569be8ae95a5aa505018397eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39938ad81c457a441d6815f72dfa2b65/" rel="bookmark">
			IJCAI2023 Decoupling with Entropy-based Equalization for Semi-Supervised Semantic Segmentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Decoupling with Entropy-based Equalization for Semi-Supervised Semantic Segmentation 半监督语义分割与基于熵的均衡解耦
Paper：https://www.ijcai.org/proceedings/2023/74
Code：None
Abstract 半监督语义分割方法是缓解语义分割中标注消耗高问题的主要解决方案。然而，类不平衡问题使得模型偏向于训练样本充足的头类，导致尾类的性能较差。
为了解决这个问题，我们提出了一种基于师生模型的解耦半监督语义分割（ D e S 4 DeS^4 DeS4）框架。具体来说，我们首先提出了一种解耦训练策略，将编码器和分段解码器的训练分开，以实现平衡解码器。
然后，提出了一种基于不可学习原型的分割头来正则化类别表示分布一致性，并在教师模型和学生模型之间进行更好的连接。
此外，提出了一种多熵采样（MES）策略来收集像素表示以更新共享原型以获得类别无偏的头部。
我们在两个具有挑战性的基准（PASCAL VOC 2012 和 Cityscapes）上对所提出的 D e S 4 DeS^4 DeS4 进行了广泛的实验，并比以前最先进的方法取得了显着的改进。
1 Introduction 语义分割是计算机视觉领域最基本的任务之一，它可以应用于自动驾驶汽车和电影编辑等许多应用中。近年来，基于深度神经网络的语义分割取得了显着的进展[He et al, 2016; Chen et al, 2018a] 以及大规模注释良好的分割数据集 [Everingham et al, 2015; Cordts 等人，2016]。现有的基于深度学习的完全监督分割方法需要大量数据，并且需要大规模数据集进行训练。然而，获取分割数据集非常耗时且费力，因为它们是像素级掩模的密集注释。为了缓解这种高注释消耗问题，半监督语义分割受到了广泛关注[French et al, 2020;邹等人，2021； Chen et al, 2021]，它提供了利用有限注释和大量未标记图像的潜力。
许多半监督分割工作旨在应用一致性正则化 [French et al, 2020;陈等人，2021；张等人，2022]和自我训练[Bachman 等人，2019；陈等人，2020； Fan 等人，2022a] 策略。这些方法通常采用教师-学生范式 [French et al, 2020]，并通过教师模型生成的伪标签来监督学生模型，如 图 1(a) 所示。然而，由于模型是使用不平衡数据进行训练的，因此大多数方法受到语义分割的像素分类精度的限制，这导致尾部类别学习的退化。最近，一些工作试图缓解半监督语义分割中的不平衡问题 [1]、[2] 。例如，分布对齐和随机采样 （DARS）[3] 和 UCC [4] 探索了真实分布和伪标记分布之间的不匹配问题，并提出了渐进式数据增强策略和动态数据增强策略。分别是交叉集复制粘贴 (DCSCP)。 AEL [Hu et al, 2021] 通过重新采样和重新加权来解决有偏差的训练问题，如 图 1(b) 所示。它提出了两种基于自适应的数据增强方法和置信库的采样策略。不同的是，USRN 提出了一种具有聚类子类的类平衡子类框架，如 图 1(c) 所示。然而，现有的方法联合学习编码器和解码器，这种学习方式忽略了长尾问题对不同组件的影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39938ad81c457a441d6815f72dfa2b65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0516037d6d3fad086744c0be5c6d8438/" rel="bookmark">
			P1586 四方定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Powered by:NEFU AB-IN
Link
文章目录 P1586 四方定理题意思路代码 P1586 四方定理 题意 四方定理是众所周知的：任意一个正整数n，可以分解为不超过四个整数的平方和
给定的正整数n，编程统计它能分解的方案总数。
思路 d p [ i ] [ j ] dp[i][j] dp[i][j]代表i可用j个平方数组成的方案数，所以最后输出 d p [ n ] [ 1 − 4 ] dp[n][1-4] dp[n][1−4]的和即可
由于所有数都可以使用无数次，所以采用完全背包的思想，可以理解为有1,2,3…等物品，体积为各自的平方，每个的价值都是一样的，背包体积为n，目的是问塞满背包的方案数
得出dp方程 d p [ i ] [ j ] + = d p [ i − k ∗ k ] [ j − 1 ] dp[i][j] += dp[i - k*k][j-1] dp[i][j]+=dp[i−k∗k][j−1]
代码 /* * @Author: NEFU AB-IN * @Date: 2023-09-10 12:05:40 * @FilePath: \Contest\C\C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0516037d6d3fad086744c0be5c6d8438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25875aacdb160f0fcb12288e9d35269c/" rel="bookmark">
			python词云 wordcloud库详细使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言使用wordcloud生成词云的步骤API参考分词简介英文分词中文分词，jieba matplotlib库简介实例从一段文本建立词云根据蒙版建立词云从词频建立词云从图片颜色建立词云 传入中文字体路径解决乱码问题 前言 “词云”这个概念由美国西北大学新闻学副教授、新媒体专业主任里奇·戈登（Rich Gordon）于提出，词云是一种可视化描绘单词或词语出现在文本数据中频率的方式，它主要是由随机分布在词云图的单词或词语构成，出现频率较高的单词或词语则会以较大的形式呈现出来，而频率越低的单词或词语则会以较小的形式呈现。词云主要提供了一种观察社交媒体网站上的热门话题或搜索关键字的一种方式，它可以对网络文本中出现频率较高的“关键词”予以视觉上的突出，形成“关键词云层”或“关键词渲染”，从而过滤掉大量的文本信息，使浏览网页者只要一眼扫过文本就可以领略文本的主旨。
例如：（图片来自于网络）
你也想做出这么具有视觉震撼效果的词云吗？借助python的wordcloud库便可实现。
wordcloud库不是python内置库，需要安装。windows+R，打开cmd，然后在命令行输入：
pip install wordcloud 等待安装完成即可。
关于wordcloud库最详细的使用教程，可参考：
wordcloud官方文档
本文是在作者参考官网后，然后结合自己的示例整理出。源代码和相关资料下载资源（0积分下载）：
https://download.csdn.net/download/weixin_55697913/87697233
使用wordcloud生成词云的步骤 读取文件，分词整理
可能会用到字符串相关函数、jieba库等。
配置对象参数，加载词云文本
创建一个WordCloud对象，使用.generate()方法加载文本。
计算词频，输出词云文件
使用to_file()方法输出到文件。或者利用其他库（如pyplot）展示图像。
生成词云时，wordcloud 默认会以空格或标点为分隔符对目标文本进行分词处理。
对于中文文本，分词处理需要由用户来完成，jieba库是常见的中文分词库。
一般步骤是先将文本分词处理，然后以空格拼接，再调用wordcloud库函数。
处理中文时还需要指定中文字体，见本文末尾传入中文字体路径解决乱码问题。
API参考 最重要的一个API：
class wordcloud.WordCloud(font_path=None, width=400, height=200, margin=2, ranks_only=None, prefer_horizontal=0.9, mask=None, scale=1, color_func=None, max_words=200, min_font_size=4, stopwords=None, random_state=None, background_color='black', max_font_size=None, font_step=1, mode='RGB', relative_scaling='auto', regexp=None, collocations=True, colormap=None, normalize_plurals=True, contour_width=0, contour_color='black', repeat=False, include_numbers=False, min_word_length=0, collocation_threshold=30) 重要参数详解：
font_path：字体路径。使用中文很可能产生乱码，需要下载专门的中文字体，然后将路径传入。width, height：画布的大小。mask：蒙版（熟悉ps的小伙伴应该很清楚），可以传入一个图像当做蒙版，这时width，height会被忽略。蒙版的纯白色部分将没有文字，其他颜色部分将有文字。min_font_size：词云最小字体的大小。max_font_size同理。max_words：最大词语的数量。stopwords：set of strings or None，出现在停用词里的词将不会出现在词云中。如果None，则使用默认的stopwords。如果使用.generate_from_frequencies方法，则会被忽略。background_color：背景颜色，可以直接用white、black等字符串。repeat：bool, default=False。是否可以重复单词。color_func：callable, default=None。可以传入一个函数或者后面提到的ImageColorGenerator，用于给词云上色。 方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25875aacdb160f0fcb12288e9d35269c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4820c1b9ae10e18ee9ad064c39195789/" rel="bookmark">
			【达梦数据库】分布式计算集群DMDPC原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 系统结构多副本系统执行流程DML 流程DDL流程 系统结构 达梦分布计算集群英文全称 DM Distributed Processing Cluster，简称 DMDPC。
DMDPC 是基于达梦数据库管理系统研发的一款同时支持在线分析处理和在线事务处理的新型分布式数据库系统。它既具备传统单机数据库的绝大部分功能，又提供了分布式计算集群才拥有的高可用、高扩展、高性能、高吞吐量和对用户透明等高级特性。
一个完整的 DMDPC 架构由计划生成节点 SP、数据存储节点 BP 和元数据服务器节点 MP 三部分组成。SP 对外提供分布式数据库服务，用户可以登录到任意一个 SP 节点，获得完整的数据库服务；BP 负责存储数据，执行 SP 的调度指令并将执行结果返回给 SP；MP 负责存储元数据并向 SP、BP 提供元数据服务。
SP 节点不存储数据，配置成单机即可。MP 和 BP 节点既可以配置成单机，也可以配置成多副本系统。其中每一个多副本系统中只有一个作为主节点，其余节点均作为备份节点。
计划生成节点SP：SQL Processor。对外提供数据库服务，负责接收用户请求并生成计划、划分子计划、按照一定规则计算并行度并调度各个子计划，并最终将执行结果返回给用户。对于一次客户端请求任务来说，客户端连接的SP负责生成、划分并调度计划，其它的SP和BP负责执行计划。SP的实现是在已有的成熟达梦单机数据库处理框架的基础上新增了分布式计算处理。数据存储节点BP：Backend Processor。DMDPC集群中数据实际存储的节点，负责存储数据和接收SP的子任务调度指令，执行子任务，并返回结果给SP。一个DMDPC集群可配置多个BP节点同时提供服务，且可以随着用户业务量变化动态增删BP节点。为了保障BP节点能够持续提供服务，每一个BP节点又可以配置成一个BP多副本系统。元数据服务器节点MP：Metadata Processor。DMDPC集群中提供元数据服务（即字典信息服务）的节点。所有DDL请求都会经过SP转发给MP执行，元数据信息全部存储在MP。一个DMDPC集群只能配置一个MP节点提供服务。为了保障MP节点能持续提供服务，MP节点可以配置成一个MP多副本系统。 多副本系统 在现实环境中，DMDPC运行过程中有可能会碰到各种故障情况，比如系统掉电或者出现硬件故障（如磁盘损坏）、自然灾害（地震、火灾）等极端情况，因此需要对BP或MP采用多副本系统架构进行存储，以保障DMDPC的数据安全和高可用性，避免出现数据损坏和丢失，并且可以快速恢复数据库服务，满足用户不间断提供数据库服务的要求。
DM多副本系统由N个节点实例组成，N必须是大于1的奇数。只有配置了RAFT归档的实例才能加入多副本系统。
目前一个多副本系统最多支持部署9个节点实例。同一个RAFT组中的所有节点（三个或三个以上）共同构成一个多副本系统。实例之间通过XMAL模块进行TCP消息通讯。各个节点实例之间基于RAFT协议选举出一个领导者作为主库，其他实例作为备库（也就是副本）角色运行。主库会自动向备库同步日志，备库接收并重新应用日志，从而达到主备库之间数据保持一致的目的。
BP多副本架构：
MP多副本架构：
执行流程 DML 流程 DML流程分为两种情况：一般流程和优化流程。优化流程是指在实际执行时，优化器会综合多种条件，对符合优化的细节进行优化之后形成的流程。EXPLAIN查看执行计划时，包含mpp_opt_flag(1)的即为优化流程下的执行计划，包含mpp_opt_flag(0)的即为一般流程下的执行计划。
DDL流程 DMDPC中处理DDL请求的流程如下：
客户端发送DDL请求给SP；SP在经过初步分析后，判断出是DDL请求，转发给MP，等待MP响应；MP接收到SP转发的DDL请求后，根据具体类型，更改系统表；如果有B树创建、删除等用户数据操作，转发给相应BP完成；所有步骤完成后回复SP；SP根据MP的反馈结果向客户端报告成功或失败。 达梦数据库 - 新一代大型通用关系型数据库 | 达梦在线服务平台 (dameng.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9edbbe4cec3a8a257cb876b43e2b06/" rel="bookmark">
			Redis的介绍、安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、redis官网二、redis是什么三、能干嘛总体功能一图概述优势小总结 三、Redis的下载与安装Redis的安装Redis迭代演化和Redis7新特性新特性部分说明Redis的安装 安装步骤总结Redis的卸载 一、redis官网 https://redis.io/
中文官网：http://www.redis.cn/
二、redis是什么 Remote Dictionary Server(远程字典服务)是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据库提供了丰富的数据结构，例如String、Hash、List、Set、SortedSet等等。数据是存在内存中的，同时Redis支持事务、持久化、LUA脚本、发布/订阅、缓存淘汰、流技术等多种功能特性提供了主从模式、Redis Sentinel和Redis Cluster集群架构方案
三、能干嘛 1.分布式缓存，挡在mysql之前的带刀护卫
与传统数据库关系(mysql)
Redis是key-value数据库(NoSQL一种)，mysql是关系数据库
Redis数据操作主要在内存，而mysql主要存储在磁盘
Redis在某一些场景使用中要明显优于mysql，比如计数器、排行榜等方面
Redis通常用于一些特定场景，需要与Mysql一起配合使用
两者并不是相互替换和竞争关系，而是共用和配合使用
2.内存存储和持久化（RDB+AOF）
redis支持异步将内存中的数据写道硬盘上同时不影响继续服务
3.高可用架构搭配
单机、主从、哨兵、集群
4.缓存穿透、击穿、雪崩
5.分布式锁
6.队列
Reids提供list和set操作，这使得Redis能作为一个很好的消息队列平台来使用。
我们常通过Reids的队列功能做购买限制。比如到节假日或者推广期间，进行一些活动，
对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。也比较适合适用。
7.排行版+点赞
在互联网应用中，有各种各样的排行榜，如电商网站的月度销量排行榜、社交APP的礼物排行榜、小程序的投票排行榜等等。Redis提供的zset数据类型能够快速实现这些复杂的排行榜。
比如小说网站对小说进行排名，根据排名，将排名靠前的小说推荐给用户
总体功能一图概述 优势 性能极高-Redis能读写的速度是110000次/秒，写的速度是81000次/秒Redis数据类型丰富，不仅仅支持简单的key-value类型的数据，同时还支持list，set，zset，hash等数据结构的存储Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用Redis支持数据的备份，即master-slave模式的数据备份 小总结 三、Redis的下载与安装 Redis的安装 下载地址：https://redis.io/download/
我使用的是redis-7.2.0
redis的在线测试地址：https://try.redis.io/
命令参考：http://doc.redisfans.com/
Redis迭代演化和Redis7新特性 新特性部分说明 Redis的安装 推荐使用linux安装Redis
我使用的docker（docker安装需要在配置docker容器的时候将所需要用到的端口映射出来，方便使用）安装的Redis，docker教程可以查看这篇文章：https://blog.csdn.net/xdznb_/article/details/132697915
linux安装redis必须要先具备gcc编译环境
什么是gcc:
gcc是linux下的一个编译程序，是C程序的编译工具。
GCC(GNU Compiler Collection) 是 GNU(GNU’s Not Unix) 计划提供的编译器家族，它能够支持 C, C++, Objective-C, Fortran, Java 和 Ada 等等程序设计语言前端，同时能够运行在 x86, x86-64, IA-64, PowerPC, SPARC和Alpha 等等几乎目前所有的硬件平台上。鉴于这些特征，以及 GCC 编译代码的高效性，使得 GCC 成为绝大多数自由软件开发编译的首选工具。虽然对于程序员们来说，编译器只是一个工具，除了开发和维护人员，很少有人关注编译器的发展，但是 GCC 的影响力是如此之大，它的性能提升甚至有望改善所有的自由软件的运行效率，同时它的内部结构的变化也体现出现代编译器发展的新特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9edbbe4cec3a8a257cb876b43e2b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100312319aa816fffce1f49491d037ba/" rel="bookmark">
			MacBook苹果电脑重装、降级系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载balenaEtcher镜像启动盘制作工具 https://tails.net/etcher/balenaEtcher-portable.exe
2、选择从文件烧录选择下载好的Mac 镜像文件
百度网盘 请输入提取码（Mac OS 10.10-12版本镜像文件）
第二步选择目标磁盘，这里需要准备一块16G左右的U盘插入电脑
第三步选择好U盘后烧录即可
3、将Mac系统U盘插上电脑，按下Mac开机键后，马上按下“option”键不放，稍等几秒会出现启动盘选择界面，这里不要选择网络，选择制作好的系统盘“Mac OS Catalina”按回车键即可；
4、进Mac系统安装界面，在macOS 实用工具处选择磁盘工具点击继续，打开“磁盘工具”
5、选中系统盘-选择“抹掉”-格式默认APFS-抹掉
格式化完成返回mac OS实用工具界面
6、选择安装macOS-继续
7、选择同意
8、选择安装在我们刚刚抹掉的系统盘-安装
9、系统安装过程中等待安装完成即可，期间会重启1-2次
10、安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d8f82b4244f051093f51aa1c920936/" rel="bookmark">
			golang入门笔记——Hertz
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Hertz介绍应用层路由层协议层传输层HZ脚手架 Hertz的使用一个简单的案例：利用Hertz监听8080端口并编写/ping的get处理函数Hertz和gin一样，提供了分组路由的功能Hertz路由的匹配优先级：静态路由&gt;命名路由&gt;通配路由参数绑定：Bind、Validate、BindAndValidate用于参数绑定和校验中间件HTTP ClientHertz代码生成工具Hertz的一些基本函数 Hertz介绍 Hertz是字节跳动研发的企业级微服务HTTP框架，具有高易用性、易扩展、低时延等特点。是基于自研网络库Netpoll开发的内部框架Hertz。Hertz框架整体上满足：
1.极致性能优化的问题性
2.面对未来不可控需求的扩展能力，Hertz采用了4层分层设计（应用层、路由层、协议层、传输层），保证各个层级功能内聚，同时通过层级之间的接口达到灵活扩展的目标。整体框架如下图：
应用层 主要包括与用户直接交互的易用的API，主要包括Server、Client和一些其他通用抽象。Hertz框架最具特点的是处理函数（HandlerFunc）多了一个context上下文，这是在大量的实践过程中发现的，业务方通常需要一个标准的上下文在RPC Client或者日志、Tracing等组件间传递，但由于请求上下文（RequestContext）生命周期局限于一次HTTP请求之内而以上提到的场景往往存在异步的传递和处理， 导致如果直接传递请求上下文，会导致出现一些数据不一致的问题。因此最终增加了一个标准的上下文入参，从根本上解决各种因为上下文生命周期不一致的异常问题，处理函数的格式为：
type HandlerFunc func(c context.Context,ctx *app.RequestContext)
路由层 Hertz在设计路由时，给了用户极高的自由度去注册路由，支持的路由有：支持静态路由、参数路由的注册；支持按优先级匹配，支持路由回溯，支持尾斜线重定向。例如：
1.优先级匹配，如/a/b和/:c/b，同时满足时，优先匹配/a/b
2.路由回溯，如注册/a/b和/:c/d，当匹配/a/d时仍然能够匹配上/:c/d
3.支持尾斜线重定向，如注册/a/b，当匹配/a/b/时重定向到/a/b上
协议层 协议层负责不同协议的实现和扩展。Hertz支持协议的扩展，用户只需要实现下面的接口便可以按照自己的需求在引擎上扩展协议，同时也支持通过ALPN协议协商的方式注册。Hertz首批只开源了 HTTP1 实现，未来会陆续开源 HTTP2、QUIC 等实现。协议层扩展提供的灵活性甚至可以超越 HTTP 协议的范畴，用户完全可以按需注册任意符合自身需求的协议层实现，并且加入到Hertz的引擎中来，同时，也能够无缝享受到传输层带来的极致性能。
传输层 传输层负责底层的网络库的抽象和实现
Hertz支持底层网络库的扩展。Hertz原生完美匹配Netpoll，在时延方面有很多深度的优化，Netpoll对TLS能力的支持有待完善，为此Hertz底层同时支持基于Golang标准网络库的实现适配，同时支持网络库的一键切换，用户可根据自己的需求选择合适的网络库进行替换。如果用户有更加高效的网络库或其他网络库需求，也完全可以根据需求自行扩展。
BIO:
go func(){ for{ conn,_:=listener.Accept() go func(){ conn.Read(request) handle... conn.Write(response) } } } NIO:
go func(){ for{ readableConns,_:=Monitor(conns) //监听器，有足够的数据之后再去唤醒 for conn:=range readableConns{ go func(){ conn.Read(request) handle... conn.Write(response) } } } } go net是“BIO”，需要用户来管理buffer.
go net存下全部Header，减少系统调用次数，能够复用内存，能够多次读
type Conn interface{ Read(b []byte)(n int,err error) Write(b []byte)(n int,err error) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7d8f82b4244f051093f51aa1c920936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312d0c444c561b728846e82a5bfbd7ac/" rel="bookmark">
			可重入函数与不可重入函数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不可重入函数的定义： 在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果有一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数
不可重入（non-reentrant）函数不能由超过一个任务所共享，除非能确保函数的互斥 （或者使用信号量，或者在代码的关键部分禁用中断）。
禁用中断原因：不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。我们知道中断时确实保存一些上下文，但是仅限于返回地址，cpu 寄存器等之类的少量上下文，而函数内部使用的诸如全局或静态变量，buffer 等并不在保护之列，所以如果这些值在函数被中断期间发生了改变，那么当函数回到断点继续执行时，其结果就不可预料了。
可重入函数的定义： 这个安全的函数又叫可重入函数，所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。
可重入函数可以在任意时刻被中断， 稍后再继续运行，不会丢失数据。可重入函数要么使用本地变量，要么在使用全局变量时 保护自己的数据。
可重入函数可以允许有该函数的多个副本在运行，由于不同任务使用的是分离的栈，所以不会互相干扰。
它除了使用自己栈上的变量以外不依赖于任何环境（包括 static）
保证函数的可重入性的方法： 避免使用全局或静态变量，尽量使用局部变量
全局或静态变量可能被多个线程共享，如果不加控制地访问它们，就会导致不可重入。所以在写函数时候尽量使用局部变量（例如寄存器、堆栈中的变量）；
避免使用非线程安全的函数库
某些函数库可能使用全局或静态变量来存储一些数据，这些数据可能会被多个线程共享。如果这些函数库不是线程安全的，也会导致不可重入。
避免使用死锁
在设计不可重入函数时，需要避免出现死锁的情况，即两个或多个线程彼此等待对方释放某些资源的情况。
使用信号量、互斥量等同步机制或采取关中断
为了保证不可重入函数的线程安全，我们可以使用信号量、互斥量等同步机制来控制对共享变量或资源的访问。
满足下列条件的函数多数是不可重入（不安全）的： 函数体内使用了静态的数据结构；
函数体内调用了malloc() 或者 free() 函数；
malloc就是一个不可重入函数，如一个进程此时正在执行malloc分配堆空间，此时程序捕捉到信号发生中断，执行信号处理程序中恰好也有一个malloc，这样就会对进程的环境造成破坏，因为malloc通常为它所分配的存储区维护一个链接表，插入执行信号处理函数时，进程可能正在对这张表进行操作，而信号处理函数的调用刚好覆盖了进程的操作，造成错误。 函数体内调用了标准 I/O 函数。因为标准I/O库很多实现都以不可重入的方式使用全局数据结构。
进行了浮点运算，许多的处理器/编译器中，浮点一般都是不可重入的 (浮点运算大多使用协处理器或者软件模拟来实现。
调用printf。
不可重入函数的案例 函数有static变量或者全局变量，则该函数是不可重入函数
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;errno.h&gt; int g_mysign = 0; //这个函数会修改全局变量g_mysign的值 void muNEfunc(int value) { //.....其他处理代码 g_mysign = value; //.....其他处理代码 } //信号处理函数 void sig_usr(int signo) { muNEfunc(22); //因为一些实际需求必须要在sig_user这个信号处理函数里调用muNEfunc int myerrno = errno; if(signo == SIGUSR1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/312d0c444c561b728846e82a5bfbd7ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec828954c6e9359b0b4c1b6e9b3d0c50/" rel="bookmark">
			linux发行版本Ubuntu安装，显卡驱动安装以及软件安装卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux/Ubuntu22.04LTS安装，英伟达显卡驱动安装以及软件安装卸载 1 暗影精灵6安装Ubuntu1.1 更新系统1.2 卸载原有nvidia显卡驱动1.3 安装nvidia显卡驱动1.4 查看nvidia显卡信息1.5 打开显卡设置 2 常用软件安装和卸载2.1 安装谷歌浏览器2.2 卸载火狐浏览器2.3 安装拼音输入法2.4 安装串口调试软件2.4.1 安装Moserial串口助手2.4.2 安装putty 3 国产Linux系统的安装4 linux相关操作命令4.1 通过SSH 远程主机4.2 开关机命令4.3安装新立得软件管理软件 5 问题以及解决方案5.1 NTFS格式硬盘不能读写 1 暗影精灵6安装Ubuntu 手上有一台暗影精灵6的笔记本，配置为R7 4800H+2060，具体的相关信息如下
H/W path Device Class Description ======================================================= /0/0 memory 15GiB System memory /0/1 processor AMD Ryzen 7 4800H with Radeon Graphi /0/100/1.1/0 display TU106 [GeForce RTX 2060] /0/100/1.2/0 eno1 network RTL8111/8168/8411 PCI Express Gigabi /0/100/2.1/0 wlo1 network Wi-Fi 6 AX200 /0/100/2.3/0/0 /dev/nvme0 storage HP SSD EX900 250GB /0/100/2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec828954c6e9359b0b4c1b6e9b3d0c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a4557576e10b0973278abad8fddb38/" rel="bookmark">
			js-map方法中调用服务器接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Array.prototype.map() 方法中调用服务器接口时，可以使用异步函数来处理。
示例：
async function fetchData() { try { const response = await fetch('https://api.example.com/data'); // 通过 fetch 发送请求 const data = await response.json(); // 解析响应数据为 JSON 格式 return data; } catch (error) { console.log('请求出错:', error); throw error; } } async function processData() { const dataArray = [1, 2, 3, 4, 5]; try { const processedArray = await Promise.all(dataArray.map(async (item) =&gt; { const data = await fetchData(); // 调用服务器接口获取数据 // 处理数据逻辑 const processedItem = item + data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a4557576e10b0973278abad8fddb38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a939aebf19567e4b6ecb9ebc3b3b9f/" rel="bookmark">
			input修改checkbox复选框默认选中样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： &lt;input type="checkbox" /&gt; input修改checkbox默认选中样式，直接设置选中后的样式不生效，需要先给复选框设置-webkit-appearance: none（取消默认样式）， 再设置样式才会生效。
默认样式选中前后对比图：
解决示例： /* 设置未选中样式 */ input[type="checkbox"] { position: relative; width: 15px; height: 15px; line-height: 15px; border: 1px solid #949494; /* 取消默认样式 */ -webkit-appearance: none; } /* 设置选中样式 */ input[type="checkbox"]:checked { background-color: red; } input[type="checkbox"]:checked::after { content: "✓"; position: absolute; top: 0; width: 15px; height: 15px; color: #fff; text-align: center; } 选中前后对比图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f73b648a4c2ad4be71d1fa3fa4da9b/" rel="bookmark">
			【信息学奥赛一本通】题解目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【信息学奥赛一本通】题解目录 信息学奥赛一本通OJ
以下本人做的OJ题解
针对每一道题我都会给出题目考点、解题思路、题解代码。必要时也会给出不同的解题方法。
本人水平有限，如有不足之处，欢迎大家指正。如看过后还有不明白的地方，欢迎在评论区留言。
作者：君义_noip
基础(一) C++语言 第一章 C++语言入门 1001 Hello,World!：点击这里
2060 【例1.1】计算机输出： 点击这里
2061 【例1.2】梯形面积：点击这里
2062 【例1.3】电影票：点击这里
2063 【例1.4】牛吃牧草：点击这里
1002 输出第二个整数：点击这里
1003 对齐输出：点击这里
1004 字符三角形：点击这里
1005 地球人口承载力估计：点击这里
第二章 顺序结构程序设计 第一节 运算符和表达式 2064 【例2.1】交换值：点击这里
2065 【例2.2】整数的和：点击这里
2066 【例2.3】买图书：点击这里
1006 A+B问题：点击这里
1007 计算(a+b)×c的值：点击这里
1008 计算(a+b)/c的值：点击这里
1009 带余除法：点击这里
1010 计算分数的浮点数值：点击这里
第二节 常量和变量 2067 【例2.5】圆：点击这里
2068 【例2.6】鸡兔同笼：点击这里
1011 甲流疫情死亡率：点击这里
1012 计算多项式的值：点击这里
1013 温度表达转化：点击这里
1014 与圆相关的计算：点击这里
1015 计算并联电阻的阻值：点击这里
第三节 标准数据类型 1414 【17NOIP普及组】成绩：点击这里
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06f73b648a4c2ad4be71d1fa3fa4da9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da80f7785d673f8198bef495da86fe5/" rel="bookmark">
			信息学奥赛一本通 1351：【例4-12】家谱树 | 洛谷 B3644 【模板】拓扑排序 / 家谱树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目链接】 ybt 1351：【例4-12】家谱树
洛谷 B3644 【模板】拓扑排序 / 家谱树
【题目考点】 1. 图论 拓扑排序 【解题思路】 要求序列中“每个人的后辈都比那个人后列出”。
如果这样建图：每个人是一个顶点。如果a是b的父辈，那么有一条从a到b的有向边&lt;a, b&gt;。
根据拓扑排序的定义：如果从a到b有一条路径，那么b在拓扑排序中在a的后面。
那么这个图的拓扑排序可以满足题目对所求的序列的要求。
因此这是个拓扑排序模板题，建图，求拓扑排序。
【题解代码】 解法1：使用vector邻接表 #include&lt;bits/stdc++.h&gt; using namespace std; #define N 105 vector&lt;int&gt; edge[N]; int n, deg[N];//deg[i]:顶点i的入度 void init()//建图 { int f, t; cin &gt;&gt; n; for(f = 1; f &lt;= n; ++f) { while(cin &gt;&gt; t &amp;&amp; t != 0) { edge[f].push_back(t); deg[t]++; } } } void topoSort()//拓扑排序 { queue&lt;int&gt; que; for(int i = 1; i &lt;= n; ++i) if(deg[i] == 0) { cout &lt;&lt; i &lt;&lt; ' '; que.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1da80f7785d673f8198bef495da86fe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a99fa2792f1d7625aaffadb6a2bb029/" rel="bookmark">
			综述 | 时空序列预测模型有哪些研究方向？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自知乎 作者常长
本篇文章针对时间序列预测领域中的交通流预测（交通流预测模型也可以用于其他时空序列预测问题），总结了近几年顶会顶刊中交通流模型的组成和分类。
希望这篇文章可以帮助读者更好的了解交通流模型的框架，从整体上了解近年的模型。从整体角度，熟悉各种交通流模型的结构和特点，可以帮助我们更好的使用和设计模型。
大致可以从三个方面描述“交通流模型”的内容和结构，分别是：空间模块、时间模块和聚合方式。在空间模块中常用的结构有：CNN（卷积神经网络），GCN（图卷积神经网络）和Attention（注意力机制）；而在时间模块中常用的结构有：LSTM（长短时神经网络），GRU（门控循环单元），TCN（时间卷积网络），Attention（注意力机制）；常用的聚合方式有：Sequential Structure（序列结构），Coupled Structure（耦合结构）和Spatial-Temporal Synchronized Learning（时空同步学习）。 时空序列预测模型=空间模块+时间模块+聚合方式
从整体上来说，近年的时空序列预测模型的组成可以概括为如上公式，再细节一点就是不同模型有不同的小trick（这个可以通过阅读论文和代码进一步详细了解）。可以按照这三个方面给模型进行分类，在下文会着重讨论各个模型的不同。
不同的模型是这三个方面的排列组合，下面介绍几种有效的、用得多的组合结构。包括：GNN+TCN+Sequential、GNN+RNN+Sequential/Coupled、Attention+其他+Sequential、时空同步学习。
01
总览
交通流预测问题的特征有三个，包括：Speed（速度），Flow（流量），Occupy（道路占用率），这三个变量的预测都属于交通流预测问题的范畴。
如下图是近年顶会顶刊里中稿的交通流paper（Traffic Flow Prediction和Traffic Speed Prediction这两列），发表时间如下所示，时空维度的模块组成如下所示。
注：近年新发表的交通流模型远远不止这些（CCF A/B/C；SCI），下表格列举的是性能较好或者更有创新的模型。
近年来，顶刊顶会中的交通流预测模型
02
GNN+TCN+Sequential
GWNET（全称Graph WaveNet）和MTGNN是GNN+TCN结构的代表模型。用GCN处理空间特征，用TCN（本质上是膨胀因果卷积，1维卷积，也称为WaveNet）。除此之外，GWNET和MTGNN还都在GCN中采用了adpative matrix（自适应邻接矩阵，增加拟合参数、拟合能力）。
从实验验证结果来说，GNN+TCN是目前精度最高的框架（之一），并且因为模型全是CNN没有RNN和Attention的缘故，模型的计算和训练速度都更快。同时采用自适应邻接矩阵是提供精度的重要方式。
（跟随GWNET和MTGNN的脚步，也有了更多的模型）
Graph WaveNet框架图
[1] Z Wu, S Pan, G Long, J Jiang, and C Zhang. 2019. Graph WaveNet for Deep Spatial-Temporal Graph Modeling. In IJCAI. International Joint Conferences on Artificial Intelligence Organization.
[2] Zonghan Wu, Shirui Pan, Guodong Long, Jing Jiang, Xiaojun Chang, and Chengqi Zhang.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a99fa2792f1d7625aaffadb6a2bb029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92167e210a09707babdbd35877947a13/" rel="bookmark">
			vue实现 Element-UI 的 Tree Select 树形选择器组件（一）组件封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果需要动态根据数据渲染，请参考这篇文章：
vue实现 Element-UI 的 Tree Select 树形选择器组件（二）递归遍历json菜单多级数据
①：支持树形菜单多级选择
②：支持input检索功能
③：element-ui 的 select组件 和 tree组件 结合
1. 具体效果如下 github下载地址：https://github.com/xiechunhao/vue-treeSelect 2. 下面是详细代码 2.1 组件封装代码： &lt;template&gt; &lt;el-select :value="valueTitle" :clearable="clearable" @clear="clearHandle"&gt; &lt;el-input class="selectInput" :placeholder="placeholder" v-model="filterText"&gt; &lt;/el-input&gt; &lt;el-option :value="valueTitle" :label="valueTitle" class="options"&gt; &lt;el-tree id="tree-option" ref="selectTree" :accordion="accordion" :data="options" :props="props" :node-key="props.value" :default-expanded-keys="defaultExpandedKey" :filter-node-method="filterNode" @node-click="handleNodeClick"&gt; &lt;/el-tree&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/template&gt; &lt;script&gt; export default { name: "el-tree-select", props:{ /* 配置项 */ props:{ type: Object, default:()=&gt;{ return { value:'id', // ID字段名 label: 'title', // 显示名称 children: 'children' // 子级字段名 } } }, /* 选项列表数据(树形结构的对象数组) */ options:{ type: Array, default: ()=&gt;{ return [] } }, /* 初始值 */ value:{ type: Number, default: ()=&gt;{ return null } }, /* 可清空选项 */ clearable:{ type:Boolean, default:()=&gt;{ return true } }, /* 自动收起 */ accordion:{ type:Boolean, default:()=&gt;{ return false } }, placeholder:{ type:String, default:()=&gt;{return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92167e210a09707babdbd35877947a13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e78bce1797dc89d39449a68f3c23a6/" rel="bookmark">
			阿里云服务器是什么？云服务器详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器是什么？云服务器ECS是一种安全可靠、弹性可伸缩的云计算服务，云服务器可以降低IT成本提升运维效率，免去企业或个人前期采购IT硬件的成本，阿里云服务器让用户像使用水、电、天然气等公共资源一样便捷、高效地使用服务器。阿里云服务器具有安全、稳定、弹性升降配、高性能、易用可扩展等优势。阿里云百科来详细说下什么是阿里云服务器以及阿里云服务器的优缺点分析：
目录
阿里云服务器ECS介绍
一：云服务器ECS功能详解
1、多种计算架构、ECS实例规格和存储类型
2、专有网络VPC
3、快照与多种镜像类型选择
4、多种付费类型
二：云服务器的使用场景
三：阿里云全球基础设施
四：阿里云服务器优势
五：客户案例
阿里云服务器ECS介绍 云服务器ECS，即Elastic Compute Service，翻译过来是弹性云计算服务，ECS是什么意思？可以理解为阿里云服务器的英文名，腾讯云服务器叫CVM。国内云服务器提供商有很多，如阿里云、腾讯云、华为云等，阿里云作为国内第一云，云服务器具有安全可靠、运行稳定、弹性可伸缩、高性能、使用简单和可拓展性等优势。
阿里云服务器ECS
企业或个人想要搭建IT业务，按照传统的思路，前期需要采购服务器等硬件设备，可能需要将服务器托管到机房，或者自建机房，这种模式无论是时间还是金钱都需要耗费太多人力物力。云计算的出现，帮助用户降低IT成本，免去公司或个人前期采购IT硬件的成本，云服务器让用户像使用水、电、天然气等公共资源一样便捷、高效地使用服务器，像新浪微博、淘宝都是基于阿里云的云计算服务，阿里云作为国内第一云，市场份额占比远超友商，上云就上阿里云，可以在阿里云CLUB中心aliyun.club领取专属代金券。
下面阿里云百科来详细说下阿里云服务器ECS的功能、优势、使用场景及客户案例：
一：云服务器ECS功能详解 阿里云服务器ECS提供丰富的架构、ECS实例规格及存储类型供用户选择，用户可以根据实际使用场景选择合适的云服务器；阿里云提供VPC专有网络打造用户在云上的网络环境，专有网络之间逻辑上彻底隔离，用以保护用户的数据安全；云服务器提供多种计费模式，让用户自由选择；云服务器提供快照、镜像等功能，为客户提供数据保护和快速部署。
1、多种计算架构、ECS实例规格和存储类型 阿里云服务器架构和ECS实例规格
阿里云服务器提供X86、ARM计算架构、GPU异构计算等、弹性裸金属及超级计算集群架构，云服务器ECS规格常见的有ECS共享型s6、计算型c7、通用型g8、通用算力型、内存型、GPU型、本地SSD型、大数据型、高主频型、裸金属型等，CPU处理器包括intel和AMD，用户可以根据自身应用实际使用场景来选择对应的ECS实例规格。
云服务器ECS实例规格不同，云服务器CPU处理器型号、网络带宽、网络收发包PPS、连接数、多队列、云盘IOPS等性能参数也不同，不同ECS实例规格对应的性能参数对照表参考：ECS实例规格性能参数表
阿里云服务器存储提供云盘、本地盘，云盘分为高效云盘、SSD云盘和ESSD云盘，一台云服务器可搭配1到65块不同容量的存储磁盘，云盘提供最高9个9的可靠性，参考：云盘块存储详解
普惠上云，在活动：aliyunbaike.com/go/aliyun 中，新用户可以拿到低至1折的优惠折扣，关于阿里云服务器报价，也可以参考：https://www.aliyunbaike.com/ecs/6330/
2、专有网络VPC 专有网络VPC是阿里云为用户提供的云上私有网络，基于专有网络VPC可以构建隔离的网络环境，专有网络之间逻辑上彻底隔离，只能通过对外映射的IP（弹性公网IP和NAT IP）互联。由于使用隧道封装技术对云服务器的IP报文进行封装，所以云服务器的数据链路层（二层MAC地址）信息不会进入物理网络，实现了不同云服务器间二层网络隔离，因此也实现了不同专有网络间二层网络隔离。专有网络内的ECS使用安全组防火墙进行三层网络访问控制。
用户可以在专有网络VPC上按照自身实际情况配置访问控制规则，自定义网络规划如子网划分、自定义IP地址、网段、路由表和网关等。阿里云提供丰富的网络连接方式，如VPN、专线连接、NAT网关云企业网等。
3、快照与多种镜像类型选择 阿里云为每个云盘有1256个快照额度，为客户数据提供更长的保护周期和更细的保护粒度。自动快照可实现自动化数据备份，支持秒级创建/回滚的极速快照和快照一致性组。
阿里云为云服务器提供丰富的镜像及镜像类型，公共镜像、镜像市场、自定义镜像、社区镜像满足各类型用户对于应用环境的快速部署、灵活管理的需求。镜像可以定制、分发和共享。
4、多种付费类型 云服务器支持包年包月、按量付费、节省计划、预留实例券和抢占式5种付费模式，用以满足用户长周期低成本以及周期高弹性的计算要求，让用户按照自身所需选择合理的付费类型，节省成本。
节省计划：适合用户在一定时间段内（1年或3年）有稳定使用云资源的场景（以元/小时为单位衡量）。在购买节省计划后，开通计划下的ECS、ECI等按量资源，每小时可享受计划折扣权益，每小时账单将自动进行抵扣。包年包月：适合长期稳定的业务，购买周期越长，折扣越高，最高可享受5年3折。按量付费：紧贴业务需求购买资源的付费方式，秒级计费，用多少花多少。预留实例券：一种抵扣券，适合需要兼顾灵活性和成本的业务，或者需要预留实例资源的业务。搭配按量付费实例使用，可以抵扣掉按量付费实例计算部分的账单。相比直接使用按量付费实例，成本最大可以降低79%。抢占式实例：适合周期性离线计算场景，可使用远低于原价的成本获得资源，最低原价一折售卖，但会根据供需变化或者竞价价格而被释放。 二：云服务器的使用场景 几乎所有的IT架构都离不开云服务器，常见的应用场景如Web网站应用、在线游戏、大数据分析及深度学习等。阿里云百科以通用的Web网站应用为例，架构图如下：
阿里云服务器ECS使用场景架构图
如上图所示，云服务器ECS提供计算服务，这是业务的基础，CDN网络为Web应用提供内容分发服务，内容缓存在OSS存储，负载均衡处理HTTP请求，并将流量分发到主业务可用区，前端和应用服务器部署在ECS云服务器上，SLB可以做到负载均衡，ESS弹性伸缩按需业务创建或释放资源，部署在多可用区RDS上的数据库保证业务的容灾性能。
三：阿里云全球基础设施 阿里云基础设施目前已面向全球四大洲，开服运营28个公共云地域、86个可用区，此外还拥有5个金融云、政务云专属地域，并且致力于持续的新地域规划和建设，从而更好的满足用户多样化的业务和场景需求。伴随着基础设施的加速投入和深入布局，阿里云将为广大用户享受云计算的优质体验提供坚实基础。可以使用阿里云测速工具aliyunping.com测试一下本地到阿里云服务器各个地域节点的Ping值网络延迟。
阿里云全球基础设施地域数据中心
阿里云服务器研发团队，专注于阿里云基础设施中计算、存储和互联领域，从芯片、部件到整机系统进行持续研发与创新。目前研发成果主要包含服务器方升架构及自研硬件，自研存储硬件Aliflash，以及阿里云异构计算加速平台，通过整体推动阿里云新一代云原生硬件架构落地和服务器新品研发，为阿里云产品构筑从芯片到基础软件系统的核心技术竞争力，满足数字创新大潮下阿里云客户不断增长的对计算存储极致性能需求。
由阿里云自行建设并运营维护的超级数据中心，辐射京津冀、长三角、粤港澳三大经济带，为云计算提供超大规模算力支撑，并且在发挥强大计算性能的同时注重资源利用效率的提升，因地制宜，采用绿色清洁能源，如太阳能，风冷，液冷，深层湖水冷却技术等，用实际行动践行绿色发展理念。
四：阿里云服务器优势 阿里云弹性计算10年深厚技术积淀，云服务器具有稳定、弹性、安全、高性能、易用性及可拓展性等优势：
稳定：单实例可用性达 99.975%，多可用区多实例可用性达 99.995%，云盘可靠性达9个9，可实现宕机自动迁移、快照备份弹性：支持分钟级别创建千台实例，多种弹性付费选择更贴合业务现状，同时带来弹性的扩容能力，实例与带宽均可随时升降配，云盘可扩容安全：提供DDoS防护、木马查杀等服务，提供支持可信计算、硬件加密、虚拟化加密计算的实例，通过多方国际安全认证，ECS云盘支持数据加密功能高性能：单实例最高可选256vCPU ，内存6TB，主频3.8GHz，性能最高可达2400万PPS，80Gbps，100万IOPS，1600万session，网络时延20us+易用性：丰富的操作系统和应用软件，通过镜像可一键简单部署，同一镜像可在多台 ECS 中快速复制环境，轻松扩展可拓展性：ECS可与阿里云各种丰富的云产品无缝衔接，可持续为业务发展提供完整的计算、存储、安全等解决方案 五：客户案例 客户案例包括新浪微博、火花思维、汇量科技、驻云科技等，另外，淘宝“双十一”千亿交易背后五亿人的“剁手”是阿里云提供技术支持，上云就上阿里云。
更多关于阿里云服务器配置及精准报价，可以参考阿里云百科aliyunbaike.com关于云服务器ECS的详细说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fd1aa5dd70e6192f467b0c8ed51619/" rel="bookmark">
			uniapp获取用户手机号码，以及流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取用户手机号码需要6个必要条件，
1.必须是企业账号，否则是无权限获取的用户手机号码的，企业账号你需要获取到你微信小程序的appid和小程序密钥（这个后面要用到）
查看appid和小程序密钥的地址：
小程序https://mp.weixin.qq.com/wxamp/devprofile/get_profile?token=197451409&amp;lang=zh_CN
2.调用uni.login()获取到用户的code值
3.获取到用户code值之后调用uni.request()请求微信的服务器，拿到用户的session_key值
4.通过微信提供的获取微信手机号的方法getphonenumber拿到encryptedData iv两个字段的内容
5.用户授权完毕之后我们可以拿到encryptedData值和iv值（这两个值用于解密）
6.所有值全部都可以拿到之后，通过微信提供的解密方法：可以拿到最终的手机号
微信提供的方法在：
服务端获取开放数据 | 微信开放文档微信开发者平台文档https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html
找到WXBizDataCrypt.js放入自己的文件夹中，所有条件满足之后就可以正常走通了，此下面代码可以直接拿来使用，样式随便乱写的，自己调整
&lt;template&gt; &lt;view class="bigBox"&gt; &lt;view class="box"&gt; &lt;input v-model="phone" /&gt; &lt;view class="useWexin"&gt; &lt;button open-type="getPhoneNumber" @getphonenumber="getPhoneNumber" plain="true"&gt;获取手机号&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import WXBizDataCrypt from "../../utils/WXBizDataCrypt.js" export default { data() { return { phone: "", phone_iv: "", js_code: "", session_key: "", } }, onShow() { this.go() }, methods: { go() { uni.login({ provider: 'weixin', success: res =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39fd1aa5dd70e6192f467b0c8ed51619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5bc48de6f7c91ea2854bee987a31517/" rel="bookmark">
			js 引入lodash.js调用其方法demo 例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;html&gt; &lt;head&gt; &lt;title&gt;Lodash-Working Example&lt;/title&gt; &lt;script type = "text/JavaScript" src = "https://cdn.jsdelivr.net/npm/lodash@4.17.20/lodash.min.js"&gt;&lt;/script&gt; &lt;style&gt; div { border: solid 1px #ccc; padding:10px; font-family: "Segoe UI",Arial,sans-serif; width: 50%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div style = "font-size:25px" id = "list"&gt;&lt;/div&gt; &lt;script type = "text/JavaScript"&gt; // 去重 const arr = [1, 1, 2, 3, 3, 4, 5]; console.log(_.uniq(arr)); // [1, 2, 3, 4, 5] &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f240792c9f521c0efd38372d09b97a5f/" rel="bookmark">
			【Linux】1.0 登录用户配置 &#43; 基本指令part 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、登录二、Linux 配置普通用户三、一些常规设置四、OS 操作系统五、Linux 基本指令01 - pwd 指令02 - ls 指令ls 指令sum. 03 - cd 指令tree终止程序快捷键 cd 指令 sum. 04 - touch 指令nano 05 - mkdir 指令06.rmdir指令 &amp;&amp; rm 指令（重要） 一、登录 方式一：输入操作指令（以root用户为例）-[ ssh root @公网IP ] → 输入用户密码
方式二：新建 → 确认 → 打开 → 用户名：root → 输入用户密码 （如下图）
二、Linux 配置普通用户 以 root 账户登录，输入下述指令，查看已经配置过的普通用户： ls /home 创建普通用户： adduser [username] 例：adduser RoundBottle 设置密码：（密码不能包含用户名，不能小于7位，请根据提示设置密码） passwd [username] 例：passwd RoundBottle 注意：如果 忘记用户密码，以root用户登录，输入指令：passwd [username] 可以重新设置该用户的密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f240792c9f521c0efd38372d09b97a5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075eba13beb4fe61184238834f00610e/" rel="bookmark">
			基于el-tooltip组件封装超出显示省略号，鼠标hover显示tooltip的组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于el-tooltip组件封装超出显示省略号，鼠标hover显示tooltip的组件 el-tooltip组件存在的问题：
el-tooltip没有行超出显示省略号的功能使用了该组件每个hover都会显示tooltip，没有满足超出才显示的需求。 基于el-tooltip组件，实现一个超出行才显示hover tip的组件
&lt;template&gt; &lt;el-tooltip :disabled="!isShow" v-bind="$attrs"&gt; &lt;template #content&gt; &lt;slot name="content"&gt;{{ props.content }}&lt;/slot&gt; &lt;/template&gt; &lt;div class="content" :style="{width: props.width}" @mouseover="showTooltip"&gt; &lt;span ref="contentRef"&gt; &lt;slot&gt;{{ props.content }}&lt;/slot&gt; &lt;/span&gt; &lt;/div&gt; &lt;/el-tooltip&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref } from "vue"; interface props { content: string; width: string; } const props = withDefaults(defineProps&lt;props&gt;(), { content: "", width: "", }); const isShow = ref(true); const contentRef = ref(); const showTooltip = () =&gt; { // 判断行元素width是否超过父元素width，超过才显示el-tooltip if (contentRef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/075eba13beb4fe61184238834f00610e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/59/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>