<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e406d2dc9858d452c7663f7c13d535/" rel="bookmark">
			考研经验总结——目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、写作顺序二、个人情况说明三、读评论四、一些小牢骚五、一些注意事项（持续更新） 一、写作顺序 我将准备从三个阶段开始介绍吧
考研前考研中考研后（也就是现在我的这种情况） 考研前我会分为：数学、专业课、政治、英语 四个部分来写
我应该会涉及：学习方法总结、
二、个人情况说明 本科：双非二本
目标：南京211
专业：电子信息（学硕）
科目：政治、数学一、英语一、电子技术基础（数电、模电、信号）——复试：通信原理
数学：选填共错4个、后面大题对前两个、其他题的第一问也写了一点。估：91分
英语：完型对13个、阅读错7个、新题型错1个，估分：65
政治：单选加多选，得39分，估分：70
专业课（感觉有点寄）：估分100分
三、读评论 我刚刚从张宇的视频底下看到一些评论，拿出来稍微浅谈一下吧，不引战，说的不好也别喷
其实看到这里，也挺感慨的，我的题目刷的很少，考前10天才把真题刷完，那些什么冲刺卷，我就象征性的做了两套，没像他这么卷，做的这么多，我选择也是蒙3个，但是对了2个，大题对了两个
emmmm，我这个填空我也做了，也作对了，是-1/π，分母有个4（2的平方）他可能漏了。所以导致他算错了
四、一些小牢骚 2024.1.12
也是过了很久了，也说说考研本身吧。
首先是，坚持下去，会有结果的，也会有学上的。
在考研途中，会有各种心理崩溃的情况。比如，学习改专业课了，其他学校的大变动，可能会有大批考生临时到你这个方向，等等。（数二转数一的情况比较少）。我依稀记得，我这个专业，10月的时候吧，才公布，专硕直接砍了，幸好学硕没动，但是当时1-2天吧，确实很害怕，但凡有几个专硕想不开，专硕转学硕的，我就很头疼了。心理压力很大。思考了很久要不要换学校（换个普本研究生也是个不错的选择），但是最终还是没有换，一旦确定下来，心理就好多了，再一次就是网上预报名的时候。当你报名费交了的时候，心情也是尘埃落定了。
五、一些注意事项（持续更新） 因为我会时不时想起来，所以持续性程序
考研最后的2个月自己的作息一定要和考研匹配上（主要是中午），比方说上午11.30才考试结束，结果你正常一般11点就吃饭，那么考场上，可能你11点就开始饿了，会影响效率这边强烈建议把23年（对于你们就是24年的真题）的数学和英语都留在，考前的第4天这样，当成一次考试。上午考数学，下午考英语，严格按照考试时间划分。之后心里有个底。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75faf0ee8006026d2b2dd24d3dea5c17/" rel="bookmark">
			C&#43;&#43;力扣题目98--验证二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例 1：
输入：root = [2,1,3] 输出：true 示例 2：
输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内-231 &lt;= Node.val &lt;= 231 - 1 思路 要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。
有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。
#递归法 可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：
vector&lt;int&gt; vec; void traversal(TreeNode* root) { if (root == NULL) return; traversal(root-&gt;left); vec.push_back(root-&gt;val); // 将二叉搜索树转换为有序数组 traversal(root-&gt;right); } 然后只要比较一下，这个数组是否是有序的，注意二叉搜索树中不能有重复元素。
traversal(root); for (int i = 1; i &lt; vec.size(); i++) { // 注意要小于等于，搜索树里不能有相同元素 if (vec[i] &lt;= vec[i - 1]) return false; } return true; 整体代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75faf0ee8006026d2b2dd24d3dea5c17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df75211158a210321f54436d0a11de4/" rel="bookmark">
			Dubbo的服务降级策略剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 服务降级策略概述 设置Dubbo服务降级策略的主要目的，简单来说就是为了实现对指定服务的请求可以不处理或者简单处理。服务降级策略主要有以下两种：
（1）force策略。服务消费端不进行远程调用，直接执行mock方法（即服务降级方法），如返回设置的mock值、抛出异常或执行自定义mock类。
（1）mock = "force:return mock值" （2）mock = "force:throw 抛出的异常名称" （3）mock = "force:自定义的Mock类名" （2）fail策略。当调用远程接口失败时（非BIZ_EXCEPTION时），执行mock方法，如返回设置的mock值、抛出异常或执行自定义mock类。
（1）mock = "fail:return mock值" （2）mock = "fail:throw 抛出的异常名称" （3）mock = "fail:自定义的Mock类名" 服务降级主要用在以下场景：
当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，以释放服务器资源，保证核心任务的正常运行。当服务响应超时或连接请求超时，不用继续等下去，而采用降级措施，以防止分布式服务发生雪崩效应。在大促销之前通过降级开关关闭推荐、评价等对主流程没有影响的功能。大促销完毕后，再进行恢复。在秒杀这种流量比较集中并且流量特别大的情况下，因为突发访问量特别大可能会导致系统支撑不了。这个时候可以采用限流来限制访问量，当达到阀值时，后续的请求被降级。 总的来说，服务降级策略主要用在保障核心服务的可用性，防止分布式服务发生雪崩效应，以及在服务器压力剧增或服务响应超时等情况下保证服务的正常运行。
2 设置服务降级策略 设置服务降级策略的主要方式有以下两种：
（1）通过dubbo控制台设置指定服务的降级策略。
（2）在服务消费端设置接口级别或方法级别的服务降级策略。举例如下。
设置接口级别的降级策略：
@Reference(mock = "fail:return null") private TestService testService; 或者 &lt;dubbo:reference id="testService" interface="com.hn.TestService" protocol="dubbo" mock="fail:return null"/&gt; 设置方法级别的降级策略：
&lt;!-- 对getUserList方法进行降级，其它方法正常调用 --&gt; &lt;dubbo:reference id="testService" interface="com.hn.TestService" protocol="dubbo"&gt; &lt;dubbo:method name="getUserList" mock="fail:return null"/&gt; &lt;/dubbo:reference&gt; 3 服务降级策略过程剖析 在服务消费端发起远程调用的过程中，服务消费端首先调用MockClusterInvoker的invoker()方法。
（1）当没设置降级策略时，直接调用DubboInvoker的invoker()方法发起远程调用。
（2）当服务降级策略为“force策略”时，不进行远程调用，直接执行mock方法，如返回定义的mock值、抛出异常或执行自定义mock类。
（3）当服务降级策略不是“force策略”时，直接发起远程调用。当调用远程接口失败时（非BIZ_EXCEPTION时），执行mock方法，如返回设置的mock值、抛出异常或执行自定义mock类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7df75211158a210321f54436d0a11de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/759f16c327f197ab841f951ef56d767a/" rel="bookmark">
			C&#43;&#43;力扣题目700--二叉搜索树中的搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定二叉搜索树（BST）的根节点 root 和一个整数值 val。
你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。
示例 1:
输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3] 示例 2:
输入：root = [4,2,7,1,3], val = 5 输出：[] 思路 之前我们讲的都是普通二叉树，那么接下来看看二叉搜索树。
在关于二叉树，你该了解这些！ (opens new window)中，我们已经讲过了二叉搜索树。
二叉搜索树是一个有序树：
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树 这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。
本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。
#递归法 确定递归函数的参数和返回值 递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。
代码如下：
TreeNode* searchBST(TreeNode* root, int val) 确定终止条件 如果root为空，或者找到这个数值了，就返回root节点。
if (root == NULL || root-&gt;val == val) return root; 确定单层递归的逻辑 看看二叉搜索树的单层递归逻辑有何不同。
因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。
如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回NULL。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/759f16c327f197ab841f951ef56d767a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60831c9e8fb0a465cbec6b711f8c91ba/" rel="bookmark">
			Java锁的分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一章 Java线程池技术应用
第二章 CountDownLatch和Semaphone的应用
第三章 Spring Cloud 简介
第四章 Spring Cloud Netflix 之 Eureka
第五章 Spring Cloud Netflix 之 Ribbon
第六章 Spring Cloud 之 OpenFeign
第七章 Spring Cloud 之 GateWay
第八章 Spring Cloud Netflix 之 Hystrix
第九章 代码管理gitlab 使用
第十章 SpringCloud Alibaba 之 Nacos discovery
第十一章 SpringCloud Alibaba 之 Nacos Config
第十二章 Spring Cloud Alibaba 之 Sentinel
第十三章 JWT
第十四章 RabbitMQ应用
第十五章 RabbitMQ 延迟队列
Java锁的分类
文章目录 系列文章目录前言1、公平锁和非公平锁2、可重入锁3、独享锁/共享锁4、互斥锁/读写锁5、乐观锁/悲观锁6、分段锁7、偏向锁/轻量级锁/重量级锁8、自旋锁 前言 本章节介绍Java中的几种常见的锁：公平锁和非公平锁、可重入锁、独享锁/共享锁、互斥锁/读写锁、乐观锁/悲观锁、分段锁、偏向锁/轻量级锁/重量级锁、自旋锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60831c9e8fb0a465cbec6b711f8c91ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32eab75896425315e970974a2711bbfe/" rel="bookmark">
			C&#43;&#43;力扣题目617--合并二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你两棵二叉树： root1 和 root2 。
想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。
返回合并后的二叉树。
注意: 合并过程必须从两个树的根节点开始。
示例 1：
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] 示例 2：
输入：root1 = [1], root2 = [1,2] 输出：[2,2] 思路 相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？
其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。
#递归 二叉树使用递归，就要想使用前中后哪种遍历方式？
本题使用哪种遍历都是可以的！
我们下面以前序遍历为例。
动画如下：
那么我们来按照递归三部曲来解决：
确定递归函数的参数和返回值： 首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。
代码如下：
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { 确定终止条件： 因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了（如果t2也为NULL也无所谓，合并之后就是NULL）。
反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。
代码如下：
if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2 if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1 确定单层递归的逻辑： 单层递归的逻辑就比较好写了，这里我们重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32eab75896425315e970974a2711bbfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786f78299792189bbdefbe865b1cb03a/" rel="bookmark">
			C#执行数据加密的DES.Create 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、重载
二、Create()
1.定义 2.实例1，加密和解密文件中的数据
3.实例2，加密和解密内存中的数据
三、Create(String)
四、关于DES加密
命名空间：
System.Security.Cryptography
数据集：
System.Security.Cryptography.dll
创建加密对象的实例以执行数据加密标准 (DES) 算法。
一、重载 Create()创建加密对象的实例以执行数据加密标准 (DES) 算法。Create(String)创建加密对象的实例以执行数据加密标准 (DES) 算法的指定实现。 二、Create() 创建加密对象的实例以执行数据加密标准 (DES) 算法。
1.定义 public static System.Security.Cryptography.DES Create (); 返回 DES 一个加密对象。 2.实例1，加密和解密文件中的数据 // DES.Create() // 创建和使用 DES 对象来加密和解密文件中的数据。 using System.Security.Cryptography; using System.Text; namespace ConsoleApp8 { class DESSample { static void Main() { try { byte[] key; byte[] iv; using (DES des = DES.Create()) // 以随机秘钥创建加密流对象，初始化IV { key = des.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786f78299792189bbdefbe865b1cb03a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae20a219ae0964377ef7d5b6eaf052df/" rel="bookmark">
			【嵌入式——QT】QT静态编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【嵌入式——QT】QT静态编译 QT下载查看文档下载Visual Studio打开命令行模式编译添加QT到Qt Creator编译示例 QT下载 下载地址
进入目录，我这里选择的qt-everywhere-src-5.14.1.zip。
查看文档 解压压缩包打开源码，查看README文件，里面有windows的要求。
我们要选择一个编译环境 MinGW 和 MSVC，这两个环境是不兼容的，要看一下你当前支持的编译器是什么。
下载Visual Studio 我们下载自己所需要的Visual Studio来作为编译器，我这里选择的版本是2019版本，同时也是QT所支持的版本。
Visual Studio下载地址
按照步骤安装即可，选择社区版。
打开命令行模式 打开安装Visual Studio自带的 x86 Native Tools Command Prompt for VS 2019 或者 x64 Native Tools Command Prompt for VS 2019 看个人需求。我这里选择的是x86的。如果不知道怎么查找的话，可以直接按win按键，搜索native就会给你提示出来两个版本的工具。
编译 进入刚刚解压好的QT源码目录，D:\Qt\qt-everywhere-src-5.14.1\qtbase\mkspecs\common
打开msvc-desktop.conf文件，修改==-MD为-MT==。
修改前
QMAKE_CFLAGS_RELEASE = $$QMAKE_CFLAGS_OPTIMIZE -MD QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_OPTIMIZE -Zi -MD QMAKE_CFLAGS_DEBUG = -Zi -MDd 修改后
QMAKE_CFLAGS_RELEASE = $$QMAKE_CFLAGS_OPTIMIZE -MT QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_OPTIMIZE -Zi -MT QMAKE_CFLAGS_DEBUG = -Zi -MTd 提示：D的意思是动态编译(dynamic link)，T的意思是静态编译（static link）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae20a219ae0964377ef7d5b6eaf052df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf93af846937e45cfe96cd143d5920c/" rel="bookmark">
			RSIC-V“一芯”学习笔记（二）——Linux入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、Busybox套件三、重要的追踪工具——strace四、Shell五、正则表达式六、重定向（多次输入测试时）七、一些组合命令八、自动化脚本九、学会查阅十、亲（yuan）近(li) bai du十一、不要逃避困难十二、重视小问题 一、前言 这部分在之前学习嵌入式的时候，已经整理了很多方面的知识点，这里只会做一些补充，并不会大章的再次梳理
二、Busybox套件 嗯，刚刚特等去查了下什么是coreutils，其实就是一个工具包，而这个包里面，包含了很多常用的命令，比如cat、chmod、cp等等。以此类推，图上的后几种都是讲的命令。因此，不多赘述。
三、重要的追踪工具——strace 我第一眼看到这个名词的时候，我感觉很熟悉，在考研之前学到过。刚刚找了找，是我之前在学习内核的时候，有一篇文章，着重强调了strace的重要性，说，学好内核，这个strace能很方便去理解。
相关介绍在这
RK3399平台开发系列讲解（内核调试篇）2.19、strace跟踪器的原理及使用
比如，我想知道ls是如何运行的，显示当前目录的，你可以输入命令strace ls
“ls”是如何被寻找的
stace -f bash -c “ls”
区别：
在Linux中，strace是一个用于跟踪系统调用和信号的工具。通过在命令前加上strace，你可以查看该命令执行时系统调用的详细信息。现在来看一下strace ls和strace bash -c "ls"的区别：
strace ls：
这将跟踪直接运行的ls命令。
你将看到ls进程执行期间的系统调用和信号。
这将提供有关ls命令如何与系统进行交互的详细信息。
示例：
bash
Copy code
strace ls
strace bash -c “ls”：
这将跟踪运行在bash shell中的ls命令。
由于bash -c "ls"表示在bash中执行ls，你将看到bash及其子进程执行期间的系统调用和信号。
这将提供有关bash解释器如何执行命令以及与ls命令的交互的详细信息。
示例：
bash
Copy code
strace bash -c “ls”
总的来说，通过使用strace，你可以深入了解命令执行期间系统调用的细节，以及与操作系统内核的交互。
四、Shell 五、正则表达式 字符串匹配的编程语言
（不细讲）
六、重定向（多次输入测试时） 把要输入的一串指令放入“txt”文件，用sort进行排序
（说实话，没太理解，怎么把输出当成命令去使用）
七、一些组合命令 第一行就是，不断重试该命令直至成功，比如：网络不稳定，写一条循环上传。吃饭回来，就完成。
第二行cpuinfo就是cpu的相关信息
八、自动化脚本 讲命令写到一个文件里面
（提高效率）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf93af846937e45cfe96cd143d5920c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce010b0d5ffe34938ee0fa0259c71013/" rel="bookmark">
			关于tex中的表格设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 控制表格列宽和行高控制表格列宽的同时实现居中tex中多表格排列单元格的合并与分割对单个单元格进行操作 控制表格列宽和行高 将下面的代码放在table环境内，放在tabular环境外
== 调整表格宽度和高度==：
\resizebox{\textwidth}{2cm}{%第一个{}是表格宽度， 第二个{}是表格高度 \begin{tabular} XXXX \end{tabular} } %12可随机设置，调整到适合自己的大小为止
调整列间距：
\setlength{\tabcolsep}{7mm}{ \begin{tabular} XXXX \end{tabular} }%7可随机设置，调整到适合自己的大小为止
上面的代码实现的效果往往不好，实现的是一种图片性质的缩放。
改变行高的方法是：
\renewcommand\arraystretch{1}（在array宏包中）
arraystretch默认定义为1，可以重定义得到制定倍数的表格行距。例如：
控制表格列宽的同时实现居中 利用array宏包，并配合命令p{宽}&lt;{\centering}即可实现
\begin{table}[h] \caption{符号说明} \centering \begin{tabular}{ p{3cm}&lt;{\centering} p{7cm}&lt;{\centering} p{3cm}&lt;{\centering} } \toprule {\heiti 符号} &amp; {\heiti 意义}&amp; {\heiti 单位}\\ \hline Format &amp; Extension&amp; Description\\ Format &amp; Extension&amp; Description\\ Format &amp; Extension&amp; Description\\ \bottomrule \end{tabular} \end{table} tex中多表格排列 subcaption 宏包(和subfigure会冲突)
还同时提供了 subfigure 和 subtable 环境，它们的语法和功能与 minipage 完全相同，只是在里面可以直接使用 \caption 命令来表示子标题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce010b0d5ffe34938ee0fa0259c71013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3044640cb88e2e7094bd6c149f828168/" rel="bookmark">
			在服务器创建并进入虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在服务器创建并进入虚拟环境 创建虚拟环境 创建虚拟环境，envs-name为虚拟环境的命名：
conda create -n "envs-name" python=3.6 可以通过命令查看目前已有的虚拟环境：
conda env list 通过命令激活刚刚创建好的虚拟环境（我的虚拟环境命名为graph）：
source activate graph 配置安装torch等其他包 接着就可以在虚拟环境中配置需要的包。
安装之前，首先通过命令查看CUDA的版本，使用命令：
nvidia-smi 去Pytorch官网找到对应版本和命令：
复制命令行运行。
安装完成后还可以根据需要安装一些别的包：
pip install transformers 如果报错：ReadTimeoutError
可以使用以下命令安装：
pip --default-timeout=1000 install -U transformers 以上即为安装虚拟环境的过程。
退出虚拟环境的命令：
source deactivate "envs-name" 或者
conda deactivate 连接服务器 在Setting里面： 添加一个新的环境： 选择SSH，填写服务器地址和用户名： 输入密码： 填写自己的python环境，如果是按照刚刚新建的虚拟环境，地址就是：“/home/XiaoYu/anaconda3/envs/envs-name/bin/python” 这个代表了会自动上传的项目文件地址： 进入刚刚创建好的虚拟环境来运行项目 在Pycharm的运行栏Terminal里：
首先点加号进入服务器里面 从默认的base环境转换到新建的graph环境中： cd /home/XiaoYu/anaconda3/envs/graph/bin 进入该环境：
source activate graph 进入项目文件所在地址： cd /tmp/pycharm_project_358 运行该地址下的文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ffce6983eded9fe2f89e8251b97f76/" rel="bookmark">
			Java实现城市桥梁道路管理系统 JAVA&#43;Vue&#43;SpringBoot&#43;MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块三、系统展示四、核心代码4.1 查询城市桥梁4.2 新增城市桥梁4.3 编辑城市桥梁4.4 删除城市桥梁4.5 查询单个城市桥梁 五、免责说明 一、摘要 1.1 项目介绍 基于Vue+SpringBoot+MySQL的城市桥梁道路管理系统，支持管理人员动态维护城市桥梁道路数据，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，城市桥梁道路管理系统于角色的访问控制，给管理员、普通用户使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 城市桥梁道路管理系统是一种基于Vue、SpringBoot和MySQL的应用系统，旨在为城市管理部门提供桥梁和道路的监控、维护和管理功能。下面是一些可能包含的功能模块：
用户管理：管理系统的用户账号和权限，包括管理员和普通用户。
桥梁管理：记录和管理城市中的桥梁信息，包括桥梁的名称、位置、结构、年限等。可以进行桥梁的查询、添加、修改和删除操作。
道路管理：记录和管理城市中的道路信息，包括道路的名称、起止位置、车道数等。可以进行道路的查询、添加、修改和删除操作。
监控管理：实时监控城市中的桥梁和道路状况，包括实时数据的采集、展示和报警功能。
维护管理：记录和管理桥梁和道路的维护工作，包括维护计划、维护记录和维护人员的安排。
统计分析：对桥梁和道路的数据进行统计和分析，包括使用年限、维护次数、损坏程度等指标的统计和可视化展示。
报表管理：生成各种报表和文档，包括桥梁和道路的巡查报告、维护记录和统计分析报表等。
这些功能模块可以通过Vue作为前端框架实现用户界面的设计和交互，SpringBoot作为后端框架实现业务逻辑和数据处理，MySQL作为数据库存储和管理系统的数据。整个系统的开发和部署需要前后端协作，同时考虑用户友好性、系统性能和安全性等方面的要求。
三、系统展示 四、核心代码 4.1 查询城市桥梁 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询城市桥梁") public Result&lt;IPage&lt;CityBridge&gt;&gt; getByPage(@ModelAttribute CityBridge cityBridge ,@ModelAttribute PageVo page){ QueryWrapper&lt;CityBridge&gt; qw = new QueryWrapper&lt;&gt;(); if(!ZwzNullUtils.isNull(cityBridge.getTitle())) { qw.like("title",cityBridge.getTitle()); } if(!ZwzNullUtils.isNull(cityBridge.getCode())) { qw.like("code",cityBridge.getCode()); } if(!ZwzNullUtils.isNull(cityBridge.getType())) { qw.eq("type",cityBridge.getType()); } if(!ZwzNullUtils.isNull(cityBridge.getBuildCompany())) { qw.like("build_company",cityBridge.getBuildCompany()); } if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ffce6983eded9fe2f89e8251b97f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5339d2178496aff0c1a1e47d93dc3ec9/" rel="bookmark">
			开源监控服务一瞥：Prometheus、Grafana、Zabbix、Nagios、Icinga和Open-Falcon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着信息技术的发展，监控服务在维护系统稳定性和性能方面变得越来越重要。本文将比较一些流行的开源监控服务，以帮助你选择适合你需求的解决方案。
监控服务对比 监控服务特点优势不足性能扩展性安全性Prometheus- 多维度数据模型- 监控容器化环境的强大工具- 需要单独设置存储后端- 查询性能较高，适用于大规模环境- 可通过分布式部署进行横向扩展- 支持基于HTTPS的数据传输，提供基本认证- 支持服务发现自动发现和监控目标- 巨大的社区支持- 存储引擎性能较好，适用于长期存储- 支持联邦式集群，方便构建分布式系统- 强大的告警管理和通知机制Grafana- 数据可视化和仪表板设计- 美观、直观的图形化界面- 通常需要与其他监控系统结合使用- 轻量级，对系统资源要求较低- 支持插件开发，可通过插件扩展功能- 支持用户角色和权限控制- 支持多种数据源，包括Prometheus、InfluxDB等- 大量的插件和面板- 高度可定制，适用于实时数据可视化- 支持多种数据源，易于与其他系统集成Zabbix- 多层次的监控和告警- 集成了监控、告警和可视化- 配置复杂，初学者可能需要一些时间适应- 足够高的性能，适用于中小规模环境- 常用于大型企业，支持分布式监控- 提供用户角色和权限控制，支持SSL加密- 完整的事件管理和自动发现功能- 存储引擎适用于长期存储- 通过代理实现分布式监控Nagios- 插件系统，支持多种监控任务- 历史悠久，广泛应用于企业- 界面相对较老旧，不如一些现代化的解决方案直观- 较低的资源占用，适用于小规模环境- 支持插件扩展，但扩展性相对较弱- 依赖系统用户和权限设置- 强大的告警和报告功能- 大量的社区插件和扩展- 对周期性检查任务的性能表现较好Icinga- 基于Nagios的改进版本，保留了其优点- 适用于大规模和复杂的网络环境- 对于小型环境可能有些过于庞大- 性能较好，适用于中小规模环境- 支持插件和模块扩展- 支持SSL/TLS加密传输，提供身份验证- 灵活的配置和模块化设计- 支持REST API- 存储引擎适用于长期存储- 通过Satellite模块实现分布式监控Open-Falcon- 高度可扩展的架构- 提供分布式、高可用监控解决方案- 社区相对较小，相比其他监控系统较新- 较低的性能损耗，适用于大规模监控- 支持分布式部署，易于扩展- 提供身份验证和访问控制- 支持主机、服务、网络设备等多种监控- 多维度数据采集和展示- 存储引擎性能良好，适用于长期存储- 提供Agent、Transfer、Graph、Judge等组件- 实时数据监控和历史数据存储 总结 每个监控服务都有其独特之处，选择取决于你的特定需求。Prometheus和Grafana适用于容器化环境和实时数据可视化，Zabbix和Nagios适用于传统的监控需求，而Icinga在保留传统特性的同时提供了一些现代化的改进。Open-Falcon则以其高可扩展性和分布式监控方案为用户提供了一种新颖的选择。在选择之前，请确保深入研究每个服务的文档和功能，以找到最适合你的监控解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd25817e70b30715f65450940a09492/" rel="bookmark">
			技术专栏——你所不知道的 RocketMQ 的集群管理：副本机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些精彩的技术类型的体系化文章，后面我会放到公众号上，并集中在合集“分布式消息中间件专栏”中，欢迎大家去订阅我的公众号和视频号“架构随笔录”，大家可以订阅合集，这样更加方便喔，后面会出电子版本，更加方便。另外本人也出版过“Spring Cloud Alibaba微服务架构实战派上下册”的技术类书籍，另外新书“RocketMQ分布式架构实战派”即将上架。
RocketMQ 是阿里巴巴中间件团队开源出来的高可用、高性能和高并发的分布式消息中间件，也是在调研了行业生态中主流的消息中间件之后决定自研。Kafka 不能满足金融和电商业务场景对低延迟和高可靠性方面的变态要求，ActiveMQ 在队列以及主题达到上限之后，资源 I/O 又是瓶颈。早期的 RocketMQ 的集群管理只支持主从，也就是 Master-Master 或者 Master-Slave，从新版本 4.5.0 开始支持多副本机制。
本文主要内容包括：
RocketMQ 主从集群管理原理
RocketMQ 多副本集群管理原理
如何灵活应用 RocketMQ 集群管理的方法论
Chat 内容不在多，在于如何说清楚需要讨论的问题，本文适合对 RocketMQ 有一定了解的技术工程师、技术专家以及架构师。
本篇集群管理主要针对 Broker 端。
RocketMQ集群入门 集群角色
ASYNC_MASTER
SYNC_MASTER
SLAVE
ASYNC_MASTER 是同步 Master 节点，SYNC_MASTER 是异步 Master 节点，SLAVE 是从节点。如果对消息的可靠性和可用性要求比较严格，可以采用 SYNC_MASTER 加 SLAVE 的部署方式。如果对消息可靠性要求不高，可以采用 ASYNC_MASTER 加 SLAVE 的部署方式，提升 Producer 和 Consumer 的吞吐量。
如果只是运维部署方便，则可以选择仅 ASYNC_MASTER 或仅 SYNC_MASTER 的部署方式，也就是多个 Master 组成集群，当某一个 Master 挂了之后，数据就完全丢失了，没有备份。
集群如何启动 4.7.1-SNAPSHOT 版本集群启动方式：
1. 首先启动 Name Server 集群 nohup sh mqnamesrv &amp;，这个命令会直接启动类 NamesrvStartup，通过 main 函数完成初始化，从而启动 NamesrvController，并加载全局配置文件 NamesrvConfig，配置文件会默认加载 namesrv 文件目录下的文件——kvConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dd25817e70b30715f65450940a09492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f502759a09501421d588183994ec365/" rel="bookmark">
			编程竞赛-消息存取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录链接： 力扣编程题-解法汇总_分享+记录-CSDN博客 GitHub同步刷题项目： GitHub - September26/java-algorithms: 算法题汇总，包含牛客，leetCode，lintCode等网站题目的解法和代码，以及完整的mode类，甚至链表代码生成工具都有提供。
原题链接：登录—专业IT笔试面试备考平台_牛客网 题目描述 牛牛拥有一个消息队列，容量无限，为了检测其高效性，特意做了 n\mathit nn 次操作，指令如下：
首先输入一个字符串表示操作种类，如果字符串为 "in"，说明此操作为存消息，接着输入一个正整数 t\mathit tt 以及一个非空且仅由小写字母构成的字符串 s\mathit ss，表示将类型为 t\mathit tt 的消息 s\mathit ss 存入消息队列的末尾；
如果最先输入的字符串为 "out"，说明此操作为取消息，接着输入一个非负整数 p\mathit pp，如果 p = 0\mathit p\ =\ \text 0p = 0，则取出当前消息队列中的第一条消息，否则，取出类型为 p\mathit pp 的第一条消息。
如果成功取出消息，则将此消息输出，否则，输出 −1-\text 1−1 表示当前消息队列为空或者没有相应类型的消息。
输入描述: 第一行输入一个正整数 n(3 ≤ n ≤ 2 × 105)\mathit n(\text 3\ \leq\ \mathit n\ \leq\ \text 2\ \times\ \text {10} ^ \text 5)n(3 ≤ n ≤ 2 × 105)，表示操作次数。 接下去 n\mathit nn 行，每行输入一条操作指令，首先输入一个字符串 opt\mathit {opt}opt，如果 opt = in\mathit {opt}\ =\ \mathit {in}opt = in，则接着输入一个正整数 t(1 ≤ t ≤ 100)\mathit t(\text 1\ \leq\ \mathit t\ \leq\ \text {100})t(1 ≤ t ≤ 100)，以及一个非空且仅由小写字母构成的字符串 s(∣s∣ ≤ 10)\mathit s(\mid\mathit s\mid\ \leq\ \text {10})s(∣s∣ ≤ 10)； 如果 opt = out\mathit {opt}\ =\ \mathit{out}opt = out，则接着输入一个非负整数 p(0 ≤ p ≤ 100)\mathit p(\text 0\ \leq\ \mathit p\ \leq\ \text {100})p(0 ≤ p ≤ 100)； opt\mathit {opt}opt 只有上述两种可能，具体含义如题所述。 题目保证，数据中至少有一条取消息操作。 输出描述: 对于每一条取消息操作，一行输出其消息内容，或者输出 −1-\text 1−1。 示例1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f502759a09501421d588183994ec365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e35a3eeb4a60e65d51d5f28f620b5f1/" rel="bookmark">
			Bypass Paywalls Chrome Clean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 绕过付费墙 免费阅读国外日报 正常访问无法访问参考 1 从 GitLab下载此存储库作为ZIP 文件。2 解压缩该文件，您应该有一个名为 的文件夹bypass-paywalls-chrome-clean-master。3 将文件夹移动到计算机上的永久位置（安装后不要删除该文件夹）。4 转到扩展页面 ( chrome://extensions)。5 启用开发者模式。6 单击Load unpacked并选择/打开扩展文件夹（包含文件 manifest.json) 正常访问 lefigaro.fr 无法访问 lemonde.fr
letemps.ch
liberation.fr
参考 Bypass Paywalls Chrome Clean 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c003a41d511fa9e99b1915dd223940/" rel="bookmark">
			网页设计与网站建设作业html&#43;css&#43;js，一个简易的游戏官网网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简易的游戏网页 浏览器查看 目录结构 部分代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;我的游戏&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="./css/main.css"&gt; &lt;link rel="stylesheet" href="./css/iconfont.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="wrap"&gt; &lt;!-- header --&gt; &lt;div class="header"&gt; &lt;div class="logo"&gt; &lt;a href="./index.html"&gt;游戏官网&lt;/a&gt; &lt;/div&gt; &lt;div class="search"&gt; &lt;!-- &lt;span class="icon search iconfont icon-Searchsvg"&gt;&lt;/span&gt; --&gt; &lt;div class="search-input iconfont"&gt;&lt;input type="text" placeholder="王者荣耀"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="user"&gt; &lt;img class="logo" src="./images/logo.jpg"&gt; &lt;span class="username"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- main --&gt; &lt;div class="main"&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c003a41d511fa9e99b1915dd223940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7139a31a9d006f636a511e174d0d98/" rel="bookmark">
			如何使用统计鸟网站统计分析网站流量来源?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 统计鸟官网地址：https://www.tongjiniao.com/
站长必备！网站数据统计，流量监测平台
提供网站数据统计分析、搜索关键词、流量访问来源等服务
深入分析用户点击习惯，为智能化运营网站提供更好的用户体验
目录
一、注册账号信息
二、添加站点信息
三、放置统计代码
四、查看统计信息
一、注册账号信息 首先，在网站数据统计统计鸟网站注册账号并登录。
二、添加站点信息 然后，填写网站信息，添加站点。
三、放置统计代码 将统计代码放置在网站中需要统计的页面里的head标签中。
四、查看统计信息 做完以上准备工作以后，我们就可以在统计面板实时查看到网站的实时数据了。
总体来说，使用起来还是蛮不错的，相对于其它的网站统计产品来说，非常值得一试。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/549a963c3aaa5422dcb1d378ccea9699/" rel="bookmark">
			Maven的安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 国内Maven仓库之阿里云Aliyun仓库地址及设置 用过Maven的都知道Maven的方便便捷，但由于某些网络原因，访问国外的Maven仓库不便捷，好在阿里云搭建了国内的maven仓库。
需要使用的话，要在maven的settings.xml 文件里配置mirrors的子节点，添加如下mirror：
&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; Maven配置settings.xml指定默认java8版本 &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;jdk8&lt;/activeProfile&gt; &lt;/activeProfiles&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4ea43af34afd8542aa0163c7a916c2/" rel="bookmark">
			DNS解析和主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DNS名称解析协议
二、DNS正向解析
三、DNS主从复制
主服务器
从服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541c49ce757022f4f0647f3b999d7402/" rel="bookmark">
			【STM32】| 01——常用外设 | USART
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录
【STM32】| 01——常用外设 | USART
失败了也挺可爱，成功了就超帅。 文章目录 前言1. 基础理论1.1 并行通信和串行通信1.2 同步通信和异步通信1.3 单工/半双工/全双工1.4 电平信号(RS232/TTL)和差分信号(RS485)1.5 端口(COM) 2. 串口理论2.1 串口物理连接2.1.1 多个单片机之间串口连接2.1.2 单片机和其他设备连接 2.2 串口数据信号2.3 MCU串口外设 3. 串口实践3.1 串口查询式收发3.1.1 Cubemx配置3.1.2 编写发送代码3.1.3 编写接收代码3.1.4 查询式收发的应用场景 3.2 串口中断式收发3.2.1 Cubemx配置3.2.2 使用串口中断式发送3.2.3 使用串口中断式接收3.2.4 中断式收发应用场景 3.3 串口DMA收发3.3.1 Cubemx配置3.3.2 串口DMA(DMA正常模式)接收/发送3.3.3 串口DMA(DMA循环模式)接收/发送 3.4 串口空闲中断接收不定长数据3.4.1 查询式(阻塞)接收 + IDLE3.4.2 中断式接收 + IDLE3.4.3 DMA接收 + IDLE 3.5 环形缓冲区 前言 本文描述串口相关原理、配置及使用
如基础收发功能、串口+DMA+IDEL接收一帧数据、防止数据丢失加入环形缓冲区等
环境：stm32f103zet6 keil HAL库
1. 基础理论 串口能干吗 可以用来通信。串口通信是我们常用的设备通信方式。下面先从涉及的相关概念说起
1.1 并行通信和串行通信 一般通信方式可以分为两类
1、串行通信 如串口、SPI、IIC等
2、并行通信 如SRAM等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/541c49ce757022f4f0647f3b999d7402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7bf9f5b2cfa6a63c8ab50a64095828/" rel="bookmark">
			JavaWeb-HTTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 HTTP：HyperText Transfer Protocol，超文本传输协议。读者应该不是第一次接触这个名词，但可能仍然不是很理解，笔者将逐一解释。
HyperText（超文本）：根据维基百科，Hypertext is text displayed on a computer display or other electronic devices with references (hyperlinks) to other text that the reader can immediately access. 翻译：超文本是显示在计算机显示器或其他电子设备上的文本，其中包含读者可以立即访问的其他文本的引用（超链接）。说白了，就是一段包含跳转链接的文本，其中的链接可以跳转至一个新的文本，一张图片，一段音频，一段视频等等语义扩大后的文本。
Transfer（传输）：最开始的计算机是没有网络的，所有的文本也只能在本机上编辑，查看。随着网络的诞生，文本可以由一台计算机发送给另一台计算机，这个过程就是传输。
Protocol（协议）：所谓协议，其实就是一种约定，或者称为一种格式。由于超文本需要在计算机之间传输，为了识别传输的文本内容，那么就需要约定一种传输文本的格式。好比写信：我们通常由称呼开始，接着是正文，最后是写信人的署名和日期。计算机科学中的协议实质上也是一种类似的规范。在后续介绍到HTTP的请求数据格式与响应数据格式后，读者会加深对协议的理解。
二、请求数据格式与响应数据格式 认识一个东西最好的方式就是直接看看他。于是，我们直接来看看HTTP协议到底长什么样子。
（1）请求数据格式 POST / HTTP/1.1 Accept: text/html Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,is;q=0.8,en;q=0.7 Cache-Control: max-age=0 Connection: keep-alive Host: www.baidu.com Referer: https://www.baidu.com/ Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 sec-ch-ua-platform: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7bf9f5b2cfa6a63c8ab50a64095828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb98b4880d680dca8cb2440b8a994f7c/" rel="bookmark">
			Pygame程序的屏幕显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同对象的绘制与显示过程 在Pygame中，需要将所有需要在屏幕上显示的内容都绘制在一个display surface上。该Surface通常称为screen surface，它是pygame.display.set_mode()函数返回的Surface对象。
在绘制不同对象时，可以使用不同的绘制方法。下面介绍一些常用的绘制方法：
绘制图像：
使用pygame.image.load()函数加载图像文件，返回一个Surface对象。将需要绘制的图像blit到screen surface中，使用Surface.blit()方法进行绘制。 绘制文本：
使用pygame.font.Font()函数创建字体对象，该函数接受两个参数：字体文件的路径和字体大小。使用字体对象的render()方法将文本渲染成Surface对象。将渲染好的Surface对象blit到screen surface中。 绘制几何图形：
使用pygame.draw.rect()函数绘制矩形。使用pygame.draw.circle()函数绘制圆形。使用pygame.draw.line()函数绘制直线等。 Pygame中不同对象的显示过程 在Pygame中，不同对象的显示过程如下：
颜色填充：
调用screen surface对象的fill()方法，可以将整个screen surface区域或部分screen surface区域填充为指定颜色。 简单图形：
使用pygame.draw模块下的相关函数，例如pygame.draw.line()绘制直线、pygame.draw.rect()绘制矩形、pygame.draw.circle()绘制圆形等。将绘制函数的第一个参数指定为screen surface对象，以便将图形绘制在screen surface上。 图片图像：
使用pygame.image.load()方法加载图片文件，返回一个image surface对象，表示图片的像素信息。调用screen surface对象的blit()方法，将image surface绘制到screen surface上。blit()方法的第一个参数是要绘制的image surface，第二个参数是一个坐标元组，表示绘制的位置。 文字：
使用pygame.font.Font()函数创建字体对象，指定字体文件的路径和字体大小。使用字体对象的render()方法将文字渲染成一个text surface对象。调用screen surface对象的blit()方法，将text surface绘制到screen surface上。 在绘制完所有对象后，需要调用pygame.display.flip()或pygame.display.update()函数来更新屏幕显示。flip()函数会将screen surface的内容更新到屏幕上，并清除之前的内容。update()函数只会更新有变化的部分，可以提高程序的运行效率。
总之，在Pygame中，颜色填充只需调用fill()方法，简单图形使用相关绘制函数并指定screen surface为第一个参数，图片图像先加载为image surface再使用blit()方法绘制，文字先渲染为text surface再使用blit()方法绘制。最后需要调用flip()或update()函数更新屏幕显示。
在Pygame的画面中移动物体 在Pygame中，要移动物体，可以按照以下步骤进行操作：
在游戏循环中，使用pygame.Surface.fill()方法或其他绘制函数将物体绘制在屏幕上。在每次循环中，更新物体的位置。可以通过改变物体的坐标来实现物体的移动。在下一次循环开始之前，使用pygame.Surface.fill()方法或其他绘制函数将物体从原来的位置擦除。使用pygame.Surface.blit()方法或其他绘制函数将物体绘制到新的位置上。 注意：
注意对象的绘制顺序，后绘制的对象会把先绘制的对象覆盖住。注意及时清除屏幕，当在循环中不断绘制某个对象时，若是没有及时清除屏幕，则会导致“重影”现象，特别是在对象移动的情况下；因此在每次重绘时，最好清除屏幕内容，可以利用fill（）方法把整个屏幕填充为相同颜色，也可重绘背景图片，具体方法取决于应用场景。注意记得调用pygame.display.flip（）或者pygame.display.update（）更新屏幕，否则屏幕上什么都不会显示。 具体示例：一个运动的小球 import pygame pygame.init() # 设置窗口大小 size = [400, 300] screen = pygame.display.set_mode(size) # 设置窗口标题 pygame.display.set_caption("Moving Ball") # 设置背景颜色 bg_color = (255, 255, 255) # 设置小球初始位置和速度 ball_pos = [50, 50] ball_speed = [2, 2] # 游戏循环 done = False while not done: # 处理事件 for event in pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb98b4880d680dca8cb2440b8a994f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bee67302968a8a2f4b54aa7e25e89a7/" rel="bookmark">
			写在学习webkit过程的前面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webkit起源于KHTML，是KDE开源项目的KHTML和KJS引擎的一部分。在它的诞生和发展过程中，由两家著名的公司参与开发过程中，造成两次裂变。诞生两个内核webkit和blink，并发展和产生了两个主流的浏览器，分别为safari和chrome。
现在两个重要的分支，分别由苹果和谷歌两家公司把持控制着，在浏览器市场，基于这两个内核的浏览器，已经占有市场的绝大部分份额，特别是移动端的浏览器基本上都是基于这两个分支开发的。
因此webkit技术学习，就非常重要了，虽然两个分支经过多年的各自发展，差距越来越大，但是还能找到各自相似的影子。
特别是最近通过下载各自的代码和各种版本进行编译对比，觉得对webkit系统的学习还是非常必要，只有深入的理解对比学习和分析，才能更好理解和使用。
特别是在以往做相关的web项目和进行网页的数据抓取项目开发过程中，对javascript、vue等框架开发中，对浏览器的网页渲染原理的理解总是不够透彻，特别是爬取网页数据时，对浏览器的原理就更为重要了。因此计划将在未来的学习分析源码的过程中，将学习和分析的结果学习笔记的方式来分享出来，与大家一起学习提高。
通过前面编译的源代码过程也进一步认识到，现在的开发工具和使用的语音也不再是单纯的一种语言的工具，特别是webkit是可以跨平台的，可以在windows、mac os x、linux等平台下进行代码移植共享。主体编程语言主要是c/c++，但是链接编译流程和代码处理，还使用了python、perl、ruby等语言，还引入了chocolatey、cmake、WinCairo、AppleWin支持库、ninja等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0ebbee4ac63d9eb83b323b7a9e94da/" rel="bookmark">
			揭秘HTTP协议：深入了解互联网通信的核心！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HTTPHTTP的消息结构HTTP 常用请求方法HTTP 状态码 HTTP HTTP 是超文本传输协议，HTTP是缩写，全称是 HyperText Transfer Protocol
超文本指的是 HTML、css、JavaScript和图片等，HTTP的出现就是为方便接收和发布超HTML页面，经过不断的发展，也可以用于发布接收一些音频、文件等。
HTTP 协议是用于客户端和服务端之间的通信，除此之外还有 TCP/IP 协议族在内的众多协议，请求文本资源的一方，我们称之为客户端（client），接收请求并提供相应的一方称为服务端（Server）
有时候，客户端和服务端身份是可以互换的，单就一条通信线路来讲，可以确定的是，由HTTP协议就可以区分谁是客户端谁是服务端
HTTP 的特点：
支持客户端、服务端模式，简单快速，http 允许任意传输类型的数据对象，无连接，限制每次连接处理一个请求，无状态，指明协议对事物处理没有标记的能力。灵活：允许任何数据对象，音频、视频、图片、文件等…无状态：任何两个请求之间没有必然的联系无连接：每次服务器在处理完请求后，就断开连接了，再请求就是新的连接，采用这种方式节省传输时间 HTTP1.0版的主要缺点
每个TCP 连接智能发送一个请求，发送数据完毕后，连接就关闭了，HTTP 是一种不保存状态，无状态协议，协议对于发送过来的请求或是响应都不做持久化处理
HTTP1.1虽然是无状态协议，但是为了实现期望的保存状态功能，于是引入了 Cookie技术，有了 Cookie，HTTP 协议通信，就可以管理状态了。
TCP 连接的新建成本很高，因为客户端需要和服务端 三次握手
交流端简单流程：客户端发起连接，客户端发起请求，服务端响应请求，服务端关闭链接
HTTP的消息结构 请求消息的结构：
一个请求消息是由 请求行，请求头字段，一个空行和消息主体 构成
消息主体是响应消息的承载数据
客户端：发送请求
GET/HTTP/1.1 Host: xiangi.love 服务器：发送响应
HTTP/1.1 200 OK Date: Tue, 10 Jul ... Content.Length: 362 Content.Type: text/html &lt;html&gt; ... Request Method：请求方法
Request URL：请求URL 的路径
Status Code 为状态码
Remote Address：地址
HTTP 是基于 TCP/IP 协议的应用层协议，不涉及数据包传输，规定了客户端和服务端之间的通讯方式，默认使用80端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0ebbee4ac63d9eb83b323b7a9e94da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5122b54107109a7d358b83396d9c51e5/" rel="bookmark">
			终极Linux命令宝典：从入门到精通，一网打尽！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux命令详解1、Linux初级命令1.1、ls（List）1.1.1、ls-常用参数： 1.2、pwd（Print Working Directory）1.3、touch（change file timestamps）1.3.1、touch-常用参数 1.4、cat&amp;tac (Concatenate FILE(s))1.4.1、常用参数 1.5、mkdir（Make Directory）1.5.1、常见参数 1.6、cd （Change Directory）1.7、rm&amp;rmdir（Remove Directory）1.7.1、常用参数 1.8、mv（Move）1.8.1、常用参数 1.9、cp（copy）1.10、echo1.11、head&amp;tail1.11.1、head1.11.2、tail 1.12.、more&amp;less1.12.1、常用参数 1.13、wc1.14、date1.15、cal1.16、which1.17、whereis1.17.1、常用参数 1.18、ps1.18.1、常用参数 1.19、kill&amp;killall 2、Linux进阶命令2.1、find2.1.1、find参数格式2.1.2、find命令参数find常用参数示例 2.2、grep2.3、cut2.4、diff2.5、tar2.6、du2.7、df2.8、lsof2.9、netstat2.10、ifconfig2.11、hostname2.12、route2.13、vmstatvmstat介绍vmstat参数格式vmstat命令参数vmstat常用参数示例解释 2.14、freefree介绍free参数格式free命令参数free常用参数示例解释 2.15、toptop介绍top参数格式top命令参数top常用参数示例解释 2.15、sarsar介绍sar参数格式sar命令参数 Linux命令详解 1、Linux初级命令 1.1、ls（List） List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.
列出有关文件的信息(默认为当前目录)。如果没有指定-cftuvSUX或——Sort，则按字母顺序排序。
1.1.1、ls-常用参数： -a 列出指定目录下的所有文件，包括隐藏文件
-c 使用最后一次更改文件状态以进行排序(-t)或长时间打印(-l)的时间
-h 与-l选项一起使用时，请使用单位后缀:Byte、Kilobyte、mete、gb、tb和Petabyte，以便使用以2为基数的大小将数字减少到3或更少
-l 长格式列表。(见下文)。如果输出到终端，则所有文件大小的总和将输出到长清单前面的一行中
-n 以数字形式显示用户和组id，而不是在长(-l)输出中转换为用户或组名。这个选项默认打开-l选项
-o 以长格式列出，但省略组id
-s 显示每个文件实际使用的文件系统块的数量，以512字节为单位，其中部分单元四舍五入为下一个整数值
-t 在按照字典顺序对操作数排序之前，先按修改的时间排序(最近修改的是first)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5122b54107109a7d358b83396d9c51e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2ddd702b9a2f3ea9107c50609dc0fe/" rel="bookmark">
			机器学习&#43;大数据项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、特征工程 特征清洗
特征监控
特征选择
计算每一个特征和响应变量的相关性
通过L1正则项来选择特征
训练能对特征打分的预选模型
通过特征组合后再来选择特征 通过深度学习来进行特征选择
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26999092612422134239eaffaf67250f/" rel="bookmark">
			学习笔记-数据查询语言DQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基本语法 select [all|distinct] 字段1 [别名1],字段2 [别名2]... from 表名 where 条件 group by 分组字段 having 分组之后的条件 [asc|desc] order by 排序 limit 数字或列表 2.数据准备 CREATE TABLE product ( pid INT PRIMARY KEY, pname VARCHAR(20), price DOUBLE, category_id VARCHAR(32) ); # 插入数据 INSERT INTO product(pid,pname,price,category_id) VALUES(1,'联想',5000,'c001'); INSERT INTO product(pid,pname,price,category_id) VALUES(2,'海尔',3000,'c001'); INSERT INTO product(pid,pname,price,category_id) VALUES(3,'雷神',5000,'c001'); INSERT INTO product(pid,pname,price,category_id) VALUES(4,'杰克琼斯',800,'c002'); INSERT INTO product(pid,pname,price,category_id) VALUES(5,'真维斯',200,'c002'); INSERT INTO product(pid,pname,price,category_id) VALUES(6,'花花公子',440,'c002'); INSERT INTO product(pid,pname,price,category_id) VALUES(7,'劲霸',2000,'c002'); INSERT INTO product(pid,pname,price,category_id) VALUES(8,'香奈儿',800,'c003'); INSERT INTO product(pid,pname,price,category_id) VALUES(9,'相宜本草',200,'c003'); INSERT INTO product(pid,pname,price,category_id) VALUES(10,'面霸',5,'c003'); INSERT INTO product(pid,pname,price,category_id) VALUES(11,'好想你枣',56,'c004'); INSERT INTO product(pid,pname,price,category_id) VALUES(12,'香飘飘奶茶',1,'c005'); INSERT INTO product(pid,pname,price,category_id) VALUES(13,'海澜之家',1,'c002'); INSERT INTO product(pid,pname,price,category_id) VALUES(14,'小米',1999,''); INSERT INTO product(pid,pname,price,category_id) VALUES(15,'华为',6999,'null'); INSERT INTO product(pid,pname,price,category_id) VALUES(16,'蜜雪冰城',1,null); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26999092612422134239eaffaf67250f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa46210b89b1ca9c45945a795b623151/" rel="bookmark">
			OpenGl 19高级GLSL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.GLSL的内建变量 在着色器中，需要当前着色器以外地方的数据的话，必须把数据传进来。之前我们是通过uniform类型和采样器来完成的。之外，GLSL还支持另外几个以gl为前缀的变量，提供更多读写数据的方式，比如说顶点着色器的gl_Position和片段着色器的gl_FragCoord
1.顶点着色器变量 gl_PointSize
当我们选取的一个图元是GL_POINT的话，每一个顶点都是一个图元，都会被渲染为一个点。这时我们可以通过OpenGL的glPointSize函数来设置渲染出来的点的大小，也可以在顶点着色器中修改这个值。 在顶点着色器中修改点大小的功能默认是禁用的，如若使用，则需要启用它
glEnable(GL_PROGRAM_POINT_SIZE); 同时我们可以将点的大小设置为裁剪空间的z值，也就是顶点距观察者的距离，点的大小会随着据观察者顶点距离的变远而增大。最后得到一个类似粒子的效果。
gl_VertexID
整型变量gl_VertexID储存了正在绘制顶点的当前ID。 2.片段着色器变量 gl_FragCoord（输入变量）
之前我们一直利用这个变量的z分量来获取片段的深度值，然而，我们也可以利用它的x和y分量来实现一些效果。
gl_FragCoord的x和y分量是窗口空间的坐标，原点为窗口的左下角，我们可以利用对x，y的控制得到一些想要的效果。
如下：我们可以得到一个两种颜色划分的渲染结果图。 void main() { if(gl_FragCoord.x &lt; 400) FragColor = vec4(1.0, 0.0, 0.0, 1.0); else FragColor = vec4(0.0, 1.0, 0.0, 1.0); } gl_FrontFacing
在面剔除中，我们可以根据顶点的环绕顺序来决定一个面是正向还是背向面，然后如果我们不使用顶点环绕顺序来判断，使用gl_FrontFacing可以判定当前片段是属于正向面的一部分还是背向面的一部分。如果是正向面的一部分，那么其值为true，如果是背向面的一部分，那么其值为false。这样我们就可以创建一个立方体，在内部和外部使用不同的纹理。 #version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D frontTexture; uniform sampler2D backTexture; void main() { if(gl_FrontFacing) FragColor = texture(frontTexture, TexCoords); else FragColor = texture(backTexture, TexCoords); } 如下，从箱子内部观察时：
二.接口块 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f08cbdb09c73f150164b7ecd0c1b6c/" rel="bookmark">
			网页设计与网站建设作业html&#43;css&#43;js，一个简易的答题考试网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简易的答题考试网页 目录结构 部分代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;在线考试&lt;/title&gt; &lt;link rel="stylesheet" href="./asset/main.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="wrapper"&gt; &lt;!-- 头部 --&gt; &lt;header class="header"&gt; &lt;!-- 标题 --&gt; &lt;h1&gt;网页设计与网站建设&lt;/h1&gt; &lt;/header&gt; &lt;!-- 主体内容 --&gt; &lt;main class="main"&gt; &lt;!-- 左边导航 --&gt; &lt;nav class="left-side"&gt; &lt;ul&gt; &lt;li class="current"&gt; &lt;a href="./index.html"&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="./danxuan.html"&gt;单选题&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="./duoxuan.html"&gt;多选题&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="./tiankong.html"&gt;填空题&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="./jianda.html"&gt;简答题&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f08cbdb09c73f150164b7ecd0c1b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06feb407a02e4e7fa076bfe7d160bfeb/" rel="bookmark">
			“sudo pip：找不到命令” 怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：先检查python版本
python --version
2：然后根据python版本下载相应的pip
sudo apt-get install python3-pip
(不同版本的python改变后面数字就行）
3：下载完成后再对pip进行一个升级
pip install --upgrade pip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b344d7bcc4d95d98bd04223f87552d/" rel="bookmark">
			溯源阿里巴巴的中台架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明朝可以说是中国封建王朝中最后一个由汉人统治的王朝，就算是最后清王朝也是不断的学习汉人的治国方略，但是学习最多的当然是明朝。
其实阿里巴巴的中台战略其实和明朝的历史还是蛮像的，这里小编就和大家好好的探讨一下。
今天先来从明朝的治国方略中去解析架构师的重要性。
熟悉明朝历史的小伙伴应该非常的清楚，尤其是朱元璋搞的那一套，我确实是佩服，这套组织架构理念，把明朝早期的官员是治的服服贴贴的。
第一，朱元璋设立中书省，也就是这个机构能够直达天子，天子可以休息，但是中书省不能休息；
第二，为了节制中书省的权利，朱元璋又设立左右丞相，并且在中书省成立之初，权利最高的左丞相居然是大将军徐达，而擅长管理国家事务的李善长居然是右丞相，这一点确实太高明；
第三，朱元璋严格控制官方的俸禄，也就是说明朝官员的薪水都非常的低。
从国家的角度去看，朱元璋绝对是大明王朝的顶级架构师，也就是说他负责从0到1的架构了整个大明王朝的组织结构，也奠基了整个大明两百多年的国运的基石。
总之，朱元璋既要依赖中书省处理朝廷事务，几乎就是等同于天子办公，又要防着中书省。
大家都知道，阿里巴巴的中台战略其实有点类似于明朝的中书省，中书省的实际控制人是朱元璋，但是阿里巴巴的中台战略的实际控制人是马云领导的高层。
那么中台战略的核心就是要确立业务中台和技术中台的核心领导地位，也就是说企业一旦要去做中台，那就需要给予中台绝对的权利，这样才能真正的去发挥中台的优势。
就像明朝的中书省一样，在明朝建立初期，它的效果还是非常明显的，毕竟国家百废待兴，需要有一批能人去做事情，并且是替天子做事情。
中台的思想其实也是一样的，无论是哪家公司，中台都是要快速的去响应高层的需求，这样这个中台才是有意义的，不然都是扯淡。
如何评判一个公司的中台战略是否高效呢？
首先，不要看前期的业务阻力，只要是创新就会存在各种声音，比反对也好，支持也好，其实都是从自身的利益出发的，也就是利己主义，但是假如高层要强推中台，并且赋予了对应负责人的赏罚决断的权利，那么有那么一点阻力，也不要惊讶，因为你的权利大了，肯定是有跳出来和你对着干的，一个改革者是不会惧怕这些流言蜚语的。
然后，是否有一直和目前公司的技术团队味道不一样的产品、测试和开发人员，也就是说要有一只战斗力强的军队，这样你才能去做事和成事，假如没有，那么千万不要去碰，那样你会沦为老板中台的炮灰。
其次，要看你的中台服务是否能够阶段性的接入业务服务，比如优先考虑去下沉基础服务，也就是说将基础的业务服务改造完成之后，快速的下沉到中台，并为各个产品线提供服务。
这里有一个判断高效的策略，比如你以前每个产品线部署抽离出的基础服务需要20台机器，目前有三个产品线，那就是需要20*3台机器，那么接入你的中台服务之后，通过优化性能和流程，只需要10台机器就解决了，那么老板看到这个数据之后，就认为这个非常提效，并且还节约成本。
最后，做中台一定要将总的战略拆分为若干个可以落地的里程碑战略，并且各个突破。
并且做中台一定要先做技术，也就是技术一定要跟上，妄想只做业务，而不做技术，去落地中台的，那样肯定会死的很难看的。
阿里巴巴之所以中台能够落地，除了老板的全力支持之外，那肯定是离不开一线的技术开发人员的技术储备和业务储备，以及全力的朝着一个目标去努力。
另外网上很多都在传阿里巴巴的中台已经拆了，但凡是做过中台的开发人员都知道，这个肯定是不可能的，组织架构调整，但是底层的技术架构肯定不可能短时间替换的。
中台战略是一种非常重的架构模式，也就是说只有你的业务足够负复杂，并且沉淀了很多业务元素和产品之后，中台才是一种高效的产品落地的方式，但是当你的产品复杂到一定程度之后，也就是说你的业务的变与不变很难做区分了，中台就很难满足“创新速度非常快”的产品的诉求了，这样中台就会成为制约产品创新的阻力了。
当然一般公司在落地业务中台的时候，都会按域来拆分的，比如我们会拆分用户中台、订单中台和支付中台等。
总之阿里巴巴的中台思想来源于欧洲一家公司，但是追踪溯源，其实和明朝的中书省类似，都是高度的集权组织。
如果用的好，那么就可以非常的高效，假如用的不好，就像朱元璋一样，会直接将中书省废弃掉，并永久性的罢免宰相这个角色。
另外我的新书RocketMQ消息中间件实战派上下册，在京东已经上架啦，目前都是5折，非常的实惠。 https://item.jd.com/14337086.html​编辑https://item.jd.com/14337086.html
“RocketMQ消息中间件实战派上下册”是我既“Spring Cloud Alibaba微服务架构实战派上下册”之后，又一本历时超过1年半的巨无霸技术实战类型的书籍。
为了提高读者阅读本书的体验性，本书总共设计了十个特色，下面我一一的给技术小伙伴阐述一下。 【特色一】由浅到深 本书将RocketMQ的技术原理和最佳实践体系化，按照由浅到深的顺序呈现给读者，使读者可以按照章节顺序按部就班地学习。当学习完全书内容之后，读者不仅能熟悉RocketMQ的核心原理，还能充分理解RocketMQ的“根”。
【特色二】技术新 本书不仅包括RocketMQ4.x（4.9.2版本）的核心原理分析和最佳实践，还包括RocketMQ5.x（5.1. 0版本）的新特性分析和最佳实践。
【特色三】精心设计的主线：零基础入门，循序渐进，直至彻底掌握RocketMQ 本书精心研究了程序类、架构类知识的认知规律，全书共分为6篇：①基础；②进阶；③高级；④高并发、高可用和高性能；⑤应用；⑥新特性，是一条相对科学的主线，让读者快速从“菜鸟”向“RocketMQ分布式架构实战高手”迈进。
【特色四】绘制了大量的图，便于读者理解RocketMQ的原理、架构、流程 一图胜于文，书中在涉及原理、架构、流程的地方配有插图，以便读者更加直观地理解。
【特色五】从架构师和技术专家的视角分析RocketMQ 本书创造性地分析了RocketMQ具备高并发、高可用和高性能的功能及原理，并从架构的视角展开分析，这些也是程序员进阶为技术专家或架构师必备的技能。
以下为从架构师和技术专家的视角分析RocketMQ典型案例，读者阅读完本书之后，也能够达到这样的水准。
【特色六】不仅有原理分析，还有大量的实战案例 本书介绍了大量的实战案例，能让读者“动起来”，在实践中体会功能，而不只是一种概念上的理解。
在讲解每一个知识模块时，我在思考：在这个知识模块中，哪些是读者必须实现的“标准动作”（实例）；哪些“标准动作”是可以先完成的，以求读者能快速有一个感知；哪些“标准动作”具有一定难度， 需要放到后面完成。读者在实践完书中的案例之后，就能更容易理解那些抽象的概念和原理了。
本书的目标之一是，让读者在动手中学习，而不是“看书时好像全明白了，一动手却发现什么都不会”。通过体系化的理论和实战案例去培养读者的主动学习能力，这样本书的价值就会被最大化。 本书相信“知行合一”的理念，而不是“只知，而不行”，避免开发人员出现眼高手低的现象。尤其是在技术面试过程中，面试官更加看重的是既懂原理，又能够主动是实践技术的技术人。
【特色七】深入剖析原理 本书以系统思维的方式，从业务功能视角剖析 RocketMQ 底层的技术原理，使读者具备快速阅读 RocketMQ 框架源码的能力。读者只有具备了这种能力，才能举一反三，实现更复杂的功能，应对更复杂的应用场景。
【特色八】从运维的视角分析 RocketMQ 的最佳实践 【特色九】参与开源 本书向读者展示了如何修改 RocketMQ 源码，并快速验证案例分析。这样，读者可以从中学到参与开源的技能，并为后续自己能够参与开源做准备。
【特色十】双色印刷，读者体验会更好 为了提高读者阅读本书的体验，在有上下两册的前提下（巨无霸，超过800页），出版社不吝啬印刷成本，依然采用双色印刷。
【推荐】本书的最佳学习路径 为了提高读者学习RocketMQ的效率，我这边结合我自身从RocketMQ小白到RocketMQ专家的经历，为读者汇总了一条最佳学习路径。
【寄语】作者寄语 RocketMQ是我深度参与研究的一款开源消息中间件，无论是从源码，还是架构场景，我都提炼了很多最佳实践。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b344d7bcc4d95d98bd04223f87552d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cccc8de25cfdd1907c7de919e90f591/" rel="bookmark">
			【JVM的相关参数和调优】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JVM 调优的参数类型一、标配参数二、X参数三、XX参数 JVM 调优的常用参数 JVM 调优的参数类型 一、标配参数 这类此参数在jdk的各个版本之间很少会变化，基本不改变
java -version，查看当前电脑上的jdk的版本信息 java -help，查看java命令的各种选项和参数 java -showversion，相当于上述两者结合 4. jps，查看后台运行的 java 进程
public class Test { public static void main(String[] args) throws InterruptedException { // 让该程序一致在后台 Thread.sleep(Integer.MAX_VALUE); } } Test 的进程 id 为 29636
5. jinfo，通过进程 id 查看正在运行的 java 程序的参数信息
jinfo -flag 具体参数（XX参数） java进程编号（-flag，是一个进程号同时指定要查看的一个参数）
jinfo -flags java进程编号（-flags，是一个进程号所有的参数）
二、X参数 java -Xint -vesion，解释执行模式 解释执行命令会告诉java虚拟机使用解释执行模式来执行程序。在解释执行模式下，Java程序的代码将逐行被解释器翻译成机器指令并执行。这种模式通常会导致程序执行速度较慢，但它可以在不同的平台上运行代码，因为不需要事先将代码编译成机器代码。
java -Xcomp -version，第一次使用就编译成本地代码 编译执行命令会告诉java虚拟机在第一次执行程序时将代码编译成本地机器代码。这种模式下，Java程序的代码会被即时编译器翻译成机器指令，并保存下来以备下次执行使用。这样，在后续执行时，程序的执行速度会比解释执行模式下更快，因为代码已经被编译成机器代码。
java - Xmixed -version，混合模式（JVM默认采用的模式） 混合模式命令会告诉java虚拟机在运行时根据程序的运行情况来选择解释执行或即时编译执行。在混合模式下，虚拟机会根据代码的热度来判断是否将其编译成机器代码。热度通常是通过代码的执行频率衡量的。因此，混合模式可以充分利用即时编译的性能优势，同时又能适应代码的动态性。
三、XX参数 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cccc8de25cfdd1907c7de919e90f591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92cde9a4f5af794d33dec11b37e772f1/" rel="bookmark">
			Rust-类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bool 布尔类型(bool)代表的是“是”和“否”的二值逻辑。它有两个值：true和false。
一般用在逻辑表达式中，可以执行“与”“或”“非”等运算。
char 字符类型由char表示。它可以描述任何一个符合unicode标准的字符值。在代码中，单个的字符字面量用单引号包围。
字符类型字面量也可以使用转义符：
因为char类型的设计目的是描述任意一个unicode字符，因此它占据的内存空间不是1个字节，而是4个字节。
对于ASCⅡ字符其实只需占用一个字节的空间，因此Rust提供了单字节字符字面量来表示ASCⅡ字符。我们可以使用一个字母b在字符或者字符串前面，代表这个字面量存储在u8类型数组中，这样占用空间比char型数组要小一些。示例如下：
整数类型 Rust有许多的数字类型，主要分为整数类型和浮点数类型。本节讲解整数类型。各种整数类型之间的主要区分特征是：有符号/无符号，占据空间大小。
需要特别关注的是isize和usize类型。
它们占据的空间是不定的，与指针占据的空间一致，与所在的平台相关。如果是32位系统上，则是32位大小；如果是64位系统上，则是64位大小。
在C++中与它们相对应的类似类型是int_ptr和uint_ptr。Rust的这一策略与C语言不同，C语言标准中对许多类型的大小并没有做强制规定，比如int、long、double等类型，在不同平台上都可能是不同的大小，这给许多程序员带来了不必要的麻烦。相反，在语言标准中规定好各个类型的大小，让编译器针对不同平台做适配，生成不同的代码，是更合理的选择。
数字类型的字面量表示可以有许多方式：
字面量后面可以跟后缀，可代表该数字的具体类型，从而省略掉显示类型标记：
我们可以为任何一个类型添加方法，整型也不例外。比如在标准库中，整数类型有一个方法是pow,它可以计算n次幂，于是我们可以这么使用：
我们甚至可以不使用变量，直接对整型字面量调用函数：
对于整数类型，如果Rust编译器通过上下文无法分析出该变量的具体类型，则自动默认为i32类型。比如：
整数溢出 在整数的算术运算中，有一个比较头疼的事情是“溢出”。
在C语言中，对于无符号类型，算术运算永远不会overflow,如果超过表示范围，则自动舍弃高位数据。
对于有符号类型，如果发生了overflow,标准规定这是undefined behavior,也就是说随便怎么处理都可以。
未定义行为有利于编译器做一些更激进的性能优化，但是这样的规定有可能导致在程序员不知情的某些极端场景下，产生诡异的bug。
Rust的设计思路更倾向于预防bug,而不是无条件地压榨效率，Rust设计者希望能尽量减少“未定义行为”。
比如彻底杜绝“Segment Fault”这种内存错误是Rust的一个重要设计目标。
当然还有其他许多种类的bug,即便是无法完全解决，我们也希望能尽量避免。
整数溢出就是这样的一种bug。
Rust在这个问题上选择的处理方式为：默认情况下，在debug模式下编译器会自动插入整数溢出检查，一旦发生溢出，则会引发panic。
在release模式下，不检查整数溢出，而是采用自动舍弃高位的方式。示例如下：
Rust编译器还提供了一个独立的编译开关供我们使用，通过这个开关，可以设置溢出时的处理策略：
$rustc -C overflow-checks=no test.rs “-C overflow-checks=”可以写“yes”或者“no”,打开或者关闭溢出检查。
如果在某些场景下，用户确实需要更精细地自主控制整数溢出的行为，可以调用标准库中的checked_*、saturating_*和wrapping_*系列函数。
输出结果为：
checked_*系列函数返回的类型是Option&lt;_&gt;,当出现溢出的时候，返回值是None。
saturating_*系列函数返回类型是整数，如果溢出，则给出该类型可表示范围的“最大/最小”值。
wrapping_*系列函数则是直接抛弃已经溢出的最高位，将剩下的部分返回。
在对安全性要求非常高的情况下，强烈建议用户尽量使用这几个方法替代默认的算术运算符来做数学运算，这样表意更清晰。
在Rust标准库中就大量使用了这几个方法，而不是简单地使用算术运算符，值得大家参考。
在很多情况下，整数溢出应该被处理为截断，即丢弃最高位。
浮点类型 Rust提供了基于IEEE 754-2008标准的浮点类型。按占据空间大小区分，分别为f32和f64,其使用方法与整型差别不大。浮点数字面量表示方式有如下几种：
Infinite和Nan是带来更多麻烦的特殊状态。Infinite代表的是“无穷大”,Nan代表的是“不是数字”(not a number)。
指针类型 同一个类型，某些时候可以指定它在栈上，某些时候可以指定它在堆上。内存分配方式可以取决于使用方式，与类型本身无关。既可以直接访问数据，也可以通过指针间接访问数据。可以针对任何一个对象取得指向它的指针。既可以在复合数据类型中直接嵌入别的类型的实体，也可以使用指针，间接指向别的类型。甚至可能在复合数据类型末尾嵌入不定长数据构造出不定长的复合数据类型。Rust里面也有指针类型，而且不止一种指针类型。
在标准库中还有一种封装起来的可以当作指针使用的类型，叫“智能指针”(smart pointer)。 类型转换 Rust对不同类型之间的转换控制得非常严格。即便是下面这样的程序，也会出现编译错误：
Rust提供了一个关键字as,专门用于这样的类型转换：
tuple tuple指的是“元组”类型，它通过圆括号包含一组表达式构成。tuple内的元素没有名字。tuple是把几个类型组合到一起的最简单的方式。比如：
元组内部也可以一个元素都没有。这个类型单独有一个名字，叫unit(单元类型):let empty:()=();
可以说，unit类型是Rust中最简单的类型之一，也是占用空间最小的类型之一。
struct 结构体(struct)与元组类似，也可以把多个类型组合到一起，作为新的类型。区别在于，它的每个元素都有自己的名字。举个例子：
tuple struct Rust有一种数据类型叫作tuple struct,它就像是tuple和struct的混合。区别在于，tuplestruct有名字，而它们的成员没有名字：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92cde9a4f5af794d33dec11b37e772f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/088bac6d3071af21237d327d7fab80de/" rel="bookmark">
			多级缓存架构(二)Caffeine进程缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引入依赖二、实现进程缓存1. 配置Config类2. 修改controller 三、运行四、测试 通过本文章，可以完成多级缓存架构中的进程缓存。
一、引入依赖 在item-service中引入caffeine依赖
&lt;dependency&gt; &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt; &lt;artifactId&gt;caffeine&lt;/artifactId&gt; &lt;/dependency&gt; 二、实现进程缓存 这是Caffeine官方文档地址
1. 配置Config类 创建config.CaffeineConfig类
@Configuration public class CaffeineConfig { @Bean public Cache&lt;Long, Item&gt; itemCache(){ return Caffeine.newBuilder() .initialCapacity(100) .maximumSize(10_000) .build(); } @Bean public Cache&lt;Long, ItemStock&gt; stockCache(){ return Caffeine.newBuilder() .initialCapacity(100) .maximumSize(10_000) .build(); } } 2. 修改controller 在ItemController中注入两个Cache对象，并修改业务逻辑
@RestController @RequestMapping("item") public class ItemController { @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; @Autowired private Cache&lt;Long, Item&gt; itemCache; @Autowired private Cache&lt;Long, ItemStock&gt; stockCache; @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/088bac6d3071af21237d327d7fab80de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7bad57198cfd1a8136978e9329e5806/" rel="bookmark">
			在微服务架构中认证和授权的那些事儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微服务架构中认证和授权是最基础的服务能力，其中这一块行业类的标准就是OAuth2 和 SSO ，而OAuth2 和 SSO 可以归类为“用户管理和身份验证”工具，OpenID Connect 1.0是 OAuth 2.0 协议之上的一个简单身份层。
Part.1 认识OAuth 2.0 OAuth 2.0（访问委托的开放标准），它是一个授权框架，使第三方应用程序能够代表资源所有者通过协调资源所有者和 HTTP 服务之间的批准交互，或通过允许第三方应用程序获得对 HTTP 服务的有限访问权限代表自己获取访问权限；
OAuth 2.0的原理 OAuth 2.0 是一种授权协议，而不是身份验证协议。因此，它主要被设计为授予对一组资源（例如，远程 API 或用户数据）的访问权限的一种方式。
OAuth 2.0 使用访问令牌。访问令牌是代表最终用户访问资源的授权的一段数据。OAuth 2.0 没有为访问令牌定义特定格式。但是，在某些情况下，经常使用 JSON Web Token (JWT) 格式。这使令牌发行者能够在令牌本身中包含数据。此外，出于安全原因，访问令牌可能有到期日期。
OAuth 2.0的角色 角色的思想是OAuth2.0授权框架核心规范的一部分。这些定义了 OAuth 2.0 系统的基本组件，如下所示：
（1）资源所有者：拥有受保护资源并可以授予访问权限的用户或系统。
（2）客户端：客户端是需要访问受保护资源的系统。要访问资源，客户端必须持有适当的访问令牌。
（3）授权服务器：该服务器接收来自客户端的访问令牌请求，并在资源所有者成功验证和同意后发出这些请求。授权服务器公开两个端点：授权端点，它处理用户的交互式身份验证和同意，以及令牌端点，它涉及机器对机器的交互。
（4）资源服务器：保护用户资源并接收来自客户端的访问请求的服务器。它接受并验证来自客户端的访问令牌，并将适当的资源返回给它。
OAuth 2.0的范围 范围是 OAuth 2.0 中的一个重要概念。它们用于准确指定可以授予资源访问权限的原因。可接受的范围值以及它们与哪些资源相关，取决于资源服务器。
OAuth 2.0访问令牌和授权码 OAuth 2授权服务器在Resource Owner授权访问后可能不会直接返回Access Token。相反，为了更好的安全性，可以返回授权码，然后将其交换为访问令牌。此外，授权服务器还可以使用访问令牌颁发刷新令牌。与访问令牌不同，刷新令牌通常有很长的有效期，并且可以在后者到期时交换为新的访问令牌。由于刷新令牌具有这些属性，因此客户端必须安全地存储它们。
OAuth 2.0是如何工作的？ 在最基本的层面上，在可以使用 OAuth 2.0 之前，客户端必须从授权服务器获取自己的凭证、_client id_ 和客户端密码，以便在请求访问令牌时识别和验证自己。
使用 OAuth 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7bad57198cfd1a8136978e9329e5806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c163885476cd18f045410c125cd47797/" rel="bookmark">
			响应式编程WebFlux基础API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebFlux的工作流程 在WebFlux中，主要的组件包括：
Reactor: Reactor是WebFlux底层使用的响应式编程库，提供了Mono和Flux这两种响应式类型，分别用于表示0-1个和0-N个异步序列元素。WebHandler: 是处理请求的核心接口，所有的请求都会被分配给一个WebHandler来处理。HandlerMapping: 用于将请求映射到对应的WebHandler。HandlerAdapter: 用于适配WebHandler的执行，使其能够处理请求并返回响应。WebFilter: 类似于Servlet中的Filter，可以在请求处理前后进行拦截和处理。ServerResponse和ServerRequest: 分别代表HTTP的响应和请求，在WebFlux中用于处理非阻塞的请求和响应。RouterFunction: 用于声明式地定义路由规则，将请求映射到处理器函数。 工作流程图 Request Dispatch Map to Filter Process Response Return Use Async Processing Client Server HandlerMapping WebHandler WebFilter HandlerAdapter ServerResponse Reactor 在这个流程中：
客户端发送请求到服务器。服务器接收到请求，并将其分发给HandlerMapping。HandlerMapping根据请求信息将其映射到对应的WebHandler。WebFilter可以在请求到达WebHandler之前或之后进行拦截和处理。WebHandler处理请求，可能会使用Reactor库中的Mono或Flux进行异步处理。HandlerAdapter将WebHandler的处理结果适配成服务器可以发送的响应。ServerResponse将响应返回给客户端。 WebFlux核心API 1. HttpHandler与HttpServer HttpHandler HttpHandler是WebFlux中处理HTTP请求的核心接口之一。它代表一个能够处理HTTP请求并生成响应的组件。HttpHandler可以被看作是一个函数，接受一个HTTP请求并返回一个表示HTTP响应的Publisher。典型的HttpHandler可以是一个Lambda表达式或一个实现了接口的类。可用于 Reactor Netty 的适配器， Undertow、Tomcat、Jetty 和任何 Servlet 容器。
HttpServer HttpServer是Reactor Netty提供的一个用于构建HTTP服务器的类。它允许你配置服务器的主机名、端口、SSL支持等信息。
public class SimpleHttpHandlerServerExample { public static void main(String[] args) throws IOException { HttpHandler httpHandler = RouterFunctions.toHttpHandler( RouterFunctions.route() .GET("/hello", request -&gt; ServerResponse.ok().bodyValue("Hello, WebFlux!")) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c163885476cd18f045410c125cd47797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435fc8c7fcf12539e5ec779774ee0b2c/" rel="bookmark">
			响应式编程初探-自定义实现Reactive Streams规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学响应式编程，这里先记录下，响应式编程的一些基础内容
1.名词解释 Reactive Streams、Reactor、WebFlux以及响应式编程之间存在密切的关系，它们共同构成了在Java生态系统中处理异步和响应式编程的一系列工具和框架。
Reactive Streams：
Reactive Streams 是一个规范，定义了一组接口和协议，用于处理异步数据流的背压。它包括发布者（Publisher）、订阅者（Subscriber）、订阅（Subscription）和处理器（Processor）等接口。Reactive Streams 规范的目标是提供一种标准的方式来处理异步数据流，解决背压问题。Java标准库从Java 9开始提供了 java.util.concurrent.Flow 类，定义了Reactive Streams规范。 Reactor：
Reactor 是一个基于Reactive Streams规范的响应式编程框架。它提供了一组用于构建异步、事件驱动、响应式应用程序的工具和库。Reactor 的核心是 Flux（表示一个包含零到多个元素的异步序列）和 Mono（表示一个包含零或一个元素的异步序列）。Reactor 通过提供响应式的操作符，如map、filter、flatMap等，使得开发者能够方便地进行数据流的转换和处理。 WebFlux：
WebFlux 是Spring Framework 5引入的响应式编程支持。它构建在 Reactor 之上，提供了一套用于构建异步、非阻塞、响应式的Web应用程序的API。WebFlux支持使用Reactive Streams处理HTTP请求和响应。Spring WebFlux 可以用于构建反应式的RESTful服务，支持使用注解的方式定义路由和处理器函数。 响应式编程：
响应式编程是一种编程范式，强调数据流和变化的传播。在这个范式中，数据源产生数据并通知观察者，观察者相应地处理这些数据。这种方式更容易处理异步操作和事件。在Java中，响应式编程通常涉及到使用类似于Reactor或RxJava的库，这些库提供了响应式的操作符和工具。 综上所述，Reactive Streams 提供了规范，Reactor 是一个实现了该规范的响应式编程框架，而WebFlux是Spring对于响应式编程的支持。它们共同致力于构建异步、非阻塞、响应式的应用程序。响应式编程则是一种更广义的编程范式，与Reactive Streams和Reactor等具体实现密切相关。
2.Reactive Streams 规范 2.1.Reactive Streams规范定义 在java.util.concurrent.Flow 类中，定义了Reactive Streams规范
Publisher（发布者）：负责生成数据流，并向订阅者发送数据。Subscriber（订阅者）：表示数据流的消费者，它订阅一个或多个发布者，并接收数据。Subscription（订阅）：表示订阅关系的接口，用于控制数据流的请求和取消。Processor（处理器）：充当发布者和订阅者的中间组件，可以对数据进行转换和处理。 2.2.API方法 1. Publisher（发布者）: interface Publisher&lt;T&gt; { void subscribe(Subscriber&lt;? super T&gt; subscriber); } subscribe(Subscriber&lt;? super T&gt; subscriber)： 用于订阅数据流。当订阅者调用这个方法时，发布者将建立与订阅者的订阅关系，并开始推送数据。 2. Subscriber（订阅者）: interface Subscriber&lt;T&gt; { void onSubscribe(Subscription subscription); void onNext(T item); void onError(Throwable throwable); void onComplete(); } onSubscribe(Subscription subscription)： 在订阅关系建立时调用。通过这个方法，订阅者可以持有 Subscription 对象，以便后续请求数据和取消订阅。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/435fc8c7fcf12539e5ec779774ee0b2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8064fa4c09ca3e5ad5eaed3d6449e3c/" rel="bookmark">
			如何改造现有文件为 CMD 模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何改造现有文件为 CMD 模块 经过一段考察，我们终于要在项目中引入模块机制和 Sea.js 了，那么如何将现有的文件改造成 CMD 模块就成了重要的问题。下面针对一些典型场景来说明包装的方式。
首先还是请大家详细了解下 CMD 模块定义规范，只要洞悉事物的定义和本质，一切问题可迎刃而解。
改造主流模块 这里指的是 jQuery、Moment、Backbone、underscore 等业界主流模块，这些模块一般都有对 AMD 和 CommonJS 的支持代码，例如 jQuery 源文件的最后几行：
if ( typeof module === "object" &amp;&amp; module &amp;&amp; typeof module.exports === "object" ) { module.exports = jQuery; } else { window.jQuery = window.$ = jQuery; if ( typeof define === "function" &amp;&amp; define.amd ) { define( "jquery", [], function () { return jQuery; } ); } } 还有 Backbone 里：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8064fa4c09ca3e5ad5eaed3d6449e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c81d5244f0b9ca6cdbd55de480904a6/" rel="bookmark">
			Python装逼代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天，我们来做两个可以装逼的代码。
一、黑客帝国 做这个需要有pygame库。
首先导入库
import random import pygame 代码部分：
import random import pygame PANEL_width = 600 PANEL_highly = 500 FONT_PX = 15 pygame.init() winSur = pygame.display.set_mode((PANEL_width, PANEL_highly)) font = pygame.font.SysFont("123.ttf", 25) bg_suface = pygame.Surface((PANEL_width, PANEL_highly), flags=pygame.SRCALPHA) pygame.Surface.convert(bg_suface) bg_suface.fill(pygame.Color(0, 0, 0, 28)) winSur.fill((0, 0, 0)) letter = ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm'] texts = [ font.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c81d5244f0b9ca6cdbd55de480904a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29870e9127305b56f9e528b7a92b7c8c/" rel="bookmark">
			【架构专题】我为什么要写Spring Cloud Alibaba微服务架构实战派上下册这本书？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写这本书之前，我先后在两家杭州的“独角兽”公司担任技术负责人，并推进公司核心业务的“中台化”改造。在落地业务中台和技术中台的过程中，督促并指导开发人员统一使用Spring Cloud Alibaba作为中台服务最底层的基础框架。为了快速推进业务服务Spring Cloud Alibaba化的进度，我冲在业务的第一线，收集和整理开发人员在使用Spring Cloud Alibaba过程中反馈的技术问题，并提供有效的技术解决方案，直至项目落地。
我每周都会做技术复盘，通过分析大量的问题总结出一个结论：开发人员反馈的问题大部分都是由于Spring Cloud Alibaba使用不合理所造成的。也就是说，很多开发人员并不了解Spring Cloud Alibaba的原理及如何落地实践。于是，我就产生了把我这几年落地Spring Cloud Alibaba的经验通过图书的方式输出的想法。
我写本书的主要目的也是为了让大家能够学到新的技术，并告诉大家有这些技术可以为大家所用。
当初定的目标让大家能够学到如下知识。
（1）掌握Spring Cloud Alibaba的核心原理及微服务架构项目实战经验；
（2）掌握Nacos注册中心和配置中心的核心原理及微服务架构项目实战经验；
（3） 掌握Sentinel的核心原理及微服务架构项目实战经验；
（4） 掌握 Seata的核心原理及微服务架构项目实战经验；
（5）掌握RocketMQ的核心原理及微服务架构项目实战经验；
（6）掌握Skywalking的核心原理及微服务架构项目实战经验；
（7）掌握Elastic Job的核心原理及微服务架构项目实战经验；
（8）掌握ShardingSphere的核心原理及微服务架构项目实战经验；
（9）掌握Spring Cloud Gateway的核心原理及微服务架构项目实战经验；
（10）掌握分布式缓存Redis的集群管理和分布式锁的原理及微服务架构项目实战经验；
（11）掌握Discovery的核心原理及微服务架构项目实战经验；
（12）掌握在业务中台和技术中台中落地“基于Spring Cloud Alibaba微服务架构”的项目实战经验；
（13）掌握在微服务架构中“基于DataX的异构数据迁移“的项目实战经验；
（14）掌握在微服务架构中“基于Skywalking的链路告警平台“的项目实战经验；
（15）掌握在微服务架构中“基于ELK和Sywalking的全链路日志平台“的项目实战经验；
Part.1 本书特色 本书聚焦于Spring Cloud Alibaba微服务架构实战，全面分析了基于Spring Cloud Alibaba的微服务架构全栈技术原理。本书有如下特色：
（1）技术新
Spring Cloud Alibaba是一个将Spring Cloud“阿里巴巴化”的微服务架构框架，它具备Spring Cloud 所有的能力，并添加了Nacos、Dubbo、RocketMQ等 Spring Cloud不具备的微服务架构能力。简单来说就是：搭建微服务架构，使用Spring Cloud ALibaba比使用Spring Cloud 更高效，更简单，开发的技术成本更低。
本书中所有代码采用目前的Spring Cloud Alibaba的最新版本（2.2. 5.RELEASE）来编写，与Spring Cloud Alibaba相关的微服务技术（Seata、RocketMQ等）也采用的是目前最新的稳定版本。
（2）精心设计的主线：零基础入门，循序渐进，直至项目实战。
本书精心研究了程序类、架构类知识的认知规律，全书总共分为五个部分：入门篇、基础篇、中级篇、高级篇及项目实战篇，设计了一条相对科学的主线“它是什么→怎么进行基础环境搭建→怎么搭建基础开发环境→怎么进行单项技术开发→怎么完成一个完整的项目”，让读者快速从菜鸟向微服务架构实战高手迈进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29870e9127305b56f9e528b7a92b7c8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a0ae7e54a7811207a3546abeabfd69/" rel="bookmark">
			彻底解决charles抓包https乱码的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做js逆向，听说charles比浏览器抓包更好用，结果发现全是乱码，根本没法用。
然后查询网上水文：全部都是装证书，根本没用！
最后终于找到解决办法，在这里记录一下：
乱码的根本原因： charles证书过期了！
此时就算往操作系统导入证书也没有用！
解决办法： 菜单：Help=&gt;SSL Proxing=&gt; Reset Charles Root Certificat 重置证书！
然后再install Charles Root Certificate 再重启charles, 注意了，一定要重新打开charles!
搞定！
然后注意下面两个配置：
1. SSL Proxy Setting=&gt;include=&gt; host和port都填*号
2. 必须通过chrome的代理插件SwitchyOmega来调用charles的8888端口，否则charles捕获不到抓包的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81fa872675c9ec713863006e2d178404/" rel="bookmark">
			基于LVGL编写的windows串口工具： LCOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LCOM: Serial Port Tools based on LVGL (PC Software) 一直以来我都想用LVGL做一个真正意义上的PC软件，来验证或者表达LVGL出色的特性，现在我用LCOM做到了！
LCOM 是一个基于LVGL编写的串口工具，界面简洁，功能出色，并且上手简单。
LCOM的一些功能包括：
以HEX或ASCII格式发送和接收数据。 实时刷新COM端口列表。可设置COM端口的连接参数包括波特率、奇偶校验、数据位、停止位和流控。 支持定时发送 支持换行发送(CR、LR、CRLF) 多种字符编码格式支持，比如 ASII,GBK(Chinese),UTF-8,UTF-16 等 Modbus模式支持（为百问网STM32H5 modbus解决方案准备（学习教程）） 界面多语言支持 多条字符串发送 自动保存设置（退出保存） 串口自动检测，支持记住上次使用的串口号 串口断线自动重连 TCP/UDP 支持，包括客户端和服务端模式支持 自定义主题 More todo 演示视频：https://www.bilibili.com/video/BV1bK4y1z7se
获取 LCOM GitHub: https://github.com/100askTeam/LCOM/releasesGitee:https://gitee.com/weidongshan/LCOM/releases 源码 Not yet open source (soon)
GitHub: https://github.com/100askTeam/LCOMGitee:https://gitee.com/weidongshan/LCOM Issues GitHub: https://github.com/100askTeam/LCOM/issuesGitee:https://gitee.com/weidongshan/LCOM/issues 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2611a3c556e4331c898274475eb4ddd/" rel="bookmark">
			使用 EmbeddingBag 和 Embedding 完成词嵌入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍨 本文为[🔗365天深度学习训练营学习记录博客\n🍦 参考文章：365天深度学习训练营\n🍖 原作者：[K同学啊 | 接辅导、项目定制]\n🚀 文章来源：[K同学的学习圈子](https://www.yuque.com/mingtian-fkmxf/zxwb45)
使用 EmbeddingBag 和 Embedding 完成词嵌入，首先需要处理文档中的文本，将其转换为适合进行词嵌入的格式，涉及到以下步骤：
文本清洗：移除文档中的特殊字符和标点符号，将文本统一为小写（如果适用）。分词：将文本分割成单词或标记（tokens）。建立词汇表：从分词后的文本中创建一个词汇表，每个唯一的单词对应一个索引。文本向量化：将文本转换为数字形式，以便进行嵌入处理。 第二步，使用 EmbeddingBag 和 Embedding 层进行词嵌入。EmbeddingBag 层适用于处理变长的文本，它会计算所有嵌入向量的平均值或和。而 Embedding 层适用于单个单词或固定长度的序列。
目标文件： 实现代码： from collections import Counter import torch import torch.nn as nn import re # 清洗文本并进行分词 def tokenize(text): # 移除特殊字符和标点，并转换为小写 text = re.sub(r'[^\w\s]', '', text).lower() # 分词 return text.split() # 创建词汇表 def create_vocab(text_tokens): vocab = Counter(text_tokens) vocab = sorted(vocab, key=vocab.get, reverse=True) vocab_to_int = {word: ii for ii, word in enumerate(vocab, 1)} # 索引从1开始 return vocab_to_int # 将文本转换为数字形式 def text_to_int(tokens, vocab_to_int): return [vocab_to_int[word] for word in tokens if word in vocab_to_int] # 定义Embedding和EmbeddingBag层 def define_embedding_layers(vocab_size, embedding_dim=100): embedding = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2611a3c556e4331c898274475eb4ddd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79607b975c3267af95f1192b9c1948c6/" rel="bookmark">
			最佳解决方案：如何在网络爬虫中解决验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Captcha（全自动区分计算机和人类的公开图灵测试）是广泛应用的安全措施，用于区分合法的人类用户和自动化机器人。它通过呈现复杂的挑战，包括视觉上扭曲的文本、复杂的图像或复杂的拼图等方式，要求用户成功解决这些挑战以验证其真实性。然而，在进行网络爬虫时，验证码的存在可能带来重大障碍。在本文中，我们将深入探讨在网络爬虫过程中常见的各种验证码类型，并重点介绍如何有效解决验证码的最佳方法，特别是利用Capsolver这一可靠而先进的验证码解决服务的能力。
在开始之前，这里有一个额外的Capsolver优惠码：WSC
使用该优惠码后，每次充值后您将获得额外的5%奖励。
什么是网络爬虫？ 网络爬虫是自动提取网站数据的过程。它涉及以编程方式访问网页、解析其内容并提取所需信息。网络爬虫已成为各种目的的无价工具，包括市场研究、竞争分析、数据挖掘等。
验证码在网络安全中的重要性： 验证码通过区分人类用户和自动化机器人的方式在网络安全中发挥着关键作用。它们作为一种防御机制，阻止机器人访问敏感信息或执行恶意活动。验证码通常要求用户完成挑战，例如识别扭曲的文本、选择特定图像或解决谜题。
是否有可能解决验证码？ 验证码可以被解决，尽管完全绕过它们是困难的。推荐的方法是通过实施措施，如速率限制、会话管理、代理轮换和用户代理随机化，防止验证码出现。然而，如果验证码仍然出现，可以通过手动解决、验证码解决服务或机器学习算法来解决。
在下面的讨论中，我们将探讨适用于Python或任何其他编程语言的两种方法，为您提供有关有效解决验证码并获取所需数据的宝贵见解。
在网络爬虫中遇到的验证码类型： 网络爬虫涉及从网站提取数据，在此过程中可能会遇到不同类型的验证码。一些常见的验证码类型包括：
基于图像的验证码：这些验证码要求用户识别并选择符合特定标准的特定图像，例如识别对象或字符。基于文本的验证码：基于文本的验证码呈现给用户扭曲或模糊的文本，用户需要解密并正确输入。基于音频的验证码：音频验证码播放一系列扭曲或混乱的声音，用户必须听并准确转录。ReCaptcha V2和V3：ReCaptcha是由Google开发的广泛使用的验证码系统。它包括各种类型，例如选择与给定描述相匹配的图像或解决谜题。hCaptcha：hCaptcha与reCaptcha非常相似，主要区别在于hCaptcha允许多家公司在用户与网站交互时共享数据标记的优势，而使用reCaptcha时，只有Google从众包数据标记的集体努力中受益。 解决网络爬虫中验证码的最佳解决方案：Capsolver 对于从事大规模数据爬取或自动化任务的人员来说，验证码可能会带来重大挑战。然而，有一个优秀的解决方案可解决这些问题：Capsolver。Capsolver轻松高效地解决各种验证码障碍，为那些遇到验证码挑战的人提供及时的解决方案。
Capsolver支持各种类型的验证码服务，包括reCAPTCHA（v2/v3/Enterprise）、FunCaptcha、hCaptcha（Normal/Enterprise）、DataDome、GeeTest V3/V4、Imperva/Incapsula、AWS Captcha、CyberSiara、Akamai Web/Bmp、ImageToText等等。它涵盖了市场上大部分验证码类型。如果在使用过程中遇到新类型或挑战，请随时联系Capsolver寻求帮助。
使用Capsolver有两种主要方法：API服务和扩展服务。
a. API服务：
第1步：注册并获取API密钥
首先，访问官方Capsolver网站并注册一个账户。注册后，您将收到一个API密钥，这是使用Capsolver验证码解决服务的关键。
第2步：选择验证码类型
Capsolver支持各种常见的验证码类型，包括reCAPTCHA、hCaptcha、FunCaptcha等。根据您遇到的验证码类型，选择相应的API方法来解决它。如果您对所面临的验证码类型或特定于站点的参数（如sitekey）不确定，Capsolver提供了一个带有参数识别功能的扩展。该扩展允许用户识别验证码类型、sitekey、pageAction、API Domain和目标网站的Capsolver JSON。在检测到验证码参数后，Capsolver将返回一个包含详细提交验证码参数到其服务的说明的JSON。
第3步：将Capsolver API集成到您的应用程序或脚本中
Capsolver提供了一个易于使用的API，可以将其集成到您的应用程序或脚本中。根据您使用的编程语言，Capsolver提供相应的文档，帮助您快速入门。
第4步：获取解决方案结果
当您的账户有足够的余额和正确的参数时，向Capsolver API发送请求。API将处理验证码并返回解决方案结果。然后，您可以从API响应中检索解决方案结果。
b. 扩展服务
Capsolver还提供了一个扩展，适用于非程序员，使不熟悉编码的用户更方便地使用Capsolver的验证码解决服务。这个扩展可以轻松集成到Google Chrome浏览器中，让您在不编写任何代码的情况下享受Capsolver的验证码解决服务。浏览器扩展帮助用户自动识别和点击验证码验证，为非技术人员处理验证码挑战提供更便捷的方式。此外，浏览器扩展还可以帮助有残疾的人自动识别和交互验证码验证。
总结 总而言之，在网络爬虫和处理验证码方面，Capsolver是目前可用的最佳解决方案。凭借对reCAPTCHA、hCaptcha、FunCaptcha等各种验证码类型的全面支持，Capsolver提供了一种可靠高效的方式来克服验证码挑战。无论是通过适用于应用程序和脚本的API服务，还是适用于非程序员的扩展服务，Capsolver都为用户提供了解决验证码的必要工具。通过利用Capsolver的功能，个人可以简化他们的网络爬虫流程，克服验证码的障碍并提取所需的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04e933cce91a564de91cdfca64523ad/" rel="bookmark">
			rosetta error: failed to open elf at /lib64/ld-linux-x86-64.so.2怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在打包然后运行docker镜像的时候遇到了这个问题
➜ docker-demo docker run javaweb:1.0 -d rosetta error: failed to open elf at /lib64/ld-linux-x86-64.so.2 Trace/breakpoint trap 注意观察，这个库函数里面有x86-64字样，指的是支持64位运算的X86架构的CPU，这种CPU一般由Intel和AMD家生产的芯片。
而如果恰好你的电脑是搭载Apple Chip例如M1/M2/M3的MacBook，那么系统里是没有这个函数库的，就会报错。
解决办法是在Docker引入Base操作系统的时候，加上--platform=linux/amd64指定AMD64格式，然后重新打镜像。
FROM --platform=linux/amd64 ubuntu:16.04 Reference:
https://stackoverflow.com/questions/71040681/qemu-x86-64-could-not-open-lib64-ld-linux-x86-64-so-2-no-such-file-or-direc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a2d9dd9c74d0ee64631b9e57ce21ee/" rel="bookmark">
			2024年解决网络抓取中CAPTCHA问题的顶级CAPTCHA解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络抓取领域，CAPTCHA作为一种安全措施用于区分人类用户和自动化机器人。CAPTCHA是“Completely Automated Public Turing Test to Tell Computers and Humans Apart”的缩写，向用户提出挑战，例如扭曲的文本、图像或谜题，用户必须成功解决以证明其真实性。然而，CAPTCHA对于网络抓取的努力可能带来重大障碍。在2024年，Capsolver成为首屈一指的CAPTCHA解决方案，提供先进的功能和能力。本文探讨了CAPTCHA的概念、它在网络抓取中的重要性，并强调了为什么Capsolver成为2024年CAPTCHA挑战的顶级解决方案。
在我们开始之前，这是一个给Capsolver的额外优惠代码：WSC。在兑换后，每次充值后您将获得额外的5%奖励。
了解CAPTCHA： CAPTCHA是一种安全机制，旨在防止自动化机器人访问网站或执行恶意活动。它基于图灵测试，旨在区分人类智能和人工智能。CAPTCHA通过呈现扭曲或混淆的文本、图像或谜题向用户提出挑战，这些对机器人来说通常很难解读。通过成功完成CAPTCHA挑战，用户证明了自己作为人类的真实性。
CAPTCHA在网络抓取中的作用： 网络抓取涉及自动化从网站提取数据的过程。它是一种用于市场研究、数据分析和竞争情报等多种目的的有价值技术。然而，网站实施CAPTCHA来保护其数据并防止未经授权的抓取。当抓取机器人遇到CAPTCHA时，它们很难解决它们，阻碍了抓取过程，需要人工干预。这个障碍需要使用像Capsolver这样的CAPTCHA解决方案来克服CAPTCHA在网络抓取过程中带来的挑战。
Capsolver：2024年顶级CAPTCHA解决方案 Capsolver以以下几个原因成为2024年领先的CAPTCHA解决方案：
广泛的CAPTCHA支持：
Capsolver广泛支持在网络抓取过程中常见的各种CAPTCHA类型。无论是reCAPTCHA（v2/v3/Enterprise）、hCaptcha（Normal/Enterprise）、FunCaptcha、DataDome、GeeTest V3/V4等，Capsolver都可以高效解决。这种广泛的覆盖确保了网络抓取者可以自信地处理各种CAPTCHA挑战。
灵活的集成选项：
Capsolver提供了用户友好的API服务和浏览器扩展，可以与不同的编程语言和框架无缝集成。无论您使用Python、JavaScript还是其他任何编程语言，Capsolver简化了集成过程，轻松将CAPTCHA解决能力融入到您的网络抓取项目中。
无与伦比的准确性：
Capsolver的一个突出特点是其在解决CAPTCHA方面的卓越准确性。通过先进的算法和尖端的机器学习技术，Capsolver在准确地绕过CAPTCHA挑战方面取得了很高的成功率。这种可靠性确保了网络抓取者可以在没有CAPTCHA障碍的情况下获取所需的数据。
大规模项目的可扩展性：
Capsolver设计用于处理大规模的网络抓取项目。其强大的基础设施和高效的处理能力使网络抓取者能够在大规模的情况下处理CAPTCHA，而不会影响性能或准确性。无论您是从少数几个网站抓取数据，还是在多个域上进行广泛爬取，Capsolver都能无缝处理工作负载。
快速响应时间：
在快节奏的网络抓取世界中，时间至关重要。Capsolver理解这一点，并提供快速响应时间，以确保不间断的抓取过程。通过最小的延迟和快速的CAPTCHA解决响应，Capsolver允许网络抓取者以最高效的方式操作，节省时间和资源。
结论： CAPTCHA在网络抓取中带来了重大挑战。然而，Capsolver在2024年成为顶级CAPTCHA解决方案，提供先进的功能、适应不断发展的CAPTCHA、可扩展性、用户友好的特性和优秀的客户支持。通过Capsolver，网络抓取者可以有效地克服CAPTCHA障碍，简化其抓取过程，确保高效地从网站中提取有价值的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ca02d287fe708f61675247a8a7c273/" rel="bookmark">
			【嵌入式——C&#43;&#43;】基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【嵌入式——C++】基础知识 变量作用域局部作用域全局作用域块作用域类作用域 常量标识符命名规则数据的输入运算符算术运算符赋值运算符比较运算符逻辑运算符 变量作用域 局部作用域 在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
int main () { // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout &lt;&lt; c; return 0; } 全局作用域 在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
// 全局变量声明 int g; int main () { // 局部变量声明 int a, b; // 实际初始化 a = 10; b = 20; g = a + b; cout &lt;&lt; g; return 0; } 块作用域 在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ca02d287fe708f61675247a8a7c273/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154d0087a6ec4731dafeff5261d4a6d6/" rel="bookmark">
			如何在网络爬虫中解决CAPTCHA？使用Python进行网络爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络爬虫是从网站提取数据的重要方法。然而，在进行网络爬虫时，常常会遇到一个障碍，那就是CAPTCHA（全自动公共图灵测试以区分计算机和人类）。本文将介绍在网络爬虫中解决CAPTCHA的最佳方法，并重点介绍CapSolver无缝集成。
了解网络爬虫中的CAPTCHA： 网络爬虫中的CAPTCHA是指在从网站提取数据时遇到的CAPTCHA挑战。CAPTCHA旨在防止自动化机器人访问和获取信息。它们通常包括对人类容易解答但对机器人难以解答的视觉或逻辑测试。
在网络爬虫中遇到CAPTCHA的原因： 网站通常使用CAPTCHA作为安全措施，以保护内容并防止未经授权的访问。在存储有价值或受限数据的网站上，以及旨在防止过度流量或网络爬虫活动的网站上，通常会出现CAPTCHA。当网络爬虫遇到CAPTCHA时，他们需要找到解决或绕过CAPTCHA的方法，以继续提取所需的数据。
解决网络爬虫中的CAPTCHA： 在网络爬虫中有效解决CAPTCHA挑战需要采用强大的策略。一种方法是手动干预，即人工解答CAPTCHA挑战。然而，这种方法耗时且会影响爬取过程的效率。
相反，开发人员可以利用自动化的CAPTCHA解决技术。这涉及使用算法和工具识别和解决CAPTCHA挑战，无需人工干预。自动化的CAPTCHA解决技术显著提高了网络爬虫任务的速度和效率。
网络爬虫开发人员可以探索各种提供CAPTCHA解决服务的库和API。这些服务提供了预训练的模型和算法，能够准确解决不同类型的CAPTCHA，包括基于图像和文本的CAPTCHA。通过将这些CAPTCHA解决服务集成到爬取工作流程中，开发人员可以有效地克服CAPTCHA挑战并继续提取所需的数据。
介绍CapSolver：网络爬虫中CAPTCHA解决的最佳解决方案： 对于从事大规模数据爬取或自动化任务的用户来说，CAPTCHA可能是一个严峻的障碍。幸运的是，CapSolver已成为解决网络数据爬取等场景中遇到的CAPTCHA挑战的首选解决方案提供商。CapSolver可以轻松快速地解决各种CAPTCHA障碍，并为遇到CAPTCHA问题的用户提供即时解决方案。
CapSolver支持各种类型的CAPTCHA服务，包括reCAPTCHA（v2/v3/Enterprise）、FunCaptcha、hCaptcha（Normal/Enterprise）、DataDome、GeeTest V3/V4、Imperva/Incapsula、AWS Captcha、CyberSiara、Akamai Web/Bmp、ImageToText等。它涵盖了市场上大多数CAPTCHA类型，并且CapSolver不断更新其功能，以解决用户遇到的新类型或挑战。
这是一个给Capsolver的额外优惠代码：WSC。在兑换后，每次充值后您将获得额外的5%奖励。
为什么要使用Python解决Web抓取中的CAPTCHA？ 在Web抓取中使用Python解决CAPTCHA是自动化数据提取的关键，它绕过了障碍并提高了效率。Python提供了强大的库来自动化解决CAPTCHA，节省时间和精力。自动化的CAPTCHA解决方案提高了Web抓取任务的准确性，确保数据提取的高效性和可靠性。
如何使用Python和Capsolver解决任何CAPTCHA问题： 先决条件：
一个有效的代理已安装Python已获得Capsolver的API密钥 步骤1：安装所需的包 执行以下命令来安装所需的包：
pip install capsolver 以下是绕过reCAPTCHA v2的示例代码 使用您的代理绕过reCAPTCHA v2的Python代码示例：
import capsolver # Consider using environment variables for sensitive information PROXY = "http://username:password@host:port" capsolver.api_key = "Your Capsolver API Key" PAGE_URL = "PAGE_URL" PAGE_KEY = "PAGE_SITE_KEY" def solve_recaptcha_v2(url,key): solution = capsolver.solve({ "type": "ReCaptchaV2Task", "websiteURL": url, "websiteKey":key, "proxy": PROXY }) return solution def main(): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154d0087a6ec4731dafeff5261d4a6d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7271deea35969407dc7eecac3281170e/" rel="bookmark">
			探索SQL性能优化之道：实用技巧与最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL性能优化可能是每个数据库管理员和开发者在日常工作中必不可少的一个环节。在大数据时代，为确保数据库系统的响应速度和稳定性，掌握一些实用的SQL优化技巧至关重要。
本文将带着开发人员走进SQL性能优化的世界，深入剖析实用技巧和最佳实践。
理解和分析慢查询 在确定需要优化的目标时，先了解哪些查询执行速度较慢非常重要。通过分析慢查询日志，找出问题并对症下药。
慢查询其实是非常棘手的技术问题，因为他不是毕现的，只有满足一定的数据量和并发请求才会产生。
首先，让我们从慢查询背后的原因入手。慢查询通常是由于数据库中大量数据量、复杂查询语句或者索引缺失等问题导致的。了解这些根本原因是解决问题的第一步。
接下来，我们需要学会如何分析慢查询。一个强大而高效的工具是数据库性能监控工具。通过监控工具收集并分析关键性能指标，例如响应时间、执行计划和索引使用情况等，我们可以快速定位到导致慢查询现象的具体原因。
对于大部分情况来说，良好地编写SQL语句也是解决慢查询问题不可或缺的一环。使用正确的索引、避免全表扫描以及减少不必要的连接操作都能够显著改善查询性能。
此外，在优化过程中，还需要注意硬件资源以及数据库参数调整等方面。合理规划硬件资源（例如内存、磁盘和网络带宽）可以进一步提升数据库性能；同时，在数据库配置中进行适当调整（如缓冲区大小、并发连接数等），也是达到优化目标必不可少的步骤。
最后，在实际应用场景中，我们要时刻保持对业务逻辑和数据模型的深入理解，并进行合理地分库分表等策略调整。这些策略可以有效降低负载压力，并提高系统整体性能。
如果业务开放人员，解决了慢查询问题，小编可以负责任的告诉大家，基本可以解决至少90%以上的性能问题。至少在小编过往的性能优化经历中，大部分都是因为慢查询导致的，后端开发中最常见的慢查询就是SQL相关的语句，也就是CRUD语句，因此一定要重视CRUD，而不是简单的完成任务开发。
选择正确的索引 索引是提高数据库检索性能的一把利器。了解如何创建并利用合适的索引类型（如B-Tree、Hash等）会给您带来显著提升。
首先，开发人员需要明确一个基本概念：索引是数据库中用于加速数据检索的结构。正确的索引选择可以大幅提升查询性能与效率。要做到这一点，以下几点是至关重要的：
1. 确定性能需求。
首先，开发人员需要明确自己对于数据查询性能的具体要求。是更快速的响应时间？还是更高吞吐量？不同类型的应用场景可能对性能有不同要求，因此根据实际需求确定性能指标非常重要。
2. 分析数据访问模式。
深入了解数据访问模式是选择正确索引方案的关键步骤之一。通过分析常见查询类型、频率以及相关字段，您可以发现哪些字段可作为索引列，并且可以根据数据分布特征进一步优化索引效果。
3. 考虑存储和维护成本。
索引并非没有代价。它们需要额外的存储空间，并且在写入操作时可能会产生额外开销。因此，在选择正确的索引方案时，我们不能忽视存储和维护成本。权衡利弊，并根据实际情况做出明智决策。
4. 评估多个方案。
针对不同查询类型和性能需求，可能存在多种可行的索引方案。在做出最终决策之前，请务必评估多个候选方案，并对其进行性能测试和比较分析。只有通过充分评估和实验验证才能找到最适合当前环境和业务需求的方案。
5. 定期监测和调整。
一旦开发人员选择了适当的索引方案并部署到生产环境中，请定期监测其性能表现，并根据运行情况进行必要调整。业务需求和数据访问模式可能会随时间变化，及时优化更新索引将保持系统性能持续提升。
总结起来，选择正确的索引方案是实现高效数据管理不可或缺的一环。通过明确性能需求、分析数据访问模式、考虑存储成本、评估多个方案以及定期监测和调整，您将能够解锁高效数据管理之门，并极大提升工作效率与用户体验。
最重要的一条是开发人员一定要理解索引和熟悉业务，比如要知道MySQL或者PG支持哪些索引以及这些索引的业务场景。最简单的，你要知道唯一性索引的作用以及它带来的性能损耗有哪些。
优化表结构 合理设计表结构不仅有助于降低存储成本，而且有助于提高查询性能。注意减少不必要的字段、合并冗余数据等。
关于合理的设计表结构，其实这个是业务设计阶段需要重点考虑的事情，尤其是重视业务架构的公司，一定会狠抓表结构设计的。
1. 了解业务需求。
在开始表结构设计之前，全面了解业务需求是至关重要的。仔细分析数据类型、数据量和数据关系，并针对性地进行规划。确保每个表都具备清晰明确的定义，并且字段命名简洁、易于理解。
2. 正确选择主键。
主键在表中扮演着至关重要的角色，它可以保证数据唯一性并加速查询效率。选择一个合适的主键类型（如自增整数型或GUID），避免使用复合主键或过长字段作为主键，以免影响索引性能。
3. 合理使用索引。
索引是提高查询速度和降低系统负载的有效手段。但是过多或不恰当地使用索引可能会导致额外存储开销和更新操作延迟。根据具体查询需求选择适合的索引类型（如单列索引、组合索引等），避免冗余和重复索引。
4. 规范化与反规范化处理。
在设计表结构时，根据具体情况进行规范化或反规范化处理。规范化可以消除数据冗余并提升数据一致性，但也会增加查询时的连接操作；反规范化可以减少连接操作并提升查询速度，但会通过冗余数据增加存储空间。
5. 考虑分区和分表。
当数据库中包含大量数据时，考虑采用分区和分表技术可以进一步提高查询效率。通过将数据按照某种规则进行拆分、分区存储或者利用垂直与水平分表策略，可以减小单个表的大小，并使得查询操作更加高效。
6. 定期优化与维护。
优化表结构设计不仅仅只是一次性工作，在日常运营中需要定期进行监测和调整。识别慢查询、瓶颈点以及频繁更新字段等问题，并根据实际情况进行相应调整和优化。
总之，在现代数据库管理中，优化良好的表结构设计对于系统性能至关重要。通过深入了解业务需求、精心选择主键、合理使用索引以及灵活运用规范化与反规范化处理等手段，开发人员将能够实现更快速、可靠且高效地操作您宝贵的数据库资源。
后端开发人员一定要重视业务架构，并将性能的隐患规避在表设计这个环节，从而做到事半功倍。假如业务上线了，你再去改表结构就非常麻烦了，一方面要做数据迁移，另一方面数据量太大，你也没办法有效的去修改表结构。
编写高效的SQL语句 学会编写高效率的SQL语句至关重要。注意避免 SELECT *，合理使用 JOIN 和 WHERE 子句以及其他高级特性。
首先，在编写SQL语句之前，深入了解数据库结构和表之间的关系是至关重要的。确保你对所使用的数据库模式有着清晰的理解，并熟知表之间的连接方式。这将使你更加准确地定位你需要查询的数据，避免不必要的复杂性和性能问题。
其次，在优化查询性能方面，使用正确的索引是不可或缺的。索引可以极大地提升查询速度，但也需要谨慎使用。在选择合适的列作为索引时，考虑到频繁查询和经常更新的情况，并平衡索引维护带来的开销。
此外，了解各种SQL函数和操作符是提高编写效率和复杂查询能力的关键。例如，掌握聚合函数、条件语句和多表连接操作等功能可以让你更轻松地实现复杂业务逻辑和数据统计需求。
值得一提的是，遵循良好的编码规范也是高效SQL编写不可或缺的一环。清晰且可读性强的代码将使你自己和其他开发人员更容易理解、维护和调试。要始终保持一致性，并注意避免冗余代码以及无用或过度复杂化的查询。
最后但同样重要的是测试你所编写的SQL语句。通过对各种场景进行全面测试，包括正常输入、异常输入以及大数据量情况下等测试用例，以确保它们能够正确、快速地执行，并返回准确结果。
总而言之，在精通SQL编写方面并没有捷径可走。它需要不断地学习、实践和经验积累。
多利用查询缓存 尽量充分利用数据库自带的查询缓存机制，并对缓存策略进行调整以适应具体场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7271deea35969407dc7eecac3281170e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb345961d10a62ab88352ca920fb7abc/" rel="bookmark">
			数据截取处理、富文本去除所有标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：在做项目中有个需求是填写表单后生成一份文档，文档可以编辑、保存。
这部分用富文本处理了，涉及到的逻辑就是对象--&gt;富文本标签形式
在给后端传的数据格式再把富文本标签形式--&gt;对象形式。
涉及到文字，图片、表格，以及图片表格的标题。
数据截取处理 // 数据截取处理 extractString(str, startChar, endChar) { const pattern = `${startChar}(.*?)${endChar}`; const regex = new RegExp(pattern); const matches = str.match(regex); return matches ? matches[1] : ''; }, 用法： let a = this.extractString(item, '&lt;img', '&lt;/p&gt;') item就是要处理的字串，后面一个开始元素，一个结束元素。
富文本去除所有标签 str='&lt;div class="proposal-content" style="text-indent:2em; font-size:16px; line-height:1.5"&gt;光伏组件在运行过程中，光电转换效率会受到影响，输出功率有所降低。本报告年衰减率根据《光伏制造行业规范条件（2021年本）》计算，晶硅组件衰减率首年不高于2.5%，后续每年不高于0.6%。&lt;/div&gt;' let a = str.replace(/&lt;[^&gt;]+&gt;/g, '') .replace替换其他数据：
proposalString = proposalString.replace(new RegExp('&lt;p data-we-empty-p="" style="padding-left:2em;"&gt;', 'g'), paragraph); ‘g’是全局替换，不然只会替换第一个。
富文本转对象大致实现思路： 因为要数据对应，以下是后端传过来的数据：
let obj = [ { content: '合浦位于广西壮族自治区北海市合浦县合浦闸口镇。项目所在地的经纬度坐标为21.69°N, 109.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb345961d10a62ab88352ca920fb7abc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67391d6364c1b7dd745de2aa99b1464f/" rel="bookmark">
			基于Docker Compose单机实现多级缓存架构2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、环境参考二、专栏简介三、扩展 一、环境参考 NameVersionDocker Desktop for Windows4.23.0Openjdk8MySQL8.2.0Redis7.2Canal1.1.7OpenResty1.21.4.3-3-jammy-amd64Lua-Caffeine- 二、专栏简介 多级缓存实现过程比较长，将拆分为多个文章分步讲述。如果一切顺利，大致会得到如下一个多级缓存架构：
本专栏主要对Lua缓存、Redis缓存、Caffeine缓存进行实践，以及缓存同步实践。依次为以下几篇：
多级缓存架构(一)项目初始化多级缓存架构(二)Caffeine进程缓存多级缓存架构(三)OpenResty Lua缓存多级缓存架构(四)Redis缓存多级缓存架构(五)缓存同步 三、扩展 对于高可用，集群等扩展，例如下图的构造，本专栏只包含部分展开但并不提供实践指导。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c718c6a0ef91e54c8dc2634f615868e/" rel="bookmark">
			vscode 修改备注颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置（Settings）中搜索“editor.tokenColorCustomizations” "editor.tokenColorCustomizations": { "comments": { "fontStyle": "italic", "foreground": "#008800" } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72659f5ff31e9858b17498aee2d2b620/" rel="bookmark">
			怎么把workspace的数据导入到simulink查看波形？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仿真截图；
示例代码：
sampleTime = 0.001; %设置采样时间 numSteps = 1/sampleTimes; %设置时间矩阵长度 time = sampleTime*(0:numSteps-1); %定义时间矩阵 time = time'; %时间矩阵转置 data = sin(2*pi/3*time); %设置与时间相关信号 simin = timeseries(data,time); %赋值给simin，与simulink名称对应 设置simulink中from workspace 模块的采样时间与示波器的采样时间，与matlab代码对应，以上示例均为0.001；先创建脚本，运行脚本，然后建立simulink仿真，运行仿真，查看仿真波形。如下所示。
此时数据是依照time生成的，假如我们只有一个数据，从示波器导出的，并没有时间这个数组，又该怎么导入到simulink呢 ？
比如有一个10000个点的数据，如下图所示，这是两个正弦信号叠加产生，此时没有时间维度信号。但是由于是从示波器导出的，我们知道示波器的采样频率，此时是10k。
此时仅需要对time数据进行重构即可，这个数据在workspace里面名称是S。
sampleTime = 0.001; %设置采样时间 numSteps = 1/sampleTimes + 1; %设置时间矩阵长度 time = sampleTime*(0:numSteps-1); %定义时间矩阵 time = time'; %时间矩阵转置 data = S; %设置与时间相关信号 simin = timeseries(data,time); %赋值给simin，与simulink名称对应 然后再运行仿真即可，注意还是需要调整采样时间和仿真时长再仿真。
以上数据均为10000个点对应1s去构造的，假如10000个点，只有0.1s，此时如何去处理呢？代码如下，主要是要对time矩阵进行特殊处理，并且相应更改采样时间。比如 time矩阵构造就应该是 采样时间 * 数据点数。
Fs = 100000; % 假设采样频率为 1000 Hz T = 1/Fs; % Sampling period L =100000; % 数据点数 t = (0:L-1)*T; % Time vector S = sin(2*pi*50*t) + 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72659f5ff31e9858b17498aee2d2b620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e302de2eecb2b8e9c76eb3bd4204d6d/" rel="bookmark">
			多级缓存架构(四)Redis缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Redis服务二、Redis缓存预热1. 引入依赖2. handler类实现 三、整合Redis缓存四、运行五、测试1. redis缓存预热2. redis缓存命中 六、高可用集群 通过本文章，可以完成多级缓存架构中的Redis缓存。
一、Redis服务 在docker/docker-compose.yml中，添加redis服务块
redis: container_name: redis image: redis:7.2 volumes: - ./redis/redis.conf:/usr/local/etc/redis/redis.conf ports: - "6379:6379" command: ["redis-server", "/usr/local/etc/redis/redis.conf"] networks: multi-cache: ipv4_address: 172.30.3.21 二、Redis缓存预热 在spirngboot项目启动时，将固定的热点数据提前加载到redis中。
1. 引入依赖 pom.xml添加如下依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;6.1.4.RELEASE&lt;/version&gt; &lt;!-- 或更高版本 --&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba.fastjson2/fastjson2 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt; &lt;version&gt;2.0.41&lt;/version&gt; &lt;/dependency&gt; application.yml添加如下配置
spring: redis: host: 172.30.3.21 2. handler类实现 新建config.RedisHandler类，内容如下，主要是重写afterPropertiesSet，完成缓存预热逻辑，saveItem和deleteItemById函数给之后的章节使用。
@Component public class RedisHandler implements InitializingBean { @Autowired private StringRedisTemplate redisTemplate; @Autowired private IItemService itemService; @Autowired private IItemStockService stockService; @Override public void afterPropertiesSet() throws Exception { List&lt;Item&gt; itemList = itemService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e302de2eecb2b8e9c76eb3bd4204d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1adef648a85dd120f9c2ed33b67f2630/" rel="bookmark">
			怎么把workspace的数据导入到simulink进行FFT分析？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么把数据导入到simulink在这篇博客已经阐述了，那么如何把数据导入到simulink还能进行FFT分析呢？
首先我们看simulink的FFT分析界面，（前置步骤：导入powergui模块，双击powergui模块，Tool选项卡，选择FFT Analysis。示波器选择将数据保存，并且按需求命名。）
1：设置所需分析数据区段的开始时间；2：设置所需分析数据的周期；3：设置基波频率；4：设置最大分析频率； 输入信号：
Fs = 10000; % 假设采样频率为 1000 Hz T = 1/Fs; % Sampling period L =10000; % 数据点数 t = (0:L-1)*T; % Time vector S = sin(2*pi*50*t) + 1.2*sin(2*pi*100*t)+ 0.3*sin(2*pi*200*t); 基波频率为50Hz，谐波分量为2倍频和4倍频，FFT分析结果如下所示；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef184b14a2538f9d1fd562be84686ea3/" rel="bookmark">
			Fast.ai
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址：https://colab.research.google.com/
https://colab.research.google.com/notebooks/gpu.ipynb#scrollTo=tMce8muBqXQP
克隆此存储库后，请确保您已 nbdev_install_hooks在终端中运行。这将安装 Jupyter 和 git hooks 以自动清理、信任和修复笔记本中的合并冲突。
在存储库中进行更改后，您应该运行nbdev_prepare并进行其他必要的更改，以便通过所有测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d8082385e13cfb8ef11df13099fb85/" rel="bookmark">
			Python基础教程——用做一个童年经典flybird游戏！【完整教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们用Python写一个十年前风靡一时的flybird小游戏。主要用到是pygame模块。这个拿来做游戏还是很方便。
游戏界面
1.设置好编码模式和导入所需的库。假如模块缺失的自行用pip命令安装一下缺失的模块。
#!/usr/bin/env python3 # -*- coding: utf-8 -*- import sys import random import pygame 2.定义好全局变量，屏幕宽高、管道宽高、小鸟的宽高、地面的高度。这里我们使用长方体代替管道和小鸟。
# FPS FPS = 30 # 屏幕宽高 SCREEN_WIDTH = 288 SCREEN_HEIGHT = 512 # 管道宽高 PIPE_WIDTH = 50 PIPE_HEIGHT = 300 # 管道之间空隙 PIPE_GAP_SIZE = 100 # 小鸟 BIRD_WIDTH = 20 BIRD_HEIGHT = 20 # 地面高度 FLOOR_HEIGHT = 80 # 游戏有效高度 BASE_HEIGHT = SCREEN_HEIGHT - FLOOR_HEIGHT 3.定义好小鸟类，设置好初始的状态、更新小鸟的位置方法、上升、下落状态方法和绘制小鸟方法。
class Bird(pygame.sprite.Sprite): def __init__(self, position): pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0d8082385e13cfb8ef11df13099fb85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c789b175f1514a3a807fd00bb53a8f32/" rel="bookmark">
			【osgEarth】在osgEarth中实现的一些模型效果：雷达波、通信链路、爆炸、尾焰、轨迹、文字标牌等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习osgEarth也有一段时间了，记录一下最近一段时间的学习成果。
主要是在osgEarth三维场景中实现了一些模型效果，部分模型参考借鉴了西安恒歌的一些显示效果（当然是不能和他们比的doge），期间也从杨总(freesouths)的一些资料、文章中学到了很多，在此也感谢杨总他们的无私奉献。
下面是一些效果的展示。
1、雷达效果 雷达波模拟 雷达脉冲模拟 雷达扫描模拟 2、通信链路效果 链路脉冲模拟 链路流光模拟 3、爆炸效果 4、粒子尾焰效果 5、飞行轨迹效果 6、文字标牌 7、一个简单的仿真小场景 制作了一个简单的仿真小场景，感兴趣的可以看看：简单的仿真场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0094f8bd29f51f223c0d8d79ba039e5/" rel="bookmark">
			2023 IoTDB Summit：天谋科技高级开发工程师苏宇荣《汇其流：如何用 IoTDB 流处理框架玩转端边云融合》...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12 月 3 日，2023 IoTDB 用户大会在北京成功举行，收获强烈反响。本次峰会汇集了超 20 位大咖嘉宾带来工业互联网行业、技术、应用方向的精彩议题，多位学术泰斗、企业代表、开发者，深度分享了工业物联网时序数据库 IoTDB 的技术创新、应用效果，与各行业标杆用户的落地实践、解决方案，并共同探讨时序数据管理领域的行业趋势。
我们邀请到天谋科技高级开发工程师，Apache IoTDB PMC Member 苏宇荣参加此次大会，并做主题报告——《汇其流：如何用 IoTDB 流处理框架玩转端边云融合》。以下为内容全文。
目录
端边云场景的挑战
端边云流处理框架
基于流处理框架的应用
线上线下的朋友们大家下午好，我是苏宇荣，天谋科技的高级开发工程师，目前是正在指导我们的流处理框架的开发。今天给大家带来的题目是：如何用 IoTDB 流处理框架来玩转我们的端边云融合。这里有两个关键词，第一个就是我们的流处理框架，这是一个新东西；第二个就是我们的应用场景，端边云融合。我们将从技术和应用两个部分给大家来剖析一下我们的这个主题。
我们的内容主要分为三个部分：第一个，我们先看看端边云融合的一些场景，以及目前解决方案的一些痛点。第二个，我们就通过痛点，来看看我们的一个新的解决方案。最后，我们会开枝散叶，去讲解基于流处理框架的一些应用，包括数据同步、双活集群、实时告警、数据推送等等，你想要的，我相信应有尽有。
01
端边云场景的挑战
首先，我们来看看端边云场景的整个挑战。首先我们来看看端边云这个应用场景的特点，从分类上来说，我想把它分为三类，一个叫数据库内，一个叫数据库间，一个叫数据库外。在端边云里面，我们可能想在端侧做一些实时的告警，充分地利用端侧较弱，但是能分布起来、scale 起来的性能。我们也可能想在云侧做一些流式计算，对于上报汇聚上来的数据做一些统一的处理，可能还会有一些比如说实时聚合，数据写回等等的应用。
数据库间这个场景就更加典型了，我们在今天早上的论坛，包括前面的讲解里面都提到过，我们会有各种各样的同步，那今天也会给大家带来比如说跨网闸同步、降采样同步，以及正常的一些集群间的高性能同步等等场景。
数据库外，我们又可以基于这种流处理框架，去做比如说客户端订阅、消息队列数据推送，以及 Flink CDC Connector 这样的一些技术实践。我们希望我们的解决方案能够融合这些特点。
我们先来看看传统的解决方案是怎么样的？以这个数据同步的场景为例，我们两个时序数据库中间往往要引入一些通用计算引擎或者流引擎，比如说 Kafka。那这样的话，可不仅仅是引入 Kafka 一个组件这么简单，可能还有 ZK，更可能会出现像 Flink、Spark 这样的衔接工具。
那从软件架构的视角来说，我们在端侧本来性能就很羸弱了，这一套架构其实完全不适用；从功能上来说，似乎又有一些“高射炮打蚊子”。我们还可以再继续往下想，数据在多个进程之间来回的流转，多次的读写转发，实际上它的性能上限很低，其实也不适用。
从运维人员的角度来说，我们也跟很多的客户去聊过，他们感觉这个组件这么多，运营起来很繁杂，资源占用也很多，稳定性也很差，那他们是拒绝的。
从开发人员的视角来说，大家如果用过 Flink 可能就会知道，其实它的 API 相对比较复杂，它的学习曲线很陡峭，要让一个正常的、低成本的开发去做这件事情成本很高，他们二次开发可能也做不好。这些问题其实一直都存在，没有一个很好的解决方法。
那我们也看到有一些时序数据库产品，针对像数据同步这样的场景，引入了一些比如说企业级的工具，但是它从根本上来说没有改变之前的这种架构，它的产品形态其实进化是不彻底的，它的架构也不解决根本的问题。
02
端边云流处理框架
有了这些思考之后，我们是怎么想的呢？我们引入了一个为端边云融合而生的数据库内的流式计算框架，我们称之为嵌入式、分布式的库内流处理框架，它有 6 大特点。第一就是它的高可用性，在分布式的场景部署的情况下，我们的计算是高可用的，任意的副本的失效不会影响它的可用性。第二个就是可靠性，我们这个框架提供一个 at-least-once 的计算语义。第三个就是容错性，我们这个框架支持进度的记录，出错自动的重试，断点自动重算等等。
第四个就是我们的性能，我们是做到了一个库内的引擎，所以它的本质其实是一个近存储的计算，可以以最小 I/O 与 CPU 的代价去利用数据进行计算。同时我们也可以针对一些特殊的场景，比如数据同步，做一些内核级别的优化。第五个就是我们提供了非常好的可观测性，我们提供了接口调用时间、事件堆积的数量等 10 余个指标，可以给用户去提供查看功能。最后就是可扩展性，我们既然说我们研发的是一个框架，那肯定是支持自定义的。我们提供了 Java 的开放编程接口，支持用户以自定义的方式去进行插件的开发，同时对于插件我们也是支持热插拔的。
那么有了这些特性之后，不妨来看看我们在数据库内怎么去定义一个流处理任务。我们把这个流处理任务叫做 Pipe，而流水线 Pipeline 被抽象成三个阶段：第一个阶段我们叫做 Source，第二阶段是 Processor，第三个叫 Sink。各个阶段的逻辑都是由独立的插件来进行表达的，各阶段的插件也均支持用户去自定义地开发。最后一点就是，用户开发好的插件，它是具有复用性的，可以通过组合各个插件来灵活地实现不同的功能。一会儿我们会从场景上举例，大家也可以看到这个能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0094f8bd29f51f223c0d8d79ba039e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b034c1c15b0f601b72f2913c6ba0edb6/" rel="bookmark">
			微服务自动化.docker-compose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解： kubernetes 也称为k8s，也是用于自动部署和管理容器应用程序的开源系统
Docker-Compose项目是Docker官方的开源项目,负责实现对Docker容器集群的快速编排 通过编写docker-compose文件可对多个服务同时进行启动/停止/更新(可定义依赖,按顺序启动服务)
docker-compose将所管理的容器分为3层结构： project 1 一个微服务项目
service N 由N个微服务组成
container N 而每个微服务又由N个节点组成 docker-compose.yml组成一个project,project里包括多个service,每个service定义了容器运行的镜像（或构建镜像）
Docker-Compose的工程配置文件默认为docker-compose.yml
前面我们使用 Docker 的时候,定义 Dockerfile 文件,然后使用 docker build、docker run 等命令操作容器. 然而微服务架构的应用系统一般包含若干个微服务,每个微服务一般都会部署多 个实例,如果每个微服务都要手动启停,
那么效率之低,维护量之大可想而知.而使用 Docker Compose 可以轻松、高效的管理容器, 它是一个用于定义和运行多容器 Docker 的应用程序工具.
三步过程 1)用dockerfile,或者镜像定义应用程序的环境,以便在任何地方复制.
2)在docker-compose.yml中定义组成应用程序的服务,以便它们可以在单独的环境中一起运行.
3)运行docker compose up启动并运行整个应用程序.
上传文件 将docker-compose-Linux-x86_64重命名为docker-compose
将刚才下载的docker-compose文件上传到centos7的/usr/local/bin/目录下 cd /usr/local/bin
添加可执行权限 chmod +x /usr/local/bin/docker-compose
version: 指定 docker-compose.yml 文件的写法格式 services：
容器1：
容器2：
services：多个容器集合
然后把那个文件复制到bin目录：
cd /usr/local/bin
给文件授权：
[root@localhost ~]# chmod a+x docker-compose
启动：[root@localhost ~]# .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b034c1c15b0f601b72f2913c6ba0edb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3074e391224e9d3374714a51b814ca/" rel="bookmark">
			认识字面量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字面量：数据在程序中的书写格式
整数小数写法无变化
字符：在程序中必须使用单引号，有且只能有一个字符
字符串：程序中必须使用双引号，内容可有可无
布尔值：true、false
空值：null
示例和结果如上和下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d06e9b488bae7d2bc0cac5bdf0bd1c4/" rel="bookmark">
			图像评价指标PSNR、SSIM、LPIPS、FID（接上篇，这篇主要讲FID）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于FID的计算，这里我直接使用startGANv2中的计算FID的方法，比较简单，快速。理论部分我就不讲了，网上一搜一大堆，我写的都是干货（主要是怕太长了，没人看😂）
上一篇是关于PSNR、SSIM、LPIPS的感兴趣的小伙伴们可以看一下。
https://blog.csdn.net/qq_43826289/article/details/135396128?spm=1001.2014.3001.5502
1、首先进入你所在项目的文件夹下（或者你所测试的数据集同级目录下）下载下面代码到你的项目中
https://gitcode.com/clovaai/stargan-v2/overview?utm_source=csdn_github_accelerator&amp;isLogin=1
如下图所示
2、需要根据上面给出的地址配置所需要的虚拟环境，不用按照给出的版本，根据自己的环境版本安装对应的版本即可（一般来说，直接安装最新版本就可以，我也没管版本是多少）
比如说原论文中安装的版本
pip install pillow==7.0.0 scipy==1.2.1 tqdm==4.43.0 munch==2.5.0 换成下面的版本也可以（下载的是最新版本的）
pip install pillow scipy tqdm munch 3、配置完虚拟环境之后
配置完环境将激活虚拟环境，进入下载代码的文件夹
cd stargan-v2/ 然后执行下面的命令
python -m metrics.fid --paths 原始文件 输出文件 例如，可以是单张图像，也可以是一个文件夹，这里我使用的是一个文件夹
python -m metrics.fid --path ../data/input ../data/output 然后等待程序运行完就可以得到FID。
用于日常记录，希望能帮助到大家！！！！！最后祝大家都科研顺利，多多发论文！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b092d12f26ac70bba0a020bd44a942/" rel="bookmark">
			打印的前后顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题经常会有
&lt;script&gt; console.log(1) setTimeout(function(){ console.log(2) }) console.log(3) let p=new Promise((resolve,reject) =&gt;{ console.log(4) resloved('hhhhhh') }) p.then( res =&gt;{ console.log(res) console.log(5) }, res =&gt;{ console.log(7) } ) console.log(6) &lt;/script&gt; 宏任务：script(整体代码)，setTimeout,UI渲染，VO，postMessage,MessageChannel,setlmmedate(node环境)
微任务：Promise, MultationObserver, proxess.nextTick(node环境)
执行顺序
1
3
4
6
hhhhhh
5
2
注意： Promise ,一旦创建立即执行，打印7是迷惑项不会执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06bb9a5c03e158fb9cf4d53b0e656292/" rel="bookmark">
			图像评价指标PSNR、SSIM、LPIPS、FID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近再复现图像处理方面的论文的时候发现几个评价图像质量的指标：
1、FID（Fréchet Inception Distance）：FID是用于评估生成模型的质量和多样性的指标。值越小，表示生成图片越多样、质量越好。
2、SSIM（Structural Similarity Index）：SSIM用于衡量两幅图像的相似性，包括亮度、对比度和结构。是一种测量两个图像之间相似性的方法。值越接近1表示图像的质量更高，相反接近0的值表示的图像质量较差。
3、PSNR（Peak Signal-to-Noise Ratio）：PSNR用于衡量图像的质量，通过比较原始图像和压缩图像之间的峰值信噪比来评估压缩算法的效果。PSNR的值越高，表示图像质量越好。
4、LPIPS（Learned Perceptual Image Patch Similarity）：LPIPS用于衡量两幅图像的感知相似度，与人类主观感知更加接近。该度量标准学习生成图像到ground truth的反向映射强制生成器学习从假图像中重构真是图像的反向映射，并优先处理它们之间的感知相似度。LPIPS的值越低，表示两幅图像的感知差异越小。
因为FID的特殊性，这里先介绍除了FID的其他三个评价指标。
关于FID大家可以看下面这篇博客（都是我写滴😀！！！）
https://blog.csdn.net/qq_43826289/article/details/135396468?spm=1001.2014.3001.5502
from tqdm import tqdm import torch import os from torch.utils.data import Dataset from torch.utils.data import DataLoader import numpy as np import cv2 import lpips from skimage.metrics import peak_signal_noise_ratio as psnr_loss from skimage.metrics import structural_similarity as ssim_loss import argparse parser = argparse.ArgumentParser(description='PSNR SSIM script', add_help=False) # 将此处的路径换成自己的原始输入图像文件夹 parser.add_argument('--input_images_path', default='./image/input') # 将此处的路径换成自己的输出图像文件夹 parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06bb9a5c03e158fb9cf4d53b0e656292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845966e2e6f4cf4ef034a254eb7d3fba/" rel="bookmark">
			网站安全检测：推荐 8 款免费的 Web 安全测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着 Web 应用越来越广泛，Web 安全威胁日益凸显。黑客利用网站操作系统的漏洞和 Web 服务程序的 SQL 注入漏洞等得到 Web 服务器的控制权限，轻则篡改网页内容，重则窃取重要内部数据，更为严重的则是在网页中植入恶意代码，使得网站访问者受到侵害。这也使得越来越多的用户关注应用层的安全问题，对 Web 应用安全的关注度也逐渐升温。下面向大家推荐 8 款非常有用的免费 Web 安全测试工具。
N-Stalker Free Version
N-Stalker Web 应用程序安全 2012 免费版本能够为您的 Web 应用程序清除该环境中大量常见的漏洞，包括跨站脚本（XSS）、SQL 注入（SQL injection）、缓存溢出（Buffer Overflow）、参数篡改 （Parameter Tampering）等等。
Netsparker Community Edition
Netsparker Community Edition 是一款 SQL 注入扫描工具，是 Netsparker 的社区免费版本，提供了基本的漏洞检测功能。使用友好，灵活。
Websecurify
Websecurify 是一款开源的跨平台网站安全检查工具，能够帮助你精确的检测 Web 应用程序安全问题。
Wapiti
Wapiti 是 Web 应用程序漏洞检查工具。它具有“暗箱操作”扫描，即它不关心 Web 应用程序的源代码，但它会扫描网页的部署，寻找使其能够注入数据的脚本和格式。
Skipfish
Skipfish 是 Google 公司发布的一款自动 Web 安全扫描程序，以降低用户的在线安全威胁。和 Nikto 和 Nessus 等其他开源扫描工具有相似的功能。
Exploit-Me
Exploit-Me 是一套 Firefox 的 Web 应用程序安全测试工具，轻量，易于使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845966e2e6f4cf4ef034a254eb7d3fba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3e572a15cfd85e00a80a7f42f2caa6/" rel="bookmark">
			【Java】解决Servlet编程中出现的中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、引言 前面两篇文章我们讲述了编写Servlet程序的基本步骤和修改一个Servlet程序
【Java】编写一个简单的Servlet程序​​​​​​
【Java】SmartTomcat的配置及使用 上面两篇文章的示例代码都是使用的全英文，当我们编写中文，发现似乎出了一点点问题🤔
2、问题的出现及原因 （1）问题的产生 将Java代码改为下面代码
import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet("/hello") public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println("hello world"); resp.getWriter().write("你好 java"); } } 再次运行程序，发现浏览器页面上出现乱码🫣
（2）原因 问题产生的原因
IDEA构建字符的编码方式是utf-8
而浏览器解析字符的编码方式是GBK
两者不一致，导致最终页面出现乱码😵
3、问题的解决 要解决上述编码不一致的问题，我们对代码进行修改
在http响应报文中，显式地告诉浏览器，返回的body字符集是什么
添加下面这句代码
resp.setContentType("text/html;charset=utf8"); 运行程序 中文显示正常，修改代码成功👏 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d4f5c1a85fb895237a4c8eebdb602b/" rel="bookmark">
			成绩转换 switch全部列出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求编写程序将一个百分制成绩转换为五分制成绩。转换规则：
大于等于90分为A；小于90且大于等于80为B；小于80且大于等于70为C；小于70且大于等于60为D；小于60为E。 输入格式: 输入在一行中给出一个整数的百分制成绩。
输出格式: 在一行中输出对应的五分制成绩。
输入样例: 90 输出样例: A #include&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; scanf("%i",&amp;a); switch(a){ case 90 ... 100: printf("A");break; case 80 ... 89: printf("B");break; case 70 ... 79: printf("C");break; case 60 ... 69: printf("D");break; case 0 ... 59: printf("E");break; default :printf("输入错误");break; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6142c9068fa0fd05046f9cc9808c5849/" rel="bookmark">
			响应式编程WebFlux基础实战练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是WebFlux？
响应式编程WebFlux是Spring Framework 5中引入的一个全新的响应式编程框架，它基于Reactor库构建，提供了异步和非阻塞的事件处理。WebFlux框架设计用于处理长时间运行的异步任务，例如网络调用或数据库操作，而不会阻塞线程。这样可以提高系统的吞吐量和伸缩性。并在Netty，Undertow和Servlet 3.1 +容器等服务器上运行。
WebFlux基础实战练习 0. WebFlun环境准备 基于Spring Boot，项目依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.1.6&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;chapter04-webflux&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt; &lt;version&gt;2023.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Starter Test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6142c9068fa0fd05046f9cc9808c5849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78358b24167f7582422e9bba4fdb2ee5/" rel="bookmark">
			Think and Retrieval: A Hypothesis Knowledge Graph Enhanced Medical Large Language Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是LLM系列文章，针对《Think and Retrieval: A Hypothesis Knowledge Graph Enhanced Medical Large Language Models》的翻译。
思考与检索：一个假设知识图增强的医学大语言模型 摘要1 引言2 相关工作3 前言4 方法5 实验6 结论 摘要 我们探讨了大型语言模型（LLM）的兴起如何显著影响自然语言处理领域的任务性能。我们重点研究了两种策略，即检索增强生成（RAG）和微调（FT），并提出了假设知识图增强（HyKGE）框架，利用知识图来增强医学LLM。通过集成LLM和知识图谱，HyKGE在解决准确性和可解释性挑战方面表现出卓越的性能，在医学领域具有潜在的应用前景。我们使用真实世界数据集进行的评估突出了HyKGE在提供准确知识和精确信心方面的优势，特别是在复杂和困难的场景中。该代码将在发布前可用。
1 引言 2 相关工作 3 前言 4 方法 5 实验 6 结论 在本文中，我们提出了HyKGE，一个假设知识图增强的医学大语言模型。通过集成LLM和知识图谱，HyKGE在解决准确性和可解释性挑战方面表现出卓越的性能，在医学领域具有潜在的应用前景。在两个医疗QA任务上进行的综合实验（使用两个LLM-turbo）验证了我们方法的有效性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c565fc23a371bd9d317529e1c4ffbf2/" rel="bookmark">
			web3d-three.js场景设计器-sprite广告牌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		three.js使用Sprite精灵实现文字或者图片广告牌1.将文字绘制到Canvas，调整对应宽高。2.作为Cavans材质绑定到Sprite3.加载到场景调整适当的scale function createLabel({ text, fontSize, textColor, color, imageUrl }) {
return new Promise((resolve, reject) =&gt; {
let canvas = document.createElement('canvas');
let context = canvas.getContext('2d');
context.font = `${fontSize}px Arial`;
let textWidth = context.measureText(text).width;
canvas.width = Math.ceil(textWidth);
canvas.height = Math.ceil(fontSize * 1.5);
context.font = `${fontSize}px Arial`;
if (color) {
context.fillStyle = color;
context.fillRect(0, 0, canvas.width, canvas.height);
}
let drawText = (imgHeight = 0) =&gt; {
context.textBaseline = 'middle';
context.textAlign = 'center';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c565fc23a371bd9d317529e1c4ffbf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627c811ee1f8ebfe456eb9a828b5a9d9/" rel="bookmark">
			JDBC 连接 MySQL 配置（附完整 demo）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 MySQL 驱动 从MySQL官网下载JDBC驱动的步骤如下：
1）访问MySQL的官方网站：MySQL
2）点击页面上方的"DOWNLOADS"菜单；
3）在下载页面，找到"MySQL Community (GPL) Downloads"部分，点击进入;
4）在MySQL Community Downloads页面，找到"Connector/J"链接，点击进入;
5）在Connector/J页面，您将看到最新版本的JDBC驱动程序。如果要下载历史版本，请点击"Archives"选项；
6）选择您需要的版本号，并确保选择"Platform Independent"作为操作系统；
7）点击"zip"格式的下载链接开始下载；
8）下载完成后，解压缩“zip”文件，您将看到驱动包（mysql-connector-j-8.0.31.jar）。
把驱动导入 IntelliJ IDEA 1）在 Java 项目中新建 lib 文件夹；
2）把 mysql-connector-j-8.0.31.jar 复制到 lib 文件夹下；
3）右击 lib 文件夹，并点击 Add as library，如下图所示；
4）mysql 驱动导入完成；
代码部分 import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class mysqlConnect { public static void main(String[] args) { String url = "jdbc:mysql://172.19.108.205:3306/jdbc"; // 172.19.108.205 为安装数据库的主机 IP，3306 为 mysql 端口号，jdbc 为自己建立的数据库名称 String username = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627c811ee1f8ebfe456eb9a828b5a9d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08adfad5b4d2233fa65c603fd6cd2a2c/" rel="bookmark">
			[Onnx简化库深度剖析] OnnxSimplifier和OnnxOptimizer解读-(4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [Onnx简化库深度剖析] OnnxSimplifier和OnnxOptimizer解读-(4) 简介 现在主要用于通过实操进行onnx简化库的每种pass的特性和效果。因为Pass实在太多，因此这里挑了一些效果显著的Pass进行呈现。 左边的是原始模型，右边的是特定Pass优化后的模型
OnnxOptimizer各Pass的实操和特性说明 adjust_add 前：常量输入是A，动态输入是B后：常量输入是B, 动态输入是A特性：把动态输入变成Add算子的第一个input
eliminate_common_subexpression 前：含有两个公共的表达式Y(Mul(X,Sigmoid(X)))后：合并只有一个特性：合并公共的结构 eliminate_if_with_const_cond 前：含有If算子，存在子图后：没有If算子，子图被暴露特性：cond确定的If算子被去除 eliminate_nop_cast 前：有一个Cast算子，to=float32,input_dtype=float32后：没有Cast算子特性：to=input_dtype的Cast被消除 eliminate_nop_flatten 前：存在Flatten算子后：没有Flatten算子特性：对shape不起作用的Flatten算子被消除 eliminate_nop_monotone_argmax 前：存在Y=ArgMax(Exp(X))这样的结构后：只有Y=ArgMax(X)特性：类似于Exp，只要是输出/输入是正相关的激活函数接入ArgMax算子后，该激活函数可以被消除而不影响结果 eliminate_nop_with_unit 前：存在很多乘1.0、加0.0等无效操作后：去除了很多无效的操作特性：消除掉同0并的And、同1乘的Mul、同0或的Or、同0加的Add、减0的Sub、除1的Div、方1的Pow、 无效的Concat eliminate_shape_gather 前：Y=Gather(Shape(X))后：Y=2特性：X的Shape已知，那么Y就是已知的。 fuse_add_bias_into_conv 前：B=Add(Conv2d(X,Y), A)后：B=Conv2d(X,Y,A)特性：把Add常量融合进Conv2d中 fuse_bn_into_conv 前：Y=BN(Conv2d(X))后：Y=Conv2d(X)特性：把BN融合进Conv2d中,主要因为重构了Conv2d的weight和bias fuse_consecutive_concats 前：存在很多axes一致的连续concat操作后：只有一个concat特性：合并很多axes一致的连续concat操作为一个 fuse_consecutive_log_softmax 前：Z=log(softmax(X))后：X=logsoftmax(X)特性：合并算子成为一个算子 fuse_qkv 前：普通的产生qkv的结构，拥有三个矩阵乘后：合并为一个矩阵乘，后续用split分开特性：对qkv结构特定优化 fuse_transpose_into_gemm 前：存在transpose执行矩阵转置操作后：转置操作被gemm的transA/B属性替代特性：消除transpose算子 总结 结束了，已经搞定了onnx官方的简化库的基本细节了。后面再续其他有趣的东东。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af86310085e3d30ebd5c292baf76a40a/" rel="bookmark">
			代码随想录算法训练营第17天（需复习 |（二叉树4 110.平衡二叉树 257. 二叉树的所有路径 404.左叶子之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树part04 110.平衡二叉树 （优先掌握递归）解题思路 257. 二叉树的所有路径 （优先掌握递归）解题思路 404.左叶子之和 （优先掌握递归）解题思路 110.平衡二叉树 （优先掌握递归） 再一次涉及到，什么是高度，什么是深度，可以巩固一下。
题目链接：110.平衡二叉树
文章讲解/视频讲解：110.平衡二叉树
解题思路 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。
这里按照高度的思路来解题，要用后序遍历
要求比较高度，必然是要后序遍历
// 递归 高度的思想 后序遍历 class Solution { public boolean isBalanced(TreeNode root) { return getHeight(root) != -1; } private int getHeight(TreeNode root) { if (root == null) return 0; // 左 int leftHeight = getHeight(root.left); if (leftHeight == -1) return -1; // 左子树已经不是一个平衡二叉树 // 右 int rightHeight = getHeight(root.right); if (rightHeight == -1) return -1; // 中 // 左右子树高度差大于1，return -1表示已经不是平衡树了 if (Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af86310085e3d30ebd5c292baf76a40a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d93d03267a9316f8fb4d5c4d81d29d/" rel="bookmark">
			[Onnx简化库深度剖析] OnnxSimplifier和OnnxOptimizer解读-(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [Onnx简化库深度剖析] OnnxSimplifier和OnnxOptimizer解读-(3) 简介 补充剩下的所有Pass的特性 具体的Pass实现和细节罗列（补充 PassPassNamePassTypePassEfficiencyPassOptimizationType描述EliminateNopMonotoneArgmaxeliminate_nop_monotone_argmaxNopPartialCompute消除掉那些正相关的激活函数到argmax函数上，减少计算EliminateNopPadeliminate_nop_padNopCompleteCompute消除pads=0的Pad算子EliminateNopConcateliminate_nop_concatNopCompleteMemory消除输入个数为1的Concat算子EliminateNopSpliteliminate_nop_splitNopCompleteMemory消除输出个数为1、input_dim[axis]=split[0]的Split算子EliminateNopExpandeliminate_nop_expandNopCompleteCompute消除expand_dim可以广播到input_dim的Expand算子EliminateShapeGathereliminate_shape_gatherFuseCompleteCompute融合掉indices=[indices_val,]、前面的节点是Shape的Gather算子EliminateSliceAfterShapeeliminate_slice_after_shapeFuseCompleteCompute融合掉前面的节点是Shape的Slice算子EliminateNopTransposeeliminate_nop_transposeNopCompleteCompute消除掉不起作用的transpose算子FuseAddBiasIntoConvfuse_add_bias_into_convFuseCompleteCompute融合掉前面的节点是Conv2d、且input[1]是常量可配合dim的Add算子FuseBNIntoConvfuse_bn_into_convFuseCompleteCompute融合BN算子到Conv2d上，同时修改Conv2d的权重FuseConsecutiveConcatsfuse_consecutive_concatsFusePartialCompute融合前面的axis相同的Concat到该Concat节点上FuseConsecutiveLogSoftmaxfuse_consecutive_log_softmaxFuseCompleteCompute融合softmax+log成为LogSoftmax算子FuseConsecutiveReduceUnsqueezefuse_consecutive_reduce_unsqueezeFuseCompleteCompute当前面的Reduce算子的axes=Unsqueeze_axes、keepdims=0时，融合Unsqueeze算子到Reduce算子上FuseConsecutiveSqueezesfuse_consecutive_squeezesFuseCompleteCompute合并多个连续的Squeeze算子成为一个Squeeze算子FuseConsecutiveTransposesfuse_consecutive_transposesFuseCompleteCompute合并多个连续的Transpose算子成为一个Transpose算子FuseMatMulAddBiasIntoGemmfuse_matmul_add_bias_into_gemmFuseCompleteCompute合并MatMul+Add成为一个Gemm算子FusePadIntoConvfuse_pad_into_convFuseCompleteCompute合并Pad+Conv成为一个Conv算子,Pad操作合并到了Conv上FusePadIntoPoolfuse_pad_into_poolFuseCompleteCompute合并Pad+AveragePool/MaxPool成为一个Pool算子FuseTransposeIntoGemmfuse_transpose_into_gemmFuseCompleteCompute融合前面的Transpose操作反转Gemm的transA/transB参数，从而融合掉transpose算子ReplaceEinsumWithMatmulreplace_einsum_with_matmulReplaceCompleteCompute满足条件的einsum变成matmul操作："bhij,bhjd-&gt;bhid"变成matmul; "bhid,bhjd-&gt;bhij"变成transpose+matmul操作LiftLexicalReferenceslift_lexical_referencesSeparateCompleteMemory待说明SplitInitsplit_initSeparateCompleteMemory待说明SplitPredictsplit_predictSeparateCompleteMemory待说明FuseConcatIntoReshapefuse_concat_into_reshapeFuseCompleteCompute融合reshape的shape输入的concat/cast算子，变成constant shape输入EliminateNopReshapeeliminate_nop_reshapeNopCompleteCompute消除掉reshape dim == input_dim的reshape算子EliminateOpWithUniteliminate_nop_with_unitNopCompleteCompute消除掉同0并的And、同1乘的Mul、同0或的Or、同0加的Add、减0的Sub、除1的Div、方1的Pow、 无效的ConcatEliminateCommonSubexpressioneliminate_common_subexpressionNopCompleteCompute消除掉那些属性/输入一致的节点，也就是公共子表达式FuseQKVfuse_qkvFuseCompleteCompute合并qkv计算的三个matmul为只有一个matmul: A = matmul(X, Q), B = matmul(X, K), C = matmul(X, V) ==&gt; A,B,C = split(matmul(X, concat(Q,K,V)))FuseConsecutiveUnsqueezesfuse_consecutive_unsqueezesFuseCompleteCompute融合连续的Unsqueezes算子EliminateDeadEndeliminate_deadendNopCompleteCompute移除掉output没有连接到其他节点的nodeEliminateIdentityeliminate_identityNopCompleteCompute移除掉Identity nodeEliminateShapeOpeliminate_shape_opFuseCompleteCompute融合掉可以直接获取input_shape的Shape算子FuseConsecutiveSlicesfuse_consecutive_slicesFuseCompleteMemory融合掉axes没有交集的连续的slice算子，合并为一个SliceEliminateUnusedInitializereliminate_unused_initializerNopCompleteMemory移除掉不被使用的initializerEliminateDuplicateInitializereliminate_duplicate_initializerNopCompleteMemory移除掉重复的initializerAdjustSliceAndMatmuladjust_slice_and_matmulReplaceCompleteCompute调整slice和matmul之间的顺序，以便优化：Y = Matmul(Slice(data, start, end, axes) ,rhs) ==&gt; Y = Slice(Matmul(data, rhs), start, end, axes)RewriteInputDtyperewrite_input_dtypeOtherCompleteNone重写input的类型从int64变成int32，从A=node1(INT64_INPUT) ==&gt; A=node1(Cast(INT32_INPUT, INT64)) …
总结 基本上目前所有的Pass已经被罗列出来了，后续会用实际的效果去加深大家的印象 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278ddd8065d9f0a2c710fe9a5238801e/" rel="bookmark">
			Mixtral 8X7B MoE模型基于PAI的微调部署实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：熊兮、求伯、一耘
引言 Mixtral 8x7B 是Mixtral AI最新发布的大语言模型，在许多基准测试上表现优于 GPT-3.5，是当前最为先进的开源大语言模型之一。阿里云人工智能平台PAI是面向开发者和企业的机器学习/深度学习平台，提供了对于 Mixtral 8x7B 模型的全面支持，开发者和企业用户可以基于 PAI-快速开始（PAI-QuickStart）轻松完成Mixtral 8x7B 模型的微调和部署。
Mixtral 8x7B 模型介绍 Mixtral 8x7B 是基于编码器（Decoder-Only）架构的稀疏专家混合网络（Sparse Mixture-Of-Experts，SMoE）开源大语言模型，使用 Apache 2.0 协议发布。它的独特之处在于对于每个 token，路由器网络选择八组专家网络中的两组进行处理，并且将其输出累加组合，因此虽然 Mixtral 8x7B 拥有总共 47B 的参数，但每个 token 实际上只使用13B的活跃参数，推理速度与13B模型相当。
Mixtral 8x7B 支持多种语言，包括法语、德语、西班牙语、意大利语和英语，支持的上下文长度为32K token，并且在所有的评估的基准测试中均达到或优于 Llama-2-70B 和 GPT-3.5，特别是在数学、代码生成和多语言基准测试中，Mixtral 大大优于 Llama-2-70B。
Mixtral AI 同时也发布了 Mixtral 8x7B 指令微调版本 Mixtral-8x7B-Instruct-v0.1，该版本通过监督微调和直接偏好优化（Direct Preference Optimization, DPO）进行了优化，以更好地遵循人类指令，对话能力领先于目前的其他开源模型的指令微调版本。
PAI-QuickStart 介绍 快速开始（PAI-QuickStart）是阿里云人工智能平台PAI的产品组件，它集成了国内外 AI 开源社区中优质的预训练模型，涵盖了包括大语言模型，文本生成图片、语音识别等各个领域。通过 PAI 对于这些模型的适配，用户可以通过零代码和 SDK 的方式实现从训练到部署再到推理的全过程，大大简化了模型的开发流程，为开发者和企业用户带来了更快、更高效、更便捷的 AI 开发和应用体验。
运行环境要求 本示例目前仅支持在阿里云乌兰察布地域，使用灵骏集群环境运行。资源配置要求：GPU 推荐使用 GU108（80GB显存），推理需要2卡及以上资源，LoRA微调需要4卡及以上资源。阿里云 PAI 灵骏智算服务资源开通和管理请参考官网文档：灵骏智算资源的购买开通 通过PAI控制台使用模型 开发者可以在 PAI 控制台的“快速开始”入口，找到 Mixtral-7x8B-Instruct-v0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/278ddd8065d9f0a2c710fe9a5238801e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c10a99ffe475fbffe59c7241a6848c/" rel="bookmark">
			Redis如何保证缓存和数据库一致性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 现在我们在面向增删改查开发时，数据库数据量大时或者对响应要求较快，我们就需要用到Redis来拿取数据。
Redis：是一种高性能的内存数据库，它将数据以键值对的形式存储在内存中，具有读写速度快、支持多种数据类型、原子性操作、丰富的特性等优势。 优势：
性能极高：Redis的读速度可以达到110000次/s，写速度可以达到81000次/s，这主要得益于它基于内存存储的特点，以及其单线程事件驱动架构的设计。丰富的数据类型：Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储，这些数据结构可以满足多种应用场景的需求。原子性操作：Redis的所有操作都是原子性的，这意味着这些操作要么成功执行，要么失败完全不执行。这为Redis在实现事务和并发控制方面提供了极大的便利。丰富的特性：Redis还支持发布/订阅、通知、键过期、事务、管道、Lua脚本、集群分片和数据复制等功能。这些特性使得Redis在实现消息队列、缓存系统、分布式系统等方面具有很大的优势。支持持久化：Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。这使得Redis的数据不会因为重启或者宕机而丢失。支持备份和恢复：Redis支持数据的备份和恢复，即master-slave模式的数据备份。这为Redis的数据安全提供了保障。丰富的客户端：Redis支持各种各样的语言的客户端接入，包括Python、Java、C#、PHP等。这使得开发者可以使用自己熟悉的编程语言来操作Redis。 综上所述，对Redis有个简单的理解。
常用方式 启动项目时将热点数据放入redis缓存中（如果没这样做，直接看第二点）用户请求过来之后，先查缓存有没有数据，如果有则直接返回。如果缓存没数据，再继续查数据库。如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。如果数据库也没数据，则直接返回空。 此时，问题来了，假如说我们的热点数据是人员信息，此时新增了一条张三的信息，你再去缓存拿取的时候是不会有张三这条信息的，因为数据只是更新在了数据库并没有更新在缓存中。此时测试人员可能就会有疑问，明明新增成功了，但是数据呢？所以我们需要保证Redis缓存与数据库数据一致的问题。
解决 1 先删缓存，再更新数据库 先删除缓存，数据库还没有更新成功，此时如果读取缓存，缓存不存在，去数据库中读取到的是旧值，缓存不一致发生。
1.1 解决方案：延时双删 延时双删的方案的思路是，为了避免更新数据库的时候，其他线程从缓存中读取不到数据，就在更新完数据库之后，再 sleep 一段时间，然后再次删除缓存。
sleep 的时间要对业务读写缓存的时间做出评估，sleep 时间大于读写缓存的时间即可。
流程如下：
线程1删除缓存，然后去更新数据库线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值。 2 先更新数据库，再删除缓存 如果反过来操作，先更新数据库，再删除缓存呢？
这个就更明显的问题了，更新数据库成功，如果删除缓存失败或者还没有来得及删除，那么，其他线程从缓存中读取到的就是旧值，还是会发生不一致。
2.1 解决方案一：借用消息中间件帮助完成 先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。
问题： 引入消息中间件之后，问题更复杂了，怎么保证消息不丢失，怎么样保证消息的有序性等问题随之而来。就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的 2.2 设置缓存过期时间 每次放入缓存的时候，设置一个过期时间，比如 5 分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。
问题： 如果数据更新的特别频繁，不一致性的问题就很麻烦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f395320a6499a0c08b331f77654b8ae0/" rel="bookmark">
			系分笔记计算机网络OSI七层模型概念、协议和作用以及TCP/IP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、概述2、 OSI七层模型概念、协议和作用3、TCP/IP协议3.1 网络层协议和传输层协议3.2 应用层协议 4、总结 1、概述 计算机网路是系统分析师考试的常考知识点，本篇主要记录了知识点：OSI七层模型概念、协议和作用以及TCP/IP协议中比较重要的考点。
2、 OSI七层模型概念、协议和作用 计算机网络的OSI七层模型从底层往上，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。
3、TCP/IP协议 计算机网络的TCP/IP协议，经常在选择题目中出现，主要考察点是各协议在哪一层。
3.1 网络层协议和传输层协议 其中网络层协议包括了IP、ICMP、ARP、RARP、IGMP；传输层协议包括了TCP、UDP。
3.2 应用层协议 应用层协议较多，包括FTP、TELNET、DNS、HTTP、DHCP、SMTP、POP3等等，常考协议与端口的关系。
4、总结 本篇笔记学习和记录了ISO七层模型和TCP/IP协议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2948a5da998ccbbe6e197127fc8ed4a6/" rel="bookmark">
			Good Bye 2023 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A 2023 sequence a, whose product was equal to 2023, k numbers were removed, leaving a sequence b of length n. Given the resulting sequence b, find any suitable sequence a and output which k elements were removed from it, or state that such a sequence could not have existed.
Notice that you are not guaranteed that such array exists.
有解前提为 ( Π 1 n b i ) ∣ 2023 (\Pi_1^n b_i) | 2023 (Π1n​bi​)∣2023，加1补足剩余部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2948a5da998ccbbe6e197127fc8ed4a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bcd08a0f893d7f71c54b5264df639f9/" rel="bookmark">
			Spring Boot 整合 Camunda 实现工作流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作流是我们开发企业应用几乎必备的一项功能，工作流引擎发展至今已经有非常多的产品。最近正好在接触Camunda，所以来做个简单的入门整合介绍。如果您也刚好在调研或者刚开始计划接入，希望本文对您有所帮助。如果您是一名Java开发或Spring框架爱好者，欢迎关注我程序猿DD，持续非常技术干货。
Camunda简介 Camunda是一个灵活的工作流和流程自动化框架。其核心是一个运行在Java虚拟机内部的原生BPMN 2.0流程引擎。它可以嵌入到任何Java应用程序和任何运行时容器中。
官网网站: https://www.camunda.org/
入门文档: https://docs.camunda.org/get-started/
动手整合Camunda 下面就来一步步动手尝试一下吧。
准备工作 使用Camunda提供的项目初始化工具(Camunda Automation Platform 7 Initializr)[https://start.camunda.com/]
如上图，包名之类的根据自己需要做好配置，最后输入管理账号和密码，点击Generate Project按钮，自动下载工程。
解压下载后的工程，使用IntelliJ IDEA打开，其项目结构
打开pom.xml文件，添加camunda依赖：
&lt;dependency&gt; &lt;groupId&gt;org.camunda.connect&lt;/groupId&gt; &lt;artifactId&gt;camunda-connect-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.camunda.bpm&lt;/groupId&gt; &lt;artifactId&gt;camunda-engine-plugin-connect&lt;/artifactId&gt; &lt;/dependency&gt; 由于Camunda Automation Platform 7 Initializr默认的Spring Boot版本已经是3.1了，所以如果要做一些降级调整，可以手工修改pom.xml中dependencyManagement配置，比如下面这样：
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.6.4&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.camunda.bpm&lt;/groupId&gt; &lt;artifactId&gt;camunda-bom&lt;/artifactId&gt; &lt;version&gt;7.15.0&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 打开配置文件application.yaml，可以看到类似下面的内容
spring.datasource.url: jdbc:h2:file:./camunda-h2-database camunda.bpm.admin-user: id: transduck password: 111111 spring.datasource.url：工作流引擎使用的数据库配置，您也可以根据官网文档去调整到其他数据库中（尤其生产环境）。
camunda.bpm.admin-user：管理员账户配置，可以在这里修改用户名和密码
创建一个简单的工作流 下面我们尝试创建一个简单的工作流：
第一步，我们将请求用户提供两个输入：name和message 第二步，我们将这些输入传递给我们的服务以创建消息输出
开始编码：
创建第一步提到的数据模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bcd08a0f893d7f71c54b5264df639f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7932b9c0e05f60dbc1b953b3869a2c4/" rel="bookmark">
			Unity中URP下实现能量罩（性能优化 和 BRP适配）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、性能优化1、尽可能减少纹理采样次数2、 尽量把 max函数 换成 saturate函数，可以减少一次GPU指令3、尽可能的把计算移到顶点着色器4、变体优化5、变量放入 常量缓冲区 二、BuideIn Render Pipeline适配1、C#脚本开启摄像机深度图2、CG语言适配 三、最终效果和代码 前言 在之前的文章中，我们实现了URP下的能量罩效果。
Unity中URP下实现能量罩（扭曲流光花纹） 我们在这篇文章中，对其进行性能优化 和 BRP下的适配。
一、性能优化 1、尽可能减少纹理采样次数 我们这里把 能量罩花纹纹理 和 抓屏扭曲纹理 合并成同一个来使用，在效果上没多大变化。但是，可以少使用一次纹理采样。 2、 尽量把 max函数 换成 saturate函数，可以减少一次GPU指令 3、尽可能的把计算移到顶点着色器 在片元着色器中计算，需要对片元中的每一个像素进行计算，消耗性能较大 4、变体优化 5、变量放入 常量缓冲区 二、BuideIn Render Pipeline适配 1、C#脚本开启摄像机深度图 Camera.main.depthTextureMode = DepthTextureMode.Depth;
2、CG语言适配 抓屏纹理 GrabPass{“_GrabPass”}
引入库修改 #include “UnityCG.cginc”
纹理申明 sampler2D _MainTex;
float4 _MainTex_ST;
sampler2D _CameraDepthTexture;
sampler2D _GrabPass;
顶点着色器中，顶点坐标系变换需要修改为BRP的方法 v2f vert(appdata v)
{
v2f o = (v2f)0;
o.positionWS = mul(unity_ObjectToWorld,v.positionOS);
o.positionVS = UnityObjectToViewPos(v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7932b9c0e05f60dbc1b953b3869a2c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11b2f0fe41d7880701125d46e57ee4c/" rel="bookmark">
			算法回忆录——DFS与BFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 广度优先搜索2. 深度优先搜索 1. 广度优先搜索 拿迷宫（二维，上下左右四个方向，入口在左方）来举例，一开始从入口出发，一直往右走，如果遇到了路口，就记录下该路口有几条路可以走，然后选择一条走下去，如果走下去又遇到了一个路口，那么又记录下这个路口有几条路口可以走，然后返回第一个路口，选择未走过的路走下去…
总结一下就是，遇到第一个路口，记录一下该路口有几条路，随便选一条，当遇到第二个路口的时候，又记录一下该路口有几条路，然后返回第一个路口，走另外一条路。也就是说，必须先走完第一个路口的所有路，才能走下一个路口的所有路。
到这，会发现这个过程跟由树的结构很容易解释（圆表示路口，线表示路）：
1表示第一个路口，记录这个路口连通的三个路口，选择从左到右第一条路走走到2（第二个路口），记录第二个路口连通的两个路口（只记录不走），返回第一个路口，走第二条路走到3（第三个路口，若有连通的路口就记录，没有就不记录），返回第一个路口，走第三条路走到4（第四个路口），记录第四个路口连通的一个路口，返回第一个路口第一个路口所有路走完，按记录的先后顺序来到第二个路口走到5（第五个路口），记录，返回走到6，记录，返回。第二个路口走完，按记录的先后顺序来到第三个路口第三个路口没有路，来到第四个路口走到7，记录，返回，第四个路口走完来到第五个路口… 而搜索算法针对到是图这类结构，它与树不同的是，拿迷宫来说，树结构的话每条路都是能走到尽头的，图结构的话可能你走到第五个路口，继续走，还能返回到第一个路口，就是这样。
上面的记录步骤可以看到，是先记录哪个路口就走那个路口，可以用队列来实现（先进先出）
下面举一个岛屿最大面积算法题为例：
​ 给定一个由0和1组成的二维数组grid，0表示海洋，1表示岛屿，求岛屿最大面积就是求多个相邻岛屿的总面积最大。（相邻只包括上下左右相邻，斜方向上的相邻不算）
例如:
# 最大面积为5 [[0,1,1,1], [0,0,1,0], [0,1,0,0], [0,1,1,1], [0,0,1,0],] # 最大面积为1 [[0,0,0,0,1,0,1]] 思路：
同迷宫一样，我们从grid[0,0]开始往右找（第一行完了，就从下一行开始）找到岛屿后，判定它是不是已经遍历过如果没有遍历过，就将它标记为已遍历然后判断它的左右上下有没有连着的岛屿，有就标记直到连着的所有的岛屿的左右上下都没有连着的岛屿就结束。记录此时连着的岛屿的总面积然后从grid[0,1]再开始…找完后就能得到最大的岛屿面积 from collections import deque grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] def BFS(grid): # 用来获取一个网格上下左右的四个节点 around = [[-1, 0], [1, 0], [0, 1], [0, -1]] # 获得网格的高度和宽度 height = len(grid) width = len(grid[0]) # 初始化辅助数组，该数组大小与grid一样，其中元素全部为False visit = [] for i in range(height): w = [False for j in range(width)] visit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11b2f0fe41d7880701125d46e57ee4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343ed14e8892b7a25afa20e57f534c91/" rel="bookmark">
			Apache配置ssl证书-实现https访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 1.1 安装Apache服务器 #下载安装apache yum install httpd -y #启动apache服务 systemctl start httpd systemctl enable httpd #查看服务状态 netstat -lntp |grep http 1.2 Apache服务器上已经开启了443端口 443为HTTPS服务的默认端口 1.3 Apache服务器上已安装了mod_ssl.so模块 启用SSL功能,安装mod_ssl.so模块 yum install -y mod_ssl 1.4 获取SSL证书 二、配置apache 2.1 配置apache文件 vhost的域名配置文件.conf，在目录：/etc/httpd/conf.d HTTP配置： Listen 80 # 指定域名 ServerName www.example.com # 指定文档根目录 DocumentRoot /var/www/html # 是否启用访问日志 CustomLog /var/log/httpd/access.log combined # 指定错误日志路径 ErrorLog /var/log/httpd/error.log # 配置虚拟主机 &lt;VirtualHost *:80&gt; ServerAdmin admin@example.com DocumentRoot /var/www/html/project # 访问权限 &lt;Directory /var/www/html/project&gt; Options Indexes FollowSymLinks MultiViews AllowOverride All Order allow,deny allow from all Require all granted &lt;/Directory&gt; # 使用PHP解析器处理.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/343ed14e8892b7a25afa20e57f534c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b642b7244b90321d11621b7009dcdd58/" rel="bookmark">
			【计算机网络】内容整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 分组交换 分组交换则采用存储转发（整个包必须到达路由器，然后才能在下一个链路上传输)技术。
在发送端，先把较长的报文划分成较短的、固定长度的数据段。
电路交换 在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源(缓存、链路传输速率)
建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；通信：主叫和被叫双方就能互相通电话；释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源）。 时延计算 吞吐量 应用层 体系结构 C/S 客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。
客户-服务器方式所描述的是进程之间服务和被服务的关系。
客户是服务的请求方，服务器是服务的提供方。
服务请求方和服务提供方都要使用网络核心部分所提供的服务。
P2P 没有永远在线的服务器
任意终端系统直接通信
对等方向其他对等方请求服务，向其他对等方提供服务
对等体间歇连接并更改IP地址
Socket 进程间通信利用套接字(Socket)发送和接受消息来实现
URL 统一资源定位器
&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;
HTTP 超文本传输协议
基于web的应用层协议
C/S结构
client-----browser:请求接受和展示web对象server-----Web server:响应客户的请求，发送对象 连接 非持续连接
每个TCP连接最多发送一个对象然后关闭连接多个对象需要多个TCP连接HTTP1.0版本使用非持续连接
缺点：
每个对象需要两个RTT
每个TCP连接有开销
浏览器经常打开多个并行TCP连接来获取网页所需的对象 持续连接
客户端和服务器之间的单个TCP连接可以传输多个对象HTTP1.1版本使用持续连接 非流水线 客户在收到前一个响应后才能发出
下一个请求。这比非持续连接的两倍RTT的开销节省了建立TCP连接所需的一个RTT时间。服务器在发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。 流水线 服务器在发送响应后保持连
接打开同一客户机/服务器之间的后续HTTP请求和响应报文通过已打开的TCP连接发送客户机在遇到被引用对象时立即发送请求对于所有被引用的对象，只有一个RTT 响应时间 RTT(往返时延)：从客户机发送一个很
小的包到服务器并返回所经历的时间
HTTP响应时间：
发起、建立TCP链接需要一个RTT发送HTTP请求消息到HTTP相应消息的前几个字节到达需要一个RTT文件发送时延
非持续HTTP响应时间=2RTT+文件发送时延
请求报文 请求方法：
响应报文 首部 通用首部 Cache-Control:通过指定指令来实现缓存机制。
max-age=&lt;\seconds&gt;设置缓存存储的最大周期，超过这个时间缓存被认为过期指定no-cache或max-age=0表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。
Connection:决定当前的事务完成后，是否会关闭网络连接 “keep-alive”“closed”
Keep-Alive:允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数
Date:表明创建HTTP报文的日期和时间。其中时间GMT代表格林威治标准时间 请求头 Host:指明了请求将要发送到的服务器主机名和端口号（可选）
User-Agent:指明用户代理，即浏览器的类型
Accept:列举用户代理希望接收的媒体资源的MIME类型
Accept-Language：用来提示用户期望获得的文档自然语言的优先顺序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b642b7244b90321d11621b7009dcdd58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726b72eca73b2a6a605893ccd7e4ae3b/" rel="bookmark">
			排列和组合【Combination/Permutation 还是 Choose/Arrangement】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介排列与组合符号说明公式公式推导参考资料 简介 排列和组合是概率与组合数学中的基本概念。排列关注的是从集合中选取一定数量的元素，并考虑它们的顺序，而组合则强调元素的选择，而不考虑顺序。这两个概念在解决问题中有广泛的应用，如在统计学、概率论、密码学等领域。总的来说，排列和组合为我们提供了一种方式，通过数学的手段来计算和理解从集合中选择元素的不同方式。🏃
排列与组合 排列是指从一个集合中选择一些元素，按照一定的顺序进行排列。如果我们有一个集合 S S S，包含 n n n个元素，那么从中选择 k k k个元素进行排列的方式数（不放回，不考虑重复）用 P ( n , k ) P(n,k) P(n,k)、 P k n P_{k}^{n} Pkn​或者 A n k A_{n}^{k} Ank​表示，计算公式为：
P ( n , k ) = n ! ( n − k ) ! P(n, k) = \frac{n!}{(n-k)!} P(n,k)=(n−k)!n!​
其中 n ! n! n!表示 n n n的阶乘，即 n ! = n × ( n − 1 ) × ( n − 2 ) × … × 2 × 1 n!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/726b72eca73b2a6a605893ccd7e4ae3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfde1b4a748c709067046aaf4e7ec432/" rel="bookmark">
			展望2024：9大要点把握PLM软件趋势，云PLM领导者Arena
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年《质量强国建设纲要》（以下简称《纲要》）的推出，再次确定了中国要走上制造业高质量发展之路的决心。《纲要》指出要深入实施质量强国战略，加快传统制造业技术迭代和质量升级，推动工业品质量迈向中高端。当前，中国正从制造大国迈向制造强国，提升制造企业的产品研发水平和质量管理是必由之路。
PLM产品生命周期管理软件是世界一流制造企业的“定鼎神器”，自上个世纪90年代开始世界各国的领先制造企业就纷纷采用PLM软件，提高从产品设计到生产制造乃至售后服务的全过程质量和效率。进入20世纪，PLM软件也是制造企业进一步提升产品和服务创新的重要平台，而云PLM还是中小制造企业快速实现高水平高质量发展的关键数字化手段。
2023年9月，全球首屈一指的PLM软件公司PTC宣布正式落地中国首个云原生SaaS产品Arena PLM及QMS（质量管理系统）软件解决方案。在全球知名商业软件评价机构G2发布的2023秋季PLM软件Grid魔力象限报告中，云原生的Arena高居领导者象限。面向2024年，PTC公司认为要从9大方面把握PLM软件选型，而云PLM是最重要的趋势。
云PLM软件的9大能力要素 PLM软件经过40余年的发展历史，已经成为产品概念、设计、开发和生产制造的所有数据与流程的管理平台。PLM软件不断将完整的机械、电子和软件设计整合到一个单一真实数据源，帮助制造企业和供应链合作伙伴共同优化产品开发，同时持续改进质量。
与此同时，市场环境正变得日益复杂。当今经济让远程工作和分布式协同成为必要，IoT、AI等数字技术还在加大产品开发的复杂性。PTC认为，把握新一代企业级云PLM软件的9大要素，有助于制造企业在复杂多变的环境中，获得最优的制造成果，走上高质量发展之路。这9大能力要素包括：协同、BOM管理、工程变更管理、文档管理、合规遵从、项目管理、业务分析、PLM集成以及云架构。
首先，云架构是最新的PLM软件趋势。而企业级云PLM能够将处于不同地理位置的团队整合到单一和统一的系统中，制造企业内部团队和供应链伙伴外部团队能够使用简单的互联网浏览器就实现实时协同，也能消除内外部的“数据孤岛”，让所有人基于“单一真实数据源”互联协同。
其次，BOM管理是传统PLM优势，云PLM还能高效创建、审查和审批最新的BOM清单，确保产品制造没有任何错误或质量问题，也确保在生产制造各阶段的合理成本分配以及让团队及时获知影响供应链或下游制造的任何变更。
第三，云PLM的工程变更管理提供了可控的设计变更流程，从而加速产品开发和上市。产品团队能够更高效率实现工程变更请求和工程变更单，包括自动流转的审批流程，同时还能够对整个产品生命周期中的所有零部件、组装、制图、软件和其它变更进行归档和追溯。
第四，基于云PLM的文档管理能够满足当今高监管的市场环境要求，产品团队能够管理和追踪所有与产品和质量相关的文档，包括产品指标、生产指南、SOP标准操作流程、质量策略和培训记录。基于云的文档管理，让团队能够集中存储文档以及建立审批审计流和优化文档提取。
第五，企业级云PLM能够确保流程、策略和系统满足各种出口管控、环境法规和质量法规的合规遵从要求，还包括对FDA、ISO、RoHS、REACH、ITAR、EAR以及其它行业标准的兼容，以降低合规风险。
第六，云PLM的项目管理要能够允许产品团队跨产品生命周期跟踪各种任务、指令和资源，确保达成所有产品开发周期里程碑。这包括为产品团队提供所有相关团队的可视性，从而帮助团队在项目优先级和产品发布等方面做出更好的决策。
第七，云PLM对相关指标的追踪和分析能力，让企业对于产品和质量流程有更好的可视性，以实现持续质量提升。能够及时获取KPI指标，可让企业在新产品开发和上市过程中，采取更积极的方式以减少可能出现的风险。
第八，制造企业可能已经在产品生命周期的各阶段采用了各种软件解决方案，通过云PLM平台连接这些软件系统能够进一步优化产品开发过程，加速产品上市时间。企业级云PLM系统还应该能够轻松与ERP、CRM等制造相关系统和EDA、MCAD、电子元器件数据库（如SiliconExpert、Octopart等）等工程和设计系统相连接。
第九，如果制造企业在寻求一个能够快速开发、仅需要最小IT基础设施且能够随着业务扩展而扩展的系统，那基于云的SaaS PLM解决方案就是最佳选择。与传统部署于企业数据中心的PLM软件不同，SaaS PLM能够让制造企业免于自有数据中心等开销，而且还能持续获得PLM软件供应商的技术更新，省去传统的软件升级费用以及降低整体拥有成本。
用户“点评优选”的云原生领导者Arena 全球知名商业软件评价机构G2定期发布PLM软件Grid魔力象限评估报告，该报告是基于真实用户的调研以及社交平台数据的综合。在G2的2023秋季PLM软件Grid魔力象限评估报告中，Arena被列入领导者象限，而且是用户票选第一的云原生PLM。相关用户对于Arena的评价是：能够让用户无缝地获取所有与质量管理相关的必要信息，其用户友好的界面和架构良好的流程，让用户团队能够轻松在各种任务中导航以及执行任务。
作为云原生的SaaS PLM，Arena的优势在于提高产品研发效率、缩短实施部署周期以及提升供应链协作效率。很多制造企业的设计与供应链都处于分散状态，而设计的持续变更则导致出现交付周期和质量一致性等问题。Arena将产品信息、人员和流程整合到单一的企业云平台，为企业提供无缝、整合的协同环境，为新产品开发和持续的流程改进提供单一产品数据源，帮助企业持续优化和制造更好的产品，特别是让整条供应链上处于不同“孤岛”的团队实现敏捷协作，也无需复杂的多系统集成。
Arena将质量记录和流程与产品设计连接起来，提供了一个闭环质量系统，帮助医疗器械、生物技术制造、汽车制造等企业开发安全、合规的产品并推向市场。Arena通过单一事实数据源，帮助企业管控、支持和持续改善质量流程，可在零部件、BOM、制图和文档等整个产品相关记录中，管控和追踪质量信息。Arena将质量与产品开发直接相连接，让跨功能的团队能够轻松识别、协同、解决和预防质量问题。Arena自动化的闭环质量流程，还能够提供从产品概念设计到上市商业化的增强的可视性与可追溯性。
Arena不仅能够满足企业云PLM的9大能力要素要求，还是全球云原生PLM的领导者，Arena提供了全新的解决方案和研发产品的模式，帮助用户以敏捷的产品开发方式进行更好的协作，采用Arena的用户可以更快的速度、更高的质量和节省一半的时间进行产品设计开发。作为云原生PLM，Arena极大缩短了传统PLM的平均部署周期，而多租户的SaaS云服务也可以轻松随着企业业务的发展而扩展，覆盖更多地理位置上的团队，支持基于授权角色的协作，最大化系统可用性、可扩展性和安全性。
目前Arena在全球拥有1400多家客户，其中包括700多家高科技电子领域企业、350多家生命科学领域企业以及300多家物联网领域企业。而目前全球100%的TOP15领先ODM或合同制造商的供应链企业，都采用了Arena云服务。
PTC近年来逐渐形成了两大业务单元：以Digital Thread（数字主线）为主的优势产品矩阵，包括Creo、Windchill、ThingWorx以及Codebeamer等；以Velocity（速度）为主、突出敏捷和快速响应的云原生产品矩阵，包括Onshape和Arena等。目前，云原生的Arena PLM&amp;QMS已经和OnShape CAD&amp;下一代PDM，以原生方式打通，用户可以轻松实现CAD和PLM的无缝协同。
展望2024 随着Arena在中国市场的正式落地，将在中国市场拉动云原生PLM的普及以及更大程度加深PLM的应用和采用。Arena适合各行各业，特别是供应链较长和产品研发周期较短的电子制造业与医疗生物器械行业。Arena也适用于大中小型企业，一家企业可以从10人左右的部署规模，逐渐扩展到上千甚至上万人的部署规模。更为重要的是，Arena将国际领先的产品质量管理体系引入中国市场，让更多的创新企业和创新产品得以快速和高质量方式走向全球，进而打响中国制造的高质量品牌！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb8873ba219b7fa0b298c8309b82ffc/" rel="bookmark">
			Easticsearch性能优化之硬件优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Easticsearch性能优化之硬件优化 一、CPU配置二、内存配置1、内存配置总体方针2、内存实际分配3、禁止swap4、GC设置 三、IO（磁盘） 对于性能优化，升级硬件设备配置一直都是提高服务能力最快速有效的手段。硬件优化主要可以从CPU、内存、存储设备(磁盘)、显卡、散热系统、主板、电源、外设设备等。
在系统层面能够影响应用性能的一般主要包括三个因素：CPU、内存和 IO(磁盘)。可以从这三方面进行 Elasticsearch 的性能优化工作。
一、CPU配置 CPU（中央处理器）是计算机系统中最重要的组成部分之一，在CPU内可分为两个主要的单元，分别是：算数逻辑单元和控制单元。 它负责执行计算机程序中的指令和控制计算机系统的操作。
我们都知道Elasticsearch 是一个多线程的应用程序，而多线程的上下文切换会导致CPU的繁忙，Elasticsearch 同时是一个很消耗内存的应用程序，特别是在进行排序、聚合时特别吃内存，这样会导致频繁的GC，也会导致CPU比较繁忙。所以合理的CPU的配置可以更好的提升Elasticsearch 的性能。
比如部署Elasticsearch 时应该选择具有多个内核的现代处理器，常见集群使用2到8核的机器(建议CPU8核，当然具体情况看具体使用)。也可选择高频CPU，来提供更快的计算速度，从而加快Elasticsearch 的处理速度。
注意：更快的 CPUs 和更多的核数之间选择，选择更多的核数更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。
二、内存配置 上面说过Elasticsearch 在排序和聚合时都很耗内存，如果有一种资源是最先被耗尽的，它可能是内存。所以有足够的堆空间来应付它们是很重要的。即使堆空间是比较小的时候，也能为操作系统文件缓存提供额外的内存。因为 Lucene 使用的许多数据结构是基于磁盘的格式，Elasticsearch 利用操作系统缓存能产生很大效果。这样显得内存的合理配置比具体配置多少个（CPU）重要的多得多。
1、内存配置总体方针 对于Elasticsearch 的堆内存分配建议将总内存的一半分配给堆内存，但不要超过机器的物理限制。对于数据节点最好不要超过32G，master节点可适当少点(数据节点一半即可)。所以64 GB 内存的机器是非常理想的，但是 32 GB 和 16 GB 机器也是很常见的。少于8 GB 会适得其反（你最终需要很多很多的小机器），大于 64 GB 的机器也会有问题(会有一定浪费，成本也会增加)。
为什么将总内存的一半分配给堆内存？
答：由于 ES 构建基于 lucene，而 lucene 设计强大之处在于 lucene 能够很好的利用操作系统内存来缓存索引数据，以提供快速的查询性能。lucene 的索引文件 segements 是存储在单文件中的，并且不可变，对于 OS 来说，能够很友好地将索引文件保持在 cache 中，以便快速访问；因此，我们很有必要将一半的物理内存留给 lucene；另一半的物理内存留给 ES（JVM heap）。
为什么数据节点最好不大于32G？
答：在 Elasticsearch 中，将堆内存设置为超过32GB 的主要原因是基于 Java 虚拟机（JVM）的限制。具体来说，这是由于 JVM 使用指针压缩技术所导致的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb8873ba219b7fa0b298c8309b82ffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d06e657ef91cca2179be1bba25628d/" rel="bookmark">
			aes-cbc-128加密C#、java和php代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php $method = 'aes-128-cbc'; $key = '1234567890123456'; $iv = '1234567890123456'; $data = '你好啊'; $encrypted = openssl_encrypt($data, $method, $key, 1, $iv); $encrypted = base64_encode($encrypted);//结果和C#加密的一样 echo $encrypted; echo "&lt;br&gt;"; $decrypted = openssl_decrypt(base64_decode($encrypted), $method, $key, 1, $iv); echo $decrypted; C# 新建.net7控制台项目
internal class Program { static void Main(string[] args) { var key = "1234567890123456"; var iv = "1234567890123456"; var input = "你好啊"; var jiami = EncryptByAESNew(input, key, iv); Console.WriteLine(jiami); Console.WriteLine(DecryptByAESNew(jiami, key, iv)); } /// &lt;summary&gt; /// AES加密算法 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82d06e657ef91cca2179be1bba25628d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8d60f6e755fdba5d772f4a7850aa8f1/" rel="bookmark">
			2023下半年软考证书什么时候发放？怎么领取？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经确定领取时间的地区： 广东：
电子版：2024年1月8日上线
纸质版：预计24年2月开始
重庆：
邮寄申领：2024年1月15日0:00-3月1日23:00
现场领取：2024年1月15日-2月7日
贵州：
邮寄申领：1月11日9:00-1月31日16:00
现场领取：2024年1月10日起
山东：
电子版：2024年1月8日上线
纸质版：2024年1月10日起
湖南：
邮寄申领：2024年1月13日00:00-1月21日17:30
现场集中领取：2024年1月25日
山西：
邮寄受理：2024年1月9日起
现场领取：2024年1月24日-26日
福建：
2024年1月15日至2月5日
统一通过EMS方式邮寄发放
云南：
邮寄申领：2024年1月11日9:00—1月24日24:00
现场领取：2024年1月12日开始工作日
河北：2024年1月11日起
浙江：2024年1月10日起
江苏：2024年1月10日起
广西：2024年1月10日起
辽宁：2024年1月10日起
软考证书领取方式： 个人领证：凭本人有效身份证原件等资料领取；
他人（单位）代领：凭代领人及持证人有效身份证原件等资料领取（有些地区不支持代领）；
证书邮寄：网上申请证书邮寄（部分地区支持）。
软考证书领取流程： 携带相关资料证件，如身份证、准考证、成绩单等；填写《专业资格考试登记表》。
由于各地区软考证书发放时间不同，领取流程可能也有所差异，因此请考生们及时关注当地软考办的证书领取通知，于规定时间内携带相关证件资料前往指定地点领取自己的证书。
新版计算机软件水平考试证书是什么样子？相信不少考生还没有见过改版后的计算机软考证书模样，不妨来看下新版软考证书样本图吧！
新版软考证书内页左侧写了“计算机技术与软件专业技术资格”，盖了中华人民共和国人力资源和社会保障部以及中华人民共和国工业和信息化部的红色印章。右侧则有姓名、证件号码、性别、出生年月、级别、专业、批准日期、管理号以及照片等内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56229dc93a82aff20c8d59e1f4952c6f/" rel="bookmark">
			【JVM】字节码文件的组成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 魔数与Class文件版本
魔数是一个用于校验字节码文件是否有效的标识，位于文件开头的前四个字节，魔数之后是次版本号和主版本号，共同构成了字节码文件的版本号。
2.常量池
常量池是字节码文件中的一个结构，包含了该类的所有常量，如数字，字符串，符号常量等。
3.访问标志
用于描述该类或接口的访问权限和属性。
4.类索引，父类索引，接口索引
分别指向该类的全限定名，父类的全限定名 和该类实现的接口列表。
5.字段表集合
包含了该类的所有字段，每个字段都有访问标志，名称，描述符和值。
6.方法表集合
包含了该类的所有方法，每个方法都有访问标志，名称，描述符和字节码指令序列。
7.属性表集合
包含了该类或接口的所有属性，如源文件名，行号表，本地变量表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361919f4e0a4ce0fe69c002911fa714a/" rel="bookmark">
			spring boot mybatis-plus dynamic-datasource 配置文件 相关依赖环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot mybatis-plus dynamic-datasource 配置文件 相关依赖环境配置
##yaml配置
server: port: 8866 servlet: context-path: /yym tomcat: max-threads: 300 connection-timeout: 57000 max-connections: 500 connection-timeout: 57000 spring: datasource: dynamic: primary: master strict: false # 严格模式 datasource: master: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.3.156:3306/yymdb?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8 username: yym password: 123456 druid: initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false webStatFilter: enabled: true statViewServlet: enabled: true url-pattern: /druid/* # 控制台管理用户名和密码 login-username: admin login-password: admin filter: stat: enabled: true # 慢SQL记录 log-slow-sql: true slow-sql-millis: 1000 merge-sql: true wall: config: multi-statement-allow: true mybatis-plus: mapper-locations: classpath*:mapper/**/*Mapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361919f4e0a4ce0fe69c002911fa714a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e692dd5ad368f190d852d016cced2b5/" rel="bookmark">
			如何在前端项目中引入外部字体并使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、下载字体二、使用 文章转自掘金： https://juejin.cn/post/7063111159372578829
在前端开发中，不免遇到会有需要更换字体的需求，这时我们先要给需求方讲清楚更换字体一定要考虑到版权问题，要找有明确说明是免费使用的授权文档，不然一不小心就会成为背锅侠，这可百口莫辩了。我们UI选取的两个字体都是他去找了相关的授权使用书，证明是免费商业可用，我们才给他使用的，没有授权书我们可不能稀里糊涂的更换字体，这个一定要注意，谨记！
一、下载字体 既然版权的问题UI解决了，那我们就不能再去推脱了。那如何在项目中引入外部字体并使用呢？其实很简单，不管项目是Vue还是React，都是一样的，具体做法参考如下：
下载字体最好交给UI去做，因为样式效果是他设计的，自然字体文件也因由他解决，最好使用UI下载好的字体文件，我们只需要告诉UI我们需要.ttf或.otf的字体文件即可，至于其它琐事就麻烦他给你解决完善。如果你非要自己去下载字体文件，那推荐你使用下载字体-http://xiazaiziti.com/网站查找字体并下载。
二、使用 当所有问题都完美解决之后，就轮到我们出手了。
1、首先我们在assets文件夹中创建fonts文件夹，将下载好的字体放入fonts文件夹中：
2、在assets文件夹中创建style文件夹（我们把重置网页样式，覆盖样式或通用样式都放在style文件夹下），新建一个font.less文件：
3、在font.less文件中写入如下代码：
@font-face { font-family: 'openSans'; src: url('../fonts/OpenSansCondensed-Light.ttf'); font-weight: normal; font-style: normal; } @font-face { font-family: 'fzfs'; src: url('../fonts/FZFSJW.ttf'); font-weight: normal; font-style: normal; } 4、然后在main.js(Vue)或index.tsx(React)中引入：
import './assets/style/font.less'; 5、样式使用：
.bit-th-cn { font-size: 14px; font-family: 'fzfs'; color: #555; } .bit-th-en { font-family: 'openSans'; color: #555; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764f19583cbeea17e77c48d9b7e6dc62/" rel="bookmark">
			Yarn工作机制 &amp; 三种调度器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.Yarn资源调度器1.1 Yarn基础架构1.2 Yarn工作机制 二.Yarn调度器与调度算法2.1 先进先出调度器(FIFO)2.2 容量调度器(Capacity Scheduler)2.2.1 特点2.2.2 调度器资源分配算法 2.3 公平调度器(Fair Scheduler)2.3.1 特点2.3.2 缺额2.3.3 队列资源分配方式2.3.4 调度器资源分配算法 一.Yarn资源调度器 Yarn 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而 MapReduce 等运算程序则相当于运行于操作系统之上的应用程序。
1.1 Yarn基础架构 YARN 主要由 ResourceManager、NodeManager、ApplicationMaster 和Container 等组件构成。
1.2 Yarn工作机制 （1）MR 程序提交到客户端所在的节点。
（2）YarnRunner 向 ResourceManager 申请一个 Application。
（3）RM 将该应用程序的资源路径返回给 YarnRunner。
（4）该程序将运行所需资源提交到 HDFS 上。
（5）程序资源提交完毕后，申请运行 mrAppMaster。
（6）RM 将用户的请求初始化成一个 Task。
（7）其中一个 NodeManager 领取到 Task 任务。
（8）该 NodeManager 创建容器 Container，并产生 MRAppmaster。
（9）Container 从 HDFS 上拷贝资源到本地。
（10）MRAppmaster 向 RM 申请运行 MapTask 资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764f19583cbeea17e77c48d9b7e6dc62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d35bcfa2d38ca8293cfa6b4aacce35/" rel="bookmark">
			自动驾驶：低阶可部署的单目测距算法-基于YOLO与透视变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发环境
部署平台：英伟达的Jetson Nano
环境：Linux + ROS
语言：C++
设备：1920*1080像素的摄像头、开发板。
模型：yolo-v8s
二、单目测距实现思路
0、标定相机和车辆（假设已经标定完成）
1、通过yolo对目标检测，获得ROI区域
2、根据ROI计算车辆和地面接触的中心点
3、根据车辆类别先验信息，主要是高度真实数据，反算车辆的实际距离
完整代码链接，要点小费哦
三、核心代码展示
等会儿上传 四、效果图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f27694be6803d4450c5c3d21e7bb7b7/" rel="bookmark">
			PC-lint Plus在安全系统中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​本文翻译自官方文档 pclp-sca
1、概述 Vector Informatik GmbH 开发的静态分析工具受到全球几乎所有行业成千上万家企业的信赖。我们的用户群中有很大一部分利用我们的工具来开发嵌入式和安全关键型环境的应用程序。长期以来，我们通过实施嵌入式编译器使用的语言扩展、支持各种 MISRA 编码标准以及增加诊断功能来解决嵌入式开发人员的具体问题，为这一群体提供支持。 作为我们对嵌入式和安全关键型开发人员社区持续承诺的一部分，我们为在此类环境中使用 PC-lint Plus 编写了本指南。
本指南提供
最佳实践清单，遵循该清单将有助于最大限度地正确使用 PC-lint Plus，使您意识到潜在问题的领域、避免或检测异常操作的步骤，以及支持稳健套料环境的策略建议。
讨论环境因素以及 PC-lint Plus 在运行时可能受到的环境影响。
2、在安全关键应用中使用 PC-lint Plus 的最佳实践 2.1 确保配置正确 开发一个包含库头文件的简短测试程序，并使用所依赖的编译器特定功能。在该程序上运行 PC-lint Plus，以确保其产生正确的结果，并确保在处理库头文件时不会产生错误。
在使用新的库头文件之前，创建一个包含这些头文件的空 C 或 C++ 文件，并在该文件上运行 PC-lint Plus。在使用这些库头文件的任何生产代码上运行 PC-lint Plus 之前，确保库头文件产生的任何错误都已得到解决。
2.2 针对特定目的验证工具 我们建议使用测试线束来确保 PC-lint 满足您的需求和期望，从而建立对 PC-lint Plus 配置的信心，并针对特定目的验证其功能。
例如，如果您依赖 PC-lint Plus 来检测特定的 MISRA 违规行为，则应 1) 查看我们的文档以确定所声称的支持级别；2) 查看并理解与规则支持声明相关的任何文档注意事项；3) 创建包含已知 MISRA 规则违规行为的测试，并验证 PC-lint Plus 是否使用您的配置生成预期的相应诊断。
应定期运行此类测试，包括在使用 PC-lint Plus 的新设施、更改配置和升级 PC-lint Plus 时。保持此类测试有助于 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f27694be6803d4450c5c3d21e7bb7b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebfd457c5da5cb96e2f8869f2768a005/" rel="bookmark">
			最新热门商用GPT4.0带MJ绘画去授权版本自定义三方接口(开心版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一台VPS
搭建宝塔
解析域名
上传程序至根目录
访问首页在线安装配置数据库
PHP版本选择:7.3
安装完成后访问网站首页即可！
配置APIKEY，登录网站后台自定义配置，不然网站无法使用！
网站后台地址/admin 默认账号:admin 密码:123456
程序完美运行，独家开发，支持7种会员开通模式，有:”购买提问次数”或者”开通月付会员”套餐等等，GPT4支持Token收费模式！
套餐次数和价格可以自定义在后台进行修改
支付直接对接易支付或码支付就可以了，每个IP均有免费提问一次(可以自定义)，然后自动强制跳转登录
登录之后可购买付费套餐，也可以关闭整站收费功能，具体到后台设置里面自己去看吧
总之功能很齐全，Prompt角色扮演功能也有，绘图和GPT4也支持！
源码下载：YISHEN源码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b504bda8e22ee3d1aaf4f36454fd2e/" rel="bookmark">
			《JVM由浅入深学习【八】 2024-01-12》JVM由简入深学习提升分(JVM的垃圾回收算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 JVM的垃圾回收算法1. 标记-清除算法（Mark-Sweep）原理步骤优点缺点 2. 复制算法（Copying）原理步骤优点缺点 3. 标记-整理算法（Mark-Compact）原理步骤优点缺点 4. 分代收集算法（Generational Collection）原理步骤优点缺点 结论 JVM的垃圾回收算法 引言
Java虚拟机（JVM）的垃圾回收（GC）是Java内存管理的重要部分。正确理解不同的垃圾回收算法对于优化Java应用性能至关重要。本文将探讨JVM中常见的垃圾回收算法，分析它们的工作原理，并对比它们的优缺点。
1. 标记-清除算法（Mark-Sweep） 原理 标记-清除算法分为“标记”和“清除”两个阶段：首先标记出所有从根集合（如线程栈、静态字段等）可达的对象，然后清除未被标记的对象。
步骤 步骤1（标记）：显示内存堆中的对象，用不同颜色标记可达和不可达的对象。
步骤2（清除）：展示清除后的内存堆，不可达对象被移除。
优点 简单直观。
不需要额外移动存活对象。
缺点 清除后会产生大量内存碎片。
标记和清除过程效率不高。
2. 复制算法（Copying） 原理 将内存划分为两块，每次只使用其中一块。当这一块内存用完时，程序就将所有存活的对象复制到另一块内存中，然后清除当前块的所有对象。
步骤 复制前：展示内存的两个区域，其中一个区域包含对象。
复制后：存活的对象被复制到另一块区域中，原区域被清空。
优点 无内存碎片。
复制过程中仅处理存活的对象，适合对象存活率低的场景。
缺点 内存利用率低，只能使用一半的内存。
对象复制需要时间，影响性能。
3. 标记-整理算法（Mark-Compact） 原理 类似于标记-清除算法，但在清除阶段不直接释放未被标记的对象，而是将所有存活的对象都向一端移动，然后清理掉边界以外的内存。
步骤 标记阶段：显示标记存活对象的过程。
整理阶段：显示所有存活对象向内存的一端移动的过程。
优点 解决了内存碎片问题。
保持了较高的内存利用率。
缺点 移动对象需要时间，可能会暂停用户线程。
实现相对复杂。
4. 分代收集算法（Generational Collection） 原理 基于对象的生命周期不同，将内存划分为几个代，如年轻代、老年代等。不同代使用不同的垃圾回收算法。
步骤 内存分代示意图：展示年轻代和老年代的内存分布。
各代的垃圾回收过程：分别展示年轻代使用复制算法，老年代使用标记-清除或标记-整理算法的过程。
优点 提高了垃圾回收的效率和内存的利用率。
可以针对不同代的特点优化算法。
缺点 管理复杂，需要调整各代的大小和回收频率。
结论 不同的垃圾回收算法各有优劣，通常JVM会根据具体应用的需求和特点选择合适的算法。理解这些算法的原理和特点对于优化Java应用和调试内存问题非常有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c603bb044e2bb320a700ab23afe29555/" rel="bookmark">
			uniapp：如何将返回标根据下滑的距离而改变颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目过程中我们会遇到这种情况：
返回标和背景颜色重合导致无法看见的情况，这里有一个简单的方法可以实现
监听页面向下滑动的api： onPageScroll : function(e) { //nvue暂不支持滚动监听，可用bindingx代替 console.log("滚动距离为：" + e.scrollTop); }, ​ ​ 这个api会实时监听你鼠标向下滚动的距离，直接写在vue2：methods中即可。vue3直接写在setup函数中就可以了如图所示：
步骤 1、先在data中定义数据taranY 2、在方法onPageScroll获取监控的距离 3、在html中通过三目运算符，通过判断taranY的值是大于40（因为下滑距离大于40时刚好与背景颜色重合），从而改变颜色 来看看运行效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0c9822f011e84483a4c93d87c98895/" rel="bookmark">
			AMEYA360报导：瑞萨宣布收购Transphorm，大举进军GaN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全球半导体解决方案供应商瑞萨电子与全球氮化镓(GaN)功率半导体供应商Transphorm, Inc.(以下“Transphorm”)于今天宣布双方已达成最终协议，根据该协议，瑞萨子公司将以每股5.10美元现金收购Transphorm所有已发行普通股，较Transphorm在2024年1月10日的收盘价溢价约35%，较过去十二个月的成交量加权平均价格溢价约56%，较过去六个月的成交量加权平均价格溢价约78%。此次交易对Transphorm的估值约为3.39亿美元。
此次收购将为瑞萨提供GaN(功率半导体的下一代关键材料)的内部技术，从而扩展其在电动汽车、计算(数据中心、人工智能、基础设施)、可再生能源、工业电源以及快速充电器/适配器等快速增长市场的业务范围。
作为碳中和的基石，对高效电力系统的需求正在不断增加。为了应对这一趋势，相关产业正在向以碳化硅(SiC)和GaN为代表的宽禁带(WBG)材料过渡。这些先进材料比传统硅基器件具备更广泛的电压和开关频率范围。在此势头下，瑞萨已宣布建立一条内部SiC生产线，并签署了为期10年的SiC晶圆供应协议。
瑞萨现目标是利用Transphorm在GaN方面的专业知识进一步扩展其WBG产品阵容。GaN是一种新兴材料，可实现更高的开关频率、更低的功率损耗和更小的外形尺寸。这些优势使客户的系统具有更高效、更小、更轻的结构以及更低的总体成本。也因此，根据行业研究，GaN的需求预计每年将增长50%以上。瑞萨将采用Transphorm的汽车级GaN技术来开发新的增强型电源解决方案，例如用于电动汽车的X-in-1动力总成解决方案，以及面向计算、能源、工业和消费应用的解决方案。
瑞萨首席执行官柴田英利表示：“Transphorm是一家由来自加州大学圣塔芭芭拉分校、并扎根于GaN功率、经验丰富的团队所领导的公司。Transphorm GaN技术的加入增强了我们在IGBT和SiC领域的发展势头。它将推动和扩大我们的关键增长支柱之一的功率产品阵容，使我们的客户能够选择最佳的电源解决方案。”
Transphorm联合创始人、总裁兼首席执行官Primit Parikh博士以及Transphorm联合创始人兼首席技术官Umesh Mishra博士表示：“结合瑞萨全球布局、广泛的解决方案和客户关系，我们很高兴能为WBG材料的行业广泛采用铺平道路，为其显着增长奠定基础。这项交易还将使我们能够为客户提供进一步扩展服务，并为我们的股东带来可观的即时现金价值。此外，它将为我们杰出的团队提供一个强大的平台，以进一步发展Transphorm卓越的GaN技术和产品。”文章来源：http://www.ameya360.com/hangye/111182.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f8bd8ba9a34fc2761ea141157a080e/" rel="bookmark">
			Unity云渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		曾经做过一个数字孪生项目，里面涉及到核心模块是3D效果渲染，刚开始的时候对业务场景不是非常清晰或者交流不够充分，在技术选型上走了很多弯路，也浪费的大量的时间，不过也得到了很多宝贵的实践经验和教训。
第一次尝试，刚开始参与做3D模块的小伙伴选型了threejs来做3D效果的渲染，当然如果只是单独看做3D效果threejs肯定是可以的，问题的关键是数据还不小。当时他基于这种方式通过文件流的方式作为数据的输入，threejs对这个数据进行加载渲染，当时就卡的不行了，后来放弃了这种方案。
第二次尝试，另外一个小伙伴基于这种场景技术选型了Unity技术来实现该需求。Unity是基于C#语言来做的开发，可以做客户端方式的3D效果，当然也是可以生成为html被web应用集成，因此选择了Unity生成html的方式进行实践。刚开始做效果的时候也是使用少量的数据做测试的，在Unity中通过http方式远程获取业务数据作为输入，当下载完成之后再进行3D渲染，后来发现3D效果的业务数据可不是一般的多，而是数据量非常大，可以达到上百G的数据，而且还要在很短的时间内就要完成渲染，按照当前的方案无论如何是达不到效果的。因此该方案又被放弃了。
第三次尝试，山重水复疑无路,柳暗花明又一村。正当冥思苦想寻找思路的时候，有人提出有没有云渲染的方法，后来经过一番资料的查找，发现Unity确实有云渲染的解决方案。其核心技术就是Unity Render Streaming，这也是官方提供的Unity云渲染的解决方案。该解决方案的核心思路就是在服务端上产生了大量的业务数据，产生业务数据的生成器和Unity部署在一台机器上，不经过海量数据的网络传递，也不经过大量文件的IO的读写，产生数据的同时直接传递给Unity，通过Unity进行实时消费渲染之后，通过视频流的方式传递到浏览器端，这样就根本减少了浏览器端的消耗，从而达到了效果。
1）Web浏览器将Offer SDP发送到 Web 服务器。
2）Unity检查Web服务器是否有未处理的Offer SDP，并接收任何找到的。
3）Unity将Answer SDP发送到Web服务器。
4）Web浏览器检查Web服务器是否有未处理的Answer SDP并接收任何找到的。
5）Web浏览器将ICE Candidate发送到Web服务器。
6）Unity检查Web服务器是否有未处理的ICE Candidates并接收任何找到的。
7）Unity将ICE Candidate发送到Web服务器。
8）Web浏览器检查Web服务器是否有未处理的ICE Candidate并接收任何找到的。
参考资料：
https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/best-practice-for-unity-remote-rendering
https://blog.csdn.net/wuquanl/article/details/123643685
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/21/">«</a>
	<span class="pagination__item pagination__item--current">22/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/23/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>