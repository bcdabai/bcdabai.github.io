<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4c76e98e990a41f55a7652e9da2c7e/" rel="bookmark">
			react中使用Modal.confirm数据不更新的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Modal.confirm的时候今天发现了个疑惑的问题，为什么我明明从新set了数据而页面视图没有变化，查了一下官方文档找到了答案，解决了这个问题，特意在这里留下痕迹。
import { Button, Col, Form, Input, Modal, Radio, Row, Select, Space, Spin } from 'antd' let modal = null export default function (props) { const [typeStr, settypeStr] = useState('') const [lookIPorAS, setlookIPorAS] = useState('ip') const returnModalFun = () =&gt; { return &lt;Row className="m-b-10-px"&gt; &lt;Col span={16} key={lookIPorAS}&gt; &lt;Radio.Group onChange={onchangeFun} value={lookIPorAS}&gt; &lt;Radio value="ip"&gt;IP&lt;/Radio&gt; &lt;Radio value="as"&gt;AS&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/Col&gt; &lt;/Row&gt; } const onchangeFun = (e) =&gt; { setlookIPorAS(e.target.value) } const detailsFun = (item) =&gt; { setItemObj(item) const { type } = item if (type === '滥用') { // settypeStr('abuseString') modal = Modal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4c76e98e990a41f55a7652e9da2c7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e5783847b9365625a8498bb2097cb8/" rel="bookmark">
			javaScript:DOM元素的获取（静态/动态获取）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.dom元素获取的意义与使用场景 使用场景（绝大多数js操作都需要dom操作）
总结/疑问解答！ 二.DOM元素获取的常用方法（重点）
获取dom元素（动态）
document.gerElementbyId()
document.gerElementsBytagName()
document.gerElementsByclassName()
document.gerElementsByname()通过name属性查找元素
获取dom元素（静态）
1.querySelector(css选择器) 新方法，ie低版本不支持，返回的是符合选择器的第一个元素对象
2.querySelectorAll(css选择器) 返回的是符合选择器的所有元素对象
3.特点（重点）
4.注意
静态和动态的区别
相关代码
一.dom元素获取的意义与使用场景 DOM 元素获取在 JavaScript 中具有重要的意义和作用。它使我们能够动态地与网页中的元素进行交互，并根据用户的操作或特定的逻辑来修改页面的外观和行为。
作用/意义（了解即可）
操作和修改元素内容：通过获取 DOM 元素，我们可以修改元素的文本内容、HTML 结构或其他属性。这使得我们可以根据需要动态地修改页面，例如更新文本、插入新的元素或更新图片等。添加和删除元素：通过获取 DOM 元素及其父元素，我们可以动态地添加新的元素到页面中，或删除现有的元素。这对于创建动态内容、响应用户操作或实现交互性的网页非常有用。修改元素样式：通过获取 DOM 元素的引用，我们可以修改元素的 CSS 样式，包括颜色、尺寸、位置等。这使得我们可以根据特定条件或用户操作来改变元素的外观，从而实现更好的用户体验或动态效果。添加事件监听器：通过获取 DOM 元素，我们可以为元素添加事件监听器，以便在用户执行特定操作时触发相应的 JavaScript 代码。这使我们能够实现响应式的交互，并处理用户的点击、鼠标移动、键盘输入等事件 使用场景（绝大多数js操作都需要dom操作） 动态网页：当需要根据用户的操作或特定的逻辑来动态更新网页内容或行为时，DOM 元素获取非常有用。例如，表单验证、菜单导航、动画效果等。单页应用程序（SPA）：在使用 JavaScript 框架（如React、Angular、Vue.js）开发单页应用程序时，通过获取 DOM 元素来操作和更新页面是必要的。例如，根据路由切换组件、更新数据、渲染视图等。动态表单验证：当需要验证表单输入的有效性，并基于验证结果提示用户时，通过获取 DOM 元素来检索表单字段，并应用相应的验证逻辑非常有用。注意DOM 元素获取是一项强大的功能，但在处理大量元素时可能会影响性能。因此，在使用过程中要注意使用正确的选择器，并避免不必要的DOM操作，以提高网页的性能和响应速度。 总结/疑问解答！ dom操作其实在前面的文章中已经用到很多次了，但是一直没有系统性的总结，接下来的几篇文章，主要来总结dom操作以及dom操作相关的案例（小游戏），比如说：选字游戏，连连看，打地鼠，多球碰撞，随机抽签，无缝轮播，原生js绘制时钟等等。
二.DOM元素获取的常用方法（重点） 获取dom元素（动态） 获取dom元素
document.gerElementbyId() document.gerElementsBytagName() document.gerElementsByclassName() document.gerElementsByname()通过name属性查找元素 ie下只针对于input元素起作用
在标准浏览器下，可以适用于任何标签
注意：gerElementsByname()的调用对象只能是 document
以上几种方法在前面的文章中都有讲到，所有在这里面不做过多的讲述，详情可以翻阅往期的笔记。下面是文章链接javaScript：如何获取html中的元素对象_js 获取html对象_小姚学前端的博客-CSDN博客
获取dom元素（静态） 1.querySelector(css选择器) 新方法，ie低版本不支持，返回的是符合选择器的第一个元素对象 let age = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4e5783847b9365625a8498bb2097cb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf17775615bc6e3ddcca8cd5167f8b5e/" rel="bookmark">
			filelist_package的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		filelist_package的使用 文章目录 filelist_package的使用不使用pkg的filist首先filelist（tb.f）中如果只是包含文件夹，不是指定包含文件。如果文件不在同一文件夹下 在filelist使用pkg（作用是避免过多使用`include或在filelist中放入过多条目）不能将pkg在module内部中`include。也不能在pkg内`include "pkg"。还有也不能在pkg内`include "interface.sv"。filist中加上pkg嵌套的package以及非嵌套package。 总结 验证中filelist以及package的使用
Systemverilog 中`include 和 filelist区别
下面的例子中使用的makefile：
dumpfile：
不使用pkg的filist 首先filelist（tb.f）中如果只是包含文件夹，不是指定包含文件。 比如我们有三个文件在同一个文件夹下：
第一个lab_task.sv，里面只包含了一个task print_t,但是这个task使用,lab_task0.sv里面定义的print_i task。
第二个lab_task0.sv，也只定义一个task
第三个就是一个testbench的文件，注释部分先不用看。这里面只是调用了print_t这个task。
filelist我们这样写：注释的部分不用看（//）
此时lab_task.sv和lab_task0.sv是没有包含出来，只是列举了包含他们的path ./。但是lab28_dpi是列出来的，编译结果是：
可以看到 ，编译找不到print_t，那么我们就需要显示的将lab_task.sv和lab_task0.sv包含进去。显示包含有两种方式：
第一种方式是直接在filelist中。将两个文件列出来，需要注意文件顺序。（这里其实+incdir+./可以不要，因为我们需要的两个文件已经列出来）
编译结果就不会报错：
第二种就是tb.f不变，但是在lab28_dpi中将两个文件`include进来。这种也不会报错（但是注意+incdir+./不能省略，因为可能lab_task可能和testbench不在同一个文件夹下，所以需要指明路径，这里省略是因为在同一个目录下）。
如果两种方式同时使用就会报重复编译错误，也就是如果filist列举出来，那么就不用include进去（这种情况可以使用宏来避免）。
如果文件不在同一文件夹下 如果我们把lab_task.sv和lab_task0.sv放在上一级目录，filist为：
testbench依然为：
编译报错，找不到对应的lab_task.sv，和lab_task0.sv：
这说明我们需要把这两个文件显示的包含进来，和上面一样，也是上面这两种方式：
首先说第二种include方式，我们可以在testbench的include上加上路径，include "../lab_task.sv" ,include “…/lab_task0.sv”，这样也会编译出结果，但是这种不常用。常用的是tb.f中加上上一级目录，同时testbench中include不变。也就是只需要把tb.f改为：
第一种方式在filist中加上这两个文件申明，就是加上两行…/lab_task.sv，…/lab_task0.sv。但是就别既在filist中加文件，又在testbench中加include。比如我们两种都使用，那么就会报错：
（如果想要避免这种错误，可以使用宏定义来控制）。
在filelist使用pkg（作用是避免过多使用`include或在filelist中放入过多条目） 不能将pkg在module内部中include。也不能在pkg内include “pkg”。还有也不能在pkg内`include “interface.sv”。 比如，下面两种都会报错
module test() `include "pkg1.sv" endmodule package pkg1; `include "pkg2.sv" endpackage 正确的应该是在外面`include(因为include就是把代码段嵌入include处)，在里面import。比如
`include "pkg1.sv" module test(); import pkg1::*; endmodule filist中加上pkg 比如我们现在用一个pkg将两个task文件包进去（此时lab_task.sv，lab_task0.sv,lab_pkg.sv都在目录…/下,而makefile，filelist，testbench都在./（当前目录） ）,文件内容如下（注释部分先不去管）：
此时，我们也可以使用两种方式来使用pkg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf17775615bc6e3ddcca8cd5167f8b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f8e78d2f455c459a2d55a319ff2037/" rel="bookmark">
			CPU扫盲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU扫盲 文章目录 CPU扫盲指令集指令集概念指令集架构CPU和指令集的关系 CPU如何执行指令以及流水线技术指令系统组成地址空间操作数指令操作和编码 CPU如何执行一条指令CPU如何执行多条指令 RISC-V指令集架构寄存器RSIC-V32I 寄存器说明 RAISC指令比较指令格式比较寻址方式比较公共指令功能 RAISC常见指令类型基础整数指令算数运算类指令逻辑运算指令移位运算累指令位操作指令转移指令普通访存指令(数据传输指令)条件分支指令边界检查访存指令内存屏障指令 基础浮点指令特权指令伪指令 RISCV一些关注的信号 问题CPU为什么只能发single，不能发burst？ CPU指令集 CPU扫盲-CPU与指令集的关系
CPU扫盲-CPU如何执行指令以及流水线技术 计算机原理学习（3）-- 内存工作原理
一口气看完45个寄存器，CPU核心技术大揭秘 指令集 指令集概念 指令集顾名思义就是一套指令的集合。
在CPU的世界里只有0和1，指令就是通过特定顺序、特定数量的0和1的来定义相加、赋值等行为。
指令集则是一系列行为的集合，通过他们就可以指挥CPU为各种事物编码。
指令集是一个CPU的基石，要实现CPU 计算和控制功能，就必须定义好一系列与硬件电路相匹配的指令系统.指令就是我们交代CPU 要执行的操作，指令集就可以简单理解为指令的集合。我们把cpu 能够识别的指令汇总在一起就构成了一个指令集。不同的CPU 有不同的指令集，根据他们的繁简程度可以分为两种：复杂指令集CISC 和精简指令集 RISC
CPU与指令集中提到创造指令集并不难，难的是如何将指令集推广，那这篇文章我们就从创作者的角度去理解它，我们尝试创造一个只包含几个指令的指令集。当然这篇文章的目的不是摒弃全部现有指令集概念完全闭门造车，而是站在现有指令集概念的肩膀上从创造者的角度去更深入的理解它。
目前界内的指令集分为两个派系CISC (Complex Instruction Set Computer / 复杂指令集计算机）和RISC (Reduced Instruction Set Computer / 精简指令集计算机），CISC和RISC 并不是具体的指令集，而是两种不同的指令体系，相当于指令集中的门派，是指令的设计思想。举个例子，就像中医与西医，中医讲究从整体上调理身体，西医则更多的是解决器质性病变。这就是两种不同的医疗思路，类似于 CISC 和 RISC 这两种指令体系。那什么是指令集呢？拿中医举例，像华伦、张仲景这两位医圣，他们虽然都是基于中医的思想治病，但医术各有特色，水平也不尽相同，这就相当于不同的指令集。
CISC系列指令集的出现远早于RISC，那时候设计指令集就是摸着石头过河，考虑比较局限，当时的程序员还都在使用汇编语言编写代码，总期望着一个指令可以多干一些事情，把工作转移给硬件电路，这样程序员爽歪歪，这样做的结果就是指令越来越复杂，长短不一，参数繁多。CPU硬件电路的制造工艺虽然不断进步但其电路的设计始终被CISC的指令集限制，最终成为CPU性难以能提升、尺寸难以缩小的瓶颈。此时诞生了RISC。其实最开始并没有CISC这个名字，只是后面出现了RISC为了作区分就将RISC之前的指令集统称CISC。CISC中的指令集就是大杂烩，长短不一、使用频率不一、没有规则限定，而RISC相当于对CISC的一次重构，借鉴了 CISC 的经验，取其精华，弃其糟柏。在RISC中采用定长指令，大大提升译码效率；将复杂指令拆分成多个简单指令，减少了硬件电路的复杂性，给予CPU微架构设计更多的发挥空间（苹果的M1）；限制每个指令最多一个内存寻址操作数，推崇寄存器到寄存器的操作，保证每个指令都能在单个时钟周期内完成… RISC旨在提高每个指令的执行时间，以此来提升CPU工作流水线整体性能。
无论是CISC还是RISC都是采用操作码+操作数的设计思路，指令集中的操作数可以是寄存器、立即数、内存地址三种，也对应了CPU寻址的三大类：
寄存器寻址：寄存器寻址就是操作数是某一个寄存器，CPU执行指令时需要从寄存器中获取或写入”数据“。如：mov ax, bx，将bx寄存器中的值写入ax寄存器。内存寻址：内存寻址就是操作数是一个内存地址，CPU执行指令时需要从内存中获取或写入”数据“。内存寻址又分为直接寻址、基址寻址、变址寻址、基址变址寻址。我们这里只用最容易理解直接寻址，就是将直接在操作数中给出的数字作为内存地址，告诉 CPU 取此地址中的”数据“作为操作数。如：mov ax, [0x3000]，将0x3000 地址中的”数据“写入ax寄存器。立即数寻址：立即数寻址就是操作数是一个常数。只所以叫立即数就是凸显这个”数据“CPU拿来立即可以使用，在执行指令时无需去内存或寄存器中寻址。如：mov ax, 0x18，将数据 0x18写入ax寄存器。 接下来我们尝试来设计一个指令集，我们这里为了凸显寻址方式的不同多加个一个”寻址方式“字段，我们的指令集规则如下：
11代表操作数为内存地址，10代表操作数为寄存器，00代表操作数为立即数。如：11 00 10 代表操作数1是内存地址，操作数2是立即数，操作数2是寄存器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f8e78d2f455c459a2d55a319ff2037/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67602ee874270ab0ffd3792c10121550/" rel="bookmark">
			2023-2024年最新软件工程专业毕设项目推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 简介1 如何选题2 最新软件工程毕设选题 0 简介 学长搜集分享最新的软件工程业专业毕设选题，难度适中，适合作为毕业设计，大家参考。
学长整理的题目标准：
相对容易工作量达标题目新颖 1 如何选题 最近非常多的学弟学妹问学长关于选题的问题，所以今天学长来教大家如何进行毕业设计选题！
毕业设计的选题尤为重要，选好题目是最终完成毕业设计的第一步。
因为题目的选择跟之后的设计实现密不可分，如果你所选择的题目是你无法实现的，而且定题以后就不能修改了，这无疑会给你带来很大的困扰。
先介绍一下自己, 本人HIT研究生在读, 接触许多大三大四的实习生，我都会帮他们分析选题的难度，根据他自己对知识掌握的情况来帮他们选题。
一般来说，一套网站系统，像一些基于ssm框架的管理系统比较容易一点，更为容易一些。但今年来，这种前后端系统(统称XXX管理系统)很难通过毕设答辩，因为基本做被烂了，更多的学校要求设计题目内必须包含算法。
选题分享，技术解答
https://gitee.com/yaa-dc/warehouse-1/blob/master/python/README.md
2 最新软件工程毕设选题 基于SSM的热点推荐个性化新闻系统的设计与实现
基于卷积神经网络的共享单车识别系统的设计与实现
基于深度学习的图片自动分类系统的设计与实现
基于VUE框架的实时新闻推送平台的设计与实现
基于卷积神经网络的垃圾短信识别系统的设计与实现
基于卷积神经网络的垃圾短信识别系统的设计与实现
基于遗传算法的股票预测系统设计与实现
基于SSM开发的微博舆情系统的设计与实现
基于SSM的人力资源管理系统的设计与实现
基于卷积神经网络的人体行为识别系统的开发与设计
基于协同过滤算法的图书管理系统的设计与实现
基于BP神经网络的停车场管理系统的设计与实现
基于YOLOV5的火灾快速识别系统的设计与实现
基于CNN算法的图像艺术风格迁移系统的设计与实现
基于React框架开发企业教育平台后台管理系统的设计与实现
基于机器学习的歌曲自动生成系统的设计与实现
基于线性回归的毕业生招聘信息及租房数据系统的设计与实现
基于卷积神经网络的在线作业检测与存档管理系统的设计与实现
基于神经网络模型的文本纠错系统的设计与实现
基于深度学习的驾驶行为识别管理系统的设计与实现
基于卷积神经网络模型的垃圾分类系统的设计与实现
基于CNN的多标签新闻分类系统的设计与实现
基于卷积神将网络的识别图片数字自动打码系统设计与实现
基于BP神经网络的畜牧业养殖场管理系统的设计与实现
基于BP神经网络的人脸朝向系统的设计与实现
基于卷积神经网络的人体关键点识别系统的研究与实现
基于深度学习的相似图片识别系统的设计与实现
基于卷积神经网络的邮件管理系统的设计与实现
基于卷积神经网络模型水果识别分类的设计与实现
基于机器学习的餐饮服务管理系统的设计与实现
基于卷积神经网络算法的车牌识别停车管理系统的设计与实现
基于Bp神经网络的停车场车牌识别系统
基于内容关联的饮食推荐系统在青岛工学院的应用
基于SSM框架的校园帮系统的设计与实现
基于K-means算法的校园美食推荐系统
基于Java的疫苗预约网站的设计与实现
基于协同过滤算法的医院病人健康饮食定制系统的设计与实现
基于深度学习的图片审核系统在微博的应用
基于协同过滤的个性化书籍推荐系统的设计与实现
基于SSM框架的学生实习管理系统的设计与实现
基于DBSCAN算法的可视化数据分析平台的设计与实现
基于Web的农场租赁及农产品销售管理系统
基于卷积神经网络RL人机对弈的应用设计
基于蚁群算法的北京市旅游景点线路优化系统的研究与实现
基于Web的电子产品销售系统的设计与实现
基于SSM+LayUI的租房信息共享系统的设计与实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67602ee874270ab0ffd3792c10121550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1734486e11c3b2bcd75bc41348d80980/" rel="bookmark">
			AHB_Matrix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AHB_Matrix 文章目录 AHB_Matrix ARM的BUS Matrix的作用
AHB Bus Matrix以及AHB的局限性
ARM的BUSMatrix就是多主（Core，DMA等），多从（内部RAM，APB，外部总线等）的交联和仲裁。目的是为了提高不同主机访问不同外设情况下的带宽，另外一个就是简化BusMaster的协议设计。
比如，DMA把片内RAM的数据搬运到APB的外设，如串行口。同时Core从外部总线，SDRAM取指令。如果单一总线，那么Core和DMA控制器就需要先仲裁总线控制权，然后才能访问对应的外设，此时单一总线的带宽不一定够。如果用交联矩阵，那么Core可以直接访问SDRAM，同时DMA访问APB外设。
如果没有用到多个BUSMaster，典型如DMA，LCD控制器等都没有用到，具体看芯片，那么Matrix不会有什么性能提升；当然，如果用到了多个Slave，可能会有少量的性能损失，切换总线节点可能需要比直接仲裁更多的时间；（仲裁完成-传输数据vs仲裁完成-切换/保持总线节点-传输数据）
如果只用了一个Slave，比如Core，DMA，LCD都是只访问外部总线的SDRAM，实质上就是多主单从结构，效率或许会下降。至少看ATmel的手册，切换连接节点好像需要一个MCK，单总线仲裁，不一定会需要这一个周期。
多主多从的应用才会得到较为明显的好处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8945116814d7a19b3f95b4f4f7756589/" rel="bookmark">
			React native 生成资源清单文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发中,我们时常要引用很多资源,比如图片,字符串,颜色等等，
react 这个引用方法 import和require 必须传递相对路径,不便于移动应用开发,本人实在受不了这种引用方式,而且require加载图片,不能是变量,很烦人,我给出一种映射解决办法
上面这种图片引用方式实在太痛苦,我给出一种优雅方案,动态产生资源清单文件:
第一步:在项目根目录新建一个init.js文件
第二步:在init文件中加入代码:
/** * @author youxuan E-mail:xuanyouwu@163.com * @Description * @Company Beijing dsb */ //获取项目工程里的图片 var fs = require('fs');//引用文件系统模块 //小心勿动 gennerateResource('Resource.ts'); /** * 生成清单 */ function gennerateResource(fileName) { var notice = `\n//!!!!!代码自动生成,请勿手动修改!!!!!\n`; var content = `\n/**\n* @author youxuan E-mail:xuanyouwu@163.com\n* @Description 资源清单\n*/\n`; var images = `${listImages("./react_native/imgs")}`; var strings = `export const String={\n${listStrings("./react_native/res/strings")}\n};`; var colors = `export const Color={\n${listColors("./react_native/res/colors")}\n};`; var values = `export const Value={\n${listDimen("./react_native/res/values")}\n};`; content = `${content} \n${notice}\n${images} \n${notice}\n${strings} \n${notice}\n${colors} \n${notice}\n${values}`; fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8945116814d7a19b3f95b4f4f7756589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ffd1be1980a5240f4bd2db1f2bb224/" rel="bookmark">
			C&#43;&#43;程序架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C++编译模式
通常，在一个C++程序中，只包含两类文件——.cpp文件和.h文件。其中，.cpp文件被称作C++源文件，里面放的都是C++的源代码；而.h文件则被称作C++头文件，里面放的也是C++的源代码。
C+ +语言支持“分别编译”（separate compilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的.cpp文件里。.cpp文件里的东西都是相对独立的，在编 译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。比如，在文件a.cpp中定义 了一个全局函数“void a() {}”，而在文件b.cpp中需要调用这个函数。即使这样，文件a.cpp和文件b.cpp并不需要相互知道对方的存在，而是可以分别地对它们进行编译， 编译成目标文件之后再链接，整个程序就可以运行了。
这是怎么实现的呢？从写程序的角度来讲，很简单。在文件b.cpp中，在调用 “void a()”函数之前，先声明一下这个函数“void a();”，就可以了。这是因为编译器在编译b.cpp的时候会生成一个符号表（symbol table），像“void a()”这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以 顺利地生成了。
注意这里提到了两个概念，一个是“定义”，一个是“声明”。简单地说，“定义”就是把一个符号完完整整地描述出来：它是变 量还是函数，返回什么类型，需要什么参数等等。而“声明”则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的，我这里先用着，你链接 的时候再到别的地方去找找看它到底是什么吧。定义的时候要按C++语法完整地定义一个符号（变量或者函数），而声明的时候就只需要写出这个符号的原型了。 需要注意的是，一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。试想，如果一个符号出现了两种不同的定义，编译器该听谁的？
这 种机制给C++程序员们带来了很多好处，同时也引出了一种编写程序的方法。考虑一下，如果有一个很常用的函数“void f() {}”，在整个程序中的许多.cpp文件中都会被调用，那么，我们就只需要在一个文件中定义这个函数，而在其他的文件中声明这个函数就可以了。一个函数还 好对付，声明起来也就一句话。但是，如果函数多了，比如是一大堆的数学函数，有好几百个，那怎么办？能保证每个程序员都可以完完全全地把所有函数的形式都 准确地记下来并写出来吗？
二、什么是头文件
很显然，答案是不可能。但是有一个很简单地办法，可以帮助程序员们省去记住那么多函数原型的麻烦：我们可以把那几百个函数的声明语句全都先写好，放在一个文件里，等到程序员需要它们的时候，就把这些东西全部copy进他的源代码中。
这 个方法固然可行，但还是太麻烦，而且还显得很笨拙。于是，头文件便可以发挥它的作用了。所谓的头文件，其实它的内容跟.cpp文件中的内容是一样的，都是 C++的源代码。但头文件不用被编译。我们把所有的函数声明全部放进一个头文件中，当某一个.cpp源文件需要它们时，它们就可以通过一个宏命令 “#include”包含进这个.cpp文件中，从而把它们的内容合并到.cpp文件中去。当.cpp文件被编译时，这些被包含进去的.h文件的作用便发 挥了。
举一个例子吧，假设所有的数学函数只有两个：f1和f2，那么我们把它们的定义放在math.cpp里：
/* math.cpp */
double f1()
{
//do something here....
return;
}
double f2(double a)
{
//do something here...
return a * a;
}
/* end of math.cpp */
并把“这些”函数的声明放在一个头文件math.h中：
/* math.h */
double f1();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8ffd1be1980a5240f4bd2db1f2bb224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d123d8ff40bed320ceacf0c6c58335/" rel="bookmark">
			【完整详细教程】Ubuntu22.04 双显卡 3090Ti*2 KVM虚拟机多显卡直通与Parsec高清远程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献： Ubuntu配置GPU直传kvm虚拟机 - CodeAntennaKVM虚拟机GPU直通，step by step - 机械意志 (mechanical-consciousness.com)lspci的输出简单分析 - 成蹊0xc000 - 博客园 (cnblogs.com)PCI passthrough via OVMF - Arch Linux 中文维基 (archlinuxcn.org)Win10/11 如何开启 第二屏幕/副屏/虚拟显示器，让平板成为副屏 - 知乎 (zhihu.com) 首先声明，本文的背景是在两张同型号的3090ti中选择一张进行直通，在整个直通过程中，上面的参考文献给与了我很大的帮助，本篇内容是我基于他们描述完整操作后的记录，其中不乏对原文的直接摘抄，但也结合了我个人的机器情况进行了重新梳理，并进行了多次可行性验证，因为每个人的机器情况可能都大不相同，希望我的记录能给和我相同配置的同学一些帮助。如果有不懂的命令，建议大家查一下GPT，可能理解起来会快很多。
直通步骤： 1. 确定是否支持虚拟化： 确定本机是否支持VT-P虚拟化，一般需要主板BIOS开启VT-P。如果不能进BIOS确认，也可以在终端里确认。
检查CPU是否支持虚拟化，运行如下命令：
$ egrep -c '(svm|vm)' /proc/cpuinfo
如果显示为0，则不支持虚拟化。
系统配置：Ubuntu22.04.1 LTS，GPU 3090 Ti*2，CPU i7 13700K，主板 华硕Z790-P
2. 在宿主机系统中启用iommu组： 打开/etc/default/grub，找到GRUB_CMDLINE_LINUX_DE FAULT，修改为下面内容：
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash intel_iommu=on"
接着我们需要更新grub：
$ sudo update-grub -u
然后重启电脑，重启完后我们需要检查iommu有没有被正确启用：
$ dmesg | grep -i iommu
如果你在输出中看到很多pci xxxx:xx:xx.x: Adding to iommu group xx，那么恭喜你，第一步完成了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63d123d8ff40bed320ceacf0c6c58335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6711de3dedac1e92e53456ac2c9d788d/" rel="bookmark">
			阿里云2核4G服务器5M带宽五年租用价格表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云2核4G服务器5M带宽可以选择轻量应用服务器或云服务器ECS，轻量2核4G4M带宽服务器297元一年，2核4G云服务器ECS可以选择计算型c7、c6或通用算力型u1实例等，买5年可以享受3折优惠，阿腾云分享阿里云服务器2核4G5M带宽五年费用表：
目录
阿里云2核4G服务器5M带宽收费
阿里云轻量应用服务器2核4G费用表
阿里云ECS服务器2核4G配置表
阿里云2核4G服务器5M带宽收费 阿里云2核4G服务器可以选择轻量应用服务器或者ECS云服务器，云服务器ECS是专业级云服务器，大多数使用场景均可以胜任，尤其是集群类、高容灾应用，建议选择云服务器ECS；如果是只需要一台云服务器的单机应用，也可以选择轻量应用服务器，轻量应用服务器成本更低，关于ECS服务器和轻量服务器的详细区别请参考：阿里云轻量应用服务器和ECS云服务器区别对比
本文阿腾云来详细说下阿里云2核4G服务器5M公网带宽五年费用：
阿里云轻量应用服务器2核4G费用表 在阿里云官方活动上：atengyun.com/go/aliyun 有一款2核4G配置的轻量应用服务器，4M带宽，优惠价一年297.98元，如下图：
阿里云2核4G服务器
只是在活动上，只能一次性买一年，原价是960元一年，首年购买可以享受3.1折优惠折扣，另外公网带宽是4M，并不是5M，如果是搭建网站应用，网站视频、图片媒体文件存放到对象存储OSS上，网站接入CDN，4M带宽也是差不多的，轻量应用服务器的好处是，第一年购买成本足够低。
阿里云ECS服务器2核4G配置表 阿里云2核4G云服务器可以选择通用算力型u1、计算型c7、共享标准型s6、AMD计算型c8a、高主频计算型hfc8i等，如下图：
阿里云2核4G服务器
阿腾云建议选择通用算力型u1或计算型c7，因为这两款云服务器ECS规格降价了，云服务器u1年付直降40%，计算型c7云服务器年费直降28%，阿腾云给大家来算一下费用：
ECS通用算力型u1服务器：2核4G配置、5M带宽、40G ESSD系统盘，五年折后价格是：10672.34元；ECS计算型c7服务器：2核4G配置、5M带宽、40G ESSD系统盘，五年折后价格是：10732.350元；可以在阿里云CLUB中心：aliyun.club 领取专属代金券。 阿腾云来给大家详细整理了云服务器u1和云服务器c7这两款2核4G5M带宽服务器配置报价表：
云服务器ECS规格2核4G费用40GB ESSD系统盘费用5M公网带宽五年总费用（折后费用）ECS通用算力型u1原价10108.8元，五年3.8折，优惠后是3841.3元5年原价1200元，五年5折，优惠后600元5年原价7500元，带宽8.5折，折后6375元10672.34元五年ECS计算型c7原价11741.73元，五年3.2折，优惠后是3757.35元5年原价1200元，五年5折，优惠后600元5年原价7500元，带宽8.5折，折后6375元10732.35元五年 如上表所示，一次性购买5年，云服务器c7可以享受3.2折优惠、云服务器u1是3.8折优惠，云服务器c7是企业级独享型云服务器，CPU采用第三代Intel Xeon可扩展处理器（Ice Lake）Platinum 8369B，基频2.7 GHz，全核睿频3.5 GHz，阿腾云建议选择阿里云服务器ECS计算型c7实例，2核4G配置、5M的带宽，一年优惠价1万元左右。
综上，阿里云2核4G服务器5M带宽五年多少钱？如果是中下企业或个人开发者使用，可以选择轻量应用服务器，2核4G4M带宽一年297元；如果是企业级应用，建议选择云服务器计算型c7实例，2核4G5M带宽五年优惠价1万元左右。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9971c916ab9ca6f3ca6d49aafae046c0/" rel="bookmark">
			正确介绍自己的项目经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、前期分析
1.知己知彼百战不殆
2.熟能生巧，对答自如
3.明确目标，控盘引导
二、面试技巧
三、项目准备
四、面试题场景
五、注意事项
总结
前言 在面试时，经过简单寒暄后，面试官一般先从让候选人自我介绍开始，紧接着就是问候选人简历中所列的项目，让介绍下项目经验。
常见的问法是，说下你最近的（或感觉不错的）一个项目。面试中很多人忽视对这一个环节的准备，不仅回答不了面试官的追问，甚至连自己的项目都讲不清楚，说起来磕磕巴巴，甚至有的人说出的项目经验从时间段或技术等方面和简历上的不匹配，这样无疑会让面试官对面试者的能力产生怀疑。
面试时7分靠能力，3分靠技能。本文将从 “前期准备” 和 “面试技巧” 两大层面告诉大家如何准备面试时的项目介绍，当然，这只是一家之言，没有最好的方式，只要更适合的方法，仁者见仁，智者见智。
一、前期分析 1.知己知彼百战不殆 如果想打动面试官，那么你就必须得了解他到底想要从你口中了解到什么，哪些信息是他所想要的。
在面试前准备项目描述时，别害怕，因为面试官什么都不知道，最了解项目的还是你自己。
面试官是人，不是神，拿到你的简历的时候，只能根据你所描述的项目去推测你的工作经历，是没法核实你的项目细节的（一般公司回到录用后，通过背景调查的方式来核实）。
更何况，你做的项目是以月或以年为单位计算的，而面试官最多用30分钟来从你的简历上了解你的项目经验，所以你对项目的熟悉程度远远超过面试官，所以你一点也不用紧张，而面试官想了解更多，他想知道你的工作方式及项目中所负责的内容、所用到的技术栈，就不得不从你的介绍中去深挖技术点，以期了解你对项目及技术的了解的深度。
首先从气势上就要告诉面试官，这项目就是你参与的，有你所负责的功能模块，让面试官不容置疑。
心态上准备好了，那么就要分析面试官想要考察什么呢？
表达能力。考察表达及逻辑思维能力，看面试者能不能再几分钟跟一个完全没有参与过项目的人讲清楚这个项目。实际工作经验。你在项目中承担了什么角色，做了什么工作。这些工作中的技术含量及跟同事合作情况如何。另外可能会针对某个项目，不断深入问一些技术上的问题，或者从侧面问技术类显示，这是为了深入核实你做项目的细节及对技术的理解运用。解决问题能力。一般会问项目难点，其实就是想知道当你遇到技术活业务难点，是如何思考并解决问题的。项目复盘及经验总结能力。哪里是自己觉得做的成功的，哪里觉得没做好的，是否还有继续优化的空间。自己所做的项目对个人能力有哪些提升。 2.熟能生巧，对答自如 首先是需要有个充足的准备，写项目经验一定要写自己熟悉的，因为面试官就会根据你写的项目经验提问。在面试前，就要在脑子里过一遍这个项目，准备好说辞，面试的时候自信点，讲清楚这个项目是满足什么需求的，开发过程中遇到哪些困难，自己怎么解决这些困难的。如果你经过充分准备，面试中也能答的很好，那面试官好感度就会增加，相反，如果面试中说的磕磕绊绊，那么可信度就会低了。
3.明确目标，控盘引导 在面试前，你需要明确自己的面试目的，就是通过面试，争取拿到Offer。
最保守的方式就是在自己介绍项目的时候，以面试官为主导，回答很简单，就是面试官问你一句你答一句。这回让面试官失去想了解你的信息，其次也会让自己错失表现自己，凸显重点思想的机会。做好防守虽然也是一种取胜的方式，但并非上策，很容易丢分。
讲自己简历中所列的项目一定要很清晰明了有逻辑，埋下后续可能会提问到的技术点，也给面试官留下一个好印象。如果项目经验介绍的号，有逻辑和阴道力，那么就会给自己带来以下两点明显的好处：
给面试官带来的第一印象好，会让面试官感觉该候选人表诉能力较强。一般来说，面试官会根据候选人介绍的项目背景来提问题，假设面试时会问10个问题，那么至少有5个问题会根据候选人所介绍的项目背景来问，候选人如果说的好，那么就可以很好的引导面试官去问后继问题，这就相当于把提问权完全交由自己控制了。 如果你的工作经验比面试官还丰富的话，甚至还可以控制整个面试流程，甚至遇到 Nice 的面试官的话会以讨论的方式进行沟通。
应聘者面试官对项目及技能了解程度很了解只能听你说，只能根据你说的内容做出判断面试过程中的职责很短的时间内防守成功即可如果不能全面了解，找不到你薄弱的地方就代表你做过准备时间面试前你有充足的时间准备一般在面试前用30分钟阅读你的简历沟通过程你可以出错，但别出关键性的错误不会太为难你，除非你太差技巧表达要有逻辑性，引导面试官提问，也可以从网上找，其实就问些通用的有规律的问题足够多的面试题 既然面试官无法了解你的底细，那么他们怎么来验证你的项目经验和技术？下面总结了一些常用的提问方式。
提问方式目的让你描述工作经验和项目（极有可能是最近的），说的是否和简历上一致看看你是否真的做过这些项目看你简历上项目里用到的技术，比如框架，数据库，然后针对这些技术提些基本问题还是验证你是否做过这些项目，同时看你是否了解这些技术，为进一步提问做准备针对某个项目，不断深入地问一些技术上的问题，或者从不同侧面问一些技术实现，看你前后回答里是否有矛盾深入核实你的项目细节针对某技术，问些项目里一定会遇到的问题，比如候选人说做过数据库，那么就会问索引方面的问题通过这类问题，核实候选人是否真的有过项目经验（或者还仅仅是学习经验） 二、面试技巧 内容上要对项目进行以下拆分，思考并进行总结，并试着口语化讲出来。
项目描述。用通俗易懂且简洁的方式简述项目，阐述整个项目及其背景、规模，不要有太多技术词汇。项目模块。2-3分钟的流程介绍，详细的列出项目实现的功能，各个模块，整个过程，大概思路。项目技术栈。说出项目实现的技术栈和架构，能够说出项目的不寻常之处，比如采用了某项新技术，采用了某个框架等，简要说明技术选型。候选人的角色及责任。说出你在项目中的责任，所涉及的功能模块、运用技术、碰到的难题、代码细节、技术点、应对措施。项目总结，待优化点。 方法上可以使用万能的STAR原则
Situation（背景）：做这个项目的背景是什么，比如这是个人项目还是团队项目，为什么需要做这个项目，你的角色是什么，等等。
Target（目标）：该项目要达成的目标是什么？为了完成这个目标有哪些困难？
Action（行动）：针对所要完成目标，你做了哪些工作？克服了其中一些困难？
Result（结果）：项目最终结果如何，有哪些成就？有哪些不足之处可以改进？
除了项目所取得的成绩之外，候选人还可以说明自己做完项目的感受，包括项目中哪些环节做的不错，哪些环节有提高的空间，自己在做这个项目中有何收获等。
无论是介绍自己的IT产品开发经历，还是在其他公司的实习项目经历，候选人都可以运用STAR法则来具体说明，轻松表现出自己分析阐述问题的清晰性、条理性和逻辑性。
但面试前如下的一些情况还是需要多加注意的。
回答很简单。问什么答什么，往往就一句话回答。如果你日常回答别人的问题或者之前面试中出现过类似情况就要有所改善了。这里应该将你知道的说出来，重点突出跟问题相关的思想、框架和技术等。扯闲篇，大忌。说少了太过于简短没有互动不好，自来熟，回答没有重点，没有逻辑，乱说一通也是大忌。会让面试官感觉你思路混乱，抓不到重点，只是拿其他方面的东西东拼西凑。说的太过流利。未必是件好事，虽然面试有所准备在面试官看来是好事，但是机械的准备好答案去背诵，主观上给人一种你并没有理解这个问题，只是靠记忆知道答案，后续面试官的问题也会相应的加大难度。这方面改善建议是适当停顿，做思考状，边思考边说，过程中同面试官有个眼神上的互动。有的放矢的介绍技术细节。不要一次性过多的介绍技术细节，技术面点到为止，等面试官来问。因为面试官通常都有自己的面试节奏，所以技术点等着问的时候再多聊，可以事先埋下技术点引导着面试官来继续追问。主动介绍项目亮点。因为面试官没有义务挖掘你的亮点，所以这就需要自己主动提。遇到不会的问题，就如实说这个技术点不会，或者半懂也可以直接说。甚至可以谈谈自己的见解，把自己了解的说说。 三、项目准备 一般来说，在面试前，大家应当准备项目描述的说辞，自信些，因为这部分你说了算，流利些，因为你经过充分准备后，可以知道你要说些什么。而且这些是你实际的项目经验（不是学习经验，也不是培训经验），那么一旦让面试官感觉你都说不上来，那么可信度就很低了。
不少人是拘泥于 “项目里做了什么业务，以及代码实现的细节”，这就相当于把后继提问权直接交给面试官。下表列出了一些不好的回答方式。
回答方式后果我在xx软件公司做了xx门户网站项目，这个项目做到了xx功能，具体是xx和xx模块，各模块做了xx功能，客户是xx，最后这个项目挣了xx钱直接打断，因为业务需求我不需要了解，我会直接问他项目里的技术（需要招聘一个前端开发，会React）最近一个项目我是用JQuery实现的，实现了...或者我最近做的不是开发，而是测试...或者我最近的项目没有用到React提问：你最近用到React技术的项目是什么时候，然后在评语上写：最近xx时间没接触过React在毕业设计的时候（或者在读书的时候，在学习的时候，在xx培训学校，在xx实训课程中）直接打断，提问你这个是否是商业项目，如果不是，你有没有其他的商业经验。如果没商业项目经验，除非是校招，否则就直接结束面试描述项目时，一些关键要素（比如公司、时间、所用技术等）和简历上的不匹配我们会深究这个不一致的情况，如果是简历造假，那么可能直接中断面试，如果真的是笔误，那么就需要提供合理的解释 在避免上述不好的回答的同时，大家可以按下表所给出的要素准备项目介绍。如果可以，也请大家准备一下用英语描述。
要素样式控制在1分钟里面，讲出项目基本情况，比如项目名称，背景，给哪个客户做，完成了基本的事情，做了多久，项目规模多大，用到哪些技术，数据库用什么，然后酌情简单说一下模块。重点突出背景、技术、数据库和其他和技术有关的信息。我在xx公司做了xx外汇保证金交易平台，客户是xx银行，主要完成了挂盘，实盘成交，保证金杠杆成交等功能，数据据是Oracle，前台用到JS等技术，后台用到Java的SSH，几个人做了x个月。不需要详细描述各功能模块，不需要说太多和业务有关但和技术无关的。如果面试官感兴趣，等他问。要主动说出你做了哪些事情，这部分的描述一定需要和你的技术背景一致。我做了外汇实盘交易系统，挂单成交系统，xxx模块，做了x个月描述你在项目里的角色我主要做了开发，但在开发前，我在项目经理的带领下参与了业务调研，数据库设计等工作，后期我参与了测试和部署工作。可以描述用到的技术细节，特别是你用的技术细节，这部分尤其要注意，你说出口的，你一定要知道，因为面试官后面就根据这个问的。如果你做了5个模块，宁可只说你能熟练说上口的2个。用到了Java里面的集合，JDBC...等技术，用到了Spring MVC等框架，用技术连接数据库。这部分你风险自己承担，如果可以，不露声色说出一些热门的要素，比如Linux，大数据，大访问压力等。但一旦你说了，面试官就会直接问细节。这个系统里，部署在Linux上，每天要处理的数据量是xx，要求是在4小时，1G内存的情况下处理完成5千万数据。平均访客是每分钟xxx。 不露痕迹地说出面试官爱听的话 在项目介绍的时候（当然包括后继的面试），面试官其实很想要听一些关键点，只要你说出来，而且回答相关问题比较好，这绝对是加分项。我在面试别人的时候，一旦这些关键点得到确认，我是绝对会在评语上加上一笔的。
下面列出面试官爱听的关键点和对应的说辞：
关键点说辞能考虑到代码的扩展性，有参与框架设计的意识我的项目xx保险项目，用到SSH技术，数据库是Oracle（这个是铺垫），开发的时候，我会先和项目经理一起设计框架，并参与了框架的构建，连接数据库的时候，我们用到了DAO，这样做的理由是，把SQL语句封装到DAO层，一旦要扩展功能模块，就可以不用做太多的改动有调优意识，能通过监控发现问题点，然后解决在开发阶段，我就注意都内存的性能问题和SQL运行的时间问题，在压力测试阶段，我会通过xx工具来监控内存和数据库，发现待提升的代码点，然后通过查资料来优化。最后等项目上线后，我们会部署监控系统，一旦发现内存和数据库问题，我们会第一时间解决。动手能力很强，肯干活，会的东西比较多，团队合作精神比较好 在项目里，我不仅要做开发的工作，而且需要自己测试，需要自己根据一些日志的输出到数据库或Java端去debug，当我开发好一个模块时，需要自己部署到Linux上测试。
或者，一旦遇到问题，如果是业务方面，我会及时和项目经理沟通，如果是技术方面的，我会自己查资料，如果是测试方面的，我会及时和测试的人沟通。
责任心比较强，能适应大压力的环境 被问 “你如果在项目里遇到问题怎么办？”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9971c916ab9ca6f3ca6d49aafae046c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a556d7c3f7bf17302b64ace337e4ad90/" rel="bookmark">
			数据结构与算法基础-学习-25-图之MST（最小代价生成树）之Prim（普利姆）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、生成树概念
二、生成树特点
三、最小代价生成树（MST）
四、MST实际中的应用
五、Prim（普利姆）
1、宏定义
2、结构体定义
3、函数定义
（1）InitShortestEdgeArray
（2）UpdateShortestEdgeArray
（3）DestroyShortestEdgeArray
（4）PrimMST
（5）InitMST
（6）DestroyMST
（7）PushMST
4、实现思路
六、Linux环境代码测试
一、生成树概念 1、所有顶点均由边连接在一起，但不存在回路的图。
2、一个图可以有许多棵不同的生成树。
二、生成树特点 1、生成树的顶点个数与图的顶点个数相同。
2、生成树是图的极小连通子图，去掉一条边则非连通。
3、一个有n个顶点的连通图的生成树有n-1条边。
4、在生成树中再加一条边必然形成回路。
5、生成树中任意两个顶点间的路径是唯一的。
三、最小代价生成树（MST） 给定一个无向网，在该网的所有生成树中，使得各边权值之和最小的那颗生成树称为该网的最小生成树，也叫最小代价生成树。
四、MST实际中的应用 城市中需要铺设线路，怎么样铺设，使得成本低且覆盖所有城市。
五、Prim（普利姆） 1、宏定义 #define PARENT_INIT_VALUE -1 #define LOWEST_WEIGHT_VALUE 0 #define LOWEST_EDGE_VERTEX_INIT_INDEX -1 2、结构体定义 //最小生成树 typedef struct MinimumSpanningTree { VertexIndexType StartIndex;//起始顶点 VertexIndexType EndIndex; //结束顶点 WeightType Weight; //起始顶点到结束顶点边上的权值 }MinimumSpanningTree; typedef struct MstType { MinimumSpanningTree* MstArray; WeightType ArrayLen; WeightType ArrayMaxLen; }MstType; //Prim //普利姆算法适用于稠密图，所以我们这边用邻接矩阵实现。 typedef struct ShortestEdgeType { VertexIndexType VertexIndex; WeightType LowestWeight; }ShortestEdgeType; typedef struct ShortestEdgeArray { ShortestEdgeType* Array; VertexIndexType ArrayLen; VertexIndexType ArrayMaxLen; }ShortestEdgeArray; 3、函数定义 （1）InitShortestEdgeArray VertexIndexType InitShortestEdgeArray(ShortestEdgeArray** SEA, AMGraph* AMG, VertexIndexType StartVertexIndex) { JudgeAllNullPointer(SEA); JudgeAllNullPointer(AMG); *SEA = (ShortestEdgeArray*)MyMalloc(sizeof(ShortestEdgeArray)); (*SEA)-&gt;Array = (ShortestEdgeType*)MyMalloc(sizeof(ShortestEdgeType) * (AMG-&gt;CurVertexNum)); (*SEA)-&gt;ArrayLen = 1; (*SEA)-&gt;ArrayMaxLen = AMG-&gt;CurVertexNum; VertexIndexType LowestEdgeVertexIndex = StartVertexIndex; VertexIndexType i; for(i = 0; i &lt; AMG-&gt;CurVertexNum; i++) { (*SEA)-&gt;Array[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a556d7c3f7bf17302b64ace337e4ad90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5da0282ed5f0b813bb66202b703667/" rel="bookmark">
			Kubernetes单主集群的部署（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、k8s单主架构集群的部署 1.操作系统初始化配置
2.部署 etcd 集群 3.部署docker引擎
4.部署 Master 组件
5.部署 Worker Node 组件
6.部署 CNI 网络组件（使用 flannel）
一、k8s单主架构集群的部署 k8s集群master01：192.168.116.10
k8s集群master02：192.168.116.20（第二部分高可用架构会加入）
k8s集群node01：192.168.116.30
k8s集群node02：192.168.116.40
etcd集群节点1：192.168.116.10（etcd集群原则上单独部署，此实验为方便部署在节点上）
etcd集群节点2：192.168.116.30
etcd集群节点3：192.168.116.40
负载均衡nginx+keepalive01（master）：192.168.116.50
负载均衡nginx+keepalive02（backup）：192.168.116.60
1.操作系统初始化配置 #关闭防火墙 systemctl disable --now firewalld iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X #关闭selinux setenforce 0 sed -i 's/enforcing/disabled/' /etc/selinux/config #关闭swap swapoff -a sed -ri 's/.*swap.*/#&amp;/' /etc/fstab #根据规划设置主机名 hostnamectl set-hostname master01 hostnamectl set-hostname node01 hostnamectl set-hostname node02 su #添加主机名映射 vim /etc/hosts #添加 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e5da0282ed5f0b813bb66202b703667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f5e06436647dae963674da018eb23a6/" rel="bookmark">
			windows查看端口占用，通过端口找进程号（查找进程号），通过进程号定位应用名（查找应用）（netstat、tasklist）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 通过端口号查看进程号`netstat`通过进程号定位应用程序`tasklist` 通过端口号查看进程号netstat 在Windows系统中，可以使用 netstat 命令来查看端口的占用情况。以下是具体的步骤：
打开命令提示符（CMD）：按Win+R组合键打开运行对话框，输入cmd并按Enter键。
在命令提示符中输入以下命令，并按Enter键：
netstat -ano 这个命令会列出所有活动的TCP连接以及监听的UDP端口，并显示相关进程的PID（进程ID）。
如果你想查找特定的端口（例如123），可以使用以下命令：
netstat -ano | findstr "123" 以上命令会查找并显示所有使用了123端口的进程。
通过进程号定位应用程序tasklist 如果你已经知道某个端口被占用，但你需要找出是哪个进程占用的，你可以记下上述命令返回结果中的PID，然后使用以下命令查找该PID对应的进程：
tasklist | findstr "PID" 其中，"PID"需要替换为你实际记录下的进程ID号。
也可以通过windows任务管理器进程号定位应用程序：
ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f5e06436647dae963674da018eb23a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e40875fd4b5a20dd57733734e54c14c/" rel="bookmark">
			解决：sh: vite: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述原因分析解决方案 问题描述 第一次pull项目，运行npm run dev时报错：sh: vite: command not found
原因分析 查看了package.json，发现是有vite的。
没有安装依赖导致的；
解决方案 执行npm i重新安装依赖，之后再执行npm run build，再执行 npm run dev 可以正常运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa998983b1cfa1ce89c59c46f4a3eeca/" rel="bookmark">
			nginx使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、nginx使用详解2.1、nginx特点2.2 静态文件处理2.3 反向代理2.4 负载均衡2.5 高级用法2.5.1 正则表达式匹配2.5.2 重定向 三、总结 一、前言 本文将详细介绍nginx的各个功能使用，主要包括
二、nginx使用详解 2.1、nginx特点 高性能：Nginx被设计成具有出色的性能。它采用事件驱动的异步架构，能够处理大量并发连接，高效地分发请求和响应。这使得Nginx非常适合用作反向代理、负载均衡器和Web服务器。
轻量级：Nginx的内存占用非常低，资源消耗较小。这使得它能够在资源有限的环境中运行，如嵌入式设备和虚拟私有服务器（VPS）。
高可用性：Nginx支持热部署和无缝升级，可以确保服务的高可用性。它还提供了健康检查和故障转移功能，以防止单点故障。
反向代理和负载均衡：Nginx可以作为反向代理服务器，将客户端请求分发给多个后端服务器，实现负载均衡。这有助于提高应用程序的可伸缩性和性能。
静态文件服务：Nginx能够高效地提供静态文件，如HTML、CSS、JavaScript和图像。它还支持文件缓存和浏览器缓存控制，以减少带宽消耗和提高网站速度。
2.2 静态文件处理 Nginx非常适合处理静态文件，如HTML、CSS、JavaScript、图像等。静态文件处理是通过配置Nginx来指定Web服务器从文件系统中提供这些文件。
配置示例：
server { listen 80; server_name example.com; location /static/ { alias /path/to/static/files/; } location / { # 其他配置，例如反向代理或动态内容处理 } } location /static/指定了一个URL路径，如/static/，Nginx将会从/path/to/static/files/目录中提供静态文件。alias指令用于指定文件存储路径。 2.3 反向代理 说到反向代理就要先说正向代理：
正向代理最大的特点是：客户端非常明确要访问的服务器地址，服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端，正向代理模式屏蔽或者隐藏了真实客户端信息。
例如：在大陆访问www.google.com，我们需要一个代理服务器，我们通过代理服务器去访问谷歌，这个过程就是正向代理。下面是一个正向代理的图示：
反向代理，客户端堆代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器。
由于反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。
Nginx可以用作反向代理服务器，将客户端请求转发到后端服务器，并将后端服务器的响应返回给客户端。这对于隐藏后端服务器、负载均衡、加速应用程序等非常有用。
配置示例：
server { listen 80; server_name example.com; location / { proxy_pass http://backend_server; } } upstream backend_server { server backend1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa998983b1cfa1ce89c59c46f4a3eeca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9740569149f7ce637e7101314cceb9/" rel="bookmark">
			微服务-kubernetes安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、kubernetes2.1、Kubernetes (K8S) 是什么2.1.1、主要特性：2.2.2、传统部署方式：2.2.3、虚拟机部署2.2.4容器部署2.2.5什么时候需要 Kubernetes2.2.6、Kubernetes 集群架构 三、kubernetes安装3.1、主节点需要组件3.1.1、设置对应主机名3.1.2、修改 hosts3.1.3、所有节点关闭 SELinux3.1.4、所有节点确保防火墙关闭 3.2、添加k8s安装源3.3、安装k8s需要的组件3.4、启动 kubelet、docker，并设置开机启动（所有节点）3.5、修改 docker 配置（所有节点）3.6、用 kubeadm 初始化集群（仅在主节点跑）3.7、安装网络插件，否则 node 是 NotReady 状态（主节点跑）3.8、把工作节点加入集群（只在工作节点跑） 一、前言 本文将详细介绍kubernetes安装流程。
二、kubernetes 2.1、Kubernetes (K8S) 是什么 它是一个为 容器化 应用提供集群部署和管理的开源工具，由 Google 开发。
Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目
2.1.1、主要特性： 高可用，不宕机，自动灾难恢复
灰度更新，不影响业务正常运转
一键回滚到历史版本
方便的伸缩扩展（应用伸缩，机器加减）、提供负载均衡
有一个完善的生态
2.2.2、传统部署方式： 应用直接在物理机上部署，机器资源分配不好控制，出现Bug时，可能机器的大部分资源被某个应用占用，导致其他应用无法正常运行，无法做到应用隔离。
2.2.3、虚拟机部署 在单个物理机上运行多个虚拟机，每个虚拟机都是完整独立的系统，性能损耗大。
2.2.4容器部署 所有容器共享主机的系统，轻量级的虚拟机，性能损耗小，资源隔离，CPU和内存可按需分配
2.2.5什么时候需要 Kubernetes 当你的应用只是跑在一台机器，直接一个 docker + docker-compose 就够了，方便轻松；
当你的应用需要跑在 3，4 台机器上，你依旧可以每台机器单独配置运行环境 + 负载均衡器；
当你应用访问数不断增加，机器逐渐增加到十几台、上百台、上千台时，每次加机器、软件更新、版本回滚，都会变得非常麻烦、痛不欲生，再也不能好好的摸鱼了，人生浪费在那些没技术含量的重复性工作上。
这时候，Kubernetes 就可以一展身手了，让你轻松管理百万千万台机器的集群。“谈笑间，樯橹灰飞烟灭”，享受着一手掌控所有，年薪百万指日可待。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc9740569149f7ce637e7101314cceb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e2243e09d05eff5f11571d2e5a7e4f/" rel="bookmark">
			Android蓝牙bt/ble开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：经典蓝牙开发 1.1：经典蓝牙简介 Android 平台包含蓝牙网络堆栈支持，凭借此支持，设备能以无线方式与其他蓝牙设备交换数据。应用框架提供了通过 Android Bluetooth API 访问蓝牙功能的途径。使用 Bluetooth API Android 应用可以执行下面的操作：
扫描其他蓝牙设备查询本地蓝牙适配器的配对蓝牙设备建立 RFCOMM 通道通过服务发现连接到其他设备与其他设备进行双向数据传输管理多个连接 传统蓝牙适用于电池使用强度较大的操作，例如 Android 设备之间的流传输和通信等。针对具有低功耗要求的蓝牙设备，Android 4.3（API 18）中引入了面向低功耗蓝牙的 API 支持。
1.2：基础知识 使用 Android Bluetooth API 来完成使用蓝牙进行通信的四项主要任务：
设置蓝牙、查找局部区域内的配对设备或可用设备、连接设备、以及在设备之间传输数据。
关于蓝牙的 API 在 android.bluetooth 包中，下面介绍一下和蓝牙相关的主要类
BluetoothAdapter
本地蓝牙适配器，是所有蓝牙交互的入口点，表示蓝牙设备自身的一个蓝牙设备适配器，整个系统只有一个蓝牙适配器。通过它可以发现其他蓝牙设备，查询绑定（配对）设备的列表，使用已知的 Mac 地址实例化 BluetoothDevice 以及创建 BluetoothServerSocket 用来侦听来自其他设备的通信。
BluetoothDevice
表示远程的蓝牙设备。利用它可以通过 BluetoothSocket 请求与某个远程设备建立连接，或查询有关该设备的信息，例如设备的名称、地址、类和绑定状态等。
BluetoothSocket
表示蓝牙套接字接口（与 TCP Socket 相似）。这是允许应用通过 InputStream 和 OutputStream 与其他蓝牙设备交换数据的节点。正是利用这个对象来完成蓝牙设备间的数据交换，
BluetoothServerSocket
表示用于侦听传入请求的开发服务器套接字（类似于 TCP ServerSocket）要连接两台 Android 设备，其中一台设备必须使用此类开发的一个服务器套接字。当一台远程蓝牙设备向此设备发出连接请求时，BluetoothServerSocket 将会在接受连接后返回已连接的 BluethoothSocket。
BluetoothClass
描述蓝牙设备的一般特性和功能。这是一组只读属性，用于定义设备的主要和次要设备类及其服务。不过，它不能可靠地描述设备支持的所有蓝牙配置文件和服务，而是适合作为设备类型提示。
BluetoothProfile
表示蓝牙配置文件的接口。蓝牙配置文件是适用于设备间蓝牙通信的无线接口规范。免提配置文件便是一个示例。如需了解关于配置文件的详细讨论，参考下面配置文件的讲解
BluetoothHeadset
提供蓝牙耳机支持，以便与手机配合使用。其中包括蓝牙耳机和免提（1.5版）配置文件。BluetoothProfile 的实现类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34e2243e09d05eff5f11571d2e5a7e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2de65cc84f86ac93cd2e165ed3f7b1a/" rel="bookmark">
			关于CSS及JS的使用技巧浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用CSS预处理器：例如Sass和Less，可以帮助开发者更快速、更有效地编写CSS代码。
模块化：将CSS和JS代码分解为模块，可以帮助开发者更好地组织和管理代码。
压缩和合并：使用压缩工具可以帮助减少CSS和JS文件的大小，使网站更容易加载并提高性能。
使用浏览器开发工具调试：浏览器开发工具提供了调试CSS和JS代码的功能，可以帮助开发者更轻松地识别和解决问题。
使用框架和库：例如Bootstrap和jQuery，可以帮助开发者更快速和有效地创建网站和应用程序。
学习CSS布局技术：例如Flexbox和Grid，可以帮助开发者更轻松地设计和排列页面元素。
熟悉CSS动画和过渡：使用CSS动画和过渡可以让网站更加吸引人，并改善用户体验。
按需加载：将JavaScript代码分割为小的，具有特定功能的文件，可以帮助提高页面加载速度。
确保跨浏览器兼容性：为了确保网站在不同的浏览器中正常工作，需要测试和调整CSS和JS代码。
及时更新：定期升级框架和库，以确保网站保持最新的功能和性能。
转自：微点阅读 https://www.weidianyuedu.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce1d20015d1baed0e9853e89bb7c358/" rel="bookmark">
			基本排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法 排序算法插入排序快速排序归并排序堆排序冒泡排序 排序算法 排序算法是计算机科学中的重要概念，用于将一组数据按照特定规则进行排序。下面是对一些常见排序算法的简要总结：
冒泡排序（Bubble Sort）：比较相邻元素并交换，每次循环将最大（或最小）的元素冒泡到最后（或最前）。时间复杂度为O(n^2)。
选择排序（Selection Sort）：在未排序部分找到最小（或最大）的元素，然后放置到已排序部分的末尾。时间复杂度为O(n^2)。
插入排序（Insertion Sort）：将未排序元素逐个插入到已排序部分的正确位置。时间复杂度为O(n^2)，但对于近乎有序的数据效果较好。
快速排序（Quick Sort）：选择一个基准元素，将小于基准的元素放在左边，大于基准的元素放在右边，然后对左右子数组分别递归应用快速排序。平均时间复杂度为O(nlogn)，最坏情况下为O(n^2)。
归并排序（Merge Sort）：将数组递归地分成两个子数组，分别进行排序，然后将排好序的子数组合并成一个有序数组。时间复杂度为O(nlogn)，但需要额外的空间来存储临时数组。
堆排序（Heap Sort）：将待排序数组构建为最大堆（或最小堆），然后将堆顶元素与最后一个元素交换，重复这个过程直到整个数组有序。时间复杂度为O(nlogn)，具有原地排序的特点。
希尔排序（Shell Sort）：通过将数组分成多个子序列进行插入排序，逐渐缩小子序列的间隔，最终完成排序。时间复杂度取决于间隔序列的选择。
计数排序（Counting Sort）：对于具有确定范围的整数，统计每个元素的出现次数，然后根据计数信息将元素放回原数组中。时间复杂度为O(n+k)，其中k是元素的范围。
这些是常见的排序算法，每个算法都有自己的特点和适用场景。选择适当的排序算法取决于数据规模、数据特征以及对性能和空间要求的考虑。
插入排序 插入排序的基本思想是：将数组分为已排序部分和未排序部分。初始时，已排序部分只包含第一个元素，然后逐步将未排序部分的元素插入到已排序部分的正确位置，直到所有元素都被插入并排序完成。
void InsertSort(vector&lt;int&gt; &amp;vec, int num) { for(int i = 1; i &lt; num; i++) { int key = vec[i];	// key为需要移动的元素，key就是插入的元素 for(int j = i; vec[j-1] &gt; key &amp;&amp; j&gt;0; j--) { vec[j] = vec[j-1]; } vec[j] = key; } } 快速排序 ​ 快速排序的核心在于挑选一个组元进行排序。
int patition(vector&lt;int&gt; &amp;vec, int start, int end) { int i = start + 1, j = end; int index = (rand() % (end - start + 1)) + start;	// 随机挑选一个组元 int pivot = vec[index]; swap(a[start], a[index]); while(true) { while(vec[i] &lt;= pivot &amp;&amp; i &lt;= end) { i++; } while(vec[j] &gt;= pivot &amp;&amp; j &gt; i) { j--; } if(i &lt; j) { break; } swap(vec[i],vec[j]); i++; j--; } swap(vec[i], vec[j]); return j; } void QuickSort(vector&lt;int&gt; &amp;vec, int start, int end) { if(start == end) { return; } int index = patition(vec, start, end); QuickSort(vec, start, index-1); QuickSort(vec, index+1, end); } 归并排序 归并排序。先将数组分小再排序合并，子数组都是有序的，先递归再归并。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ce1d20015d1baed0e9853e89bb7c358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff68ff28149a8ee42384ae9f73019438/" rel="bookmark">
			PY_SSIZE_T_CLEAN macro的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PY_SSIZE_T_CLEAN macro的作用 Extending Python with C or C++中介紹了Python的C extension的寫法，它給出的範例前兩行如下：
#define PY_SSIZE_T_CLEAN #include &lt;Python.h&gt; 其中#define PY_SSIZE_T_CLEAN的作用為何?簡單來說是讓用於解析extensions functions/methods參數的PyArg_ParseTuple函數把s#的長度參數當成Py_ssize_t而非int型別。
參考Parsing arguments and building values - Strings and buffers，PyArg_ParseTuple的s#有兩個參數：
s# (str, read-only bytes-like object) [const char *, Py_ssize_t] 分別代表字串本身及其長度，其中長度的型別必須是Py_ssize_t。
根據以下說明：
Note For all # variants of formats (s#, y#, etc.), the macro PY_SSIZE_T_CLEAN must be defined before including Python.h. On Python 3.9 and older, the type of the length argument is Py_ssize_t if the PY_SSIZE_T_CLEAN macro is defined, or int otherwise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff68ff28149a8ee42384ae9f73019438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d3af6df5cddb1c17aac25bf6b0947c/" rel="bookmark">
			防止某个分支被合并提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过git hook 防止开发人员推送test代码到远端
#!/bin/sh # test 分支不允许merge TEST_BRANCH="test" CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD) MERGE_HEAD=$(cat .git/MERGE_HEAD) MERGE_BRANCH_NAME=$(git name-rev $MERGE_HEAD --name-only) # 如果当前合并分支 匹配 test 分支 if [[ "$MERGE_BRANCH_NAME" == *"$TEST_BRANCH"* ]]; then echo "检测到非法合并: $MERGE_BRANCH_NAME ——into——&gt; $CURRENT_BRANCH" echo "撤销合并中..." git merge --abort echo "已撤销合并" fi exit 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e006b95cd052b9ffd56e2d247d0da5/" rel="bookmark">
			java实现扫码关注公众号--pc登录网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录流程如下 1.服务端获取accessToken
2.服务端请求微信接口生成带参数的二维码,微信会返回{二维码ticket,二维码有效时间,二维码图片地址}等信息。服务端将ticket响应给前端，前端拿ticket开始轮询请求服务器
3.用户扫码关注后，微信服务器会通知微信接口配置的url接口并携带{FromUserName:发送方的openid,Event:事件类型 subscribe(订阅)、unsubscribe(取消订阅)，二维码的ticket}等信息
4.服务器拿到openId和ticket 将 ticket作为key，openId作为value 存储至redis。表明此用户已扫码关注。
5.当前端拿ticket 轮询请求服务器时，服务端拿ticket去redis中查询。如果存在即扫码或关注成功,查看openid是否已注册，如已注册登录成功，如未注册则去注册。业务处理完成后服务端删除redis中的数据。
微信配置：
基本配置–》服务器配置。服务器地址(URL)即事件触发时被通知的接口
1. 服务端获取accessToken 1.accessToken 不建议使用时去获取
2. accessToken 失效性是两个小时，所以我们在redis存储1小时时间
@Override public String getPubAccessToken() { String pubAccessToken; Object obj = redisTemplate.opsForValue().get("pubAccessToken"); if (obj != null) { pubAccessToken = (String)obj; return pubAccessToken; } else { log.info("开始获取pubAccessToken"); try { String url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=" + wxPubPayProperties.getAppId() + "&amp;secret=" + wxPubPayProperties.getAppSecret(); ResponseEntity&lt;Map&gt; entity = restTemplate.exchange(url,HttpMethod.GET, null,Map.class); Map&lt;String,Object&gt; map = entity.getBody(); pubAccessToken = map.get("access_token") !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05e006b95cd052b9ffd56e2d247d0da5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da20a0431b62ec5d8712b2d90faf1baa/" rel="bookmark">
			底部tap切换同一个盒子只能单击一次，多次点击不会出现效果，只有点击另外一个盒子才能触发点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码吧，关键步骤会备注上面：
&lt;template&gt; &lt;view&gt; &lt;view style="position: sticky; bottom: 0; width: 100%; display: flex; height: 174rpx; background-color: #ffffff; border-top: 1rpx solid #F0F0F0;"&gt; &lt;view style=" display: flex; flex-flow: column wrap; justify-content: center; align-items: center; margin-top: 10rpx; width: 50%; height: 94rpx;" @tap="switchImage(true)"&gt; &lt;view style="width: 48rpx; height: 48rpx;"&gt; &lt;image v-if="isBoxSelected" src="/static/image1.jpg" mode="aspectFit" style="width: 48rpx; height: 48rpx;"&gt;&lt;/image&gt;&lt;!--点击isBoxSelected=false时的的图片--&gt; &lt;image v-else src="/static/image2.jpg" mode="aspectFit" style="width: 48rpx; height: 48rpx;"&gt;&lt;/image&gt;&lt;!--点击--&gt;&lt;!--点击isBoxSelected=true时的的图片--&gt; &lt;/view&gt; &lt;view style="width: 80rpx; font-size: 20rpx; height: 28rpx; line-height: 28rpx;"&gt; 发起申请 &lt;/view&gt; &lt;/view&gt; &lt;view style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da20a0431b62ec5d8712b2d90faf1baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725bddf5ebabb53cae0129e9f6b75768/" rel="bookmark">
			carbondata中查询hive java.net.SocketTimeoutException: Read timed out 问题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题解决方案：
步骤一：
在jdbc url 后面追加参数 ，设定各种超时时间参数设置为5000秒，因为hive任务可能会执行比较久，所以超时时间设置长一点
在hivejdbc中直接添加就行，咋carbondata中使用beeline连接方式直接在beeline -u jdbc:hive2://localhost:10000/?hive.metastore.client.socket.timeout=5000&amp;hive.server.read.socket.timeout=5000&amp;hive.server.write.socket.timeout=5000&amp;hive.server.thrift.socket.timeout=5000&amp;hive.client.thrift.socket.timeout=5000这样查询参数不生效还会报错，我在查询语句中当做参数，直接设置，
beeline -u jdbc:hive2://localhost:10000 -q"set hive.metastore.client.socket.timeout=5000 ;set hive.server.read.socket.timeout=5000; set hive.server.write.socket.timeout=5000；set hive.server.thrift.socket.timeout=5000;set hive.client.thrift.socket.timeout=5000; select * from XXXX;"
这样添加，参数值生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4f68085169f12cc197b15cfb90c317/" rel="bookmark">
			Slint学习文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Slint学习文档 Slint Learn如何学习本文档学习顺序标志说明 Slint With VSCodeSlint With Rust依赖👎定义宏 Slint与Rust分离1.添加编译依赖（slint-build）2.编写slint文件3.编写build.rs4.编写main.rs 普通组件主窗体Windowexample 文本Textexample 按钮Buttonexamplefunctions 矩形盒子元素 Rectangleexample 输入框TextInputexample 图片Imageexample 滚动窗口 Flickableexample 网格布局 GridLayoutexample 横纵布局 HorizontalLayout | VerticalLayoutHorizontalLayoutVerticalLayout 画板 PathSVG路径命令和Slint路径命令example 🚩Flag 基础知识Slint文件编写顺序与结构正确的代码Slint组件结构 组件的访问与命名组件的访问标识符（命名规范）命名组件 注释Slint中的类型颜色线性渐变径向渐变 🚩Flag 自定义类型结构体匿名结构体枚举数组 属性属性可见性自定义属性属性赋值（属性的单向绑定）属性的双向绑定private属性访问 函数与回调函数回调回调别名 条件于循环条件三元表达式循环example 动画🚩Flag 高级知识状态example通过状态更改动画 插槽模块的导入和导出全局变量导出导出重命名 导入example 🚩Flag 高级组件触碰事件区域 TouchAreaexamplefunctionsPointerEvent FocusScopeexamplefunctionsKeyEventEventResultKeyboardModifiers 弹出框 PopupWindowexamplefunctions Dialog 对话框生命周期 属性速查常用高度 height宽度 width位置 x和y叠放等级 z网格布局 col，row， colspan，rowspan拉伸 horizontal-stretch和vertical-stretch元素的最大大小 max-width和max-height元素的最小大小 min-width和min-height元素的首选尺寸 preferred-width和preferred-height是否显示 visible透明度 opacity加速渲染 cache-rendering-hint 👎阴影半径 drop-shadow-blur阴影颜色 drop-shadow-color阴影位置 drop-shadow-offset-x和drop-shadow-offset-y 窗口属性Window Params文字属性Text ParamsTextOverflowTextHorizontalAlignmentTextVerticalAlignmentTextWrap 输入框属性Textnput ParamsInputType 图片属性 Image ParamsImageFitImageRendering 滚动窗口 Flickable Params网格布局 GridLayOut横纵布局 HorizontalLayout | VerticalLayoutLayoutAlignment 触碰事件区域 TouchAreaMouseCursor 对话框 Dialog 可访问性🚩Flag Slint Learn author：syf20020816@outlook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4f68085169f12cc197b15cfb90c317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e358551a3b0b110c82b6eb8d4a048e/" rel="bookmark">
			【python】openpyxl复制插入多行数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从一个excel表复制插入多行数据到另一个excel表中
其实就是把行范围内的所有单元格（包括单元格格式和内容）复制到另一个表中，其中值（value）和单元格数字格式（number_format）可以直接复制值，用等号连接即可。其他格式，例如字体格式（font）、对齐方式（alignment）、填充（fill）、边框（border）属性，需要用到深拷贝也就是copy方法。
更多单元格样式的操作可以去看官方文档：https://openpyxl.readthedocs.io/en/stable/styles.html
中文官方文档：https://openpyxl-chinese-docs.readthedocs.io/zh_CN/latest/styles.html
from copy import copy import openpyxl as xl ''' @Desc	: 复制插入多行数据 @param1	: copy_path = 要复制的文件路径 copy_sheet_name = 要复制的工作表名称 copy_rows_start = 需要复制的开始行 insert_path = 需要插入的文件路径 insert_sheet_name = 需要插入的工作表 insert_rows_start = 需要插入的开始行 num = 复制的行数 @return	: None ''' def insert_multi_row(copy_path,copy_sheet_name,copy_rows_start,insert_path,insert_sheet_name,insert_rows_start,num): copy_rows_start = int(copy_rows_start) insert_rows_start = int(insert_rows_start) num = int(num) try: #打开要操作的工作簿 wb_copy = xl.load_workbook(copy_path) wb_insert = xl.load_workbook(insert_path) #打开对应工作表 if copy_sheet_name == '': ws_copy = wb_copy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19e358551a3b0b110c82b6eb8d4a048e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5425a613a2f3840d3001b87cb15e4c3e/" rel="bookmark">
			解决Unable to correct problems ,you have held broken packages
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当用sudo apt install &lt;package-name&gt;就会出现Unable to correct problems ,you have held broken packages
这时候我们可以尝试用aptitude安装
sudo aptitude install &lt;package-name&gt;
如果出现sudo :aptitude:command not found，则先安装aptitude
sudo apt-get install aptitude 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97aaefb3ef259a88314fefbaf206dfd5/" rel="bookmark">
			解决sudo: vim:command not find
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是使用vim命令时没有安装vim造成的，
解决方法：
sudo apt-get install vim 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d8a58d600db84a2000e2c4460b2987/" rel="bookmark">
			HTML、CSS及JS之间的区别浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML、CSS 和 JS 是构建网页的三种核心技术。
HTML（Hypertext Markup Language） 是一种标记语言，用于描述网页的结构和内容。通过 HTML，开发人员可以创建网页元素，例如标题、段落、列表、链接和图像等。
CSS（Cascading Style Sheets）是一种样式表语言，用于定义网页的外观和布局。通过 CSS，开发人员可以控制网页的字体、颜色、背景、间距和大小等属性。
JS（JavaScript）是一种编程语言，用于实现互动性和动态效果。通过 JS，开发人员可以控制网页的行为，例如用户交互、数据验证和动画等。
这三种技术共同作用于网页开发中，可以实现精美的、交互性强的网站和应用程序。
HTML、CSS和JS的主要区别如下：
HTML（超文本标记语言）用于定义Web页面的结构和内容。它是一种标记语言，包含一系列标签和属性，用于定义文本、图像、链接等元素。
CSS（层叠样式表）用于定义Web页面的样式和布局。它是一种样式表语言，用于控制文本的字体、颜色、大小、页面的布局、背景等。
JS（JavaScript）是一种脚本语言，用于给Web页面添加交互性和动态性。它能够对页面中的元素做出响应，实现特效、验证表单、处理数据等。
总体来说，HTML定义了Web页面的内容和结构，CSS定义了它的样式和布局，JS则为页面添加了交互和动态效果。三者共同作用，构成了现代Web页面的基础技术。
来源：微点阅读 https://www.weidianyuedu.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf28192227fe0ebfc1c97c1e731fd3a7/" rel="bookmark">
			Python简介、历史及优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一种高级、解释型、面向对象的编程语言。它由Guido van Rossum于1989年在荷兰创造，并于1991年发布。Python的设计哲学强调代码的可读性和简洁性，它具有清晰简洁的语法，使得它易于学习和使用。
Python的历史可以分为三个阶段：早期版本、Python2.x版本和Python3.x版本。在早期版本中，Python是个小型语言，但随着时间的推移，它不断发展壮大，现在已经成为最受欢迎的编程语言之一。Python2.x版本自2000年开始，是目前应用广泛的版本。Python3.x版本于2008年发布，它包含了许多新的语言功能和改进，但从Python2.x版本向Python3.x版本的迁移可能会带来一些问题。
Python的优点包括：
可读性好，代码简洁：Python的语法非常简单，具有良好的可读性和易于维护的特性。Python代码行数较少，代码简洁，易于阅读。
具有广泛的应用： Python可以用于许多不同领域的应用程序开发，如Web开发、数据分析、人工智能、机器学习等。
跨平台： Python可以在各种操作系统上运行，如Windows、Linux和Mac OS X等，这使得Python成为一个非常方便的开发工具。
提供大量的开发库和工具： Python提供了大量的开发库和工具，可以简化开发过程，提高开发效率。
Python的缺点包括：
性能问题：与某些编程语言相比，Python的执行速度较慢，这对于某些应用场景可能是一个问题。
大量标准库和第三方库：尽管Python提供了大量的标准库和第三方库，但这也可能导致一些不兼容和依赖问题。
缺少静态类型检查： Python是一种动态类型语言，因此缺少编译时的静态类型检查功能，可能导致一些类型错误问题。
转自：微点阅读 https://www.weidianyuedu.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c0c6c80d032d504f467ef9a51ccce9/" rel="bookmark">
			如何由墨刀的原型图自动生成Vue代码？AI能帮助实现吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前，还没有能够完全自动化生成Vue代码的AI工具，但是可以使用一些工具辅助开发。
墨刀提供了插件和导出功能来帮助将原型图转换为Vue代码，可以尝试以下步骤：
安装墨刀的Vue插件，插件可以将原型图中的组件快速转换为Vue组件，并生成相应的代码。
使用墨刀的导出功能，将原型图导出为JSON格式，然后使用转换工具将JSON格式转换为Vue代码。
当然，这种方法还需要对Vue组件的开发有一定的熟悉度，需要对Vue的生命周期、组件间通信等方面有一定了解。
总的来说，AI技术目前还不能完全自动化地将原型图转换为Vue代码，但是工具和插件可以帮助开发人员节省一些时间，提升开发效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9058fbe1edaba6e32ceda59b160a34b0/" rel="bookmark">
			navicat15 查看创建存储过程和函数，mysql8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、navicat查看存储过程，查看函数 navicat，存储过程在函数里
右键：设计函数
可以查看、修改、保存、运行函数存储过程
二、sql语句查看存储过程，查看函数 #查看存储过程 #show procedure status; show procedure status like '%proc_count_test1%' \G; show create procedure proc_count_test1; select * from information_schema.ROUTINES where ROUTINE_SCHEMA='test' and ROUTINE_TYPE='PROCEDURE'; #查看函数 #show function status; show function status like '%fun_add2%' \G; show create function fun_add2; select * from information_schema.ROUTINES where ROUTINE_SCHEMA='test' and ROUTINE_TYPE='FUNCTION'; #存储过程和函数都在information_schema.ROUTINES表内 三、新建存储过程和函数 新建函数里能建存储过程和函数
四、sql语句创建存储过程和函数 mysql8 查看创建存储过程和函数，characteristic特性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e25e19d0d1e505f6e2c373073f4041/" rel="bookmark">
			识别绕过reCaptcha v3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用CapSolver绕过reCaptcha v3 在这篇博文中，我们将指导您如何使用CapSolver绕过reCaptcha v3。
reCaptcha V3概述： reCaptcha V3是一个强大的解决方案，旨在保护您的网络资源免受不受欢迎的机器人活动。它通过实施挑战-响应测试来增加额外的安全层，以区分人类用户和机器人。然而，在某些情况下，您可能需要绕过这些验证码，例如进行测试或自动化特定任务。
CapSolver的强大功能： Capsolver是一项提供可靠方法绕过reCaptcha挑战的服务，在这种情况下非常有用。它提供不同类型的任务，以满足各种需求，确保在绕过reCaptcha V3方面获得最佳结果。
Capsolver支持reCaptcha V3，并提供多种任务类型，以确保满足您的需求：
ReCaptchaV3Task：此任务类型需要您自己的代理。
ReCaptchaV3TaskProxyLess：此任务类型使用服务器内置的代理。
ReCaptchaV3Task： ReCaptchaV3Task是一种需要您自己的代理才能工作的任务类型。对于那些拥有可靠代理池的人来说，这是理想的选择。使用个人代理可以更好地控制和自定义绕过过程。
from capsolver import ReCaptchaV3Task task = ReCaptchaV3Task( site_key='your-site-key', page_url='https://example.com', proxy='http://proxy.com', pageAction='example', user_agent='YourUserAgent' ) solution = capsolver.solve(task) ReCaptchaV3TaskProxyLess： 如果您没有访问代理的权限或者不愿使用代理，ReCaptchaV3TaskProxyLess是一个完美的选择。它利用服务器内置的代理，使整个过程更加简化和用户友好。
from capsolver import ReCaptchaV3TaskProxyLess task = ReCaptchaV3TaskProxyLess( site_key='your-site-key', page_url='https://example.com', pageAction='example' ) solution = capsolver.solve(task) 创建任务： 要开始这个过程，您需要使用createTask方法创建一个识别任务。
以下是一个示例请求：
POST https://api.capsolver.com/createTask { "clientKey":"yourapiKey", "task": { "type":"ReCaptchaV3Task", "websiteURL":"https://antcpt.com/score_detector", "websiteKey":"6LcR_okUAAAAAPYrPe-HK_0RULO1aZM15ENyM-Mf", "pageAction": "homepage", "proxy":"yourproxy" } } 一旦任务成功提交，您将在响应中收到一个任务ID：
{ "errorId": 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75e25e19d0d1e505f6e2c373073f4041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899ea09ad42423039dab1bee0531d800/" rel="bookmark">
			Capsolver Extension - 在您的浏览器中解决图像验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		☄️ 步骤1：获取Capsolver API密钥 在您可以在浏览器中解决图像验证码之前，您需要满足一些要求以能够解决图像验证码。
⚙️ 要求： Capsolver API密钥API密钥上有足够的资金Capsolver扩展程序 如何获取您的API密钥？ 在Capsolver上注册或登录 复制您的API密钥 🤯步骤2：在您的Chrome浏览器上安装扩展 1.下载拓展程序
2.粘贴先前复制的API密钥
3.现在您将能够轻松解决图像验证码！
如果有任何无法通过我们的服务解决的图像验证码，请联系我们。
4.您可以通过在页面上设置它们的ID来帮助扩展程序识别图像和输入框。
5.第一步是将要识别的图像元素的ID设置为'capsolver-image-to-text-source'。
6.第二步是将输入结果框元素的ID设置为'capsolver-image-to-text-result'。
7.然后，扩展程序将根据您设置的ID执行图像识别，并将结果填充到输入框中。
原文：Capsolver Extension - Solve Image Captcha in your browser
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c18f235ea122d3f14531fccf1972467/" rel="bookmark">
			EasyExcel实现动态生成包含下拉框、级联下拉框的excel表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间，因为项目需要，要将excel模板下载功能从附件下载迭代为后台动态生成；但是这个表格里面包含了下拉框，耗时两天才算是把这个excel表格搞完，现在记录一下，方便后续回顾。
首先，要实现的效果是这样：
根据D列的检查类型,E列弹出不同的下拉选项，F列弹出不同的问题属性；
Service层导出excel代码：
@Transactional(rollbackFor = Exception.class) public void download(HttpServletResponse response) { //导出文件格式 response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"); response.setCharacterEncoding("utf-8"); //设置导出文件名 String filename = ""; try { filename = URLEncoder.encode("Excel名称" + DateUtil.format(new Date(), "yyyy-MM-dd"), "UTF-8").replaceAll("\\+", "%20"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } response.setHeader("Content-disposition", "attachment;filename*=utf-8''" + filename + "." + ExcelFormat.XLS.getValue()); //模板实体类 List&lt;SecondInspProbExcelDTO&gt; secondInspProbExcelDTOS = new ArrayList&lt;&gt;(); //普通下拉数据 Map&lt;Integer, String[]&gt; map = ordinarySelect(); //检查类型-子类 Map&lt;String, List&lt;String&gt;&gt; inspNameMap = inspNameSelect(); //检查类型-父类 String[] proInspNameMap = proInspNameSelect(); //问题属性 Map&lt;String, List&lt;String&gt;&gt; probPropsNameMap = probPropsNameSelect(); try(OutputStream outputStream = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c18f235ea122d3f14531fccf1972467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7188a537bfe462c5671dbcb20f45c6/" rel="bookmark">
			SpringBoot&#43;Vue 登录（含验证码）、注册功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初始化项目 参考下面文章，初始vue项目并且引入ElementUI组件
网页制作神器—ElementUI（小白入门超详细）
并且参考基于Axios完成前后端分离项目数据交互 完成 request 请求工具的封装。
最终Vue.js 框架的应用程序的入口文件 main.js 的代码如下：
import Vue from 'vue' import App from './App.vue' import router from './router' import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import '@/assets/css/global.css' import '@/assets/css/iconfont/iconfont.css' import '@/assets/css/theme/index.css' import request from "@/utils/request"; // 首先，导入了 Vue、App 组件、router、ElementUI 组件库以及相关CSS 文件。 // 其中，Vue 是 Vue.js 框架的核心库，App 是根组件，router 是路由配置文件，ElementUI 是基于 Vue.js 的 UI 组件库，包括一些常用的界面元素和样式。 //设置了 Vue.config.productionTip 的值为 false，这是对 Vue 配置项的修改，表示阻止在生产环境下产生提示信息。 Vue.config.productionTip = false // 通过 Vue.use(ElementUI, { size: 'small' }) 使用 ElementUI 插件，并设置全局的默认组件尺寸为 small。 Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed7188a537bfe462c5671dbcb20f45c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c947e84a1aad3726698f334f2ec371/" rel="bookmark">
			openwrt的基本目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenWrt是一个基于Linux的嵌入式操作系统，其目录结构在不同版本和构建中可能会有所不同，但通常包括以下重要目录：
/bin：包含一些基本的命令和工具，如ls、cp、mv等。
/sbin：包含系统管理命令，只有root用户可以执行的命令通常在这里。
/etc：存储系统的配置文件，包括网络配置、软件包配置以及其他系统配置文件。
/lib：系统库文件的存放位置，用于支持各种应用程序和工具。
/usr：通常包含用户安装的应用程序、库文件和数据。其中，/usr/bin和/usr/sbin包含用户安装的可执行文件。
/var：包含运行时数据，如日志文件、临时文件、缓存等。
/tmp：用于存储临时文件的目录。
/root：root用户的家目录。
/home：普通用户的家目录，每个用户通常在此目录下有一个独立的子目录。
/mnt：用于挂载外部存储设备的目录。
/proc：一个虚拟文件系统，用于访问系统信息和内核参数。
/sys：另一个虚拟文件系统，用于与内核进行交互。
/dev：包含设备文件，用于与硬件设备进行交互。
/lib/modules：存储内核模块的目录。
/rom：通常包含只读的文件系统层，存储OpenWrt的固件和基本系统文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa42f70e3dcc0dd199cf48e5c0735ba2/" rel="bookmark">
			MTK 读取寄存器 ESD 恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AUOC_G101EAN_01_0.c
/* BEGIN PN: , Added by h84013687, 2013.08.13*/
#ifndef BUILD_LK
#include &lt;linux/string.h&gt;
#endif
#include "lcm_drv.h"
#ifdef BUILD_LK
#include &lt;platform/mt_gpio.h&gt;
#elif defined(BUILD_UBOOT)
#include &lt;asm/arch/mt_gpio.h&gt;
#else
#include &lt;../include/mt-plat/mt_gpio.h&gt;
#include &lt;../include/mt-plat/mt6735/include/mach/gpio_const.h&gt;
#endif
#ifdef BUILD_LK
#define LCD_DEBUG(fmt) dprintf(CRITICAL,fmt)
#else
#define LCD_DEBUG(fmt) printk(fmt)
#endif
#define LCM_DSI_CMD_MODE 0
#define FRAME_WIDTH (800)
#define FRAME_HEIGHT (1280)
#define REGFLAG_DELAY 0xFC
#define REGFLAG_END_OF_TABLE 0xFD // END OF REGISTERS MARKER
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa42f70e3dcc0dd199cf48e5c0735ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3906518b4213ab67f7c9264f57b0bd17/" rel="bookmark">
			SpringBoot项目结合@Slf4j将日志记录到磁盘和数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、背景介绍2、存本地2.1、配置文件2.2、使用 3、存数据库3.1、配置文件改造3.2、过滤器编写3.3、表准备3.4、添加依赖3.5、测试 4、优化4.1、日志定期删除4.2、分库处理4.3、环境 5、总结 1、背景介绍 现在我一个SpringBoot项目想记录日志，大概可以分为下面这几种：
用户操作日志：作用是记录什么用户在什么时间点访问了什么接口做了什么操作，相当于对用户在系统中的一举一动做了一个监控，这个功能我已经在我另外一篇博客中做了详细的说明，地址：https://blog.csdn.net/wujiangbo520/article/details/122057616登录登出日志：就是将所有用户登录系统和登出系统记录到数据库，比如时间、IP、IP归属地等做一个记录，这个简单，就不过多赘述了开发调试日志：就是我们常用的log.info(“xxxxx”);记录一些日志信息到磁盘中，方便上生产后，出现Bug时，可以多一些日志信息帮助我们尽快定位问题的 今天我们主要来好好聊一下开发调试日志
2、存本地 我们先来介绍一下，开发调试日志如何存本地磁盘
2.1、配置文件 首先我们需要在SpringBoot工程的resources下新建一个名叫【logback-spring.xml】的文件，内容如下：
&lt;!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL --&gt; &lt;!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 --&gt; &lt;!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 --&gt; &lt;!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 --&gt; &lt;!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt; &lt;!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt; &lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 动态日志级别 --&gt; &lt;jmxConfigurator /&gt; &lt;property name="charset" value="UTF-8"/&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3906518b4213ab67f7c9264f57b0bd17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfad872bdedb0faaa54c6d1c7aae63cd/" rel="bookmark">
			ElementUI浅尝辄止17：Progress 进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用于展示操作进度，告知用户当前状态和预期。
常见于操作流程进度或某项任务的状态。
1.如何使用？ Progress 组件设置percentage属性即可，表示进度条对应的百分比，必填，必须在 0-100。通过 format 属性来指定进度条文字内容。&lt;el-progress :percentage="50"&gt;&lt;/el-progress&gt; &lt;el-progress :percentage="100" :format="format"&gt;&lt;/el-progress&gt; &lt;el-progress :percentage="100" status="success"&gt;&lt;/el-progress&gt; &lt;el-progress :percentage="100" status="warning"&gt;&lt;/el-progress&gt; &lt;el-progress :percentage="50" status="exception"&gt;&lt;/el-progress&gt; &lt;script&gt; export default { methods: { format(percentage) { return percentage === 100 ? '满' : `${percentage}%`; } } }; &lt;/script&gt; 2.百分比内显 百分比不占用额外控件，适用于文件上传等场景。
/*Progress 组件可通过 stroke-width 属性更改进度条的高度， 并可通过 text-inside 属性来将进度条描述置于进度条内部。*/ &lt;el-progress :text-inside="true" :stroke-width="26" :percentage="70"&gt;&lt;/el-progress&gt; &lt;el-progress :text-inside="true" :stroke-width="24" :percentage="100" status="success"&gt;&lt;/el-progress&gt; &lt;el-progress :text-inside="true" :stroke-width="22" :percentage="80" status="warning"&gt;&lt;/el-progress&gt; &lt;el-progress :text-inside="true" :stroke-width="20" :percentage="50" status="exception"&gt;&lt;/el-progress&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfad872bdedb0faaa54c6d1c7aae63cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4170221a8de4a51fded45df7c5114418/" rel="bookmark">
			SW-装配体中配合用基准面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以在装配体中建立和零件关联的基准面 ，用来配合，而不需要在零件内部建立
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec99ceab7803c1897308ce28d0ce42cb/" rel="bookmark">
			Conda环境配置常用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用命令
pip list 查看pip安装的包
conda list
pip show numpy 查看包的详细信息
Conda环境配置
conda env list 查看已有的虚拟环境
conda activate my_test 切换到想要的虚拟环境
conda activate 激活canda环境
python -V #注意V是大写，即可查看Python版本号
创建环境方式一
conda create -n my_test python=3.9.7 创建新环境，这种方式里面的包比较少，而且没有jupyter notebook
创建环境方式二
conda create -n my_test python=3.9 anaconda 这种方式创建的环境与base(root)环境基本相同
conda install python=版本号 更换虚拟环境下的python版本，之前安装的包也都没有了。
Juypter notebook切换虚拟环境
首先进入自己创建的虚拟环境，activate 虚拟环境名
在自己的虚拟环境下，安装ipykernel模块，pip install ipykernel；
然后输入以下命令，python -m ipykernel install --user --name 虚拟环境名 --display-name 最终显示的名字
然后再打开jupyter notebook，发现再创建文件的时候就可以选择新加入的环境了
系统包的路径增删查
有时候一个环境下有多个相同包，怎么升级也不对，发现根本没有导入到正确的。
一旦成功导入了某个包，改变了导入顺序后，要重启kernel才能生效
print(sys.path) 查看系统路径和优先搜索顺序
print(numpy.__file__) 查看这个包来自哪个路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec99ceab7803c1897308ce28d0ce42cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b4a72df0caca139c41e28fad679582/" rel="bookmark">
			UML箭头汇总&#43;IDEA绘制UML类图详细教程&#43;chatGPT辅助生成UML类图教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：http://www.cnblogs.com/damsoft/archive/2016/10/24/5993602.html
文章目录 一、UML基础知识1.UML简介2.UML类图2.1 泛化2.2 实现（Realization）2.3 关联（Association)2.4 聚合（Aggregation）2.5 组合(Composition) 3.总结 二、IDEA如何生成类图**1.安装 PlantUML**2.安装Graphviz渲染类图3.Graphviz环境变量配置4.cmd验证安装是否成功5.PlantUML文档创建6.IDEA与Graphviz集合uml类图的常见语法和功能uml类图符号类和类之间的关系：示例：关系上的标签 三、chatGPT辅助生成UML类图教程 一、UML基础知识 1.UML简介 Unified Modeling Language (UML)又称统一建模语言或标准建模语言。
各个箭头的含义：
简单说就是以图形方式表现模型，根据不同模型进行分类，在UML 2.0中有13种图，以下是他们的主要用途简介：
1.用例图：对系统的使用方式分类.
2.类图:显示类和它们的相互关系。
3.对象图：只显示对象及它们的相互关系。
4.活动图：显示人或对象的活动，其方式类似于流程图。
5.状态机图：显示生命周期比较有趣或复杂的对象的各种状态。
6.通信图：显示在某种情形下对象之间发送的消息。
7.顺序图：显示与通信图类以的信息，但强调的是顺序，而不是连接。
8.包图：显示相关的类如何组合，对开发人员有用。
9.部署图：显示安装已完成系统的机器、过程和部署制品。
10.组件图：显示可重用的组件（对象或子系统）及期接口。
11.交互总图：使用顺序图喧赤活动的务个步骤。
12.时间图：显示消息和对象状态的准确时间限制。
13.复合结构图：显示对象在聚合或复合中的相互关系，显示接口和协作的对象
常用的 UML 图可分静（态）图、动（态）图两类，静态图主要描绘软件的静态结构，而动态图主要描绘软件的动态行为。
常用 UML 动态图（5 个）：用例图，活动图，状态机图，序列图，通信图。
常用 UML 静态图（4 个）：类图，包图，部署图，构件图。
2.UML类图 在所有UML图中，类图是使用频率最高的UML图。
类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。
类图主要关系有：泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)
2.1 泛化 【泛化关系】：是一种继承关系, 表示一般与特殊的关系, 它指定了子类如何特化父类的所有特征和行为. 例如：老虎是动物的一种, 即有老虎的特性也有动物的共性.
【箭头指向】：带三角箭头的实线，箭头指向父类
2.2 实现（Realization） 【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.
【代码体现】：类实现接口成员
【箭头指向】：带三角箭头的虚线，箭头指向接口
2.3 关联（Association) 【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；
【代码体现】：成员变量
【箭头及指向】：带普通箭头的实心线，指向被拥有者
上图，表示企业和员工的关联关系，员工都属于一个企业
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11b4a72df0caca139c41e28fad679582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0abd01e8480ae26c2cc36a6eb651a5d/" rel="bookmark">
			微信 小程序 在电脑PC端无法加载的解决办法。电脑微信小程序打不开是怎么回事？电脑微信小程序不能打开解决方法教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、电脑微信小程序打不开或者一直在加载的原因？ 1、电脑端微信版本未更新 微信版本未及时更新，也会影响小程序的正常打开，可以尝试更新版本。
2、缓存过多 如果电脑缓存文件过多，内存少，也可能导致小程序无法流畅加载出来，建议定期清理缓存。
3、小程序运行状态不正常 当小程序处于临时抢修或停止运营状态时，所有微信用户均无法正常使用。如果是小程序开发者在做更新或bug抢修，那么后期不断尝试即可，停止运营则无法继续提供服务。
4、信号/网络不稳定 检查一下手机网络wifi或者流量是否断开，有时候网络不稳定会导致无信号，也就无法打开小程序，其次检查微信是否连接上网络，消息收发是否正常，以上如果发现是网络问题，及时点击重新连接就可以解决。
二、解决办法 方法一、更新版本 1、电脑版微信小程序打不开，一般是由于版本问题，此时需要打开微信，点击左下角图标。
2、在列表中点击“设置”。
3、选择“关于微信”，点击“检查更新”。
4、如果不是最新版，点击更新，重新打开微信即可。
方法二、删除数据文件 1、首先登陆电脑微信。
2、点击微信左下角的三个横杠图标按钮，在弹出菜单中选择设置。
3、进入设置窗口后点击文件管理，点击打开文件夹。
4、打开文件夹后双击进入Msg目录。
5、退出电脑端微信。
6、在Msg目录里找到Applet.db文件并删除。这个数据库文件存放了小程序的一些信息。
7、重新登陆电脑微信，小程序打开问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062dc6a46118ce5b0eca5c454f4ae0db/" rel="bookmark">
			FPGA图像无极缩放.Demo1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周狼哥得空，把最近写的缩放代码上板子跑了下效果，现在终于可以拿出来见人了。
这个demo主要是针对没有mipi输入的小伙伴，整个demo的框图如下，通过sdk将测试图像导入到DDR中，解决mipi图像源的问题，然后通过datamover读取图像数据，为了可以实现图像的放大和缩小，先通过简单的抽样，将图像下采样到原图的1/4，然后将原始的rgb图像转成灰度，这么做的目的一个是将rgb转灰度的公式实现给大家，另一个就是考虑到资源问题，如果使用rgb格式，有些使用7010开发板的可能资源不够，或者资源用的过多出现不必要的时序问题，转成灰度之后，就可以进行图像的缩小和放大了，为了在同一个工程方便验证缩小和放大，缩放的参数通过PS来配置，小伙伴们可以通过修改ps的参数，快速的验证缩放功能的正确性，缩放好的数据通过datamover写回到DDR里，然后再读取出来给hdmi显示出来，这样就很方便的看到了图像缩放的效果。
整个的demo涉及到缩放仿真、使用matlab生成测试图，sdk导入测试图像，DDR读写逻辑，流控，rgb转灰度，缩放算法、hdmi显示等知识，对缩放感兴趣的小伙伴这是一个完整的学习demo。
下面我们看看整个工程的实际架构和资源消耗，图像依次是顶部层bd，缩放核心子层级，资源消耗和7010资源参考，缩放模块的资源大家可以参照《FPGA图像算法.无极缩放》，整个工程可以在小资源的7010上实现，解除大家对资源的后顾之忧。
最后看看实际的上板效果图，缩放的基准图是640*360，显示分辨率为1280*720，图片按顺序分别是放大到720*480，缩小到360*240，放大到1280*720。缩放比可以任意设定，行列等比例和不等比例都可以。如果对demo有兴趣的欢迎加文章末尾微信咨询。
*******往期精彩文章列表********
FPGA图像无极缩放.Demo2
FPGA图像无极缩放.Demo1
FPGA图像算法.无极缩放
基于Zynq的图像处理入门课程
FPGA图像算法.导向滤波
点击上面链接查看详情
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154e52fa92e4f2beeeee5000a3367c97/" rel="bookmark">
			argmax函数的使用(pytorch版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import torch input = torch.tensor([[6, 0], [2, 9]]) print(input.argmax()) # tensor(3) （把[[6,0],[2,9]]看成[6,0,2,9]。从0索引，第3个索引的元素最大） print(input.argmax(0)) # tensor([0, 1]) # 沿列看，第一列第0个位置（元素'6'）最大， # 沿列看，第二列第1个位置（元素'9'）最大。依旧是从0开始索引） print(input.argmax(1)) # tensor([0, 1]) # 沿行看，第一行第0个位置（元素'6'）最大， # 沿行看，第二行第1个位置（元素'9'）最大。依旧是从0开始索引） 如果一个数组中最大值个数不唯一
那么返回第一个最大值的索引
input2 = torch.tensor([0,6,9,2,1,9]) print(input2.argmax()) # tensor(2) (返回第一个最大值的索引) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b54ef92826fb2815a9b7d14371b2f1b/" rel="bookmark">
			Android 开发调试工具(ADB, DDMS, AS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 开发调试工具—ADB ADB的用途 在Android Studio中工作时，手机插口需要连接其他设备因此无法用线与电脑连接，因此可以利用Android Studio内嵌的命令台通过adb实现WIFI连接手机与电脑。
什么是ADB Android调试桥（Android Debug Bridge）是多种用途的调试工具，帮助管理设备或模拟器的状态
ADB的使用： https://www.cnblogs.com/jm0902/p/7657620.html
mac上Android Studio中adb的环境变量配置_lsw5530的博客-CSDN博客
MAC AndroidStudio ADB命令 - 简书
android studio 中adb 配置与常用命令_android studio 配置adb_唐门-西门吹雪的博客-CSDN博客
Android Studio如何配置adb以及常用命令_yangBIQ的博客-CSDN博客
ADB常用命令 Android Studio adb手机调试步骤_android studio怎么调试_大黑山修道的博客-CSDN博客
Android Studio 利用 ADB WIFI 插件实现真机无线调试https://www.cnblogs.com/zhaoxinpeng/p/6659475.html 1. 手机开启 USB 调试模式 ：把手机通过 USB 数据线连接到电脑，开启 USB调试，步骤如下：（以MEIZU PRO6 ,flyme5.2.3.0A为例）
将手机连接电脑---&gt;设置---&gt;辅助功能---&gt;开发者选项---&gt;USB调试（打开此选项）
2. 安装 ADB WIFI 插件 ：在 Android Studio 中打开 settings---&gt;Plugins，搜索并添加 ADB WIFI 然后重启 Android Studio 以完成插件的安装过程；
3. 开发调试模式设置为 USB Device
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b54ef92826fb2815a9b7d14371b2f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b871dbd8df5417a338c36c72e2d0189/" rel="bookmark">
			学生宿舍住宿管理系统代码分享 - C语言控制台程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【代码要求】 设计一个学生宿舍管理程序，方便宿舍管理。
功能要求
支持管理员对学生宿舍住宿信息的建立和修改，包括宿舍编号、楼号、宿舍性质（男/女）、已住人数、空床位数等。提供按楼号，查询当前空宿舍间数，并显示宿舍号。提供按楼号和房号，查询当前空床位数，并显示查询信息明细。提供按宿舍性质，分别统计出男生和女生当前占用的床位数和空床位数。 设计提示：程序用户分管理员，有专用密码；其他用户，不需要密码。
【代码运行】 P_C_00004_学生宿舍住宿管理系统
【代码片段】 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #define LEN 30 #define MAX 100 //定义宿舍住宿信息结构体 struct Dorm{ char id[LEN]; //宿舍编号 char fid[LEN]; //宿舍楼号 char type[LEN];//宿舍性质 int bcount; //床位数 int peo; //已住人数 }; //定义宿舍住宿信息结构体数组 struct Dorm dorm[MAX]; //定义住宿住宿信息个数 int dCount=0; 【结尾】
此文章部分内容参考自GO代码演示网，
如转载，请保留此说明和完整的页面内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c45a57fad18ff783157d28287f9c800/" rel="bookmark">
			关于C&#43;&#43;的vector用法的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准库类型的vector表示对象的集合，其中所有的对象都有相同的类型；集合中每一个对象都有一个与其对应的索引，索引用于访问对象。使用时必须包含：
#include&lt;vector&gt; using std::vector; 1、定义和初始化vector对象
vector&lt;string&gt; svec;//默认初始化，svec不包含任何元素 //事实上，最常见的方式是先定义一个空的vector, //然后当运行时获取到元素值就添加进去； vector&lt;int&gt; ivec; //往ivec中添加一些值 vector&lt;int&gt; ivec1(ivec); vector&lt;int&gt; ivec2=ivec; 列表初始化
vector&lt;string&gt; svec={"the","Three","Kingdoms"};//使用'='进行列表初始化 //也可以将初始值都放在花括号里进行列表初始化 vector&lt;string&gt; v{"Be","a","Better","Fighter"}； 创建制定数量的元素
vector&lt;int&gt; ivec(10,-1);//10和int元素，每个都初始化为-1 vector&lt;int&gt; ivec1(10);//10个int元素，每个初始化为0 vector&lt;string&gt; svec(10,"hello");//10个string元素，每个都初始化为"hello" vector&lt;string&gt; svec1(10);//10个string元素，每个都为空string对象 创建二维数组
vector&lt;vector&lt;int&gt;&gt; arr(2,vector&lt;int&gt;(5));//创建2行5列的二维数组，初值值为0 2、向vector中添加元素
push_back负责把一个值当成vector对象的尾元素“push”到vector对象的"尾端back"
vector&lt;double&gt; dvec; double temp; for(int i=0;i&lt;100;i++) { temp=i*i; dvec.push_back(temp); } 从标准输入中读取单词，存入vector中
string word; vector&lt;string&gt; text; while(cin&gt;&gt;word) { text,push_back(word); } 3、vector的其他操作
v.empty();//检查是否为空v.capacity();//返回当前vector中最大可以存储数据的容量v.size();//返回v中元素的个数v[n];//获取v中第n个元素 使用引用改变vector中的元素
vector&lt;int&gt; v{1,2,3,4,5,6,7,8,9}; for(auto &amp;i:v) { i*=100; cout&lt;&lt;i&lt;&lt;endl; } 例子：以10分为一个分数段统计成绩的数量：09,1019,20~29,…
vector&lt;int&gt; scores(11,0);//11个分数段，全都初始化为0 unsigned int grade; while(cin&gt;&gt;grade)//读取成绩 { if(grade&lt;=100)//只处理有效的成绩 ++scores[grade/10];//将对应分数段的计数值加1 } 特别注意：对于一个空的vector,不能使用下标向其中添加元素。只能使用push_back.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c45a57fad18ff783157d28287f9c800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefb058a55c84707415f3704888ca588/" rel="bookmark">
			Kalman滤波器的C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、原理介绍 kalman滤波在状态估计和多传感器融合等方面应用广泛，典型的应用有无人机的飞行姿态估计，汽车的行驶状态估计，无人驾驶中的激光雷达和其他传感器之间的融合等。至于Kalman滤波的数学推导，比较复杂，需要数学功底比较好，我看了很多次书还是不会推导，放弃了，拿过来用就行了。有点儿拿来主义了。还是的介绍下kalman滤波所涉及的系统微分方程和几个核心公式。kalman滤波分为预测和更新两步。
1）线性系统微分表达 根据现代控制理论，一个线性系统可以被描述为以下形式：
状态方程：
x k = A x k − 1 + B u k + w k x_k=Ax_{k-1}+Bu_k+w_k xk​=Axk−1​+Buk​+wk​
观测方程：
z k = H x k + v k z_k=Hx_k+v_k zk​=Hxk​+vk​
这是空间状态表达式，现代控制理论里有。 w k w_k wk​是过程噪声，服从高斯分布， v k v_k vk​是观测噪声，也服从高斯分布，即：
p ( w ) − N ( 0 , Q ) p(w)-N(0,Q) p(w)−N(0,Q)
p ( v ) − N ( 0 , R ) p(v)-N(0,R) p(v)−N(0,R)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eefb058a55c84707415f3704888ca588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5becb66a408f87cae2830f681a1f4c6e/" rel="bookmark">
			【Python 基本技能篇】解析命令行参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 通常，对于大型项目程序而言，执行程序的一个必要的步骤是正确处理命令行参数，这些命令行参数是提供给包含某种参数化信息的程序或脚本的参数。例如，在计算机视觉项目中，图像和不同类型的文件通常作为命令行参数传递给脚本，用于使程序可以处理不同图片或者不同类型文件。
命令行参数是参数化程序执行的一种常见且简单的方法，下面主要介绍三种常见的获取和解析命令行参数的方法。
一. sys.argv 为了处理命令行参数，Python 中内置了 sys.argv 模块，通过模块中的 sys.argv 就可以访问到所有的命令行参数，它的返回值是包含所有命令行参数的列表 (list)。当程序执行时，Python 从命令行获取所有值并将它们存储在 sys.argv 列表中。列表的第一个元素 sys.argv[0] 是脚本的完整路径(或脚本名称——取决于具体操作系统)。列表的第二个元素是脚本的第一个命令行参数，即 sys.argv[1]，依此类推。这可以通过下图中清晰的看出，其中 script_1.py 脚本使用两个参数执行：
接下来，让我们看看 sys.argv 是如何工作的，首先编写 scripy_1.py 脚本：
import sys print("正在运行的脚本名称: '{}'".format(sys.argv[0])) print("脚本的参数数量: '{}'".format(len(sys.argv))) print("脚本的参数: '{}'".format(str(sys.argv))) 如果我们不使用任何参数执行这个脚本：
python script_1.py 将会看到如下信息：
正在运行的脚本名称: 'script_1.py' 脚本的参数数量: '1' 脚本的参数: '['script_1.py']' 如果我们使用多个参数执行此脚本:
python script_1.py OpenCV -i test.png
将得到以下信息：
正在运行的脚本名称: 'script_1.py' 脚本的参数数量: '4' 脚本的参数: '['script_1.py', 'OpenCV', '-i', 'test.png']' 如上所示，列表的第一个元素 script_1.py (sys.argv[0]) 是脚本名称。列表的第二个元素 (sys.argv[1]) OpenCV 是脚本的第一个参数。
但同时也可以看到，sys.argv 将命令行选项 -i 也识别为参数，这样并不能方便的满足我们的需求，因此引入 getopt 模块来识别命令行选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5becb66a408f87cae2830f681a1f4c6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb14ee43addd497567227dbfbfd2f1e2/" rel="bookmark">
			windows添加文件夹到快速访问时报“执行读取操作时发生磁盘错误”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win + r打开以下命令：
%APPDATA%\Microsoft\Windows\Recent\AutomaticDestinations 然后，删除文件夹下的-ms文件，即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd8c6c0d897d1926c33eaea977c949b2/" rel="bookmark">
			jupyter notebook打开和保存文件默认路径更改方法（最简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
安装Anaconda后，新建文件的默认存储路径一般在c盘中，我们通过自带的快捷方式打开后也会到对应的c盘文件中去，相信对于大多数人来说这是不能接受的，而且如果我们想在指定文件夹下打开jupyter-notebook，就需要打开命令行，输入“jupyter notebook D:\xxx”的命令后能在指定文件夹下打开，这个过程又非常麻烦，非常不适合我这种喜欢偷懒的人。那么结果就是你只能去修改默认路径，这个方法我尝试了下，最后却不知道什么原因不能创建文件，最后没办法又给修改了回来，白白浪费了时间。
为了不让大家重复走我走过的路，今天我给大家推荐一种超级简单的方法，具体内容如下：
目录
一、首先新建一个txt文件
二、在文件中输入以下代码并保存
三、将文件扩展名.txt改为.bat
四、双击jupyter_start.bat文件，启动成功
总结
一、首先新建一个txt文件 这里你可以按照喜好随便起个名字。
二、在文件中输入以下代码并保存 jupyter notebook D:\jupyterproject 三、将文件扩展名.txt改为.bat 四、双击jupyter_start.bat文件，启动成功 总结 好了，分享到这里就结束了，其实相当于我们创建了一个快捷方式，希望能对大家起到一定的帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c46d0203462691b8e2ef07c742b803a/" rel="bookmark">
			【数据结构】 二叉树面试题讲解-＞贰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🌏引言🎄[二叉树遍历](https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=60&amp;&amp;tqId=29483&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/tsing-kaoyan/question-ranking)🐱‍👤题目描述：📌输入描述：📌输出描述： 🐱‍🐉示例：🐱‍👓思路解析：🐱‍🏍完整代码实现： 🌳[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)🐱‍👤题目描述：🐱‍🐉示例：📌示例一 📌示例二🐱‍👓思路解析🚩思路一 🚩思路二🐱‍🏍代码实现：🎈思路一代码实现🎈思路二代码实现 🎍[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)🐱‍👤题目描述🐱‍🐉示例：🐱‍👓思路解析：🐱‍🏍代码实现： 🌲拓展——[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/%E3%80%81)⭕总结 🌏引言 二叉树的操作算法是笔试面试中较为常见的题目。
本文将着重介绍平时面试中常见的关于二叉树的应用题目，马上要进行秋招了。希望对你们有帮助 _😀
🎄二叉树遍历 🐱‍👤题目描述： 编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。
📌输入描述： 输入包括1行字符串，长度不超过100。
📌输出描述： 可能有多组测试数据，对于每组数据， 输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。 每个输出结果占一行。
🐱‍🐉示例： 输入： abc##de#g##f###
输出：c b e g d f a
🐱‍👓思路解析： 首先我们先来看一下示例输入的二叉树的形状
我们首先需要做的是创建一个二叉树类，用于建立一个新的二叉树
class TreeNode1 { char val; TreeNode1 left; TreeNode1 right; TreeNode1() {} TreeNode1(char val) { this.val = val; } TreeNode1(char val, TreeNode1 left, TreeNode1 right) { this.val = val; this.left = left; this.right = right; } } 接下来我们需要
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c46d0203462691b8e2ef07c742b803a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b9ceca28faf97b0d36c56dd98b59e9/" rel="bookmark">
			XXXX is not in the sudoers file. This incident will be reported解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XXXX is not in the sudoers file. This incident will be reported解决方法
假设你用的是Red Hat系列（包括Fedora和CentOS）的Linux系统。当你执行sudo命令时可能会提示“某某用户 is not in the sudoers file. This incident will be reported.”
解决方法:编辑sudoers文件有两种办法，一种是以root帐号执行visudo，另一种是root帐号执行vi /etc/sudoers.其实两者都是修改/etc/sudoers。
注意：在修改 /etc/sudoers时，一定注意该文件是否有写权限，如果没有写权限，则使用 chmod u+w /etc/sudoers使其拥有写权限
。写完后注意将写权限去掉，以防止误操作。
假设你的用户名是“minghai”，属于“minghai”用户组。
为了让用户minghai能够执行sudo命，你可以在sudoers文件中加上一下四行的任意一行。
minghai ALL=(ALL) ALL %minghai ALL=(ALL) ALL minghai ALL=(ALL) NOPASSWD：ALL %minghai ALL=(ALL) NOPASSWD：ALL 解释说明：
第一行：允许用户minghai执行sudo命令（需要输入密码）。第二行：允许用户组minghai里面的用户执行sudo命令（需要输入密码）。第三行：允许用户minghai执行sudo命令，并且在执行的时候不输入密码。第四行：允许用户组minghai里面的用户执行sudo命令，并且在执行的时候不输入密码。 当然如果你理解上面的原理后，可以直接输入如下命令解决此问题
su - echo 'xxx ALL=(ALL) ALL' &gt;&gt; /etc/sudoers (其中xxx代表用户名) 原理扩展 通过su可以直接将身份变为 root，但需要 root 的密码
通过sudo可以执行 root 的命令串，sudo 只需要输入自己的密码，或者在sudoer中配置不需要任何密码
还可以可以使用visudo修改 /etc/sudoers 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b9ceca28faf97b0d36c56dd98b59e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556a03fc1a558b4b1ecb17d66b8c0b74/" rel="bookmark">
			设置TOMCAT SESSIONID 字符长度和生成算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改TOMCAT 默认的生成SESSION ID的算法和字符长度非常简单,只需修改context.xml中的&lt;Manager&gt;标签值,比如：
&lt;Manager sessionIdLength="20" pathname="SESSIONS.ser" maxActiveSessions="8000" secureRandomAlgorithm="SHA1PRNG" secureRandomClass="java.security.SecureRandom" maxInactiveInterval="60"
/&gt;
标红的部分不用我说大家也应该知道了，算法除了SHA1PRNG还有好几种,具体可以查看 JDK DOC的java.security.SecureRandom类章节.
更多配置见：http://tomcat.apache.org/tomcat-7.0-doc/config/manager.html
TOMCAT默认的SESSIONID生成器在高并发下可能产生些性能损失，因为采用了较为安全的随机数来生成SESSION的ID值。
实际上TOMCAT生成的SESSIONID是不可能有重复值的，查看TOMCAT源码文件:ManagerBase.java中的以下代码
/**
* Generate and return a new session identifier.
*/
protected String generateSessionId() {
String result = null;
do {
if (result != null) {
duplicates++;
}
result = sessionIdGenerator.generateSessionId();
} while (sessions.containsKey(result)); //此处保证最终生成给客户端使用的SESSIONID一定是不重复的
return result;
}
所以，不必担心SESSIONID的安全性，如果有更好的实现，可以修改相应代码用于特定项目中。
因此我们可以修改TOMCAT源码中的SessionIdGenerator.java生成ID的函数部分，比如采用 java.util.UUID+java.util.Random+(随机字符串)来构建更高效的生成SESSIONID的算法，或者自己实现相关部分等 等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2991d5afcad00302866d1fefc9ff59b/" rel="bookmark">
			2023年电赛---运动目标控制与自动追踪系统（E题）发挥题思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果有嵌入式企业需要招聘校园大使，湖南区域的日常实习，任何区域的暑假Linux驱动实习岗位，可C站直接私聊，或者邮件：zhangyixu02@gmail.com，此消息至2025年1月1日前均有效
前言 （1）因为博客编辑字数超过1W字会导致MD编辑器非常卡顿。所以我将发挥题和基础题的思路拆开了。
（2）更新日记：
&lt;1&gt;2023年8月4日，9点20分。分离发挥题思路和基础题思路，增加了博主Huiyeee整体代码，增加关于红点被黑带吸收问题的调试方法
&lt;2&gt;2023年8月4日，15点55分。回答追小球代码中的目标值是那个。
关于红点被黑带吸收问题 让IDE上出现红点 （1）很多人反馈，红点被黑色矩形框吸收了，识别不到。
（2）这边推荐的调试办法如下：
&lt;1&gt;首要目的是让PC端的IDE上人们肉眼能够看到红色激光。所以外面要适当调整下面初始化部分代码。
&lt;2&gt;我们可以将RGB565改成GRAYSCALE的灰度图。
&lt;3&gt;适当提高图像分辨率，将QQVGA改成其他图像画质。
&lt;4&gt;设置亮度，因为是从OpenART移植过来的，所以亮度不能是3000。使用OpenMV的同学请注意，应该是-3到+3.
&lt;5&gt;曝光度可以按照另外一位博主的来。通过调整曝光度，可以控制图像的明暗程度，从而创造出不同的视觉效果。我们这里没有使用sensor.set_auto_exposure()函数设置曝光度，所以是默认打开了的。你们可以看看另外一位博主的思路和调整。
&lt;6&gt;我们图像识别要关闭白平衡和自增益。但是如果调节出来没结果。可以尝试打开看看有木有优化
# 初始化摄像头 sensor.reset() sensor.set_pixformat(sensor.RGB565) # 设置图像色彩格式为RGB565格式 sensor.set_framesize(sensor.QQVGA) # 设置图像大小为160*120 sensor.set_auto_whitebal(True) # 设置自动白平衡 sensor.set_brightness(3000) # 设置亮度为3000 sensor.skip_frames(time = 20) # 跳过帧 （3）注意，这一阶段只需要调整摄像头的初始化！！！PC端IDE出现了红色斑点再开始处理！！！
白平衡和自增益的作用 （1）关闭白平衡和自增益可能适用于以下场景：
&lt;1&gt;保持色彩一致性：在某些图像识别应用中，特别是涉及色彩信息重要性较高的场景，关闭白平衡可以保持图像中的色彩一致性。白平衡会根据不同光源调整图像颜色，这可能导致相同对象在不同光照条件下的颜色出现差异，影响识别的准确性。
&lt;2&gt;特定光照条件下的优化：在一些特殊环境中，如低光照条件或强烈光线照射的情况下，关闭自增益可以避免图像过度曝光或欠曝光。这样做可以保留图像中更多细节，有助于图像识别算法更好地处理图像。
&lt;3&gt;原始数据分析：在某些图像分析应用中，关闭白平衡和自增益可以使用原始的传感器数据进行分析，而不受相机的颜色处理和亮度调整影响。这可以提供更纯粹、更原始的数据，有助于一些特定图像处理和识别算法的优化。
（2）需要注意的是，关闭白平衡和自增益也可能导致一些挑战，比如图像中的颜色信息可能会出现较大的变化，而且在某些场景下可能需要更复杂的图像处理算法来应对不同光照条件下的挑战。因此，在图像识别应用中是否关闭白平衡和自增益需要根据具体的情况和应用场景进行权衡和决策。
发挥题思路 第一问 — 追踪 （1）我个人认为这个必须上PID了。我个人认为这个题目和OpenMV的追小球云台代码类似。
（2）基础题目我认为一个OpenMV就可以完成。而发挥题目需要两个OpenMV。这两个OpenMV一个放红色激光笔，一个放绿色激光笔。
（3）各位可以综合追小球云台的代码，以及我下面讲的：关于C站那位博主代码的注意事项 部分。
（4）追踪的绿色激光笔建议。
&lt;1&gt;变成灰度图，这样可以消除其他颜色的干扰，只观察红色。然后追踪。
&lt;2&gt;提高分辨率，较高的分辨率，能够提供更好的效果。
&lt;3&gt;使用多组颜色阈值，就像OpenMV多颜色识别详解的代码那样。让识别的颜色阈值变成多组。提高分辨效果。
第二问 — 追踪和走基础题3，4问 如果基础题做出来了，以及发挥题的追踪做出来了。那么就直接用基础题的红色激光笔走，然后发挥题追踪。这个和上面的代码应该是差不多的。
第三问 — 暂停键 这个我还是建议自己焊接一个按键，并联一个104的电容，进行硬件方面的按键消抖。然后自己写逻辑代码。
main.py （1）以下为官方的追小球云台代码，我增加了中文注释。
（2）因为GitHub是在外网，所以我直接复制过来了。但是总是有一些网友，硬要官方的GitHub链接。我也贴到了前言部分。
代码 import sensor, image, time from pid import PID from pyb import Servo #从内置pyb导入servo类，也就是舵机控制类 pan_servo=Servo(1) #定义两个舵机，对应P7引脚 tilt_servo=Servo(2) #定义两个舵机，对应P8引脚 pan_servo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2991d5afcad00302866d1fefc9ff59b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2fa23a09436be088bb65bb133603882/" rel="bookmark">
			2023年电赛---运动目标控制与自动追踪系统（E题）OpenART mini的代码移植到OpenMV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果有嵌入式企业需要招聘校园大使，湖南区域的日常实习，任何区域的暑假Linux驱动实习岗位，可C站直接私聊，或者邮件：zhangyixu02@gmail.com，此消息至2025年1月1日前均有效
前言 （1）已经有不少同学根据我上一篇博客完成了前三问，恭喜恭喜。有很多同学卡在了第四问。
（2）我说了OpenART mini的代码是可行的。但是他们不会移植到OpenMV上，再次我讲移植之后的代码贴出来。
（3）吐槽一下，我就看不懂了。为啥这么多人移植不了。这不是几分钟的事情吗？（苦笑）
识别矩形框以及对应角点 （1）这个地方的40行会出现一个奇怪的报错，说corner没有被定义。但是前面明明调用corner = r.corners()进行了一波定义。
（2）然后我在在前面写上了一句corner = 0，报错就消失了。这个bug很奇怪。希望各位注意
from machine import Pin import sensor, image, time import pyb #import seekfree, pyb # 初始化TFT180屏幕 #lcd = seekfree.LCD180(3) # 初始化摄像头 sensor.reset() sensor.set_pixformat(sensor.RGB565) # 设置图像色彩格式为RGB565格式 sensor.set_framesize(sensor.QQVGA) # 设置图像大小为160*120 sensor.set_auto_whitebal(True) # 设置自动白平衡 sensor.set_brightness(3000) # 设置亮度为3000 sensor.skip_frames(time = 20) # 跳过帧 clock = time.clock() corner = 0 while(True): clock.tick() img = sensor.snapshot() # -----矩形框部分----- # 在图像中寻找矩形 for r in img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2fa23a09436be088bb65bb133603882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2bed58ff3363e8ac68893e3beb0f0a5/" rel="bookmark">
			2023年电赛---运动目标控制与自动追踪系统（E题）OpenMV方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果有嵌入式企业需要招聘校园大使，湖南区域的日常实习，任何区域的暑假Linux驱动实习岗位，可C站直接私聊，或者邮件：zhangyixu02@gmail.com，此消息至2025年1月1日前均有效
前言 （1）废话少说，很多人可能无法访问GitHub，所以我直接贴出可能要用的代码。此博客还会进行更新，先贴教程和代码
（2）
&lt;1&gt;视频教程： https://singtown.com/learn/49603/
&lt;2&gt;OpenMV追云台官方Github链接 ：https://github.com/SingTown/OpenMV-Pan-Tilt/tree/master/pan-tilt/src
（3）有些人肯定说红点太小了，OpenMV不行精度不够，看这个C站上做出来的阈值代码：https://blog.csdn.net/weixin_52385589/article/details/126334744
（4）赛事方肯定不可能直接让你上现成的玩意，不然比赛的意义在哪里？我看了一下网上的一些讨论。肯定是要用摄像头的，K210好像有官方库，K210的同学可以了解一下。
（5）OpenMV的话需要多训练，建议最好做灯光补偿，毕竟OpenMV对灯光要求很高，环境光线一点要稳定！！！
注意：有网友反馈，官方说不能使用灯光补偿。我没得到相关信息，请各位确认之后再决定要不要使用灯光补偿。
（6）各位，有问题尽量C站私信。因为评论太多了，我容易漏掉。（虽然写评论区可以给我加热度，哭）
（7）这篇博客是会根据情况实时更新的，所以请各位注意刷新。
（8）再次强调，提供的都是伪代码！！！肯定会报错！！！要自己调整！！！我只提供思路，饭都端上来了，还不能吃吗？！
（9）更新日记：
&lt;1&gt;2023年8月2日，上午9点。OpenMV官方的追云台代码，以及相关解读。
&lt;2&gt;2023年8月2日，上午10点。增加C站另一位大佬的调试结果代码。
&lt;3&gt;2023年8月2日，下午2点。更改错别字，增加基础题思路。
&lt;4&gt;2023年8月2日，下午2点10分。增加网友的一些提问。
&lt;5&gt;2023年8月2日，下午2点40分。更改了前言部分，希望各位问问题私信我，因为写在评论区有时候会被刷新掉。
&lt;6&gt;2023年8月2日，下午2点50分。更新了基础题的思路，第四问还有待商榷。
&lt;7&gt;2023年8月2日，下午3点。更新了网友的一些问题
&lt;8&gt;2023年8月2日，下午3点40分。关于OpenMV的鱼眼畸变可能带来的问题，增加了软硬件解决方案。
&lt;9&gt;2023年8月2日，下午4点35分。关于代码报错问题回复，器件选择问题。
&lt;10&gt;2023年8月2日，下午5点30分。更新关于购买推荐的OpenMV云台可能导致的问题，以及据说可行的现成方案。
&lt;11&gt;2023年8月2日，下午6点。更新鱼眼畸变代码报错问题，基础题的第一问和第二问代码给出来了
&lt;12&gt;2023年8月2日，下午6点20分。更新了关于博客视频的资料在哪里，关于代码怎么获取。
&lt;13&gt;2023年8月2日，下午6点40分。关于K210，OpenART mini，OpenMV代码问题回答。
&lt;14&gt;2023年8月2日，下午7点30分。回答网友，舵机抽搐问题，OpenMV与主控通讯，第一问和第二问舵机控制不稳定。
&lt;15&gt;2023年8月2日，下午9点20分。更新推荐舵机，数字舵机比模拟舵机精度更高。
&lt;16&gt;2023年8月3日，12点睡觉前最后一次更新。关于激光和OpenMV安装位置。
&lt;17&gt;2023年8月3日，9点50分。更新了OpenART mini移植到OpenMV的方案，将网友回答专门组成了一篇博客。
&lt;18&gt;2023年8月3日，10点30分。更新发挥题目思路。
&lt;19&gt;2023年8月3日，11点30分。将目前反馈可行方案放在了最醒目的地方。
&lt;20&gt;2023年8月4日，9点20分。将基础题第三问进行了微调。将基础题和发挥题分离。发挥题还在补充思路，基础题也会在中午前补充完思路。请不要着急。
&lt;21&gt;2023年8月4日，10点30分。基础题的所有测试思路都给出来了，伪代码也给了，硬件测试思路也给了，还做不出来，真的就一点救都没有了。
网上所宣传的现成可行方案 OpenART mini的同学看这个 （1）我看网上有人说OpenART mini有一个现成的方案。如果会OpenART mini的同学，可以尝试。以下是这个资料
（2）百度网盘资料：
OpenART min模块资料链接：https://pan.baidu.com/s/1yoCNXzci_dfHzW33emxdLA
提取码：mxx8
（3）关于云台控制：
&lt;1&gt;云台由两个舵机组成，下面的舵机控制偏航角(左右)旋转，上面的舵机控制俯仰角(上下)旋转。
&lt;2&gt;如果在云台上面安装一个激光发射装置，当我们控制单个舵机旋转时，观察激光路径发现是一条直线，并且云台的两个舵机路径分别是一个水平和一个垂直的直线，如果我们同时控制两个舵机旋转的舵机就可以实现在一个面的任意位置激光投影。
&lt;3&gt;若此时我们需要控制舵机按照设定的固定路径移动，当路径为线段时，仅需要知道线段的起点坐标和终点坐标即可(坐标对应舵机的高电平时间,也就是占空比)，如果直接将起点和终点输出到云台舵机，会发现虽然到达了起点和终点，但路径并非直线路径，这是由于X轴和Y轴移动距离不一致而产生的，因此需要将这条线段细分，比如通过起点坐标和终点坐标将线段细分为1000份，每次仅移动一份的距离，此时就会发现激光的路径沿着线段逐渐移动了。
&lt;4&gt;如果需要移动的路径为一个闭合矩形，我们仅需得到矩形的四个角的坐标，按照上面线段的分段移动的方式，分别将四条边细分后再控制舵机逐渐移动，即可实现看起来较为丝滑的闭合矩形路径。
&lt;5&gt;在编写控制程序时，如果采用这样分段移动的方式，那么我们可以将程序段放置在周期中断内执行，此时就可以确立单次移动的时间，从而控制整体的移动速度。移动速度的控制是必须的，不管是路径稳定还是点位追踪都需要涉及到移动速度的精准控制。
（4）E题中所涉及到的主控型号赛题没有任何限制，可以使用智能车竞赛中的核心板（例如RT1064、TC264、CH32V307、STC），其中RT1064主板有三个舵机接口，可以比较方便控制云台，激光也没有限制，只要求了光斑大小小于等于1厘米即可。
（4）关于这个方案的相关影像资料：
1
2
5
4
6
OpenMV的同学看这个 点开这个链接：2023年电赛—运动目标控制与自动追踪系统（E题）OpenART mini的代码移植到OpenMV
硬件注意事项 接线问题 （1）我们这里是使用的OpenMV的P8和P7引脚。所以建议引脚如下图引出。
（2）舵机一般是5V供电，所以注意VCC是供5V的电压。而右边那两个GND和VCC是连接OpenMV的。如果右边的VCC是连接OpenMV的VIN引脚，就可以供5V电。如果是连接OpenMV的3.3V引脚，iu只能供3.3V电压。否则OpenMV会被烧掉！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2bed58ff3363e8ac68893e3beb0f0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f77444c4442c330da860eb991bcbcd/" rel="bookmark">
			疑问：相同Service ID、不同Instance ID的SOME/IP服务如何被使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我的一个疑问，向各位朋友请教，请帮忙留意回复一下，感谢！
在SOME/IP中，Service ID是用来识别和标记哪个服务，Instance ID是用来识别和标记某个服务的哪个实例。
既然是相同的服务，这个服务提供的Method、Set Field、Get Field的方法应该是一样的。结合SOME/IP的数据结构，其中没有包含Instance ID的信息，也就是说，在服务调用的时候，服务消费者是没有指定哪个Instance ID的。可以这样理解吗？对应不同的Instance ID，它们提供的服务调用都是相同的。
只有在SD的Entry里找到Instance ID的信息：
FindService、OfferService里的Instance ID可以标识不同的服务实例，一个ECU节点能有相同服务的不同实例吗（Instance ID不同）？如果可以，在开发这个服务的时候，Method、Field操作的服务调用都是相同的，这样不同实例在开发的时候差异是什么呢？只体现在SubscribeEventGroup进行事件订阅上吗？是不是意味着，不同的实例它们的差别只是在EVENT和Notifier上？
在网上查询到：
举个例子，假设有一个车辆的故障诊断服务，它提供了相同类型的故障码查询功能。不同的车辆可能拥有不同的实例，每个实例代表不同的车辆。这些实例的Method实现应该相同，因为它们提供的是相同的故障码查询服务。但是，对于Event（事件）和Notification（通知）方面，由于每辆车的故障情况可能不同，因此Event和Notification的实现需要根据实际情况进行单独的处理。
但是没有理解，这个说明是把每个车辆单做不同的服务实例，用Instance ID做为了节点的标识。那么，有没有在相同节点上有相同服务的不同实列的情况呢？在什么情况下使用？开发时有什么差异？
希望有朋友能帮忙解答疑惑！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab2d8a9a5cf814305c45b48a6071f0e/" rel="bookmark">
			项目实战 — 博客系统③ {功能实现}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、编写注册功能
🍅 1、使用ajax构造请求（前端）
🍅 2、统一处理
🎄 统一对象处理
🎄 保底统一返回处理 🎄 统一异常处理
🍅 3、处理请求
二、编写登录功能
🍅 1、使用ajax构造请求
🍅 2、处理请求
🎄 创建实体类
🎄 添加接口方法
🎄 service层
🎄 controller：处理请求并返回
三、编写博客列表页面
🍅 1、SessionUtils
🍅 2、处理请求
🍅 3、使用ajax构造请求
三、编写注销功能
🍅 1、使用ajax获取请求
🍅 2、处理请求
四、编写删除文章功能
🍅 1、使用ajax构造请求
🍅 2、处理请求
🎄 mapper层：接口方法
🎄 service层
🎄 controller层：处理请求
五、编写文章添加功能
🍅 1、使用ajax构造请求
🍅 2、处理请求
🎄mapper层：添加接口方法
🎄service层：返回受影响行数
🎄 controller：处理添加文章的请求
六、修改功能：查询到修改的文章
🍅 1、通过ajax构造请求
🍅 2、处理请求
🎄Mapper层：添加接口
🎄service层
🎄controller层
七、修改功能：修改查询到的文章
🍅 1、通过ajax构造请求 🍅 2、处理请求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eab2d8a9a5cf814305c45b48a6071f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ee36b4be1e5b7e63d9c7f4dd4b8760/" rel="bookmark">
			（python）求e的近似值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自然常数e可以用级数1+1/1!+1/2!+⋯+1/n!来近似计算。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬
本题要求对给定的非负整数n，求该级数的前n项和。
解决代码如下：
n=eval(input()) e=1 divisor=1 for i in range(1,n+1): divisor *= i e=e+1/divisor print("{:.8f}".format(e)) #或 import math n=int(input()) e = sum(1/math.factorial(i) for i in range(n+1)) print("{:.8f}".format(e)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d51dd1c3fe64460bf7bed6ccb4ee1cd/" rel="bookmark">
			（python）最大公约数和最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在两行中分别输入一个正整数M,N，输出这两个数的最大公约数和最小公倍数。
解决代码如下：
import math num1 = int(input()) num2 = int(input()) m = int(input()) n = int(input()) gys = 1 if m &gt; n: m, n = n, m for i in range(n, 0, -1): if n % i == 0 and m % i == 0: gys = i break print(gys, m * n // gys) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a4f9d2b0446805099c8abd9f34be36/" rel="bookmark">
			（python）判断IP地址合法性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 每个合法的IP地址由'.'分隔开的4个数字组成，每个数字的取值范围是0-255。 现在用户输入一个字符串 s (不含空白符，不含前导0，如001直接输入1)，请你判断 s 是否为合法IP，若是，输出'Yes',否则输出'No'。
解决代码如下：
def f(s): lists = s.split('.') if len(lists) != 4: return 'No' for i in range(4): try: tmp = int(lists[i]) if tmp not in range(0, 256): return 'No' except: return 'No' return 'Yes' ip = input() print(f(ip)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225ba4bb4d280ca366b4ea46c9e39a07/" rel="bookmark">
			css_按钮_Button_样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H5代码 &lt;!DOCTYPE HTML&gt; &lt;html lang="en-US"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;36种漂亮的CSS3网页按钮Button样式&lt;/title&gt; &lt;style type="text/css"&gt; body{ background: #f5faff; } .demo_con{ width: 960px; margin:40px auto 0; } .button{ width: 140px; line-height: 38px; text-align: center; font-weight: bold; color: #fff; text-shadow:1px 1px 1px #333; border-radius: 5px; margin:0 20px 20px 0; position: relative; overflow: hidden; } .button:nth-child(6n){ margin-right: 0; } .button.gray{ color: #8c96a0; text-shadow:1px 1px 1px #fff; border:1px solid #dce1e6; box-shadow: 0 1px 2px #fff inset,0 -1px 0 #a8abae inset; background: -webkit-linear-gradient(top,#f2f3f7,#e4e8ec); background: -moz-linear-gradient(top,#f2f3f7,#e4e8ec); background: linear-gradient(top,#f2f3f7,#e4e8ec); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/225ba4bb4d280ca366b4ea46c9e39a07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/406c8319cdb211759a8a6e0e58dd8742/" rel="bookmark">
			【运维】【NFS】 频繁卡死 ｜NFSv3 迁移到 NFSv4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 基础知识（和NFSv3的区别）2. 迁移流程1. 知道哪些目录需要迁移2. 选择一个目录作为 NFSv4 虚拟根目录3. 数据迁移4 修改/etc/exports5 客户端 mount 3. 总结 前言 之前实验室的 NFS 频繁卡死，在网上又找不到对应的文章来解决问题，之后改为NFSv4 解决了这个问题（同时又无文章介绍 NFS v4 的迁移）。。
本文主要介绍一个解决NFS频繁卡死的问题
迁移到 NFSv4实验环境为 Ubuntu 关于NFSv3 如何 迁移到 NFSv4 有一个粗略的外文版本，大家可以参考：
https://community.hpe.com/hpeb/attachments/hpeb/itrc-156/354601/1/329228.pdf
以下是鄙人实践的总结，供大家参考
1. 基础知识（和NFSv3的区别） 首先 NFSv4 只能有一个根目录，和NFSv3 不同
如： 在NFSv3中，我们可以随便写 /etc/exports 文件
/home/nfs1 *(rw,sync,no_subtree_check,no_root_squash) /home/nfs2 *(rw,sync,no_subtree_check,no_root_squash) 但是在NFSv4 中，只能有一个根目录，意味着我们的目录必须按如下结构组织（/srv/nfs 为根目录）
/srv/nfs/ /src/nfs/nfs1/ /src/nfs/nfs2 那么怎么让之前的目录迁移到下面目录呢？，把目录内容移动过去当然是一种方法，但是后面实践时我会介绍一种更便捷的方法
2. 迁移流程 迁移分为 5 步
1. 知道哪些目录需要迁移 2. 选择一个目录作为 NFSv4 虚拟根目录 3 将数据迁移到 虚拟根目录中 （有两种方法） 4 修改/etc/exposts 5 客户端 mount 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/406c8319cdb211759a8a6e0e58dd8742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9395d3db492a9e1ca6a048f00965737/" rel="bookmark">
			网络入门基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
计算机网络背景
网络发展
认识协议
协议的制订
网络协议详解
协议分层
OSI七层模型
TCP/IP模型
网络传输的基本流程
局域网通信
跨网络通信
网络中的地址管理
IP地址
MAC地址
计算机网络背景 网络发展 独立模式：计算机之间相互独立
在早期的时候，计算机之间是相互独立的，此时如果多个计算机要协同完成某种业务，那么就只能等一台计算机处理完后再将数据传递给下一台计算机，然后下一台计算机再进行相应的业务处理，效率非常低下。 网络互联：多台计算机连接在一起，完成数据共享 局域网LAN: 计算机数量更多了, 通过交换机和路由器连接在一起
后来这样的网络雏形逐渐发展，连入这个网络中的机器变得越来越多，于是就出现了局域网的概念。在局域网中有一种设备叫做交换机，交换机主要完成局域网内数据的转发工作，也就是在局域网内将数据从一台主机转发给另一台主机。各个局域网之间通过路由器连接起来，路由器主要完成数据的路由转发工作。 广域网WAN: 将远隔千里的计算机都连在一起
各个局域网之间通过路由器相互连接在一起，便组成了一个更大的网络结构，我们将其称之为广域网。实际局域网和广域网是一种相对的概念，我们也可以将广域网看作一个比较大的局域网。 认识协议 “协议”本质就是一种约定，通信双方只要曾经做过某种约定，之后就可以使用这种约定来完成某种事情。而网络协议是通信计算机双方必须共同遵从的一组约定，因此我们一定要将这种约定用计算机语言表达出来，此时双方计算机才能识别约定的相关内容。
计算机之间的传输媒介是光信号和电信号. 通过 "频率" 和 "强弱" 来表示 0 和 1 这样的信息. 要想传递各种不同的信息, 就需要约定好双方的数据格式。
比如通信计算机双方曾经做过如下约定：
如果code的值为1，则表示需要将data的值存储进数据库。如果code的值为2，则表示需要将data的值写入日志信息。如果code的值为3，则表示需要将data的值进行打印输出。 就是一个位段结构，我们是可以通过位段来表示某种协议规定的，而实际上计算机网络里面的协议报头也就是通过位段来实现的。
我们有了这样的约定后，当甲计算机向乙计算机发送类似于{1, 0x1234}的数据时，乙计算机识别到code的值是1，于是就知道了甲计算机是让自己将data的值存储进数据库，这是一种纯软件的约定方案。
协议的制订 在当前这个互联网时代，计算机生产商有很多，计算机操作系统也有很多，计算机网络硬件设备更是多种多样，那我们是如何让这些不同厂商之间生产的计算机能够相互顺畅的通信的呢？这时候就需要有人站出来，约定一个共同的标准，并且让大家都来遵守这个标准，这就是网络协议。
而那个站出来的人一定是该领域当中的佼佼者，因为网络协议的定制本质就是规则的定制，你要站出来制定规则那么一定要同行业的其他人都认可你。比如5G标准的定义，华为就是那个站出来的人，华为在通信领域已经具备很强的通信能力了，在这个行业里它就是所谓的佼佼者。
正所谓“一流的企业做标准，二流的企业做品牌，三流的企业做产品”。但是标准的定制有一部分是公益性、开源性的，它制定标准的目的是为了让我们的世界变得更好；而标准的定制还有一部分是具有一定盈利性质的，当你需要使用这项技术时就会收取部分专利费，此时就能将曾经做的技术投入进行变现。 网络协议详解 协议分层 协议分层的好处
网络协议栈设计成层状结构，其目的就是为了将层与层之间进行解耦，保证代码的可维护性和可扩展性。
比如在打电话的时候，站在工程师的角度实际这两个人并不是直接进行沟通的，而是甲的电话将甲说的话记录下来，经过一系列编码转码后，通过通信网络将信息从甲的电话传递到了乙的电话，然后信息在乙的电话中再经过对应的编码转码，最后乙才通过话筒听到了甲所说的话。
其中，人与人之间通信使用的是汉语，我们可以将其称为语言层；而电话和电话之间通信使用的是电话系统相关的一些接口，我们可以将其称之为通信设备层。
后来随着科技的发展，我们都用上了智能手机，此时我们下层使用的通信设备变了，或是这部电话卖到了其他国家，此时上层使用的通信语言变了，但我们仍然可以正常沟通。
分层最大的好处在于“封装”，在分层情况下，将某层的协议进行替换后，通信双方之间是不会受到影响的。
理解各层之间直接通信
从上述例子我们还可以看出，虽然在打电话时我们并不是直接进行沟通的，但是我们可以认为我们是在直接进行沟通，并且这两台电话也不是直接在进行沟通的，数据经过电话后，还需要各种基站，各种电信网络来进行数据转发，但是这两台电话依旧可以认为是直接在和对方电话进行通信的。
因此对于网络协议我们需要有一个基本的认识：关于通信，同层协议可以认为自己在和对方层直接进行通信，从而达到简化对于网络协议栈的理解。
也就是说，在网络协议栈中我们可以认为通信双方的应用层之间直接在进行通信，也可以认为通信双方的传输层之间直接在进行通信，对于网络层和数据链路层也同样如此。
OSI七层模型 上面我们说的是TCP/IP四层协议，而实际当初那个站出来的人定的协议叫做OSI七层协议：
OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机OSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整。通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯但是它既复杂又不实用，所以我们按照TCP/IP四层模型来讲解。 OSI七层模型如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9395d3db492a9e1ca6a048f00965737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b5f6f981990bcceef72dd02ca50886/" rel="bookmark">
			PVE GPU Pass Through（pve显卡直通）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题记录2023-8-31
显卡直通
原理和流程
最底层开启VT（虚拟化技术）
PVE设置
上传镜像
创建虚拟机windows
虚拟系统驱动
问题记录2023-8-31 近期遇到添加的显卡的虚拟机启动不起来 状态如下
状况1：虚拟机的控制台一直处于这种状态 虚拟机运行状态是黄色感叹号⚠️
状况2：虚拟机的控制台显示guest has not initialzed the display (yet) 虚拟机运行状态是黄色感叹号⚠️
排查过程中发现在硬件中把pci的显卡给去掉后就可以正常运行。问题锁定显卡直通存在问题，然后在网上查到一个帖子，说其实7.0后就不用设置这么多配置和参数了，只需要
/etc/default/grub文件
#找到： GRUB_CMDLINE_LINUX_DEFAULT="quiet"
#然后修改为： GRUB_CMDLINE_LINUX_DEFAULT="quiet intel_iommu=on iommu=pt"
修改完配置文件后执行update-grub更新一下grub配置文件
至此问题解决。
显卡直通 原理和流程 最底层：打开主机Bios下的最底层直通开关VT-D；
PVE系统层：打开PVE系统的IOMMU支持，大概意思是PVE系统级别的开关；
PVE系统层：关闭PVE系统对显卡的调用，腾出来给虚拟机用；
虚拟机层：配置要用显卡的虚拟机，让他去调用显卡；
虚拟系统层：让Windows系统装上显卡的驱动，让虚拟机系统能调用下卡；
最底层开启VT（虚拟化技术） 最底层：打开主机Bios开启VT（Virtualization Technology）
由于不同品牌主机开启VT的方法不同 请自行百度
PVE设置 进入pve命令行界面
修改/etc/default/grub文件
并在里面找到GRUB_CMDLINE_LINUX_DEFAULT="quiet" 这一行 将这一行替代成，目的是开启底层的硬件直通功能
GRUB_CMDLINE_LINUX_DEFAULT="quiet intel_iommu=on iommu=pt video=efifb:off,vesafb:off" 注意 如果是AMD的处理器是不一样的内容，
添加完毕后，我们更新一下grub配置文件 输入命令 update-grub
然后找到配置文件/etc/modules 在结尾添加内容，打开pci硬件的直通
vfio vfio_iommu_type1 vfio_pci vfio_virqfd 上述就完成了PVE层的PCI直通设置，加下来我们将PVE系统禁止加载显卡驱动，目的是不与需要显卡直通的虚拟机冲突争夺HDMI通道，找到这个路径
/etc/modprobe.d/ pve-blacklist.conf 添加一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b5f6f981990bcceef72dd02ca50886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1700f10962987dfb28900494be2f9a8c/" rel="bookmark">
			css预编译器： center；}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS预编译器是一种用于构建CSS的工具，它可以将CSS代码转换为更易于管理和维护的格式。它们可以使CSS代码更加灵活，更易于重用，并且可以帮助开发人员更轻松地组织和管理CSS代码。
CSS预编译器是一种用于构建CSS的工具，它可以将CSS代码转换为更易于管理和维护的格式。它们可以使CSS代码更加灵活，更易于重用，并且可以帮助开发人员更轻松地组织和管理CSS代码。
CSS预编译器通常会使用一种特定的语法，这种语法可能与原生CSS语法不同。例如，SASS（Syntactically Awesome Style Sheets）是一种流行的CSS预编译器，它使用一种称为SCSS（Sassy CSS）的语法，这种语法比原生CSS语法更加灵活。
下面是一个使用SASS的示例：
// SCSS
$primary-color: #F00;
.btn {
background-color: $primary-color;
font-size: 16px;
padding: 10px;
}
// CSS
.btn {
background-color: #F00;
font-size: 16px;
padding: 10px;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3d6bf1fe5c3ded7d4b5253c791bf2f/" rel="bookmark">
			csgo如何显示帧数(含代码示例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSGO可以通过控制台命令来显示帧数，代码如下：打开CSGO游戏，按下“~”键打开控制台；
CSGO可以通过控制台命令来显示帧数，代码如下：
1. 打开CSGO游戏，按下“~”键打开控制台；
2. 在控制台输入“cl_showfps 1”，即可开启帧数显示；
3. 若要关闭帧数显示，只需在控制台输入“cl_showfps 0”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17df2d5429d3cb83fa595c5815055b3/" rel="bookmark">
			linux 软链接 硬链接概念与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例示例Linux 软链接：软链接是一种特殊的文件，它允许用户在不同目录中创建多个同名文件的快捷方式。软链接可以通过 ln 命令创建，它会在指定的目录中创建一个指向另一个文件的软连接。
Linux 软链接：
软链接是一种特殊的文件，它允许用户在不同目录中创建多个同名文件的快捷方式。软链接可以通过 ln 命令创建，它会在指定的目录中创建一个指向另一个文件的软连接。
示例代码：
ln -s /home/user/file.txt /home/user/link.txt
Linux 硬链接：
硬链接是一种特殊的文件，它允许用户在同一个文件系统中创建多个同名文件的快捷方式。硬链接可以通过 ln 命令创建，它会在指定的目录中创建一个指向另一个文件的硬连接。
示例代码：
ln /home/user/file.txt /home/user/link.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf83ce9c420bdcde2a6ac7440eb67353/" rel="bookmark">
			uni 组件样式被公共样式覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 组件默认字体颜色白色 改变主题背景默认色会跟随改变 设置组件字体颜色也会被覆盖
设置scoped 加上::v-deep &lt;style scoped lang="stylus"&gt; ::v-deep .checklist-box.is-checked .checklist-text { color: #ffffff !important; } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c87f1199e8e70c088e032182828b10/" rel="bookmark">
			FreeRTOS的信号量和互斥量之间的区别和联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 信号量信号量简介信号量特征 互斥量互斥量的上锁机制互斥量的优先级继承机制 二值信号量和互斥量的作用二值信号量的作用互斥量的作用 二值信号量和互斥锁关系相同点不同点 如何根据场景选择回答信号量和互斥锁之间的区别： 信号量 信号量简介 队列(queue)可以用于传输数据：在任务之间、任务和中断之间，消息队列用于传输多个数据，占用时间按也相对较长，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，一般是用作同步的效果
所有的信号量的本质的都是特殊的队列(特殊：信号量只有队列头部，并没有后面的环形存储区，也就是说信号量只负责消息传递，并不传递数据)信号量用来进行共享资源的管理和任务同步【ps：信号量里面的二值信号量用于同步】
信号量特征 信号量这个名字，我们可以把它拆分来看，信号可以起到通知信号的作用，然后我们的量还可以用来表示资源的数量，当我们的量只有0和1的时候，它就可以被称作二值的信号量，只有两个状态，当我们的那个量没有限制的时候，它就可以被称作为计数型信号量。 信号量也是队列的一种
因为队列创建的时候，需要传入队列的长度以及队列的大小，而我们的信号量其实就是一种特殊的队列，只不过它的大小是0，毕竟我们的信号量是不需要传递数据，只需要传递信号，然后长度是N，当N=1的时候就是二值信号量，他就只有0和1两个状态，这里的0和1两个状态是指被填入和被拿走这两个状态，当N&gt;1时，就是我们的计数信号量，他也不传递数据，只是传递一个数量值，一般是记录我们设备的资源数量 二值信号量：
二值信号量其实就是一个长度为1，然后大小为零的队列，然后它的状态只有0和1两种状态，也就是被写入和被取走的两种状态，通常情况下，我们用它来进行数据同步，就像平时在程序中设置的那个变量flag 计数信号量：
计数信号量其实就是二指信号量的升级版，那只是信号量只有0和1两种状态，而我们的这个就有很多种状态，通常情况下是用来记录系统的资源，就比如说我们记录一个车库里的辆车，每当有人来停车或者取车的时候他的数量都会进行对应的加减，我们就可以很轻松的看到我们车库的状态，然后也知道车库里面有几辆车 互斥量 互斥量的上锁机制 由于上面的那种情况导致我们的二值信号量，通常都是用来进行数据的同步一个负责发送数据，然后一个负责同步数据，而互斥量，其实它更像一个上锁的机制，两个任务需要公用一个资源，所以我们可以把互斥量又叫做互斥锁 互斥量的优先级继承机制 互斥量的出现就是去弥补二值信号量的缺点，使得上锁的低优先级的任务可以先运行，然后是有锁的高优先级的任务，最后才是中间优先级的任务 优先级继承机制：上锁期间其他任务无法进行抢占
二值信号量和互斥量的作用 二值信号量的作用 同步：中断与任务之间使用信号量来完成同步，同样，任务与任务之间也可以使用信号量来完成同步。
共享资源管理：二值信号量也可以用于共享资源的管理。举个例子一个共享资源，一次只能一个任务使用且只有使用和未使用两种状态。使用共享资源的两个状态作为信号量的话，那么这就是二值信号量。
互斥量的作用 互斥量（mutex）又称互斥信号量，是一个特殊的二值信号量，可以通过它来确保执行流在代码关键区互相排斥，从而对共享资源进行独占式处理。互斥量是二进制信号量的一个变种，开启互斥量需要在头文件FreeRTOSConfig.h中设置configUSE_MUTEXES为1。任意时刻互斥量的状态只有两种，开锁或闭锁。 二值信号量和互斥锁关系 相同点 （1）同为用于多线程（任务）条件同步的机制
（2）都可用于对共享资源的保护
不同点 （1）优先级反转问题
互斥量和二值信号量最大的区别就是：互斥量具有优先级继承。例如，低优先级的任务A持有互斥量的时候，优先级高的任务B开始尝试获得这个锁。但是任务B无法获取互斥量而进入阻塞状态。正在使用互斥量的任务A会临时将优先级提升到任务B的优先级。这个优先级提升的过程就是优先级继承。这个机制用于确保高优先级任务进入阻塞状态的时间尽可能地短。
实例：
互斥量的出现就是去弥补二值信号量的缺点，使得上锁的低优先级的任务可以先运行，然后是有锁的高优先级的任务，最后才是中间优先级的任务
（2）应用的优势场景不同：
二值信号量更适合用于用于任务与任务或中断与任务之间的同步，互斥量更适合用于互斥，用于保护保护只能有一个任务访问的共享资源。
互斥量不能用于中断服务程序中，信号量可以。因为互斥可能会阻塞，但是中断不能阻塞等待；而且互斥量有优先级继承机制，只有互斥量从任务中释放和获取时才有意义，而不是中断。
（3）使用API创建不同
如何根据场景选择 根据场景选择合适的同步机制
互斥量是包含优先级继承机制的二值信号量。二值信号量是实现同步（任务之间或任务和中断之间）的更好选择，而互斥量是实现简单互斥的更好选择，虽然互斥量也可以用于任务与任务之间、任务与中断之间的同步，但是互斥量更多用于保护共享资源的互锁。 根据优先级设计同步机制
因为二值信号量没有优先级继承继承，所以二值信号量相对适合优先级高的任务。 回答信号量和互斥锁之间的区别： 互斥量是一个特殊的二值信号量，特殊点在于互斥量具有优先级继承，优先级继承的特点是任务上锁期间其他任务无法进行抢占，这就导致上锁的低优先级的任务可以先运行，所以互斥锁的应用场景更多是在于保护公共资源，而二值信号量适合任务与任务或中断与任务之间的同步，因为在中断服务程序中，二值信号量不会阻塞，互斥量可能会阻塞。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b25277e3ee2e71c674fad84fe5e41f0/" rel="bookmark">
			金九银十如何抱佛脚？2023最新大厂 Java 面试真题合集（附完整答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023 秋招眼看着就要来了，但是离谱的是，很多同学最近才想起来还有秋招这回事，所以纷纷临时抱佛脚，问我有没有什么快速磨枪的方法，
我的回答是：有！
说起来，临阵磨枪没有比背八股文更靠谱的了，很多人对这个很不屑：呵，背题家罢了！
但国内大环境如此，你不背，你就找不到满意的工作，很现实的一个事情。当然，你可以选择出淤泥而不染，身体力行的表示反抗，对推动国内互联网陋习改革出一份力，那我还是很佩服的。
PS：家里无矿者建议慎重！
郑重承诺：
文中所有资料完全可白嫖，有需要的小伙伴看文末下方领取下载即可
这些面试资料都是我通过各种渠道收集到的大厂面试真题，并附有最新的权威答案，绝不是网络上那些已经是几年前甚至十几年前的面试题所能媲美的，除面试题外还有我整理的一些经典 Java 学习电子书也都可以无偿分享给大家，同学们可以对照着查漏补缺，争取早日上岸，拿到 offer 后别忘了回来给我点个赞。
这套面试题主要是针对 0-5 年左右的 Java 开发程序员提升的，不管是传统行业还是互联网行业，掌握这些技术基本都能拿到一个不错的薪资，希望对大家有所帮助。
面试资料
一、Java 基础 二、Java 异常 三、Java 集合 四、Java 并发 五、JVM 六、SSM 框架 Spring 框架
Spring MVC
Mybatis
七、MySQL 八、数据结构与算法 面试
力扣刷题笔记
九、Redis 十、计算机网络 十一、操作系统 十二、消息队列与分布式 学习资料
23 本 Java 学习核心书籍
数据结构与算法
JVM
Spring
MySQL
Redis
Linux
多线程
各大厂真题
深圳、上海、杭州、北京、广州真实 Java 面试题 北京-百度-Java 中级.pdf
北京-京东-Java 实习生.pdf
杭州-阿里云 Java 实习生.pdf
杭州-蚂蚁金服-Java 高级 pdf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b25277e3ee2e71c674fad84fe5e41f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/129fe406a02cc41dbb76225613048090/" rel="bookmark">
			2023全国大学生数学建模A题思路&#43;模型&#43;代码&#43;论文（比赛开始后持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.A题思路模型：9.7晚上比赛开始后，第一时间更新，获取见文末名片
3 全国大学生数学建模竞赛常见数模问题常见模型分类
3.1 分类问题
3.2 优化问题
详细思路见此名片，开赛第一时间更新
1.A题思路模型：9.7晚上比赛开始后，第一时间更新，获取见文末名片 2.比赛时间：2023年9月7日18点到2023年9月10日20点
3 全国大学生数学建模竞赛常见数模问题常见模型分类 优化模型
预测模型
评价模型
3.1 分类问题 判别分析：
又称“分辨法”，是在分类确定的条件下，根据某一研究对象的各种特征值判别其类型归属问题的一种多变量统计分析方法。
其基本原理是按照一定的判别准则，建立一个或多个判别函数；用研究对象的大量资料确定判别函数中的待定系数，并计算判别指标；据此即可确定某一样本属于何类。当得到一个新的样品数据，要确定该样品属于已知类型中哪一类，这类问题属于判别分析问题。
聚类分析：
聚类分析或聚类是把相似的对象通过静态分类的方法分成不同的组别或者更多的子集，这样让在同一个子集中的成员对象都有相似的一些属性，常见的包括在坐标系中更加短的空间距离等。
聚类分析本身不是某一种特定的算法，而是一个大体上的需要解决的任务。它可以通过不同的算法来实现，这些算法在理解集群的构成以及如何有效地找到它们等方面有很大的不同。
神经网络分类：
BP 神经网络是一种神经网络学习算法。其由输入层、中间层、输出层组成的阶层型神经网络，中间层可扩展为多层。RBF（径向基）神经网络：径向基函数(RBF-Radial Basis Function)神经网络是具有单隐层的三层前馈网络。它模拟了人脑中局部调整、相互覆盖接收域的神经网络结构。感知器神经网络：是一个具有单层计算神经元的神经网络，网络的传递函数是线性阈值单元。主要用来模拟人脑的感知特征。线性神经网络：是比较简单的一种神经网络，由一个或者多个线性神经元构成。采用线性函数作为传递函数，所以输出可以是任意值。自组织神经网络：自组织神经网络包括自组织竞争网络、自组织特征映射网络、学习向量量化等网络结构形式。K近邻算法：　K最近邻分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。
3.2 优化问题 线性规划：
研究线性约束条件下线性目标函数的极值问题的数学理论和方法。英文缩写LP。它是运筹学的一个重要分支，广泛应用于军事作战、经济分析、经营管理和工程技术等方面。建模方法：列出约束条件及目标函数；画出约束条件所表示的可行域；在可行域内求目标函数的最优解及最优值。
非线性规划：
非线性规划是具有非线性约束条件或目标函数的数学规划，是运筹学的一个重要分支。非线性规划研究一个 n元实函数在一组等式或不等式的约束条件下的极值问题，且 目标函数和约束条件至少有一个是未知量的非线性函数。目标函数和约束条件都是 线性函数的情形则属于线性规划。
整数规划：
规划中的变量（全部或部分）限制为整数，称为整数规划。若在线性模型中，变量限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法往往只适用于整数线性规划。一类要求问题的解中的全部或一部分变量为整数的数学规划。从约束条件的构成又可细分为线性，二次和非线性的整数规划。
动态规划：
包括背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等。
动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。
多目标规划：
多目标规划是数学规划的一个分支。研究多于一个的目标函数在给定区域上的最优化。任何多目标规划问题，都由两个基本部分组成：
详细思路见此名片，开赛第一时间更新 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd4ed9bd2f4a11a7d9a502cdcc23b49/" rel="bookmark">
			2023全国大学生数学建模C题思路&#43;模型&#43;代码&#43;论文（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.C题思路模型：9.7晚上比赛开始后，第一时间更新，获取见文末名片
3 全国大学生数学建模竞赛常见数模问题常见模型分类
3.1 分类问题
3.2 优化问题
详细思路见此名片，开赛第一时间更新
1.C题思路模型：9.7晚上比赛开始后，第一时间更新，获取见文末名片 2.比赛时间：2023年9月7日18点到2023年9月10日20点
3 全国大学生数学建模竞赛常见数模问题常见模型分类 优化模型
预测模型
评价模型
3.1 分类问题 判别分析：
又称“分辨法”，是在分类确定的条件下，根据某一研究对象的各种特征值判别其类型归属问题的一种多变量统计分析方法。
其基本原理是按照一定的判别准则，建立一个或多个判别函数；用研究对象的大量资料确定判别函数中的待定系数，并计算判别指标；据此即可确定某一样本属于何类。当得到一个新的样品数据，要确定该样品属于已知类型中哪一类，这类问题属于判别分析问题。
聚类分析：
聚类分析或聚类是把相似的对象通过静态分类的方法分成不同的组别或者更多的子集，这样让在同一个子集中的成员对象都有相似的一些属性，常见的包括在坐标系中更加短的空间距离等。
聚类分析本身不是某一种特定的算法，而是一个大体上的需要解决的任务。它可以通过不同的算法来实现，这些算法在理解集群的构成以及如何有效地找到它们等方面有很大的不同。
神经网络分类：
BP 神经网络是一种神经网络学习算法。其由输入层、中间层、输出层组成的阶层型神经网络，中间层可扩展为多层。RBF（径向基）神经网络：径向基函数(RBF-Radial Basis Function)神经网络是具有单隐层的三层前馈网络。它模拟了人脑中局部调整、相互覆盖接收域的神经网络结构。感知器神经网络：是一个具有单层计算神经元的神经网络，网络的传递函数是线性阈值单元。主要用来模拟人脑的感知特征。线性神经网络：是比较简单的一种神经网络，由一个或者多个线性神经元构成。采用线性函数作为传递函数，所以输出可以是任意值。自组织神经网络：自组织神经网络包括自组织竞争网络、自组织特征映射网络、学习向量量化等网络结构形式。K近邻算法：　K最近邻分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。
3.2 优化问题 线性规划：
研究线性约束条件下线性目标函数的极值问题的数学理论和方法。英文缩写LP。它是运筹学的一个重要分支，广泛应用于军事作战、经济分析、经营管理和工程技术等方面。建模方法：列出约束条件及目标函数；画出约束条件所表示的可行域；在可行域内求目标函数的最优解及最优值。
非线性规划：
非线性规划是具有非线性约束条件或目标函数的数学规划，是运筹学的一个重要分支。非线性规划研究一个 n元实函数在一组等式或不等式的约束条件下的极值问题，且 目标函数和约束条件至少有一个是未知量的非线性函数。目标函数和约束条件都是 线性函数的情形则属于线性规划。
整数规划：
规划中的变量（全部或部分）限制为整数，称为整数规划。若在线性模型中，变量限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法往往只适用于整数线性规划。一类要求问题的解中的全部或一部分变量为整数的数学规划。从约束条件的构成又可细分为线性，二次和非线性的整数规划。
动态规划：
包括背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等。
动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。
多目标规划：
多目标规划是数学规划的一个分支。研究多于一个的目标函数在给定区域上的最优化。任何多目标规划问题，都由两个基本部分组成：
详细思路见此名片，开赛第一时间更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a85d45763ae82a06faa672cfcbeb0e4/" rel="bookmark">
			液化气瓶充装追溯管理系统-燃气安全信息监管系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前，燃气已经成为了人们日常生活中不可或缺的重要能源。在城乡燃气普及的今天，如何有效监管燃气安全，保障人民生命财产安全，成为了燃气管理工作的重要任务。
为推动燃气安全治理模式向事前预防转型，加快建立城乡燃气安全长效机制，近日，河北省安委会发布了《河北省城乡燃气安全专项整治工作方案》，旭华智结合方案中的相关政策，进一步完善了城乡燃气监管信息平台的功能。
旭华智能城乡燃气监管信息平台，以智能化感知设备提供数据基础，以市/县/企业三级燃气安全监管平台为核心，对基础数据进行分析研判，可视化展示及预警指挥调度，可以及时发现燃气泄漏、压力异常等安全隐患，有效预防燃气事故的发生。
除了保障燃气安全，城乡燃气监管信息平台还有利于提升燃气管理效率。通过信息化手段，平台可以实现燃气信息的快速传递和共享，让管理部门可以更加便捷地掌握燃气供需情况，制定更加科学的决策。
液化气瓶充装追溯管理系统，作为平台的重要模块，可通过二维码或电子标签等身份识别手段，加强气瓶的跟踪追溯管理，实现对液化气瓶从检测、充装、运输、供应、配送全链条监管，切实提升燃气气瓶充装智能化监管水平。
总之，城乡燃气监管信息平台是燃气管理未来发展的趋势。通过该平台，监管部门可以更好地保障燃气的安全供应，提升燃气管理的效率和质量，为城乡居民提供更加安全、便捷的燃气服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9abedbfdae95b5ef44b99384b1797b3b/" rel="bookmark">
			携程 2024秋招内推 火热进行中！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		携程 2024秋招 内推火热进行中！~ 公司简介:携程校园招聘是为携程集团招募和培养未来的技术专家、业务骨干、管理人员的培训生成长项目。进入携程后，公司会为每位培训生量身拟定双轨+四维驱动培养计划， 施行双通道成长模式，可自由选择专家、管理者为职业发展目标。 【内推福利】
更好的机会被HR捞起简历，优先考虑内推同学！！
专属内推码 ‼️ 领取 秋招 专属内推码 &amp; 查看更多详细资料： 可使用通用内推码投递哦：NTAH5k0 PC端投递地址：携程集团(Trip.com Group) - 内部推荐
手机端扫码：
内推福利 🤲 简历优先处理，热门岗位优先安排面试～
公司福利 "3+2"混合办公模式，2天远程办公让你实现work from home/hotel的自由！拒绝内卷和996，平衡工作与生活，团建假+团建费多多，去探索更美好的世界~平时福利多多，发各种礼品卡，也可以特价买机票/酒店/门票等等，做旅行达人~5天带薪病假+5天以上年假，充分享受假期时光（搭配混合办公食用更爽哦）薪资可观，交通补贴/餐饮补贴；2-3年可落户上海5W生育礼金，生孩子发钱在携程实现啦 秋招内推信息 【内推对象】2024届应届毕业生（毕业时间：2023.9-2024.8）
【内推时间】即日起至10月31日（24:00)
【热招岗位】前后端开发、产品经理......
【学生特权】简历优先筛选，热招岗位优先安排面试
岗位类型：开发、算法、产品、运营、运维，HC多多 尽早上车！
工作地点：上海、北京.....
其他 🧐楼主简介:
我们是IBU公共技术团队，通过技术突破和创新引领携程集团的国际化趋势。
在这里有浓厚的技术氛围和定期的技术分享，帮助同学们拓展视野，追求卓越。在这里有最新的技术探索和实施场景，引领技术潮流，赋能国际业务增长，不亦乐乎！
共同的理想和愿景让我们大家相遇，IBU公共技术团队期待各位的加入！
工作体验：汪十号：For a better world，在携程一起追逐太阳吧
Github：https://github.com/kevinten10
个人博客： http://www.kevinten.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a510a3df880178a458cc34febb3fa47e/" rel="bookmark">
			【论坛java项目】第四章 Redis，一站式高性能存储方案：Redis入门、Spring整合Redis、点赞、收到的赞、关注、取消关注、关注列表、粉丝列表、优化登录模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Redis入门基础知识String 类型hash类型列表无序集合有序集合 总结Redis的概念Redis的持久化想要返回有序集合中元素的个数 二、Spring整合Redis1、 引入依赖2、配置Redis配置文件——application.properties配置类——RedisConfig测试 三、点赞为什么用Redis？1、service业务层工具类——RedisKeyUtil点赞——LikeService 2、视图层——LikeController3、页面discuss-detail.htmldiscuss.js 4、首页的赞帖子方法——HomeController首页——index.html测试 5、帖子详情页面的赞DiscussPostControllerdiscuss-detail.html测试 四、我收到的赞1、主体——RedisKeyUtil2、业务层——LikeService3、页面discuss-detail.htmldiscuss.js显示在用户的主页——UserController首页——index.html个人主页——profile.html 4、测试 五、关注、取消关注关注取关功能1、主体——RedisKeyUtil2、业务层——FollowService3、视图层——FollowController4、页面——profile.js测试 补充关注多少人，统计数量1、业务层——FollowService2、视图层——UserController3、页面——profile.html测试 六、关注列表、粉丝列表1、业务层——FollowService2、视图层——FollowController3、页面个人主页——profile.html关注的人——followee.html粉丝——follower.html 测试 七、优化登录模块1、使用Redis存验证码Redis——RedisKeyUtil视图层——LoginController测试 2、使用Redis存登录凭证Redis——RedisKeyUtil业务层——UserService 3、使用Redis存用户信息UserService 一、Redis入门 https://github.com/microsoftarchive/redis
百度网盘下载
默认端口号
基础知识 内置16个库，没名字，索引区分 String 类型 hash类型 列表 无序集合 有序集合 分数排序
查一下库里有多少key
设置某一个key的过期时间
总结 Redis的概念 NoSQL是关系型数据库之外的数据库的统称，Redis就是一个NoSQL数据库。Redis以键值对的形式，将数据存储于内存中Redis的值支持多种数据类型，包括字符串、哈希、列表、集合、有序集合等。Redis提供了对值进行运算的命令，如对集合求交集、并集、差集等。 Redis的持久化 RDB是以快照的形式，将内存中的数据整体拷贝到硬盘上。执行RDB存储时会产生阻塞，因此RDB不适合实时备份，而适合定时备份。AOF是以以追加的形式将缓存中的数据存放到硬盘中，不是整体拷贝。AOF操作的实时性好，但是产生的数据体积大，数据的恢复速度慢。 想要返回有序集合中元素的个数 二、Spring整合Redis 引入依赖
spring-boot-starter-data-redis 配置Redis
目配置数据库参数编写配置类，构造RedisTemplate 访问Redis
redisTemplate.opsForvalue (）redisTemplate.opsForHash ()redisTemplate.opsForList (）redisTemplate.opsForset (）redisTemplate.opsForzSet (） 1、 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置Redis 配置文件——application.properties redis 数据库本机端口 # RedisProperties spring.redis.database=11 spring.redis.host=localhost spring.redis.port=6379 配置类——RedisConfig package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a510a3df880178a458cc34febb3fa47e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78dc069c104230008d58639ecc05f369/" rel="bookmark">
			okx合约交易
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.做多 和交易所借USDT和还USDT的过程不收利息。
2.做空 3.爆仓 4.总结 不同交易所的手续费不一样。
5.okx合约实战 永续合约:表示只要不爆仓，就可以一直存在。（一般使用这个）
交割合约：表示到达交割时间，不论赔还是赚都会平仓。
全仓：假如账户有100块钱，哪怕开的是1块钱的仓，只要你的仓位爆掉，账户里面的100块钱也全部会亏掉。
逐仓：假如账户有100块钱，开的是1块钱的仓，如果你的仓位爆掉，账户里面的也只是会亏掉1块钱。（推荐）
倍数：一般5倍以下，如果激进可以选择高倍数。
限价委托：比如现在btc价格是27600美金，我想要去做多它，我感觉以后价格会上涨，但是我不想现在去做多，想btc回调一下到27500美金，然后再去做多，那么就可以进行设置btc价格为27500，然后设置做多多少钱的btc，点击开多，这样单子就会挂起来。【挂单后不知道会不会到27500，如果跌破27500那么就会被迫成交并且出现亏损】（不推荐挂单操作做多做空）
市价委托：根据当前市场最优价下单，然后做多做空【只要下单立马会成交，这样可以止盈止损】（推荐市价委托做多做空）
止盈止损：可以设置什么价格止盈和止损。
市价全平：可以以最快的速度平掉仓位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524035e953fd84996b571537b94006d4/" rel="bookmark">
			自动化测试系列 —— UI自动化测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UI 测试是一种测试类型，也称为用户界面测试，通过该测试，我们检查应用程序的界面是否工作正常或是否存在任何妨碍用户行为且不符合书面规格的 BUG。了解用户将如何在用户和网站之间进行交互以执行 UI 测试至关重要，通过执行 UI 测试，测试人员将尝试模仿用户的行为，以查看用户将如何与程序进行交互，并查看网站的运行情况是否如预期的那样，是否有缺陷。
什么是 UI 测试？ UI 测试涵盖了用户交互部分，包括用户关注的网站结构和视觉部分。Web 网站包含许多来自 CSS，JavaScript 和许多其他语言的不同 Web 元素，网站元素可以连接到屏幕、键盘、鼠标或用户用于与网站进行交互的任何其他工具，UI 测试则捕获这些元素并对其进行测试和声明。
在执行 UI 测试时，需要注意确保应用程序不存在任何跨浏览器兼容性问题。由于每个浏览器都使用不同的浏览器引擎，并且可能不支持相同的 CSS 功能。因此，确保UI 在所有主要浏览器上无缝呈现非常重要。在不同的浏览器上进行测试称为跨浏览器测试，可以帮助测试人员在所有主要浏览器和设备（包括手机，平板电脑等）的多种组合下测试其网站。
手动或自动，如何选择？ 与其他任何类型的测试一样，UI 测试也可以手动或通过自动化执行。手动测试要求测试人员在每个元素上手动执行每个测试。例如，测试输入字段将需要针对任何差异一次又一次地键入不同的值。如果网站 UI 的组件较少​​，则最好通过手动过程进行 UI 测试，快速地完成。但它不适合复杂的网站，用户界面丰富的网站使手动 UI 测试则非常低效，费时且容易出错。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：110685036 适合UI自动化测试的场景 不是所有的测试场景都适合用自动化测试来实现，对此，可以参考以下的标准辅助判断：
项目的需求不会频繁变动页面的 UI 已经进入稳定阶段项目周期足够长大量回归的测试任务 其中，有些项目是明显不适合使用 UI 自动化测试的，例如视频播放器，音乐播放器等交动性强，并发依赖强的软件。
UI自动化测试的优点 UI自动化测试过程简化了创建UI测试、运行测试以及查看结果的过程，开发和测试团队选择自动化UI测试的原因有很多，最值得注意的包括：
时间 – 手动测试速度很慢，无法与许多开发过程保持同步。成本 – 手动测试需要大量资源且成本很高。准确性 – 执行重复性任务时，手动测试容易出现更多错误。相反，自动化减少了这些错误的机会。规模化 – 执行复杂的迭代时，很难依靠手动测试。趋势 – 大多数组织已经意识到如何从自动化测试中受益，因此，跳上自动化潮流的压力越来越大。 UI自动化测试设计原则 一个测试用例完成一个功能点测试（常用）：一个手工用例对应一个自动化测试用例；一个脚本是一个完整的场景；脚本之间独立，不能有依赖（脚本间相互隔离）：例如与登陆状态相关的用例：个人中心、订单详情、下单购物等，如果脚本之间不独立，相互依赖，在登陆的测试脚本失败的情况下，会导致个人中心、订单详情、下单购物的测试脚本全军覆灭，后续修复与维护成本高；设置合适的检查点：通过断言判断用例的成功与否；设计良好的框架：Python 常用的测试框架有 unittest 与 pytest，利用框架，及对共用的测试模块进行封装，减少自动化测试脚本维护的工作量； WEB端UI测试工具介绍 API测试用例主要由4个部分组成，分别是：用例的基础信息、前置步骤、请求脚本以及断言。
UTF UTF( Unified Functional Testing) = QTP( Quick Test Pro) + ST( Service Test)由 HP 公司开发。它是一种企业级的自动测试工具，提供了强大易用的录制回放功能，同时兼容对象识别模式与图像识别模式两种识别方式，支持 B/S 与 C/S 两种架构的软件测试，是目前主流的自动化测试工具。主要是用于回归测试和同一软件的新版本测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/524035e953fd84996b571537b94006d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/304a945b14c14b82d2d32e023de42af6/" rel="bookmark">
			万字超详细解析！Spring之基于注解的声明式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		14.1、概述 14.1.1、编程式事务 事务功能的相关操作全部通过自己编写代码来实现：
Connection conn = ...; try { // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 提交事务 conn.commit(); }catch(Exception e){ // 回滚事务 conn.rollBack(); }finally{ // 释放数据库连接 conn.close(); } 编程式事务的缺陷：
细节没有被屏蔽：所有细节都需要程序员自己来完成，比较繁琐。
代码复用性不高：每次实现功能都需要自己编写代码，代码没有得到复用。
14.1.2、声明式事务 因为事务控制的代码有规律可循，代码的结构基本是确定的；所以框架就可以将固定模式的代码抽取出来，并进行相关的封装。
封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。
声明式事务的优点：
提高开发效率
消除了冗余的代码
框架考虑和实现功能会更加全面
14.1.3、总结 编程式：自己写代码实现功能
声明式：通过配置让框架实现功能
14.2、环境搭建 创建名为spring_transaction的新module，过程参考13.1节
14.2.1、创建Spring的配置文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location="jdbc.properties"&gt;&lt;/context:property-placeholder&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="datasource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;!--通过${key}的方式访问外部属性文件的value--&gt; &lt;property name="driverClassName" value="${jdbc.driver}"&gt;&lt;/property&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/304a945b14c14b82d2d32e023de42af6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888cbd47f6a5495f18701793820e56f5/" rel="bookmark">
			7K字详解换上 HikariCP 连接池到底有多快？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。
比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。
并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。
这个时候，我们就可以使用一个虚拟的池子，将这些资源保存起来，当使用的时候，我们就从池子里快速获取一个即可。
在 Java 中，池化技术应用非常广泛，常见的就有数据库连接池、线程池等，本文主讲连接池，线程池我们将在后续的博客中进行介绍。
公用池化包 Commons Pool 2 我们首先来看一下 Java 中公用的池化包 Commons Pool 2，来了解一下对象池的一般结构。
根据我们的业务需求，使用这套 API 能够很容易实现对象的池化管理。
&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; GenericObjectPool 是对象池的核心类，通过传入一个对象池的配置和一个对象的工厂，即可快速创建对象池。
public GenericObjectPool( final PooledObjectFactory&lt;T&gt; factory, final GenericObjectPoolConfig&lt;T&gt; config) 推荐一个开源免费的 Spring Boot 最全教程：
https://github.com/javastacks/spring-boot-best-practice
案例 Redis 的常用客户端 Jedis，就是使用 Commons Pool 管理连接池的，可以说是一个最佳实践。下图是 Jedis 使用工厂创建对象的主要代码块。
对象工厂类最主要的方法就是makeObject，它的返回值是 PooledObject 类型，可以将对象使用 new DefaultPooledObject&lt;&gt;(obj) 进行简单包装返回。
redis.clients.jedis.JedisFactory，使用工厂创建对象。
@Override public PooledObject&lt;Jedis&gt; makeObject() throws Exception { Jedis jedis = null; try { jedis = new Jedis(jedisSocketFactory, clientConfig); //主要的耗时操作 jedis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888cbd47f6a5495f18701793820e56f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e2c21bd3c7392890dbe29909c05035/" rel="bookmark">
			【Cocos Creator 项目实战 】益智游戏《消灭星星》加强版（附带完整源码工程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文乃Siliphen原创，转载请注明出处
目录
游戏介绍
概述
游戏整体流程
游戏框架设计
单一职责的类
主要流程控制类
核心玩法模块
UI：
游戏世界：
本文项目的代码组织结构
作者项目实践总结
场景只有一个入口脚本
尽量少在节点上挂载脚本
构建游戏世界
ECS 设计
消除物
棋盘地图
逻辑计算和显示分离
消除的实现
查找联通分量
逐步由内向外扩张的消除动画
掉落的实现
合并的实现
道具的实现
本文的完整实现源码工程
【 Cocos Creator 项目实战】系列文章链接：
游戏介绍 《消灭星星》是一个爆款休闲游戏，累计用户5亿+。
目前（2023.08.06）在 App Store 上39.6万个评分，评分4.6，益智解谜类第7名。
参考链接：‎‎App Store 上的“消灭星星全新版®”
概述 本文讲解用 Cocos Creator 实现一款加强效果版的《消灭星星》的核心流程和算法。
Cocos Creator 版本：Cocos Creator 3.8.0
本文实现的游戏效果如下：
运行体验本文的实现：
* Web 体验地址：Cocos Creator | 消灭星星
* 微信小游戏体验（使用微信扫码下图）：
文本末尾给出完整实现的源码工程。
游戏整体流程 游戏执行一轮玩家操作的流程：等待玩家点击操作 -&gt; 用户点击 -&gt; 消除-&gt; 掉落 -&gt; 合并 -&gt; 等待玩家点击操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42e2c21bd3c7392890dbe29909c05035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44eb44f1b53b8a7f574a09386e66a530/" rel="bookmark">
			linux系统维护篇：/dev/null 妙用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 /dev/null 是一个特殊的设备文件，该文件接收的所有数据都会被丢弃（不显示、不打印、不记录），类似于黑洞。
场景 场景1，执行命令有输出信息（正确和错误），且直接通过输出内容判断执行命令的结果是成功还是失败。
场景2，对于命令的输出信息，不希望打印在终端。
原理 将所执行命令的输出信息重定向到指定位置（文件）。若需记录则指定文件，若不需要记录则使用空设备文件【/dev/null】。
重定向 &gt; ：将左边数据写入到右边文件，每次写入都会清空右边文件。
&gt;&gt; ：将左边数据写入到右边文件，每次写入都在文件中追加内容，不会清空原来内容。
1 &gt; &amp;2 ：将命令输出的正常信息写入到第2输出通道。 2&gt; &amp;1 ： 将命令输出的错误信息写入到第1输出通道 。
案例：正确和错误信息都写入到all.log文件中，终端屏幕不再显示打印 文件描述符 文件描述符是与文件输入、输出关联的整数值。常见的三种描述符为，0表示标准输入（stidin），从键盘获取的输入（stdout）；1表示标准输出（stderr），输出到终端屏幕；2表示标准错误，输出到终端屏幕。
示例：
1、标准输出：指命令执行后正常的打印，也可理解为执行命令成功后的打印输出
2、标准错误：指命令执行后错误的打印，也可理解为执行命令失败的打印输出
案例用法 案例1，将执行命令的标准错误输出（错误输出）进行丢弃不再显示，简言之，命令输出中报错信息不显示输出，正常信息会显示
#command 表示执行的命令 command 2&gt; /dev/null 案例2， 将执行命令的标准输出（正确输出）进行丢弃不再显示，简言之，命令输出中报错信息会显示，正常信息不会显示
#command 表示执行的命令 command &gt; /dev/null 案例3，将执行命令的输出无论是否报错都丢弃，输出的所有信息都不显示
#command 表示执行的命令 command &amp;&gt; /dev/null 案例4、将执行命令的输出信息中，错误信息和正常信息分别写入到不同的文件
find /home/test_u1/ 1&gt;filelist.log 2&gt;erro.log 命令结果标准输出判断 案例：
nc -zvw3 172.16.89.22 999 &amp;&gt; /dev/null #获取丢弃后的返回值，标准状态结果：0，执行成功，1，失败 result=$? #直接执行命令，会有错误输出打印 [test_u1@localhost ~]$ nc -zvw3 172.16.89.22 999 Ncat: Version 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44eb44f1b53b8a7f574a09386e66a530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e104356bbc0c2bc93aaf0f09e6c037/" rel="bookmark">
			13款web前端常用的富文本编辑器插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		富文本编辑器是一种可内嵌于浏览器，所见即所得的文本编辑器。它提供类似于Office Word 的编辑功能，方便那些不太懂html用户使用。
1、wangEditor 网址：http://www.wangeditor.com/
基于JavaScript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。
2、TinyMCE 网址：https://www.tiny.cloud/docs/demo/full-featured/
TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。
功能齐全，界面美观。
3、百度ueditor 网址：UEditor Docs
UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制。源码地址：https://github.com/fex-team/ueditor#ueditor
4、kindeditor 网址：http://kindeditor.net/demo.php
KindEditor 是一套开源的在线html编辑器，主要用于让用户在网站上获得所见即所得编辑效果，开发人员可以用 KindEditor 把传统的多行文本输入框(textarea)替换为可视化的富文本输入框。
KindEditor 使用 JavaScript 编写，可以无缝地与 Java、.NET、php、ASP 等程序集成，比较适合在 CMS、商城、论坛、博客、Wiki、电子邮件等互联网应用上使用。 5、Textbox 网址：https://www.textbox.io/
Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。
6、CKEditor 网址：https://ckeditor.com/ckeditor-5/demo/
CKEditor官方版是一款专业专业的在线文字编辑器，软件支持各种不同的浏览器，可以让用户们轻松在线编辑，CKEditor5官方版软件体积非常小巧，使用起来也十分方便快捷，还能与不同的编程语言相结合，是大家编辑网页代码的必备工具。
7、quill 网址：https://quilljs.com/
Quill是轻型的编辑器，样式一般（黑白风），功能中等，它的代码高亮功能比较强，同样支持行内编辑模式，工具条可自定义。
开源免费，项目活跃，一直有人维护。
8、simditor 网址：https://simditor.tower.im/
simditor是Tower平台使用的富文本编辑器，是一款轻量化的编辑器，界面简约，功能实用，插件不是很多，功能要求不高的可以使用，开源免费。
9、summernote 网址：https://summernote.org/
summernote是一款轻量级的富文本编辑器，比较容易上手，使用体验流畅，支持各种主流浏览器。
summernote开源免费，该项目一直比较活跃，一直都有人在维护。summernote同样依赖于jquery和bootstrap，使用前先引入这两项。
10、jodit 网址：https://xdsoft.net/jodit/
Jodit是一款使用纯TypeScript编写的（无需使用其他库），开源富文本编辑器，支持中文。 11、Editor.md 网址：https://pandao.github.io/editor.md/
功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费。
12、froala Editor 网址：https://www.froala.com/wysiwyg-editor
界面非常好看，功能可满足大部分需求（非免费，可破解）
13、dhtmlxEditor 网址：https://dhtmlx.com/docs/products/dhtmlxRichText/
DHTMLX组件是一整套基于js的UI库，功能强大，其中包含编辑器dhtmlxEditor。
该编辑器可以直接集成到Angular，react和vue.js框架中，该编辑器还同时支持Markdown和富文本。
支持普通视图和类似word一样的页面视图，支持全屏幕，工具支持自定义，包括工具条颜色和样式等。
dhtmlxEditor分为免费版和收费版，免费版具有绝大多数功能。
以上就是我收集的一些比较受欢迎的富文本编辑器，喜欢的朋友、用过的朋友可以一起看看，一起探讨。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2abe2bcf0a497968054c9c0ebfde3352/" rel="bookmark">
			在github上快速找到自己评论过或者发布过的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在github上快速找到自己评论过或者发布过的问题
场景:
我在github某个项目想的某个问题下发布了提问,后来我解决了这个问题,然后我想快速找到这个问题,并把我的解决办法放到上面,
通过在GitHub搜索中放入is:issue involves:my-username(此处是你的github名)来实现此目的
此时会找到你参与的所有问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee19d291d9b4f6cd5a9c77141f7f0a6/" rel="bookmark">
			ER图总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1、概念
2、组成部分
2.1、实体
2.2、属性
2.3、联系
2.4、连线
2.4.1、1对1联系：
2.4.2、1对多联系：
3、步骤：
3.1 验收标准：
4、注意
1、概念 E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型
2、组成部分 2.1、实体 实体是ER图中的基本元素之一，表示数据模型中的数据对象。它们通常对应于现实世界中的对象或事件。例如，对于一个学校系统，实体可以包括学生、教师、课程等。每个实体都有自己的实体实例，例如一个特定的学生（如张三）或一门特定的课程（如数学）。实体在ER图中通常用长方形表示，长方形内部标注的是实体名称。
2.2、属性 属性是ER图中的另一个基本元素，用于描述实体的特性。例如，学生实体可以具有属性，如姓名、学号、年级等。属性通常用椭圆形表示，并且椭圆形内部标注的是属性的名称和数据类型。有些属性也可能是唯一标识符，用来唯一标识实体的实例，这样的属性在ER图中会用下划线标注。
2.3、联系 联系是用来描述实体与实体之间的相互关联或依赖关系的。例如，学生和课程之间可能存在“选课”的关系，教师和课程之间可能存在“授课”的关系。联系在ER图中通常用菱形表示，菱形内部标注的是联系的名称。
2.3.1、1对1 1对1联系是指两个实体之间存在一种一对一的关联关系。换句话说，对于实体集A中的每一个实体，实体集B中最多只存在一个实体与之相关联。同样地，对于实体集B中的每一个实体，实体集A中也最多只存在一个实体与之相关联。在ER图中，1对1联系可以通过在两个实体之间画一个箭头来表示，从一个实体指向另一个实体。箭头所在的直线表示联系的类型。例如，在"学生-成绩"关系中，每个学生对应一份成绩单，因此可以使用1对1联系来表示这个关系。
2.3.2、1对多 1对多联系是指一个实体集中的实体与另一个实体集中的多个实体之间存在关联关系。具体来说，对于实体集A中的每一个实体，实体集B中至少存在一个实体与之相关联；而对于实体集B中的每一个实体，实体集A中最多只存在一个实体与之相关联。在ER图中，1对多联系可以通过在"一"侧的实体上画一个箭头来表示，箭头指向实体集B。例如，在"班级-学生"关系中，一个班级有多名学生，因此可以使用1对多联系来表示这个关系。
2.4、连线 实体与属性之间；实体与联系之间；联系与属性之间用直线相连。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)
3、步骤： 确定所有的实体集合；选择实体集应包含的属性确定实体集之间的联系确定实体集的主键，用下划线在属性上表明主键的属性组合确定联系的类型，在用线将表示联系的菱形框联系到实体集时，在线旁注明是1或n(多）来表示联系的类型 3.1 验收标准： 词汇表达准确，实体为名词，联系为动词。图形使用是否准确，见上文。实体之间的关系正确，如学生与课程之间的关系为多对多。实体名称和属性与数据库中的表名和字段对应。实体为数据库中表的名字，属性为数据库中的字段。 4、注意 1、数据库命名要规范，只能使用半角英文字母、数字、下划线作为数据库表和列的名称。2、数据库包含的数据表过多，可以分几张er图来展现。3、如果实体过多，可将属性和实体分开画。4、当有多对多关系并且产生第三张表的时候，直接将新表的字段放在菱形关系的上面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fdb32c9d0b8ae542761e7e4c0ffc32e/" rel="bookmark">
			css 修改浏览器滚动条样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在全局样式文件内设置滚动条样式
// 设置滚动条 ::-webkit-scrollbar { width: 8px; height: 8px; } ::-webkit-scrollbar-track { width: 8px; background: rgba(144, 147, 153, 0.3); -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em; } ::-webkit-scrollbar-thumb { background-color: rgba(144, 147, 153, 0.5); background-clip: padding-box; min-height: 28px; -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em; } ::-webkit-scrollbar-thumb:hover { background-color: #101f1c; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8388df3159f8053b67e3ad2f46a2d71f/" rel="bookmark">
			java中设计模式的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、单例模式1.饿汉2.懒汉 二、装饰器模式三、工厂模式1.简单工厂2.工厂方法模式3.抽象工厂模式 四、建造模式五、适配器模式六、模板模式七、代理模式八、责任链模式九、享元模式十、观察者模式十一、策略模式总结 前言 java的版本不断的迭代更新，各种框架和组件也层出不穷，但是设计的思想永远不会变，也许平时只是一个curl工程师，还在代码中看不到任何设计模式的影子，那可太糟心了。设计模式的应用往往也能反应一个程序员的水平，设计模式说到底就是可扩展 可解耦 多封装一些共用行为，就是为了提升代码的可读可用性，设计模式就像写文章一样，没有对错之分，一条语句可以有多种表达方式 修辞手法。
一、单例模式 保证类只产生有且只有一个实例。由私有构造函数，共用访问点，一个静态初始变量组成。单例模式分饿汉和懒汉。
1.饿汉 饿汉不管需不需要直接实例化，不用考虑多线程冲突问题，可用于配置文件初始化。
package com.orange.demo.design; public class Single { private static Single instance = new Single(); // 禁止外部实例化 private Single(){} public static Single getInstance(){ return instance; } public void execute(){ System.out.println("饿汉"); } public static void main(String[] args){ Single single = Single.getInstance(); single.execute(); } } 2.懒汉 懒汉是调用时才实例化，线程不安全，可通过双锁机制保证线程安全，多用于对外部客户端的初始化
package com.orange.demo.design; public class Single { private static volatile Single instance;//禁止指令重排 // 禁止外部实例化 private Single(){} public static Single getInstance(){ if (instance==null) { synchronized (Single.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8388df3159f8053b67e3ad2f46a2d71f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7297f89a14bfe10313af607f65aac53d/" rel="bookmark">
			formData 传二维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在网上找了各种方法，后端都不能正常解析，无意间发现这样可行，记录在册希望可以帮到其他人
let table = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] const formData = new FormData() for (let i = 0; i &lt; table.length; i++) { const row = table[i] // 这里的'table'是后端接受的字段名 formData.append(`table[${i}]`, row.join(',')) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc57aa47ceb7661969bce00900aeb165/" rel="bookmark">
			Unity 顶点vertices，uv，与图片贴图，与mesh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mesh就是组成3d物体的三角形们。
mesh由顶点组成的三角形组成，三角形的大小 并不 需要一样，由顶点之间的位置决定。
mesh可以是一个或者多个面。
贴图的原点在左下角，uv是贴图的坐标，数量和顶点数一样（不是100%确定，比如前后左右4个面，贴图最终如何封闭，我还不知道），是贴图和顶点的对应关系。
新建空场景，把一下代码放到main camera：
using System; using System.Collections; using System.Collections.Generic; using UnityEngine; #if UNITY_EDITOR using UnityEditor; #endif public class codeMesh2 : MonoBehaviour { GUIStyle fontStyle = new GUIStyle(); string msg = " - - "; // Start is called before the first frame update Vector3 center = new Vector3(); GameObject o; bool ready = false; //int startCalled = 0; Camera c; string err = ""; int moveRage = 25; int moveRage2 = 0; int moveRage2_1 = 0; Mesh mesh = null; public int width = 10; public int height = 10; public Texture aText = null; /// &lt;summary&gt; /// 上一次更新帧率的时间 /// &lt;/summary&gt; private float m_lastUpdateShowTime = 0f; /// &lt;summary&gt; /// 更新显示帧率的时间间隔 /// &lt;/summary&gt; private readonly float m_updateTime = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc57aa47ceb7661969bce00900aeb165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a562a00788fb0dd7f1bc80cf12ca19/" rel="bookmark">
			数据库和缓存如何保证一致性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢📢📢📣📣📣
哈喽！大家好，我是【一心同学】，一位上进心十足的【Java领域博主】！😜😜😜
✨【一心同学】的写作风格：喜欢用【通俗易懂】的文笔去讲解每一个知识点，而不喜欢用【高大上】的官方陈述。
✨【一心同学】博客的领域是【面向后端技术】的学习，未来会持续更新更多的【后端技术】以及【学习心得】。
✨如果有对【后端技术】感兴趣的【小可爱】，欢迎关注【一心同学】💞💞💞
❤️❤️❤️感谢各位大可爱小可爱！❤️❤️❤️ 目录
前言
一、先更新数据库，还是先更新缓存？
🌴 先更新数据库，再更新缓存
🌴 先更新缓存，再更新数据库
🚀 小结
二、先更新数据库，还是先删除缓存？
🌵 旁路缓存策略
🌵 先删除缓存，再更新数据库
🌵 先更新数据库，再删除缓存
三、数据一致性解决方案
🌴 先更新数据库，再更新缓存
🌴 先删除缓存，再更新数据库
前言 在我们的项目开发中，为了提高数据的访问速度以及降低数据库负载，我们通常会将热点数据存储在缓存当中，像Redis缓存是基于内存的缓存系统，读取数据的速度非常快，通常可以在微秒级别内进行响应数据，但是由于缓存的存在，也同时引入了缓存与数据库的一致性问题，本文将进行解析如何保证其一致性。
本文针对数据不一致性提供四种策略进行解析，一心在这里就不卖关子了，先直接展开：
先更新缓存，再更新数据库。先更新数据库，再更新缓存。先删除缓存，再更新数据库。先更新数据库，再删除缓存。 四种策略无非就是先后顺序，一心把他总结为两个问题：
问题一：先更新数据库，还是先更新缓存？
问题二：先更新数据库，还是先删除缓存？
在这里，我们带着这两个问题来进行逐一展开。
一、先更新数据库，还是先更新缓存？ 🌴 先更新数据库，再更新缓存 流程：【请求A】先将数据库的数据更新为 1，然后在更新缓存前，【请求 B】 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 【请求A】更新缓存为 1。
此时，数据库中的数据是 2，而缓存中的数据却是 1，出现了缓存和数据库中的数据不一致的现象。（此方案在实际中不建议采用）
🌴 先更新缓存，再更新数据库 流程：【请求A】先将缓存的数据更新为 1，然后在更新数据库前，【请求B】来了， 将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 【请求A】将数据库的数据更新为 1。
此时，数据库中的数据是 1，而缓存中的数据却是 2，出现了缓存和数据库中的数据不一致的现象。（此方案在实际中不建议采用）
🚀 小结 无论是【先更新数据库，再更新缓存】，还是【先更新缓存，再更新数据库】，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。
二、先更新数据库，还是先删除缓存？ 🌵 旁路缓存策略 对于不更新缓存，而是删除缓存中的数据。然后读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。我们将这种策略称为Cache Aside 策略，中文是叫旁路缓存策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a562a00788fb0dd7f1bc80cf12ca19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1014ec131adb1d4cb49360ba16c0a3/" rel="bookmark">
			Unable to make field final int java.math.BigInteger.signum accessible: module java.base does not ***
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习dubbo时遇到的报错！！
我的环境：JDK17、Dubbo3.2.0-beta.2、Springboot3.1.3、zookeeper3.5.10
呃呃呃，没有四号头绪！
虽然报这个错，但是可以正常运行。所以不在意的话可以先不用管这个错。但是我有点强迫症。。。
好在在官网找到一篇博客
博客地址：使用jdk17编译运行dubbo 2.7.14项目 | Apache Dubbo
重新启动，完美决解！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b858ae869a30162f5b0269da4e6a3780/" rel="bookmark">
			任意文件读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、任意文件读取概述1.1 漏洞成因1.2 漏洞危害1.3 漏洞分类1.4 任意文件读取1.4.1 文件读取1.4.2 任意文件读取 1.5 任意文件下载1.5.1 一般情况1.5.2 PHP实现1.5.3 任意文件下载 二、任意文件读取攻防2.1 路径过滤2.1.1 过滤`../` 2.2 简单绕过2.2.1 双写绕过2.2.2 绝对路径2.2.3 使用`..\` 三、 任意文件读取挖掘3.1 手动挖掘3.2 经典案例 四、漏洞修复方案4.1 输入验证4.2 避免其他漏洞4.3 限定文件的访问范围 五、参考连接 一、任意文件读取概述 ​ 一些网站的需求，可能会提供文件查看与下载的功能。如果对用户查看或下载的文件没有限制或者限制绕过，就可以查看或下载任意文件。这些文件可以是源代码文件，配置文件，敏感文件等等。
任意文件读取会造成（敏感）信息泄露；
任意文件读取大多数是由于其他漏洞引发的，如，RCE、目录遍历、文件包含等。
任意文件读取与任意文件下载本质上没有区别，信息都是从服务端流向浏览器的。
​ 文件读取与下载可能形式不同，但是从本质上讲读取与下载没有区别，从权限角度来讲，读取与下载都
需要读权限。
1.1 漏洞成因 不管是任意文件读取还是任意文件下载，触发漏洞的条件都是相同的：
存在读取文件的功能（函数），也就是说，Web应用开放了文件读取功能；读取文件的路径客户端可控，完全控制或影响文件路径参数；没有对文件路径进行校验或者校验不严导致校验被绕过；输出了文件的内容。 1.2 漏洞危害 ​ 下载服务器任意文件，包括源代码文件、系统敏感文件、配置文件等等。
​ 可以配合其他漏洞，构成完整攻击链。对源代码文件进行代码审计，查找更多的漏洞。
​ 任意文件读取与下载重点关注的文件：
源代码配置文件敏感文件日志文件… 1.3 漏洞分类 任意文件读取任意文件下载 1.4 任意文件读取 以PHP脚本为例子，有一些函数可以实现文件读取功能。
1.4.1 文件读取 读取文件的函数函数特点readfile()直接读取文件内容
自带输出功能file_get_contents()直接读取文件内容
需要输出读取内容fread()打开文件
计算文件大小
读取文件
输出文件
关闭文件 readfile :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b858ae869a30162f5b0269da4e6a3780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64891672b5a782fc4fe9024e1d72cff2/" rel="bookmark">
			JAVA类的加载时机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 类的加载时机 1.对象被创建（new）时 2.子类调用父类时 3.使用类的静态成员、静态方法时 4.静态代码块（static）在类加载时运行，并且只会执行一次。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24348638a2d0db19da1c74181148679b/" rel="bookmark">
			Windows安装单节点Zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚学习Dubbo，在Centos7中docker安装的zookeeper3.7.1。然后在启动provider时一直报错，用尽办法也没有解决。然后zookeeper相关的知识虽然以前学习过，但是已经忘记的差不多了。现在学习dubbo只能先降低版本使用了，之后再复习zookeeper。所以这里记录一下最简单的方式：就是在windows安装zookeeper3.5.10
zookeeper下载地址：Index of /dist/zookeeper (apache.org)
启动过程也遇到了问题，在网上也有相关解决方法。我这里就直接按照正确步骤写了
解压--&gt;修改配置文件(复制一份zoo_sample.cfg并重命名为zoo.cfg)
编辑zkServer.cmd(将%JAVA%改成Java)
双击zkServer.cmd就可以启动成功了
这里有一个工具，可以看到连接成功了！(工具是我之前下载安装的，忘记具体下载地址了，可以去GitHub上去找）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9935dc4633cef94e5f9256dbce3c6f42/" rel="bookmark">
			P1152 欢乐的跳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 一个 n n n 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 [ 1 , n − 1 ] [1,n-1] [1,n−1] 之间的所有整数，则称之符合“欢乐的跳”，如数组 { 1 , 4 , 2 , 3 } \{1,4,2,3\} {1,4,2,3} 符合“欢乐的跳”，因为差的绝对值分别为： 3 , 2 , 1 3,2,1 3,2,1。
给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。
输入格式 每组测试数据第一行以一个整数 n ( 1 ≤ n ≤ 1000 ) n(1 \le n \le 1000) n(1≤n≤1000) 开始，接下来 n n n 个空格隔开的在 [ − 1 0 8 , 1 0 8 ] [-10^8,10^8] [−108,108] 之间的整数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9935dc4633cef94e5f9256dbce3c6f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c8c95d08b3048160f634e8f2781f31/" rel="bookmark">
			python numpy array 中删除含0量高于阈值的行--数据清洗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 数据中包含较多0值，类似于包含较大噪声，对结果产生较大影响
目标 对数据进行清洗，在进行其他数据清洗操作的基础上，实现删除数据中包含较多0值的行
可类比推广到删除其他
代码实现 data = data[np.sum(data == 0, axis=1) &lt; data.shape[-1] * 0.6, :] 首先，使用np.sum(data == 0, axis=1)统计每行数据中含0的数量保留含0量少于所有数据60%的行，下面这行代码的输出为bool向量 np.sum(data == 0, axis=1) &lt; data.shape[-1] * 0.6 示例 data=np.array([[0,0,0,0,0,0,0,0,0,0], [1,1,1,1,1,1,1,0,1,1], [2,2,2,0,0,0,0,2,2,2], [3,3,3,3,3,3,3,3,3,3], [4,0,4,0,4,0,4,0,4,0], [5,5,5,0,0,0,0,0,0,0], [6,6,0,0,0,0,0,0,6,6] ]) print(data.shape) print(np.sum(data == 0, axis=1) ) print(np.sum(data == 0, axis=1) &lt; data.shape[-1] * 0.6) data = data[np.sum(data == 0, axis=1) &lt; data.shape[-1] * 0.6, :] print(data) print(data.shape) 输出结果
# 原始数据大小 (7, 10) # 每行含0的数量 [10 1 4 0 5 7 6] # 每行含0量是都小于设定值 [False True True True True False False] # 清洗完的数据 [[1 1 1 1 1 1 1 0 1 1] [2 2 2 0 0 0 0 2 2 2] [3 3 3 3 3 3 3 3 3 3] [4 0 4 0 4 0 4 0 4 0]] # 清洗完的数据大小 (4, 10) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/60/">«</a>
	<span class="pagination__item pagination__item--current">61/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/62/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>