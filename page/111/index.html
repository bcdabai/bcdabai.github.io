<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52dac812851b6d33fcbbdfee27869f39/" rel="bookmark">
			which——查看所使用的一系列命令的程序文件的存放位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		which命令 1、作用 查看所使用的一系列命令的程序文件的存放位置
2、语法 which 要查找的命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d68822b1581552e5be91c958ae2fd1e/" rel="bookmark">
			CNN经典网络模型（五）：ResNet简介及代码实现（PyTorch超详细注释版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、开发背景
二、网络结构
三、模型特点
四、代码实现
1. model.py
2. train.py
3. predict.py
4. spilit_data.py
五、参考内容
一、开发背景 残差神经网络(ResNet)是由微软研究院的何恺明、张祥雨、任少卿、孙剑等人提出的， 斩获2015年ImageNet竞赛中分类任务第一名， 目标检测第一名。 残差神经网络的主要贡献是发现了“退化现象（Degradation）”，并针对退化现象发明了 “直连边/短连接（Shortcut connection）”，极大的消除了深度过大的神经网络训练困难问题。神经网络的“深度”首次突破了100层、最大的神经网络甚至超过了1000层。
二、网络结构 ResNet的前两层为输出通道数为64、步幅为2的7×7卷积层，后接步幅为2的3×3的最大池化层。 不同于GoogLeNet，ResNet在每个卷积层后增加了批量规一化层。接着， ResNet使用4个由残差块组成的模块，每个模块使用若干个同样输出通道数的残差块。 第一个模块的通道数同输入通道数一致。 由于之前已经使用了步幅为2的最大池化层，所以无须减小高和宽。 之后的每个模块在第一个残差块里将上一个模块的通道数翻倍，并将高和宽减半。ResNet的一个重要设计原则是：当feature map大小降低一半时，feature map的数量增加一倍，这保持了网络层的复杂度。最后，输入全局平均汇聚层，以及全连接层输出。通过配置不同的通道数和模块里的残差块数可以得到不同的ResNet模型，例如更深的含152层的ResNet-152。34层ResNet如下图所示：
残差单元（残差块） ResNet团队分别构建了带有“直连边（Shortcut Connection）”的ResNet残差块、以及降采样的ResNet残差块，区别是降采样残差块的直连边增加了一个1×1的卷积操作。对于直连边，当输入和输出维度一致时，可以直接将输入加到输出上，这相当于简单执行了同等映射，不会产生额外的参数，也不会增加计算复杂度。但是当维度不一致时，这就不能直接相加，通过添加1×1卷积调整通道数。这种残差学习结构可以通过前向神经网络+直连边实现， 而且整个网络依旧可以通过端到端的反向传播训练。结构如下图所示：
三、模型特点 1.超深的网络结构(突破1000层) 网络深度为什么重要？因为CNN能够提取low/mid/high-level的特征，网络的层数越多，意味着能够提取到不同level的特征越丰富。并且，越深的网络提取的特征越抽象，越具有语义信息。
2.使用Batch Normalization 为什么不能简单地增加网络层数？对于原来的网络，如果简单地增加深度，会导致梯度弥散或梯度爆炸。Batch Normalization可以解决该问题的，因此可以训练到几十层的网络。
3.残差块 随着网络层数增加，出现了新的问题：退化问题，在训练集上准确率饱和甚至下降了。这个不能解释为过拟合，因为过拟合表现为在训练集上表现更好才对。退化问题说明了深度网络不能很简单地被很好地优化。作者通过实验说明：通过浅层网络y=x 等同映射构造深层模型，结果深层模型并没有比浅层网络有更低甚至等同的错误率，推断退化问题可能是因为深层的网络很那难通过训练利用多层网络拟合同等函数。
怎么解决退化问题？深度残差网络。如果深层网络的后面那些层是恒等映射，那么模型就退化为一个浅层网络。所以要解决的就是学习恒等映射函数。但是直接让一些层去拟合一个潜在的恒等映射函数H(x) = x，比较困难，这可能就是深层网络难以训练的原因。但是，如果把网络设计为H(x) = F(x) + x。我们可以转换为学习一个残差函数F(x) = H(x) - x. 只要F(x)=0，就构成了一个恒等映射H(x) = x. 此外，拟合残差会更加容易。
总的来说，一是其导数总比原导数加1，这样即使原导数很小时，也能传递下去，能解决梯度消失的问题； 二是y=f(x)+x式子中引入了恒等映射（当f(x)=0时，y=2），解决了深度增加时神经网络的退化问题。
4.结构简单 虽然ResNet的主体结构跟GoogLeNet类似，但ResNet结构更简单，修改也更方便，因此ResNet迅速被广泛使用。
四、代码实现 model.py ：定义ResNet网络模型train.py：加载数据集并训练，计算loss和accuracy，保存训练好的网络参数predict.py：用自己的数据集进行分类测试spilit_data.py：划分给定的数据集为训练集和测试集 1. model.py import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d68822b1581552e5be91c958ae2fd1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad6cd3a6d9b615bceebc9316afc83a6/" rel="bookmark">
			03C&#43;&#43;核心编程——黑马程序员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++核心编程 本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。
1 内存分区模型 C++程序在执行时，将内存大方向划分为4个区域
代码区：存放函数体的二进制代码，由操作系统进行管理的全局区：存放全局变量和静态变量以及常量栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义：
不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程
1.1 程序运行前 ​ 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域
​ 代码区：
​ 存放 CPU 执行的机器指令
​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令
​ 全局区：
​ 全局变量和静态变量存放在此.
​ 全局区还包含了常量区, 字符串常量和其他常量（由const修饰的常量）也存放在此.
​ 该区域的数据在程序结束后由操作系统释放.
示例：
//全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 int a = 10; int b = 10; //打印地址 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ad6cd3a6d9b615bceebc9316afc83a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030d37bdb6ec95e5caa220856615a884/" rel="bookmark">
			spring boot集成mybatis-plus——通过id修改用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实体类不变：
package org.example.Entity; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; @TableName("users") //不一致时，需要映射 public class MyUser { @TableId(type = IdType.AUTO) private int id; private String name; private int age; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030d37bdb6ec95e5caa220856615a884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d25c10d3e2658656e676d45ec30ef8/" rel="bookmark">
			字节跳动青训营--前端day7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Node.js 的应用场景 (why)1. 前端工程化2. web服务端应用3. Electron跨端桌面应用 二、Node.js 运行时结(what)1. V8 ，libuv2. 优缺点3. js单线程4. 跨平台 三、编写 Http Server (how)1. SSR (server side rendering)2. Debug3. 部署 四、延伸话题1. node.js贡献代码2. 编译node.js3. 诊断/追踪4. WASM，NAPI 前言 仅以此文章记录学习历程。
一、Node.js 的应用场景 (why) 1. 前端工程化 Bundle：webpack, vite, esbuild, parcelUglify：uglifyjsTranspile：bablejs, typescript其他语言加入竞争：esbuild, parcel, prisma 现状：其他语言难以替代
2. web服务端应用 学习曲线平缓，开发效率较高运行效率接近常见的编译语言社区生态丰富及工具链成熟(npm, V8 inspector)与前端结合的场景会有优势(SSR) 现状：竞争激烈，但Node.js 有自己独特的优势
3. Electron跨端桌面应用 商业应用: vscode,slack, discord,zoom大型公司内的效率工具 现状:大部分场景在选型时，都值得考虑
二、Node.js 运行时结(what) 1. V8 ，libuv V8: JavaScript Runtime,诊断调试工具(inspector)libuv: eventloop (事件循环),syscall (系统调用) 举例:用 node-fetch 发起请求时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4d25c10d3e2658656e676d45ec30ef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923a0f4e8600365d5659f8f5e28e425c/" rel="bookmark">
			c语言占位符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用占位符：
%d, %i------代表整数，%f------浮点数，%s------字符串，%c------char. %p------指针，%fL------长log，%e------科学计数法，%g------小数或科学计数法。
C语言中的格式占位符：
%a,%A 读入一个浮点值(仅C99有效)
%c 读入一个字符
%d 读入十进制整数
%i 读入十进制，八进制，十六进制整数
%o 读入八进制整数
%x,%X 读入十六进制整数
%s 读入一个字符串，遇空格、制表符或换行符结束。
%f,%F,%e,%E,%g,%G 用来输入实数，可以用小数形式或指数形式输入。
%p 读入一个指针
%u 读入一个无符号十进制整数
%n 至此已读入值的等价字符数
%[] 扫描字符集合
%% 读%符号
数据类型和占位符之间的对应关系
char和unsingned char %c
short %hd
unsigned short %hu
long %ld
unsigned long %lu
int %d
unsigned int %u
float %f/%g
double %lf/%lg
%f和%lf会保留小数点后面多余的0 如 3.1400000 .2%f得 3.14
%g和%lg不会保留 如 3.14
————————————————
版权声明：本文为CSDN博主「lulubaby_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lulubaby_/article/details/108946925
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6fe940609dc23c8a968034208db16a/" rel="bookmark">
			Python Matlab R的Mann-Kendall趋势检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python Matlab R的Mann-Kendall趋势检验 水文气象中推荐使用Mann-Kendall趋势检验
这是一种非参数统计检验方法，在中心趋势不稳定时，关注数据的秩。
该方法不需要不需要满足正态分布的假设，因而具有普适性。
根据自己需要（图像、并行计算、线趋势图等等）分享python\matlab\R的方法
Python进行Mann-Kendall趋势检验 代码如下：
# -*- coding: utf-8 -*- from __future__ import division import numpy as np import pandas as pd from scipy import stats from scipy.stats import norm def mk_test(x, alpha=0.05): """ This function is derived from code originally posted by Sat Kumar Tomer (satkumartomer@gmail.com) See also: http://vsp.pnnl.gov/help/Vsample/Design_Trend_Mann_Kendall.htm The purpose of the Mann-Kendall (MK) test (Mann 1945, Kendall 1975, Gilbert 1987) is to statistically assess if there is a monotonic upward or downward trend of the variable of interest over time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad6fe940609dc23c8a968034208db16a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3deae101254d6408b4a69068722c2d99/" rel="bookmark">
			微信小程序网易云音乐设计与实现  毕业设计-附源码261620
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于SSM微信小程序的网易云音乐 摘 要 随着我国经济迅速发展，人们对手机的需求越来越大，各种手机软件也都在被广泛应用，但是对于手机进行数据信息管理，对于手机的各种软件也是备受用户的喜爱，微信小程序的网易云音乐系统被用户普遍使用，为方便用户能够可以随时进行微信小程序的网易云音乐系统的数据信息管理，特开发了基于微信小程序的网易云音乐系统的管理系统。
微信小程序的网易云音乐系统主要是对系统所要实现的功能进行详细考虑，确定所要实现的功能后进行界面的设计，在这中间还要考虑如何可以更好的将功能及页面进行很好的结合，方便用户可以很容易明了的找到自己所需要的信息，还有系统平台后期的可操作性，通过对信息内容的详细了解进行技术的开发。
微信小程序的网易云音乐系统的开发利用现有的成熟技术参考，以源代码为模板，分析功能调整与微信小程序的网易云音乐系统管理的实际需求相结合，讨论了基于微信小程序的网易云音乐系统管理的使用。 关键词：微信小程序的网易云音乐系统；JAVA
Netease cloud music based on SSM wechat applet Abstract With the rapid development of China's economy, people's demand for mobile phones is increasing, and various mobile phone software are also widely used. However, for data information management of mobile phones, various mobile phone software are also loved by users. Netease cloud music system of wechat applet is widely used by users. In order to facilitate users to manage the data information of Netease cloud music system of wechat applet at any time, The management system of Netease cloud music system based on wechat applet is developed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3deae101254d6408b4a69068722c2d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df6c8f46f044bf019b84713aa25e4f1/" rel="bookmark">
			C&#43;&#43;之class和struct的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，struct是一个数据类型，所以struct内不能定义函数；
在C++中保留了struct关键字，并且进行了补充，struct类似于class，可以有成员变量和成员函数,可以实现继承和多态.
C++中struct和class的区别
struct成员默认是public属性,而class成员默认是private属性 struct默认继承方式是public,而class默认继承方式是private struct不可以使用模板,而class可以使用模板 C++是面向对象的语言,所以编程单位是类,所以下面简单对struct进行演示
#include&lt;iostream&gt; using namespace std; struct A { int m_age; string m_name; A() {} A(int age, string name) :m_age(age), m_name(name) {} void show() { cout &lt;&lt; "name：" &lt;&lt; m_name &lt;&lt; "，age：" &lt;&lt; m_age &lt;&lt; endl; } ~A() {} }; struct B :A { int m_no; B(struct A a, int no) { m_age = a.m_age; m_name = a.m_name; m_no = no; } void show() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0df6c8f46f044bf019b84713aa25e4f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0981d9526b53493a43e8444b2a0f21c0/" rel="bookmark">
			(十二) Docker-compose容器编排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker-compose 一、概述1、简介2、作用3、下载 二、核心概念三、使用步骤四、Compose常用命令五、Compose编排微服务实践一、构建项目的镜像1、建立数据库表2、POM文件3、YAML4、主启动类5、业务类1、生成简易代码2、配置类3、实体类4、Mapper5、Service6、Controller 6、打 Jar 包上传服务器，编写 DockerFile7、构建镜像 二、不用Compose的情况下三、使用Compose1、编写docker-compose.yml文件3、修改项目配置文件重新打Jar包3、执行Compose4、进入mysql容器实例并新建库db2023以及新建表t_user5、测试6、停止容器 一、概述 1、简介 Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排
Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器
这是类似于Spring的对比
2、作用 如果需要同时部署多个服务,这样每个服务都需要单独写Dockerfile然后在构建镜像,构建容器，这是非常繁琐的，为了解决这个问题,所以有了Compose
Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project） 可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。
Docker-Compose 解决了容器与容器之间如何管理编排的问题。
3、下载 现在都是Docker Desktop进行管理，具体可以参考官方文档
官网文档说明
https://docs.docker.com/compose/compose-file/compose-file-v3/
官网下载
https://docs.docker.com/compose/install/
安装
新版本不用下，一般自带可以通过命令docker compose -v查看
下载命令
curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose --version 卸载
rm /usr/local/bin/com.docker-compose 二、核心概念 一文件
docker-compose.yml
两要素
服务（service）
一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器
工程（project）
由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。
三、使用步骤 编写Dockerfile定义各个微服务应用并构建出对应的镜像文件使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线 四、Compose常用命令 docker-compose -h # 查看帮助 docker-compose up # 启动所有docker-compose服务 docker-compose up -d # 启动所有docker-compose服务并后台运行 docker-compose down # 停止并删除容器、网络、卷、镜像。 docker-compose exec yml里面的服务id # 进入容器实例内部 docker-compose exec docker-compose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0981d9526b53493a43e8444b2a0f21c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce13c182e9e4570b9bda40e3c803bd50/" rel="bookmark">
			docker释放镜像空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 清理无容器使用的镜像 docker system prune -a 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0d5e4fcf2917d42c55e4b484483587/" rel="bookmark">
			2d-rts 大规模实时寻路方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 基础概念 grid map 2d-rts游戏一般不用物理引擎而用网格地图（比如：老古董wymsum，红警2好像也是）来实现地图功能，这里也使用网格地图，不用物理引擎和导航网格体默认每个grid最多放一个单位，就不需要用rvo2避让算法，也不需要碰撞基于grid map的寻路一般有寻路距离限制，地图大小限制，路太长图太大会有性能瓶颈，达不到”实时“的要求 a*寻路算法 a*算法的结果并不是最优路径，但它的速度快如果a*的目标点不可达，那a*会将能遍历的区域都遍历一遍，这将无法发挥它的优点，另外有的目标点需要a*遍历地图的大部分才能找到路线，这也是个性能问题 flow field pathfind 算法 有利于群体寻路，这个算法好像是主流生成流场会从目标点开始广度优先遍历全图，将比a*更消耗性能，需要优化 二. 解决a*目标点不可达 带来的性能问题 设置 max_deep max_deep为最大遍历次数，当超过该次数时，以当前遍历到的路线为最终路线，这样就改变了目标点的位置
新进/线程+回调 既然需要时间，那就等吧，别阻塞当前程序就行
动态标记哪些位置可达或不可达 并不好用
先看这种情况 一张地图上有几个岛（岛与岛之间没有陆地连接），其余都是海，单位无法移动到海中，只能在陆地上移动，A岛的单位自然也无法移动到B岛
这种情况较好解决，只要在游戏初始化好前（包括制作地图时）标记好每个grid属于A岛、B岛还是海。当目标点为属于海或其他岛时，该点则不可达。
如果策划非要到这个点，
单位位置与该点连一条线段，从靠近该点的一端开始遍历，将第一个可以到达的点更新为目标点以该点为起始点广度优先遍历出第一个可以到达的点，并更新为目标点，这可能出现新的性能问题 单位环（仅idea） 接上，一个岛上有好几个单位围成一个环，中间有几块空地没有单位，这些空地就是无法到达的地方，这个问题我还没实现过，只有思路
可以在一帧当中的恰当时机，遍历所有单位生成环，在起始点和目标点连一条线段，线段与环的交点情况：
如果一个环与线段有连续的交点，将这些交点视为一个交点
如果一个环与线段有连续的交点，该段交点的两个端点，如果它们附近不在线段上的点都在线段同一侧，则将该段交点视为零个交点，否则视为一个交点
偶数个交点：目标点和起始点没有被该环包围，可达奇数个交点：目标点或起始点被环包围，不可达 三. 寻路地图构建 默认是grid map
这里需要用到一些游戏逻辑层的东西
单位移动引擎 坦克只能在陆地上行走，船只能在上面行走，直升机可以在任何地方行走，这几种单位所用的移动引擎各不相同
引擎对应的移动地图 一张grid map 地形图当中可能由：山、丘陵、河流、海
那么，对于坦克的引擎的移动地图，就要从地形图当中映射
def geo_mapper(v): # 9999 表示不可到达 table = {山:1, 丘陵:1, 河流: 9999, 海: 9999} return table.get(v) 得出一张坦克引擎的移动地图，a*就是依据这张地图来进行计算的
接受多个图层的影响 依据上面的mapper，坦克可以移动岛丘陵上，但当该丘陵上有一个单位时，由于一个grid最多放一个单位，该坦克就无法移动到丘陵上
这时可以再加一个单位图层，用来标记单位的位置，可以规定：0表示没有单位，其他值表示有单位，添加引擎对单位地图的更新函数
def unit_mapper(v): return 0 if v == 0 else 9999 移动地图的更新 当地形图更改、单位移动、单位创建和单位摧毁都会局部更新移动地图，这个步骤不怎么消耗性能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee0d5e4fcf2917d42c55e4b484483587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/722fc99085573f291c4c328892f6747a/" rel="bookmark">
			【Vue】this代表什么含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. vue组件中2. 回调函数3. 箭头函数4. 直接调用5. 方法调用6. new调用来源 先来个this的翻译帮助下理解 this 指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式(直接调用、方法调用、new调用、bind、call、apply、箭头函数)决定了 this 指向。
1. vue组件中 在Vue所有的生命周期钩子方法（如beforeCreate，created，beforeMount，mounted，beforeUpdate， updated，beforeDestroy以及destroyed）里使用this，this指代调用它的Vue实例，即（new Vue）
new Vue({ data: { a: 1 }, created: function () { console.log('a is: ' + this.a) } methods: { plus: function () { this.a++ } } }); vue组件或者实例中，不管是生命周期钩子函数created还是自定义函数plus，他们中的this都是指当前vue实例
2. 回调函数 methods: { searchLocations: function() { var address = this.search var geocoder = new window.google.maps.Geocoder() geocoder.geocode({ address: address }, function(results, status) { if (status === window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/722fc99085573f291c4c328892f6747a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e9dfda8f7b399473bb481d41035761/" rel="bookmark">
			torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 12.00 MiB (GPU 0; 1.96 GiB total ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个CUDA内存错误，代表GPU内存不足，无法分配12.00 MiB的内存。您可以尝试设置max_split_size_mb以避免内存碎片，以获得更多的内存。请参考PyTorch的内存管理文档以获得更多信息和PYTORCH_CUDA_ALLOC_CONF的配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7930f9f00c18d7846af261ecf95a6f2/" rel="bookmark">
			Android在xml文件 添加了按钮 但是运行后 虚拟机或者手机上无法显示的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先确定xml里面 对应的context 是不是对应的Activity类，名字是否正确；
2.确定对应的Activity类里面的 setContextView(R.layout.xxx)这个是不是你对应的xml；
3.确定initView里面有没有声明这个按钮或者其他 findViewById(R.XXXX)；
4.这个按钮绑定的Click事件方法是否正确；
5.布局是否超出界限(可先设置固定的宽高测试)；
6.没了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27231e9573289abbae6fd3239c1ce0a8/" rel="bookmark">
			常用的消息队列的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 消息队列的作用： 1、应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；
2、异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；
3、限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；
4、消息驱动的系统：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；
首先选择消息队列要满足以下几个条件： 1、开源
2、流行
3、兼容性强
消息队列需要： 1、消息的可靠传递：确保不丢消息；
2、Cluster：支持集群，确保不会因为某个节点宕机导致服务不可用，当然也不能丢消息；
3、性能：具备足够好的性能，能满足绝大多数场景的性能要求。
RabbitMQ RabbitMQ 2007年发布，是一个在 AMQP (高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。
优点 1、RabbitMQ 的特点 Messaging that just works，“开箱即用的消息队列”。RabbitMQ 是一个相对轻量的消息队列，非常容易部署和使用；
2、多种协议的支持：支持多种消息队列协议，算的上是最流行的消息队列之一；
3、灵活的路由配置，和其他消息队列不同的是，它在生产者 （Producer）和队列（Queue）之间增加了一个Exchange模块，你可以理解为交换机。这个Exchange模块的作用和交换机也非常相似，根据配置的路由规则将生产者发出的消息分发到不同的队 列中。路由的规则也非常灵活，甚至你可以自己来实现路由规则。
4、健壮、稳定、易用、跨平台、支持多种语言、文档齐全，RabbitMQ的客户端支持的编程语言大概是所有消息队列中最多的；
5、管理界面较丰富，在互联网公司也有较大规模的应用；
6、社区比较活跃。
缺点 1、RabbitMQ 对消息堆积的处理不好，在它的设计理念里面，消息队列是一个管道，大量的消息积压是一种不正常的情况，应当尽量去避免。当大量消息积压的时候，会导致RabbitMQ的性能急剧下降；
2、性能上有瓶颈，它大概每秒钟可以处理几万到十几万条消息，这个对于大多数场景足够使用了，如果对需求对性能要求非常高，那么就不太合适了。
3、RabbitMQ 使用 Erlang。开发，Erlang 的学习成本还是很高的，如果后期进行二次开发，就不太容易了。
RocketMQ RocketMQ出自阿里公司的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，消息可靠性上比 Kafka 更好。经历过多次双十一的考验，性能和稳定性还是值得信赖的，RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。
优点 1、单机吞吐量：十万级；
2、可用性：非常高，分布式架构；
3、消息可靠性：经过参数优化配置，消息可以做到0丢失，RocketMQ 的所有消息都是持久化的，先写入系统 PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据；
4、功能支持：MQ功能较为完善，还是分布式的，扩展性好；
5、支持10亿级别的消息堆积，不会因为堆积导致性能下降；
6、源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控。
缺点 1、支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟；
2、社区活跃度一般，作为国产的消息队列，相比国外的比较流行的同类产品，在国际上还没有那么流行，与周边生态系统的集成和兼容程度要略逊一筹；
3、没有在 mq 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27231e9573289abbae6fd3239c1ce0a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5b1eee6e29c34e82091befd9878c3d/" rel="bookmark">
			看书标记【R语言 商务数据分析实战5】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看书标记——关于R语言 chapter 55.2 任务实现 【R语言 商务数据分析实战5】 chapter 5 金融服务机构资金流量预测
数据理解和预处理&gt;&gt;检验平稳性+纯随机性&gt;&gt;得到模型阶数建立ARIMA模型
5.2 任务实现 检验数的平稳性
# 设置工作目录并读取数据 setwd() # 快速读取数据 dataFile &lt;- data.frame(data.table::fread('./data/user_balance_table.csv')) # 日期转化为标准时间格式 dataFile$report_date_new &lt;- as.Date(as.character(dataFile$report_date), '%Y%m%d') # 创建一个新的数据集，对相同日期的资金申购量进行统计 library(plyr) data.purchase &lt;- ddply(dataFile, .(report_date_new), summarize, purchase = sum(total_purchase_amt)) # 绘制时序图 purchase &lt;- ts(data.purchase$purchase, start = c(2013, 7), end = c(2014, 8), frequency = 365) plot(purchase, type="l", ylab = "inflows", xlab = "date", xaxt = "n") acf(purchase, lag.max = 30) # 数据自相关检验 # 处理非平稳序列 # 筛选2014-03-01至2014-07-31的数据作为训练集，2014—08数据作为测试集 index &lt;- which(data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f5b1eee6e29c34e82091befd9878c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ff142fbfe2d88a83408f9af83e45c5a/" rel="bookmark">
			Java 后端接收前端的富文本参数，传到后台后标签样式数据丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 前端传参的时候，某个参数中是富文本格式，格式如下：
{ "id": "698002e34cb64156ade62a073699f5d9", "apiName": "基本信息测试", "code": "ONLINE-CYCZGJ-202302110936", "reqParam": "&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;参数英文名&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;参数中文名称&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;参数是否必填&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;参数值是否可空&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;idCardNo&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;false&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;"
}
reqParam这个参数传递到后台之后，接收的数据变为： 参数英文名参数中文名称参数是否必填参数值是否可空，其中的&lt;table&gt;&lt;toboy&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;等标签全部丢失
问题定位： 拦截攻击问题，默认会把字符串中含有代码的标签过滤
解决办法： #xss配置,防止xss攻击 xss: #过滤开关 enabled: false #排除链接（多个用逗号分隔） excludes: /dataservice/apiserviceregister/save #匹配链接 urlPatterns: /dataservice/* 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706936ccac42e81f9ed5962ec0573ca1/" rel="bookmark">
			频率与波长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		射频设计时要考虑的除了指标外，还有一些需要注意的地方，比如在外壳的设计时，其内腔的大小尺寸需要与所工作的频率相关，这也就涉及到波长的关系，而频率与波长的关系是相反的，即频率越高，波长越短，如1GHz时波长约30CM，而到了10GHz时波长则变成了3CM,因此内腔的空间尺寸要避免与波长的二分之一相同，同样对体积的限制也就更多，但波长的较低也会对产品的小型化有极大便利，比如射频天线的便携及微型化共体，当然频率也会变高，带来的改善是为信号的传输增加了带宽，提升了信号的传输效率，频率与波长的计算公式为光速除以频率等于波长，光速约为3乘以10的8次方，频率的单位为Hz，波长的单位为m，综合考虑频率与波长的影响，是提升产品可靠性的重要措施。仅供参考！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb92352a331f6c92a0c01a8577552e19/" rel="bookmark">
			PCIE物理层、数据链路层与物理层、Zynq的优势及应用小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.大纲 1.PCI体系结构的事务层、数据链路层和物理层的大致实现过程
2.Zynq的优势及其应用场所
2.内容 1.事务层
传送TLP包，包括很多不同类型的TLP，TLP的结构，如何被传送，有关事务层的讲解和PCIE的拓扑图紧密结合，可见事务层处于一个比较系统的视野。
2.数据链路层
给出了一个比较清晰的例子，大致讲了数据链路层是如何从事务层接受包，并发送到接受端，这里印象深刻的有滑动窗口模型和ACK/NCK应答报文，滑动窗口中存放了数据报文，只有当接收到成功接收的指令时才会清空一部分已经成功发送的指令；当接收到发送失败的指令时，会重新发送；重新发送的过程不会一直持续下去，超过一定的时间会进行数据链路的同意训练；为了提高利用率，应答报文会在超过阈值或者计时器技术结束后统一发送；
3.物理层
1）明确了差分传输的重要性，在高速链路中大多都采用差分传输，其抗干扰能力强
2）发送逻辑与接收逻辑的结构，其中大致包括了缓存、多路选择器、加扰（减少EMI电磁干扰）、编解码（8/10b）、分不同链路发送等
3）物理层中传输数据的类型，不仅仅有TLP、DLLP、PLP，按照内容可以分为数据和控制字符，编码过程对于这两种字符是不一样的
4）编码过程主要是为了平衡报文中的1和0，保证直流平衡，因为假如1太多电容会充满，电容就无法正常工作
4.Zynq的优势总结
1）ARM相比软核（microblaze）性能优势显著，可以运行在更高的工作频率，而优势可以将ARM与软核搭配使用；ARM与其他硬处理器（PowerPC）相比也有较大的优势
2）与单处理器相比，加了FPGA的Zynq可以进行更多的并行计算，有加速效果
3）与处理器+FPGA结构相比，Zynq将ARM与FPGA合并成一个芯片，可以减小体积和功耗，减小成本，缩短两方通信的时间
5.Zynq的应用场所
软件无线电、视频与图像处理、医疗、智能系统……这里以软件定义无线电为例子着重讲了动态重构的概念DPR，说明是如何用一个通用的架构来实现不同的无线电功能，可以将系统的架构标准化，使用更小的芯片、更低的功耗达成更多功能的需求
参考文献
1.PCI EXPRESS 体系结构导读
2.The_Zynq_Book_ebook_chinese
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40de57f4a61ac2f73f0804b35dbd75cc/" rel="bookmark">
			Python中requests库使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中requests库使用方法详解 前言：一、什么是Requests二、安装Requests库三、各种请求方式1. 基本的GET请求2. 带参数的GET请求3. 解析json4. 获取二进制数据5. 添加headers6. 基本POST请求 三、响应四、高级操作1. 文件上传2. 获取cookie3. 会话维持、模拟登陆4. 代理设置5. 异常处理 前言： 开发环境：Windows10专业版
开发软件：Pycharm Community 2022.3
一、什么是Requests Requests 是⽤Python语⾔编写，基于urllib，采⽤Apache2 Licensed开源协议的 HTTP 库。它⽐ urllib 更加⽅便，可以节约我们⼤量的⼯作，完全满⾜HTTP测试需求。
二、安装Requests库 在前面的Python基础中我们已经在电脑中配置好了Python环境
如果你还没有安装Python环境可以参考我的这篇文章Python基础——0.Python环境的安装___H2__的博客-CSDN博客
进入命令行win+R执行命令提示符
输入：pip install requests 即可开始安装requests库
项目导入requests：import requests
三、各种请求方式 各种请求方式的使用方法是：
import requests requests.post('http://httpbin.org/post') requests.put('http://httpbin.org/put') requests.delete('http://httpbin.org/delete') requests.head('http://httpbin.org/get') requests.options('http://httpbin.org/get') 这五种请求的意义分别是：
GET： 请求指定的页面信息，并返回实体主体。
HEAD： 只请求页面的首部。
POST： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。
PUT： 从客户端向服务器传送的数据取代指定的文档的内容。
DELETE： 请求服务器删除指定的页面。
**get 和 post比较常见 **
GET:请求将提交的数据放置在HTTP请求协议头中；
POST:提交的数据则放在实体数据中
1. 基本的GET请求 import requests response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40de57f4a61ac2f73f0804b35dbd75cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf633acc78633777aca36d068e05456/" rel="bookmark">
			字节跳动青训营--前端day5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、初识HTTP拓展—输入地址到页面渲染发生了哪些事情 二、协议分析1.发展2.报文2.1 请求报文：请求行：请求头主体 2.2 响应报文：状态行响应头响应正文 2.3缓存 3.发展3.1 Http23.2 Https 三、拓展 前言 仅以此文章记录学习历程
一、初识HTTP HTTP (HyperText Transfer Protocol)
超文本运输协议：是实现网络通信的一种规范是应用层协议，基于TCP协议分为请求和响应两个部分简单可拓展（支持自定义，如：header等）是无状态协议 拓展—输入地址到页面渲染发生了哪些事情 详细了解地址：web前端面试系列（这是我觉得讲的比较详细的一篇文档了）
二、协议分析 1.发展 2.报文 客户端发送的叫请求报文服务器发送的叫响应报文
如上图：主要分为三部分：
2.1 请求报文： 请求行： 主要分为三个部分：请求方法；请求路径；http的版本
请求方法：（前4为常用方法）
请求头 即HTTP header fields。指在HTTP的请求和响应消息中的消息头部分
作用：它们定义了一个超文本传输协议事务中的操作参数
请求头作用Host指明了请求将要发送到的服务器主机名和端口号User-Agent用户代理；可以用来区分软件类型，操作系统，手机还是浏览器，软件开发商等Accept接收类型，表示浏览器支持的MIME类型(对标服务端返回的Content-Type)Connection决定当前的事务完成后，是否会关闭网络连接Upgrade-Insecure-Requests表示客户对加密和认证响应的偏好Content-Type客户端发送出去实体内容的类型Content-Length客户端发送出去实体内容的长度Cache-Control指定请求和响应遵循的缓存机制，如no-cachelf-Modified-Since对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内lf-None-Match对应服务端的ETag，用来匹配文件内容是否改变 (非常精确)Expires缓存控制，在这个时间内不会请求，直接使用缓存，服务端时间Max-age代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存Cookie有cookie并且同域访问时会自动带上Referer该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段) HTTP头部字段可以自己根据需要定义
主体 常用于post和put等请求传递参数
2.2 响应报文： 状态行 主要分为三个部分：http版本；状态码；状态信息
常见状态码：
响应头 响应头作用Server指明了服务器应用程序软件的名称和版本Content-Type服务端返回的实体内容的类型Content-Length服务端返回的实体内容的长度Date报文创建的日期和时间Keep-Alive连接的状态（可以用来设置超时时长和最大请求数）Connection决定当前的事务完成后，是否会关闭网络连接Age对象在缓存代理中存贮的时长Last-Modified请求资源的最后修改时间Expires应该在什么时候认为文档已经过期,从而不再缓存它Max-age客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效ETag资源的特定版本的标识符，Etags类似于指纹Set-Cookie设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端Access-Control-Allow-Origin服务器端允许的请求Origin头部 (警如为*) 响应正文 通常用来返回响应体
2.3缓存 3.发展 3.1 Http2 相比之前版本更快、更稳定、更简单
HTTP/2连接都是永久的，而且仅需要每个来源一个连接流控制:阻止发送方向接收方发送大量数据的机制服务器推送 新增特性：
多路复用：在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”二进制分帧：采用二进制格式传输数据，而非 HTTP 1.x的文本格式，解析起来更高效首部压缩：在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送服务器推送：这种方式非常合适加载静态资源，免得客户端再次创建连接发送请求到服务器端获取 3.2 Https HTTPS : Hypertext TransferProtocol Secure
经过TSL/SSL加密
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cf633acc78633777aca36d068e05456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f758d87a3855d767fd074c4f0111d3da/" rel="bookmark">
			Spring Security在前端后端分离项目中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security 是 Spring 家族中的一个安全管理框架，可以和Spring Boot项目很方便的集成。Spring Security框架的两大核心功能：认证和授权
认证： 验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户。简单的理解就是登陆操作，如果可以登录成功就说明您是本系统的用户，如不能登录就说明不是本系
统的用户！而且登录成功以后需要记录当前登录用户的信息！
授权：经过认证后判断当前用户是否有权限进行某个操作！
如上图所示就是展示了当前登录用户可以操作的权限：用户管理、角色管理、菜单管理等，并且针对角色管理可以进行新增、修改、删除、导出等权限。
而现在前后端分离开发成为了主流的开发方式，那么在前后端分离开发方式下如何使用Spring Security就是本文章需要重点研究的内容。
2、Spring Security认证功能
2.1 前端分离项目的认证流程
要想了解如果使用Spring Security进行认证，那么就需要先了解一下前后端分离项目中的认证流程，如下所示：
2.2 Spring Security原理初探
要想使用Spring Security框架来实现上述的认证操作，就必须先要了解一个Spring Security框架的工作流程。
2.2.1 过滤器链
Spring Security的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。
图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。
UsernamePasswordAuthenticationFilter: 负责处理我们在登陆页面填写了用户名密码后的登陆请求。
ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。
FilterSecurityInterceptor：负责权限校验的过滤器。
2.2.2 认证流程
Spring Security的认证流程大致如下所示：
概念速查:
Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。
AuthenticationManager接口：定义了认证Authentication的方法
UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。
UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。
2.3 认证实现
在前后端分离项目中，前端请求的是我们自己定义的认证接口。因为在认证成功以后就需要针对当前用户生成token，Spring Security中提供的原始认证就无法实现了。在我们自定
义的认证接口中，需要调用Spring Security的API借助于Spring Security实现认证。
2.3.1 思路分析
认证：
1、自定义认证接口
① 调用ProviderManager的方法进行认证 如果认证通过生成jwt
② 把用户信息存入redis中
2、自定义UserDetailsService
① 在这个实现类中去查询数据库
校验：
1、定义Jwt认证过滤器
① 获取token
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f758d87a3855d767fd074c4f0111d3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b2a3b0495e272f2a206ef1b0a74326/" rel="bookmark">
			linux防火墙，端口，进程命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux防火墙，端口，进程常用的一些命令
firewall-cmd --zone=public --add-port=5672/tcp --permanent #开放5672端口（开放后需要要重启防火墙才生效） firewall-cmd --zone=public --remove-port=5672/tcp --permanent #关闭5672端口（关闭后需要要重启防火墙才生效） firewall-cmd --reload #配置立即生效 firewall-cmd --zone=public --list-ports	#查看防火墙所有开放的端口 systemctl stop firewalld.service	#关闭防火墙 systemctl enable firewalld	#开机启动防火墙 systemctl disable firewalld	#禁止防火墙开机启动 firewall-cmd --state	#查看防火墙状态 firewall-cmd --list-ports	#查看已开放的端口 netstat -lnpt	#查看监听的端口 netstat -tunlp |grep 5672	#检查端口被哪个进程占用 -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 ps 6832	#查看进程的详细信息 kill -9 6832	#中止进程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc08ce5bbbeaeb2e2a926c1ee76207b/" rel="bookmark">
			STC89C52输出14Hz~1KHz的PWM，频率可调，占空比1%~99%可调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/***************************************************************** * 功能描述: 输出PWM，可调频率范围14Hz~1KHz，占空比1%~99% * 修改日期: 2021年5月18日 * 硬件说明: 11.0592M *****************************************************************/ /*-----------------------包含头文件区域-------------------------*/ #include&lt;reg52.h&gt; //单片机头文件 #include "stdio.h" #include "string.h" #include "stdarg.h" /*-----------------------数据类型定义区域-----------------------*/ typedef unsigned char u8; //定义类型unsigned char别名为u8 typedef unsigned int u16; //定义类型unsigned int别名为u16 typedef unsigned long u32; //定义类型unsigned int别名为u16 /*-----------------------端口/引脚定义区域----------------------*/ sbit LED = P2^7; //定义P2.7引脚名为LED sbit KEY1 = P3^2; //定义P3.2引脚名为KEY1 sbit KEY2 = P3^3; //定义P3.3引脚名为KEY2 sbit KEY3 = P3^4; //定义P3.4引脚名为KEY3 sbit KEY4 = P3^5; //定义P3.5引脚名为KEY4 /*-----------------------用户自定义数据区域---------------------*/ #define FOSC 11059200L //系统时钟 #define UART_BAUD 9600 //串口波特率 #define TIMER_CLOCK FOSC / 12 //定时器时钟（系统时钟/12T模式） //定时器值 =（-（定时器时钟/32）/波特率）32是波特率因子，代表移动一位需要多少个时钟脉冲 #define Timer1_value (-(TIMER_CLOCK/32)/UART_BAUD) #define T1_10us(x) (65536-(((float)TIMER_CLOCK / 100000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc08ce5bbbeaeb2e2a926c1ee76207b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704b922302a7d985577e76856943b2ae/" rel="bookmark">
			关于Kali修改静态IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么修改kali中IP地址为静态？ 步骤 vim /etc/network/interfaces -------&gt;注意，一定要是root用户 会出现这样的界面
然后须在这后面添加
auto eth0 iface eth0 inet static address **.**.**.** -------&gt;这里输入你想要设置的静态IP地址 netmask 255.255.255.0 ------&gt;这里看你的IP地址是几类的，一般为C类，然后是3个255 gateway **.**.**.** -------&gt;这里的网关基本上与address的前三位保持一样，然后最后一位一般为2 dns 114.114.114.114 -----&gt;一般国内的dns 最后保存再退出进行服务重启就行啦
service networking restart -----重启网络服务 总结 以上就是文章的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f95abae5766d430aa71e2599948e59/" rel="bookmark">
			ics文件添加到系统日历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ics文件链接是可下载的文件链接。使用系统方法
NSString *urlString =@"";
NSURL *url = [NSURL URLWithString:urlString];
if([[UIApplication sharedApplication] canOpenURL:url]) {
[[UIApplication sharedApplication] openURL:url options:@{} completionHandler:nil];
}
跳转到系统浏览器（默认Safari），按照safari提示一步一步操作，可以将文件内的事件添加到日历上。
重点：
1.ics文件链接后缀为.ics，系统会识别为日历事件链接，可以添加到系统日历。
例子：http://test.ics?text=1
2.ics文件链接后缀为.ics，系统会识别为订阅链接，可以添加到系统日历。
例子：http://test?text=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d0cd907f000786240edc19ad6cb8124/" rel="bookmark">
			nacos注册报错排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos注册报错排查 结论 nacos2版本客户端无法连接nacos1版本的服务端，原因是Nacos2.0版本相比1.X新增了gRPC的通信方式，因此需要增加2个端口
问题背景 本机启动若依系统路由模块，nacos配置为公司服务器提供nacos，发现启动报错；
配置的端口为30848,但是日志显示的是31848端口不可用，以下为相关报错日志和nacos配置
--- #################### 注册中心相关配置 #################### spring: cloud: nacos: server-addr: 172.25.21.186:30848 discovery: namespace: dev # 命名空间。这里使用 dev 开发环境 register-enabled: false --- #################### 配置中心相关配置 #################### spring: cloud: nacos: # Nacos Config 配置项，对应 NacosConfigProperties 配置属性类 config: server-addr: 172.25.21.186:30848 # Nacos 服务器地址 namespace: dev # 命名空间。这里使用 dev 开发环境 group: DEFAULT_GROUP # 使用的 Nacos 配置分组，默认为 DEFAULT_GROUP name: # 使用的 Nacos 配置集的 dataId，默认为 spring.application.name file-extension: yaml # 使用的 Nacos 配置集的 dataId 的文件拓展名，同时也是 Nacos 配置集的配置格式，默认为 properties 2023-02-02 11:05:37.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d0cd907f000786240edc19ad6cb8124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8778f503eac7cf14a157deaf46550ad1/" rel="bookmark">
			ubuntu建立新用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建testuser用户
sudo adduser testuser 2.设置root密码
sudo passwd root
3.更改sudoers编辑权限 sudo chmod u+w /etc/sudoers
4.给testuser新增权限
sudo vim /etc/sudoers
添加一行：
testuser ALL=(ALL:ALL) ALL
5.保存以后关闭sudoers的编辑权限
sudo chmod u-w /etc/sudoers
6.切换用户
su gerrit
7.删除用户
sudo userdel -r testuser ps:如果提示
删除用户出现user xxx is currently used by process xxx的 则是因为这个用户正在使用 , 我们要退出这个用户 ctrl +d(退出当前用户), 切换到其他用户上去,再执行命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe61ff4b28505d43852cc036ba65ef9/" rel="bookmark">
			C/C&#43;&#43;语言编程练习(Dev-C&#43;&#43;工具)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言编程练习 前言： 编程注重实战练习，笔者将近期从头开始敲的C语言代码练习分享出来，打算作为将来自己回顾温习的宝典，同时也可以借互联网的平台为大家一起学习C语言献出绵薄之力。以C语言应试为重心的读者可以快速浏览例题代码并直接翻阅最后的C语言经典习题。
任何代码都是可以被优化的，每个问题也都可以用不同的解法。笔者确保每段源代码在C++环境下都可以运行。读者们有所思所想的，欢迎评论留言。
关于C语言语法知识点内容，笔者将会写在最新的笔记博客中。知识点和练习都会不断更新内容，力求逐步做到C语言入门的水准。
另外要说明的是，cpp文件兼容C语法，因此笔者的代码主要用C语法，有部分使用C++语法。简单的代码很快过，来回切中英文不方便，因此大部分简单的代码不做中文注释了，但是规范一点的观念还是应该一行代码一行注释。
目录 一、语句的三种基本结构（顺序、分支（选择）、重复（循环））
1.温度转换
2.梯度计价
3.数的位数
4.数列
5.小球落地反弹
6.字符类型判断
猜数字
自动售卖机
简易计算器二、数组（一维、二维）、函数
杂例
1.素数与素数表
2.阶乘和计算
三角形计算附录：C语言经典习题
1.斐波那契数列
2.求圆周率（两种方法） 各章分有案例习题分析和实战项目练习两个板块。例题也是习题，可以先自己写，再比对。
基本代码模板–Hello World! #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { printf("Hello C++World! I'm coming. \r\n\0"); system("pause"); return 0; } 代码分析：首先，最重要的是main函数，也被称作主函数或入口函数，是一切代码执行的入口，一个项目必须有且只能有一个main。关于main，早期编程者使用void main()无需返回值，因安全性问题现在的编程规范要求使用int main(int argc,char const *argv[])，最后函数返回值为0，它可以被简写为int main(void)，void可以省略。
其次，printf库函数的使用，print打印，f函数/功能(function)。注意格式使用，善用printf可以使控制台程序的交互性很好。注意我们要使用库函数时，需要和系统“打个招呼”，也就是声明使用到的头文件，这是很重要的一点。输出函数printf和读取函数scanf都 包含(include)在标准(standard)输入(input)输出(output)头文件(.header)中，即include &lt;stdio.h&gt;，再(#)打个戳就行了。
最后，为了让程序的结束由人来控制，笔者习惯加上system(“pause”);，当然也可以加getchar();。它应该需要用到标准静态链接库lib ，&lt;stdlib.h&gt;。
其实单单一个printf库函数就包含C的很多知识点，笔者也刚入门，在这里就这样点一下，有兴趣的读者可以另外查阅资料深入了解。printf读入的字符串默认补’\0’（即字符串结束标志NULL，ASCII码值也为0），如果遇到’\0’，后面的字符均不再被输出。‘\n’是换行，即跳至下一行，一般用来替代’\r’‘\n’，'\r’是回车，这里头包含了计算机发展的历史，在UNIX和MAC系统中行末只有\n（前者）或\r（后者）而Windows系统行末是\r\n。
掌握调试–Debug 打断点，逐步运行代码，查看变量值变化，找出原因修改代码或优化代码。
一、语句的三种基本结构 案例习题分析 例1：温度转换 华氏度转换成摄氏度
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int c, f; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe61ff4b28505d43852cc036ba65ef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7219f177c471788ab57953e7ea40be/" rel="bookmark">
			win10系统远程连接桌面窗口太小怎么调大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程桌面窗口太小，看不清桌面信息调整方法
1.左下角开始邮件--&gt;运行
2.运行--&gt;mstsc
3.显示选项
4.显示选项--&gt;显示 调整大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8cceb40eadebdbff20ce5704533c7f/" rel="bookmark">
			文本数据预处理:可能需要关注这些点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、文本数据获取2、常规文本数据预处理2.1 将文本数据清洗干净2.2 将文本数据格式化 3、任务相关的文本数据预处理3.1 不平衡问题3.2 数据增强问题3.3 数据标注问题 4、一些可用的文本预处理工具5、总结 本文关键词： 文本数据预处理、中文文本预处理、自然语言处理
摘要： 要进行自然语言处理相关工作，文本数据预处理是个必不可少的过程。本文将对文本数据预处理相关的内容进行归纳整理，主要包括以下4个方面内容：
文本数据获取常规文本数据预处理任务相关的文本数据预处理文本预处理工具 1、文本数据获取 “巧妇难为无米之炊”，要做文本数据处理，首先需要获得文本数据。对于此问题，大家可以“八仙过海，各显神通”，借助一切合法、合理方式收集数据集。一般的，可以通过：自有数据整理、公开数据爬取和开源数据引用三个渠道获取数据。
自有数据：收集整理自有或者组织内部的可用数据集。
爬取数据：爬虫是获取数据的重要手段，但是在执行该操作前需遵守相关法规和Robots协议，在爬取数据后合法应用数据。通常，可以通过requests、BeautifulSoup4和Selenium等python工具完成绝大多数爬取任务。
图片豆瓣电影评论爬取可参考：
https://www.cnblogs.com/fengxi177/p/16939376.html
开源数据：当前已有很多公开的NLP数据集支撑相关的研究和应用分析，如github项目： 项目名项目链接项目概述CLUEDatasetSearchhttps://github.com/CLUEbenchmark/CLUEDatasetSearch收集了众多中英文NLP数据集funNLPhttps://github.com/fighting41love/funNLP分门别类的组织了众多的NLP数据集和项目awesome-chinese-nlphttps://github.com/crownpku/Awesome-Chinese-NLP收集了中文自然语言处理相关资料Chinese_medical_NLPhttps://github.com/lrs1353281004/Chinese_medical_NLP收集了医疗NLP领域（主要关注中文）评测数据集与论文相关资源 由此，在收集好原始数据集后便可进行后续相关的NLP分析了。
特别的，数据集可以保存为txt、json、csv、tsv、sql表等等格式，只要你喜欢，都可以（哈哈哈，有些格式可能会比较占用内存，较大数据集时需要留意）。
图片此处分享一个csv超大文件数据读取技巧，即利用pandas的chunksize分块读取。
import pandas as pd df = pd.read_csv("data.csv", chunksize=10000) # 每次读取1w行数据 for df_chunk in df: print(df_chunk) 2、常规文本数据预处理 文本数据作为一种非结构化数据，除了特别处理过的数据集，大多数直接收集的文本数据会掺杂或多或少的无用信息，如果直接将其进行相关的文本分析于建模是无益的。通常，需要先对文本数据进行预处理操作。
文本数据预处理的主要目的一般有两个，即：
（1）将文本数据清洗干净（标准自定）
（2）将文本数据格式化（需求自定）
2.1 将文本数据清洗干净 空格换行符，利用replace操作将原始文本中的空格、tab键、换行符\n、\r等与文本无关的字符直接替换为空。
无用信息剔除，如：停用词表构建。
标点符号去除，利用正则表达式去除标点符号，中英文标点符号可以通过如下两个方式获取。
中文标点符号：from zhon.hanzi import punctuation （需要安装包：pip install zhon）
英文标点符号：from string import punctuation
特别的，文本情感分析中，可保留有情感倾向的标点符号，如：？和！
在噪声数据中提取需要数据，利用正则表达式完成数据提取。如：只需要提取汉字时可以利用正则[\u4e00-\u9fa5]
简体繁体转换，可安装包：pip install opencc
英文数据：词形还原、大小写转换等 （推荐python包：NLTK）
2.2 将文本数据格式化 文本分句，根据标点符号分句。文本分段，根据换行符或其他数据规律分段。文本根据字段存储：半结构化文本数据存储excel数据提取，推荐安装python包pandas，pip install pandas
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8cceb40eadebdbff20ce5704533c7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c5cbc11b9af935dc01c22f5e0bd826/" rel="bookmark">
			HDFS通过WEB UI操作文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HDFS通过WEB UI操作文件 1、创建目录2、向指定目录上传文件3、返回上层目录4、移动文件5、删除文件6、修改文件权限、所有者，组等信息7、搜索文件8、查看文件 进入Browse the file system
1、创建目录 2、向指定目录上传文件 3、返回上层目录 4、移动文件 此时查看/button目录下已经没有hadoop.jpg这个文件了。
5、删除文件 6、修改文件权限、所有者，组等信息 注：凡是带有虚线下划线的就是可以修改的属性
7、搜索文件 8、查看文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b53f9c47a8e225a85d1c2c861705c8/" rel="bookmark">
			HDFS常用命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDFS常用命令汇总 一、前言信息二、帮助信息查看1、查看帮助信息2、帮助文档（附带命令的详细说明） 三、常用命令1、创建目录2、查看目录下的内容3、上传文件4、上传并删除源文件5、查看文件内容6、查看文件开头内容7、查看文件末尾内容8、下载文件9、合并下载文件10、拷贝文件11、追加数据到文件中12、查看磁盘空间13、查看文件使用的空间14、移动文件15、修改文件副本个数16、查看校验码信息17、显示路径下的目录、文件和字节数18、从本地拷贝文件19、拷贝文件到本地20、查找目录文件21、删除文件 一、前言信息 官网命令说明查看
说明：
命令适用范围hadoop fs使用范围最广，建议使用，可操作任何对象hadoop dfs只可操作HDFS文件系统(已弃用)hdfs fs只可操作HDFS文件系统，包括与Local FS间的操作hdfs dfs只可操作HDFS文件系统，常用 二、帮助信息查看 1、查看帮助信息 hadoop fs []表示可选参数，&lt;&gt;表示必须参数
2、帮助文档（附带命令的详细说明） hadoop fs –help 三、常用命令 1、创建目录 hadoop fs –mkdir [-p] &lt;path&gt; 2、查看目录下的内容 hadoop fs –ls [-h] [-R] [&lt;path&gt;] -h 人性化显示文件大小 -R 递归查看指定目录及子目录 3、上传文件 hadoop fs –put [-f] [-p] &lt;localsrc&gt; &lt;dst&gt; -f 覆盖目标文件(若文件已存在) -p 保留访问和修改时间、所有权和权限 localsrc 本地文件系统 dst 目标文件系统 4、上传并删除源文件 hadoop fs –moveFromLocal &lt;localsrc&gt; &lt;dst&gt; 这个和put唯一不同的地方就在于该命令会上传完后会删除源文件
5、查看文件内容 读取文件全部内容显示在标准输出控制台(大文件慎用)
hadoop fs –cat &lt;src&gt; 6、查看文件开头内容 查看文件前1KB的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b53f9c47a8e225a85d1c2c861705c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97bf34e9b61b456cc59d33050ed9dac0/" rel="bookmark">
			Cherry-Pick、Squash Commits、Rebase使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Cherry-Pick二、Squash Commits三、Rebase总结 前言 在Git多分支开发场景下，常常会遇到把a分支的提交记录代码复制到b分支，将多次提交记录合并成一个提交等问题，以下将介绍使用IDEA如何快速的实现这些功能。
一、Cherry-Pick cherry-pick的意思是挑选，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。使用场景就是，不想merge整个分支的代码到当前分支，就可以使用cherry-pick了。
以下展示IDEA中如何快速使用cherry-pick
1、如下图中，当前分支为dev2，目标分支为dev。这里将演示从dev分支cherry-pick部分提交记录到dev2分支中，cherry-pick的按钮是一个樱桃一样的小图标。
2、cherry-pick之后，dev2分支有绿色原点，待提交记录。这样就完成了cherry-pick的使用，非常简单。
二、Squash Commits Squash Commits的作用能够将多次提交记录合并成一个。
重复第一个步骤，将dev中四次提交，全部cherry-pick到dev2。选中需要合并的记录，如下图。
Squash之后，会将多个提交信息展示出来，修改成自己需要的信息即可。
看Event Log可以发现，Commited Squashed成功了，右下角出现了蓝色和绿色的原点。这时不要去fetch/update分支代码，因为此时只是在local合并成功了，远程分支还是四个记录，所以就会出现远程分支有未获取的记录。此时，直接push合并的记录到远程分支即可。
未push合并后的分支前
打开git bash，输入命令强制push上去。
git push --force 看到远程分支的多次提交记录也合并成功了。
三、Rebase 以上cherry-pick的操作实际上是通过git的rebase命令去进行合并的。
git rebase -i 命令可以压缩合并多次提交 格式：git rebase -i [startpoint] [endpoint] 其中-i的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint] [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。
pick：保留该commit（缩写:p）reword：保留该commit，但我需要修改该commit的注释（缩写:r）edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）squash：将该commit和前一个commit合并（缩写:s）fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）exec：执行shell命令（缩写:x）drop：我要丢弃该commit（缩写:d） 参考：https://blog.csdn.net/w57685321/article/details/86597808
此处展示两种常用的使用方式：
// 合并最近的两次提交 git rebase -i HEAD~2 按i进入编辑，可以修改pick为fixup，表示使用commit，但是忽略掉comment。修改好后，按Esc退出，在wq保存即可。
观察提交记录和信息，可以看到合并两个请求成功了。
另一种方式如下：
// 合并从当前head到15f745b(commit id) git rebase -i 3261b8f5 这里3261b8f5 是我first commit记录的hash值，同样出现vi编辑框，选择需要的信息wq保存退出即可。
效果如下图
总结 本文介绍了Cherry-Pick、Squash Commits、Rebase的使用，做一个记录。在使用rebase中，有可能出现冲突，按提示解决冲突。如操作失败，可以abort rebase重新弄，不影响分支信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1f6d81d8f30dffa119b8b20a676e94/" rel="bookmark">
			python-oracledb——利用python连接Oracle数据库的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python-oracledb——利用python连接Oracle数据库的利器 python-oracledb功能亮点是：python-oracledb 与 cx_Oracle 使用方法对比cx_Oracle使用方法python-oracledb的使用方法安装方法：独立链接模式使用连接池的方法 之前使用的数据库一直是MySql，偶尔使用PostgreSQL，都是利用的数据库连接池使用；
最近需要在Oracle数据库取数据，因此查找了一下连接的方法。网上大部分都是给出的使用cx_Oracle库进行连接，方法也比较简单。但是在进一步了解的时候发现cx_Oracle库 的最新版本已经升级为python-oracledb了；于是简单探究了一下。
python-oracledb驱动程序是一个Python扩展模块，可以访问Oracle数据库。它具有支持Python数据库API v2.0规范的全面功能，具有相当多的附加内容和一些排除项。
python-oracledb驱动程序是cx_Oracle 8.3的重命名的主要版本继承者。
python-oracledb功能亮点是： 从 PyPI 轻松安装支持多个 Oracle 数据库版本；支持 Python 数据库 API v2.0 规范
执行 SQL 和 PL/SQL 语句广泛的 Oracle 数据类型支持，包括 JSON、大型对象 （ 和 ） 和 SQL 对象的绑定CLOBBLOB
连接管理，包括连接池Oracle 数据库高可用性功能充分利用 Oracle 网络服务基础架构，包括加密的网络流量 python-oracledb 与 cx_Oracle 使用方法对比 cx_Oracle使用方法 import cx_Oracle # 设置连接参数 connection = cx_Oracle.connect(user="hr", password="welcome", dsn="localhost/orclpdb1") cursor = connection.cursor() cursor.execute(""" SELECT first_name, last_name FROM employees WHERE department_id = :did AND employee_id &gt; :eid"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c1f6d81d8f30dffa119b8b20a676e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60853d349bfee5e7a1aa392e4c9c8359/" rel="bookmark">
			CentOS 7上进行gitlab的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS系统上安装所需的依赖：
ssh，
防火墙，
postfix(用于邮件通知) ，
wget，
以下命令也会打开系统防火墙中的HTTP和SSH端口访问
使用命令
yum install -y curl policycoreutils-python openssh-server
安装完成之后，需要启用和启动sshd服务，执行命令：
systemctl enable sshd
systemctl start sshd
打开 /etc/sysctl.conf 文件，在文件最后添加新的一行
输入如下文本：
net.ipv4.ip_forward = 1
这样，就配置好了防火墙。
作用为，当linux主机有多个网卡时，一个网卡收到的信息时可以传递给其他网卡，即数据可以进行转发
systemctl enable firewalld
systemctl start firewalld
systemctl enable firewalld
由于gitlab是需要使用postfix来作为邮件发送服务的，还需安装下以下服务。
直接命令安装，确认安装环节，输入【y】即可：
yum install postfix
安装完成之后，打开/etc/postfix/main.cf 文件，找到inet_protocols = all，将 all 改为 ipv4。
然后，启动postfix，输入命令：
systemctl enable postfix
systemctl start postfix
安装gitlab
到了开始安装gitlab的时刻了
首先，先更改下镜像源地址（该镜像源的地址设置成了清华大学的，下载提速）
在/etc/yum.repos.d 目录下新建 gitlab-ce.repo 文件，并在里面输入如下内容：
[gitlab-ce] name=Gitlab CE Repository baseurl=https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60853d349bfee5e7a1aa392e4c9c8359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ff3fa7a3d57dc56eb52458a1cffe67/" rel="bookmark">
			skynet设计原理和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		skynet设计原理 一、多核并发编程方式二、skynet2.1、skynet简介2.2、环境准备2.3、编译安装2.4、Actor 模型2.5、消息队列2.6、actor公平调度 三、skynet的使用3.1、第一个skynet程序3.2、skynet网络消息3.3、skynet定时消息3.4、skynet actor间消息 四、vscode调试skynet总结 一、多核并发编程方式 （1）多线程。
在一个进程中开启多线程，为了充分利用多核，一般设置工作线程的个数为 cpu 的核心数。memcached 就是采用这种方式。
多线程在一个进程当中，所以数据共享来自进程当中的虚拟内存；这里会涉及到很多临界资源的访问，所以需要考虑加锁。
（2）多进程。
在一台机器当中，开启多个进程充分利用多核，一般设置工作进程的个数为 cpu 的核心数。nginx 就是采用这种方式，nginx 当中的 worker 进程，通过共享内存来进行共享数据；也需要考虑使用锁。
（3）CSP。
以 go 语言为代表，并发实体是协程（用户态线程、轻量级线程）；内部也是采用多少个核心开启多少个线程来充分利用多核。
（4）Actor。
erlang 从语言层面支持 actor 并发模型，并发实体是 actor（在skynet 中称之为服务）；skynet 采用 c + lua来实现 actor 并发模型；底层也是通过采用多少个核心开启多少个内核线程来充分利用多核。
二、skynet 2.1、skynet简介 它是一个轻量级游戏服务器框架，但也不仅仅用于游戏。
轻量级体现在：
实现了 actor 模型，以及相关的脚手架（工具集）：actor 间数据共享机制以及c 服务扩展机制。实现了服务器框架的基础组件。实现了 reactor 并发网络库；并提供了大量连接的接入方案；基于自身网络库，实现了常用的数据库驱动（异步连接方案），并融合了 lua 数据结构；实现了网关服务；时间轮用于处理定时消息。 skynet抽象了actor并发模型，用户层抽象进程；sknet通过消息的方式共享内存；通过消息驱动actor运行。
skynet的actor模型使用lua虚拟，lua虚拟机非常小（只有几十kb），代价不高；每个actor对应一个lua虚拟机；系统中不能启动过多的进程就是因为资源受限，lua虚拟机占用的资源很少，可以开启很多个，这就能抽象出很多个用户层的进程。lua虚拟机可以共享一些数据，比如常量，达到资源复用。
抽象进程而不抽象线程的原因在于进程有独立的工作空间，隔离的运行环境。
sknet的所有actor都是对等的，通过公平调度实现。
2.2、环境准备 ubuntu：
sudo apt-get install git build-essential readline-dev autoconf # 或者 sudo apt-get install git build-essential libreadline-dev autoconf centos：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ff3fa7a3d57dc56eb52458a1cffe67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0eaefa3bcca56c5e256689e576c22fe/" rel="bookmark">
			capabilities 字段字段：V4L2设备具备的能力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* Values for ‘capabilities’ field /
#define V4L2_CAP_VIDEO_CAPTURE 0x00000001 / Is a video capture device /
#define V4L2_CAP_VIDEO_OUTPUT 0x00000002 / Is a video output device /
#define V4L2_CAP_VIDEO_OVERLAY 0x00000004 / Can do video overlay /
#define V4L2_CAP_VBI_CAPTURE 0x00000010 / Is a raw VBI capture device /
#define V4L2_CAP_VBI_OUTPUT 0x00000020 / Is a raw VBI output device /
#define V4L2_CAP_SLICED_VBI_CAPTURE 0x00000040 / Is a sliced VBI capture device /
#define V4L2_CAP_SLICED_VBI_OUTPUT 0x00000080 / Is a sliced VBI output device /
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0eaefa3bcca56c5e256689e576c22fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ebc500fc4628b1bc9b55d0eb6855ce4/" rel="bookmark">
			element-ui组件的使用，导航菜单（NavMenu）组件、分页组件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ElementUI 1、简介：是'饿了么'公司推出的基于Vue2的组件库
2、使用方法：具体可见官网https://element.eleme.cn/#/zh-CN/component/installation ​ （1）在vue项目中安装：npm install element-ui
​ （2）在main.js文件中进行全局的配置
import ElementUI from 'element-ui' ;//导入element-ui库 import 'element-ui/lib/theme-chalk/index.css' ;//导入element-ui的样式文件 Vue.use(ElementUI);//在vue原型上注册外部对象 二、图像组件 &lt;el-image style="width: 100px; height: 100px" :src="url" :fit="fit"&gt; &lt;/el-image&gt; //1.src属性：图像的地址，绑定变量用来指定图片的地址，通常需要使用require来拉取图片 //2.fit属性：确定图片如何适应到容器框（'fill', 'contain', 'cover', 'none', 'scale-down'） //3.lazy属性：图片懒加载（按需加载） 三、导航菜单（NavMenu） 1、导航方向：通过mode属性设置 2、菜单项： &lt;el-menu mode="方向" background-color="背景色" text-color="文本颜色" default-active="默认打开的菜单" active-text-color="活动的菜单的文本的颜色"&gt; &lt;el-submenu index="1"&gt; //菜单项 &lt;template slot="title"&gt; //标题文本 &lt;i class="el-icon-notebook-2"&gt;&lt;/i&gt; //文本前的图标 &lt;span&gt;在线教材&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index="1-1"&gt; //子菜单项 &lt;router-link to="/books" class="link"&gt;出版图书&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="1-2"&gt;教案管理&lt;/el-menu-item&gt; &lt;el-menu-item index="1-3"&gt;教材管理&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; //disabled属性：表示该菜单项不可用 三、上传组件：Upload &lt;el-upload class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ebc500fc4628b1bc9b55d0eb6855ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5016e1a82c184d5a18e3b8889b8ddb2/" rel="bookmark">
			网络编程(socket通信基础)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、socket 简介二、主机字节序与网络字节序三、网络编程中的结构体四、库函数1. socket()函数2. bind()函数3. listen()函数4. connect()函数5. accept()函数补：TCP三次握手与连接队列6. gethostbyname()函数7. send()函数8. recv()函数 五、TCP报文分包和粘包六、客户端和服务端程序客户端服务端 一、socket 简介 套接字，运行在计算机中的两个程序通过socket建立通道，数据在通道中传输。
1) 流socket：基于TCP协议，建立通道（主要）
2) 数据报socket：基于UDP协议，无需建立和维持连接，无通道(比较少)
流socket通信流程：
二、主机字节序与网络字节序 网络字节序： 采用大端字节排序(将高序字节存于起始位置)，网络间通信统一采用网络字节序。
主机字节序： 可能为小端字节排序(将低序字节存于起始位置)，需转化成网络字节序然后进行通信。
两者之间转换函数： htons() //host to network short s-&gt;短(16位)，同理其它函数htonl(),ntohs(),ntohl()。l-&gt;长(32位)
如图为小端转大端(32位)：
三、网络编程中的结构体 struct sockaddr{ //不常用结构体 unsigned short sa_family; //地址类型，AF_xxx IPv4 char sa_data[14]; //14字节供端口和地址使用 }; struct sockaddr_in{ //常用结构体 short int sin_family;	//地址类型 unsigned short int sin_port; //端口号(两字节) struct in_addr sin_addr; //地址(结构体) unsigned char sin_zero[8] //八字节，为了和struct sockaddr一样 2+4+8=14(方便两结构体强制类型转换) }; struct in_addr{ unsigned long s_addr; //地址(linux32位四字节,linux64位八字节，一般是四字节) }; 四、库函数 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5016e1a82c184d5a18e3b8889b8ddb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0df31f9071ccc6c9c15001f7b5ed37/" rel="bookmark">
			看过的文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 微服务与分布式：
CAP与BASE理论
好的技术方案，高level去概述问题：
0.spring Cloud项目：
0.RestTemplate结合Ribbon实现负载均衡： 1.Springcloud Gateway: good, 关于熔断，关于限流。
2.Springcloud Gateway: 客户端只能从网关访问微服务，禁止直接访问服务。
3.SpringCloud Sleuth入门介绍:
4.服务划分--微服务如何拆分(DDD)
5.分布式事务：
6.服务雪崩、降级与熔断
7.Redis 集群原理：
8.RabbitMQ：
二. Spring：
1.Spring源码系列：
2.Spring中Bean的单例与多例：
3.Spring Security:
三. Java：
0.线程
1.大牛：深入了解java，Java内存模型，锁，AQS，CAS(Unsafe类，Atomic)，类加载器，注解，枚举，并发之阻塞队列，等等的系列文章
2.JUC ReentrantLock源码解析：
3.锁的理解与使用：
4.并发编程系列：wait原理的讨论
5.深入了解JDBC之 PreparedStatement 和 Statement：
6.动态代理两种实现方式：
四.云原生：
五.面试题：
六.大杂烩： 1.关于maven聚合项目结构以及怎样打包：
2.IO操作： 3.Mysql连接查询join： 【mySQL】left join、right join和join的区别_wdquan19851029的专栏-CSDN博客 4.关于数据库事务 与 锁（重要）：
5.微服务监控：
6.springboot事务使用与失效情况（重要）：
7.系统扩展AKF理论：
8.响应式编程 到 WebFlux:
9.Spring AOP
一. 微服务与分布式： CAP与BASE理论 cap理论与base理论_月上柳梢头。的博客-CSDN博客_cap理论
[分布式]：分布式系统的CAP理论_Franco蜡笔小强的博客-CSDN博客_分布式cap
好的技术方案，高level去概述问题： 分布式顶层架构设计之--究竟啥才是互联网架构“高可用”_wdquan19851029的专栏-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e0df31f9071ccc6c9c15001f7b5ed37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1145e045f8c7767b04bd8147c4509bd/" rel="bookmark">
			安装jellyfin搭建家庭影音库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装jellyfin搭建家庭影音库 1 配置虚拟机安装docker1.1 CentOS7.9安装1.2 yum源配置1.2.1 备份1.2.2 下载新的CentOS-Base.repo到/etc/yum.repos.d/1.2.3 运行 yum makecache 生成缓存 1.3 安装Ffmpeg1.3.1 先安装epel-release1.3.2 导入密钥并安装nux存储库1.3.3 安装ffmpeg1.3.4 测试 1.4 docker安装配置1.4.1 安装必要工具1.4.2 添加软件源信息1.4.3 替换源地址1.4.4 更新并安装Docker-CE1.4.5 开启Docker服务1.4.6 设置Docker开机自启 2 安装配置Jellyfin2.1 采用docker方式安装2.1.1 从镜像仓库中拉取最新版本镜像2.1.2 从镜像仓库中拉取最新版本镜像2.1.3 启动镜像并设置开机自启 2.2 设置防火墙放行端口2.2.1 放行8096（Web访问）端口2.2.2 放行1900（DLNA）端口2.2.3 配置立即生效 2.3 设置Windows文件夹共享至CentOS虚拟机2.2.1 在VMware中进行设置2.2.2 虚拟机中设置开机自动挂载2.2.2.1 创建文件夹和脚本文件2.2.2.2 打开文件开始编辑脚本，这里使用vi文本编辑器打开2.2.2.3 点击i并输入以下内容2.2.2.4 修改权限，保证脚本文件能执行2.2.2.5 输入crontab -e，打开定时任务配置列表，添加定时任务2.2.2.6 定时任务进程，设置开机启动2.2.2.7 启动并查看定时任务进程状态2.2.2.8 重启后使用df -h指令检查挂载点是否存在 3 访问Web进行Jellyfin设置 Jellyfin是一个自由软件媒体系统（官方网址： https://jellyfin.org/），可让您控制媒体的管理和流媒体。它可以从您自己的服务器流式传输到任何设备，没有任何附加条件，致力于让所有用户都能访问最好的媒体系统。 1 配置虚拟机安装docker 1.1 CentOS7.9安装 按照VMware提示一步步往下走，建议主机网络选择为桥接模式，这样家里的其他设备就能就能发现搭建的视频服务器了。
1.2 yum源配置 yum源采用阿里云提供的源，速度快，这里提供的源只适合CentOS 7。
1.2.1 备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 1.2.2 下载新的CentOS-Base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1145e045f8c7767b04bd8147c4509bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b06afc56e92d802d9b60570b9ba7930/" rel="bookmark">
			2023年软考报哪门比较好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年软考报名还有一个月左右就会启动了，大家有想好报考哪门吗？不妨看看下文，让你的思路更加清晰。
软考科目汇总：
(1)高级资格：网络规划设计师、系统规划与管理师、系统架构设计师、信息系统项目管理师、系统分析师;
(2)中级资格：计算机硬件工程师、信息安全工程师、软件过程能力评估师、系统集成项目管理工程师、软件评测师、软件设计师、网络工程师、多媒体应用设计师、嵌入式系统设计师、电子商务设计师、信息系统监理师、数据库系统工程师、信息系统管理工程师;
(3)初级资格：网页制作员、信息处理技术员、信息系统运行管理员、电子商务技术员、网络管理员、程序员。
【腾讯文档】软考真题，速记口诀，知识点文档下载
https://docs.qq.com/doc/DU1dEcHlta3BZanlY
选择科目思路：
一：专业相关
和自己专业越近，当然就越容易考了，在自己兴趣不确定的情况下，根据自己的专业来选择吧。由从左到右匹配度由强到弱排列（并不是绝对的）。
软件设计/评测师：软件工程，计算机科学与技术，信息管理与信息系统，电子商务，物流管理。
网络工程师：网络工程，通信/电子信息工程，计算机科学与技术，软件工程，信息管理与信息系统，电子商务，物流管理。
数据库系统工程师：软件工程，计算机科学与技术，信息管理与信息系统，电子商务，物流管理。
电子商务设计师：电子商务，信息管理与信息系统，物流管理，计算机科学与技术，软件工程，工商管理。
嵌入式系统设计/多媒体应用/计算机辅助设计师：软件工程，计算机科学与技术，电子信息工程，信息管理与信息系统，电子商务，物流管理。
信息系统监理师/信息系统管理工程师：信息管理与信息系统，电子商务，物流管理，计算机科学与技术，软件工程，工商管理。
二：热门科目，科目通过率
近年来比较热门的科目：信息系统项目管理师，系统集成项目管理工程师，软件设计师 ，网络工程师。
往往比较热门的科目也更容易通过。
三：发展方向
信息系统项目管理师
岗位描述：从事信息系统项目管理的高级管理人员、高级项目经理
适合人群：适合IT基础薄弱的管理岗位报考、或者技术转管理的人员
系统架构设计师
岗位描述：从事系统架构分析、设计与评估的高级技术人员
适合人群：适合熟悉软件系统建模、系统架构设计的技术人员
系统分析师
岗位描述：从事制定需求规格说明书、从事开发、设计的高级技术人员
适合人群：适合熟悉开发过程与方法、数据库、信息安全的技术人员
系统规划与管理师
岗位描述：从事IT服务和IT运维的高级技术人员
适合人群：适合熟悉ITSS相关知识和IT服务人员，侧重于运维管理
系统集成项目管理工程师
岗位描述：从事信息系统项目管理的中层领导、中级项目经理
适合人群：适合IT基础薄弱的管理岗位报考、尤其是想做IT管理的小白
软件设计师
岗位描述：从事软件设计与开发工作的中级技术人员
适合人群：适合从事C++或Java的一种程序设计语言的开发人员
网络工程师
岗位描述：从事网络规划设计、安装调试、运行维护的中级技术人员
适合人群：适合具有计算机网络基础知识的技术人员
信息安全工程师
岗位描述：从事信息安全设施、运维和配置的中级技术人员
适合人群：适合对密码学、网络安全防护、计算机安全防护感兴趣的技术人员
信息系统监理师
岗位描述：从事IT工程监理的中级技术人员
适合人群：适合想从事信息系统工程监理或对其感兴趣的管理人员
数据库系统工程师
岗位描述：从事数据库系统设计、建立、运行、维护的中级技术人员
适合人群：适合从事大型数据库管理、设计、开发、维护的人员
信息系统管理工程师
岗位描述：从事信息系统的功能和性能、应用、资源、安全进行监控的中级技术人员
适合人群：适合熟悉信息系统开发和运维知识的人员
软件测评师
岗位描述：从事软件测试工作的中级技术人员
适合人群：适合想去第三方测试机构的人员
嵌入式系统设计师
岗位描述：从事嵌入式系统的设计、制作和集成的中级技术人员
适合人群：适合想从事嵌入式系统开发的人员
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec03c93e018cdab29011d480a4d8a5f/" rel="bookmark">
			VR视频加密SDK方案一机一码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VR视频比传统的平面视频给用户带来更好的体验，而且现在在教育、娱乐等领域VR类视频也越来越多。相比传统的视频制作，VR视频的成本要更高，所以重视VR视频的版权保护提升安全性，是很多VR内容制作商不得不考虑的问题。那么VR视频加密有哪些方案可选呢？
我们知道传统的视频加密有以下几种：1、针对特定场景和设备做定制化的加密方案 2、如果已有播放器，可以通过加解密SDK，方便更快速高效的实现视频加密 3、使用一些成品化视频加密系统，比如点盾云。那么VR视频加密解决方案厂家又可以提供哪些可选方案呢？
点量软件专注视频加密多年，从专业的角度来说这个问题其实是取决于具体的场景，每个方案都有自己的优势，只有针对场景选择合适的才是好的。根据以往经验VR视频加密可以选择以下方案：
针对特定场景提供定制化加密方案 这种一般是在局域网或者特定场所下的解决方案，比如学校、医院等。这类方案没有特定的形式，但是VR视频处于加密状态，必须满足一定的条件才可以解密播放，为了安全性更高一般会使用专用播放器。对于不同的VR设备要单独做适配。每家的加密方案都是独立的，彼此互不影响，安全性更高，甚至每个客户都可以自定义密钥。
提供加解密SDK对接服务 如果是已经有了自己的VR客户端，不想改动客户端但对VR视频加密又必须做，则可选择SDK模式。这样对用户来说是无感知的，但是在客户端中播放的VR视频都是经过加密的，可以是在线播放也可以是本地播放。如果是本地播放即使拷贝到新的设备上也是处于加密状态无法播放。一般整个加密系统包括：加密、解密SDK和授权激活三个部分。除了加密，还可以实现一机一码、防录屏、限制播放时间和次数、水印自定义等功能。
直接使用成品视频加密软件系统 这种是比较简单的，直接选择一个Saas软件产品，支持VR视频的播放即可。这种视频加密软件一般能实现一机一码、防录屏、限制播放时间和次数、限制播放设备、水印自己设置、试看等。也可以本地也可以在线播放，在线播放则需要考虑视频的码率、用户数对于带宽和流量的要求，因为流量成本是随时产生的，费用也是不断变化的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b060171b139121bfd8fce50b8bb9c3c/" rel="bookmark">
			从实测出发，掌握 NebulaGraph Exchange 性能最大化的秘密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从开发完 NebulaGraph Exchange，混迹在各个 NebulaGraph 微信群的我经常会看到一类提问是：NebulaGraph Exchange 的性能如何？哪些参数调整下可以有更好的性能？…索性来一篇文章从实测出发，和大家讲讲如何用好这个数据工具。在本文你将获得 NebulaGraph Exchange 的最佳使用姿势。
01. 环境准备 硬件：
Spark 集群：三台机器，每台 96 core，256 G 内存NebulaGraph 集群：三台机器，每台 128 core，252 G 内存，SSD，双万兆网卡数据：LDBC sf100 数据 软件：
Spark 版本：2.4.4NebulaGraph 版本：3.3.0 02. NebulaGraph 优化配置 在进行大批量数据导入时，可以调整 NebulaGraph Storage 服务和 Graph 服务的配置，以达到最大导入性能。请根据 NebulaGraph 的配置描述和你的实际环境资源进行参数调整。
在本次实践中，NebulaGraph 的集群配置针对以下几个配置项进行了修改，其他均采用默认配置：
"storaged": --rocksdb_block_cache=81920, --heartbeat_interval_secs=10, --reader_handlers=64, --num_worker_threads=64, --rocksdb_db_options={"max_subcompactions":"64","max_background_jobs":"64"} "graphd": --storage_client_timeout_ms=360000, --session_idle_timeout_secs=2880, --max_sessions_per_ip_per_user=500000, --num_worker_threads=64 NebulaGraph Storage 服务优化 在这里简单讲一下几个 Storage 服务优化配置项：
--rocksdb_block_cache 数据在内存缓存大小，默认是 4 MB，大批量数据导入时可以设置到当前内存的 1/3；--num_worker_threads storaged 的 RPC 服务的工作线程数量，默认 32；--query_concurrently 为 true 表示 storaged 会并发地读取数据，false 表示 storaged 是单线程取数；--rocksdb_db_options={"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b060171b139121bfd8fce50b8bb9c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf7854fdaf7c6a0d7f649df04e3efcc/" rel="bookmark">
			kubernetes -- 删除namespace的过程以及遇到的bug解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过阅读本篇文章你可以收获如下知识：
解决一个bug。理解k8s的controller中，删除namespace的源码，理解其中的删除过程。 问题 执行kubectl delete ns {ns-name}命令来删除ns-name的时候，发现状态一直停留在Terminating。
[root@k8smaster k8slearn]# kubectl get ns NAME STATUS AGE default Active 99m hello Terminating 36m kube-node-lease Active 99m kube-public Active 99m kube-system Active 99m 我想到的是可能是namespace底下有资源，等资源被删除之后系统才能安心删除掉namespace，然后我们来看一下资源：
[root@k8smaster k8slearn]# kubectl get all -n hello No resources found in hello namespace. 发现是没有资源的，那么到底是什么原因让删除失败了呢？
我们看一下namespace的具体内容：
[root@k8smaster k8slearn]# kubectl get ns hello -o yaml apiVersion: v1 kind: Namespace metadata: creationTimestamp: "2023-02-01T06:42:00Z" managedFields: - apiVersion: v1 fieldsType: FieldsV1 fieldsV1: f:status: f:phase: {} manager: kubectl-create operation: Update time: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf7854fdaf7c6a0d7f649df04e3efcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968d095beae91dcda780206fdd0839d8/" rel="bookmark">
			彻底卸载Ubuntu双系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们卸载Ubuntu双系统，可能出于以下原因：
1、Ubuntu系统内核损坏无法正常进入 2、Ubuntu系统分配空间不足，直接扩区较为复杂 3、以后不再使用Ubuntu，清理留出空间 无论出于哪种原因，我们都是要卸载干净它。下面教大家如何将Ubuntu系统卸载干净，让电脑磁盘重新回到安装前的清爽状态。
电脑状态
Ubuntu18.04 Win10 1、把开机启动项设为默认Windows启动 我们安装双系统后，一般会在开机后显示Ubuntu、Ubuntu高级选项、win10这样的启动项选择界面，如果不选择，默认进入Ubuntu。现在我们要把win10移动到最上面实现开机默认启动。
开机之后出现图标，立马按F2进入BIOS界面（不同电脑进入BIOS的快捷键不同，具体可以搜索），然后进入【BOOT】选项。可以看到EFI中Ubuntu在win10前面。
选择win10，然后上移到Ubuntu前，如下图所示：
然后到【Exit】中，选择第【Exit Saving Changes】回车，即保存并退出。
2、删除Ubuntu系统分区 使用磁盘管理软件 DiskGenius 删除Ubuntu系统的几个分区，包括EFI分区，注意不要删除win10的EFI分区。
1、打开DiskGenius，可以看到自己的磁盘分区情况，红线框中是我的Ubuntu分区，因为当时安装Ubuntu设置的分区大小就是这样，所以比较肯定。 2、如果你忘记哪些是你的Ubuntu分区也没关系。 首先你知道你win10的EFI启动盘，一般是260M，这个千万不要动！下面有个很小的只有16M的MSR分区，这个是保留分区，不要动它。然后会有C盘、D盘、E盘等等，这些你肯定也清楚，不需要动。最后还会有个1000M大小的分区，那个是电脑的恢复分区，也不要动它。除这些外，都是Ubuntu的分区了。排除法做题。
3、知道了Ubuntu分区后，我们就要删除这些分区，右击选中这些分区，然后选中【删除分区】 4、删除完成后，可以看到DiskGenius帮我们把这些空闲分区合并成一块了。 5、最后别忘了选择【磁盘】——&gt;【保存分区表】，保存才能生效。 3、删除开机启动引导项 删除了Ubuntu系统所有分区后，Windows的EFI分区里仍然会有Ubuntu系统的引导项，我们第一步是将它隐藏了，是为了后面重启不会跳出检测磁盘的蓝色信息，但是还没有删除，。不删除它的话开机更改启动顺序时Ubuntu系统将仍然存在。
1、win+R打开命令行，输入以下命令 diskpart list disk 2、选择Windows的安装磁盘，我这里是磁盘0，然后查看该磁盘的分区信息 select disk 0 list partition 3、确定Windows的EFI分区，一般是200多M，我这里是分区1，然后为它分配盘符。 盘符不可与已有盘符重复，比如你电脑已有CDE盘，那么就分配26个字母中排在E后面的字母F、G、H等等，最好隔几个字母，防止你插上U盘和驱动器。
select partition 1 assign letter=J 4、此时，Win+E 打开此电脑，就会有刚刚分配的盘符J 5、由于权限不够，不能直接打开该磁盘，可通过记事本间接打开。在Windows附件中，用管理员权限运行记事本。 6、打开记事本后，左上角【文件】——&gt;【打开】，选择刚刚新增的J盘，会看到里面有个EFI文件夹 7、进入EFI文件夹，删除Ubuntu文件夹 8、返回刚刚的命令行，删除刚刚分配的盘符。可以看到又回归原来状态 remove letter=J 至此，Ubuntu卸载完成
文章来源：https://blog.csdn.net/qq_42257666/article/details/120721561
转载目的：个人备忘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b63cacbe44807bb66dbfcaaaac1dc4/" rel="bookmark">
			一文弄懂redis的架构演变之路（附图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文大约需要 13 分钟。
这篇文章我想和你聊一聊 Redis 的架构演化之路。
现如今 Redis 变得越来越流行，几乎在很多项目中都要被用到，不知道你在使用 Redis 时，有没有思考过，Redis 到底是如何稳定、高性能地提供服务的？
你也可以尝试回答一下以下这些问题：
我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？
我的 Redis 故障宕机了，数据丢失了怎么办？如何能保证我的业务应用不受影响？
为什么需要主从集群？它有什么优势？
什么是分片集群？我真的需要分片集群吗？
...
如果你对 Redis 已经有些了解，肯定也听说过数据持久化、主从复制、哨兵这些概念，它们之间又有什么区别和联系呢？
如果你存在这样的疑惑，这篇文章，我会从 0 到 1，再从 1 到 N，带你一步步构建出一个稳定、高性能的 Redis 集群。
在这个过程中，你可以了解到 Redis 为了做到稳定、高性能，都采取了哪些优化方案，以及为什么要这么做？
掌握了这些原理，这样平时你在使用 Redis 时，就能够做到「游刃有余」。
这篇文章干货很多，希望你可以耐心读完。
从最简单的开始：单机版 Redis 首先，我们从最简单的场景开始。
假设现在你有一个业务应用，需要引入 Redis 来提高应用的性能，此时你可以选择部署一个单机版的 Redis 来使用，就像这样：
这个架构非常简单，你的业务应用可以把 Redis 当做缓存来使用，从 MySQL 中查询数据，然后写入到 Redis 中，之后业务应用再从 Redis 中读取这些数据，由于 Redis 的数据都存储在内存中，所以这个速度飞快。
如果你的业务体量并不大，那这样的架构模型基本可以满足你的需求。是不是很简单？
随着时间的推移，你的业务体量逐渐发展起来了，Redis 中存储的数据也越来越多，此时你的业务应用对 Redis 的依赖也越来越重。
但是，突然有一天，你的 Redis 因为某些原因宕机了，这时你的所有业务流量，都会打到后端 MySQL 上，这会导致你的 MySQL 压力剧增，严重的话甚至会压垮 MySQL。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66b63cacbe44807bb66dbfcaaaac1dc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e558d02294e3e2ce7cc6978dc98805/" rel="bookmark">
			超简单·Ubuntu系统Git安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装git只需要在终端terminal的base环境下执行三个命令即可：
1.更新
sudo apt update
2.下载git
sudo apt install git
3.查看git版本，查看是否安装成功
git --version
然后就安装完毕了
在其他环境下也可以用第三条命令同时检测到git版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69eb01bcb4c82faf7fedfd5fe1d4448a/" rel="bookmark">
			Windows下YOLO V5环境（pytorch，cuda）配置及部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习yolo v5 分享一下学习经验
一.torch环境配置： 1.Anaconda安装 首先需要下载一个Anaconda来方便我们配置pytorch的环境
Anaconda直接百度就可以找到官网并且下载
可以进入Anaconda的官网查询你想下载的版本对应的是哪个安装包，主界面进入后直接点击下方的Get Additional Linstallers
点进来之后会进入如下界面
上面默认是最新版的Anaconda选择你对应的系统就能进行安装了 不过有的时候我们需要下载一些比较旧的版本的Anaconda， 在Anaconda的界面选择下面蓝框里的archive就会得到旧版本安装表的列表了
如果没有科学上网的话国内在Anaconda官网下载速度可能会很慢也容易出现下载失败等问题，这时候可以访问下面的国内源进行下载，下载完成后一直点确定就行了。
https://mirrors.bfsu.edu.cn/anaconda/archive/ 2.CUDA安装（如果你的电脑没有NIVDIA显卡可以跳过这一步） 首先从开始菜单打开NIVDIA的控制面板，如果没有的话需要到官网下载显卡驱动 ，具体可以参考这位老哥的博客
https://blog.csdn.net/weixin_36040777/article/details/114875128?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167522802616782425111390%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=167522802616782425111390&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-114875128-null-null.142^v72^control,201^v4^add_ask&amp;utm_term=%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E4%B8%8B%E8%BD%BD&amp;spm=1018.2226.3001.4187
打开NV的控制面板后点击左下角的系统信息，然后选择组件
这一行就是显示当前你显卡能支持的“最高”（划重点）CUDA版本，像我的就是12.0.139
接下来就可以从NIVDIA的官网下载我们需要的CUDA（别无脑下载最新版本，有时候pytorch并没有支持到最新的CUDA）可以先访问Pytorch的官网看一眼
比如我现在其实已经能从官网上下载到12.0的CUDA了，但是Pytorch只有到11.7的版本所以请下载11.7版本的CUDA，官网如下：https://developer.nvidia.cn/cuda-toolkit-archive 如果安装CUDA报错了有可能是和visual studio冲突，CUDA安装选择自定义安装，关闭CUDA下的VSE（visual studio edition）选项
按下Win+R键输入cmd进入命令窗口输入下面的代码
nvcc -V 出现如下窗口则表示安装成功了
3.pytorch安装 接下来从开始菜单打开anaconda prompt，输入(后面的python=3.9表示的是建立的python环境，可自行选择版本)
conda create -n yolov5 python=3.9 执行后会出现问你是否确定安装，输入y再回车即可。然后来激活我们创建的yolov5环境，输入如下代码来激活我们刚刚创建好的环境，后面的操作都要在这个环境里操作
conda activate yolov5 后面的操作都需要保证前面的括号里显示的是我们创建的yolov5环境，不是就再输入一次上面的代码
接下来就要进行pytorch的安装了，这边推荐进行先下载离线包然后进行安装
进入这个网站：https://download.pytorch.org/whl/torch_stable.html
选择对应的pytorch版本
前面cu xxx是你的CUDA版本，像我是11.7的CUDA就选择cu117，前面没安装CUDA的选择cpu就好了，后面的cp则表示你的python版本，我们刚才创建yolov5的环境时使用的是python=3.9，这边我们就选择cp39的版本，然后选择后面是win的版本就好了，这边建议同时下载一下torchvision和torchaudio
下载完成后回到anaconda prompt输入：cd 你下载好的文件的地址 然后输入：pip install 下载的文件名（torchvision和torchaudio同理）
安装完成后在anaconda prompt输入python并回车激活python
输入如下代码
import torch import torchvision 没有报错即可
二.yolov5部署 1.yolo环境 进入如下网站：https://github.com/ultralytics/yolov5
下载yolo并解压，然后打开anaconda prompt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69eb01bcb4c82faf7fedfd5fe1d4448a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a529344ab6c28bf566797ef104d55a6/" rel="bookmark">
			hutool的httpUtil的使用（访问第三方接口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对接第三方接口获取数据 以下仅为自己项目中所写并能够跑通 有问题留言 如若不对 请指出告知一下
//传参形式：map 基本类型 string public static String creatPost(String url,Map param,String contentType) throws Exception{ //时间戳 long timeSpan = System.currentTimeMillis()/1000; System.out.println("时间戳="+timeSpan); //组装TOKEN String signature = SecureUtil.md5(APPTOKEN + APPSECRET + timeSpan).toLowerCase(); System.out.println("组装signature="+signature); System.out.println("组装signature的长度="+signature.length()); //发起请求 HttpResponse responsse = HttpUtil.createRequest(Method.POST, url) .header("x-qys-accesstoken",APPTOKEN) .header("x-qys-timestamp", timeSpan+"") .header("x-qys-signature", signature) .header("Content-Type",contentType) .form(param) --以表单形式的参数拼接 .execute(); System.out.println("--------"); String result = responsse.body(); System.out.println("响应结果="+result); System.out.println("--------"); return "SUCCESS"; } //contentType = "multipart/form-data" //如果是post请求 contentType = "multipart/form-data" 建议使用.form进行传参 //如果是get请求 建议使用.body进行传参 形式 url+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a529344ab6c28bf566797ef104d55a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c4fda499bda46987517ef7e38fd9d66/" rel="bookmark">
			E/BufferQueueProducer: [SurfaceView]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E/BufferQueueProducer: [SurfaceView[MainActivity]#3(BLAST Consumer)3](id:5ac800000003,api:0,p:-1,c:23240) disconnect: not connected (req=2) 简单记录一下分析过程吧，希望能给大家提供一个思路，也想看看大家对这个问题有什么新的思路。
设计逻辑
一个SurfaceView显示camera的图像，上面覆盖一层SurfaceView 显示人脸识别框。
发生问题的场景
当上一个页面有其他的SurfaceView显示完，立刻切过来需要显示的时候，就会出现camera的SurfaceView黑屏的情况。
解决问题的方法
多绘制依次人脸识别框的的SurfaceView
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05bb6fe65d6dfaeb347fab78b6784fda/" rel="bookmark">
			Linux 实时查看网卡流量（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 实时查看网卡流量 TABLE OF CONTENTS nload工具 nload用于实时查看网卡流量，默认系统都没有安装，首先安装方式如下：
$ yum install -y epel-release $ yum install -y nload 使用也非常简单，如下：
$ nload Device eth0 [192.168.0.110] (4/5): =================================================================================== Incoming: Curr: 5.21 kBit/s # Incoming：进来的流量 Avg: 4.09 kBit/s # Outgoing：出去的流量 Min: 1.59 kBit/s # Curr：当前的流量值 Max: 12.51 kBit/s # Avg：平均值的流量值 Ttl: 4.16 GByte # Min：最小的流量值 Outgoing: # Max：最大的流量值 Curr: 16.48 kBit/s # Ttl：总的流量值 Avg: 14.38 kBit/s Min: 6.73 kBit/s Max: 28.39 kBit/s iftop工具 默认系统没有安装，需要安装，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05bb6fe65d6dfaeb347fab78b6784fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a3e261eab63bfcde8bd7da151edac6/" rel="bookmark">
			最全的strapi V4使用（踩坑经历）1、strapi安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装并创建项目
1.在电脑创建项目文件夹"strapi",进入文件夹，点击按住键盘shift+鼠标右健打开菜单，选择"在些处打开power shell窗口"
2在打开的命令行窗口中输入命令，我们这些安装相对稳定的v4.3.8版本，点击回车后开始安装
npx create-strapi-app@4.3.8 项目名称
这时窗口提示我们选择“quickstart(快速安装)”或者“Custom(自定义安装)”我们这次选择的是mysql 的数据库，所以我们选择“Custom”
选择 "mysql"按提示输入 SQL数据库相关信息
注：这里提前要检测自己的node版本和npm版本。不然会安装失败，这里我踩了很久的坑~~
这里引用官网的版本说明。
3、安装成功
二、项目启动
第一次启动项目前执行命令，编辑项目静态资源
npm run build
执行命令，启动项目
为了安全，开发时使用“npm run develop”，项目上线时使用“npm run start”
项目启动后，默认访问地址为http://localhost:1337/admin/
第一次启动项目，项目需要你填写创建管理员信息，填写提交后，你的项目将创建完成，并成功进入欢迎界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc41a0c60bf9eb3be7fe8bf47e461b8/" rel="bookmark">
			simpledatefomat报multiple points
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 simpledatefomat报multiple points 欢迎使用Markdown编辑器处理办法使用ThreadLocal隔离创建simpleDateFormat 欢迎使用Markdown编辑器 发现一个偶现的问题，后台报错显示simpleDateFormat的parse报错了。
明明传入的日期格式是正确的，为什么会报错。。。
后来搜索到问题，参考博客：
https://blog.csdn.net/EDG_win/article/details/106022657
处理办法 不将simpleDateFormat放在工具类或者提取为公共变量，每次使用前new一个即可。（相对消耗资源）加入锁机制（并发能力下降）使用ThreadLocal（推荐，每个线程只会创建一个simpleDateFormat） 使用ThreadLocal隔离创建simpleDateFormat 方法一：
private static final ThreadLocal&lt;DateFormat&gt; sdf = new ThreadLocal&lt;DateFormat&gt;(){ @override protected DateFormat initialValue() { return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); } } 方法二：
private static final ThreadLocal&lt;DateFormat&gt; sdf = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbdb559905add508da67498456a1b539/" rel="bookmark">
			element的tab，循环中下划线不显示的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5593787afa187a07b7127e2ffbae169d/" rel="bookmark">
			Flink官方例子解析：WordCount
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 今天介绍的是官方子项目flink-examples-streaming里面的WordCount例子。
WordCount ，中文：单词统计，是大数据计算常用的例子。
2. WordCount需要实现的功能 监听指定目录下的文件，读取文件的文本内容；如果未指定监听路径，则读取静态的字符串变量分词统计每个单词的出现次数把单词统计的结果输出到指定的文件中；如果未指定输出路径，则把结果打印输出 参数说明：
--input 指定监听目录， 非必填
--output 指定结果输出的文件路径， 非必填
--discovery-interval 指定监听的间隔时间， 非必填
--execution-mode 指定Flink的执行模式，非必填，默认为STREAMING模式
3. 代码实现 3.1 指定监听目录 //使用工具类CLI的fromArgs方法解析参数 final CLI params = CLI.fromArgs(args); //setGlobalJobParameters(params),可以在Flink Web UI 中查看到传入的参数 env.getConfig().setGlobalJobParameters(params); if (params.getInputs().isPresent()) { // 如果指定了--input参数，则创建file source, 从指定的路径读取文件 FileSource.FileSourceBuilder&lt;String&gt; builder = FileSource.forRecordStreamFormat( new TextLineInputFormat(), params.getInputs().get()); // 如果指定了--discovery-interval参数，file source 会持续监听指定的目录的新文件 params.getDiscoveryInterval().ifPresent(builder::monitorContinuously); // 指定算子名称为"file-input" text = env.fromSource(builder.build(), WatermarkStrategy.noWatermarks(), "file-input"); } else { // 没有指定--input参数， 从静态变量WordCountData.WORDS读取数据 // 指定算子名称为"in-memory-input" text = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5593787afa187a07b7127e2ffbae169d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b628197892e37ea925b2b2b5e07aef7/" rel="bookmark">
			【无标题】Java使用@RequestBody和@RequestParam注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@RequestBody和RequestParam区别、使用 1、@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；2、GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交；3、在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个； 注意事项 1、如果参数时放在请求体中，传入后台的话，那么后台要用@RequestBody才能接收到；如果不是放在 请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收；
2、如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400；
3、如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：
a:后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类时，会根据json字符串中的key来匹配对应实体类的属性;
b:json字符串中，如果value为"“的话，后端对应属性如果是String类型的，那么接受到的就是”“，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null;
c:json字符串中，如果value为null的话，后端对应收到的就是null;
d:如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null 或”“都行。千万不能有类似"stature”:
示例：
使用@RequestBody 可接受的参数 String, Map，JSONObject，或者对应的JavaBean @PostMapping("/test") @ApiOperation("xxx") @NoRepeatSubmit public Object test(@RequestBody TechnicalWhiteImgRequest technicalWHiteImgRequest) { return null; } /** * @author : liudy23 * @date : 2023/1/6 */ @Data @ApiModel("xxx请求参数") public class TechnicalWhiteImgRequest implements Serializable { private static final long serialVersionUID = -3138667394788394672L; @ApiModelProperty("xxxDTO") private List&lt;TechnicalWhiteImgDTO&gt; technicalWhiteImgList; @ApiModelProperty("xxx附件信息") private List&lt;SysFile&gt; fileList; @ApiModelProperty("xxx类型") private Integer type; } /** * @author : liudy23 * @date : 2023/1/6 */ @Data @ApiModel("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b628197892e37ea925b2b2b5e07aef7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e956c324ad820d710be441e9b2617a3e/" rel="bookmark">
			YT8521SC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YT8521SC 品牌
MOTORCOMM
封装
QFN48
批号
2022
数量
12600
RoHS
是
产品种类
电子元器件
比较小工作温度
-50C
比较大工作温度
100C
比较小电源电压
2V
比较大电源电压
7V
长度
5.1mm
宽度
1.4mm
高度
2.9mm
型号
YT8521SC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10216bbb6e6327e464e18349d460b040/" rel="bookmark">
			1438. 绝对差不超过限制的最长连续子数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 题目 二、 示例 三、 思路与代码 1. 思路： 采用滑动窗口算法， 而关于窗口容器采用一个特殊的数据结构， 即multiset； 在 C++ 中 multiset 内部元素是有序的，基于红黑树实现。multiset 可以有重复元素； 本题的关键就在于， 如何快速的找到窗口内的最大值与最小值？ 利用multiset， mutiset.rbegin()返回引用multiset容器最后一个元素（最大值）的反向迭代器， 而multiset.begin()则是正向迭代器； 因为， 只要窗口中最大值与最小值之间的差值都超过了限制值limit， 则说明任意两个数字之间的差都不符合； 首先，right指针移动滑动窗口；而当窗口中最大值与最小值之间的差超过了限制limit， 则left指针移动收缩窗口（multiset.erase()）;更新答案的时机为：窗口中最大值与最小值的差不超过limit时， 更新数据；注意从窗口中移出元素的操作！！！：这里用的是multiset容器（因为题目给出的值可能有重复）， 所以在删除的时候不能直接erase， 这样会把所有重复的值都删除掉， 要先windows.find(value)：multiset::find(是C++ STL中的内置函数，该函数返回指向在多集容器中搜索的元素的lower_bound的迭代器。如果未找到该元素，则迭代器指向该集合中最后一个元素之后的位置；找到后再erase掉， 这样从窗口中移出元素才是正确的；具体见代码解析； 2. 代码： 代码中包含详细解析 class Solution { public: int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) { // 使用 multiset multiset&lt;int&gt; mst; // 内部原理是平衡二叉搜索树 int left = 0; int right = 0; int n_len = nums.size(); int cnt = 0; while (right &lt; n_len) { int c = nums[right]; right++; mst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10216bbb6e6327e464e18349d460b040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eea43c952a07ea03850f0b3cc4265dc/" rel="bookmark">
			Java-等待子线程执行完毕后执行主线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直入主题，代码如下：（不懂评论区评论，当日回复信息） 技术实现关键：计数器（CountDownLatch）
public static void main(String[] args) { // 新建一个为2的计数器 final CountDownLatch latch = new CountDownLatch(2); // 新建线程1任务 Thread thread1 = new Thread() { @Override public void run() { try { Thread.sleep(6000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("Thread1启动了!!!"); latch.countDown(); } }; // 启动线程1 thread1.start(); // 新建线程2任务 Thread thread2 = new Thread() { @Override public void run() { System.out.println("Thread2启动了！！！"); latch.countDown(); } }; // 启动线程2 thread2.start(); System.out.println("等待两个线程执行结束-------"); try { // 等待计数器为0 latch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eea43c952a07ea03850f0b3cc4265dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3b5d937570fbf868f636783e4e4cb6/" rel="bookmark">
			【Kotlin】泛型总结 ★ ( 泛型类 | 泛型参数 | 泛型函数 | 多泛型参数 | 泛型类型约束 | 可变参数结合泛型 | out 协变 | in 逆变 | reified 检查泛型参数类型 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、泛型类二、泛型参数三、泛型函数四、多泛型参数五、泛型类型约束六、可变参数 vararg 关键字与泛型结合使用七、使用 [] 运算符获取指定可变参数对象八、泛型 out 协变九、泛型 in 逆变十、泛型 invariant 不变十一、泛型逆变协变代码示例十二、使用 reified 关键字检查泛型参数类型 一、泛型类 定义一个 泛型类 ,
将 泛型参数 T 放在 尖括号 &lt;T&gt; 中 , 该泛型参数放在 类名后 , 主构造函数之前 , 该泛型参数 T 是 类型占位符 ,
在 该泛型类类中 可以使用 类型占位符 T 作为一个类 使用 ,
可以 定义 T 类型成员属性主构造函数中可以接收 T 类型的实例对象作为参数 ,T 类型可以 作为函数的返回值 ; 通常情况下 , 泛型参数 都使用 T 表示 , 使用其它字母 或者 字符串 都可以表示 泛型参数 , 但是 约定俗成 都使用 T 来表示泛型 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d3b5d937570fbf868f636783e4e4cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72df59d39726f73235a78dc215a4f3d1/" rel="bookmark">
			用python初始化date变量为1970年1月1日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 Python 可以使用 datetime 模块中的 datetime 类来初始化日期变量为 1970 年 1 月 1 日：
from datetime import datetime date = datetime(1970, 1, 1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342f5a58611ec94ae42008d9e4802a8f/" rel="bookmark">
			Windows10家庭版的功能中没有Hyper-V的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要在windows安装Docker，遇到的问题：
Windows10家庭版添加Hyper-V的方法
将下面的内容复制到编辑器或者记事本当中
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 保存，修改文件名称，为Hyper-V.cmd
在系统桌面上，我们找到并右键点击【Hyper-V.cmd】文件图标，在右键菜单中点击：以管理员身份运行
然后等待程序执行，就ok啦
执行结束 键入 Y，重启
重启之后，到控制台-&gt;启动或关闭windows功能 （点开查看！）
下面所示，Hyper-V已经存在啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a015e8ad4178e9ddb57916dfbad49cdc/" rel="bookmark">
			上传本地文件至gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 上传本地文件至gitee git init git add . git commit -m "first commit" git remote add origin "https://gitee.com/xxx自己的地址.git" git push -u origin +master 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7838076d36edf24a62075dcd66f652bf/" rel="bookmark">
			vs 如何引用第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很久很久没用vs了。 今天突然用vs，需要引用第三方库，一下不知道怎么弄了。折腾老半天。现在做个记录
第三方库分为 lib和 dll
lib是纯静态的，代码函数等等都在里面。生成exe的时候，全部打包到exe里面。这样不灵活
而dll这种方式是： 需要有头文件一般放在include里面 ，dll这里是函数实现，lib这里是导出函数的名字
以glog为例 做说明
glog里面有三个目录
include
bin
lib
以上3个目录 分别放着头文件，dll和 lib文件
首先打开 vs2012， 项目属性
1 c/c++ ----》常规----》附加包含目录加入 X:\XXX\glog\include
这里是告诉项目，头文件在哪里
2 链接器---》 常规-------》附加库目录： 在这里加入X:\XXX\glog\lib
3 链接器---》输入------》附加依赖项： XXXX.lib 这里实际是填写lib的名字
以上编译生成是没有问题了
4 最后glog的dll拷贝到和exe放在一起
、、、、、、、、、、、、完毕、、、、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011590160d035875240587c710ecf2a3/" rel="bookmark">
			golang gin框架源码分析（三）---- 问其根本 net/http包需要深究才能有始有终
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 全系列总结博客链接前引golang gin框架源码分析（三）---- 问其根本 net/http包需要深究才能有始有终1、从示例代码入手2、ListenAndServe(addr string, handler Handler) error1、server.ListenAndServe()2、server.Serve(l net.Listener) error3、conn.serve(ctx context.Context) { 3、HandleFunc(pattern string, handler func(ResponseWriter, *Request))1、mtx.HandleFunc(pattern string, handler func(ResponseWriter, *Request))2、mux.ServeHTTP(w ResponseWriter, r *Request) 4、简单总结一下 全系列总结博客链接 golang Gin框架源码分析 全系列总结博客
前引 本意是没有打算写这一篇的 但是这两天在刷面经的时候发现 还是有问这个net/http包的
这个看样子是逃不掉了 还是需要深挖一下
发现要做的事情太多 太忙 但是想到如果能回到自己的hometown 今年9月份就要定正式工作了
这个offer起码决定了后面好几年的日子 也不得不这几个月再硬着头皮冲一下了
golang gin框架源码分析（三）---- 问其根本 net/http包需要深究才能有始有终 1、从示例代码入手 刚刚也才基本把net/http的框架给梳理了一遍 还是很有收获的^^
这里还是简单推荐一下 一篇对于net/http解析写的挺好的帖子 我下面贴一下链接 大家可以先去看看这篇
Introduction 万字手撕Go http源码server.go
还是从示例代码入手 下面是非常常见的用net/http写一个高并发的web服务器的代码 我们注册url相对应的处理函数就是以下面的方式来注册的 那我们就可以顺藤摸瓜的去看一下 ListenAndServe函数 和 HandleFunc函数是怎么运行的
package main import ( "net/http" "strconv" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011590160d035875240587c710ecf2a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c0f4695fe663696cc506d9ba391eef/" rel="bookmark">
			Unix环境高级编程_进程环境_启动代码,环境变量表,进程内存结构,库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是《UNIX环境高级编程》第7章内容，这篇文章记录进程所需要的环境。
4 进程环境 程序加载到内存，运行起来后就成为了进程。就像人活着需要生活环境（衣食住行的环境）一样，进程也需要运行环境，进程所需要的环境如下：启动代码、环境变量、进程的内存空间布局、库等，下面分别说这四点。
4.1 进程环境1：启动代码 启动代码就是启动程序的代码。所有高级语言的程序，都有自己的启动代码。C程序运行时，最开始运行的是启动代码，启动代码再去调用main函数，然后整个C程序都已运行。启动代码由编译器提供，其都是用汇编写的，为什么都是汇编写的呢？因为还没有程序内存空间之前，高级语言无法运行，所以启动代码都是汇编写的。
4.1.1 启动代码做的两件事 对c程序的内存空间进行布局，得到c程序运行所需要的内存空间结构。
高级语言程序在运行时，函数调用需要“栈”，启动代码就需要在c内存空间上建立“栈”，说白了就是从c内存空间中划出一段空间，然后以“栈”的形式来进行管理。留下相应库接口
如果程序使用的是动态库的话，编译时，动态库代码并不会被直接编译到程序中，只会留下相应的接口，程序运行起来后，才会去对接库代码，为了能够对接动态库，启动代码会留下动态库的对接接口。 4.1.2 进程的终止方式 进程的正常终止 进程主动调用终止函数/返回关键字结束，就是正常终止。有三种方式：
方式1：main调用return关键字结束
return关键字的作用是返回上一级函数，如果main函数的子函数调用return，返回的上一级是main函数。如果main函数调用return，main函数所返回的上一级是启动代码。方式2：程序任何位置调用exit函数结束
程序任意位置调用exit函数，程序返回到启动代码。Exit函数原型如下： #include &lt;stdlib.h&gt; void exit(int status); 看到stdlib.h这个头文件，我们就知道exit函数是一个c库函数。main函数调用return将返回值返回给启动代码后，启动代码又会调用exit(返回值)，将返回值返回。
一般函数错误时候，会调用exit函数。
方式3：程序任何位置调用_exit函数结束
_exit是一个系统函数（系统API），而exit是c库函数，exit就是调用_exit来实现的。所以，exit是_exit的封装，比_exit多了很多功能。
_exit函数原型： #include &lt;unistd.h&gt; void _exit(int status); 总结这三种方式：
return,exit,_exit都可以终止进程，但是尽量使用return和exit, 这三种方式的执行过程如下：
Return：
return(0) —————&gt; exit(0) ————&gt; _exit(0) ———&gt; Linux OS
** exit**
exit(0) ————————&gt; _exit(0) ————&gt; Linux OS
** _exit**
_exit(0) ————&gt;Linux OS 进程正常终止时候，注册进程终止函数 在写程序时候，可以使用atexit函数注册进程终止处理函数。函数原型如下：
#include &lt;stdlib.h&gt; int atexit(void (*function)(void)); 显然，这是一个C库函数。其功能是：
注册（登记）进程终止处理函数，参数就是被登记“进程终止函数”的地址。当进程无论什么时候正常终止时，会自动的去调用登记的进程终止处理函数，实现进程终止时的一些扫尾处理。
代码演示： #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c0f4695fe663696cc506d9ba391eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3384cc1b3845e09d270e36e4ebb85655/" rel="bookmark">
			R语言与数据分析—上（篇幅长，全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容过长但详细，分三篇写，总结分享也供日后参考回顾
一、什么是R语言 R是免费的，是一个全面的统计研究平台，提供了各式各样的数据分析技术，R拥有顶尖的绘图功能
二、R语言优点和缺点 优点 1、有效的数据处理和保存机制
2、拥有一整套数组和矩阵的操作运算符
3、一系列连贯而又完整的数据分析中间工具。图形统计可以对数据直接进行分析和显示，可用于多种图形设备
4、一种相当完善、简洁和高效的程序设计语言
5、R语言是彻底面向对象的统计编程语言
6、R语言和其它编程语言、数据库之间有很好的接口
7、R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差
8、R语言具有丰富的网上资源
缺点 1、不够规范，不容易上手，需要付出大量学习成本
2、扩展包不稳定
3、扩展包多，有很多重复功能，需要很多时间找自己需要的包
三、R软件的安装 1、登陆R官网 R: The R Project for Statistical Computing (r-project.org)
2、点击
3、选个离自己近的站点，我选的中国科技大学
4、选择版本
5、这个是二进制版本的R基础软件
6、就可以下载了
7、下载完成一直下一步安装即可
四、R软件的运行和设置 桌面双击图标，进入，一般32位的都有一个图标，64位的有俩，进去里面可以看到菜单，其他选项的内容都可以在控制台输入命令完成。窗口是最重要的部分，所有的工作都主要在这个窗口完成的
不管是什么系统，R语言都有三种运行方式：交互式、R脚本、R工作空间，打开R默认就是交互式的，可以通过写字板打开配置文件
我们可以在配置文件里自定义，加上First里放些自己常用的函数，Last里放点清理操作
五、Rstudio及基本操作 Rstudio是一款第三方开发的非常好用的R语言集成环境，软件把R控制台，绘图窗口、帮助窗口集成到一个界面下，还能补齐代码。必须先安装R软件，因为Rstudio是个集成环境不包括R软件，打开界面可以看到四个窗口
设定工作目录：很重要，所有输入和输出文件的默认位置，包括读取和写入数据等
getwd()显示当前目录，setwd()修改目录
工作目录设置完就可以开始操作了，无需对变量进行声明
赋值运算符 -&gt;/&lt;-/&lt;&lt;-
ls()列出变量，str()列出具体内容，ls.str()组合
删除工作空间不需要的变量可以是一个或多个rm()，删除之后无法恢复，没有回收站的功能，如果想删除所有的变量需要调用list函数，rm(list=ls())
history()列出历史记录，()里可以写数字代表行数
清屏ctrl+L
save.image()保存工作空间
q()退出
六、R包的安装 可以根据官网的Task Views浏览R包，可以根据自己研究的方向到自己需要的类目去寻找自己需要的R包，学R包比学R还难，R包很多就好像手机APP，网址：The Comprehensive R Archive Network (r-project.org)，再点击Task Views右边就可以看到各种各样的R包
安装R包的方式有两种，第一种联网在线安装，第二种代码安装，推荐第一种。安装包的函数install.packages()，括号里放入需要的R包，首次使用这个函数不加参数会提示选择镜像站点，我选择了一个比较近的，选择完后会弹出这个站点里的R包，R中使用字符串都需要加上引号，要是不输入引号就会把你输入的东西当做R的对象来处理，程序找不到这个对象就会报错。
联网在线安装 通过函数我们安装一下R包
有的时候镜像站点无法访问了，需要修改默认的镜像站点，我们可以修改Rprofile.set这个文件，修改里面的set a CRAN选项,默认是自动选择，要是选择不了，可以添加一个国内比较方便的站点
使用.libPaths()函数可以显示库的位置，在线安装会默认把R包安装到这个目录下
输入函数library()可以看到R包
使用代码安装 一些服务器为了安全无法访问网络采用代码安装的方式，要去R的官网或者镜像站点去下载源代码，需要注意依赖关系问题，如果提前知道依赖关系就要将依赖包一起下载上传到服务器，我们试着去安装一个包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3384cc1b3845e09d270e36e4ebb85655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae8965bdf7e0049e75cc866ff918b00/" rel="bookmark">
			CSS中的margin塌陷和margin合并BUG以及BFC的常见应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
margin塌陷
BUG表现形式
运行结果
margin塌陷BUG解决方法
如何成为BFC元素
margin合并
BUG表现形式
运行结果
margin塌陷BUG解决方法
BFC的常见其它应用
margin塌陷 BUG表现形式 例如下图，正常情况下，.content设置了margin-left,margin-top会使它相对父集偏移，即红色方块应该会出生在黑色大正方体的右下方，而实际情况却只出生在了右上方，即margin-top属性没有生效的，并且当我们把margin-top属性加大后，当它大于.wrapper的top边距100px时，它会带动着它的父集一起移动，且在相对黑色正方体中的位置不变，如果外层在套一层父集也一样，当大于那层父集的margin-top时，会带着3个元素一起动，它们之间的位置不会变。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .wrapper{ width: 200px; height: 200px; background-color: black; margin-top: 100px; margin-left: 100px; } .content{ width: 100px; height: 100px; margin-left: 100px; margin-top: 100px; background-color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt;	&lt;div class="wrapper"&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 运行结果 margin塌陷BUG解决方法 一.在父集元素.wrapper中设置border-top属性，例如border-top:1px solid red。
如何成为BFC元素及作用 二.给父元素.wrapper设置以下属性使子元素成为 BFC（Block Formatting Context 格式化上下文）元素，理解为另一种CSS的渲染规则。（推荐使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ae8965bdf7e0049e75cc866ff918b00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d35afc012488866ce8ad24c6479e90/" rel="bookmark">
			Redis缓存穿透——实战代码教学，亲身体验高并发如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 注重版权，转载请注明原作者和原文链接
🥭 作者：全栈小袁
🍎 原创个人开源博客项目(目前V2.0微服务版本)：https://github.com/yuanprogrammer/xiaoyuanboke
🍉 开源项目觉得还行的话点点star，有什么需要完善或者点子欢迎提issue 小袁有话说 众所周知，Redis三大问题，缓存穿透、缓存击穿、缓存雪崩，也是最常见的缓存问题，在面试当中也是经常被问到，今天我们就先来讲讲 缓存穿透 问题的解决以及如何编写代码
之前我也是看过很多相关的知识，这篇文章是结合自己所学总结的一篇文章，如果什么地方有问题或者不足之处可以评论区留言告诉我
缓存击穿和缓存雪崩，后续出~
一、前期准备 数据表 随便创建一个表，这里以用户表作为演示
CREATE TABLE `user` ( `id` int(10) NOT NULL AUTO_INCREMENT, `username` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名', `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码', `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称', `mobile` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '号码', `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱', `gmt_create` datetime(0) NULL DEFAULT NULL COMMENT '时间', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 1001 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; 使用在线工具随机生成一千条数据，工具地址：https://datum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62d35afc012488866ce8ad24c6479e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fded5fb5ba9240871e6bde250173229/" rel="bookmark">
			Ubuntu16.04 网络连接后很快断开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu连接网络后，很快网络自动断开，下面提供常见的排查方式及解决方法。
点击Ubuntu右上角网络连接选项，连接上所选网络时，先ping一下外网发现可以ping通。 ping www.baidu.com 隔一小段时间后，右上角网络图标显示网络已断开。再ping一下外网发现无法ping通，显示未知的名称或服务。
此现象一般为网络故障，确认网络配置中的IP、网关、掩码无误后，可以通过修改DNS解析文件来解决。
添加 nameserver 解析地址，与修改网卡配置功能类似，无需重启网卡，会自动生效。具体步骤如下：
编辑resolv.conf文件 sudo gedit /etc/resolv.conf 在文件末尾加入 nameserver 114.114.114.114 或者 nameserver 8.8.8.8 重新连接网络，查看网络是否可用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd6802eb1c4c959eed67926cc69a9a3/" rel="bookmark">
			DBA常用SQL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		达梦数据库更新统计信息 收集指定用户下所有表所有列的统计信息：
-- 进入达梦命令行 disql cd /data/dmdbms/tool ./disql disql V7.6.1.52-Build(2020.03.17-119193)ENT SQL&gt; conn ncc_0611_TW/nccloud001@192.168.xx.xx:5236 服务器[192.168.61.19:5236]:处于普通打开状态 登录使用时间: 2.411(毫秒) SQL&gt; DBMS_STATS.GATHER_SCHEMA_STATS('CQJ',100,TRUE,'FOR ALL COLUMNS SIZE AUTO'); 收集指定用户下所有索引的统计信息：
DBMS_STATS.GATHER_SCHEMA_STATS('CQJ',1.0,TRUE,'FOR ALL INDEXED SIZE AUTO'); Mysql导入dump文件 login Mysql using root
drop database cqj; Then cmd to sql dump file path:
mysql -uroot -pWelcome1 &lt; 20210407cqj.sql If not drop database , then
c:\Data\sas\Datadump_mysql&gt;mysql -u root -pWelcome1 --default-character-set=utf8 -D jeesite &lt; 20200101.sql mysql: [Warning] Using a password on the command line interface can be insecure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bd6802eb1c4c959eed67926cc69a9a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53fd0e6c65681f41410ae3b9fd675ad/" rel="bookmark">
			Kettle 实战教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kettle 实战教程
1.引言....................................................................................8
1.1 编写目的...........................................................8
1.2 阅读对象...........................................................9
1.3 术语和定义.......................................................9
1.3.1 资源库..........................................................9
1.3.2 Transformation...........................................9
1.3.3 Job..............................................................10
1.3.4 Hop.............................................................10
1.3.3.1 Transformation hop.....................10
1.3.3.2 Job hop..........................................10
1.3.5 Chef............................................................10
1.3.6 Kitchen........................................................10
1.3.7 Spoon...........................................................11
1.3.8 Pan................................................................11
2. 产品介绍.......................................................................11
2.1 什么是ETL...........................................................11
2.1.1 ETL 概念之背景.............................................11
2.1.2 ETL 概念之工作流程......................................12
2.1.3 ETL 概念之操作步骤.......................................13
2.2 什么是 kettle..........................................................14
2.2.1 什么是kettle？..................................................14
2.2.2 主要功能............................................................15
2.3 Kettle 的整体结构图.............................................15
2.4 运行环境.................................................................15
2.5 支持的 DB 种类.....................................................16
2.6 支持的操作系统.....................................................16
2.7 支持的文件类型.....................................................16
2.8 安装说明.................................................................16
2.8.1 Window 下安装................................................16
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c53fd0e6c65681f41410ae3b9fd675ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d634d4303d5b56a23d837dd47f0b45/" rel="bookmark">
			Qt QObject详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 QObject类是所以Qt类的基类，也是Qt对象模型的核心。这个模型中的核心特性就是能让对象键无缝通信的信号和槽的机制。我们可以使用connect()函数将一个信号连接到一个槽上，也可以使用disconnect()删除这个连接。为了防止无休止的的信号通知，还可以使用blockSignals()来临时阻塞信号。而connectNotify()和disconnectNotify()两个函数可以让我们能够跟踪一个对象上信号的连接变化。
QObject对象使用对象树的方式来组织它们自己。所以，当你以另一个对象作为父来创建一个QObject对象时，该对象会自动的将它自己添加的父级的孩子列表中，父级会接管该对象的所有权，也就是说，父级会在自己的析构函数中自动释放它的所有孩子。我们可以使用对象名通过findChild()或findChildren()函数在对象树中查找一个或多个对象。
本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（C++语言基础，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓
每一个QObject对象都有一个objectName()，并且它的类名也可以使用metaObject（）对象来获取。还可以使用inherits()来判断一个对象所属的类是否继承自另一个类。
当一个对象被销毁时，它会发出destroyed()信号。我们可以捕捉该信号来做一些最后的处理。
QObject对象可以使用event()函数来处理事件，还可以通过installEventFilter()和eventFilter()函数来过滤或拦截其他对象的事件。QObject还支持基本的定时器。
注意，对于所有实现信号、槽、或者属性的QObject对象来说**，Q_OBJECT宏**都是必须的。我们推荐在每一个QObject的子类中使用这个宏，无论其是否实现信号、槽或属性，这可以避免一些奇怪的行为。
Qt中，所有的控件都派生自QObject。而QObject中的isWidgetType()函数可以判断一个对象是否是一个控件。
QObject所有的成员方法：
2. 线程亲和性 QObject对象有一个线程亲和性，或者是它生存在某个特定的线程中。当一个QObject对象接收到一个queued signal或一个posted event时，相应的槽函数或事件处理器会在该对象所生存的线程中执行。
注意，如果一个线程没有线程亲和性，或者，如果它生存的线程没有运行事件循环，那么它不能接收到queued singal或posted event。
默认情况下，QObject对象生存在创建它的那个线程中。但我们可以使用thread()函数来查询对象的线程亲和性，还可以使用moveToThread()函数来改变一个对象的线程亲和性。并且，所有的对象都和它的父生存在同一个线程中。因此：
在调用setParent()时，如果涉及到的两个对象不在同一个线程，就会失败。
当一个QObject对象被移动到其他线程时，它们所有孩子也会自动被移动。
moveToThread()在对象有父级的时候，会失败
如果一个QObject对象是在QThread::run()中被创建的，那么它们不能成为QThread对象的孩子，因为QThread对象并不生存在调用QThread::run()的那个线程中。
注意，一个QObject对象的成员变量不会自动成为该对象的孩子。对象间的父子关系必须通过向子对象的构造函数传递一个指针，或通过调用setParent()来实现。如果没有这样做，那么，当调用moveToThread()时，QObject对象的成员变量会仍然存在于老线程中。
3. 没有拷贝构造函数或赋值运算符 QObject对象既 没有拷贝构造函数也没有赋值运算符。实际上，它们在QObject类中都进行了声明，只不过是放在了private区域，并使用了Q_DISABLE_COPY()宏进行了禁用。这样一来，你应该在需要QObject子类作为值的地方，使用一个QObject指针来代替。例如，因为没有拷贝构造函数，你不能将QObject对象作为值存储到容器类中， 必须使用指针来存储。
4. 自动连接 Qt的元对象系统提供了一个自动连接信号和槽的机制。只要对象定义了合适的对象名，并且相应的槽函数的声明遵循移动的命名约定，那么就会在运行时通过QMetaObject::connectSlotsByName()函数来自动进行信号和槽的连接。我们在之前的例子中，经常使用的“转到槽…”操作，就通过这种机制实现的。
5. 动态属性 从Qt4.2开始，就可以在运行时动态的从QObject对象上添加或移除属性。动态属性不需要在编译时进行声明，但它们提供了和静态属性一样的效率，并使用同一套API进行操作，即使用property()函数来读取属性值，使用setProperty()函数来修改属性值。
而从Qt4.3开始，Qt Designer也支持了动态属性，并且Qt的标准控件和用户自定义的控件都可以被赋予动态属性。
6. 国际化 所有QObject的子类都支持Qt的翻译特性，也使我们可以把应用程序的用户界面翻译成不同的语言。而为了使用户可见的文本可以被翻译，我们必须使用tr()函数来将这些文本包围起来。
7. 属性文档 属性只有一个：objectName，类型是QString
相关成员方法
QString objectName() const void setObjectName(const QString &amp;name) 8. 常用成员方法 QObject::QObject(QObject *parent = nullptr)：构造函数 有一点注意，当控件的父对象为空时，这个控件就是一个顶层窗口控件。 QObject::~QObject()：析构函数 当对象销毁时，所有和它相关的信号都回断开，相关的事件也会从事件队列中移除。建议使用deleteLater()来销毁对象，它比直接销毁delete更安全。 手册中有一个警告：删除所有子对象。如果这些对象中的任何一个在栈或全局上，则程序迟早会崩溃。 我的理解是：使用new在堆上分配空间来创建子对象，让父对象负责它的内存回收；如果要在栈上创建对象，就不要指定它的父对象，以免父对象回收了栈内存，导致崩溃。 不建议从父项外部保留指向子对象的指针。如果仍然这样做，则destroy()信号检测对象何时被销毁。 警告：等待传递挂起事件时删除QObject可能会导致崩溃。如果QObject存在于与当前正在执行的不同的线程中，则不能直接删除它。改为使用deleteLater（），这将导致事件循环在所有挂起事件传递给它之后删除该对象。 bool QObject::blockSignals(bool block) 当参数block=true时，该对象的信号被阻塞，即信号发不出去；除了destroy()信号。 const QObjectList＆QObject :: children（）const 返回子对象列表，QObjectList的定义：typedef QList &lt; QObject * &gt; QObjectList ; 列表第一个子项是最初添加的，最后一个子项是最后添加的； 在QWidget中的子项会因为提升函数raised()和降低lowered()，导致子项在列表中的变化，提升后子项将成为列表的最后一个，降低后会成为列表中最后一个。 connect函数组 QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection); QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection); QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type = Qt::AutoConnection) const; QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection); QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor); QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type = Qt::AutoConnection) disconnect void QObject :: dumpObjectInfo() const 将有关此对象的信号连接等的信息转储到调试输出。 QList QObject::dynamicPropertyNames() const 返回使用setProperty()加载的属性列表。 bool QObject::event(QEvent *e) [virtual] 此虚函数接收事件到对象，如果事件e被识别和处理，则应返回true 。可以重新实现event()函数以自定义对象的行为。 确保为所有未处理的事件调用父事件类实现。 bool QObject::eventFilter(QObject *watched, QEvent *event) [virtual] 如果此对象执行installEventFilter安装为watched对象的事件过滤器，则过滤事件。 在重新实现此函数时，如果要过滤掉事件，即停止进一步处理，则返回true; 否则返回false。 警告：如果在此函数中删除接收器对象，请确保返回true。否则，Qt会将事件转发给已删除的对象，程序可能会崩溃。 T QObject::findChild(const QString &amp;name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const 返回找到第一个子项或孙子项； options取值： Qt::FindDirectChildrenOnly：只在子项中查找； Qt::FindChildrenRecursively：在所有项（包括孙子、重孙子等）中递归查找 如：返回parentWidget中名字为button1的QPushButton QPushButton *button = parentWidget-&gt;findChild&lt;QPushButton *&gt;("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67d634d4303d5b56a23d837dd47f0b45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ededde27e48179c7a68a790bbd78ad4/" rel="bookmark">
			python之tkinter控件详解(1)下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 前言⒈按钮详解（下）·(1)给按钮添加功能①基本输出②判断&amp;输出step1:获取输入的数据step2:条件判断拓：把文字打在tkinter窗口里 2.总结·(1)知识点·(2)注意 附件1——函数讲解介绍定义函数 附件2——本文章使用的源代码预告 前言 接上篇文章，上一篇我们讲解了tkinter的按钮，今天我们给按钮添加功能。
这篇文章可能会较短，希望大家谅解
⒈按钮详解（下） 先看一下成果（主要看输出区和我在输入框里输入的数字）
·(1)给按钮添加功能 ①基本输出 在我们平时填写问卷的时候，会有一个提交按钮，将我们输入的数据上传到后台数据库里，tkinter改怎么实现呢？需要用到函数
想必应该都知道函数是什么，该怎么使用吧。不知道的看附件1，这里不过多赘述。
def可以定义一个函数
下面，我们定义一个函数，叫做main，函数体是输出 ‘提交成功’ 。
def main(): print(‘提交成功’) 把函数与按钮结合，要使用command参数，例如：command=main
注意：
⒈command参数里函数名不用加括号
⒉函数必须在按钮之前定义
⒊如果用到了变量，建议使用label声明为全局变量后使用
def main(): print('提交成功') a_button = tk.Button(win, text="提交",fg='blue',bg='yellow',bd=5,font=('华文行楷',30),command=main) a_button.pack() 运行演示
②判断&amp;输出 step1:获取输入的数据 要获取输入的数据需要使用get()指令
def main(): print('提交成功') print('提交的数据是:',int(a.get())) a_button = tk.Button(win, text="提交",fg='blue',bg='yellow',bd=5,font=('华文行楷',30),command=main) a_button.pack() 注意：get()是一个固定指令，不能不写括号
运行演示
step2:条件判断 添加一个判断语句即可（if/if-elif-else/if-else）
def main(): print('提交成功') print('提交的数据是:',int(a.get())) if int(a.get())&gt;=5: print('大于等于5') else: print('小于5') a_button = tk.Button(win, text="提交",fg='blue',bg='yellow',bd=5,font=('华文行楷',30),command=main) a_button.pack() 运行演示
第一次输入4，第二次输入5
拓：把文字打在tkinter窗口里 和以前添加文字的方法一样，这里不过多赘述，不会的看第一篇文章
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ededde27e48179c7a68a790bbd78ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93131570cd23f9a324e0ea3697e67ea/" rel="bookmark">
			HALCON 导出代码封装成 MFC DLL ，调用FreeLibrary 应用程序会卡住，退不出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析：DLL中注释掉HALCON接口调用，可正常退出应用程序，所以原因在于加在halcon的dll问题上。
解决方法：目前使用延时加在DLL的方式。如封闭的DDL名称为A.DLL，则设置应用程序的项目属于
属性配置-&gt;链接器-输入-&gt;延时加载DLL中输入 A.dll
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce776c0304bd1ee7b624fd7ae90e88b9/" rel="bookmark">
			【14】IP协议基础及分片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 IP协议IP的包头结构分片 网络层位于数据链路层与传输层之间。网络层中包含了许多协议，其中最为重要的协议就是IP协议。网络层提供了IP路由功能。理解IP路由除了要熟悉lP协议的工作机制之外，还必须理解IP编址以及如何合理地使用IP地址来设计网络。
IP协议 lnternet Protocol，因特网协议 IP的包头结构 分片 分片：当数据包比链路MTU大时，就可以被分解为很多的足够小片段的过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc1a2a337bcbd4abefa28a951627e50/" rel="bookmark">
			Impala常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Impala 字符串函数 1、去除字符串之前和之后的任意个数的空格 ​ btrim(string a)
[master:21000] &gt; select btrim(' hello ') as btrim; +-------+ | btrim | +-------+ | hello | +-------+ 2、返回字符串的长度，两个函数功能相同 ​ char_length(string a)
​ character_length(string a)
--char_length得到hello world的长度 [master:21000] &gt; select char_length('hello world') as char_length; +-------------+ | char_length | +-------------+ | 11 | +-------------+ --通过函数character_length得到hello world的长度 [master:21000] &gt; select character_length('hello world') as character_length; +------------------+ | character_length | +------------------+ | 11 | +------------------+ 3、拼接多个字符串 ​ concat(string a,string b…)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc1a2a337bcbd4abefa28a951627e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa820b856a82789d80bef747e6765b27/" rel="bookmark">
			RustDesk自建服务器实录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		购买腾讯云 选择地理上最近的地域，以便速度最快，我在武汉，选择的是成都。
云服务器基本配置：
镜像信息：Ubuntu 22.04 LTS
实例规格：CPU: 2核 内存: 2GB
系统盘：40GB SSD云硬盘
流量包：300GB/月（带宽：4Mbps）
远程登录选择WebShell一键登录，简单方便。
腾讯云 产业智变·云启未来 - 腾讯 (tencent.com)
→控制台→产品管理→最近访问→轻量服务器→服务器→Ubuntu→远程登录→一键登录→进入远程Bash界面
安装配置Docker容器 文章来源：docker-compose自建RustDesk远程控制服务器
所有操作均在root权限进行，需要先切换用户
sudo -i 1、新建文件夹【/root/rustdesk_data】
mkdir /root/rustdesk_data 2、进入文件夹
cd /root/rustdesk_data 3、新建yml文件，并写入保存配置
vi docker-compose.yml yml文件配置内容如下：
version: '3' networks: rustdesk-net: external: false services: hbbs: container_name: hbbs ports: - 21115:21115 - 21116:21116 - 21116:21116/udp - 21118:21118 image: rustdesk/rustdesk-server:latest command: hbbs -r rustdesk.example.com:21117 volumes: - ./data:/root networks: - rustdesk-net depends_on: - hbbr restart: unless-stopped hbbr: container_name: hbbr ports: - 21117:21117 - 21119:21119 image: rustdesk/rustdesk-server:latest command: hbbr volumes: - .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa820b856a82789d80bef747e6765b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2af7f118be79671f65e62ce943fda13/" rel="bookmark">
			《最佳停止时间》：什么时候可以停止寻找？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一个有趣的数学编程知识 《最佳停止时间》：什么时候可以停止寻找？
日常生活有很多"寻找-决策过程"，如果考察所有选项，要花费很长时间，可能还会错失机会，后面遇到的未必有前面的好。能否确定一个时间点，到了某个阶段就停下来，不再寻找了，这时找到合适候选人的概率最大？
这在数学上称为"秘书问题"。
某公司招聘一名秘书，有100名候选人，依次面试。每面试完一个人，就必须立刻决定是否录取。也就是说，不能面试完所有人，再回过头决定录取哪一个，一旦放弃当前候选人，就只有从后面的面试者中选择。
这个设定是合理的，象征我们在生活中遇到的各种机会。机会来临时，转瞬即逝，必须立刻决定是否抓住它，错过就是错过了。你在三个月前放弃了一个机会，不可能三个月后再捡起来。
大家可以想一想，这时应该面试多少人？
如果录用得太早，可能错过后面更好的候选人；如果录用得太晚，可能错误放走前面的合格人选。
数学家对这个问题，已经有了充分的讨论。经过计算，成功概率最大的方法，叫做"1/e 法则"。e 是自然对数的底数，约等于2.718，那么 1/e 就约等于37%，所以它又称"37%法则"。
"37%法则"的意思就是，寻找阶段进行到37%就要停止。 100个应聘者，先面试前37个，此后的面试只要遇到一个更优秀的，就立刻录取，不再继续面试了。换句话说，前37个面试者无论多么优秀，都不会录取，他们只是用来确定录取的标准。
如果最合适的候选者偏偏在前面37%里面，那就只能错过了，作为"寻找阶段"不得不付出的成本。最终录取的将是不如前面候选人的次优选择。
这个法则很实用，日常生活中，只要符合"寻找-决策过程"的场景，都可以适用37%法则。
（1）相亲时，假定有10个相亲对象，那么前3～4个可以作为寻找阶段，后面只要遇到一个比前面更好的人，就可以同意了。
（2）租房时，假定有一个月的找房子时间，那么30天的37﹪也就是11天。在找了11天之后，你就要出手了。只要发现比先前更令人心动的房子，就不要犹豫，马上租下来。
（3）读书时，假定这本书有100页，如果读了37页，还没有发现感兴趣的内容，那就可以放弃了。
（4）一个10集的电视剧，第4集是最佳弃剧时间。
（5）一个10分钟的视频，看了3分42秒，如果还是觉得不好看，就可以关掉了。
（6）一个年轻人想在18岁到24岁，一共7年时间里找到人生方向，确定未来想做什么。那么，他有2.59年（7 * 0.37）的时间自由尝试。也就是说，到了大三下学期就应该初步定下自己的方向，后面除非遇到更有吸引力的事情，否则就不应该转换事业方向。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997a93f02b7ecc26d4780ff7b9ae4088/" rel="bookmark">
			[Pytorch] CIFAR-10数据集的训练和模型优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章借鉴了我的朋友Jc的报告，他是一个十分优秀的人。
本篇文章记录了第一次完整训练优化的过程
0 关于数据集 在CIFAR-10 dataset的介绍中，cifar-10数据集一共10类图片，每一类有6000张图片，加起来就是60000张图片，每张图片的尺寸是32x32，图片是彩色图，整个数据集被分为5个训练批次和1个测试批次，每一批10000张图片。测试批次包含10000张图片，是由每一类图片随机抽取出1000张组成的集合。剩下的50000张图片每一类的图片数量都是5000张，训练批次是由剩下的50000张图片打乱顺序，然后随机分成5份，所以可能某个训练批次中10个种类的图片数量不是对等的，会出现一个类的图片数量比另一类多的情况。
1数据处理 1.1 加载数据集和归一化 transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))的作用
使用Normalize()函数，将数据转换为标准正太分布，使得模型更加容易收敛，其中 mean 和 std 的3个值分表表示图像的3个通道。对于单通道的灰度图，可以写成 transforms.Normalize(mean=[0.5], std=[0.5])。
## 加载数据集归一化 transform = transforms.Compose( [transforms.ToTensor(), # transforms.Normalize(mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225])# 66.98 transforms.Normalize(mean=[0.5, 0.5, 0.5],std=[0.5, 0.5, 0.5]) ] ) PyTorch 中我们经常看到 mean = [0.485, 0.456, 0.406], std = [0.229, 0.224, 0.225] ，是从 ImageNet 数据集的数百万张图片中随机抽样计算得到的。
train_data = torchvision.datasets.CIFAR10("dataset", train=True, transform=transform, download=True) test_data = torchvision.datasets.CIFAR10("dataset", train=False, transform=transform, download=True) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/997a93f02b7ecc26d4780ff7b9ae4088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884bc2827608dccfa9e25982f9021864/" rel="bookmark">
			如何在windows系统中创建本地SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在windows系统中创建本地SSL证书
1.环境准备 Windows 安装 OpenSSL
https://slproweb.com/products/Win32OpenSSL.html
Win64 OpenSSL v3.0.5 Light
EXE | MSI
安装完毕，添加到系统变量 Path
C:\Program Files\OpenSSL-Win64\bin win 键 + R，cmd，打开命令行界面
查看 openssl 版本
C:\Users\ran&gt;openssl version OpenSSL 3.0.5 5 Jul 2022 (Library: OpenSSL 3.0.5 5 Jul 2022) 比如想要生成的证书，放在 D 盘 cert 文件夹下，先 CD 到目录
C:\Users\ran&gt;D: D:\&gt;cd D:\cert D:\cert&gt; 2 证书创建的具体过程 解压openssl-WIN32.zip,进⼊解压⽬录的bin⽬录中,打开openssl.exe，以下的命令均在openssl.exe中执⾏。
⽣成私钥 使⽤openssl⼯具⽣成⼀个RSA私钥
genrsa -des3 -out server.key 2048 说明：⽣成rsa私钥，des3算法，2048位强度，server.key是秘钥⽂件名。
注意：⽣成私钥，需要提供⼀个⾄少4位的密码。
⽣成CSR（证书签名请求） ⽣成私钥之后，便可以创建csr⽂件了。
此时可以有两种选择。理想情况下，可以将证书发送给证书颁发机构（CA），CA验证过请求者的⾝份之后，会出具签名证书（很贵）。另
外，如果只是内部或者测试需求，也可以使⽤OpenSSL实现⾃签名，具体操作如下：
req -new -key server.key -out server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/884bc2827608dccfa9e25982f9021864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1c2a297ec4db35f202b4e47f672e487/" rel="bookmark">
			Java——红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 红黑树也是一种二叉搜索树，但是和avl树不同，它并不是依靠平衡因子来保证树的平衡的，而是通过颜色
红黑树每个节点中会存储颜色，分为红色和黑色，通过红黑树的限制条件，可以保证从根节点出发到叶子节点的每一条路径长度都不会是其他路径长度的两倍，以此达到接近平衡，保证了搜索的效率是log2（N）
性质 红黑树需要满足以下几点性质：
每个节点不是红色的就是黑色的根节点必须是黑色的如果一个节点是红色的，那么他的孩子节点必须是黑色的每一条路径从根节点到叶子节点中的黑色节点的个数必须相同所有的叶子节点（这里指的是空节点）都是黑色的 红黑树节点的定义 红黑树中的节点不仅需要定义左右孩子的指针，父节点的指针，自身存储的值，还要存储这个节点的颜色，这里通过枚举来存储
并且需要满足新创建的节点是红色的，因为如果要是创建的是黑色的，那么在插入的过程中很难保证性质四——每一条路径从根节点到叶子节点中的黑色节点的个数必须相同
节点定义代码 static class RBTreeNode { public RBTreeNode left; public RBTreeNode right; public RBTreeNode parent; public int val; public COLOR color; public RBTreeNode(int val){ this.val = val; //新创建的节点默认是红色 this.color = COLOR.RED; } } COLOR枚举 package rbTree; public enum COLOR { RED,BLACK } 插入 在插入时和AVL树一样，要先按照平衡二叉树来进行遍历插入
先判断根节点是否为空，为空则直接插入
然后定义一个cur和parent，cur先为root，cur一直向下遍历。
如果val小于cur.val，cur就变成cur.left
大于的话就变成cur.right
如果等于，就说明已经有这个节点了，return false
在cur遍历的过程中，使parent始终为cur的上一个节点，使得当cur变成空时，能够记录上一个节点的位置
然后判断val和parent.val的大小关系，插到对应的位置上
RBTreeNode node = new RBTreeNode(val); if(root == null){ root = node; node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1c2a297ec4db35f202b4e47f672e487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf6d369196ac9caff83717ef338e49a2/" rel="bookmark">
			用友u8 出现 由于目标机器积极拒绝，无法连接。192.168.2.206:11520
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封面图是在b站复制过来的，电脑上安装了全产品版的U8和2016 sql server数据库
服务端和客户端的防火墙关闭、仍然出现这个错误。服务端U8在电脑右下角会有一个“图标用友应用服务管理器”，右击它打开“窗口”，把里面的服务关闭后重启服务，再试试。不行的话打开用友系统服务里面的“诊断工具”诊断下哪里出问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/520f5d435067078e28e806c3d5a89b0a/" rel="bookmark">
			CMake中INSTALL_RPATH与BUILD_RPATH问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.RPATH和RUNPATH区别2.CMake build之后消除RPATH3.CMake install之后保持RPATH 1.RPATH和RUNPATH区别 RPATH和RUNPATH都可以用来在运行时搜索动态库。
下面用一个简单的例子说明二者的区别。eg：一个小工程中，有1个头文件和3个源文件。
头文件sub.h中的内容如下： #ifndef TESTRPATH_SUB_H #define TESTRPATH_SUB_H void f1(void); void f2(void); #endif 源文件a.c中的内容如下：
#include "sub.h" void f1(void) { } 源文件b.c中的内容如下：
#include "sub.h" void f2(void) { f1(); } 源文件main.c中的内容如下：
#include "sub.h" int main(void) { f2(); } 测试：
在Ubuntu16.04 + gcc5.4中编译，命令及结果如下： madengyun@intellif-B250-HD3:~/TestRpath$ gcc a.c -fPIC -shared -o liba.so madengyun@intellif-B250-HD3:~/TestRpath$ gcc b.c -fPIC -shared -L$PWD -la -o libb.so madengyun@intellif-B250-HD3:~/TestRpath$ gcc main.c -L$PWD -Wl,-rpath,$PWD -lb madengyun@intellif-B250-HD3:~/TestRpath$ ldd a.out linux-vdso.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/520f5d435067078e28e806c3d5a89b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a87457ccc984dbd7aa7e3aeadc73079/" rel="bookmark">
			【Java】SpringCloud使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud使用 发起远程调用 根据订单id查询订单的同时，把订单所属的用户信息一起返回，但订单信息和用户信息分属两个不同的模块。
本质上是订单模块向用户模块发起请求，在spring中使用resttemplate发起。
@MapperScan("cn.itcast.order.mapper") @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } } 搭建Eureka-server 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; 在启动类上添加注解
添加配置文件 server: port: 10086 # 服务端口 spring: application: name: eurekaserver # eureka的服务名称 eureka: client: service-url: # eureka的地址信息 defaultZone: http://127.0.0.1:10086/eureka 注册客户端 引入pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; 编写配置文件 spring: application: name: userservice eureka: client: service-url: defaultZone: http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a87457ccc984dbd7aa7e3aeadc73079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ada5212f1a753e6ed5e32548e95d60/" rel="bookmark">
			【面试大全-缓存】-Redis必修课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要用缓存 使用缓存的目的是提高读写性能，在实际业务场景下，更多是为了提高读的性能，带来更高的并发量，Redis的读写性能比Mysql好很多，这个时候可以把Mysql的热点数据同步到Redis中来。 Redis有哪些好处 读取速度快，响应快支持多种数据结构：字符串、列表、集合、有序集合、哈希等。支持事务，且操作遵守原子性其他丰富的功能：队列、主从复制、集群、数据持久化等。持久化存储，Redis提供RDB和AOP两种持久化存储方案，解决Redis挂掉数据丢失问题。缺点：内存数据库，受单台物理机器内存的大小，虽然Redis有过期策略，但还是需要提前预估和节约内存。修改配置文件，进行重启，时间比较久，这端时间不能提供服务。 为什么 使用 Redis 而不是用 Memcache 呢 Redis和Memcache都是将数据存放到内存中，都是内存数据库，不过Memcache还可以用于图片、视频等缓存。Memcache仅支持key-value数据结构、Redis不仅支持key-value数据结构，还支持list、set、hash等Redis当物理内存用完的时候，还可以将很久没用的value持久化到磁盘。存储数据安全，Memcache挂掉后数据不存在了，Redis定期持久化到磁盘。Memcache单个value最大1M,Redis单个最大512MRedis原生支持集群，Memcache没用原生支持集群，需要在客户端自己实现。 为什么Redis单线程模型效率也非常高 C语言开发、效率高纯内存操作基于非阻塞的IO多路复用单线程能够避免多线程上下文切换带来的额外开销 说说Redis的线程模型 Redis内部使用 文件事件处理器。因为这个文件事件是单线程的，所以Redis也叫做单线程的模型，它采用IO多路复用同事监听多个Soket，根据Soket上的事件来选择对应的事件处理器：文件事件处理器包含4个部分：多个SoketIO多路复用程序文件事件分派器事件处理器多个Soket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用会监听多个Soket，会将Soket产生的事件放入队列中进行排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器处理。 为什么Redis要把所有数据放在内存中 Redis将数据放在内存中有一个好处，那就是实现最快的速度对数据进行存取，如果数据存储在硬盘中，磁盘IO会严重影响Redis性能，而且Redis提供了持久化功能，不用担心服务器重启对内存中数据的影响，其次硬件越来越便宜的情况下，Redis也越来越受欢迎。 Redis缓存刷新策略有哪些 maxmemory-policy volatile-lruLRU（最久没有被访问的数据最闲被淘汰）LFU（最近没有被访问到的数据最先被淘汰）FIFO（最先进入的数据最闲被淘汰）超时剔除 Redis持久化方式方式有哪些，以及有什么区别 RDB AOF 两种持久化方式RDB持久化：快照的方式半持久化，记录所有的键值对，在某个节点将数据写入一个临时文件，持久化结束后，用和这个文件替换上次的文件，达到数据恢复。优点：只有一个dump.rdb文件，方便持久化或者数据恢复性能最大化，采用fork一个子进程来操作，让主进程继续处理命令，让子进程进行处理，保证了Redis的性能缺点：数据安全性低，RDB是间隔一段时间进行持久化，如果持久化时发生故障，会发生数据丢失，这种方式适合数据要求不严谨的时候。AOF持久化：所有命令按指定的协议持久化存储，保存为AOF文件优点：数据安全，可以通过配置每次都可以进行记录AOF机制的rewrite模式，可以对AOF命令合并重写，当误操作时，也可以删除某些命令进行恢复缺点：AOF比RDB文件要大，且恢复速度慢数据集大的时候，比RDB启动效率低 Redis持久化方式如何选择 不仅仅使用RDB这样回照成很多数据丢失也不仅仅使用AOF，AOF恢复速度慢，AOF每次都会记录命令，恢复难度可能增大Redis支持同事开启两种方式持久化方式，我们可以综合这两种机制，用AOF来保证数据不丢失，做为数据恢复的第一选择，用RDB来做不同程度的冷备，在AOF丢失或者损坏的时候，采用RDB进行恢复如果两种都开启，在Redis重启的时候，会采用AOF来加载数据，因为AOF数据更加完整 Redis事务的理解 Redis事务是一组组合命令，是Redis的最小执行单位，它可以保证一次执行多条命令，每个事务是一个单独的隔离操作，事务中所有的命令都会序列化，按顺序执行。Redis事务不支持回滚，回滚需要增加很多工作，Redis保持简单、快速的特性。 为什么Redis设计成单线程 多线程的话会设计到锁的操作，并且多线程会有线程切换上下文开销，而且CPU目前不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存和网络开销。 什么是 bigkey？会存在什么影响 bigkey是指占用内存比较大的key，比如一个字符串可以占用300M网络阻塞：获取key时，传输数据量比较大，增加带宽压力超时阻塞：因为bigkey占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。 Redis集群模式 Redis Sentinel：体量较小时，选择单机部署Redis Cluster：官方提供的集群解决方案，体量较大时，使用Redis Cluster，通过分片，使用更多内存。 Redis Cluster集群模式原理 所有节点相互相连集群节点挂掉会自动转移 Redis Cluster 集群方案什么情况下会导致整个集群不可用 Redis没有使用哈希一致性算法，使用的是哈希槽，Redis中哈希槽一共有16384个，假设有三个集群节点，挂掉一个节点时，在某段时间这段哈希槽是不可用的，也就是集群不可用。 Redis集群有哪几种 单节点单机模式也支持一主多从结构带有哨兵的集群部署 Redis常见性能问题有哪些 Master最好不要做持久化工作，入RDB快照，AOF日志文件如果数据比较重要，可以在slave开启AOF日志按秒进行配置持久化为了主从复制的安全性和稳定性，最好部署在同一局域网内主从复制不要用图状结构，用单向链表结构更为稳定，即 Master -&gt; Slave1 -&gt; Slave2 -&gt; Slave3 。如果master挂掉，Salve1立即启用做为master。 假设Redis有1亿个key，其中10w个key是以固定的title，如何将他们快速查找出来 我们可以使用 keys 和 scan 命令使用 keys 命令 ：可以使用keys进行全数据查询，当然Redis是单线程，数据量过大会进行阻塞，而且keys没有分页功能。使用 scan 命令：scan命令和keys命令一样具有匹配功能，但是scan命令不会阻塞线程，并且查找的数据可能存在重复，需要客户端自己去重，因为scan是通过游标进行查询的，所以不会导致Redis出现假死，scan在检索过程中，被删除的元素是不会被查询出来的，相对来说scan命令耗费的时间更长，但是不影响Redis正常使用。 什么情况下会导致Redis阻塞 Redis主机负载过高，也会导致系统崩溃数据持久化占用过多的资源对Redis的API使用不当，导致Redis出现问题外部服务器问题（cpu、内存、网络） 缓存和数据库哪个先更新呢 为了解决数据不至于问题，其中一种解决方案是使用读写串行化，可以通过队列来实现，但是可能存在读请求的挤压，读请求并发高。如果写入数据库和更新到缓存的值是一致的时候，这个时候可以同步更新缓存和数据库，如果对于写比较频繁，而读不频繁的时候，我们需要对对缓存进行删除，等读的时候再去获取如果写数据的值和缓存的值不一致的时候，写入缓存的数据需要通过几个表进行计算，那就没必要马上更新缓存，需要要删除缓存即可，等获取需要的时候再去进行计算一般的解决方案是先删除缓存数据，再更新数据库。常见的三种方式：先更新数据库库、再更新缓存先删除缓存，再更新数据库先更新数据库，再删除缓存。首先我们放入缓存的数据本来就不应该是实时性要求过高，比如用户余额，所以缓存的过期时间保证最终一致性是比较靠谱的。我们不应该过度设计增加系统的复杂度遇到实时性、一致性要求较高的，就应该查询数据库，即使可能性能不高。 怎么提高缓存命中率 提前加载业务数据到缓存中增加缓存存储空间，提高能够缓存的数据提高缓存的更新频率 Redis 如何解决 key 冲突 Redis中，如果key相同，后面一个会覆盖前面一个，如果要解决key冲突，就要有一套key命名规则，比如 按 业务 + 系统 + 子模块 等自定义命名规则。 Redis 报内存不足怎么处理 修改配置文件 maxmemory 参数，曾大内存设置缓存淘汰策略，提高内存的使用率使用Redis集群，提高存储量 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题 缓存雪崩：系统设置的缓存在同一时间大面积过期，这时业务都去查询DB，给DB造成很大的压力，可能导致服务器岩机。解决办法：讲缓存失效时间分散。缓存穿透：指用户查询的时候缓存里面没有，数据库里面也没有，这两就会导致查询2次无用的操作，这样就绕过缓存直接查询数据库。解决办法：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33ada5212f1a753e6ed5e32548e95d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53602d6df1555b84ecece4198e27fdf/" rel="bookmark">
			仿牛客论坛项目Docker部署(ElasticSearch&#43;Redis&#43;Kafka&#43;MySQL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仿牛客论坛项目 项目部署(docker)1.ElasticSearch安装本体安装ik插件 2.Zookeeper3.Kafka测试是否启动成功 4.MySQL启动mysql测试载入数据 5.Redis6.DockerFile构建Java8项目部署成功 参考 项目部署(docker) 1.ElasticSearch 安装本体 mkdir -p /opt/docker/es/plugins #创建插件文件 docker pull elasticsearch:7.17.7 #拉取镜像 docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -v /opt/docker/es/plugins:/usr/share/elasticsearch/plugins -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms512m -Xmx512m -Duser.timezone=GMT+08" -d elasticsearch:7.17.7 测试一下,可以看到开启成功
安装ik插件 下载ik插件到/opt/docker/es//plugins下 注意文件名需要为ik
然后解压 unzip ik.zip docker exec -it elasticsearch bash进入到容器内部
可以看到挂载成功
这个插件没有7.17.7的版本,所以使用7.17.6
在plugin-descriptor.properties进行修改
modify elasticsearch.version=7.17.6 to elasticsearch.version=7.17.7 重启容器docker restart elasticsearch 成功
2.Zookeeper 下载镜像docker pull wurstmeister/zookeeper启动容器 docker run -d --name zookeeper -p 2181:2181 -v /etc/localtime:/etc/localtime wurstmeister/zookeeper -v /etc/localtime:/etc/localtime :让容器使用和服务器同样的时间设置 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53602d6df1555b84ecece4198e27fdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a112549f53b0b3332aadce91d8f52dd/" rel="bookmark">
			C# 开发 DNF手搓按键。keybd_event 模拟键盘操作（重点是方向键模拟）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发目标：使用keybd_event和键盘HOOK实现一个按键模拟DNF中的技能指令。操作角色是红眼。
二、项目进度：初步实现技能指令释放，没有对键盘连按做处理，会有N多重复命令，导致角色会抽搐。没有做自定义按键，所有指令都是写到程序中的，不够灵活。
三、开发环境：Win11 ,VS 2022, .net6
四、详细介绍：
创建键盘钩子，拦截键盘操作
public class Hook { /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; public Hook() { } /// &lt;summary&gt; /// 单例模式 /// &lt;/summary&gt; public static readonly Hook _HookClient = new Hook(); #region 钩子 //委托 public delegate int HookProc(int nCode, int wParam, IntPtr lParam); HookProc KeyBoardHookProcedure; public delegate void HookHandle(Keys key, int DownOrUp); public event HookHandle EventHandle; //钩子状态 public static int hHook = 0; //键盘Hook结构函数 [StructLayout(LayoutKind.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a112549f53b0b3332aadce91d8f52dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8644a1aeceac0c77de139a3c5a4c50bd/" rel="bookmark">
			java springboot结合gdal打包docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤1 创建DockerFile文件 # 基于某个源镜像 这里需要java+gdal 3.2.0 环境 所以不是openjdk FROM projectairws/gdaljava:latest #维护者信息 MAINTAINER WRY ADD *.jar app.jar ENTRYPOINT ["java","-Dspring.profiles.active=dev","-jar","/app.jar"] #暴露的端口 EXPOSE 9889 步骤2 项目中加入gdal加载配置的文件 2.1 引入依赖:
&lt;dependency&gt; &lt;groupId&gt;org.gdal&lt;/groupId&gt; &lt;artifactId&gt;gdal&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; 2.2 项目中加入以下代码用于项目启动时动态加载gdal
import cn.hutool.core.util.ClassUtil; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang.StringUtils; import org.gdal.gdal.gdal; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; import java.io.File; import java.io.IOException; /** * @author : ruoyu * @date : 2023/1/11 */ @Component @Slf4j public class GdalLoaderEngine { private static final String DefaultOsPath = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8644a1aeceac0c77de139a3c5a4c50bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46456aaecc7be5dfcf3422ff1040fbbc/" rel="bookmark">
			ESXI密码重置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		故障现象：忘记了esxi系统管理密码，无法维护。
加载安装镜像包：
进入虚拟机BIOS，将启动盘设置为第一启动项：
扫描可用设备：
扫到一个磁盘：
按F1可以查看磁盘的详情：
按回车回到磁盘详情界面，再按回车，来到操作选择界面；在此处选择“Install ESXi，preserve VMFS datastore”，然后按回车：
键盘布局选择US即可：
输入新密码两次：
确认安装：
按F11开始安装：
安装完成，点击回车将移除安装盘并重启：
验证，成功：
【鸣谢】南京骄可网络
http://www.jiaoko.com/h-nd-521.html
【备注】：preserve，中文意思为保护、维持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469523b9614c9a4b1057fcb7121be155/" rel="bookmark">
			Mac pro 租用服务器整体流程 Vast.ai
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、我租用的是Vast.ai，里面有不同套餐供人选择。
2、首先需要在Billing下添加一张信用卡，冲$10，这个大概就可以使用了。
第一步：
第二步
3、添加实例。
4、第一次创建Instance时需要配置SSH, 具体操作网站有提示，也可以参照如下步骤： There is no ssh password, we use ssh key authentication. If ssh asks for a password, typically this means there is something wrong with the ssh key that you entered or your ssh client is misconfigured. On Ubuntu or Mac, first you need to generate an rsa ssh public/private keypair using the command: ssh-keygen -t rsa Next you may need to force the daemon to load the new private key: ssh-add 这一步如果出现Permission Deny需要先启动SSH-AGENT： eval 'ssh-agent' 然后再执行 ssh-add Then get the contents of the public key with: cat ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/469523b9614c9a4b1057fcb7121be155/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51ac7cf7aced7a39f95488c2b7bbeac/" rel="bookmark">
			Windows hosts修改后不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows hosts修改后不生效问题 在使用Windows时有些特殊原因需要修改hosts，但是修改之后发现无法生效，可依次尝试如下操作：
存在DNS缓存，在控制台运行命令清除DNS缓存：ipconfig /flushdns确保hosts文件的编码格式为ANSI程序无权访问hosts，修改hosts文件的访问权限，增加ALL APPLICATION PACKAGES的读权限 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe403d872b3c883a6542263877ee5198/" rel="bookmark">
			零的执行人--时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世间最无情的莫过于时间，他一点一点的将你身边的亲人，朋友，爱人，所有你和这世间所有的联系，慢慢夺走，不由分说，不得商量。
时间最有情的也莫过于时间，他将人原本空洞的记忆，一点点塞满。爱情，友情，亲情，统统给予你，直至此生变得有意义，不论你是否接受。
如果说我们每个人从出生开始便和死神签订了一份有限契约，那么时间便是这份契约的绝对执行人。
越早想明白自己和执行人的关系，那么越早就能看清自己和这个世界的关系。
也许所谓的修行就是一点一点的和时间和解吧～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac03785dc0e698229d4631fe87bdd8d/" rel="bookmark">
			Apache Tomcat 存在 JsonErrorReportValve 注入漏洞（CVE-2022-45143）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞描述 Tomcat 是由 Apache 软件基金会下属的 Jakarta 项目开发的一个 Servlet 容器，实现了对 Servlet 和 JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat Valve等。
Tomcat 受影响版本中的 JsonErrorReportValve 类由于未对用户可控的类型（type）、消息（message）或描述（description）值进行转义，在 Tomcat 处理用户请求时，如果调用序列中的 Valve 时响应状态码大于或等于400，或者引发了未捕获的异常，则会将攻击者请求数据输出到 tomcat 打印的错误报告中。攻击者可利用此漏洞将恶意数据注入到 tomcat 的输出报告中，或导致输出报告中的 json 输出无效。
漏洞名称Apache Tomcat 存在 JsonErrorReportValve 注入漏洞漏洞类型注入发现时间2023/1/4漏洞影响广度一般MPS编号MPS-2022-64112CVE编号CVE-2022-45143CNVD编号- 影响范围 org.apache.tomcat:tomcat-catalina@[9.0.40, 9.0.69)
org.apache.tomcat:tomcat-catalina@[10.1.0-M1, 10.1.2)
org.apache.tomcat:tomcat-catalina@(-∞, 8.5.84)
修复方案 升级org.apache.tomcat:tomcat-catalina到 8.5.84 或 9.0.69 或 10.1.2 或更高版本
参考链接 https://www.oscs1024.com/hd/MPS-2022-64112
https://nvd.nist.gov/vuln/detail/CVE-2022-45143
https://github.com/apache/tomcat/commit/b336f4e58893ea35114f1e4a415657f723b1298e
https://tomcat.apache.org/security-8.html
情报订阅 OSCS(开源软件供应链安全社区)通过最快、最全的方式，发布开源项目最新的安全风险动态，包括开源组件安全漏洞、事件等信息。同时提供漏洞、投毒情报的免费订阅服务，社区用户可通过配置飞书、钉钉、企业微信机器人，及时获得一手情报信息推送：
https://www.oscs1024.com/cm/?src=csdn
具体订阅方式详见：
https://www.oscs1024.com/docs/vuln-warning/intro/?src=csdn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa651e4033e7fcdbe883f308ae28c5a4/" rel="bookmark">
			C&#43;&#43;基础入门（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 1.介绍·(1)什么是C++·(2)C++发展历程·(3)C++语言标准·(4)C++的编译和环境拓：什么是编译？ ·(5)ISO C++ 98关键字表 ⒉知识探索·(1)必备工具&amp;结构·(2)注释·(3)输出①基础输出②多行输出 ⒊总结·(1)知识点·(2)注意⚠️： 拓展练习 1.介绍 ·(1)什么是C++ C++是一种计算机高级程序设计语言，由C语言扩展升级而产生的 ，最早于1979年由本贾尼·斯特劳斯特卢普在AT&amp;T贝尔工作室研发。
C++既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计。
C++拥有计算机运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的问题描述能力。
·(2)C++发展历程 1970年，AT&amp;T贝尔实验室的工作人员D.Ritchie和K.Thompson共同研发了C语言。研制C语言的初衷是用它编写UNIX系统程序，因此，实际上C语言是UNIX的“副产品”。
1971年，瑞士联邦技术学院N.Wirth教授发明了第一个结构化的编程语言Pascal。
20世纪70年代中期，本贾尼·斯特劳斯特卢普在剑桥大学计算机中心工作。斯特劳斯特卢普希望开发一个既要编程简单、正确可靠，又要运行高效、可移植的计算机程序设计语言。而以C语言为背景，以Simula思想为基础的语言，正好符合斯特劳斯特卢普的初衷和设想。
1979年，本贾尼·斯特劳斯特卢普到了AT&amp;T贝尔实验室，开始从事将C改良为带类的C（C with classes）的工作。、1983年，该语言被正式命名为C++。
1985年、1990年和1994年，C++先后进行3次主要修订。
C++的标准化工作于1989年开始 ，并成立了一个ANSI和ISO（International Standards Organization）国际标准化组织的联合标准化委员会。
1994年1月25曰，联合标准化委员会提出了第一个标准化草案。在该草案中，委员会在保持斯特劳斯特卢普最初定义的所有特征的同时，还增加了部分新特征。
在完成C++标准化的第一个草案后不久，亚历山大·斯特潘诺夫（Alexander Stepanov）创建了标准模板库（Standard Template Library，STL）。在通过了标准化第一个草案之后，联合标准化委员会投票并通过了将STL包含到C++标准中的提议。STL对C++的扩展超出了C++的最初定义范围。虽然在标准中增加STL是个很重要的决定，但也因此延缓了C++标准化的进程。
1997年11月14日，联合标准化委员会通过了该标准的最终草案，
1998年，C++的ANSI/IS0标准被投入使用。
·(3)C++语言标准 自C++的ANSI/IS0标准投用以来，共进行过5次更新
·(4)C++的编译和环境 截至2014年3月，C++共有12个主流集成开发环境。
我使用的是Dev C++软件，有要软件的私信我
截至2014年3月，C++共有5款主流编译器。
拓：什么是编译？ 编译就是把编程语言翻译成机器语言的过程。
如果代码写错了，那么计算机无法理解，就是编译错误。
·(5)ISO C++ 98关键字表 ⒉知识探索 ·(1)必备工具&amp;结构 #include &lt;iostream&gt; using namespace std; int main() { return 0; } #include &lt;iostream&gt;
using namespace std;
要求会背！必须掌握
int main()是一个程序的开始
return 0;是一个程序的结尾
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa651e4033e7fcdbe883f308ae28c5a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda82ea2776ed0d27c9750d10010073a/" rel="bookmark">
			Android开发指南之相机-----选择一个相机库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择一个相机库 英文原文出处
注意:如果您想使用设备的默认相机应用程序执行基本的相机操作，如捕捉照片或视频，请参阅Camera intents(下文有中文翻译)。
如果你想在Android应用程序中添加摄像头功能，你有三个主要选项:
CameraXCamera2Camera (弃用) 对于大多数开发者，我们推荐CameraX。CameraX是一个Jetpack库，支持绝大多数Android设备(Android 5.0及更高版本)，并提供了围绕常见用例设计的一致的高级API。CameraX为您解决设备兼容性问题，这样您就不必向应用程序添加特定于设备的代码。
CameraX是建立在Camera2包之上的。如果您需要低级别的相机控件来支持复杂的用例，Camera2是一个不错的选择，但是这个API比CameraX更复杂，并且需要管理特定于设备的配置。与CameraX一样，Camera2可以在Android 5.0 (API级别21)及更高版本上运行。
原来的Android Camera类已弃用。新的应用程序应该使用CameraX(推荐)或Camera2，现有的应用程序应该迁移，以利用新功能，避免失去与未来设备的兼容性。
Camera intents 要执行基本的相机操作，如使用设备的默认相机应用程序捕捉照片或视频，您不需要集成相机库。使用Intent就可以了。
用相机应用拍张照片 Android通过调用Intent将操作委托给其他应用程序。这个过程包括三部分:Intent本身，启动外部Activity的调用，以及当焦点返回到Activity时处理图像数据的一些代码。
这是一个调用Intent来捕捉照片的函数。
val REQUEST_IMAGE_CAPTURE = 1 private fun dispatchTakePictureIntent() { val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE) try { startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE) } catch (e: ActivityNotFoundException) { // display error state to the user } } 用摄像应用录制视频 你也可以调用Intent来捕捉视频。
val REQUEST_VIDEO_CAPTURE = 1 private fun dispatchTakeVideoIntent() { Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent -&gt; takeVideoIntent.resolveActivity(packageManager)?.also { startActivityForResult(takeVideoIntent, REQUEST_VIDEO_CAPTURE) } ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda82ea2776ed0d27c9750d10010073a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47a60825f97f2bd1ca73c9127987a879/" rel="bookmark">
			Git学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git作为一款分布式版本控制工具，在我们的日常生活中起到了巨大的作用。
何为版本控制：举一个简单例子，我们的在做一个设计方案时会经过多次整改，而我们将每一版文档都保存我们的电脑上，这就是一个本地版本控制。
版本控制有哪些？ 所有的版本数据都保存在服务器上，用户本地只有自己以前所同步的版本，不联网的话，用户无法看到最新的版本，服务器出问题，就完蛋了。代表产品：SVN,CVS,VSS
分布式版本控制Git 每个人都拥有全部代码，有一定安全隐患。
所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在联网时push到相应的服务器或其他用户那里，由于每个用户都保存了所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。
关于SVN和Git的区别：
SVN是集中式版本控制系统，版本库是集中在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要将自己完成的工作推送到中央服务器。集中式版本控制系统必须联网才能使用，对网络带宽要求较高。
Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候无需联网，因为版本都在自己电脑上。若自己在电脑上修改了文件A,这时只需将各自修改的推送给对方，就能看到对方的修改了，Git可以直接看到更新了哪些代码和文件。
Git是目前最先进的分布式版本控制系统。
下载Git 官网的下载地址太慢
https://git-scm.com/
我们可以使用国内的一些镜像网站
https://registry.npmmirror.com/binary.html?path=git-for-windows/
无脑安装下一步即可
这里博主先卸载一下，因为之前博主安装时是通过pycharm安装的，因此默认安装在了C盘，这里重装一下。首先去环境变量中把git相关删除掉
然后卸载软件就可以了
卸载完成后我们去镜像网站下载自己所需版本，最新的就行
在安装式时注意：使用notepadd++作为我们的文本编辑器，默认是vim这个选我们自己常用的即可
安装完成后，在开始菜单可以看到Git选项，此外我们鼠标右击可以看到Git的相关选项：
Git Bash :Unix和Linux风格的命令行，使用最多，推荐最多
Git CMD：Windows风格的命令行
Git GUI：图像界面的Git,不建议初学者使用，尽量熟悉命令，没啥用
下面我们介绍一些常用的Linux命令
常用的Linux命令 1）、cd : 改变目录。 2）、cd . . 回退到上一个目录，直接cd进入默认目录 3）、pwd : 显示当前所在的目录路径。 4）、ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。 5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。 6）、rm: 删除一个文件, rm index.js 就会把index.js文件删除。 7）、mkdir: 新建一个目录,就是新建一个文件夹。 8）、rm -r : 删除一个文件夹, rm -r src 删除src目录 rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！ 9）、mv 移动文件, mv index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47a60825f97f2bd1ca73c9127987a879/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/110/">«</a>
	<span class="pagination__item pagination__item--current">111/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/112/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>