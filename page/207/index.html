<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef5df8b4778d5828ccf13656f5e07bc/" rel="bookmark">
			Redis5种数据类型使用场景梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis在我们日常工作中使用的非常频繁，但是很多同学只会使用string类型，那么今天笔者梳理下redis中常用的5种数据类型，分别适用于哪些业务场景和基本操作，让大家以后能够在合适的缓存场景使用合适的数据类型。
String字符串类型 Redis支持的字符串类型不是定长分配的字符串，是动态变长字符串，修改字符串在没有增加特别多内容的情况下不需要重新分配内存空间，内部结构实现上有点类似于java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。
常用使用场景
字符串类型常用的场景有以下这些：
1）缓存结构体信息：
将结构体json序列化成字符串，然后将字符串保存在redis的value中，将结构体的业务唯一标示作为key；这种保存json的用法用的最多的场景就是缓存用户信息，将用户bean信息转成json再序列化为字符串作为value保存在redis中，将用户id作为key。从代码中获取用户缓存信息就是一个逆过程，根据userid作为key获取到结构体json，然后将json转成java bean。
基本操作：
127.0.0.1:6379&gt; set user.10001 {“id”:”10001”,”name”:”monkey”}
(integer) 1
2）计数功能：
我们都知道redis是单线程模式，并且redis将很多常用的事务操作进行了封装，这里我们最常用的就是数值自增或自减，redis的作者封装了incr可以进行自增，没调用一次自增1，因为redis是单线程运行，所以就算client是多线程调用那么也是正确自增，因为incr命令中将read和write做了事务封装。同样可以设置incr的step，每次根据step进行自增，当然如果要达到自减的效果，那么只要将step设置为负数就可以了。
计数功能使用的场景很多，我们之前经常用在实时计数统计场景，也用在过库存场景、限流计数场景等等，而且redis的性能也是非常高的，对于一般的并发量没那么高的系统都是适用的。
基本操作：
127.0.0.1:6379&gt; set num 1
127.0.0.1:6379&gt; incr num
(integer) 2
127.0.0.1:6379&gt; incrby num 2
(integer) 4
List列表类型 redis的列表的数据结构和Java中的LinkedList比较类似，所以List类型的前后插入和删除速度是非常快的，但是随机定位速度非常慢，时间复杂度是O（n）需要对列表进行遍历。
常用使用场景
1）list列表结构常用来做异步队列使用
将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。
2）list可用于秒杀抢购场景
在商品秒杀场景最怕的就是商品超卖，为了解决超卖问题，我们经常会将库存商品缓存到类似MQ的队列中，多线程的购买请求都是从队列中取，取完了就卖完了，但是用MQ处理的化有点重，这里就可以使用redis的list数据类型来实现，在秒杀前将本场秒杀的商品放到list中，因为list的pop操作是原子性的，所以即使有多个用户同时请求，也是依次pop，list空了pop抛出异常就代表商品卖完了。
基本操作：
//库存为3瓶可乐
&gt; rpush goods:cola cola cola cola
(integer) 3
&gt; lpop goods:cola
"cola"
&gt; lpop goods:cola
"cola"
Hash数据类型 redis的hash相当于hashmap，内部实现上和hashmap一致，数组＋链表的数据结构。
Screenshot 2018-09-20 17.50.55
redis的hash数据类型只能是字符串。它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的hash结构取而代之。 当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef5df8b4778d5828ccf13656f5e07bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d1598212dff9f13447d454da451bda/" rel="bookmark">
			五年，好久不见
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久不见
2021年5月9号，距离上次发博客已经过去了五年。
五年，不长不短，但对我个人来说，这是生活变化最大的五年。
从一个刚刚离校、还在学校宿舍暂住的、手腕骨折的、喜欢打篮球的、未婚的少年，开始正式进入社会、经历社会的毒打...
五年，右手骨折的手腕终于好了，打球的频率慢慢的变成一周一次（骨折养伤了一年多，不能打球实在是太痛苦。。。），喜欢的勇士、皇马各自都经建立王朝然后到现在王朝落幕，
五年，女朋友已经成了老婆，我们相互依赖、共同扶持成长。我们对自己的婚姻很自信，生活里甚少争吵，我很喜欢！
五年间，经历了比之前20年更多的生死离别比，但我一直相信，他们并没有离去，在平行的空间里他们生活的更好、更精彩。
五年间，公司换了两家，一直工作的很愉快，是我性格原因还是运气比较好？ 相比五年前初出社会的毛头小子，现在的我是那时候的我仰慕的对象吧？哈哈
未来五年
我应该有宝宝了吧，女孩最好！
应该有车了吧？。。。 车牌应该摇到了吧？！ 应该换了个大房子，学区房有吗？
应该养了宠物了吧？猫和狗都好，我都很喜欢～
我还在给别人打工吗？最近感觉有点腻了，说不准我搞了个副业更赚钱了？
我应该不嫌老吧？ 毕竟我爱运动，心态也比较好，当然老婆应该更年轻，人间天生的
打球应该还是不会放弃吧？ 这是真爱，游泳技术应该好很多
我家皇马会咋样？勇士只喜欢库里，五年库里也应该退役了
家人都幸福吧？ 身体一定要健康
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9bc589ec4e22258703fe60ad5f08951/" rel="bookmark">
			编译原理复习总结（精华版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文创作过程中参考了网上多篇文章，如有侵权，请联系作者删除 笔记分两部分：
——第一部分是一些小知识点
——第二部分对应了几个大题的解题模板
第一部分 这部分没什么体系，比较零碎，只记录了我感觉比较重要的部分知识点，大部分是一些容易混淆知识点的辨析
二义文法：对一部文法，如果至少存在一个句子，有两棵不同语法树，称该句子是二义性的，包含二义性的句子的文法称为二义文法。上下文无关文法是否具有二义性是不可判定的。但有些特殊的2型文法[例如LL（1）、LR（0）、LR（1）等文法]是先天无二义性的NFA和DFA的主要区别在于：1）DFA没有输入空串之上的转换动作。2）对于DFA，一个特定的符号输入，有且只能得到一个状态，而NFA就有可能得到一个状态集。DFA：只有唯一初态。NFA：有初态集。DFA是NFA的特例。分析方法分两大类：自上而下分析法和自下而上分析法 即推导与归约，最右推导是规范推导，逆过程为规范规约
自上而下语法分析是从G的开始符号S出发，通过反复使用产生式句型中的非终结符进行替换，逐步推导出源程序串，是一种产生的方法，面向目标的方法
自下而上语法分析从输入串开始不断寻找子串与文法G中某个产生式P的候选式进行匹配，并用P的左部代替之，逐步归约到S，是一种辨认的方法，基于目标的方法短语，直接短语，句柄，素短语，最左素短语：（这里给出在语法树上的直观区别方法）
—短语：在语法树中表示所有分支结点对应子树，短语即子树叶子对应的符号。注： 子树包括语法树本身，及句型本身也可以称为短语
—直接短语：在语法树中表示为该短语只有上下相邻父子两代
—句柄：最左直接短语
—素短语：指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语
—最左素短语：最左素短语就是句型最左边的素短语，是算符优先分析法的规约对象 例如：G[T]:
T → TF|F
F → F↑P|P
P → (T)|i
求给定句型：TP↑(T*F)的短语，直接短语，句柄，素短语，最左素短语
步骤：
1.根据产生式做推导
2.根据推导画出语法树
3.根据语法树和以上规则得答案
—短语 5 个 P，T* F，(T* F)，P↑(T* F)，TP↑(T F)
—直接短语 2 个 P，T* F
—句柄 P
—素短语 T* F
—最左素短语 T* F
关于：LR(0)、SLR、LR、LALR
—区别：
—判断方法：
翻译程序、编译程序、解释程序
翻译程序：将用某种语言编写的程序转换成另一种语言形式的程序的程序
编译程序：用高级语言编写的源程序转换（加工）成与之等价的另一种用低级语言编写的目标程序的翻译程序。
解释程序：解释程序是高级语言翻译程序的一种，他将输入的源程序作为输入，解释一句后就提交给计算机执行一句，源程序命令被逐个直接解释执行
算符文法与算符优先文法:
算符文法：任一产生式的右部都不含两个连续非终结符的文法
算符优先文法：是不含空字符且对任一对终结符都有确定的&gt;&lt;=关系的算符文法
字母表：元素的非空有穷集合
符号：字母表中的元素
符号串：字母表中符号组成的有穷序列
句子、句型、语言
句型是由识别符Z推导而得的符号串
句子是没有非终结符号的句型
语言是句子的集合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9bc589ec4e22258703fe60ad5f08951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87594119e3690ad7df8c8a8050abc07/" rel="bookmark">
			如何下载GitHub上的ipynb文件,在GitHub 上下载指定的文件夹的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何下载GitHub上的ipynb文件 本文介绍如何将github上的ipynb文件下载到本地，并用jupyter打开。
操作步骤如下：
在GitHub上用浏览器打开该.ipynb文件；
点击代码窗口右上角的raw或者download，则代码会在新窗口中显示为json格式；
按Ctrl+S或右击将json代码保存到本地，注意将后缀改为.ipynb；
再用jupyter打开本地的ipynb文件即可；
在GitHub 上下载指定的文件夹的两种方法 一、下载所有文件
首先介绍下如果你要下载GitHub下所有的项目文件的话，可以点击其主页下的Clone or download下的Download Zip ，可以直接下载到本地电脑；或者复制其链接，如下
然后再打开Git Bash,前提是你需要电脑已经下载安装好了Git
git clone 链接地址 二、下载指定文件
你是否也经常会遇到这种情况呢？经常在Github上发现一些自己用得到的仓库，你可能会star或者folk。
但是，经常你可能会有这样的需求：我们只希望从Git仓库里取指定的文件或者文件夹出来。在SVN里面，这非常容易实现，因为SVN基于文件方式存储，而Git却是基于元数据方式分布式存储文件信息的，它会在每一次Clone的时候将所有信息都取回到本地，即相当于在你的机器上生成一个克隆版的版本库。
那么这篇博文，我想可以帮助到你
例如，在仓库：Git示例仓库中，我们只想要”/jpeg”这个文件夹下的文件
下面是关键操作步骤
step1：From GitURL to SVNURL
点开”/jpeg”子文件，复制浏览器中的地址，如下：
https:// github. com/shanfl/collectcode/tree/3b09c/jpeg（链接加了左右空格，防止智能识别链接。下同）
将”/tree/3b09c/”替换成”/trunk/”，则新生成的新链接为：https:// github .com/shanfl/collectcode/trunk/jpeg
注意：这里根据分支的不同，通用的办法是将”/branches/branchname/”替换成”/trunk/”。例如：”/tree/master/” to “/trunk/” ； “/tree/develop/” to “trunck”
step2：svn checkout your code
svn checkout SVNURL 这里的SVNURL就是step1中生成的url 简单操作 如果觉得以上操作还觉得麻烦，可以直接进入这个网站：DownGit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b97421ef41a5d5c82df97f6bed56a8b/" rel="bookmark">
			Java数组的各种使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组的定义：
/* * 数组是相同类型数据的有序集合 * 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。 * 其中，每一个数据称作一个数组元素，每个数组元素都可以通过一个下标来访问它们。 */ /* * 数组的声明创建： * 首先必须声明数组变量，才能在程序中使用数组。 * 声明数组变量的语法： * dataType[] arrayRefVar; //首选的方法 * 或 * dataType arrayRefVar[] ; //效果相同，C/C++风格 * * Java语言使用new操作符来创建数组，语法如下： * dataType[] arrayRefVar = new dataType[arraysize]; * 数组的元素是通过索引来访问的，数组索引从0开始。 * 获取数组长度： * arrays.length */ public class Demo1 { public static void main(String[] args) { int[] num1; //1.声明一个数组 int num2[]; //与上一个意思相同。 num1 = new int[10]; //2.创建一个数组，可以存放10个整型数字 int[] nums3 = new int[10]; //声明和创建用一句写出 //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b97421ef41a5d5c82df97f6bed56a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45461bf52ebb2c0118f7090eace4da6/" rel="bookmark">
			计算机网络慕课第三章习题与解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：同类型题目题号相同，由-表示不同题目
1、系统采用带位填充的帧界标记法，收方从网络接收到一个字符串是 11101111100。那么，发送方发送的原始字符串是什么？
11101111110
【解答】：
根据成帧方式可以推断原始字符串为：
11101111110
带位填充的帧界标记法（比特填充的标志比特发）
由特殊的比特模式标记帧的开始和结束，【01111110】/【0x7E】：每当发方的数据链路层在数据中遇到连续五个1，就自动在输出的比特流中填入一个比特0。
1-2、采用比特填充的比特标记法，对0111 1100 0111 1110 组帧后，对应的比特串是多少？
011111000011111010
【解答】：
见1解答
2、有一个字符串1001011，采用奇校验进行检错。试计算应追加到字符串后的校验位是什么？
1
【解答】：
偶数个1，故在校验位加1
若是奇个1，则在校验位加0
3、在回退n帧协议中，当帧序号为5比特，发送窗口的最大尺寸是多少？
31
【解答】：
对于回退n帧协议：
对于最大帧序号为max_seq个，则最多可以发送的帧（窗口大小）为（max_seq-1）
最大帧序号：2^5=32
4、在选择性重传协议中，当帧序号为4比特，并且发送窗口和接收窗口尺寸相同时，发送窗口的最大尺寸是多少？
8
【解答】
对于选择重传协议：
窗口最大尺寸不应该超过序号空间的一半
序号空间最大帧序号：2^4=16
5、系统采用的码字分别是 0000，0011， 1100， 1111（分别对应待传送的码 00， 01， 10 和 11）。请使用海明距离判断：该系统可以检测出多少位错误？
1
【解答】：
该码字列表的海明距离为2，可以检验1位错误
5-2、系统采用纠1位错的海明码，现在要传输的数据是7位，问需要的冗余位至少是几位？
4
【解答】：
对于纠所有单个错误的海明码
假设码字有m个数据位和r个校验位，要能够纠正单个错误，应该有如下关系：
m + r + 1 ≤ 2 r \begin{array}{l}m+r+1\leq2^r\\\end{array} m+r+1≤2r​
m=7，可以计算得r至少为4
5-3、系统采用纠1位错的海明码，待传输的数据是：10101111，校验集合采用偶校验，编码后的码字是下面哪一个？
101001001111
【解答】
计算校验位的校验集合，对其校验集合用偶校验计算校验码填入该校验位
p1p2m3p4m5m6m7p8m9m10m11m12101001001111 对应校验位的校验集合以及校验和：
P1:{p1,m3,m5,m7,m9,m11}-&gt;1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c45461bf52ebb2c0118f7090eace4da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bd985044f2a7819d69138bff6c6d5f/" rel="bookmark">
			linux服务媒体,安装和使用Jellyfin配置Linux媒体服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍在Linux操作系统上安装Jellyfin的方法，同时使用jellyfin，我们可以在几分钟内立即配置Linux媒体服务器，并访问它。Jellyfin支持GNU/Linux、Mac OS和Microsoft Windows操作系统。
在Linux上安装Jellyfin
Jellyfin软件包可用于大多数流行的Linux发行版，例如Arch Linux、Debian、CentOS、Fedora和Ubuntu等。
在Arch Linux及其衍生产品(如Antergos，Manjaro Linux)上，可以使用任何AUR帮助工具安装Jellyfin，例如YaY(参考：安装及使用Arch Linux/Manjaro系统中的AUR助手yay)：
$ yay -S jellyfin-git
在CentOS/RHEL上：
下载最新的Jellyfin rpm软件包并进行安装：
$ wget https://repo.jellyfin.org/releases/server/centos/jellyfin-10.2.2-1.el7.x86_64.rpm
$ sudo yum localinstall jellyfin-10.2.2-1.el7.x86_64.rpm
在Fedora上：
下载Jellyfin并安装：
$ wget https://repo.jellyfin.org/releases/server/fedora/jellyfin-10.2.2-1.fc29.x86_64.rpm
$ sudo dnf install jellyfin-10.2.2-1.fc29.x86_64.rpm
关于Debian系统，如果APT尚未安装，请为APT安装HTTPS传输：
$ sudo apt install apt-transport-https
导入Jellyfin GPG签名密钥：
$ wget -O - https://repo.jellyfin.org/debian/jellyfin_team.gpg.key | sudo apt-key add -
添加Jellyfin存储库：
$ sudo touch /etc/apt/sources.list.d/jellyfin.list
$ echo "deb [arch=amd64] https://repo.jellyfin.org/debian $( lsb_release -c -s ) main" | sudo tee /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39bd985044f2a7819d69138bff6c6d5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7bcb64fcb3264cf8aa75418027f5e0/" rel="bookmark">
			DIJ --迪杰斯特拉最短路算法 c&#43;&#43; 链式前向星优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首先讲解原理 后讲解源代码
原理
DIJ算法，迪杰斯特拉算法，求最短路径
给出一张图，给出各个点间的距离（不能到达视为无穷大），给出一个顶点，将之视为出发点，求出这个点到其余所有点的最短路径。
思想介绍 两个集合 S 和U ，S集合最开始只有给定的出发点，U集合是除了出发点之外的所有点。U集合中所有点都表示为 距离出发点距离xxx的点，
例如 S{A} U{ B(4),C(7),D(无穷大）}这样表示
最开始把U中距离出发点最小的加入到S集合中，并且要审查U中集合是否因为S集合中点的加入，使得U中的点到出发点的距离变小了。如果有那么就要更新。
每次都执行两步操作：
1：从U集合中选择到出发点距离最小的点 加入到S集合
2：更新U集合中剩余的点到出发点的最短路
所以现在请你思考一下，这个算法实现起来的难度在哪里，当你发现这个算法哪里最难实现，那就是这个算法的核心
难点：加入新的点后，如何更新目前其它点到出发点的最短路径，因为新加入的点很可能会影响到原来的值，比如将E加入之后，原来A和C本来无法相连，距离为无穷大，但是有了E这个中间串联的，现在AC可以连接了，距离为一个确定的数。
算法实现讲解
第一步，对输入的边的顶点以及权值进行存储
非常重要的一个图的存储方式–链式前向星
以往的存储图的方式是邻接表，但是有缺陷，这是采用二维数组的方式存储，首先二维数组是非常耗费空间的，其次是两个点之间可能并不存在边。
链式前向星，只需要一个结构体以及一个head一维数组，效率极高，空间上时间上都优越不少。值得大家深入了解。
DIJ算法核心操作
首先进行边的遍历（这里采用的是链式前向星的遍历方式）
当这个顶点没有被访问过，并且当前ans值可以被优化时，进行ans值得更新操作。遍历完成之后，还要不断找最小值，进而确定pos的新的值（pos的新的值要选择ans值最小的进行下一步）
输出结果，程序结束
*总结： 本文重在强调两点，第一是摒弃传统的邻接表存储方式，改用时间空间上更为优越的链式前向星（读者可自行查阅详细信息）
第二是强调DIJ算法的核心操作，重在加入新的点之后，如何更新剩余点到初始点的最短距离*。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4117d7fe8d01915893f6082d9f42bc8/" rel="bookmark">
			ElasticSearch十三--ES--自定义Analyzer分词器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义Analyzer 多字段特性 实现精确匹配
增加一个 keyword 字段 使用不同的analyzer
不同语言pinyin 字段的搜索还支持为 搜索 和 索引 指定不同的 analyzer Exact Values vs Full Text Exact Value 包括数字 / 日期 / 具体一个字符串（例如 Apple Store） 精确值 不需要分词
ES 中的 keyword 全文本，非结构化的文本数据 需要分词
ES 中的 text 自定义分词 当 ES 自带的分词器无法满足时，可以自定义分词器。通过自己组合不同的组件实现
Character Filter
Tokenizer
Token Filter
通过自己组合上面不同的组件，可以实现出不同的分词器效果。
Character Filter 在 Tokenizer 之前对文本进行处理。可以配置多个进行不同的文本处理。会影响 Tokenizer 的 position 和 offset 信息
下面是一些自带的 Character Filter
HTML strip 去除 html 标签Mapping 字符串替换Pattern replace 正则匹配替换 Tokenizer 将原始的文本按照一定的规则，切分为词
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4117d7fe8d01915893f6082d9f42bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1bfe0676cf4a95a7abf9e82d43aeb18/" rel="bookmark">
			使用php为html页面创建登录验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用php为html页面创建登录验证码 效果
验证码的创建
&lt;?php //1.创建画布 $canvas=imagecreatetruecolor(100,30); //2.创建背景颜色 $bg_color=imagecolorallocate($canvas, 0xCC, 0xCC, 0xCC); //3.填充颜色(注意：上面的第二步只是创建对应的颜色，第一个参数放画布是因为，画布分为rgb和真彩，所对应的rgb值有所不同) imagefill($canvas, 0, 0, $bg_color); //4.生成验证码的字符 $charCode="ZXCVBNMASDFGHJKLQWERTYUIOP23456789zxcvbnmkjhgfdsaqwertyuip"; $charCode_len=strlen($charCode)-1; $code="";//最终生成的验证码 for($i=0;$index=4,$i&lt;$index;$i++){ $code.=$charCode[mt_rand(0, $charCode_len)]; } //将code发布到session上用于页面核对验证码 session_start(); $_SESSION['vCode']=$code; or($i=0;$index=4,$i&lt;$index;$i++){ //随机创建一个真彩色，用于添加到字体颜色 $fontColor=imagecolorallocate($canvas, mt_rand(0, 100), mt_rand(0, 50), mt_rand(0, 50)); //设置字体的其他属性 imagettftext($canvas,//作用的背景图 16,//字体大小 mt_rand(0, 45),//字体的倾斜角度 16*$i+15,mt_rand(20, 30),//字体再x、y轴上的浮动范围 $fontColor, 'D:\php\http\Apache24\htdocs\Task345\fonts\SourceCodePro-Bold.ttf', $code[$i]); } /设置干扰元素 小点点 for($i=0;$index=300,$i&lt;$index;$i++){ $dotColor=imagecolorallocate($canvas, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255)); imagesetpixel($canvas, mt_rand(0, 100), mt_rand(0, 30), $dotColor); } //设置干扰元素 线 for($i=0;$index=12,$i&lt;$index;$i++){ $lineColor=imagecolorallocate($canvas, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255)); imageline($canvas, mt_rand(0, 100), mt_rand(0, 30), mt_rand(0, 100), mt_rand(0, 30), $lineColor); } //设置verifyCode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1bfe0676cf4a95a7abf9e82d43aeb18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfe68c50fe292866758ded4819f65b4/" rel="bookmark">
			【密码学】Base64 编码 ( Base64 简介 | Base64 编码原理 | 最后编码组字节不足时补位 ‘=‘ 符号 | Base64 编码实现参考 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Base64 简介二、Base64 编码原理三、最后编码组字节不足时补位 '=' 符号四、Base64 编码实现参考 一、Base64 简介 Base64 不是加密算法 , 是一种 可读性算法 , 其目的不是用于保护数据 , 其目的是为了可读性 ;
普通的二进制数据随机性很大 , 使用二进制文件打开后 , 参考下图 , 有很多奇怪的字符 , 都叫不上名称 , 可读性很差 , 也没办法表述出来 ;
使用 Base64 之后 , 其可读性增强很多 , 标准的 Base64 编码只能从下面的字符中选择字符 ;
private static final byte ENCODE[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', }; Base64 由 64 64 64 个字符组成 , 包括大写 A-Z , 小写 a-z , 数字 0-9 , 两个符号 + 和 / , 上面代码中的 ENCODE 字符数组中的 64 64 64 个字符 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cfe68c50fe292866758ded4819f65b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd9fa68f289868b2ab9049cbc735a200/" rel="bookmark">
			linux wifi热点端口,Linux系统部署hostapd&#43;dhcpd的方式来设置wifi热点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先什么是hostapd？ hostapd 是一个用户态用于AP和认证服务器的守护进程 它实现了IEEE 802.11相关的接入管理，IEEE 802.1X/WPA/WPA2/EAP 认证,RADIUS客户端，EAP服务器和RADIUS 认证服务器。 Linux下支持的驱动有：Host AP，madwifi，基于mac80211的驱动。
二、如何识别无线网卡是否支持AP模式 iw命令识别：iw list 查看Supported interface modes:信息如下图：
若「Supported interface modes」中有「AP」的话，你的无线网卡就可以支持AP模式。如果没有则不支持。 三、开始部署 1、eth0 直接dhcp获取IP即可，如果没有获到IP，手动执行dhclient eth0 2、配置wlan0 静态IP (wlan0 是无线网卡，你的可能是wlan1) 网卡配置文件：/etc/network/interfaces
Allow-hotplug wlan0
Iface walan0 inet static
Address 192.168.100.1
Netmask 255.255.255.0
3、开启路由转发 vi /etc/sysctl.conf net.ipv4.ip_forward = 1(0改为1) 4、iptables添加规则(Ubuntu如果没iptables，自行安装sudo apt-get install iptables) iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -o eth0 -j MASQUERADE 5、安装ahostapd sudo apt-get install hostapd 6、配置dhcp配置文件：/etc/dhcp/dhcpd.conf 网段和无线网卡网段相同
启动dhcp服务：/etc/init.d/isc-dhcp-server start 7、贴出我的hostapd配置文件：/etc/hostapd/hostapd.conf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd9fa68f289868b2ab9049cbc735a200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68215db375784b417c3c7e7e1370e98b/" rel="bookmark">
			列表的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表的遍历（一个一个拿出来）
listName = [“张三丰”,“李四”,“王麻子”,“范铜”] #
##遍历列表中所有元素
print("*"*20)
for obj in listName:
print(obj)
print("*"*20)
##通过 下标（索引）获取值
for i in range(0,len(listName)):
print(“第%d -&gt; %s”%(i,listName[i]))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c39e4490cc634ddd16544f0052828d6/" rel="bookmark">
			linux中卸载ambri-servle,HDP Ambari完全卸载（RPM Install）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文针对 rpm 包安装的 Ambari 集群，应用文件存储的路径比较分散，找起来比较麻烦。特记录一下，以便以后查看，以节约时间。
卸载前确保集群所有服务进程已经停止
查看集群安装的组件方法
Ambari 组件查找
[root@node01 ~]# rpm -qa|grep ambari
ambari-metrics-hadoop-sink-2.6.2.2-1.x86_64
ambari-server-2.6.2.2-1.x86_64
ambari-agent-2.6.2.2-1.x86_64
ambari-metrics-monitor-2.6.2.2-1.x86_64
ambari-metrics-grafana-2.6.2.2-1.x86_64
ambari-metrics-collector-2.6.2.2-1.x86_64
HST 组件查找
[root@node01 ~]# rpm -qa|grep smartsense
smartsense-hst-1.4.5.2.6.2.2-1.x86_64
Hadoop 组件查找
[root@node01 ~]# rpm -qa|grep hadoop
hadoop_2_6_5_0_292-yarn-2.7.3.2.6.5.0-292.x86_64
hadoop_2_6_5_0_292-client-2.7.3.2.6.5.0-292.x86_64
ambari-metrics-hadoop-sink-2.6.2.2-1.x86_64
hadoop_2_6_5_0_292-2.7.3.2.6.5.0-292.x86_64
hadoop_2_6_5_0_292-mapreduce-2.7.3.2.6.5.0-292.x86_64
hadoop_2_6_5_0_292-libhdfs-2.7.3.2.6.5.0-292.x86_64
hadoop_2_6_5_0_292-hdfs-2.7.3.2.6.5.0-292.x86_64
Hadoop 集群依赖组件查找
[root@node01 ~]# rpm -qa|grep ranger
ranger_2_6_5_0_292-yarn-plugin-0.7.0.2.6.5.0-292.x86_64
ranger_2_6_5_0_292-hdfs-plugin-0.7.0.2.6.5.0-292.x86_64
[root@node01 ~]# rpm -qa|grep spark
spark_2_6_5_0_292-yarn-shuffle-1.6.3.2.6.5.0-292.noarch
spark2_2_6_5_0_292-yarn-shuffle-2.3.0.2.6.5.0-292.noarch
Zookeeper 组件查找
[root@node01 ~]# rpm -qa|grep zookeeper
zookeeper_2_6_5_0_292-3.4.6.2.6.5.0-292.noarch
zookeeper_2_6_5_0_292-server-3.4.6.2.6.5.0-292.noarch
HDP 依赖组件查找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c39e4490cc634ddd16544f0052828d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27717aedf01e1eed599c89b8bbbc3ca0/" rel="bookmark">
			mac成功安装GDB记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac成功安装GDB记录 我的系统：macOS Catalina 10.15.6
一、安装gdb ​ 我一开始使用brew命令安装，但始终没有成功，最后转而直接下载安装包进行了安装，下载地址。下载10.2版本，完了之后打开压缩包，输入如下命令：
ocean@MacBookPro gdb-10.2$ ./configure # 配置 ocean@MacBookPro gdb-10.2$ make -j4	# 编译 ocean@MacBookPro gdb-10.2$ make install # 安装 ocean@MacBookPro gdb-10.2$ gdb -v # 查看安装版本 ocean@MacBookPro test$ gcc a.c -g # 写一个测试代码a.c进行测试 ocean@MacBookPro test$ gdb a.out # 进入gdb (gdb)run # 获得报错，看看是否报错与下面的报错类似，如果不是，那么这一步就可能有问题 ​ 一开始下载的是8.0版本，但在未授权的状态下一直报错的是找不到相关文件，报错与其他为授权证书下的完全不同，即如果正常的话应该是如下报错。因此我又重新下载了一个版本，即10.2版本，最终获得了类似的如下报错，第一步完成。
ocean@MacBookPro test$ gdb -v # 查看安装版本 GNU gdb (GDB) 10.2 Copyright (C) 2021 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27717aedf01e1eed599c89b8bbbc3ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4da93ad853cf6403a4c95d14f70c611/" rel="bookmark">
			Java之while循环基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 while 循环控制1. 基本语法2. while 循环执行流程分析3. 注意事项和细节说明4. 课堂练习题 while 循环控制 1. 基本语法 2. while 循环执行流程分析 While01.java
画出流程图
使用 while 循环完成前面的题 //输出10句 你好,兮动人 int i = 1; //循环变量初始化 while( i &lt;= 10 ) {//循环条件 System.out.println("你好，兮动人" + i);//执行语句 i++;//循环变量迭代 } System.out.println("退出while ，继续.." + i); // 11 3. 注意事项和细节说明 循环条件是返回一个布尔值的表达式while 循环是先判断再执行语句 4. 课堂练习题 WhileExercise.java
打印 1-100 之间所有能被 3 整除的数 [使用 while ] 化繁为简：即将复杂的需求，拆解成简单的需求，逐步完成。先输出 1-100 之间的数 int i = 1; while (i &lt;= 100){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4da93ad853cf6403a4c95d14f70c611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f7d90cf4dc0ad58b90ad7cb6a1ac8f/" rel="bookmark">
			论文中如何查看引用的文献在正文中的位置：word中查找交叉引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作方法：
ctrl+H，跳出替换对话框。该对话框有三栏，分别为：查找、替换、定位。我们利用定位功能进行查找。如下所示：
便可以逐个参考文献进行确定。漏了的或者用过的记录下来即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ecdde92f988702ce75f28cf115c8f4d/" rel="bookmark">
			linux磁盘挂载报错,Linux mount挂载磁盘报错  mount: wrong fs type, bad option, bad superblock on /dev/vdb...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux mount挂载磁盘报错 mount: wrong fs type, bad option, bad superblock on /dev/vdb
Linux挂载磁盘报如下错误：
mount: wrong fs type, bad option, bad superblock on 192.168.0.68:/mnt,
missing codepage or helper program, or other error
(forseveral filesystems (e.g. nfs, cifs) you might
need a/sbin/mount.helper program)
In some cases useful infois found in syslog - trydmesg|tail or so
安装nfs
yum install nfs-utils
运行fdisk -l命令查看实例上的数据盘，发现/dev/vdb未被使用
[[email protected] ~]# fdisk -l
Disk/dev/vda: 42.9 GB, 42949672960bytes255 heads, 63 sectors/track, 5221cylinders
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ecdde92f988702ce75f28cf115c8f4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21874bc089f67827bfb9aea836f13bb8/" rel="bookmark">
			windows安装Oracle11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装下载 Oracle11g下载 Oracle11g 安装包下载之后解压安装包，点击 `setup`安装前环境检查安装过程配置1. 配置安全更新2. 安装选项3. 系统类4. 网络安全选项5. 安装类型6. 产品语言7. 数据库版本8. 安装位置9. 配置类型10. 数据库标志符11. 配置选项11.1 内存11.2 字符集11.3 示例方案 12. 管理选项13. 数据库存储14. 备份和恢复15. 方案口令16. 先决条件检查17. 概要18. 安装产品19. 安装完成 查看 Oracle 服务 安装下载 Oracle11g 下载 Oracle11g 安装包 在官网下载相应版本的安装包，我选择的是 Oracle Database 11g Release 2 Express Edition for Windows 64
## 下载入口 https://www.oracle.com/database/technologies/oracle-database-software-downloads.html ## 选择版本 https://www.oracle.com/database/technologies/xe-prior-releases.html 下载之后解压安装包，点击 setup 本安装路径为 E:\softs\OracleDatabase11g\database，实验环境为虚拟机上的 win10 专业版 1909
安装前环境检查 使用 win10 系统安装，会出现 [INS-13001]环境不满足最低要求。
修改 E:\OracleDatabase11g\database\stage\cvu 下的 cvu_prereq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21874bc089f67827bfb9aea836f13bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a8154bdeb7c2bb9ebcf6b765ccba73/" rel="bookmark">
			android studio快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ctrl+G----&gt;跳转指定行 Ctrl+E----&gt;弹出最近打开文件列表 Ctrl+J----&gt;弹出快捷代码框,p s f s-&gt;public static final string Ctrl+F12----&gt;查看类中所有方法 Ctrl+Alt+L----&gt;对当前类的所有代码进行格式化 Ctrl+Alt+V----&gt;快速声明一个变量，本地变量赋值 Ctrl+Alt+H----&gt;左边栏上弹出此方法的调用关系 Ctrl+Alt+O----&gt;自动导包或删除无用的包 Alt+Insert----&gt;快速代码生成框，有构造、getter/setter、toString方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f31557df51714f794d95ff7443ef15a7/" rel="bookmark">
			PTA  (课堂作业)使用函数删除字符串中的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用函数删除字符串中的字符
添加链接描述
注意：要消\n
法1：用同一数组修改
#include &lt;stdio.h&gt; void delchar(char *str, char c); int main() { int i, j, repeat; char c, s[100]; scanf("%d ", &amp;repeat); for (i = 1; i &lt;= repeat; i++) { getchar();//消\n (换行符号） gets(s); scanf("%c", &amp;c); delchar(s,c); printf("result: %s\n", s); } } void delchar(char *str, char c) { int i, j; i = j = 0; while (str[i] != '\0') if (str[i] != c) str[j++] = str[i]; i++; } str[j] = '\0'; } 法1：用同一指针修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f31557df51714f794d95ff7443ef15a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1da1e03fb7beb9f050c141a59f4e573/" rel="bookmark">
			docker常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 批量删除没有tag的镜像 sudo docker images | grep none | awk '{print $3}' |xargs sudo docker rmi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ba33d1bf789ad889d3fec080056b5a/" rel="bookmark">
			《高性能MySQL》读书笔记（1~6章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1章 MySQL架构与历史1.1 MySQL逻辑架构1.1.1 连接管理与安全性1.1.2 优化与执行 1.2 并发控制1.2.1 读写锁1.2.2 锁粒度表锁行级锁 1.3 事务1.3.1 隔离级别1.3.2 死锁1.3.3 事务日志1.3.4 MySQL中的事务自动提交在事务中混合使用存储引擎隐式和显式锁定 1.4 多版本并发控制1.5 MySQL的存储引擎1.5.1 InnoDB存储引擎InnoDB概览 1.5.2 MyISAM存储引擎存储特性MyISAM压缩表MyISAM性能 1.5.3 MySQL内建的其他存储引擎1.5.4 第三方存储引擎1.5.5 选择合适的引擎日志型应用只读或者大部分情况下只读的表订单处理CD-ROM应用大数据量 1.5.6 转换表引擎ALTER TABLE导出与导入创建与查询（CREATE和SELECT） 第2章 MySQL基准测试2.2 基准测试的策略2.2.1 测试何种指标 2.3 基准测试方法2.3.1 设计和规划基准测试2.3.2 基准测试应该运行多长时间2.3.3 获取系统性能和状态2.3.4 获得准确的测试结果2.3.5 运行基准测试并分析结果2.3.6 绘图 2.4 基准测试工具2.4.1 集成式测试工具2.4.2 单组件式测试工具 第3章 服务器性能剖析3.1 性能优化简介3.2 对应用程序进行性能剖析3.3 剖析MySQL查询3.3.1 剖析服务器负载3.3.2 剖析单条查询 3.4 诊断间歇性问题3.4.1 确定单条查询问题还是服务器问题3.4.2 捕获诊断数据 第4章 Schema与数据类型优化4.1 选择优化的数据类型4.1.1 整数类型4.1.2 实数类型4.1.3 字符串类型VARCHAR和CHAR类型varcharchar BLOB和TEXT类型使用枚举(ENUM)代替字符串类型 4.1.4 日期和时间类型DATETIMETIMESTAMP 4.1.5 位数据类型 4.2 MySQL schema设计中的陷阱4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ba33d1bf789ad889d3fec080056b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f3bee145112fd1387693a1ed964873/" rel="bookmark">
			2021-5-8【CCF】【1031. 等腰三角形】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
输入一个正整数n，输出高为n的由*组成的等腰三角形。
输入
输入一个正整数。
输出
输出高为n的由*组成的等腰三角形。
样例输入
3
样例输出
* *** ***** 数据范围限制
1&lt;=n&lt;=20
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n-i-1;j++){ cout&lt;&lt;" "; } for(int k=0;k&lt;2*i+1;k++){ cout&lt;&lt;"*"; } cout&lt;&lt;endl; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b54f0ac262c10f620f498a4ace1e8ac/" rel="bookmark">
			Python实践：一个指令删除C代码全部注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python实践：一个指令删除C代码全部注释 前言解决思路功能实现主调demo 前言 工作中，有时需要发布无任何注释的CleanCode，但每次手动删除注释都比较麻烦，于是有了一个想法：用Python实现一个功能函数，实现一个调用即可删除C代码的全部注释。
解决思路 思路：
查找每行的内容是否含有 // 和 /*若含有 // ，则将之往后的所有内容删除若含有 /*，则判断当前行是否有 */ 如有，则删除当前行区间 /* */里的内容，并判断余下的内容是否为空或全空格如无，则删除/*以后的数据，并继续读取下一行，直到匹配到 */ 遍历到文件末尾结束 所需知识点：
文本文件读写操作字符串分割子字符串查找列表操作 功能实现 输入： 输入输出的文件路径和文件名输出： 生成删除注释后的文本文件注意： 需保证输入为C代码，且注释语法正确 实现代码如下：
import os def del_comment_c(in_dir, in_fname, out_dir, out_fname): in_path = os.path.join(in_dir, in_fname) out_path = os.path.join(out_dir, out_fname) f_in = open(in_path, "r", encoding='UTF-8') write_buf = [] line = f_in.readline() slash_flag = 0 while line: line = line.split("\n")[0] if line.find("//") &gt;= 0: p = line.split("//")[0] ## 存在返回起始坐标，从0开始，不存在，则返回-1 if p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b54f0ac262c10f620f498a4ace1e8ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b600936360a575a1c84a01f8bc913b74/" rel="bookmark">
			node.js 与 vue 实现 excel 导出与保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方 前端瓶子君，关注公众号
回复算法，加入前端编程面试算法每日一题群
来源：猪啰啰 https://juejin.cn/post/6953882449235410951
我们的项目是前端用vue,服务端用node.js,这个excel导出我们已经用了一年,我们目前用到的无非是图片导出,文本导出,调调excel单元格距离等.
这个node端的封装是经过同事不断的review(感谢同事),俺不断的修改优化后的代码,当时也是我第一次接触node.js,只想告诉你,用它,稳稳的！
node.js服务端代码 1.拿到需要导出的数据之后如何使用(假数据模拟,下面是页面) image.png constructor(prop) { super(prop) // 定义excel头部数据 this.header = [ { header: '游戏', key: 'gameInfo', width: 30 }, { header: '宣传图片', key: 'image', width: 15 }, { header: '游戏详情页', key: 'path', width: 15 }, { header: '状态', key: 'activeStatus', width: 30 }, { header: '排序权重', key: 'sort', width: 30 }, { header: '最近编辑时间', key: 'updateTime', width: 30 }, { header: '最近编辑人', key: 'operatorName', width: 30 }, ] } /** * 导出游戏管理数据 */ async exportGameEndGameManage() { const { list } = await this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b600936360a575a1c84a01f8bc913b74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa27dfe59145a1359f0189cd02926b3/" rel="bookmark">
			linux 7 开启远程桌面,配置CentOS 7允许来自Windows的远程桌面访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我需要从一台Windows 10电脑上，通过远程桌面访问一台CentOS 7电脑。两台电脑在同一个局域网段内。当然，如果CentOS 7电脑有公网IP也是可以的。
过程如下：
在CentOS 7上：
1、安装xrdp和tigervnc
yum install -y xrdp tigervnc
2、启动xrdp，并设为自动启动
systemctl enable xrdp
systemctl start xrdp
3、设置防火墙，开通3389端口
firewall-cmd --permanent --add-port=3389/tcp
firewall-cmd --reload
4、检查一下
netstat -nlp |grep xrdp
5、查看CentOS 7的IP地址
ip a
在Windows机上，找到“远程桌面”，输入CentOS 7电脑 的IP地址，点击“连接”，随后输入CentOS 7可以远程登录的用户的用户名和密码，即可以看到其桌面。或用鼠标右键点击右下角开始的视窗图标，在弹出的短菜单上选择“运行”，并输入mstsc，回车。
在显示出来的CentOS 7桌面上，多出一个硬盘的图标，下面写着“thinclient_drives”字样。如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03efc0caa04a4822f35ca262991d32c1/" rel="bookmark">
			学习笔记 ：E1696  C1107 错误提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习笔记 ：E1696 C1107 错误提示
错误提示：
错误提示很多，几百个。
E1696 命令行错误: 无法打开 元数据 文件 “platform.winmd”
Error C1107 未能找到程序集“platform.winmd”: 请使用 /AI 或通过设置 LIBPATH 环境变量指定程序集搜索路径
这种情况一般都是环境配置的问题。
网上有两种解决方案
1修改项目属性“使用Windows运行是扩展”；
2在库目录或者附加依赖项中添加目录
以上两种方案都未解决我的问题
我是由于Windows SDK版本不正确导致的：
一般情况更改或者修复即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59871a23df46d2a6f4bea045d66052e9/" rel="bookmark">
			Sentinel动态推拉数据持久化同步到Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我们使用Sentinel做熔断限流等操作时，一些设置好的配置默认是存放在当前服的内存中的，那么也就意味着每次重启服务，这些配置好的配置就会消失。在我们搭建微服务架构做测试的时候不是很友好。大家都知道Sentinel提供了一些持久化方式，如持久化到Nacos、本地JSON文件。这种方式虽然能解决持久化的操作，但是不能自动同步更新，也就是持久化配置写成什么样就是什么样，在程序启动后，无法动态更新到持久化存储中！当然能做到持久化Nacos或者本地JSON已经很不错了！如果作用做到这一步那么请见Sentinel整合Nacos做持久化这篇文章就够了，如果想要更加灵活，想在运行过程中动态同步Nacos那么就请往下看！
Sentinel动态推拉数据持久化同步到Nacos 这个操作字面意思看似只要同步Nacos这一套逻辑，其实并不是，同步Nacos其实分为普通服务同步Nacos和Gateway同步Nacos。因为二者无论是在Sentinel Datasource（Sentinel服务端） 还是我们自己的业务服(包括网关和其他服)通知拉取推送机制都是不一样的，所以针对这种情况需要做两手逻辑操作！
在写动态拉取数据持久化Nacos前，先保证普通服务整合Sentinel和Gateway整合Sentinel默认流程先能跑通！
Sentinel动态推拉数据持久化同步到Nacos(通用部分) 1.下载Sentinel源码
Sentinel-GitHub
我这里以1.7.1版本为基准，说到版本，这里我要多提一嘴，微服务架构搭建最恶心的我觉得倒不是代码有多难写，往往是代码没什么问题，总是各种版本对不上，这就比较头痛，不过我这里提供一套方案，这套版本适配的方案是比较准的，能帮我们确定一个版本的请款下适配Spring Boot、Spring Cloud、Spring Cloud Alibaba之间的版本版本说明，我整套微服务架构的版本使用的是Spring Boot 2.3.2.RELEASE、Spring Cloud Alibaba 2.2.5.RELEASE、Spring Cloud Hoxton.SR8
不扯远了，收回来接着本文继续搞重点！
这就是我们要二开的源码，idea打开一下
2.修改pom.xml
修改pom.xml中的sentinel-datasource-nacos的依赖，将test注释掉，这样才能在主程序中使用。
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt; 3.创建nacossync目录用来编写我们二开的代码
图中nacossync中这些类就是我们要编写的代码！
4.Naocs数据同步Properties映射类
这个类无论是Gateway二开同步还是普通服务二开都是公用的
/** * @author TAO * @description: Naocs数据同步Properties映射类 * @date 2021/5/1 22:36 */ @Component @ConfigurationProperties(prefix = "nacos.server") public class NacosConfigProperties { private String ip; private String port; private String namespace; private String groupId; public String getIp() { return ip; } public void setIp(String ip) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59871a23df46d2a6f4bea045d66052e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97cf0a852ba6c312ed9c99669474aaa1/" rel="bookmark">
			Hadoop技术介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 Hadoop是什么Hadoop发展历史Hadoop优势（4高）Hadoop 组成HDFS 架构概述YARN 架构概述MapReduce 架构概述 大数据技术生态体系 Hadoop是什么 1）Hadoop是一个由Apache基金会所开发的分布式系统基础架构。
2）主要解决，海量数据的存储和海量数据的分析计算问题。
3）广义上来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈
Hadoop发展历史 1）Hadoop创始人Doug Cutting，为了实现与Google类似的全文搜索功能，他在Lucene框架基础上进行优化升级，查询引擎和索引引擎。
2）2001年年底Lucene成为Apache基金会的一个子项目。
3）对于海量数据的场景，Lucene框 架面 对与Google同样的困难，存储海量数据困难，检索海量速度慢。
4）学习和模仿Google解决这些问题的办法 ：微型版Nutch。
5）可以说Google是Hadoop的思想之源（Google在大数据方面的三篇论文）
GFS ---&gt;HDFS Map-Reduce ---&gt;MR BigTable ---&gt;HBase Hadoop优势（4高） 1）高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元
素或存储出现故障，也不会导致数据的丢失。
2）高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。
3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处
理速度。
4）高容错性：能够自动将失败的任务重新分配。
Hadoop 组成 在 Hadoop1.x 时 代 ，Hadoop中 的MapReduce同时处理业务逻辑运算和资源的调度，耦合性较大。
在Hadoop2.x时 代，增加 了Yarn。Yarn只负责资 源 的 调 度 ，MapReduce 只负责运算。
Hadoop3.x在组成上没有变化。
HDFS 架构概述 Hadoop Distributed File System，简称 HDFS，是一个分布式文件系统。
1）NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。
2）DataNode(dn)：在本地文件系统存储文件块数据，以及块数据的校验和。
3）Secondary NameNode(2nn)：每隔一段时间对NameNode元数据备份。
YARN 架构概述 Yet Another Resource Negotiator 简称 YARN ，另一种资源协调者，是 Hadoop 的资源管理器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97cf0a852ba6c312ed9c99669474aaa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5553503d2802265861d5f6e91eae6a/" rel="bookmark">
			Ubuntu apt-get 删除安装失败的包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看有哪些安装失败的包
$ sudo dpkg --configure -a 删除安装失败的包 $ sudo dpkg --remove --force-remove-reinstreq package_name $ sudo apt-get update 删除软件包后，使用命令更新系统，成功更新后重新启动系统。
参考：https://ubuntuqa.com/article/10754.html
ubuntu针对包的常见操作：https://www.zybuluo.com/Perfect-Demo/note/1521398
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2716eebae4a6d3b8cc7ea3fa4241a68/" rel="bookmark">
			使用qt写一个软键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软键盘通过将多个ToolButton放在一个Widget当中，并将按钮提升为自定义类softKey继承于QToolButton类。
步骤：
1、为需要使用到软键盘的控件添加事件过滤器
//添加事件过滤器 ui-&gt;account_lineEdit-&gt;installEventFilter(this); ui-&gt;password_lineEdit-&gt;installEventFilter(this); //先隐藏软键盘 ui-&gt;widget-&gt;hide(); 2、重写eventFilter事件，判断当前触发对象是否是添加了过滤器的控件，且事件是否是鼠标按钮点击事件。是的话，显示软键盘，并将焦点设置到当前控件上。
bool MainWindow::eventFilter(QObject *obj,QEvent *event) { if(obj == ui-&gt;account_lineEdit &amp;&amp; event-&gt;type() == QEvent::MouseButtonPress) { ui-&gt;widget-&gt;show();	//显示软键盘 ui-&gt;account_lineEdit-&gt;setFocus();	//设置焦点 } else if(obj == ui-&gt;password_lineEdit &amp;&amp; event-&gt;type() == QEvent::MouseButtonPress) { ui-&gt;widget-&gt;show(); ui-&gt;password_lineEdit-&gt;setFocus(); } return QMainWindow::eventFilter(obj,event); } 3、若是当前控件编辑完毕则隐藏软键盘
//账号输入完毕 void MainWindow::on_account_lineEdit_editingFinished() { ui-&gt;widget-&gt;hide(); } //密码输入完毕 void MainWindow::on_password_lineEdit_editingFinished() { ui-&gt;widget-&gt;hide(); } 4、在自定义按钮类softKey的槽函数中判断当前点击的按钮文本，定义一个按键事件，通过postEvent将事件key发送出去
#include "softkey.h" softKey::softKey(QWidget *parent):QToolButton(parent) { //为按钮设置统一样式 QFile qssFile(":/qss/qss.qss"); if(qssFile.open(QIODevice::ReadOnly)) qApp-&gt;setStyleSheet(qssFile.readAll()); connect(this,SIGNAL(clicked(bool)),this,SLOT(echoClicked(bool))); } void softKey::echoClicked(bool) { if(this-&gt;text() == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2716eebae4a6d3b8cc7ea3fa4241a68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b7e340615ab7f536e5a43c107402368/" rel="bookmark">
			SparkSql如何拉取oracle数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先在你的pom中添加如下依赖
&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.3&lt;/version&gt; &lt;/dependency&gt; 之后准备sparksql容器对象
val spark = SparkSession .builder() .master("local[*]") .appName("ReadOracle") .config("spark.driver.cores","1") .getOrCreate() 拉取是调用read方法
val oracleDF = spark.read .format("jdbc") .option("url","jdbc:oracle:thin:@192.168.65.123:1521:数据库名字") .option("dbtable", "ds.task_db") .option("user", "root") .option("password", "root") .option("driver", "oracle.jdbc.driver.OracleDriver") .load(); 注意在拉取之后如果使用DF时报错无法装换DataSet，那就手动导入如下类
import org.apache.spark.sql.Dataset 或者全导进来 import org.apache.spark.sql._ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa70037619517812eac62bfc04a25205/" rel="bookmark">
			django-redis-sentinel 哨兵配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 django使用redis哨兵指南 哨兵作用：通过配置redis的哨兵机制，可以为用户提供一个可用的redis服务。
话不多说，直接怼！
pip install django-redis-sentinel 在django的settting中的配置
CACHES = { "default": { "BACKEND": "django_redis.cache.RedisCache", "LOCATION": "redis_master/10.2.158.41:26379,10.2.158.42:2639/0" "OPTIONS": { "PASSWORD": 's3cret_passw0rd!', "CLIENT_CLASS": "django_redis_sentinel.SentinelClient", } } } # "redis_master/10.2.158.41:26379,10.2.158.42:2639/0" # 注释： redis_master： 是redis哨兵配置中的名称 # 10.2.158.41:26379 哨兵的ip port # /0 0号库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb5e79e728ba672939b2cb1c3995d81/" rel="bookmark">
			MySQL 常见时间获取整理（当日、当月、当年、上一日、上一月、上一年，当月第一天，当年第一天等等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 常见时间获取整理（当日、当月、当年、上一日、上一月、上一年，当月第一天，当年第一天等等） 当前时间 SELECT now(); //当前时间，格式2020-09-02 16:00:02 SELECT curdate(); //当前日期，格式2020-09-02 SELECT date_format(now(),'%Y-%m-%d'); //当前日期，格式2020-09-02 当月
select date_add(curdate(),interval -day(curdate())+1 day) ; //当月第一天，例如2020-09-01 select date_sub(date_sub(date_format(now(),'%y-%m-%d'),interval extract(day from now())-1 day),interval 0 month); 当月第一天，格式2020-09-01 select last_day(curdate())；//当月最后一天，格式2020-09-30 select day(curdate()); //当月已过了几天，格式整数，例如2 select day(date_add( date_add(curdate(),interval 1 month),interval -day(curdate()) day )); //当前月天数(先加一个月，再减今天是第几天，得到当前月的最后一天，最后求最后一天是几号) 时间加减
select date_add(NOW(), interval 1 month); //下个月当前时间，格式2020-08-02 16:00:02 select date_sub(NOW(), interval 1 month); //上个月当前时间，格式2020-10-02 16:00:02 select date_add(curdate() - day(curdate()) +1,interval 1 month); //下个月的第一天，格式2020-10-01 select date_sub(curdate() - day(curdate()) +1,interval 1 month); //上个月的第一天，格式2020-08-01 select date_sub(date_sub(date_format(now(),'%y-%m-%d'),interval extract(day from now())-1 day),interval 1 month); //上个月的第一天，格式2020-10-01 select date_sub(date_sub(date_format(now(),'%y-%m-%d'),interval extract(day from now()) day),interval 0 month) as date; //上个月的最后一天，格式2020-10-01 select date_add(curdate(), interval 1 day)；//明日，格式2020-09-03 select date_sub(curdate(), interval 1 day)；//昨日，格式2020-09-01 当年
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceb5e79e728ba672939b2cb1c3995d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70cef8d269c6c266280c472b81e8de56/" rel="bookmark">
			FaceDemo 更改IP 流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FaceDemo 更改IP 流程 1. 打开文件2. 点击搜索3、查看设备IP4 查看是否符合我们需要更改的ip，并按下图提示修改IP按图片流程更改IP后的结果如下: 1. 打开文件 2. 点击搜索 3、查看设备IP 4 查看是否符合我们需要更改的ip，并按下图提示修改IP PS : 如何查看默认网关 ： 在控制台界面 输入 ipconfig
按图片流程更改IP后的结果如下: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e3a47cc1ef7dab1deb96570933d47b1/" rel="bookmark">
			linux怎么创建交换空间,如何在Linux下创建新的交换空间swap的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交换空间(Swap Space)，有时候也被称为虚拟内存，是硬盘中划出来的一段虚拟内存空间，用于扩展操作系统的物理内存。当系统的物理内存不够用的时候，操作系统把内存中最不常用的数据“交换”到交换空间，从而将物理内存中的一部分空间释放出来供其他程序使用。当程序需要用到交换空间内的数据的时候，操作系统再将数据从交换分区恢复到物理内存中。
Linux操作系统有两种实现交换空间的方法：交换分区(swap分区)和交换文件(swap文件)。
一.默认情况下，安装Linux的时候会自动创建交换分区。安装系统后也可以用手动方法创建交换分区：使用fdisk创建一个硬盘分区(假设为/dev/sdb1)，并设置类型为Linux swap (82)。
使用mkswap命令将/dev/sdb1格式化为swap格式：
mkswap /dev/sdb1
启用swap分区：swapon /dev/sdb1
注：可以使用free命令查看新加的交换分区。
如果需要在系统启动时自动加载此交换分区，别忘了在/etc/fstab里加入一行：/dev/sdb1 swap swap defaults 0 0
二.假如没有未分配的磁盘空间用于创建交换分区，你可能需要使用交换文件而不是交换分区来创建交换空间。
以下范例将为你演示如何使用交换文件(swap文件)创建交换空间(假设需要创建2G交换空间)：使用dd命令创建2G空白文件：dd if=/dev/zero of=/swapfile bs=1M count=2048
将文件转为swap格式：mkswap /swapfile
启用swap文件：swapon /swapfile
注：可以使用free命令查看新加的交换分区。
如果需要在系统启动时自动加载此交换分区，需要在/etc/fstab里加入一行：/swapfile swap swap defaults 0 0
(完)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66764b452c5df503d11a74624ca6327b/" rel="bookmark">
			学习笔记——pygame最常用的15个模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Color类 class pygame.Color
Pygame 中用于描述颜色的对象。Color(name) -&gt; Color Color(r, g, b, a) -&gt; Color Color(rgbvalue) -&gt; Color
方法 &amp; 属性
方法描述pygame.Color.r()获取或设置 Color 对象的红色值pygame.Color.g()获取或设置 Color 对象的绿色值pygame.Color.b()获取或设置 Color 对象的蓝色值pygame.Color.a()获取或设置 Color 对象的 alpha 值pygame.Color.cmy()获取或设置 Color 对象表示的 CMY 值pygame.Color.hsva()获取或设置 Color 对象表示的 HSVA 值pygame.Color.hsla()获取或设置 Color 对象表示的 HSLA 值pygame.Color.i1i2i3()获取或设置 Color 对象表示的 I1I2I3 值pygame.Color.normalize()返回 Color 对象的标准化 RGBA 值pygame.Color.correct_gamma()应用一定的伽马值调整 Color 对象pygame.Color.set_length()设置 Color 对象的长度（成员数量）pygame.Color.lerp()返回给定颜色的线性插值pygame.Color.premul_alpha()返回一个颜色，其中r,g,b组件已经乘以了alphapygame.Color.update()设置颜色的元素 （函数详解见官网：https://www.pygame.org/docs/）
Pygame 使用 Color 类表示 RGBA 颜色值，每个颜色值的取值范围是 0 ~ 255。允许通过基本的算术运算创造新的颜色值，支持转换为其他颜色空间，例如 HSV 或 HSL，并让你调整单个颜色通道。当没有给出 alpha 的值默认是 255（不透明）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66764b452c5df503d11a74624ca6327b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54b0f3d19ee08b097b4a5ff0148e358/" rel="bookmark">
			python数据可视化——画图基础1（figure 、坐标轴和图例设置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*由于最近跟着老师准备比赛，不得不提前学习数据分析和数据可视化，跟着B站大佬学习，在此总结一下。（内容有些粗糙，注释真的都是自己总结的大白话！） *
1.导入所需（不再重复导入）
import matplotlib.pyplot as plt import numpy as np 2.关于figure图像
#基本用法 x = np.linspace(-1,1,50)#从-1到1，分50份 y1 = 2 * x + 1 y2 = x**2 #figure图像 plt.figure() plt.plot(x,y1) plt.figure(num = 3,figsize = (8,5)) #参数num是figure的序号，figsize设置figure的长宽 plt.plot(x,y2) plt.plot(x,y1,color = 'purple',linewidth = 5.0,linestyle = '--') plt.show() 3.设置坐标轴1
x = np.linspace(-1,1,50) y1 = 2 * x + 1 y2 = x**2 plt.figure(num = 4) plt.plot(x,y2) plt.plot(x,y1,color = 'purple',linewidth = 1.0,linestyle = '--') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54b0f3d19ee08b097b4a5ff0148e358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f800dd67d01483883a32d6f223ff76b7/" rel="bookmark">
			Spring Boot优雅地处理404异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在使用SpringBoot的过程中，你肯定遇到过404错误。比如下面的代码：
@RestController @RequestMapping(value = "/hello") public class HelloWorldController { @RequestMapping("/test") public Object getObject1(HttpServletRequest request){ Response response = new Response(); response.success("请求成功..."); response.setResponseTime(); return response; } } 当我们使用错误的请求地址（POST http://127.0.0.1:8888/hello/test1?id=98）进行请求时，会报下面的错误：
{ "timestamp": "2020-11-19T08:30:48.844+0000", "status": 404, "error": "Not Found", "message": "No message available", "path": "/hello/test1" } 虽然上面的返回很清楚，但是我们的接口需要返回统一的格式，比如：
{ "rtnCode":"9999", "rtnMsg":"404 /hello/test1 Not Found" } 这时候你可能会想有Spring的统一异常处理，在Controller类上加@RestControllerAdvice注解。但是这种做法并不能统一处理404错误。
404错误产生的原因 产生404的原因是我们调了一个不存在的接口，但是为什么会返回下面的json报错呢？我们先从Spring的源代码分析下。
{ "timestamp": "2020-11-19T08:30:48.844+0000", "status": 404, "error": "Not Found", "message": "No message available", "path": "/hello/test1" } 为了代码简单起见，这边直接从DispatcherServlet的doDispatch方法开始分析。（如果不知道为什么要从这边开始，你还要熟悉下SpringMVC的源代码）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f800dd67d01483883a32d6f223ff76b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757f1b71e9cf4386cb0360731575f4ed/" rel="bookmark">
			卡巴斯基免费版安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡巴斯基免费版安装教程（如需免费版安装包请点击此处） 1、下载解压后即可获得软件安装包
2、进入软件安装界面，如图
3、点击安装
4、安装过程中，请耐心等候
5、如图，点击应用
6、点击完成
7、将小编给大家提供的序列码拷贝到软件界面中即可
8、安装成功
9、打开软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dea23d7862d97a3490e6200b509dc3d/" rel="bookmark">
			Jenkins 2.3：Jenkins 从 Gitlab 拉取代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.3：Jenkins 从 Gitlab 拉取代码 配置Jenkins能基于SSH的方式从Gitlab拉取指定的代码。具体实现方式是：
创建Jenkins服务器的SSH密钥对；为相应的Gitlab用户添加密钥对的公钥，相当于Jenkins拉取代码时，使用的是该Gitlab用户，拥有其相应的代码克隆权限；Jenkins添加密钥对的私钥，实现基于key的连接；将Gitlab项目的SSH克隆地址配置到相应的Jenkins任务中，在构建时将代码拉取到Jenkins服务器的相应目录，为接下来的测试、部署等操作做好准备。 2.3.1：Jenkins 服务器创建密钥对 root@jenkins:~# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:vEteNdz+UG6ovGyWMUjLUUSgMh/i0rScRlfa727ZGvc root@jenkins.yqc.com The key's randomart image is: +---[RSA 2048]----+ | o+o | | = .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dea23d7862d97a3490e6200b509dc3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4d5e9e952ed330462a78bddd7d621c/" rel="bookmark">
			嵌入式linux docker,嵌入式移植docker报错问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过了漫长时间的移植和查询资料，得以解决一下嵌入式docker出现的问题，很多网上的资料全都是复制粘贴复制粘贴，找不到合适的解决方法让人很是苦恼，希望自己总结出的一些解决问题的经验给广大朋友减少一些负担吧！
1.standard文件找不到：
解决方法：
tar zcvf xtables /usr/lib64/xtables
cp xtables.tar /work/initramfs/
需要到同内核同系统的另一台服务器打包在解压
2.需要iptables支持才能启动docker，移植iptables在启动docker错误：
解决方法：
docker --iptables=false
nohup docker --iptables=false &gt;/1.txt 2&gt;&amp;1 &amp;(后台启动)
3.缺少nat防火墙的网络连接模块：
解决方法：
modprobe iptable_nat
4.进入docker镜像出现问题，缺少veth模块，直接加载
解决方法：
modprobe veth
5.进入docker镜像文件系统不符合，pivot root invalid argumen
解决方法：
cat &gt;/etc/systemd/system/docker.service.d/10-ramdisk.conf &lt;
&gt; [Service]
&gt; Environment=DOCKER_RAMDISK=true
&gt; EOF
export DOCKER_RAMDISK=true
在kill掉用刚才方法启动的docker，重启就OK了
补充两点有的做完以上步骤，移植的docker就可以使用了，但是偶尔会出现以下的一种问题。
出现缺少的DNS的文件内容，把任何一台的resolv.conf 文件传过去就OK了。
附一张移植后加载的模块驱动：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d409172a12ed194b8f76a89e9712426/" rel="bookmark">
			QT QTimer定时器的暂停，开启和重新启动问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：QTimer定时器在工作中执行stop(); 函数后，再start();其结果 回答：
QT在Linux版本中，再次start(),QTimer定时器会保持之前的计时记录，并在之前的样态上继续工作，这一点可以验证。
也就是说，QTimer定时器start();之后，并不会重新计时。。。。 问题:QTimer定时器，若是需要重新启动，该如何处理 回答：
处理的方案一：
通过函数killTimer(int QTimer_id); 函数把现在停止的QTimer定时器释放掉，然后重新创建定时器，达到重新启动的目的。 QTimer *Ptimer = new QTimer; int Timer_id = Ptimer-&gt;start(1000); /*定时器的id是通过start()函数返回*/ 以上是创建部分，下面的代码是QTimer定时器需要释放时的删除函数。
... killTimer(Timer_id); ... 回答：
处理的方案二：
通过QTimer::setInterval(msec);函数，对暂停的定时器，重新填装定时器触发值。重新填装的定时器，再通过start()后，QTimer定时器便重新启动计时。 QTimer *Ptimer = new QTimer; int Timer_id = Ptimer-&gt;start(1000); /*定时器的id是通过start()函数返回*/ 以上是创建部分，下面的代码是QTimer定时器使用重新填装函数进行重新启动。
... Ptimer-&gt;setInterval(1000); Ptimer-&gt;start(); ... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b3f754e2273f8b9182566da8bafa5f/" rel="bookmark">
			mac系统通过ADB与scrcpy实现手机投屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、安装ABD和scrcpy
2、手机端配置
3、有线投屏
4、无线投屏
5、scrcpy常用快捷键
1、安装ABD和scrcpy # 安装ADB brew cask install android-platform-tools # 安装scrcpy brew install scrcpy 2、手机端配置 手机端在“开发者选项”里打开USB调试，具体方法为：
1、设置 --&gt; 关于手机 --&gt; 连续点击版本号5次左右开启“开发者选项”
2、在设置 --&gt; 系统和更新 --&gt; 开发人员选项 --&gt; USB调试打开
3、如果手机开发者选项里面有ADB相关的配置，也要看情况点击。以华为手机为例：在第2步骤之后还要打开“‘仅充电’模式下允许ADB调试”
3、有线投屏 手机通过数据线连接电脑，在控制台输入“adb devices”即可查看连接的安卓设备
# 查看adb连接的设备 adb devices # 使用scrcpy打开手机投屏 scrcpy -m 1024 4、无线投屏 保证电脑和手机在同一网段之下，同时必须先进行有线连接之后才可以无线连接
1、查看手机IP地址
方法一：手机设置 --&gt; 关于手机 --&gt; 状态消息 --&gt; IP地址 方法二：通过“adb shell netcfg”命名查看IP地址
2、通过网络IP实现adb连接，再次查看adb连接的设备，发现就会出现一个网络连接的设备
# 查看adb连接的设备 adb devices # adb设置手机打开tcpip监听端口 adb tcpip 5555 # abd通过手机的网络地址连接手机,输入自己手机的网络地址 adb connect 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b3f754e2273f8b9182566da8bafa5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb570e2e376f99261d791d291a35bc0d/" rel="bookmark">
			软考级别介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：由科科过来介绍下软考从等级、考试、证书价值等详细介绍。
一、软考介绍
计算机技术与软件专业技术资格（水平）考试（以下简称计算机软件资格考试）是原中国计算机软件专业技术资格和水平考试（简称软件考试）的完善与发展。计算机软件资格考试是由国家人力资源和社会保障部、工业和信息化部领导下的国家级考试，其目的是科学、公正地对全国计算机与软件专业技术人员进行职业资格、专业技术资格认定和专业技术水平测试。工业和信息化部教育与考试中心负责全国考务管理工作，除台湾地区外，计算机软件资格考试在全国各省、自治区、直辖市及计划单列市和新疆生产建设兵团，以及香港特别行政区和澳门特别行政区，都建立了考试管理机构，负责本区域考试的组织实施工作。
二、软考等级介绍
计算机软件资格考试设置了27个专业资格，涵盖5个专业领域， 3个级别层次（初级、中级、高级）。计算机软件资格考试在全国范围内已经实施了二十多年，近十年来,考试规模持续增长，截止目前,累计报考人数约有五百万人（来源：中国计算机技术职业资格网 2015-10-28 ）。该考试由于其权威性和严肃性，得到了社会各界及用人单位的广泛认同，并为推动国家信息产业发展，特别是在软件和服务产业的发展,以及提高各类信息技术人才的素质和能力中发挥了重要作用。
三、软考报考条件 软考27类考试，计算机软件资格考试既是职业资格考试，又是职称资格考试。同时，该考试还具有水平考试性质，报考任何级别不需要学历、资历条件，只要达到相应的专业技术水平就可以报考相应的级别。
通俗来讲：报考无年龄、学历、职业要求；符合国家合法公民即可参加考试。
四、软考考试时间
每年考试两次分别是5月和11月；报考时间大概每年3月和8月份；
五、软考考试题型及时间：
如系统集成项目管理工程师和信息系统项目管理师
五、证书样本
软考类证书封面
软考类证书
六、软考证书注意事项：
1、软考类若考两科或三科，需要同时过，一科不过，需要重新报考考试；
2、软考类证书无需继续教育（一次拿证，终生受益）；
3、目前软考类证书不仅能凭职称、入专家库还可以做入户用（如广东省）；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c7f1a44ce6b0920ed85e651947a573/" rel="bookmark">
			Prompt命令行窗口无法用鼠标选中窗口界面内的文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于cmd,anaconda prompt 命令行窗口无法用鼠标选中窗口界面内的文字
在Prompt窗口顶端,右键,选择属性
选中快速编辑模式即可.
最好也把复制粘贴快捷键选上
命令行窗口,选中文字后,鼠标右键点击一下即复制了,再点击一下即可粘贴
彩蛋 附带一条小技巧,F11可以全屏幕显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166e7ec53e5ad8ddea40bf1f15a4067c/" rel="bookmark">
			1小时1篇文学会python再做个飞机大战游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：
想慢慢学习的同学可以看我的 《python 入门到游戏实战专栏》（更新中）
想学 C 的同学可以看《大话系列之C语言》（基本更新完）
想学 C++ 的同学可以看《大话C++》（更新中）
想做习题的可以看《大学生C语言作业、习题100例白话详解》
作者简介 作者名：1_bit
简介：CSDN博客专家，2020年博客之星TOP5，蓝桥签约作者。15-16年曾在网上直播，带领一批程序小白走上程序员之路。欢迎各位小白加我咨询我相关信息，迷茫的你会找到答案。系列教程将会在流量降低时转为付费位置，流量多时将不会，各位抓紧时间学习哟~
学习开始 👸小媛：小 C，我想学做游戏了，有什么速成的办法吗？ 😰
🐰小C：没有，谢谢。
👸小媛：我看他们都可以，直接做一个飞机大战，说是一下子就学会了。 😨
🐰小C：你是想先大概过一遍内容吗？还是具体的全面的学？
👸小媛：我想先有一点体验感，自己学的舒服玩一下也行。
🐰小C：那就可以，1小时搞定。
👸小媛：这么快？那刚刚你又说不行。 😣
🐰小C：你不是全面学，只学基础核心就没啥问题。一个小时搞定还是可以做点东西的。
👸小媛：那就赶紧开始吧。
🐰小C：那我们就学 python 吧，你觉得怎么样？
👸小媛：可以呀，做出来游戏就可以了。
🐰小C：你电脑我记得有环境和编辑器，我们就用原本的就好了。
👸小媛：原本的是啥？
🐰小C：那个 vscode，我们用的库是 pygame。
👸小媛：唔，懂了。
01 hello world 🐰小C：那我们就从头开始学吧，首先打开我们的 vscode 创建一个文件叫做 game.py 进行代码的测试吧。
👸小媛：了解，我已经新建好了。
🐰小C：那我们首先写一个 hello world 吧。
👸小媛：hello world 是什么？ 😰
🐰小C：是一个经典的计算机程序，就是程序运行的时候会显示 hello world。
👸小媛：懂了，那怎么做呢？
🐰小C：首先你要知道，编程其实就是使用不同的“魔法指令”在计算机中创造不同的东西，python 用来显示内容的指令就是 print()，你用 print() 要显示什么字符串就在里面加上去就可以了。
👸小媛：这样吗？
print(helloworld) 🐰小C：在这里需要跟你提一点，在 python 中字符串是需要使用双引号引起来的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166e7ec53e5ad8ddea40bf1f15a4067c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea38ba40883a657b55223f9593f048df/" rel="bookmark">
			Java BlockingQueue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html，机翻加人工校正，仅供学习交流。
Java BlockingQueue接口 Java BlockingQueue接口表示一个线程安全的队列，可以将元素放入，也可以取出。换句话说，多个线程可以同时从Java Bloc中插入和获取元素，不会有任何并发性问题。
阻塞队列这个术语就来自于Java BlockingQueue 接口能够阻塞试图在队列插入或获取元素的线程。如果一个线程尝试获取一个元素，而队列中没有剩余的，线程将被阻塞，直到有一个元素可以获取。调用线程是否被阻塞取决于你在BlockingQueue上调用什么方法。稍后将更详细地解释不同的方法。
本文将不讨论如何自己在Java中实现一个BlockingQueue。如果你对此感兴趣，我在更理论化的Java并发教程中有一篇关于阻塞队列的文章。
BlockingQueue实现类 因为BlockingQueue是一个接口，所以您需要使用它的一个实现来使用它。concurrent包有以下BlockingQueue接口的实现:
ArrayBlockingQueue
DelayQueue
LinkedBlockingQueue
LinkedBlockingDeque
LinkedTransferQueue
PriorityBlockingQueue
SynchronousQueue
点击列表中的链接，阅读关于每个实现的更多信息。
BlockingQueue用法 BlockingQueue通常用于让一个线程产生对象，另一个线程使用它。下面的图表说明了这一原理:
生产线程将继续产生新的对象，并将它们插入到BlockingQueue中，直到队列达到它所能包含内容的某个上限，换句话说，这是极限。当阻塞队列达到其上限，生产线程在试图插入新对象时被阻塞。它将一直处于阻塞状态，直到一个正在使用的线程将一个对象从队列中取出。
消费线程不断地从BlockingQueue中取出对象来处理它们，如果使用线程试图从空队列中取出一个对象，消费线程被阻塞，直到生产线程将对象放入队列。
BlockingQueue方法 Java BlockingQueue接口有4组不同的方法，用于插入、删除和检查队列中的元素。当请求的操作不能及时执行时，每一组方法的操作都不同。下面是一个方法表:
这4种不同的行为意味着:
Throws Exception:如果尝试的操作不能立即执行，则抛出异常。Special Value: 如果尝试的操作不能立即执行，则返回一个特殊值(通常为true / false)。Blocks: 如果尝试的操作不能立即执行，方法调用将阻塞，直到它能够执行为止。Times Out: 如果尝试的操作不能立即执行，方法调用会阻塞，但是等待的时间不会超过给定的超时时间。返回一个特殊值，告知操作是否成功(通常为true / false)。
不可能将null值插入到BlockingQueue中，如果您试图插入null, BlockingQueue将抛出一个NullPointerException。
你可以访问BlockingQueue中的所有元素，而不仅仅是开始和结束的元素。假设您已经将一个对象排队等待处理，但是你的程序决定取消它。然后你可以调用remove(o)来移除队列中的特定对象。然而，这并不是很有效，所以除非必要，否则不应该使用这些Collection方法。 Java BlockingQueue例子 下面是一个Java BlockingQueue示例。这个例子使用了BlockingQueue接口的ArrayBlockingQueue实现。
首先是BlockingQueueExample类，它在单独的线程中启动Producer和Consumer。生产者将字符串插入到共享的BlockingQueue中，而消费者将它们取出。
public class BlockingQueueExample { public static void main(String[] args) throws Exception { BlockingQueue queue = new ArrayBlockingQueue(1024); Producer producer = new Producer(queue); Consumer consumer = new Consumer(queue); new Thread(producer).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea38ba40883a657b55223f9593f048df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edefd6d9073d165364ee5272294881bf/" rel="bookmark">
			2021年Android面试题知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年Android面试题知识点 1.前言2.知识点2.1、Activity和Fragment生命周期相关2.2、android中进程的优先级问题2.3、Bunder传递对象为什么需要序列化？Serialzable和Parcelable有什么区别？2.4、Android动画相关2.5、Context相关2.6、Android各版本新特性2.7、Asset目录与res目录的区别？2.8、Handler机制2.9、OOM 是否可以try catch2.10、activty和Fragmengt之间怎么通信？Fragmengt和Fragmengt怎么通信？2.11、服务启动一般有几种，服务和activty之间怎么通信，服务和服务之间怎么通信？2.12、广播注册一般有几种，各有什么优缺点？ 3.最后 1.前言 每年找工作的Android开发者都有不少人，想要找到一份更好的工作，不仅需要一份好的简历，更重要的是要熟练Android的每一个技术点、知识点。但是对于一部分开发来说，可能平常用到的东西不太会表达，这就有点吃亏了。本篇博客是关于Android面试题一部分的总结，希望能够帮到你。 2.知识点 2.1、Activity和Fragment生命周期相关 2.2、android中进程的优先级问题 前台进程：
即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最晚被杀死的。
可见进程：
可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失了焦点而不能与用户交互。
服务进程：
其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面下载的文件等；当系统要空间运行，前两者进程才会被终止。
后台进程：
其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这时的进程系统一旦没了有内存就首先被杀死。
空进程：
不包含任何应用程序的进程，这样的进程系统是一般不会让他存在的。
2.3、Bunder传递对象为什么需要序列化？Serialzable和Parcelable有什么区别？ 因为bundle传递数据时只支持基本数据类型，所以在传递对象时需要序列化转换成可存储或可传输的本质状态（字节流）。序列化后的对象可以在网络、IPC（比如启动另一个进程的Activity、Service和Reciver）之间进行传输，也可以存储到本地。
Serializable（Java自带）：
Serializable 是序列化的意思，表示将一个对象转换成存储或可传输的状态。序列化后的对象可以在网络上进传输，也可以存储到本地。
Parcelable（android专用）：
除了Serializable之外，使用Parcelable也可以实现相同的效果，不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这也就实现传递对象的功能了。
区别总结如下图所示：
2.4、Android动画相关 View 动画
作用对象是 View，可用 xml 定义，建议 xml 实现比较易读支持四种效果：平移、缩放、旋转、透明度 帧动画
通过 AnimationDrawable 实现，容易 OOM 属性动画
可作用于任何对象，可用 xml 定义，Android 3 引入，建议代码实现比较灵活包括 ObjectAnimator、ValuetAnimator、AnimatorSet时间插值器：根据时间流逝的百分比计算当前属性改变的百分比，系统预置匀速、加速、减速等插值器类型估值器：根据当前属性改变的百分比计算改变后的属性值，系统预置整型、浮点、色值等类型估值器使用注意事项：避免使用帧动画，容易OOM；界面销毁时停止动画，避免内存泄漏；开启硬件加速，提高动画流畅性硬件加速原理：将 cpu 一部分工作分担给 gpu ，使用 gpu 完成绘制工作；从工作分摊和绘制机制两个方面优化了绘制速度 tween 补间动画
通过指定View的初末状态和变化方式，对View的内容完成一系列的图形变换来实现动画效果。 Alpha, Scale ,Translate, Rotate。 属性动画有两个步聚：
1.计算属性值
2.为目标对象的属性设置属性值，即应用和刷新动画
计算属性分为3个过程：
过程一：
计算已完成动画分数 elapsed fraction。为了执行一个动画，你需要创建一个ValueAnimator，并且指定目标对象属性的开始、结束和持续时间。在调用 start 后的整个动画过程中，ValueAnimator 会根据已经完成的动画时间计算得到一个0 到 1 之间的分数，代表该动画的已完成动画百分比。0表示 0%，1 表示 100%。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edefd6d9073d165364ee5272294881bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4688f37e4fdf45f3eeb0590c57f410d/" rel="bookmark">
			如何在Mac上升级iCloud存储计划？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论您使用的是 iPhone、iPad、Mac 还是 PC，升级 iCloud 储存空间都非常简单。每个Apple帐户都具有5 GB的免费iCloud存储空间，那我们如何在Mac上升级iCloud存储计划呢？只需完成几个简单的步骤，即可购买更多储存空间。需要的朋友快和小编一起来看看吧！
具体方法如下
1.从Apple菜单中选择“系统偏好设置”。
2.在Mac上打开“系统偏好设置”，确保您已登录到Apple帐户。如果没有，您可以选择在此处登录。单击右上角的“ Apple ID”选项，如下所示。
3.接下来，转到左侧窗格中的“ iCloud”部分，并单击iCloud窗口右下角的管理。
4.在这里，左上角可以看到现在剩余的iCloud容量情况，点击“购买更多存储空间”以升级您的计划。
5.现在，您可以根据自己的喜好选择三个付费计划中的任何一个。单击“下一步”进行最后一步。
6.输入您的Apple ID密码，然后单击“购买”以确认并完成购买。
7.购买成功后，点击完成返回iCloud管理界面，可以看到左上角的容量情况发生了变化，那么你的iCloud扩容了。
以上就是在Mac上升级iCloud存储空间的方法，希望对大家有所帮助，想了解更多关于Mac相关教程，请关注macz.com吧!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342a8d8764bda818f92a6ad8673b9e1a/" rel="bookmark">
			Kubernetes源码学习-Kubelet-P1-启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在大致分析过k8s的Scheduler、Controller、APIServer三个控制平面组件后，本篇开始进入数据交互平面的daemon组件kubelet部分，看看kubelet是如何在控制平面和数据平面中以承上启下的模式工作的。
启动流程 启动入口照旧，位于项目的cmd路径下，使用cobra做cmd封装：
cmd/kubelet/kubelet.go:39
func main() { rand.Seed(time.Now().UnixNano()) command := app.NewKubeletCommand(server.SetupSignalHandler()) logs.InitLogs() defer logs.FlushLogs() if err := command.Execute(); err != nil { fmt.Fprintf(os.Stderr, "%v\n", err) os.Exit(1) } } cmd/kubelet/app/server.go:112
NewKubeletFlags和NewKubeletConfiguration方法会初始化kubelet的很多默认flag和参数，来分别看下：
cmd/kubelet/app/options/options.go:214
func NewKubeletFlags() *KubeletFlags { remoteRuntimeEndpoint := "" if runtime.GOOS == "linux" { remoteRuntimeEndpoint = "unix:///var/run/dockershim.sock" } else if runtime.GOOS == "windows" { remoteRuntimeEndpoint = "npipe:./pipe/dockershim" } return &amp;KubeletFlags{ EnableServer: true, // 容器运行时这个参数需要留意下 ContainerRuntimeOptions: *NewContainerRuntimeOptions(), CertDirectory: "/var/lib/kubelet/pki", RootDirectory: defaultRootDir, MasterServiceNamespace: metav1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/342a8d8764bda818f92a6ad8673b9e1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef01830f83400a5002698d893b6f9c50/" rel="bookmark">
			手把手教你用Java实现一套简单的鉴权服务（SpringBoot，SSM）（万字长文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、何为鉴权服务二、利用servlet+jdbc实现简单的用户登录程序1.明确思路2.手把手教你实现一个简单的web登录程序①创建web项目②编写简单的登录页面③编写servlet程序④封装jdbc操作，编写简单的数据库连接池⑤操作数据库⑥配置web.xml⑦idea运行配置⑧运行程序 三、回顾1.密码未加密裸奔2.登录信息未存储3.对于其他资源并未进行权限管理 四、优化设计1.密码加密存储2.存储登录信息3.对资源进行管理 五、关于鉴权问题1.Cookie/Session机制2.用Cookie/Session解决鉴权问题？Cookie/Session机制的缺点1.无法解决跨域问题2.session机制依赖于cookie3.可拓展性不强4.服务器压力增大5.安全性问题 3.使用token机制解决鉴权问题 六、用SpringBoot+SSM实现一套简单的鉴权服务（注册，登录，权限控制）1.注册服务①注册页面②发送验证码sendcode接口邮件发送方法（调用SpringBoot提供的mail服务（需要导包））验证码对象验证码池 ③注册用户MD5加密类注册用户接口检验验证码方法 2.登录服务登录界面登录接口认证方法登录方式enum类登录方式类认证令牌类认证令牌池 3.权限控制（拦截器）拦截器UserInterceptorMVC配置类 七、效果展示1.注册2.登录3.访问其他资源 写在最后 前言 时遇JavaEE作业，题目要求写个简单web登录程序，按照老师的意思是用servlet、jsp和jdbc完成。本着要么不做，要做就要做好的原则，我开始着手完成此次作业（其实也是写实训作业的用户鉴权部分），而之前写项目的时候也有相关经验，这次正好能派上用场。
一、何为鉴权服务 引用百度百科的话说
鉴权（authentication）是指验证用户是否拥有访问系统的权利。
鉴权包括两个方面：
用户鉴权，网络对用户进行鉴权，防止非法用户占用网络资源。网络鉴权，用户对网络进行鉴权，防止用户接入了非法的网络，被骗取关键信息。 而我们这里的鉴权主要指用户鉴权，即如何确认“你是你”。最简单的体现便是平常用的用户登录登出。
现今大部分系统都会有自己的鉴权服务，它是用户与系统交互的第一步，系统需要一系列步骤明白你是谁，你可以做哪些事，明白了这些之后它才能更好的服务于你。
二、利用servlet+jdbc实现简单的用户登录程序 1.明确思路 首先，我们要仔细思考一下我们到底需要什么？
先让我们回想一下一般的登录是如何做的呢？
对于网页，首先会出现一个登录页面，然后呢，输入账号密码，点击登录，就会弹出成功/失败的页面。
那如何去判断成功/失败呢？
思考一下，最简单的方法便是拿到前端传来的数据之后便将其拿到数据中去查，看看密码是不是一样，然后给前端回复说——我找到了，他就是XXX或者我找不到他的记录，让他重新输入账号密码。
然后前端对此回复做出相应的操作，比如登录成功便跳转到首页，失败让用户重新输入。
2.手把手教你实现一个简单的web登录程序 出于某些原因，我这里手把手教你如何实现一个简单的web登录程序。
①创建web项目 打开idea，新建一个web项目
这里为了方便jar包的管理，选择maven结构的项目（至于什么是maven结构，不懂的可以百度，了解概念即可），然后选择从原型创建，选择webapp（这里只是方便，你也可以选择空项目，不过会费点时间）。
点击下一步，输入项目名称
这里选择相应的maven，idea里有自带的maven和jar包仓库，不过我是自己去官网下了一个（不下也完全可以）。
选择完成，这样一个最简单的项目结构就出来了。
接下来需要配置一下pom.xml，因为要用到jdbc和tomcat的jar包（毕竟都是调用人家的接口（笑哭））
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;9.0.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; （加在project标签里就行），上面配置的意思就是导入两个第三方工具包
②编写简单的登录页面 这里我既想要好看，又想偷懒，所以用了layui框架的模板
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;后台管理-登陆&lt;/title&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta http-equiv="Access-Control-Allow-Origin" content="*"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef01830f83400a5002698d893b6f9c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea13c3bf3d750197f7f6ed0f84740b3b/" rel="bookmark">
			关于Spring项目中路径前加/和不加/的区别！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误 在springmvc中提交数据时，请求url中部分数据会出现两次。例如原本请求url是http://localhost:8080/user/Login，但请求时就变成了http://localhost:8080/user/user/Login,导致找不到路径。 分析 &lt;form action="/user/login"&gt; 用户名：&lt;input type="text" name="username"&gt; &lt;br&gt; 密码： &lt;input type="password" name="pwd"&gt; &lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; 这与当前的路径有关。加/代表绝对路径，从站点根目录开始找/user/login不加/代表相对路径，是从当前路径开始找user/login因此会导致出现两次user,从而请求url不正确。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d99837f475d013a49481252460159e3c/" rel="bookmark">
			图解排序算法(三)之折半插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		折半插入排序利用二分法的思想，在一个有序的序列中，找到新元素在该序列中的位置，然后插入。如图1所示，共有n个元素，前i个元素已经是有序序列，现在要将第i个元素插入其中。折半插入排序需要做两步工作：找到待插入元素的位置、插入。
图1 插入排序示意图
首先要定义两个指针(不是语法里面的指针，是下标的意思)low和high用于寻找a[i]的插入位置，low指向a[0]，high指向a[i-1]，中点mid=(low+high)/2，
图2 “折半”示意图
如图2所示二分法的思想是，比较a[i]与a[mid]的大小，若a[i]&gt;a[mid]，说明a[i]的位置应该在mid~high之间，将区间[low,high]缩短为[mid+1,high]，令指针low=mid+1；若a[i]&lt;=a[mid]，说明a[i]的位置应该在low~mid之间，将区间压缩为[low,mid-1]，令指针high=mid-1。每次折半之后，a[i]的位置应该在[low,high]之间。
如此循环，low与high渐渐靠近，直到low&gt;high跳出循环，a[i]的位置找到，low即为a[i]应该放置的位置。
找到a[i]的位置之后进行插入，先将a[low]~a[i-1]这些元素向后平移一个元素的位置，然后将a[i]放到low位置。
代码实现
#include &lt;iostream&gt; using namespace std; void BinSort(int *a,int n) //对int数组进行从小到大的排序 { for(int i=1;i&lt;n;i++) //开始 以a[0]作为有序序列，从a[1]开始找到当前元素a[i]应该放置的位置 { int low=0,high = i-1,mid;//每次寻找a[i]的位置，都要更新这些数据 while(low&lt;=high) //二分思想循环寻找a[i]的位置 { mid = (low+high) / 2; if(a[i]&lt;=a[mid]) high = mid - 1; //high指针减小 else low = mid + 1; //low指针增加 } //循环结束，low就是a[i]应该放置的位置 int temp = a[i]; for(int j=i;j&gt;low;j--) //将元素向后平移 a[j] = a[j-1]; a[low] = temp; //将元素temp = a[i] 放置到low位置 } } int main() //举例说明 { int n = 10; int a[10] = {5,8,9,4,7,5,6,3,1,11}; BinSort(a,n); for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d99837f475d013a49481252460159e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a138ef9f87b595cb475bf8d66e80cb/" rel="bookmark">
			数据库-实验八 综合实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、实验目的与要求：二、实验内容：1.在订单详情表orderitems插入新订单时自动获得水果数量，如果水果数量小于插入的新订单的水果数量，则插入失败。2.统计每个月份销量最高的三个水果，方便下次进货的时候多进货。3.随着用户消费增多，修改VIP等级 三 、实验小结 一、实验目的与要求： 利用本学期所学知识，综合运用
二、实验内容： 1.在订单详情表orderitems插入新订单时自动获得水果数量，如果水果数量小于插入的新订单的水果数量，则插入失败。 源码:
CREATE TRIGGER or_insert before INSERT on orderitems FOR EACH ROW BEGIN DECLARE qquantity int; SELECT quantity INTO qquantity FROM fruits where fruits.f_id=new.f_id; IF qquantity&lt;new.quantity THEN signal sqlstate 'HY000' set message_text = '水果数量不足'; end IF; END 测试截图:
2.统计每个月份销量最高的三个水果，方便下次进货的时候多进货。 源码:
SELECT* FROM ( select f_id,sum(quantity) from orderitems group by f_id ORDER BY sum(quantity) DESC)s LIMIT 3 测试效果截图:
3.随着用户消费增多，修改VIP等级 源码:
CREATE TRIGGER up_VIP AFTER UPDATE on orders FOR EACH ROW BEGIN DECLARE s_pay DECIMAL(10,2); SELECT SUM(original_price) INTO s_pay FROM orders WHERE orders.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a138ef9f87b595cb475bf8d66e80cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbbc5487e908fcfb53d2e59991438abd/" rel="bookmark">
			java 获取当前时间并转化为yyyy-MM-dd HH:mm:ss格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一(线程不安全, 不建议使用)
private SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//设置日期格式 Date now = new Date(); String time = sdf.format(now); 方法二(线程安全,建议使用)
import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; public class testMain { public static void main(String[] args) { // yyyy-MM-dd HH:mm:ss.SSS ---&gt; 年-月-日 时-分-秒-毫秒 （想删掉哪个小部分就直接删掉哪个小部分） String timeStr1=LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")); String timeStr2=LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")); System.out.println("当前时间为:"+timeStr1); System.out.println("当前时间为:"+timeStr2); } } 运行结果：
当前时间为:2018-11-27 10:41:47
当前时间为:2018-11-27 10:41:47.392
时间转时间戳：
/* * 将时间转换为时间戳 */ public static String dateToStamp(String s) throws ParseException{ String res; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbbc5487e908fcfb53d2e59991438abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77597e03de3258efbff17ced4f0bd421/" rel="bookmark">
			数据库实验六综合实验-水果商店进阶一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、实验目的与要求：二、实验内容1. 修正订单详情表orderitems中的水果价格与水果表fruits中的价格一致。2. 在订单详情表orderitems插入新订单时自动获得水果价格。3. 在总的订单表orders中新增“原价格”、“折扣”“应付款”三个属性，三个属性要求如下： 三、实验小结 一、实验目的与要求： 综合运用SQL语言相关知识如变量、游标、函数、触发器等解决实际问题。
二、实验内容 设计并完成以下实验，要求附上源码（非截图），测试效果截图
1. 修正订单详情表orderitems中的水果价格与水果表fruits中的价格一致。 源码：
CREATE PROCEDURE Update_price() BEGIN declare ff_price decimal(8,2); declare ff_id CHAR(10); DECLARE done TINYINT DEFAULT 0; DECLARE Update_price CURSOR for SELECT f_price,f_id from fruits; DECLARE CONTINUE HANDLER FOR NOT found set done=1; OPEN Update_price; read_cur:LOOP FETCH Update_price into ff_price,ff_id; IF done THEN leave read_cur; END IF; UPDATE orderitems set item_price=ff_price where orderitems.f_id=ff_id; END loop read_cur; CLOSE Update_price; END 运行测试结果截图:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77597e03de3258efbff17ced4f0bd421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36266221014428ba8fbaaba17bf6a615/" rel="bookmark">
			两周搞定计算机专业毕业设计，附源码&#43;论文&#43;答辩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毕设+论文+答辩通关法则，看这一篇，源码都在下面了！写在前面，尽管论文方法和毕设源码都有，但还是要看课+自己敲完完善好。做好充分准备面对答辩。
文章目录 一、毕设二、论文2.1 论文标题2.2 确定论文大纲2.3 论文内容2.3.1 文科找文献：2.3.2 论文摘要2.3.3 绪论2.3.4 论文内容 2.4 论文查重 三、答辩3.1 论文答辩前的准备3.2 论文答辩现场对弈 一、毕设 毕设直通车《黑马智慧物业毕业设计》
【毕设项目】01网上购物商城(前端+后端+云部署)
【毕设项目】02网上购物商城(前端+后端+云部署)
【毕设项目】03网上购物商城(前端+后端+云部署）
【毕设项目】04网上购物商城(前端+后端+云部署）
【毕设项目】05网上购物商城(前端+后端+云部署）
课程如上，源码找我！
二、论文 2.1 论文标题 选题：导师给出list选
根据自己的专业和兴趣选题：脑图法则+排除法
**标题要求：**见名知意 精炼
模板法则 : 前缀+中缀+后缀
前缀：增加论文含金量，非必须 基于xx [ 技术名（web/小程序/H5/flink/SSH）/分布式/微服务/分布式缓存 ]
中缀：项目名，必须 项目名(xx积分商城/xx商业BI/社区xx服务/进销存/教务管理/物业管理/车辆计费/)
后缀：必须 设计与实现 / 策略与研究
如下：
基于Web的 + 实训教学管理系统 + 的设计与实现 基于MySQL的 + 分布式SQL数据库 + 的设计与实现 基于B_S + 中小型超市进销存管理系统 + 的设计与实现 车联网大数据处理系统 + 的设计与实现 积分商城 + 的设计与实现 小结一下：可以使用模板法则：前缀+中缀+后缀，如：基于Web的+实训教学管理系统+的设计与实现；
范围不用很大–&gt;人类文明的研究–&gt;公元前1000年的人类文明研究；
2.2 确定论文大纲 论文大纲的结构比较固定：工具法则。学习前人经验多总结；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36266221014428ba8fbaaba17bf6a615/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4fdca4afef31cf0c282117a6c989e8/" rel="bookmark">
			suse linux挂载磁盘,suse11 如何查看硬盘的数目，以及每个硬盘的格式、大小、挂载点？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		suse11 如何查看硬盘的数目，以及每个硬盘的格式、大小、挂载点？
如题。方法或者命令都行。谢了！
|
fdisk -l
smartctl
hdparm
cat /proc/partitions
mount
...
X-Window下应该有设备管理器之类的东西吧？
|
df /
fdisk -l
cat /etc/fstab
|
[root@RHEL6B ~]# fdisk -l
Disk /dev/sda: 32.2 GB, 32212254720 bytes
255 heads, 63 sectors/track, 3916 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0007c6c1
Device Boot Start End Blocks Id System
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d4fdca4afef31cf0c282117a6c989e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f23d60abffa226d7291a613d46695b/" rel="bookmark">
			ssm原始整合（springmvc&#43;spring&#43;mybatis&#43;maven构建方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssm原始整合（springmvc+spring+mybatis+maven构建方式） 一、实现目标 实现一个简易版用户账户信息添加查看的后台管理
二、用到的技术点 框架：springmvc+spring+mybatis数据库：mysql前端：原生jsp项目构建：maven方式 三、整合步骤 构建maven框架在pom文件中导入相关依赖，包括spring相关、springmvc相关、mybatis相关、必要的单元测试依赖junit、日志依赖log4j等创建数据库ssm和表account在src路径下创建对应数据库的类文件account.java在resources文件中添加以后要加载用来连接数据库和查看日志的资源文件jdbc.properties和log4j.properties在resources文件中添加spring的配置文件applicationContext.xml、springmvc的配置文件spring-mvc.xml、mybatis的核心配置文件sqlMapConfig.xml根据springmvc分层的要求分别创建service层的接口和实现类、controller层的类在spring-mvc.xml中通过组件扫描的方式让spring容器创建controller层的实现、并且配置视图解析器、开放静态资源访问、添加注解驱动创建AccountMapper接口以及对应的映射文件AccountMapper.xml，并且编写对应的sql语句在sqlMapConfig.xml中加载properties资源文件、通过扫包的方法为Account定义别名、配置environment环境连接数据库，加载AccountMapper.xml映射文件在web.xml文件中配置spring监听器、springmvc前端控制器、配置请求乱码的字符编码过滤器编写service层的具体实现代码启动tomcat服务器，访问save.jsp 四、项目目录 五、实现代码
代码太多了我直接上传在Github上了，欢迎star、fork
https://github.com/xukai777/ssm-
六、实现结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dedbb818e9ef021c9cfe9d7180fdc4e0/" rel="bookmark">
			linux 文件夹名字回车,windwos linux 文档 文件 导入 问题 ^M 回车 换行 区别 整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windwoslinux文档文件 导入 问题 ^M 回车 换行 区别 整理
参考文档：
1.问题来源(背景)：
“回车”(carriage return)VS “换行”(line feed)
在计算机还没有出现之前，有一种叫做电传打字机(Teletype Model 33)的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。
这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。
后来，计算机发明了，这两个概念也就被用到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
Unix系统里，每行结尾只有“”，即“\n”；Windows系统里面，每行结尾是“”，即“\n\r”；Mac系统里，每行结尾是“”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。
2.区别：
换行符：
A windows中的换行符是\r\n，
B linux/unix下的换行符是\n。
其中:
回车符：\r=0x0d (13) return； #回车(carriage return)
换行符：\n=0x0a (10) newline。#换行(newline)
3.解决方法
排错思路，首先确定问题。
先看下我的文档#!/bin/bash
echo hahaha
echo whwhwhw
这是在windows下编辑的文档。乍一看去没有问题，但是无法执行。[diguojin@localhost public]$ ./test.sh
./test.sh: line 1: #!/bin/bash: 没有那个文件或目录
hahaha
whwhwhw
[diguojin@localhost public]$
确定问题[diguojin@localhost public]$ file test.sh
test.sh: UTF-8 Unicode (with BOM) text
[diguojin@localhost public]$ cat -A test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dedbb818e9ef021c9cfe9d7180fdc4e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfb324d21be4a4612e9401ebe198246/" rel="bookmark">
			JDK详细安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、下载安装文件二、安装三、配置环境变量1.新建环境变量JAVA_HOME2.新建环境变量CLASSPATH3.配置环境变量Path4.命令行窗口查看 前言 安装jdk8的方法：首先双击exe文件，并按照默认设置一步一步安装；然后依次右键点击“此电脑-属性-高级系统设置-高级-环境变量-新建”；接着新建环境变量JAVA_HOME；最后配置环境变量Path即可。
一、下载安装文件 jdk的安装与配置是Java学习的第一步，下面记录一下具体过程。首先根据自己系统下载对应版本。下载地址
http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
二、安装 双击exe文件，按照默认设置一步一步安装。选择自己要存放JDK的安装路径，文件也不大，我就直接放在默认位置了,这里需要大概记下你的JDK安装路径，后面需要用到！
三、配置环境变量 右键“此电脑”——“属性”——“高级系统设置”——“高级”——“环境变量”——“新建”：
1.新建环境变量JAVA_HOME 变量名：JAVA_HOME；
变量值：D:\JDK\jdk1.8.0_161 。变量值是自己的jdk安装目录：
2.新建环境变量CLASSPATH 变量名：CLASSPATH
变量值：
.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar需要注意变量值前面的“.;”
3.配置环境变量Path 双击Path，点击新建，
添加“%JAVA_HOME%\bin”；
再次点击新建，
添加“%JAVA_HOME%\jre\bin”。
这里要特别注意一下，win10环境变量值是一行一行的，不要直接点击新建，添加“%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”，否则会出现“javac不是内部或外部命令”错误。
此时环境配置完成~
4.命令行窗口查看 Win+R键弹出运行窗口，输入cmd命令打开如下窗口来测试下自己的Java是否安装成功
1.测试命令Java，若出现下图信息的话就证明Java环境已经配置成功了。
2.测试命令java -version，若出现下图信息的话就证明Java环境已经配置成功了。
3.测试命令javac，若出现下图信息的话就证明Java环境已经配置成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451b8bbea92bcc45ff09b914e240122b/" rel="bookmark">
			波束宽度与波达方向及阵元数的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		波束宽度与波达方向及阵元数的关系
clc,clear close all N=[8 128 1024];%阵元数 theta=0+eps:0.5:90;%来波方向，角度范围 x=theta.*pi/180; for j=1:3 for i=1:length(x)%波束宽度和波达方向计算公式 p(j,i)=x(i)-asin(sin(x(i))+2*asin(-1.391/N(j))/pi);%1.391为sinc函数下降3dB时x的值 end plot(theta,p(j,:)); hold on end grid on ylabel('Width in radians') title('波束宽度与波达方向及阵元数的关系') legend('N=8','N=128','N=1024') 如有问题请在评论区提问，一起交流进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3149d27a766a59e95599442482edfd1/" rel="bookmark">
			linux命令行读取本地文件路径,Windows shell命令获取当前目录的完整path？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果直接使用shell，请使用cd ，如果要在batch file中使用它，则使用%cd% (行为与environment var类似)。
您可以如下设置批处理/环境variables：
SET var=%cd% ECHO %var%
来自Windows 7 x64 cmd.exe的示例屏幕截图。
更新：如果您执行SET var = %cd%而不是SET var=%cd% ，则会发生以下情况。 感谢jeb。
从batch file中捕获当前目录
引用set命令( set /? )的Windows帮助：
如果启用了命令扩展，那么有几个dynamic的
可以扩展但不显示的环境variables
SET显示的variables列表。 这些variables值是
每次扩大variables的值时dynamic计算。
如果用户用这些名字中的一个显式地定义一个variables，那么
该定义将覆盖下面描述的dynamic定义：
％CD％ - 展开为当前目录string。
％DATE％ - 使用与DATE命令相同的格式展开到当前date。
％TIME％ - 使用与TIME命令相同的格式展开到当前时间。
％RANDOM％ - 扩展为0到32767之间的随机十进制数。
％ERRORLEVEL％ - 展开为当前的ERRORLEVEL值
％CMDEXTVERSION％ - 扩展到当前的命令处理器扩展
版本号。
％CMDCMDLINE％ - 展开到调用的原始命令行
命令处理器。
注意%CD% - expands to the current directory string. 部分。
在Unix上？
PWD
对于Windows我们可以使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3149d27a766a59e95599442482edfd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85fa47bb94fbc13f844533160381f1d3/" rel="bookmark">
			正则表达式之提取数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static String ExtractNumber(String phoneString){ // 提取数字 // 1 Pattern pattern = Pattern.compile("[^0-9]"); Matcher matcher = pattern.matcher(phoneString); //将与模式匹配的输入序列的每个子序列替换为给定的替换字符串。 String all = matcher.replaceAll(""); //System.out.println("phone:" + all); // 2 String abc = Pattern.compile("[^0-9]").matcher(phoneString).replaceAll(""); return all; } 这里我直接将提取数字的正则表达式封装成一个方法，封装成一个方法的一个好处就是下次我想用的时候直接调用就行了，就不需要再写重复的代码。
在上图中我们可以看到两种方法，其实都是一种方法，第二种方法不过是将第一种方法全部写一块去了。所以用第一种还是第二种都是可以的，下面两张图是需要传入的参数和结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f040f569ce4d46c28b813a99758f5630/" rel="bookmark">
			彻底搞懂String：字符串常量池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为最基础的引用数据类型，Java 设计者为 String 提供了字符串常量池以提高其性能，那么字符串常量池的具体原理是什么，我们带着以下三个问题，去理解字符串常量池：
1、字符串常量池的设计意图是什么？
2、字符串常量池在哪里？
3、如何操作字符串常量池？
字符串常量池的设计思想
1、字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能。
2、JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。
1）为字符串开辟一个字符串常量池，类似于缓存区。
2）创建字符串常量时，首先坚持字符串常量池是否存在该字符串。
3）存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中。
3、实现的基础
1）实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享。
2）运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收。
代码：从字符串常量池中获取相应的字符串
字符串常量池在哪里
在分析字符串常量池的位置时，首先了解一下堆、栈、方法区：
1、堆
1）存储的是对象，每个对象都包含一个与之对应的class。
2）JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。
3）对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定。
2、栈
1）每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)。
2）每个栈中的数据(原始类型和对象引用)都是私有的。
3）栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
4）数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失。
3、方法区
1）静态区，跟堆一样，被所有的线程共享。
2）方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
字符串常量池则存在于方法区
代码：堆栈方法区存储字符串
字符串对象的创建
面试题：String str4 = new String(“abc”) 创建多少个对象？
1、在常量池中查找是否有“abc”对象。
1）有则返回对应的引用实例；
2）没有则创建对应的实例对象。
2、在堆中 new 一个 String("abc") 对象。
3、将对象地址赋值给str4，创建一个引用。
所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用。
根据字面量，往往会提出这样的变式题：
String str1 = new String("A"+"B") ; 会创建多少个对象?
String str2 = new String("ABC") + "ABC" ; 会创建多少个对象?
str1：
字符串常量池："A","B","AB" : 3个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f040f569ce4d46c28b813a99758f5630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a00d3267030c5e954bc74b205b37ee/" rel="bookmark">
			秒懂设计模式之状态模式（State Pattern）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[版权申明] 非商业目的注明出处可自由转载
博文地址：https://blog.csdn.net/ShuSheng0007/article/details/116375477
出自：shusheng007
设计模式汇总篇，一定要收藏：
永不磨灭的设计模式（有这一篇真够了，拒绝标题党）
文章目录 概述类型难度 定义使用场景UML类图实例第一，定义一个状态接口第二，定义一个物流Context类第三，实现各种状态类第四， 客户端使用 技术要点总结优缺点优点缺点 状态模式与策略模式总结 概述 状态模式在日常开发中是一个非常实用的模式，可以将你的代码逼格迅速提升一个档次，所以让我们开始今天的卓越之旅吧。
类型 行为型（behavioral）
难度 3颗星
定义 当一个对象内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
定义对于初学者没啥用，因为字都认识却无法理解其中的含义。必须等学完了，回过头来看才能更加深刻的理解其含义
使用场景 你发现你的代码里面存在一个很长的if else列表，而这些分支都是因为不同状态下执行的操作不一样时考虑使用此模式
UML类图 照例先上一张俺手撕的UML类图
从上图可见，状态模式共有3个角色
State 是一个接口，封装了状态及其行为
ConcreteState X State的实现类，表示具体的状态
Context 保持并切换各个状态，其持有一个State的引用。它将依赖状态的各种操作委托给不同的状态对象执行。其负责与客户端交互
实例 最近王二狗又要过生日了，近两年他内心中是非常抗拒过生日的，因为每过一个生日就意味着自己又老一岁，离被辞退的35岁魔咒又近了一步。可惜时间是不以人的意志为转移的，任何人都阻止不了时间的流逝，所以该过还的过。令二狗比较欣慰的时，这次过生日老婆送了他一个自己一直想要的机械键盘作为生日礼物… 翠花于是在二狗生日前3天在京东上下了一个单…
自从下单以来，二狗天天看物流状态信息，心心念念着自己的机械键盘快点到…
这个物流系统就很适合使用状态模式来开发，因为此过程存在很多不同的状态，例如接单，出库，运输，送货，收货，评价等等。而订单在每个不同的状态下的操作可能都不一样，例如在接单状态下，商家就需要通知仓库拣货，通知用户等等操作，其他状态类似
下面是实例的UML类图
第一，定义一个状态接口 此接口定义各个状态的统一操作接口
public interface LogisticsState { void doAction(JdLogistics context); } 第二，定义一个物流Context类 此类持有一个LogisticsState 的引用，负责在流程中保持并切换状态
public class JdLogistics { private LogisticsState logisticsState; public void setLogisticsState(LogisticsState logisticsState) { this.logisticsState = logisticsState; } public LogisticsState getLogisticsState() { return logisticsState; } public void doAction(){ Objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57a00d3267030c5e954bc74b205b37ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e34fc5e5f88ff392765d6029f86aeb/" rel="bookmark">
			2021-05-03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Java之Spring Boot详解(非原创） - 故事爱人 - 博客园】https://www.cnblogs.com/WUXIAOCHANG/p/10877266.html
【java中封装是什么，怎么实现封装】https://mbd.baidu.com/ma/s/2Iz51ca0
【Java的封装方法_@林十一的博客-CSDN博客】https://blog.csdn.net/weixin_44587829/article/details/90272952
【github怎么下载别人的项目】https://mbd.baidu.com/ma/s/emIu4uSB
【python之初学爬虫并且将爬回来的数据存为csv文件 - 哈哈哈和 - 博客园】https://www.cnblogs.com/sgy614092725/p/shiguiyu16.html
【如何快速爬取B站全站视频信息】https://mbd.baidu.com/ma/s/jsZgBfMX
【使用 Python 简单的爬取网页数据】https://mbd.baidu.com/ma/s/kdatTWN5
【写csv文件_python爬虫25 | 爬取下来的数据怎么保存？ CSV 了解一下_weixin_39624389的博客-CSDN博客】https://blog.csdn.net/weixin_39624389/article/details/112664488
【基于数据分析的网络黑名单系统设计与实现_68手游网】https://www.office68.com/computer/24395.html
【Github 简明教程 | 菜鸟教程】https://www.runoob.com/w3cnote/git-guide.html
【GitHub Desktop的简易使用方法_xulong5000的专栏-CSDN博客】https://blog.csdn.net/xulong5000/article/details/114299173
【GitHub Desktop的简易使用方法_xiaolongqinghua的博客-CSDN博客】https://blog.csdn.net/xiaolongqinghua/article/details/87785139
【github Desktop工具桌面版汉化教程_JackieDYH的博客-CSDN博客】https://blog.csdn.net/JackieDYH/article/details/115323901
【Git 大全 - Gitee.com】https://gitee.com/all-about-git
【盘点常见的7种网络安全威胁_cloud-man的博客-CSDN博客】https://blog.csdn.net/weixin_45587182/article/details/113519370
【网络安全威胁感知系统 - 长安通信科技】http://www.chanct.com/Index/show/catid/17/id/55.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ba762908ac90def4e33257fd922b72/" rel="bookmark">
			FFmpeg开发XPlay2.0播放器-02 FFmpeg解封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		avformat_open_input /** * Open an input stream and read the header. The codecs are not opened. * The stream must be closed with avformat_close_input(). * * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context). * May be a pointer to NULL, in which case an AVFormatContext is allocated by this * function and written into ps. * Note that a user-supplied AVFormatContext will be freed on failure. * @param url URL of the stream to open.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ba762908ac90def4e33257fd922b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ff4db9bbb82d7a8e591217990ad46f/" rel="bookmark">
			linux v4l2系统详解,v4l2驱动2-linux3.0.8中V4L2_CAP_*详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这部分涉及不少专业支持，有些可能写的不好，请大家原谅！
/* Values for ‘capabilities‘ field */
#define V4L2_CAP_VIDEO_CAPTURE0x00000001 /* Is a video capture device */
#define V4L2_CAP_VIDEO_OUTPUT0x00000002 /* Is a video output device */
#define V4L2_CAP_VIDEO_OVERLAY0x00000004 /* Can do video overlay */
#define V4L2_CAP_VBI_CAPTURE0x00000010 /* Is a raw VBI capture device */
#define V4L2_CAP_VBI_OUTPUT0x00000020 /* Is a raw VBI output device */
#define V4L2_CAP_SLICED_VBI_CAPTURE0x00000040 /* Is a sliced VBI capture device */
#define V4L2_CAP_SLICED_VBI_OUTPUT0x00000080 /* Is a sliced VBI output device */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38ff4db9bbb82d7a8e591217990ad46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a460a41b7124ca8499e71e587d253af8/" rel="bookmark">
			linux防火墙禁止所以端口,利用iptables来配置linux禁止所有端口登陆和开放指定端口...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关闭所有的 INPUT FORWARD OUTPUT 只对某些端口开放。
下面是命令实现：
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP
再用命令 iptables -L -n 查看 是否设置好， 好看到全部 DROP 了
这样的设置好了，我们只是临时的， 重启服务器还是会恢复原来没有设置的状态
还要使用 service iptables save 进行保存
看到信息 firewall rules 防火墙的规则 其实就是保存在 /etc/sysconfig/iptables
可以打开文件查看 vi /etc/sysconfig/iptables
2、
下面我只打开22端口，看我是如何操作的，就是下面2个语句
iptables -A INPUT -p tcp –dport 22 -j ACCEPT
iptables -A OUTPUT -p tcp –sport 22 -j ACCEPT
再查看下 iptables -L -n 是否添加上去, 看到添加了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a460a41b7124ca8499e71e587d253af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177d59951e77426c7cddfb7a639db4ea/" rel="bookmark">
			swin transformer解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swin Transformer: Hierarchical Vision Transformer using Shifted Windows --论文解读 论文信息、概要 Swin transformer是微软今年三月25日公布的一篇利用transformer架构处理计算机视觉任务的论文。源码仅仅公布两天就在github上收获了2.2k个stars。它是我个人认为迄今为止用tranformer架构处理计算机视觉任务最有实用价值的一篇文章，在图像分割，目标检测各个领域已经霸榜，让很多人看到了transformer完全替代卷积的可能。而且它的设计思想吸取了resnet的精华，从局部到全局，将transformer设计成逐步扩大感受野的工具，它的成功背后绝不是偶然，而是厚厚的积累与沉淀。
论文链接https://arxiv.org/abs/2103.14030
总体结构 输入的图像先经过一层卷积进行patch映射，我有看过源代码，具体是将图像先分割成 4 × 4 4\times4 4×4的小块，然后将每一个小块通过映射成一个像素点，进行了通道上的扩充。以swin-s为例，输入的 224 × 224 224\times224 224×224图像经过这一步操作就变成了 56 × 56 56\times56 56×56的特征图。特征图一开始开始输入到stage1，stage1由两层transformer组成，这两层transformer的核心一个是普通的window attention, 另一个是shift window attention。可以将window attention 和shift window attention视为两个模块，在每一个stage内部就是直接堆积这两个模块。然后在stage与stage之间要有一个pooling操作来降低要处理的数据的尺寸，也就是为了从一开始的局部信息搜索到全局信息的提取。当然这个pooling操作与传统卷积里面的pooling也不太一样，它是将特征图先经过一个space to depth变为 1 4 \frac{1}{4} 41​，通道数变为原来的4倍，再又一个MLP缩减一半。也就是说没经过一个stage，总的数据量变为原来的 1 2 \frac{1}{2} 21​。
此时可以很容易的看出，swin transformer和resnet一样设计的是一个层次结果很明显的网络，底部的结构处理的数据更多也更局部，顶部的网络处理的数据更少但是语义信息是更加丰富的。不同的是swin主要提取信息的方式是采用transformer，而resnet是卷积核。
window attention 和 shift window attention 如图，window attention就是按照一定的尺寸将图像划分为不同的window，每次transformer的attention只在window内部进行计算。那么如果只有window attention就会带来每一个像素点的感受野得不到提升的问题，所以它又设计了一个shift window attention的方法，就是换一下window划分的方式，让每一个像素点做attention计算的window块处于变化之中。那么就起到了提升感受野的作用。
存在的问题 在同尺寸通计算量的前提下，swin确实效果远好于resnet。但是有几个问题：
1. 受缚于shift操作，对不同尺寸的输入要设计不同的网络，而且也要重新开始训练，这是很难接受的。
2. 和Detr一样训练的时候收敛的太慢。我自己有训练了一下最小的swin-tiny版本，大概训练了一百多轮的时候也才到72～73左右。有这方面改进的想法的朋友可以和我交流，整一篇B类应该没问题。
3. shift操作其实主要是为了提升感受野，可以换一种更好的方式。在这个方面我也有一点思路，可以交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65686b704b175e2aa8477ece4f9c0020/" rel="bookmark">
			A simple introduction to HashTable in C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A simple introduction to HashTable in C
Add, Find, parse and del
struct hashTable {
int key;
int val;
UT_hash_handle hh;
};
struct hashTable* tmp;
HASH_FIND_INT(hashtable, &amp;ikey, tmp);
test tmp == NULL
struct hashTable* tmp = malloc(sizeof(struct hashTable));
tmp-&gt;key = ikey, tmp-&gt;val = ival;
HASH_ADD_INT(hashtable, key, tmp);
struct HashTable *tmp, *iter;
HASH_ITER(hh, hashtable, iter, tmp) {
if (iter-&gt;count == 1) {
return iter-&gt;val;
}
HASH_DEL(hashtable, iter);
free(iter);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458d929b623c6dc6280b1475bbe632d6/" rel="bookmark">
			Java中9种常见的CMS GC问题分析与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 写在前面
1.1 引言
1.2 概览
2. GC 基础
2.1 基础概念
2.2 JVM 内存划分
2.3 分配对象
2.4 收集对象
2.5 收集器
2.6 常用工具
3. GC 问题判断
3.1 判断 GC 有没有问题？
3.2 判断是不是 GC 引发的问题？
3.3 问题分类导读
4. 常见场景分析与解决
4.1 场景一：动态扩容引起的空间震荡
4.2 场景二：显式 GC 的去与留
4.3 场景三：MetaSpace 区 OOM
4.4 场景四：过早晋升 *
4.5 场景五：CMS Old GC 频繁*
4.6 场景六：单次 CMS Old GC 耗时长*
4.7 场景七：内存碎片&amp;收集器退化
4.8 场景八：堆外内存 OOM
4.9 场景九：JNI 引发的 GC 问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/458d929b623c6dc6280b1475bbe632d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad9b02477952a7fa2bd99f3417dcff42/" rel="bookmark">
			2021-5-1 【PTA】【L1-6 不变初心数 (15 分)】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; using namespace std; int main() { int n; cin&gt;&gt;n;//输入n int a[12];// int x; bool flag=0; for(int i=0;i&lt;n;i++)//遍历次数 { cin&gt;&gt;x;//输入要判断的数 for(int j=2;j&lt;=9;j++)//从一到九遍历 { int s=x*j;// int sum=0; while(s!=0) { sum=sum+s%10;//每位数求和 s=s/10;//缩小一位 }	a[j]=sum;//用数组记录 } //	cout&lt;&lt;a[2]&lt;&lt;" "&lt;&lt;a[3]&lt;&lt;endl; for(int k=3;k&lt;=9;k++)//关键 { if(a[k]!=a[2]) flag=1;//只要有一个不同，flag改变 } if(flag) { cout&lt;&lt;"NO"&lt;&lt;endl;//不同为No flag=0;//变回初始状态，为下一轮做准备 (key) } else cout&lt;&lt;a[2]&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970620898d53365bdf74ae08d9b41e82/" rel="bookmark">
			通过串口控制LED的亮灭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USART 系列文章目录 五一假期，博主闲着没事，想起之前自己调试串口控制LED的亮灭问题尚未解决，便开始调试，再调试了一会时间后，觉得应该把它记录下来。 这一切问题的起源还得怪之前调试不认真，太浮躁了。
文章目录 USART 系列文章目录前言一、配置串口二、主要操作1.通过串口中断2.通过主函数 三、库函数分析1.USART_GetITStatus(USARTx, USART_IT_RXNE)2.USART_ReceiveData(USART1) 总结 前言 其中使用USART串口的一些配置方法在我之前的博客有粗略带过，纯小白看不懂建议看看其他csdn大佬们写的配置USART的方法和步骤。
我写这篇博客的目的是通过USART串口控制LED的亮灭问题，记录下我所调试过程中遇到的问题，和对于串口的一些自己的理解。
一、配置串口 由于我之前的博客有带过，就那几个步骤，注意下需要和电脑进行通信所配置的串口号、波特率、奇偶校验位、停止位、数据位那几个特殊注意下，以方便和电脑的串口调试助手进行通信。
我所使用的是XCOM的串口调试助手。
这里就贴下我所配置的串口代码吧
void uart_init(u32 bound){ //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟 //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX	GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //USART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/970620898d53365bdf74ae08d9b41e82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ecea1495046be124bfd828b37f3c74/" rel="bookmark">
			关于Java中的对象 Object o = new Object()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、对象的创建过程
1.class loading：将new T()加入到内存
2.class linking(verification,preparation,resolution)
3.class initializing
4.申请对象内存：申请new T()内存大小
5.成员变量赋默认值：如果T变量m=8，则给m赋值为0.
6.调用构造方法&lt;init&gt;
1).成员变量顺序赋初始值：将T中变量m赋值为8
2).执行构造方法语句：先调用父类super()
二、对象在内存中的存储布局
观察虚拟机配置：java -XX:+PrintCommandLineFlags -version
普通对象
1.对象头：markword 8
2.ClassPointer指针： -XX:+UseCompressedClassPointers为4自己 不开启为8字节
3.实力数据
4.Padding对齐，8的倍数
数组对象
1.对象头：markword 8
2.ClassPointer指针同上
3.数组长度：4字节
4.数组数据
5.对齐 8的倍数
三、对象具体包括什么（还没搞懂）
四、对象怎么定位
Tt = new T()
1.句柄池:t一个指针指向创建的对象，一个指针指向T.class
2.直接指针：t指针指向创建的对象，对象指针指向T.class
五、对象怎么分配(和GC有关，还未了解)
六、Object o = new Object()在内存中占用多少字节
markword + ClassPointer + Padding = 8 + 4 + 4 = 16
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5c3f03f360bb404dce2329cd0162a8/" rel="bookmark">
			linux nginx 错误日志,nginx error_log 错误日志配置说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx的error_log类型如下(从左到右：debug最详细 crit最少)：
[ debug | info | notice | warn | error | crit ]
例如：error_log logs/nginx_error.log crit;
解释：日志文件存储在nginx安装目录下的 logs/nginx_error.log ，错误类型为 crit ，也就是记录最少错误信息；
注意error_log off并不能关闭日志记录功能，它将日志文件写入一个文件名为off的文件中，如果你想关闭错误日志记录功能，应使用以下配置：
error_log /dev/null crit;
把存储位置设置到Linux的黑洞中去
错误处理：
nginx在读取配置文件指定的错误日志路径前将使用编译的默认日志位置，如果运行nginx的用户对该位置没有写入权限，nginx将输出如下错误：
[alert]: could not open error log file: open() "/var/log/nginx/error.log" failed (13: Permission denied) log_not_found 语法：log_not_found on | off
默认值：on
使用字段：location
这个参数指定了是否记录客户端的请求出现404错误的日志，通常用于不存在的robots.txt和favicon.ico文件，例如： location = /robots.txt { log_not_found off; }
最后：所有nginx配置发生改变时，最好都使用如下命令测试配置是否错误后再使用 -s reload 重载
/usr/local/nginx/sbin/nginx –t
说明：
以上是nginx的默认安装路径，如果改变了要相应的修改成自己nginx对应的路径。
输入后如果提示如下，则表示配置无误：
nginx: the configuration file /usr/local/nginx/conf/nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c5c3f03f360bb404dce2329cd0162a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f478e223726a8128c6627b941a9e7b/" rel="bookmark">
			【Unity笔记】FPS的认识与锁帧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发平台：Unity 2017版本以上
编程平台：Visual Studio 2017以上
一、认识FPS (帧数) FPS （Frames Per Second）是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。
二、常见帧数参考表 帧数描述24Hz极少数旧设备的最低帧数30Hz一般人眼能接受的最低帧数最低限定45Hz60Hz中等流程的帧数推荐120Hz丝滑流畅帧数追求 其他说明
PC端选择60Hz以上。手机端开发受设备闲置应稳定在30Hz以上。24Hz不推荐。帧数过低会导致用户出现头晕等不适症状。应尽可能避免帧数忽高忽低的表现。 三、在Unity中实现帧数锁定 打开工程项目在菜单栏中 “Edit -&gt; Project Setting”打开 “Quality” 分栏在 “Other” 分区中，调整 V Sync Count（垂直同步计数）。 其中，V Sync Count提供三项选择：
选择项描述Don’t Sync不作垂直同步Every V Blank每帧垂直同步Every Second V Blank每帧取垂直同步一半的值 限制帧数情况下，选择 “Don’t Sync”新建GameObject对象，命名为GameController新建并添加 FPSLimit.cs 至对象上，并添加下列代码内容： void Start() { //帧数限制为 30 Application.targetFrameRate = 30; } 注：该函数方法由Unity提供。
四、观察帧数是否锁定 新建并添加 FPSShow.cs 至 GameController 对象上在 FPSShow.cs 添加下列代码内容： using System; using UnityEngine; /// &lt;summary&gt; /// 帧数显示器 /// &lt;/summary&gt; public class FPSShow : MonoBehaviour { /// &lt;summary&gt; /// 单位统计时间 /// &lt;/summary&gt; private const float fpsMeasureTime = 1f; /// &lt;summary&gt; /// 单位帧数统计时间 /// &lt;/summary&gt; private const int fpsMeasureFrame = 30; /// &lt;summary&gt; /// 帧数统计 /// &lt;/summary&gt; private int fpsCount; /// &lt;summary&gt; /// 计时器 /// &lt;/summary&gt; private float timer; /// &lt;summary&gt; /// 单位时间帧数 /// &lt;/summary&gt; private int fps; /// &lt;summary&gt; /// 单位帧数耗时 /// &lt;/summary&gt; private float timeUse; private string result; private GUIStyle style; private Rect rect; /// &lt;summary&gt; /// FPS统计类型 /// &lt;/summary&gt; public enum FPSType { FixedTime, FixedFrame } /// &lt;summary&gt; /// FPS在屏幕中的位置 /// &lt;/summary&gt; public enum RectType { UpLeft, UpMiddle, UpRight, DownLeft, DownMiddle, DownRight, Middle, MiddleLeft, MiddleRight } public FPSType fpsType; public RectType rectType; private void Start() { timer = 0f; fpsCount = 0; } private void Update() { if (fpsType == FPSType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f478e223726a8128c6627b941a9e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6a5495aecf12620469297de9898ee7/" rel="bookmark">
			java StringBuffer和StringBuilder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 我们在实际的开发中，如果需要进行字符串的频繁拼接，会出现以下问题：
java中的字符串是不可变的，每一次拼接都会产生新字符串。
这样会占用大量的方法区内存。造成内存空间的浪费。
eg.
String s = "abc"; s += "hello"; 就以上两行代码，就导致在方法区字符串常量池当中创建了3个对象：
"abc" "hello" "abchello" 因此引出StringBuffer和StringBuilder可变字符串！
二、如何优化StringBuffer和StringBuilder的性能？ 在创建StringBuffer和StringBuilder的时候尽可能给定一个初始化容量。
最好减少底层数组的扩容次数。预估计一下，给一个大一些初始化容量。
关键点：给一个合适的初始化容量。可以提高程序的执行效率。
三、StringBuffer和StringBuilder的区别？ StringBuffer中的方法都有：synchronized 关键字修饰。表示StringBuffer在多线程环境下运行是安全的。
StringBuilder中的方法都没有：synchronized 关键字修饰，表示StringBuilder在多线程环境下运行是不安全的。
StringBuffer是线程安全的。StringBuilder是非线程安全的。 四、String为什么是不可变的？ 源代码内，String类中有一个 byte[ ] 数组，这个byte[ ]数组采用了 final 修饰，
因为数组一旦创建长度不可变。并且被final修饰的引用一旦指向某个对象之后，不可再指向其它对象，所以String是不可变的！
所以"abc" 无法变成 “abcd”
五、StringBuilder和StringBuffer为什么是可变的呢？ 源代码内，StringBuffer和StringBuilder内部实际上是一个 byte[ ]数组，这个byte[]数组没有被final修饰，
StringBuffer和StringBuilder的初始化容量是 16，当存满之后会进行扩容，底层调用了数组拷贝的方法System.arraycopy()。所以StringBuilder和StringBuffer适合于使用字符串的频繁拼接操作。
注意：
StringBuffer和StringBuilder默认初始化容量为16个byte[] 数组
总结 StringBuffer/StringBuilder可以看做 可变长度字符串。StringBuffer/StringBuilder初始化容量 16.StringBuffer/StringBuilder是完成字符串拼接操作的，方法名：appendStringBuffer是线程安全的。StringBuilder是非线程安全的。频繁进行字符串拼接不建议使用“+” 六、构造方法 构造方法名StringBuilder()StringBuilder(int capacity)StringBuilder(String str) eg.
class StringBufferTest{ public static void main(String[] args) { StringBuffer s1 = new StringBuffer();//创建一个容量为16的StringBuffer对象 StringBuffer s2 = new StringBuffer("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea6a5495aecf12620469297de9898ee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36793563b7303a7723366014b151ccd0/" rel="bookmark">
			Java计算数组中元素的总和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组元素的总和是指数组中所有元素（或数字）的总和。数组元素可以是整数（int）或十进制数字（float或double）。
方法1：使用for循环
这是一种传统且最常用的方法，其中使用for循环来迭代数组。
在每次迭代中，将当前数组元素添加到一个保存数组元素总和的变量中。
在循环开始之前，此变量被初始化为0。例如，
​ public class ArraySumCalculator { public static void main(String[] args) { int[] array = { 1, 34, 67, 23, -2, 18 }; // variable to hold sum of array elements int sum = 0; // iterate using a for loop for (int loopCounter = 0; loopCounter &lt; array.length; loopCounter++) { // get current array element int element = array[loopCounter]; // add element to sum sum += element; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36793563b7303a7723366014b151ccd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280e040ea38e71dacc3c02f56ce19a27/" rel="bookmark">
			Educational Codeforces Round 108 (Rated for Div. 2)_思维题B. The Cake Is a Lie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B. The Cake Is a Lie 题目传送门！
题面： 中文题意： 很简单，目的是从(1,1)走到（n,m），然后两种走法。
（x,y）变成（x,y+1）/(x+1,y)前者消耗代价x，后者则消耗代价y。
给你n,m,k。问可否保证整个移动过程中代价为k？
思路： 证明略。
实际上无论怎么走代价花费都是一样的，因为只能往右或者往上。
代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { int t; cin &gt;&gt; t; while (t--) { ll n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; ll x, y; x = 1; y = 1; if (n - 1 + n * (m - 1) == k) printf("YES\n"); else printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280e040ea38e71dacc3c02f56ce19a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd88c1dc6308e7aab1af86d3e08cf88/" rel="bookmark">
			Unity(5)-UGUI(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UGUI是什么 Unity图形用户界面Unity Graphical User Interface是Unity4.6以上版本新加入的界面显示系统。
Unity界面发展史 与OnGUI对比 全新的布局系统：Rect Transform、Layout Group强大的时间机制：鼠标指针类、拖拽类、点选类、输入类最佳的执行效能：减少了GPU负担 与NGUI对比 由NGUI创始人参与开发自适应系统更完善更方便的深度处理淡化了Atlas，直接使用Sprite PackerUGUI没有Tween组件开发效率暂时低于NGUI 基础控件 Canvas画布 简介
画布，绘制UI元素的载体，所有UI元素必须在Canvas之下。UI元素的绘制顺序依赖于层次面板中的顺序。属性Render Mode渲染方式 Screen Space-Overlay覆盖模式：UI元素将绘制在其他元素之前，且绘制过程独立于场景元素和摄像机设置，画布尺寸由屏幕大小和分辨率决定。 Pixel Perfect完美像素：若勾选，则会锐化屏幕显示效果。Sort Order渲染顺序：在多个Canvas中，值越大越渲染到最上层。 Screen Space-Camera摄像机模式：提供UICamera，Canvas对象绘制在一个与摄像机固定距离的平面上，且绘制效果受摄像机参数的影响。 Render Camera渲染摄像机Plane Distance平面与摄像机的距离Sorting Layer排序层：通过Edit–Project Settings-Tags and Layers调整Canvas渲染顺序。 World Space世界空间模式：画布渲染于世界空间，与场景中其他3D物体性质相同。 Rect Transform 简介
派生自Transform，在UGUI控件上代替原有变换组件，表示一个可容纳UI元素的矩形。属性 Pos：控件轴心点相对于自身锚点的位置。Anchor锚点：UI元素的4个顶个与锚点的间距保持不变锚点总是相对于父级，不能超越父物体范围
表示点–&gt; PosX PosY Width Hight
表示拉伸–&gt;Left Right Top BottomPivot轴心点：移动、旋转与缩放都围绕轴心点发生变化，0,0为左下顶点，1,1为右上顶点。 Image图片 属性 Image Type贴图类型： Simple简单 Preserve Aspect 保持贴图原始比例Set Native Size将贴图设置为原始尺寸 Sliced 切割 Fill Center填充中部区域，如果取消中部区域为透明 Tiled平铺 保持图片原始尺寸，从左下角重复多次填充空白 Filled填充 可以呈现出从空白到完整填充的过程 Text 文本标签 属性Character 字符Font 字体Font Style 样式Font Size 大小Line Spacing 行间距Rich Text 是否使用富文本样式Paragraph 段落Alignment 对齐方式Horizontal / Vertical Overflow 水平 / 垂直 溢出Best Fit 大小自适应 范围在Min Size 与Max Size之间Color 颜色Material 材质富文本语法 &lt;b&gt;粗体&lt;/b&gt; &lt;i&gt;斜体&lt;/i&gt; &lt;size=14&gt;字号&lt;/size&gt; &lt;color=green&gt;颜色&lt;/color&gt; 效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd88c1dc6308e7aab1af86d3e08cf88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e283c7c01c853fd407819df8c01770d3/" rel="bookmark">
			ZYNQ系列（十一）ZYNQ 使用RS9900 USB转网口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZYNQ系列（十一）ZYNQ 使用RS9900 USB转网口 第一章 Petalinux创建工程
第二章 Petalinux-config配置说明
第三章 QSPI自启动工程
第四章 将文件打包进文件系统
第五章 将文件打包进文件系统
第六章 ZYNQ下使用CMAKE创建APP工程
第七章 ZYNQ下使用CMAKE创建QT工程
第八章 ZYNQ下使用BOA
第九章 ZYNQ开机的一些配置
第十章 ZYNQ使用linux自带的按键驱动程序
第十一章 ZYNQ 使用RS9900 USB转网口
文章目录 ZYNQ系列（十一）ZYNQ 使用RS9900 USB转网口前言USB中CDC-ECM的了解和配置Ethernet Networking Control Model实现验证 前言 SR9900是一个高集成度、超低功耗、单芯片USB2.0转10/100M以太网控制电路。为各类应用增加低成本、小型封装、即插即用的快速以太网功能，可用于台式电脑、笔计本电脑、超便携式电脑、平板电脑、托架/端口复制器/扩展坞、游戏机、智能家居及任何有USB接口的嵌入式设备。
USB中CDC-ECM的了解和配置 USB中典型类及子类：
Ethernet Networking Control Model 以太网控制模型是用在主从设备间的以太网帧数据的交换。通信类接口用于配置和管理以太网程序，程序中包括的“以太网控制模型”子类码是通信类接口描写叙述定义。
数据接口则用于在USB总线上交换USB数据包。这些USB数以的包封装了完整的以太网包。CRC校验和不能包括在以太网收发数据包中。
检验失败的帧数据不能再发送到主机。这意味着设备必须可以缓冲至少一个完整的以太网帧数据。
实现 在vivado工程中使能usb0.
Linux内核配置支持CDC-ECM：
Device Drivers ---&gt; [*] Network device support ---&gt; USB Network Adapters ---&gt; &lt;*&gt; Multi-purpose USB Networking Framework -*- CDC Ethernet support (smart devices such as cable modems) 在设备树中使能usb的驱动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e283c7c01c853fd407819df8c01770d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12435b32e2a181c058c94f0069cdbf52/" rel="bookmark">
			C&#43;&#43;：信号与槽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 信号与槽
作用：实现对象间的通信，灵活高效（libevent事件驱动机制） 信号
信号使用signal关键字声明信号只要像函数那样声明即可，其中可以有参数，参数的主要作用是用于和槽通信信号是由moc自动生成的信号的返回值只能是void类型的发射信号需要使用emit关键字 槽
声明用slots：public slots：在这个区内声明的槽意味着任何对象都可以将信号与之连接protect slots：在这个区内声明的槽意味着当前类及其子类可以将信号与之相连接private slots：在这个区内声明的槽意味着只有类自己可以将信号与之相连接 槽就是一个普通的函数，可以像普通函数一样进行使用，槽与函数主要的区别就是槽可以和信号关联
ui资源（槽函数）只能在ui线程（主线程）访问
信号与槽的关系：
槽的参数类型需要与信号参数的类型相对应一个信号可以和多个槽进行关联，发送信号时，槽函数按照关联的顺序依次执行多个信号也可以与同一个槽关联信号也可以关联到另一个信号上 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4dcc2f8d7f86fcd4f94650687b0c7c/" rel="bookmark">
			Educational Codeforces Round 108 (Rated for Div. 2) ABCD题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目连接：
https://codeforces.com/contest/1519
A.Red and Blue Beans 题目思路：
1.构造最优的状态，即一个是1，一个是1+d
2.先比较r,b的大小，让小的是r，那么最多需要(1+d)*r个 b。
3.最多的和b比较一下就行了
AC代码：
#include&lt;bits/stdc++.h&gt; using namespace std; const int N=1; typedef long long ll; map&lt;int,int&gt; mp; int main() { ll a,b,d; ll t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;a&gt;&gt;b&gt;&gt;d; /*	if(d==0) { if(a==b) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; continue; } */ if(a&gt;b) swap(a,b); ll res=(1+d)*a; if(res&gt;=b) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; } return 0; } B. The Cake Is a Lie 题目思路：
1.因为懒的分析，但是看起来是结论题，于是用暴力DFS找一下规律
2.发现到（n,m)点的距离是恒定的 即 NM-1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a4dcc2f8d7f86fcd4f94650687b0c7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ea10982a7c296a72ba00567806589a/" rel="bookmark">
			clickhouse学习笔记-6-数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、整形
带符号 - Int8	[-128 : 127] - Int16	[-32768 : 32767] - Int32 - Int64 无符号 - uInt8	[0 : 255] - uInt16	[0 : 65535] - uInt32 - uInt64 二、浮点数
支持类型 - Float32 - Float64 支持以下特殊的浮点数 - Inf – 正无穷 - Inf – 负无穷 - NaN – 非数字 三、定点数
数据类型 - Decimal32	- ( -1 * 10^(9 - S), 1 * 10^(9 - S) ) - Decimal64	- ( -1 * 10^(18 - S), 1 * 10^(18 - S) ) - Decimal128	- ( -1 * 10^(38 - S), 1 * 10^(38 - S) ) 有符号的定点数，可在加、减和乘法运算过程中保持精度。对于除法，最低有效数字会被丢弃（不舍入）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ea10982a7c296a72ba00567806589a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b910b2247ca168d6cf5840c8e5271c1/" rel="bookmark">
			clickhouse学习笔记-9-问题集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从mysql同步数据到ck，有时间字段为null，同步不成功 方案一：
修改ck的字段，允许为null
CK `collect_local_date` Nullable(DateTime) COMMENT '采集的当地时间', 方案二：
数据同步的过程中，如果mysql的字段为null，则设置默认时间
mysql ifNull(`collect_local_date`, toDateTime('0000-00-00 00:00:00')), 时间转换 SELECT 'UK' as country, toDateTime('2020-02-28 05:11:31', 'UTC') AS origin_time, toDateTime(CASE WHEN country='US' THEN toString(origin_time, 'PST8PDT') WHEN country='UK' THEN toString(origin_time, 'Europe/London') WHEN country='FR' THEN toString(origin_time, 'Europe/Paris') WHEN country='JP' THEN toString(origin_time, 'Asia/Tokyo') WHEN country='ES' THEN toString(origin_time, 'Europe/Madrid') WHEN country='IT' THEN toString(origin_time, 'Europe/Rome') WHEN country='DE' THEN toString(origin_time, 'Europe/Berlin') WHEN country='MX' THEN toString(origin_time, 'America/Mexico_City') WHEN country='CA' THEN toString(origin_time, 'PST8PDT') WHEN country='IN' THEN toString(origin_time, 'Indian/Cocos') WHEN country='CN' THEN toString(origin_time, 'Asia/Shanghai') WHEN country='AU' THEN toString(origin_time, 'Australia/Canberra') WHEN country='AE' THEN toString(origin_time, 'Asia/Dubai') ELSE toString(origin_time, 'UTC') END) as local_date_time; ps: case里做toDateTime转换，存在问题，换成toString 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea5de9af6c15a6a275f0679373f4d48c/" rel="bookmark">
			clickhouse学习笔记-8-数据采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把数据从一个集群转移到另一个集群 clickhouse-client --host &lt;source&gt; -q "SELECT * FROM test.app FORMAT CSVWithNames" | \ clickhouse-client --host &lt;target&gt; --port 9000 -q "INSERT INTO test.app FORMAT CSVWithNames" ps: https://blog.csdn.net/zhangpeterx/article/details/96494877 clickhouse 同步到MYSQL insert into function mysql('ip_addr:port', 'db_name', 'table_name', 'user_name', 'password') select * from ck_table_name mysql同步到clickhouse insert into ck_db.c_fct_collect_listing( `uuid`, `date` ) SELECT `auuid`, `date` FROM mysql('ip_addr:port','db_name','table_name','user_name','password') clickhouse 导出 clickhouse-client -h 127.0.0.1 -d log -m -u default --password 123456 --query="select * from test where dt&gt;='2018-09-20' and dt&lt;='2018-10-13' order by logTime desc"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea5de9af6c15a6a275f0679373f4d48c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9ecec1b5dbd1dc4155b2be0e51fe403/" rel="bookmark">
			clickhouse学习笔记-7-数据聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数值运算 sum 简单求和
sumWithOverflow
同步求和参数的数据类型，只适用于数字
sumIf 条件求和
ifNull(x, alt)
x - 是否为空值
alt - 为空，函数返回的值
intDivOrZero 除法
round
二、类型判断 ifNull 三、分组 argMin、argMax argMin(arg, val) 取val最小时的arg值。如果有多个arg对应同一个最小值val，取遇到的第一个值，argMax同理 -- 应用 SELECT id, country, argMax(uuid,local_modify_date) AS uuid, argMax(name,local_modify_date) AS name FROM db.table_name GROUP BY id, country 如果存在GROUP BY子句，则在该子句中必须包含一个表达式列表。其中每个表达式将会被称之为“key”。 SELECT，HAVING，ORDER BY子句中的表达式列表必须来自于这些“key”或聚合函数。简而言之，被选择的列中不能包含非聚合函数或key之外的其他列。
如果查询表达式列表中仅包含聚合函数，则可以省略GROUP BY子句，这时会假定将所有数据聚合成一组空“key”。
与SQL标准不同的是，如果表中不存在任何数据（可能表本身中就不存在任何数据，或者由于被WHERE条件过滤掉了），将返回一个空结果，而不是一个包含聚合函数初始值的结果。
在GROUP BY子句中不支持使用Array类型的列。
常量不能作为聚合函数的参数传入聚合函数中。例如： sum(1)。这种情况下你可以省略常量。例如：count()。
NULL 处理 对于GROUP BY子句，ClickHouse将 NULL 解释为一个值，并且支持NULL=NULL。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc714ea39aff2c7d504c500c040d261e/" rel="bookmark">
			clickhouse学习笔记-5-函数整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日期类 时间或日期截取函数（to）—— 返回非日期 函数用途举例结果toYear()取日期或时间日期的年份toYear(toDateTime(‘2018-12-11 11:12:13’)) toYear(toDate(‘2018-12-11’))2018toMonth()取日期或时间日期的月份toMonth(toDateTime(‘2018-12-11 11:12:13’)) toMonth(toDate(‘2018-12-11’))12toDayOfMonth()取日期或时间日期的天（1-31）toMonth(toDayOfMonth(‘2018-12-11 11:12:13’)) toMonth(toDayOfMonth(‘2018-12-11’))11toDayOfWeek()取日期或时间日期的星期（星期一为1，星期日为7）。toDayOfWeek(toDateTime(‘2018-12-11 11:12:13’)) toDayOfWeek(toDate(‘2018-12-11’))2toHour()取时间日期的小时toHour(toDateTime(‘2018-12-11 11:12:13’))11toMinute()取时间日期的分钟toMinute(toDateTime(‘2018-12-11 11:12:13’))12toSecond()取时间日期的秒toSecond(toDateTime(‘2018-12-11 11:12:13’))13toMonday()取时间日期最近的周一（返回日期）toMonday(toDate(‘2018-12-11’)) toMonday(toDateTime(‘2018-12-11 11:12:13’))2018-12-10toTime()将时间日期的日期固定到某一天，保留原始时间toTime(toDateTime(‘2018-12-11 11:12:13’)) 时间或日期截取函数（toStartOf）—— 返回日期 函数用途举例结果toStartOfMonth()取日期或时间日期的月份的第一天，返回日期toStartOfMonth(toDateTime(‘2018-12-11 11:12:13’)) toStartOfMonth(toDate(‘2018-12-11’))2018-12-01toStartOfQuarter()取日期或时间日期的季度的第一天，返回日期toStartOfQuarter(toDateTime(‘2018-12-11 11:12:13’)) toStartOfQuarter(toDate(‘2018-12-11’))2018-10-01toStartOfYear()取日期或时间日期的年份的第一天，返回日期toStartOfYear(toDateTime(‘2018-12-11 11:12:13’)) toStartOfYear(toDate(‘2018-12-11’))2018-01-01toStartOfMinute()截取时间日期到分钟（之后归零），返回日期toStartOfMinute(toDateTime(‘2018-12-11 11:12:13’))2018-12-11 11:12:00toStartOfFiveMinute()截取时间日期到最近的5的倍数分钟（之后归零），返回日期toStartOfFiveMinute(toDateTime(‘2018-12-11 11:12:13’))2018-12-11 11:10:00toStartOfFifteenMinutes()截取时间日期到最近的15的倍数分钟（之后归零），返回日期toStartOfFifteenMinutes(toDateTime(‘2018-12-11 11:12:13’))2018-12-11 11:00:00toStartOfHour()截取时间日期到小时（之后归零），返回日期toStartOfHour(toDateTime(‘2018-12-11 11:12:13’))2018-12-11 11:00:00toStartOfDay()截取时间日期到天（之后归零），返回日期toStartOfDay(toDateTime(‘2018-12-11 11:12:13’))2018-12-11 00:00:00timeSlot()将时间日期中，分钟大于等于30的归于30，分钟数小于30的归为00timeSlot(toDateTime(‘2018-12-11 11:33:13’))2018-12-11 11:30:00 日期或时间日期生成函数 函数用途举例结果now()生成当前时间日期now()2018-12-13 10:10:12today()生成今天的日期today()2018-12-13yesterday()生成昨天的日期yesterday()2018-12-12 类型转化类函数 函数用途举例结果toDecimal32()将数值型或者含有非数字的字符串进行精度保留toDecimal32(23.12291, 3)23.122toDecimal64()将数值型或者含有非数字的字符串进行精度保留toDecimal128()将数值型或者含有非数字的字符串进行精度保留 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb38d53fc8c71ef6fbb6b60a0f9a67ae/" rel="bookmark">
			【缓存应用】谈谈redis应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于redis应用场景总结 1.计数器相关应用场景 高并发的秒杀活动、分布式序列号的生成
限制手机短信发送数量、接口每分钟请求次数
工单号递增计数场景
可以使用redis的 incrby命令实现原子性的递增
2.限时业务应用场景 限时的优惠活动信息、手机验证码
redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。
3.热点数据缓存应用场景 缓存热点数据，启用 allkeys-lru 淘汰策略
系统功能如下：
可以发布文章；可以对文章进行点赞；在首页可以按文章的发布时间或者文章的点赞数进行排序显示； 文章信息 HASH 来存储
文章包括标题、作者、赞数等信息，在 Redis 中使用 HASH 来存储每种信息以及其对应的值的映射
Redis 使用命名空间的方式来实现类似表的功能、命名空间可以扩展树的深度 set test1:test2:test3 123 类似json
键名的前面部分存储空间名，后面部分存储空间 ID，整个组成Hash的健名
由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，
我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。
4.排行榜相关问题应用场景 排行榜方面查询速度普遍在关系型数据库偏慢，可以借助redis的SortedSet进行热点数据的排序。
在活动中，我们需要展示各个部门的点赞排行榜， 所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,
以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，
然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。
5.分布式锁应用场景 使用redis的setnx命令进行
setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行
给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，
这个与定时任务的周期以及定时任务执行消耗时间相关
6.延时操作应用场景 7.分页模糊搜索应用场景 redis的set集合中提供了一个zrangebylex方法，语法如下：
ZRANGEBYLEX key min max [LIMIT offset count]
通过ZRANGEBYLEX zset - + LIMIT 0 10 可以进行分页数据查询，其中- +表示获取全部数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb38d53fc8c71ef6fbb6b60a0f9a67ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c20e02e9010a0e3026bdc51b7035db/" rel="bookmark">
			WindowBuilder的安装、使用与卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装（以mac系统为例，其它系统同理） 1、去官网（https://www.eclipse.org/windowbuilder/download.php）复制WindowBuilder的插件地址。注意：windowbuilder不同版本对系统要求不同，详细查看here，省事的方法是直接复制“Last good build”版本地址
2、点击eclipse 中的 Help --&gt; "Install New Software"，把复制的windowbuildeer链接粘贴在地址栏中并回车，选中检索到的插件，然后点击next、next、同意协议、Finish
3、这时eclipse界面下方就开始下载插件了，待下载完成，会提示重启eclipse，重启之后就可以正常使用了
2、使用 1、创建Application Window类型的java文件
2、点击Design就可以绘图了
3、卸载 1、选中Help --&gt; Install New Software,然后点击“aiready installed”进入查看已经安装插件的界面
2、WindowBuilder包含的有Swing、SWT、Core等三大模块，找到并选中这三个模块。如果不清楚的话在“Provider”查看，选中提供商为“Eclipse WindowBuilder”的全部条目。最后点击卸载并确定重启Eclipse即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1fe3e85dac36015e1fad41da82675f/" rel="bookmark">
			pygame一步步玩转圆、矩形、图像、旋转、透明度alpha、colorkey操作（有完整案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一直在专研pygame，略有心得，也分享了几篇文章，感谢各位朋友支持。
今天，玩转一个非常基础的知识，其实是多个知识点的汇聚，欢迎往下看。
文章目录 一、包含的基础知识点：（一）画圆（二）画矩形（三）图像变化（四）图像透明度（五）设置colorkey健 二、画矩形和圆（一）第一版（二）第二版（三）让圆这部分透明显示，即只显示底色 三、黏贴图像（一）黏贴图像（原始图）（二）错误的操作（三）正确的操作 四、让图像动起来（一）旋转变化（二）透明度变化（三）完整的代码 最后输出的效果图如下：
一、包含的基础知识点： 画圆、画矩形、图像变化、图像移动、设置透明度、设置colorkey等内容。
包含的相关函数如下：
（一）画圆 circle(Surface,color,pos,radius,width=0)
其中第一、二、五个参数根前面的两个方法是一样的，第三参数指定圆形位置，第四个参数指定半径的大小。
（二）画矩形 rect(Surface,color,Rect,width=0)
第一个参数指定矩形绘制到哪个Surface对象上
第二个参数指定颜色
第三个参数指定矩形的范围（left，top，width，height）
第四个参数指定矩形边框的大小（0表示填充矩形）
（三）图像变化 pygame.transform.scale 用于变化图像的大小
pygame.transform.rotate 用于旋转图像
（四）图像透明度 set_alpha(value, flags=0) -&gt; None
set_alpha(None) -&gt; None
设置 Surface 对象的整体透明度（surface alpha），value 参数的范围是 0 ~ 255，0 表示完全透明，255 表示完全不透明。如果传入 None，那么取消 surface alphas 设置。
（五）设置colorkey健 set_colorkey(Color, flags=0) -&gt; None
set_colorkey(None) -&gt; None
设置当前 Surface 对象的 colorkeys，当绘制 Surface 对象时，将所有与 colorkeys 相同的颜色值绘制为透明。 Color 参数可以是 RGB 颜色，也可以是映射后的颜色索引号，如果传入 None，则取消 colorkeys 的设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1fe3e85dac36015e1fad41da82675f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90cd087acf6b2331504a7f0323c3e70f/" rel="bookmark">
			mysqldump 命令参数大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysqldump 是一个数据库备份程序。
mysqldump 客户端执行逻辑备份，生成一组 SQL 语句，可以执行这些语句来重现原始数据库对象定义和表数据。它导出一个或多个 MySQL 数据库进行备份或迁移到另一个 SQL server。mysqldump 命令还可以生成 CSV、其他分隔文本或 XML 格式的输出。
本文对其常用参数总结如下（mysql 版本是 5.7），用户也可以通过 “man mysqldump” 或 “mysqldump --help” 查看其全面的用法。
--host=host_name, -h host_name MySQL 数据库主机地址，默认为 localhost。 示例：mysqldump -uroot -p --host=localhost --all-databases --port=port_num, -P port_num 连接数据库端口号 --user=user_name, -u user_name 指定连接数据库的用户名。 --password[=password], -p[password] 连接数据库的密码 --all-databases, -A 导出全部数据库的全部表。示例：mysqldump -uroot -p --all-databases --databases, -B 导出几个数据库。参数后面所有名字参量都被看作数据库名。 示例：mysqldump -uroot -p --databases test mysql --single-transaction 该选项在导出数据之前，设置事务隔离模式为 REPEATABLE READ，并提交一个 START TRANSACTION SQL 语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。 它只适用于 InnoDB。 本选项和 --lock-tables 选项是互斥的，因为 LOCK TABLES 会使任何挂起的事务隐含提交。 要想导出大表的话，应结合使用 --quick 选项。 示例：mysqldump -uroot -p --host=localhost --all-databases --single-transaction --tables 覆盖 --databases 或 -B 参数，指定需要导出的表名。 示例：mysqldump -uroot -p --host=localhost --databases test --tables test --all-tablespaces, -Y 导出全部表空间。示例：mysqldump -uroot -p --all-databases --all-tablespaces --no-tablespaces, -y 不导出任何表空间信息。示例：mysqldump -uroot -p --all-databases --no-tablespaces --add-drop-database 每个数据库创建之前添加 drop 数据库语句。 示例：mysqldump -uroot -p --all-databases --add-drop-database --add-drop-table 每个数据表创建之前添加 drop 数据表语句。 默认为打开状态，使用 --skip-add-drop-table 取消选项。 示例：mysqldump -uroot -p --all-databases --skip-add-drop-table (取消drop语句) --add-locks 在每个表导出之前增加 LOCK TABLES 并且之后 UNLOCK TABLES。 默认为打开状态，使用 --skip-add-locks 取消选项。 示例：mysqldump -uroot -p --all-databases (默认添加 LOCK 语句)； mysqldump -uroot -p --all-databases --skip-add-locks (取消 LOCK 语句) --allow-keywords 允许创建是关键词的列名字。它由列名前冠以表名实现。 示例：mysqldump -uroot -p --all-databases --allow-keywords --apply-slave-statements 在从库导出时，在 'CHANGE MASTER' 前添加 'STOP SLAVE'，并且在导出的最后添加'START SLAVE'。 示例：mysqldump -uroot -p --all-databases --apply-slave-statements --character-sets-dir=dir_name 字符集文件的目录。 示例：mysqldump -uroot -p --all-databases --character-sets-dir=/usr/local/mysql/share/mysql/charsets --comments, -i 附加注释信息，默认为打开，可以用 --skip-comments 取消。 示例：mysqldump -uroot -p --all-databases (默认记录注释)； mysqldump -uroot -p --all-databases --skip-comments (取消注释) --compatible=name 导出的数据将和其它数据库或旧版本的 MySQL 相兼容。 值可以为 ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options 等。 要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。 示例：mysqldump -uroot -p --all-databases --compatible=ansi --compact 导出更少的输出信息(用于调试)。去掉注释和头尾等结构。该选项使 --skip-add-drop-table --skip-add-locks --skip-comments --skip-disable-keys 生效。 示例：mysqldump -uroot -p --all-databases --compact --complete-insert, -c 使用完整的 insert 语句(包含列名称)。 这么做能提高插入效率，但是可能会受到 max_allowed_packet 参数的影响而导致插入失败。 示例：mysqldump -uroot -p --all-databases --complete-insert --compress, -C 在客户端和服务器之间启用压缩传递所有信息。 示例：mysqldump -uroot -p --all-databases --compress --create-options 在 CREATE TABLE 语句中包括所有 MySQL 特性选项(默认为打开状态)。 示例：mysqldump -uroot -p --all-databases --debug[=debug_options], -# [debug_options] 输出 debug 信息，用于调试。默认值为：d:t:o,/tmp/mysqldump.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90cd087acf6b2331504a7f0323c3e70f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b6b59815d4c9b27769378ba1cc3725/" rel="bookmark">
			Educational Codeforces Round 108 (Rated for Div. 2) 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题链接 A题 Red and Blue Beans 题意：给定\(r\)个红豆，\(b\)个蓝豆，将他们分到任意多个包中，要求每个包中红豆和蓝豆的差值不能超过\(d\)，可以则输出\(YES\)，否则输出\(NO\)。
贪心即可，将较小的那个放到不能放为止，然后在将另外一个顺次放进去。
代码： typedef long long LL; const int N = 200010; int main() { int T; scanf("%d", &amp;T); while (T -- ) { int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); int res = abs(a - b); if (res == 0) puts("YES"); else { int l = min(a, b); int x = res / l; int y = res % l; if (y &gt;= 1) x ++ ; if (x &lt;= c) puts("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62b6b59815d4c9b27769378ba1cc3725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdda8de65aec71100ddc9b95d2c7810/" rel="bookmark">
			Educational Codeforces Round 108 (Rated for Div. 2) A~D题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代佬们关注关注我吧（卑微55555） A题：Red and Blue Beans（思维） 题意：给你r个红色的豆和b个蓝色的豆，你可以创造一个组，该组需要满足至少有一个红豆和一个蓝豆，同时两者的数目差不超过k
思路：
1、k为0那么两种豆的数目相等
2、k不为0，那么c代表abs（r-b）, 然后我们取出r和b的最小值mi，构造每组先放一个红豆和蓝豆，然后再放最多k个数量比较多的那种颜色的豆，这种组合可以有mi组。如果还有豆多余那么就不行，如果中途分组把豆消耗完了就可以。
#include&lt;iostream&gt; using namespace std; #define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t, r, b, k; int main(int argc, char const *argv[]) { IOS cin &gt;&gt; t; while(t--) { cin &gt;&gt; r &gt;&gt; b &gt;&gt; k; int judge = 1; if (k == 0 &amp;&amp; r != b)//必须相等 { judge = 0; } else if (r != b) { int mi = r &lt; b?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bdda8de65aec71100ddc9b95d2c7810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c7a67d78088c0f92d967b55d1de1ab/" rel="bookmark">
			2021-4-29【C】【字符串排序】【从键盘输入10个字符串，按照字典顺序将其排序输出(二维字符数组)】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #include&lt;string.h&gt; void sort(char (*a)[105]) //const char *ptr //定义一个指向字符常量的指针。 //指针指向可以修改，指针指向的值不可以修改。 //char const *ptr //与1等价 //char * const ptr //定义一个指向字符的指针常数。 //指针指向不能修改，指针指向的值可以修改 { int i=0,j=0; char temp[105];//中间量 for(j=0;j&lt;9;j++){ for(i=0;i&lt;9-j;i++) { if(strcmp(a[i],a[i+1]) &gt; 0)//比较 { strcpy(temp, a[i]);//小的在前 strcpy(a[i], a[i+1]); strcpy(a[i+1], temp); } } } } int main() { char a[10][105] = {0};//二维数组初始化 int i; for(i=0;i&lt;10;i++) { scanf("%s", a[i]);//输入 //gets(a[i]); } sort(a);//排序 for(i=0;i&lt;10;i++) { printf("%s\n", a[i]); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b0e2e1e6e3e56a59ebfb3682b284ce/" rel="bookmark">
			linux删除test文件夹,Linux删除目录下的文件的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux删除目录下的文件的几种方法
删除当前目录下的文件
1.rm -f *
#最经典的方法，删除当前目录下的所有类型的文件
2.find . -type f -delete或find . -type f -exec rm -f {} \;
#用find命令查找普通文件并删除or用find命令的处理动作将其删除
3.find . -type f | xargs rm -f
#用于参数列表过长；要删除的文件太多
4.rm-f find . -type f
#删除全部普通文件
5.for delete in ls -l;do rm -f * ;done
#用for循环语句删除当前目录下的所有类型的文件
删除指定目录下的文件
1.rm -f 指定目录*
#最经典的方法，删除指定目录下的所有类型的文件
2.find 指定目录 -type f -delete或find 指定目录 -type f -exec rm -f {} \;
#用find命令查找指定目录下的所有普通文件并删除or用find命令的处理动作将其删除
3.find 指定目录 -type f | xargs rm -f
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b0e2e1e6e3e56a59ebfb3682b284ce/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/206/">«</a>
	<span class="pagination__item pagination__item--current">207/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/208/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>