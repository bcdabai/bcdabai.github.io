<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程大白的博客">
		<meta property="og:title" content="编程大白的博客" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/236406da7031552a6de8d2adc3fdb1d8/" rel="bookmark">
			毕业设计项目分享40个【源码&#43;论文】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 前言
🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的java web缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的java web管理系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享41个优质java web毕业设计项目，需要的自取。
题目1 : 基于SSM的毕业设计管理系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、个人信息、学生管理、教师管理、文件模板管理 、论坛管理、系统管理、在线选题管理、开题报告管理、中期报告管理、毕业论文管理
教师管理：个人中心、个人信息、文件模板管理、在线选题管理、老师答疑管理、开题报告管理、中期报告管理、毕业论文管理、学生提题管理、论文进度管理
学生管理：个人中心、个人信息、学生提问管理、老师答疑管理、开题报告管理、中期报告管理、毕业论文管理、学生提题管理、论文进度管理、我的收藏管理
题目2 : 基于SSM的病人跟踪治疗信息管理系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、病人管理、病例采集管理、预约管理、医生管理、上传核酸检测报告管理、上传行动轨迹管理、分类管理、病人治疗状况管理、留言板管理、系统管理
病人：首页、个人中心、病例采集管理、预约管理、医生管理、上传核酸检测报告管理、上传行动轨迹管理、病人治疗状况管理
前台首页：首页、医生、医疗资讯、留言反馈、个人中心、后台管理、在线咨询
题目3 : 基于SSM的大学生兼职跟踪系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、商家管理、学生管理、兼职招聘管理、兼职应聘管理、商家投诉管理、投诉处理管理、论坛管理、系统管理学生后台模块：首页、个人中心、兼职应聘管理、商家投诉管理、我的收藏管理，商家；首页、个人中心、兼职招聘管理、兼职应聘管理、投诉处理管理学生前台：首页、兼职招聘、兼职论坛、系统公告、我的、跳转到后台 题目4 : 基于SSM的大学生企业推荐系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、学生管理、企业管理、招聘信息管理、个人简历管理、应聘职位管理、评价企业管理、交流论坛、系统管理学生：首页、个人中心、招聘信息管理、个人简历管理、应聘职位管理、评价企业管理企业：首页、个人中心、招聘信息管理、个人简历管理、应聘职位管理、评价企业管理前台首页：首页、招聘信息、个人简历、交流论坛、个人中心、后台管理 题目5 : 基于SSM的电影院在线售票系统 🥇 题目综合评分(每项满分5分)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/236406da7031552a6de8d2adc3fdb1d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1947cfec766874adb3e2ba8f5c4c985/" rel="bookmark">
			k8s学习-通过Service访问Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设Pod中的容器很可能因为各种原因发生故障而死掉。Deployment等Controller会通过动态创建和销毁Pod来保证应用整体的健壮性。换句话说，Pod是脆弱的，但应用是健壮的。
每个Pod都有自己的IP地址。当Controller用新Pod替代发生故障的Pod时，新Pod会分配到新的IP地址。这样就产生了⼀个问题：如果⼀组Pod对外提供服务（比如HTTP），它们的IP很有可能发⽣变化，那么客户端如何找到并访问这个服务呢？Kubernetes给出的解决方案是Service。
1.1 Service是什么 由于Pod的动态性，Service解决了一个重要问题：如果一组Pod（称为“后端”）为其他Pod（称为“前端”）提供服务，前端如何找到并连接到后端的IP地址。Kubernetes中的Service为此提供了解决方案，通过提供稳定的虚拟IP和DNS，使服务发现变得简单而可靠。
1.2 Service的几种类型 （1）ClusterIP
ClusterIP 服务是 Kubernetes 的默认服务。它给你一个集群内的服务，集群内的其它应用都可以访问该服务，但是集群外部无法访问它。
（2）NodePort
除了只在内部访问的服务，我们总有很多是需要暴露出来公开访问的服务吧。在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过:NodePort来访问这些服务。
（3）LoadBalancer
LoadBalancer 服务是暴露服务到 internet 的标准方式，它借助Cloud Provider创建一个外部的负载均衡器，并将请求转发到:NodePort（向节点导流）。
1.3 ClusterIP 先创建Deployment。
vi httpd.yaml
apiVersion: apps/v1 kind: Deployment metadata: name: httpd spec: replicas: 3 selector: # 添加这一行，定义标签选择器 matchLabels: run: httpd template: metadata: labels: run: httpd spec: containers: - name: httpd image: httpd ports: - containerPort: 80 我们启动了三个Pod，运行httpd镜像，label是run: httpd，Service将会用这个label来挑选Pod。
kubectl get pod -o wide Pod分配了各自的IP，这些IP只能被KubernetesCluster中的容器和节点访问，如图所示。
[root@k8s-master ~]# kubectl get pod -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES httpd-ff8d77b9b-dpp79 1/1 Running 1 43h 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1947cfec766874adb3e2ba8f5c4c985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35541b87f9e3a66474a91ae31bb5b9a0/" rel="bookmark">
			怎 么 优 化 H5 让 它 可 以 在 300ms 之 内
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		减少HTTP请求数量：将多个小的CSS和JavaScript文件合并为一个文件，减少HTTP请求的数量。可以使用工具如Webpack、Parcel等打包工具对代码进行打包合并。
使用缓存：通过设置适当的缓存策略，让浏览器缓存静态资源（如CSS、JavaScript、图片等），减少不必要的网络请求。可以通过设置HTTP响应头中的Cache-Control、Expires等字段来控制缓存。
压缩资源：使用压缩工具对CSS和JavaScript文件进行压缩，可以减小文件大小，提高加载速度。常用的压缩工具包括UglifyJS、Terser、CSSNano等。
预加载和预连接：使用 声明需要提前加载的资源，通过 声明需要预先建立连接的域名，以加快资源的获取速度。
延迟加载和按需加载：对于非关键的资源，可以使用延迟加载或按需加载的方式，即在需要时再加载，避免一次性加载过多资源。
图片优化：对图片进行优化，包括选择合适的图片格式（如JPEG、PNG、WebP等），压缩图片大小，使用适当的图片延迟加载。
减少DOM操作：尽量减少过多的DOM操作，因为DOM操作会触发回流和重绘，影响页面加载速度。可以使用事件委托、批量操作等方式来优化DOM操作。
使用CDN加速：使用内容分发网络（CDN）来加速资源的传输，将资源分发到离用户较近的节点，减少网络延迟。
服务器优化：确保服务器的配置和性能符合要求，使用缓存技术、负载均衡等方式来提高服务器的响应速度。
需要注意的是，实际的加载时间受多个因素影响，如网络状况、设备性能等。以上只是常见的一些优化措施，具体的优化方案还需要根据具体的应用和需求进行调整和优化。可以结合性能分析工具（如Lighthouse、WebPageTest等）来评估和监测页面的性能，并进行相应的优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75627e742c5ba6fab3c2f3c2abf02a0/" rel="bookmark">
			计算机网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eNSP 实践 依赖libcup，virturalbox软件
百度搜索华为路由器常用命令
https://support.huawei.com/enterprise/zh/doc/EDOC1100041712/3488313c#display_ap_aplist
理论概念 文章不足补充 ping工作原理 - 知乎
1、无报文对比，与arp差异
2、底层调用分析，和原理图对照
3、内核对icmp协议实现原理
底层调用
strace -e trace=%net ping -c 3 ip strace -e trace=%net arp man protocols 查看协议支持情况
术语 路由表
静态、动态路由，rip、ospf路由协议等
创建端口-&gt;设置ip、掩码
以太网二层交换机 对功能进行全面描述不累述了，没实践作寄托也理解不了，更不清楚内核网络协议栈工作原理
vlan配置
创建interface，配置vlan
端口类型
vlan设备可直接通信
不同设备就需要三层交换机
1、子接口路由
2、vlanif路由
命令操作 查看ip，路由信息
display ip routing-table display interface brief 网络排查 linux内核特性 IPv4 send 内核源码
netfilter 插入的5个检查点
iptable 内置的nat表、mangle表、filter表
iptable设置规则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0155adb23462d40a2a1f9e857a530291/" rel="bookmark">
			Git分布式版本控制系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 是一个分布式版本控制系统，用于管理和跟踪文件的变化。它具有以下基本概念：
仓库（Repository）：Git 仓库是存储项目文件和版本历史的地方。仓库可以是本地的（本地仓库）或远程的（远程仓库）。
提交（Commit）：提交是将文件的更改记录到仓库中的操作。每个提交都有一个唯一的标识符（SHA-1 哈希值），用于引用该提交。
分支（Branch）：分支是基于某一提交创建的一个独立的工作区。使用分支可以同时进行多个并行的开发工作，每个分支都有自己独立的提交历史。
主分支（Master）：主分支是默认的主要开发分支，通常用于发布稳定版本。
远程仓库（Remote）：远程仓库是分布在不同地点的仓库副本，用于协作开发和备份代码。
使用 Git 的基本操作包括：
初始化仓库：使用命令 git init 在当前目录下创建一个新的 Git 仓库。
添加文件：使用命令 git add &lt;file&gt; 将文件添加到暂存区，准备提交。
提交更改：使用命令 git commit -m "&lt;message&gt;" 将暂存区的文件更改提交到仓库，并附上一条描述性信息。
查看提交历史：使用命令 git log 查看仓库的提交历史。
创建分支：使用命令 git branch &lt;branch-name&gt; 创建一个新的分支。
切换分支：使用命令 git checkout &lt;branch-name&gt; 切换到指定分支。
合并分支：使用命令 git merge &lt;branch-name&gt; 将指定分支的更改合并到当前分支。
克隆远程仓库：使用命令 git clone &lt;remote-url&gt; 克隆远程仓库到本地。
推送更改：使用命令 git push &lt;remote&gt; &lt;branch&gt; 将本地仓库的更改推送到远程仓库。
这些只是Git的基本概念和使用方式，Git还有很多高级功能和命令可以进一步探索和学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f220b40cc93e1c6d583a39f309246d/" rel="bookmark">
			CentOS 7 部署 ZeroTier Moon 节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZeroTier是一套使用UDP协议构建的SD-WAN网络软件，其主要有三部分组成：行星服务器Planet、月亮服务器Moon、客户端节点Leaf，行星服务器是ZeroTier的根节点，可以采用ZeroTier官方的服务器，也可以使用开源代码自行搭建。
月亮服务器介于行星与客户端之间，官方行星都在国外，因此可以就近公网搭建月亮服务器，客户端可以优先使用延迟更低的月亮节点进行P2P打洞或者网络中转。
客户端节点既可以安装在客户端进行远程网络接入，也可以部署后开启路由转发功能，配置静态路由后实现两个网络组网
本例是在阿里云上面操作的：IP：114.55.84.170
一、Moon节点服务器安装
1、安装
curl -s https://install.zerotier.com/ | sudo bash 2、启动
systemctl start zerotier-one systemctl enable zerotier-one 3、加入网络
zerotier-cli join 363c67c55a92a902 4、ZeroTier 官网勾选 Auth
5、生成节点配置
cd /var/lib/zerotier-one/ zerotier-idtool initmoon identity.public &gt; moon.json 6、编辑
vim moon.json # 修改 "stableEndpoints": ["114.55.84.170/9993"] 7、生成签名，成功后会出现一个 000000b8cdf1fe5d.moon 文件，这个文件名前6位0是固定的，后面b8cdf1fe5d其实就是官网上面设备ID
zerotier-idtool genmoon moon.json 8、 配置 moons.d 目录
mkdir moons.d mv 000000b8cdf1fe5d.moon moons.d/ 9、重启
systemctl restart zerotier-one 10、阿里云放行 UDP 9993
二、Windows 客户端
1、打开命令行运行，其中的 b8cdf1fe5d 就是上面的ID值
zerotier-cli orbit b8cdf1fe5d b8cdf1fe5d # 显示 200 orbit OK 2、重启 Zerotier
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87f220b40cc93e1c6d583a39f309246d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2faf4d7d1ae29685e441108b708884/" rel="bookmark">
			Compose | UI组件(十二) | Lazy Layout - 列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言LazyListScope作用域 用来干什么？LazyColumn组件含义？LazyColumn的基本使用LazyColumn Padding设置边距LazyColumn 设置边距 (contentPadding)LazyColumn 为每个子项设置边距 (Arrangement.spacedBy())LazyColumn 根据 rememberLazyListState 记录item位置根据 items函数 新增 一个key参数，增加和删除操作时，提高页面性能问题 LazyRow的含义LazyRow的使用 总结 前言 现在应用市场上很多产品都少不了列表展示需求场景，例如通讯录，短信，音乐列表等等。
所以本篇文章讲解的组件 - 列表 （LazyList 和 LazyRow ）
在了解 LazyList 和 LazyRow 之前，我们先了解下 LazyListScope作用域
LazyListScope作用域 用来干什么？ LazyColumn 和 LazyRow 内部都是继承 LazyList组件 实现，但 LazyList 不能直接使用
LazyList 的 content 是一个 LazyListScope.() -&gt; Unit 类型的作用域
LazyListScope 提供了 item , items(Int) , item(List) , itemsIndexed(List) 扩展函数来展示列表内容
item：展示单项数据
items(Int)：展示多项整型数据
items(List) 展示一组集合数据
itemsIndexed(List) 展示一组集合数据，并且带有下标
val list = ('A'..'Z').map { it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2faf4d7d1ae29685e441108b708884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81f2fecb9f0a4701ecd40fffeb0227a/" rel="bookmark">
			常用芯片学习——CD4094芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CD4094 8位移位寄存器/3态输出缓冲器 使用说明 CD4094是由一个 8 位串行移位寄存器和一个 3 态输出缓冲器组成的 CMOS 集成电路。寄存器带有存储锁存功能，集成电路根据 STROBE 信号确定锁存器是否接收移位寄存器各位数据，数据是否由锁存器传输到 3 态输出缓冲器
当 STROBE 为 0 时，输入的锁存数据是移位寄存器每一位的输出。当 STROBE 为 1 时，数据通过锁存器传输到 3 态输出缓冲器。当 OUTPUT ENABLE 为 1 时，数据传输到输出缓冲器中，转换为并联 常见封装类型 SOP-16
TSSOP-16
DIP-16
引脚说明 芯片时序图 总结：当OE引脚时能以及STR引脚拉高时，在输入时钟的上升沿读取输入数据的电平信号，在输出引脚进行输出，此时八个输出引脚都输出相同电平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0fb16c5a84c586b08ed4fa43b2f4ed/" rel="bookmark">
			秋招面试—CSS篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 CSS面试题 1.CSS可继承属性有哪些？ 文字相关：font-famliy 、font-weight 、font-size 、font-style文本相关：text-indent（首行缩进） 、text-align（水平对齐） 、line-height 、text-transfrom（文本大小写） 、word-sacping (字符间距)、letter-spacing 、color元素可见性：visibility列表布局：list-style光标：cursor 2.display的属性值有哪些？ none：元素不显示
block：块级元素
inline：行内元素
inline-block：行内块元素
table：表格
list-item：块类型元素
inherit：从父级继承display属性
🌰对list-item了解吗？
3.display 的block、inline、inline-block有什么区别？ block：块级元素，独占一行，多个元素另起一行。
inline：行内元素，宽高，水平方向的margin、padding都无效。
inline-block：对象设置为inline对象，对象内容作为为block呈现。
4.隐藏元素的方法有哪些？ display:none
visibility:hidden
opacity:0
position:absolute
clip-path:
transform:scale(0,0)
z-index:负值
5.link和import的区别？ &lt;1&gt;.link 是XHTML标签，不仅能加载CSS，还能加载RSS；而import只能加载CSS.
&lt;2&gt;.引入CSS，页面载入时同时加载；import需要等待页面载入之后才加载。
&lt;3&gt;.link 可以通过JS控制DOM来改变样式，而import不行。
🌰什么是RSS? 怎么实现通过JS控制DOM来改变样式？
6.display:none 和 visibility:hidden 的区别 display:none 隐藏的元素会从渲染树上完全消失，不会占用任何空间，它的子元素也会跟着一起消失；
visibility:hidden 隐藏的元素不会从渲染树上完全消失，会占用一定的空间，如果想让子元素显示，可以给子元素设置visible
7.对盒模型的理解？ 普通标准盒模型一般由四部分组成，content、padding、border、margin
标准盒模型：宽高的范围只包含了 content;
IE盒模型：宽高的范围为content、padding、border；
可以通过修改 box-sizing: content-box/border-box改变盒模型。
8.CSS3中的新特性 圆角边框：border-radio
文字特效：text-shadow
文字渲染：text-decoration
阴影与反射：shadoweflect
多列布局：mult-column layout
线性渐变：gradient
旋转：transform
9.伪元素（::）和伪类（:）有什么区别？ 伪元素（::）：以双冒号形式存在，在元素前后插入新的元素或样式，只存在于页面中，不存在于DOM 中;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0fb16c5a84c586b08ed4fa43b2f4ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a81bb9b6d234653fd78a2ff5d46d42/" rel="bookmark">
			基于ssm的车辆运输管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、技术介绍 Java语言SSM框架SpringBoot框架JSP页面Mysql数据库IDEA/Eclipse开发 有需要的同学，源代码和配套文档领取，加文章最下方的名片哦~
二、资料介绍 完整源代码（前后端源代码+SQL脚本）配套文档（LW+PPT+开题报告）远程调试控屏包运行 三、项目演示视频 10557_ssm400车辆运输管理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c5e1c81c8a73a5e2fb5a9321c515341/" rel="bookmark">
			基于ssm vue的电商购物网站的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、技术介绍 Java语言SSM框架SpringBoot框架JSP页面Mysql数据库IDEA/Eclipse开发 有需要的同学，源代码和配套文档领取，加文章最下方的名片哦~
二、资料介绍 完整源代码（前后端源代码+SQL脚本）配套文档（LW+PPT+开题报告）远程调试控屏包运行 三、项目演示视频 10556_ssm399电商购物网站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcca8e8580570858adf069b78d8aa69b/" rel="bookmark">
			App测试中ios和Android有哪些区别呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		App测试中，大家最常问到的问题就是：ios和 Android有什么区别呢？
在Android端，我们经常会使用 JavaScript、 HTML、 CSS等技术来编写一些简单的 UI界面。而 iOS端，我们经常会使用到 UI设计、界面布局、代码结构、 API等技术来开发一款 App。
那究竟有什么区别呢？作为一名开发者，应该了解一些基础知识，这样在开发的时候才不会迷失方向。本文将为大家详细介绍下 iOS和 Android端的区别，以及各自的开发语言，为大家做一些软件测试相关的参考。
首先我们要了解下两个端开发语言的基本语法。
类型
在 iOS和 Android中，我们使用的都是16位的字符集，这就意味着，在两个系统中，苹果使用的是相同的字符集。但 Android端可以使用32位或者64位，而 iOS端只能使用16位或32位。
由于字符集的不同，在两个系统中，代码所使用的类型也不同。Android端可以使用 char、 int、 long、 float等类型;而 iOS端只能使用 int类型。
此外，两个系统的指令集也不相同， Android端可以使用 std:: dex来创建和操作变量；而 iOS端只能使用 std:: dex来创建和操作变量。
参数
在 iOS端，我们经常会使用 applet ()函数来处理一些小的请求，或者是用函数来解决一些简单的问题。
比如在 iOS中，有一个名为 home的函数，它是用来给我们提供一些访问权限的，比如：访问某些 App，可以调用该函数来获取对应权限。因此，我们可以在 home中调用某个 API。
而在 Android端，我们最常用到的是 API class，它是用来封装一系列的接口，比如：resources、 storage等。
变量
变量是系统变量，在 Android端可以使用 bool关键字，在 iOS端可以使用 number关键字。在 JavaScript中，变量也可以使用关键字来访问，但是只能使用 number、 numset或 float来访问。所以在 JavaScript中，变量不是系统变量，而是系统函数。
函数
对于 iOS，函数是用来与其他开发语言进行交互的函数，函数的主要作用是接收用户输入并返回给用户。Android端则与 iOS相反，它没有函数的概念，它所有的操作都是由一个方法来实现的，所以在 Android端编写应用程序时，需要编写大量的方法，来实现基本的操作。
例如：对于一个图片，我们可以使用一个方法来读取图片并返回给用户。Android端比较常用的函数有：
而 iOS端则使用方法更加灵活，可以使用各种方法来完成用户所需要实现的功能。例如：对于一个视频播放器，我们可以使用 API进行视频播放；对于一个电话号码注册工具，我们可以使用 API来完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcca8e8580570858adf069b78d8aa69b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082cd3771304d2e09d0cda8db67fa8e0/" rel="bookmark">
			707. 设计链表(力扣刷题)（C语言题解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人博客主页：https://blog.csdn.net/2301_79293429?type=blog
专栏：https://blog.csdn.net/2301_79293429/category_12545690.html
题目链接： 707. 设计链表 - 力扣（LeetCode） 该题为中等题，包括了对链表的大部分常用操作，更改真的很烦，因为它很长，链表题目也不方便调试，不知道哪里有问题，你只有一点一点的对比代码才找得到错哪
AC代码： /*一定要建立虚拟头节点，方便的多---&gt;统一操作，避免每次都要将头节点单独讨论*/ typedef int VALTYPE;/*方便更改数据类型*/ /*链表的基本创建*/ typedef struct MyLinkedList { VALTYPE val; struct MyLinkedList* next; }MyLinkedList; MyLinkedList* myLinkedListCreate() { MyLinkedList* head=(MyLinkedList*)malloc(sizeof(MyLinkedList)); head-&gt;val=0; head-&gt;next=NULL; return head; } int myLinkedListGet(MyLinkedList* obj, int index) { /*这里的obj是我们创建的虚拟头节点，所以要令p=obj-&gt;next*/ MyLinkedList* p=obj-&gt;next; /*只是创建了一个指针变量，不需要动态开辟一块空间*/ int i; for(i=0;p!=NULL;i++) { if(i==index) return p-&gt;val; if(p-&gt;next==NULL) return -1; p=p-&gt;next; } return -1; } void myLinkedListAddAtHead(MyLinkedList* obj, int val) { MyLinkedList* p1=(MyLinkedList*)malloc(sizeof(MyLinkedList)); /*创建了一个结构体，需要动态开辟一块空间*/ p1-&gt;val=val; p1-&gt;next=obj-&gt;next; /*注意顺序，要先将新节点的next指向obj的next，再更新obj的next*/ obj-&gt;next=p1; } void myLinkedListAddAtTail(MyLinkedList* obj, int val) { /*正确写法*/ MyLinkedList* p=obj;/*不是obj-&gt;next了，因为也要对头节点进行判断是否为null*/ for(int i=0;p-&gt;next!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082cd3771304d2e09d0cda8db67fa8e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f64269165b8eb0e344ecbdcfa6d5bba/" rel="bookmark">
			STM32与FPGA实现以太网功能--web、UDP、tcp测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web网管程序在ETH工程已经做好并验证完成了，现在STM32+FPGA实现ping功能，那么web功能应该一样能实现
问题1：浏览器输入192.168.1.30，能出现登入界面，但是输入密码点击没反应，果然没有一帆风顺的。
原因：发现有一个设备正常，另一个设备通过TFTP下发web网页偶尔正常。打印排查下，发现读网页大小不对（估计用W25Q16弄的文件系统哪里bug，记录下，等以后处理）
问题2：web网管有的卡，登入界面不是很流畅
原因：浏览器下发命令，STM32上传web数据帧，网页数据比较大，有10K以上，需要发送10帧以上数据，STM32与FPGA数据传输效率不行，
解决方法：
1、FSMC驱动速率尽可能快，减少与FPGA通信时间
/* ComSpaceTiming */ ComSpaceTiming.SetupTime = 0; ComSpaceTiming.WaitSetupTime = 2; ComSpaceTiming.HoldSetupTime = 2; ComSpaceTiming.HiZSetupTime = 1; /* AttSpaceTiming */ AttSpaceTiming.SetupTime = 0; AttSpaceTiming.WaitSetupTime = 2; AttSpaceTiming.HoldSetupTime = 2; AttSpaceTiming.HiZSetupTime = 1; 2、STM32网络输出等待FPGA发送完（数据频率快，可能出现丢包现象）
uint8_t fpgaBuf[1600] = {0}; uint8_t fpga_SendPacket(struct pbuf *p) { struct pbuf* q = NULL; uint8_t regData = 0; uint16_t txLen = 0; xSemaphoreTake(FSMC_Handle, 1000); regData = fpga_One_read(FPAG_TX_ISR); while((regData &amp;0X01)==1)//FPGA中有未发送完成数据 { xSemaphoreGive( FSMC_Handle );//给出互斥量 // printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f64269165b8eb0e344ecbdcfa6d5bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb2e43c0d112f8b21691dc8afde6a03/" rel="bookmark">
			Qt 基础之QDataTime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 基础之QDataTime 引言一、获取(设定)日期和时间二、时间戳三、时间计算 (重载运算符) 引言 QDataTime是Qt框架中用于处理日期和时间的类。它提供了操作和格式化日期、时间和日期时间组合的功能。QDataTime可以用于存储和检索日期和时间、比较日期和时间、对日期和时间执行算术操作以及将日期和时间转换为不同的格式。(注：QDateTime不包括闰秒。)
一、获取(设定)日期和时间 获取当前日期和时间：
#include "mainwindow.h" #include &lt;QApplication&gt; #include &lt;QDateTime&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); QDateTime currentDateAndTime = QDateTime::currentDateTime(); // 获取当前日期和时间 qDebug("Current date and time: %s", currentDateAndTime.toString().toUtf8().constData()); return a.exec(); } 修改时间格式：currentDateAndTime.toString("yyyy.MM.dd hh:mm:ss")
更多格式可参考Qt Creator中的帮助：QString QDateTime::toString(QStringView format) const
获取UTC时间：QDateTime::currentDateTimeUtc();
UTC与本地时间的转换：toUTC() - toLocalTime()
QDateTime Data(QDate(2024, 1, 2), QTime(8, 30, 0)); Data = Data.toUTC(); qDebug() &lt;&lt; Data; Data = Data.toLocalTime(); qDebug() &lt;&lt; Data; 使用其构造函数或set函数设定时间：QDateTime Data(QDate(2024, 1, 2), QTime(8, 30, 0));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bb2e43c0d112f8b21691dc8afde6a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283efd82f810a77e056a7431d75ad034/" rel="bookmark">
			systemd：service与target使用及相关命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 unit1.1 unit常用命令 二、 service系统服务2.1 unit service配置文件2.1.1 [Unit]区块2.1.2 [Service]区块2.1.3 [Install]区块2.1.4 示例介绍 2.2 service常用命令 三、target3.1 tartget有关命令 四、其他系统命令4.1 systemctl 相关系统管理命令4.2 journalctl 相关命令4.3 systemd-analyze 分析系统启动 传统的Linux系统启动过程主要由著名的init进程（也被称为SysV init启动系统）来处理，而基于init的启动系统被认为有效率不足的问题，systemd是Linux系统机器的另一种启动方式，宣称弥补了以传统Linux SysV init为基础的系统的缺点；Systemd是用来启动守护进程，已成为大多数发行版的标准配置。
本文主要介绍systemd相关命令以及配置。
一、 unit Systemd可以管理所有系统资源，不同的资源统称为 Unit（单位）,Unit一共分成以下12种。其中最重要的是系统服务（Service ）和Target，本文主要介绍这两个。
Service unit：系统服务
Target unit：多个Unit构成的一个组
Device Unit：硬件设备
Mount Unit：文件系统的挂载点
Automount Unit：自动挂载点
Path Unit：文件或路径
ScopeUnit：不是由Systemd启动的外部进程
Slice Unit：进程组
Snapshot Unit：Systemd快照，可以切回某个快照
Socket Unit：进程间通信的socket Swap Unit：swap文件 Timer Unit：定时器
1.1 unit常用命令 这里只列出可能常用的unit list相关命令
#汇总unit系统启动状态 $ systemctl status #显示单个Unit的状态 $ sysystemctl status network.service #列出正在运行的Unit $ systemctl list-units #列出所有Unit，包括没有找到配置文件的或者启动失败的 $ systemctl list-units --all #列出所有没有运行的Unit $ systemctl list-units --all --state=inactive #列出所有加载失败的Unit $ systemctl list-units --failed #列出所有正在运行的、类型为service的Unit $ systemctl list-units --type=service 二、 service系统服务 service作为unit特殊的一种，日常自定义添加系统服务，其配置过程是必不可少的，因此需要熟悉配置的常用属性。这里对这个常用的service系统服务单独讲解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283efd82f810a77e056a7431d75ad034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8202bb5984da49c655e8f6ee4ddbc896/" rel="bookmark">
			C系列-自定义类型：结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 会编程的果子君
​💫个人格言:“成为自己未来的主人~” 结构体类型的声明 前面我们在学习操作符的时候，已经学习了结构体的知识，这里我们稍微复习一下。
结构体回顾 结构是一些值的集合，这些值称为成员变量，结构的每个成员可以是不同类型的变量
结构的声明 struct stg { member - list; }variable-list; 假如描述一个学生
struct stu { char name[20];//名字 int age;//年龄 char sex[5];//性别 char id[50];//学号 }; 结构体变量的创建和初始化 #include&lt;stdio.h&gt; struct stu { char name[20]; int age; char sex[20]; char id[20]; }; int main() { /* * 第一种 struct stu s = { "张三",20,"男","2023631002" }; printf("%d", s.age); printf("%s", s.name); printf("%s", s.sex); printf("%s", s.id); */ //第二种 struct stu s2 = { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8202bb5984da49c655e8f6ee4ddbc896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c576145fa340b8fe13721cd4ca2d51cd/" rel="bookmark">
			Python XPath解析html出现â解决方法 html出现&amp;#123；解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 爬网页又遇到一个坑，老是出现â乱码，查看html出现的是&amp;#数字;这样的。
网上相关的“Python字符中出现&amp;#的解决办法”又没有很好的解决，自己继续冲浪，费了一番功夫解决了。
这算是又加深了一下我对这些iso、Unicode编码的理解。故分享。
问题 用Python的lxml解析html时，调用text()输出出来的结果带有â这样的乱码：
网页原页面展示：
爬取代码：
url = "xxx" response = requests.request("GET", url) html = etree.HTML(response.text) # 直接调用text函数 description = html.xpath('//div[@class="xxx"]/div/div//text()') # 直接打印 for desc in description: print(desc) 原因 不用说自然是编码的问题。下面教大家排查和解决。
排查与解决 首先查看返回的响应是如何编码的：
response = requests.request("GET", url, proxies=proxy) # 得到响应之后，先检查一下它的编码方式 print(response.encoding) 结果如下：
然后根据这个编码的方式再来解码：
html = etree.HTML(response.text) description = html.xpath('//div[@class="xxx"]/div/div//text()') for desc in description: # print(desc) # 根据上面的结果，用iso88591来编码，再解码为utf-8 print(desc.encode("ISO-8859-1").decode("utf-8")) 结果如下：
完整代码：
url = "xxx" response = requests.request("GET", url) print(response.encoding) html = etree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c576145fa340b8fe13721cd4ca2d51cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d0d4ba9556208bcb68862730e554e8c/" rel="bookmark">
			wrappedComponentRef和ref的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wrappedComponentRef 是在使用高阶组件 (Higher-Order Component) 包装组件时的一个 prop，它用于引用被包装的组件实例。
ref 是 React 提供的用于访问 DOM 元素或者组件实例的属性。在创建组件时，可以给组件添加一个 ref 属性，然后通过该属性来获取组件实例或者 DOM 元素。
两者的区别如下：
用法不同：wrappedComponentRef 是高阶组件提供的一个特殊 prop，用于引用被包装的组件实例。ref 是 React 提供的标准属性，用于获取组件实例或者 DOM 元素。作用不同：wrappedComponentRef 主要用于高阶组件内部对被包装组件的引用，而 ref 主要用于在组件外部对组件实例或者 DOM 元素的引用。使用场景不同：wrappedComponentRef 主要在需要对被包装组件进行操作或者在高阶组件内部引用被包装组件时使用。ref 主要在需要从组件外部获取组件实例或者 DOM 元素时使用。 总的来说，wrappedComponentRef 是高阶组件特有的属性，主要用于引用被包装组件实例，而 ref 是 React 提供的标准属性，用于获取组件实例或者 DOM 元素。wrappedComponentRef 是在使用高阶组件 (Higher-Order Component) 包装组件时的一个 prop，它用于引用被包装的组件实例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6852cdf31e76311e9724311c89c81c53/" rel="bookmark">
			【vue】v-for 使用 Array.prototype.reverse() 的无限更新循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 v-for="item in items.reverse()" [Vue 警告] 组件渲染函数中可能存在无限更新循环。infinite loop update
Array.prototype.reverse 实际上修改了它应用于 的数组.
Vue 获取此更改并同时触发 v-for重新评估，触发另一个 .reverse() .这会触发 Vue 重新渲染，导致 .reverse()
要解决此问题，请使用 computed items[] 的浅拷贝上的属性(例如，使用 Array 解构 […this.items] 作为反向列表:
computed: { itemsReverse() { return [...items].reverse() } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3c6df78b739a3f2e3c3649376f6271/" rel="bookmark">
			CSS详细基础（七）圆角和阴影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		圆角和阴影是CSS3新增的样式。
一.圆角边框原理 只需要在已有的盒子标签里面添加属性如下即可：
border-radius:10px; 原理是，椭圆与边框的交集所产生的效果。
二.圆角边框使用 单位可以像上述那样，直接写成像素；亦可像如下这样写成百分比的形式：当比例为50%时，即半径与矩形的一半相等——即为圆形（此时是宽度的一半！）
border-radius:50%; 如果想做出圆角矩形，则需要设置为高度的一半。 亦可给四个角设置不同的圆角：其值对应为从左上角开始的顺时针。
border-radius:10px 20px 30px 40px; 亦可写成两种对应方式，分别表示主对角线和次对角线的两个角~
border-radius:10px 20px; 也可以分别单独写4个角：
border-top-lefr-radiusborder-top-right-radiusborder-bottom-right-radiusborder-bottom-left-radius （注意顺序不能颠倒~）
三.盒子阴影 box-shadow:h-shadow v-shadow blur spread color inset; h-shadow：必选，水平阴影的位置，允许负值 （影子在水平轴上来回移动，左负右正~）
v-shadow：必选，垂直阴影的位置，允许负值 （同理，上负下正）
blur：可选，模糊距离 （数值越大越模糊）
spread：可选，阴影的尺寸 （影子面积的大小~）
color：可选，阴影的颜色 （可以16进制，亦可rgba的写法~）
inset：可选，将外部阴影outset改为内部阴影 （需要注意的是outset不需要写，默认值） 此外，阴影不占用别的盒子的空间，不影响其他盒子的排列
上一篇的案例在这展示添加阴影的效果（写法类似伪类选择器）：（接触后触发阴影）
.box:hover{ box-shadow:10px 10px 10px 10px gray; } 四.文字阴影 text-shadow:h-shadow v-shadow blur color ; 同理，不再赘述~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfd8563e34f07bed4f1f0fffae88439/" rel="bookmark">
			排序链表---归并--链表OJ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://leetcode.cn/problems/sort-list/submissions/499363940/?envType=study-plan-v2&amp;envId=top-100-liked
这里我们直接进阶，用时间复杂度O(nlogn)，空间复杂度O(1)，来解决。
对于归并，如果自上而下的话，空间复杂度为O(n)，因为需要开辟n个结点
所以我们要换种思路，自下而上，直接将链表看成独立的n个结点。
首先合并算法：
struct ListNode* merge(struct ListNode* head1,struct ListNode* head2) { struct ListNode* dummyHead = (struct ListNode*)malloc(sizeof(struct ListNode)); dummyHead-&gt;val = 0,dummyHead-&gt;next = NULL; struct ListNode* tmp = dummyHead,*h1=head1,*h2=head2; while(h1 &amp;&amp; h2) { if(h1-&gt;val &lt;= h2-&gt;val) { tmp-&gt;next = h1; h1=h1-&gt;next; } else { tmp-&gt;next = h2; h2 = h2-&gt;next; } tmp = tmp-&gt;next; } if(h1) { tmp-&gt;next = h1; } if(h2) { tmp-&gt;next = h2; } return dummyHead-&gt;next; } 思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfd8563e34f07bed4f1f0fffae88439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a129af9458eea7e6be5d3e1c8fb07b8/" rel="bookmark">
			【FPGA原型验证】附录基础知识：FPGA/CPLD基本结构与实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚焦Xilinx ISE 介绍Xilinx公司及其产品的基本情况，并在此基础上描述了CPLD和FPGA的内部结构及基本原理。
1.1 Xilinx公司及其产品介绍 总部设在加利福尼亚圣何塞市（San Jose）的Xilinx是全球领先的可编程逻辑解决方案的供应商，图1-1为公司标志。
Xilinx公司的业务是研发、制造并销售高级集成电路、软件设计工具以及作为预定义系统级功能的IP（Intellectual Property）核，其相关产品在全球占有大量的份额，客户通过使用Xilinx及其合作伙伴的自动化设计软件和IP核，进行器件编程及设计的工作，最终实现特定的逻辑功能。
1.1.1 Xilinx公司简介 Xilinx公司成立于1984年，它首创了现场可编程逻辑阵列（FPGA）这一创新性的技术，并于1985年首次推出商业化产品。目前Xilinx满足了全世界对FPGA产品一半以上的需求。Xilinx产品线还包括复杂可编程逻辑器件（CPLD）。
Xilinx可编程逻辑解决方案缩短了电子设备制造商开发产品的时间并加快了产品面市的速度，从而减小了制造商的风险。
与采用传统方法，如固定逻辑门阵列相比，利用Xilinx可编程器件，客户可以更快地设计和验证他们的电路。
而且，由于Xilinx器件是只需要进行编程的标准部件，客户不需要像采用固定逻辑芯片时那样等待样品或者付出巨额成本。Xilinx产品已经被广泛应用于从无线电话基站到DVD播放机的数字电子应用技术中。
作为一个可编程逻辑器件的供应商，Xilinx有自己的开发套件，至今已经形成了一个完整的整体。Xilinx公司提供的开发软件主要有以下几种。
● ISE：Xilinx公司集成开发的工具● Foundation：Xilinx公司早期的开发工具，逐步被ISE取代● ISE Webpack：Webpack是Xilinx公司提供的免费开发软件，功能比ISE少一些，可以从Xilinx网站下载● 嵌入式开发套件（EDK）：用于开发集成PowerPC硬核和Micro Blaze软核CPU的工具● System Generator for DSP：配合Matlab，在FPGA中完成数字信号处理的工具● Xilinx IP核：Xilinx公司拥有非常完整的IP库 FPGA/CPLD基本结构与实现原理 FPGA和CPLD都是可编程ASIC器件，有很多共同特点，但由于FPGA和CPLD结构上的差异，具有各自的特点，为了更好地理解FPGA和CPLD的特点和应用场合，下面将对FPGA和CPLD基本结构与实现原理进行简单的介绍，这部分内容将同样有助于用户进行相关的产品设计。
1、Intel/Altera FPGA Intel/Altera FPGA组成： ALMs、LEs、RAM、DSP Blocks、Multipliers、PLLs等。
Intel/Altera的可编程逻辑单元通常被称为LE（Logic Element，逻辑单元），由一个Register和一个LUT组成。
再将10个LE有机组合起来，构成更大的逻辑功能单元——逻辑阵列模块（LAB，Logic Array Block），LAB中还包含LE间的进位链、LAB控制信号、LUT级联链、局部互连线资源、寄存器级联链等连线和控制资源。
2、Xilinx FPGA Xilinx FPGA组成： CLB（Configable Logic Block）包含Slices和DRAM。
CLB是由Slices构成的，每一个Slices基本是由LUT、进位链、MUX和寄存器组成。
Xilinx的可编程逻辑单元被称为Slice，由上下两部分组成。
每部分都由一个Register和一个LUT组成，被称为LC（LogicCell，逻辑单元），两个LC间也有一些共用逻辑。可以完成LC之间的配合与级联。
3、Lattice FPGA Lattice组成的主要可编程逻辑单元叫PFU（ProgrammableFuncTIonUnit），是由8个LUT和8~9个Register组成。
1.2.1 FPGA基本结构与实现原理 1）可配置逻辑块（CLB） CLB是FPGA内的基本逻辑单元。
实际数量和特性会依器件的不同而不同，但是每个CLB都包含一个由4或6个输入、一些选型电路（多路复用器等）和触发器组成的可配置开关矩阵。
开关矩阵是高度灵活的，可以进行配置以便处理组合逻辑、移位寄存器或RAM。
相应器件的数据手册中提供了更系统的详情。
互连CLB提供了逻辑性能，灵活的互连布线在CLB和I/O之间发送信号。有几种布线方法，从专门实现CLB互连的到快速水平和垂直长线，再到实现时钟与其他全局信号的低歪斜发送的器件。
非特别规定，设计软件使得互连布线任务从用户眼前消失，这样就极大地降低了设计复杂度。
在赛灵思公司公司的FPGA 器件中，CLB 由多个( 一般为4 个或2 个) 相同的Slice 和附加逻辑构成，如图2-5 所示。每个CLB 模块不仅可以用于实现组合逻辑、时序逻辑，还可以配置为分布式 RAM 和分布式 ROM。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a129af9458eea7e6be5d3e1c8fb07b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb575edc438c3802e16103033819235/" rel="bookmark">
			iOS App审核状态和审核时间管理指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 对于一款开发完成并准备上架的 iOS 应用程序来说，通过苹果公司的审核是非常重要的一步。苹果公司会对应用程序进行严格的检查，以确保应用程序的质量和安全性。本文将介绍 iOS 应用程序审核的流程和时间，希望能够帮助开发者更好地了解和处理审核过程中的问题。
App Store 审核状态 在 App Store 中，应用有多种状态，包括：
正在审核：这意味着应用已经提交，并且苹果公司正在审核应用程序。该状态通常持续24小时，但也可能需要更长的时间。等待审核：这意味着应用已经提交，但还没有排队等待审核。当应用排到队列中时，审核时间可能因应用而异。审核通过：这意味着应用已经通过审核，并可以发布到 App Store 上。审核被拒：这意味着应用未通过审核，并且需要进行修复或修改后重新提交。可供销售：这意味着应用已经在 App Store 上发布，并可以被用户下载和使用。 iOS App 审核时间 正常应用正在审核：这个过程无法加速，一般审核状态持续24小时就会结束。但如果遇到周末，审核时间可能会延长到72小时。内购等其他对苹果和用户影响较大的应用上线或更新，审核一般都是大于48小时。游戏审核时间较长，一般需要3天以上。 每个应用程序的审核时间可能是不同的，少则可能一个星期内能搞定，多则可能三四个星期以上。如果想让审核加快的话，建议与产品沟通是否存在敏感字眼或其他问题。
避免审核失败 为了避免应用审核失败，开发者需要注意以下几点：
程序不能存在重大 bug，不能启动或中途退出。不能绕过苹果的付费渠道。如果游戏里有实物奖励，应该说明奖励由本公司负责，与苹果无关。应用的设计不能使用苹果的标志。 上传流程 上传应用程序时，首先需要进行预审机审和人工审核。整个审核流程大体分为五个阶段：
Wait for Review：应用程序已经提交，等待审核。In Review：应用程序正在审核中。Approved：应用程序通过审核，可以在 App Store 上发布。Rejected：应用程序未通过审核，需要进行修复或修改后重新提交。Metadata Rejected：应用程序未通过元数据审核，需要进行修复或修改后重新提交。 上传成功后再回到开发者中心，刷新页面就会发现项目是等待审核状态了。正常审核周期是5个工作日，审核结果出来后也会通过邮件通知开发者。
一、选择 IPA 文件和通道 首先，在提交上传界面中，我们需要选择相应的 IPA 文件。这个文件是经过开发者编译生成的应用程序包，其中包含了应用的代码、资源和配置信息。
在提交界面的右上角，有四个通道可供选择：1，2，3 和老通道。根据实际情况，选择合适的通道进行上传。
二、设置专用密码 为了保证上传的安全性，我们需要设置专用密码。这个密码将用于验证用户身份，确保只有授权的人员能够进行上传操作。
三、上传 IPA 文件 在选择 IPA 文件和设置密码后，我们可以开始进行上传操作。点击上传按钮，等待上传完成。
四、添加 IAP 商品 如果需要添加 IAP 商品，可以通过 iTunes Connect 界面进行添加。添加完成后，我们需要使用 AppUploader 工具来提交审核。
let inAppPurchase = InAppPurchase() inAppPurchase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb575edc438c3802e16103033819235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57db3c778fec38b431decc84545c18a0/" rel="bookmark">
			iTunes Connect 中修改后的内购（IPA）审核所需的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在 iOS 开发过程中，将应用上传到 App Store 是一个重要的步骤。应用审核和 IAP 商品审核是分开的，审核一般需要等待一周左右。如果审核通过，我们会收到 Apple 发来的反馈邮件，根据邮件中的指示进行后续操作。如果已经上架的应用需要添加 IAP 商品或者修改 IAP 价格等，直接提交 IAP 审核即可，不需要再次提交应用审核。提交应用审核可以使用 AppUploader 工具，非常简单方便，下面具体来讲讲吧。
摘要 本文将介绍使用 AppUploader 工具提交上传 iOS 应用和 IAP 商品的步骤，包括选择 IPA 文件和通道、设置专用密码、提交上传并审核等。通过本文的指导，开发者可以轻松完成应用和 IAP 商品的上传和审核过程。
正文 一、选择 IPA 文件和通道 首先，在提交上传界面中，我们需要选择相应的 IPA 文件。这个文件是经过开发者编译生成的应用程序包，其中包含了应用的代码、资源和配置信息。
在提交界面的右上角，有四个通道可供选择：1，2，3 和老通道。根据实际情况，选择合适的通道进行上传。
二、设置专用密码 为了保证上传的安全性，我们需要设置专用密码。这个密码将用于验证用户身份，确保只有授权的人员能够进行上传操作。
三、上传 IPA 文件 在选择 IPA 文件和设置密码后，我们可以开始进行上传操作。点击上传按钮，等待上传完成。
四、添加 IAP 商品 如果需要添加 IAP 商品，可以通过 iTunes Connect 界面进行添加。添加完成后，我们需要使用 AppUploader 工具来提交审核。
let inAppPurchase = InAppPurchase() inAppPurchase.productID = "com.example.product1" inAppPurchase.type = .consumable inAppPurchase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57db3c778fec38b431decc84545c18a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263f1f7e1305a18f4fb79e34ca24f471/" rel="bookmark">
			【Java之HTML】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML 概念 互联网的产生：w3c的成立，
​ 互联网最开始设计的目的：看论文 ----&gt;浏览器，HTML
​ 网络三要素：HTML HTTP URL
HTML描述论文的格式
HTTP标记这个论文在网络上怎么传输
URL:指示这个论文在互联网的哪个位置： 协议 ip/域名 端口
结构 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; // HTML 是一个文本: 特点 // 1, HTML页面/文本,是由标签构成的, 标签成对出现, 有开始有结束 // 2, HTML文本,最外层标签是&lt;html&gt;标签 // 3, 整个HTML文本分为两部分, &lt;head&gt; 和&lt;body&gt;部分 实现网页的三个技术基础：HTML、CSS、JS
Body中的重要标签 hr:横线标签 &lt;hr&gt;是一个横线标签，可以在网页上显示一个横线，并且是一个单标签 属性： noshade:颜色是否有阴影(纯色) size:高度( 厚度,不同于height,不带单位时--默认px ) width:宽度(不带单位时--默认px) align:对其方式 br：换行符 &lt;br&gt;:表示一个换行符，是一个单标签 hn:标题标签 // &lt;h1&gt;&lt;h2&gt;&lt;h3&gt;&lt;h4&gt;&lt;h5&gt;&lt;h6&gt;: 标题标签 // // 注意: 在一个HTML页面中, h1只能出现一次, h2-h6可以出现多次 // 因为H1里面的内容是作为关键字存在的 // 标题标签的属性: align Left:左对齐内容（默认值） Center:右对齐内容 Right:居中对齐内容 div //&lt;div&gt;:用来对页面划分区域，是最常用的标签 p:段落标签 // &lt;p&gt;: 是一个段落标签, (极类似于div, 除了一个特点) // p标签自带上下边距 a:超链接标签 // &lt;a&gt;: 是一个超链接标签:在一个页面中通过连接打开一个新的页面 // 属性: // href: 指示要打开页面的地址, 本质上是一个url: 统一资源定位符 // target: Target 超链接属性target的value值时默认是_self _blank:在新窗口打开 _parent:在父窗口打开 _self:它使目标文档显示在超链接所在框架或者窗口中 _top:在顶级窗口打开 同组值:通过单击一个窗口中的不同链接控制另一窗口内容变化 ; 浏览器会找与target值相符的框架或者窗口中的文档，有则在其中显示文档。如果不存在，浏览器打开一个新窗口 URL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/263f1f7e1305a18f4fb79e34ca24f471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa05227db366d042192540bfdd24d6ac/" rel="bookmark">
			网络工程java&#43;ssm&#43;vue项目 - 基于SSM的药源药品商城保健品购物网站(含源码&#43;论文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 项目简介2 实现效果2.1 界面展示 3 设计方案3.1 概述3.2 系统流程3.3 系统结构设计 4 项目获取 1 项目简介 Hi，各位同学好呀，这里是M学姐！
今天向大家分享一个今年(2022)最新完成的毕业设计项目作品，【基于SSM的药源药品商城保健品购物网站】
学姐根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：5分
创新点：3分
界面美化：5分
界面美化的补充说明：使用vue的基本都能达到5分
本项目完成于2022年6月份，包含内容 : 源码 + 论文 + 答辩PPT
2 实现效果 视频地址：https://www.bilibili.com/video/BV1bg4y167Ra
2.1 界面展示 前台首页详情页面 管理员登录界面 管理员功能界面 药品信息界面 3 设计方案 3.1 概述 数据库服务器端采用了Mysql作为后台数据库，使Web与数据库紧密联系起来。采用Java技术，从数据库中获取数据、向数据库中写入数据，实现系统直接对数据库进行各种操作，在网页中加入动态内容，从而实现ssm药源购物网站所需要的各种基本功能。
ssm药源购物网站基于Web服务模式，是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在不受时间、地点的限制来使用这个系统。
3.2 系统流程 登录流程图 添加信息流程图 注册信息流程图 3.3 系统结构设计 ssm药源购物网站，主要的模块包括两个用户，管理员权限：用户管理、药品分类管理、药品信息管理、疫情常识管理、保健品推荐管理 、管理员管理、系统管理、订单管理等功能。用户权限：我的收藏管理、订单管理系统。前台页面：药品信息、疫情常识、保健品推荐、个人中心、后台管理、购物车。管理员主要是为了安全有效地存储和管理各类信息，还可以对系统进行管理与更新维护等操作，并且对后台有相应的操作权限。
4 项目获取 本项目完成于2022年6月份，包含内容 : 源码 + 论文 + 答辩PPT
项目获取：https://gitee.com/sinonfin/L-javaWebSha/tree/master
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a0652c9bf325546aa96fbd6176c5a6/" rel="bookmark">
			大数据毕设项目 - 深度学习 机器视觉 人脸识别系统 - opencv python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 机器学习-人脸识别过程人脸检测人脸对其人脸特征向量化人脸识别 2 深度学习-人脸识别过程人脸检测人脸识别Metric Larning 3 最后 0 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的毕设题目缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的项目系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的是
🚩 深度学习 机器视觉 人脸识别系统
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：3分 1 机器学习-人脸识别过程 基于传统图像处理和机器学习技术的人脸识别技术，其中的流程都是一样的。
机器学习-人脸识别系统都包括：
人脸检测人脸对其人脸特征向量化人脸识别
人脸检测 人脸检测用于确定人脸在图像中的大小和位置，即解决“人脸在哪里”的问题，把真正的人脸区域从图像中裁剪出来，便于后续的人脸特征分析和识别。下图是对一张图像的人脸检测结果：
人脸对其 同一个人在不同的图像序列中可能呈现出不同的姿态和表情，这种情况是不利于人脸识别的。
所以有必要将人脸图像都变换到一个统一的角度和姿态，这就是人脸对齐。
它的原理是找到人脸的若干个关键点（基准点，如眼角，鼻尖，嘴角等），然后利用这些对应的关键点通过相似变换（Similarity Transform，旋转、缩放和平移）将人脸尽可能变换到标准人脸。
下图是一个典型的人脸图像对齐过程：
这幅图就更加直观了：
人脸特征向量化 这一步是将对齐后的人脸图像，组成一个特征向量，该特征向量用于描述这张人脸。
但由于，一幅人脸照片往往由比较多的像素构成，如果以每个像素作为1维特征，将得到一个维数非常高的特征向量， 计算将十分困难；而且这些像素之间通常具有相关性。
所以我们常常利用PCA技术对人脸描述向量进行降维处理，保留数据集中对方差贡献最大的人脸特征来达到简化数据集的目的
PCA人脸特征向量降维示例代码：
#coding:utf-8 from numpy import * from numpy import linalg as la import cv2 import os def loadImageSet(add): FaceMat = mat(zeros((15,98*116))) j =0 for i in os.listdir(add): if i.split('.')[1] == 'normal': try: img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a0652c9bf325546aa96fbd6176c5a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b7c17f65ab06f43475ab7f73a89eab/" rel="bookmark">
			大公司如何做 APP：背后的开发流程和技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我记得五六年前，当我在 Android 开发领域尚处初出茅庐阶段之时，我曾有一个执念——想看下大公司在研发一款产品的流程和技术上跟小公司有什么区别。公司之大，对开发来说，不在于员工规模，而在于产品的用户量级。只有用户量级够大，研发过程中的小问题才会被放大。当用户量级够大，公司才愿意在技术上投入更多的人力资源。因此，在大公司里做技术，对个人的眼界、技术细节和深度的提升都有帮助。
我记得之前我曾跟同事调侃说，有一天我离职了，我可以说我毕业了，因为我这几年学到了很多。现在我想借这个机会总结下这些年在公司里经历的让我印象深刻的技术。
1、研发流程 首先在产品的研发流程上，我把过去公司的研发模式分成两种。
第一种是按需求排期的。在评审阶段一次性评审很多需求，和开发沟通后可能删掉优先级较低的需求，剩下的需求先开发，再测试，最后上线。上线的时间根据开发和测试最终完成的时间确定。
第二种是双周迭代模式，属于敏捷开发的一种。这种开发机制里，两周一个版本，时间是固定的。开发、测试和产品不断往时间周期里插入需求。如下图，第一周和第三周的时间是存在重叠的。具体每个阶段留多少时间，可以根据自身的情况决定。如果需求比较大，则可以跨迭代，但发布的时间窗口基本是固定的。
双周迭代机制
有意思的是，第二种开发机制一直是我之前的一家公司里负责人羡慕的“跑火车”模式。深度参与过两种开发模式之后，我说下我的看法。
首先，第一种开发模式适合排期时间比较长的需求。但是这种方式时间利用率相对较低。比如，在测试阶段，开发一般是没什么事情做的（有的会在这个时间阶段布置支线需求）。这种开发流程也有其好处，即沟通和协调成本相对较低。
注意！在这里，我们比较时间利用率的时候是默认两种模式的每日工作时间是相等的且在法律允许范围内。毕竟，不论哪一种研发流程，强制加班之后，时间利用率都“高”（至少老板这么觉得）。
第二种开发方式的好处：
1. 响应速度快。可以快速发现问题并修复，适合快速试错。
2. 时间利用率高。相比于按需求排期的方式，不存在开发和测试的间隙期。
但这种开发方式也有缺点：
1. 员工压力大，容易造成人员流失。开发和测试时间穿插，开发需要保证开发的质量，否则容易影响整个迭代内开发的进度。
2. 沟通成本高。排期阶段出现人力冲突需要协调。开发过程中出现问题也需要及时、有效的沟通。因此，在这种开发模式里还有一个角色叫项目经理，负责在中间协调，而第一种开发模式里项目经理的存在感很低。
3. 这种开发模式中，产品要不断想需求，很容易导致开发的需求本身价值并不大。
做了这么多年开发，让人很难拒绝一个事实是，绝大多数互联网公司的壁垒既不是技术，也不是产品，而是“快速迭代，快速试错”。从这个角度讲，双周迭代开发机制更适应互联网公司的要求。就像我们调侃公司是给电脑配个人，这种开发模式里就是给“研发流水线”配个人，从产品、到开发、到测试，所有人都像是流水线上的一员。
2、一个需求的闭环 以上是需求的研发流程。如果把一个需求从产品提出、到上线、到线上数据回收……整个生命周期列出来，将如下图所示，
一个需求的闭环
这里我整合了几个公司的研发过程。我用颜色分成了几个大的流程。相信每个公司的研发流程里或多或少都会包含其中的几个。在这个闭环里，我说一下我印象比较深刻的几个。
2.1 产品流程 大公司做产品一个显著的特点是数据驱动，一切都拿数据说话。一个需求的提出只是一个假设，开发上线之后效果评估依赖于数据。数据来源主要有埋点上报和舆情监控。
1. 数据埋点
埋点数据不仅用于产品需求的验证，也用于推荐算法的训练。因此，大公司对数据埋点的重视可以说是深入骨髓的。埋点数据也经常被纳入到绩效考核里。
开发埋点大致要经过如下流程，
• 1). 产品提出需要埋的点。埋点的类型主要包括曝光和点击等，此外还附带一些上报的参数，统计的维度包括用户 uv 和次数 pv.
• 2). 数据设计埋点。数据拿到产品要埋的点之后，设计埋点，并在埋点平台录入。
• 3). 端上开发埋点。端上包括移动客户端和 Web，当然埋点框架也要支持 RN 和 H5.
• 4). 端上验证埋点。端上埋点完成之后需要测试，上报埋点，然后再在平台做埋点校验。
• 5). 产品提取埋点数据。
• 6). 异常埋点数据修复。
由此可见，埋点及其校验对开发来说也是需要花费精力的一环。它不仅需要多个角色参与，还需要一个大数据平台，一个录入、校验和数据提取平台，以及端上的上报框架，可以说成本并不低。
2. 舆情监控
老实说，初次接触舆情监控的时候，它还是给了我一点小震撼的。没想到大公司已经把舆情监控做到了软件身上。
舆情监控就是对网络上关于该 APP 的舆情的监控，数据来源不仅包括应用内、外用户提交的反馈，还包括主流社交平台上关于该软件的消息。所有数据在整合到舆情平台之后会经过大数据分析和分类，然后进行监控。舆情监控工具可以做到对产品的负面信息预警，帮助产品经理优化产品，是产品研发流程中重要的一环。
3. AB 实验
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b7c17f65ab06f43475ab7f73a89eab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8b6290af982a00f277512ce5378d66/" rel="bookmark">
			编程笔记 html5&amp;css&amp;js 067 JavaScrip String数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程笔记 html5&amp;css&amp;js 067 JavaScrip String数据类型 一、String数据类型二、类型运算三、代码示例小结 Javascript语言中的String数据类型详解。JavaScript 中的 String 数据类型用于表示文本数据。字符串是不可变的，这意味着一旦创建了一个字符串，就不能直接修改其内容。
一、String数据类型 在 JavaScript 中，字符串可以通过以下几种方式定义：
定义字符串：
使用单引号 ' 或双引号 " 来包裹文本内容。var string1 = 'Hello, World!'; var string2 = "Hello, World!"; 转义字符：
字符串中可以包含特殊字符，通过使用反斜杠 \ 进行转义，例如换行符 \n、制表符 \t、单引号 \'、双引号 \" 等。var escapedString = "This is a string containing a \"quote\" and a newline\n"; 字符串字面量模板（ES6新增）：
可以使用反引号 `` (`) 创建模板字符串，它们可以跨越多行，并且能够嵌入表达式。let name = "Alice"; let greeting = `Hello, ${name}!`; // 结果为 "Hello, Alice!" 字符串长度：
通过 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8b6290af982a00f277512ce5378d66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93fd61097bd674dc08f73b7e03af2b6f/" rel="bookmark">
			迅为龙芯2K1000开发板运行Busybox、Buildroot、Loognix、QT5.12系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件配置
国产龙芯处理器，双核64位系统，板载2GDDR3内存，流畅运行Busybox、Buildroot、Loognix、QT5.12 系统!
接口全
板载4路USB HOST、2路千兆以太网、2路UART、2路CAN总线、Mini PCIE、SATA固态盘接口、4G接口、 GPS接口WIFI、蓝牙、Mini HDMI、温度传感器、JTAG接口等
开发指南更新! 让研发速度快上加快
更新包含了开发环境搭建、系统编译与烧写和pmon基础知识、启动流程分析、网络加载系统、烧写系统到nand以及新增pmon 移植教程、新增pmon下操作GPIO章节和pmon下Ejtag使用章节等
新增视频教程
新增龙芯2K1000开发环境搭建系列、系统编译与烧写系列PMON基础知识及启动流程分析系列、pmon 移植教程系列视频教程。
核心板参数
尺寸：65mm*55mm
CPU：龙芯2K1000双核处理器
主频：800MHZ-1GHz
内存：板载2GBDDR3
NAND容量：512M
存储：8MB的存储，用来放BOOT引导程序的存储
工作电压：12V和5V
商业级工作温度：0°C到+70°C
工业级工作温度：-40°到+85°C
内核版本：Linux3.0
系统支持：流畅运行Busybox、Buildroot、Loognix、QT512系统
引脚扩展：引出脚多达232个，10间距的邮票孔方式
底板参数：
尺寸： 190mm*125mm POWER：电直流电源输入接口
SWITCH：电源开关
Ethernet：2路10M/100M/1000M自适应以太网
USB HOST：4路USB2.0
OTG：支持
Mini HDMI：支持
RGB-LCD：支持
WIFI/BT：板载WIFI、蓝牙二合一模块
Mini PCIE：可外接miniPCIE接口的4G模块具备PCIE2.0单通道
4G模块：支持(选配)
SIM Card：1个
UART：2路串口
RS485：1路
CAN：2路
蜂鸣器：一个有源蜂鸣器
RTC：支持
LIO/UART：2mm间距20PIN插座引出
GPIO：2mm间距20PIN插座引出
耳机接口：标准3.5mm耳机接口
JTAG：1路TAG调试接口(2mm间距10PIN插座引出)
GPS：1路GPS (选配)
固态硬盘接口：1路((SATA固态盘选配）
按键：3个
温度传感器：支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e974b39e5407cf1ed5a7c7447629361/" rel="bookmark">
			项目中都可以使用的 8 种简单扩展方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 自定义 View 的属性操作 在设计自己的 View 时，通常从视图层次结构和标记中获取所需属性的方法是使用 TypedArray。然而，像所有资源一样，这样的容器对象必须正确地获取，然后在使用后释放。以下扩展旨在简化此过程：
fun View.withTypedArray( set: AttributeSet?, @StyleableRes attrs: IntArray, @AttrRes defStyleAttr: Int = 0, @StyleRes defStyleRes: Int = 0, action: TypedArray.() -&gt; Unit ) { val typedArray = context.theme.obtainStyledAttributes( set, attrs, defStyleAttr, defStyleRes ) action(typedArray) typedArray.recycle() } 2. 遍历视图层次结构 有时需要遍历所有（或部分）视图树，并对每个视图执行特定操作。在这种情况下，最简单和最方便的方法就是递归地遍历树。但是，可以通过使用扩展方法来隐藏递归函数的常数实现：
fun View.forEach(action: View.(Int) -&gt; Unit) = forEach(0, action) private fun View.forEach(level: Int = 0, action: View.(Int) -&gt; Unit) { this.action(level) if (this is ViewGroup) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e974b39e5407cf1ed5a7c7447629361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b0b151fc9a54c15bea8f3e882c3a25/" rel="bookmark">
			【UE5蓝图】 文字超出规定框，旧的文字自动上滑（滚动框实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当文字框的文本超出框体时，文字会自动往上滚动。
滚动框包裹文字框。
每次设置文本框的文本时，执行一次滚动至滚动框末尾。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183fd41202de5d7f143ebf4c158641c6/" rel="bookmark">
			如何检验 MySQL 数据库中查询语句是否已经是最优，并进行优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL数据库中，优化查询语句是提高数据库性能的关键。在这篇博客中，我们将详细介绍如何检验MySQL数据库中查询语句是否已经是最优的，并阐述如何进行优化查询以提高其效率。我们将涵盖以下几个方面的内容：
1、编写测试查询的脚本
2、执行查询并观察其执行计划
3、分析查询的性能，包括时间复杂度和空间复杂度
4、根据测试结果，对查询进行必要的优化
5、测试优化后的查询是否能够达到预期的性能
1. 编写测试查询的脚本 首先，我们需要编写一个测试查询的脚本。这个脚本将执行一个简单的查询，并记录查询的执行时间。我们可以使用MySQL的EXPLAIN语句来分析查询的执行计划。
以下是一个示例脚本：
import mysql.connector import time # 连接到MySQL数据库 cnx = mysql.connector.connect(user='your_username', password='your_password', host='your_host', database='your_database') cursor = cnx.cursor() # 编写查询语句 query = "SELECT * FROM your_table WHERE some_column = 'some_value';" # 使用EXPLAIN语句分析查询执行计划 explain_query = "EXPLAIN " + query cursor.execute(explain_query) # 获取执行计划结果 results = cursor.fetchall() print("Execution Plan:") for result in results: print(result) # 执行原始查询 start_time = time.time() cursor.execute(query) results = cursor.fetchall() end_time = time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183fd41202de5d7f143ebf4c158641c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e84f9bbb8acf7afd4686fff695a270/" rel="bookmark">
			0.1 qt的信号槽机制在pyside6中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、什么是信号/槽 Qt中QObject之间需要进行通信，信号槽就是这种通信机制。简单来说信号槽就像是电视机和遥控器，你按遥控器发出指令，电视机作出相应的反应。
在界面开发中拿按钮来举例，当你点击按钮的时候，“点击”就是这个信号，“槽”则是点击按钮后发生的事情，比如关闭窗口。信号是当对象发生其他对象可能感兴趣的一定程度上状态改变的时候发出的。它不关心谁接收这个信号，这就是真正意义上的信息封装，确保了对象能像软件组件一样被使用。槽是用来接收信号的普通成员函数，就像对象不知道是什么来接收它的信号一样，槽也不知道是否有信号连接上它。你可以连接多个信号到一个槽，一个信号也可以连接到多个槽，还可以把信号直接连接到信号。Qt组件有许多预定义的信号槽，比如按钮点击。
举个例子：
import sys from PySide6.QtWidgets import QApplication, QPushButton def my_function(): print("槽函数被调用了。") app = QApplication() button = QPushButton("调用函数。") # 连接信号和槽 button.clicked.connect(function) button.show() sys.exit(app.exec()) 二、信号类 一个基于QWidget的按钮发出点击信号就像这样：
from PySide6.QtCore import Qt, Signal from PySide6.QtWidgets import QWidget class Btn(QWidget): clicked = Signal(Qt.MouseButton) def mousePressEvent(self, event): self.clicked.emit(event.button()) 三、槽类 槽应该用@QtCore.Slot()修饰，否则会增加程序运行时的开销和错误的风险。
@Slot(str) def slot_func(self, s): ... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b857d95f6585af18c83e76f3beacb25/" rel="bookmark">
			迅为RK3588开发板使用VLCplayer进行拉流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们将 Windows 主机作为拉流端，使用 VLC 软件进行拉流，VLC 软件可以在网盘资料“iTOP-3588 开发板\02_【iTOP-RK3588 开发板】开发资料\09_Linux 系统开发配套资料\05_RTMP 开发配套资料”目录下找到，大家可以自行安装好。安装好之后打开 VLC，如下图所示：
点击左上角媒体-&gt;打开网络串流，弹出如下界面输入以下内容，如下图所示：
点击“播放”既可从 RTMP 流媒体服务器拉取视频数据进行播放，如下所示：
更多内容：B站搜索迅为RK3588开发板
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b65588c388e25125fb024d452f924bf/" rel="bookmark">
			【图像隐写】基于matlab DCT域文字水印隐写【含Matlab源码 3876期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、数字水印嵌入提取 摘要：重点介绍数字水印的嵌入与提取算法。数字水印根据水印的嵌入技术不同分为空间域数字水印和变换域数字水印。将分别介绍数字水印的空间域算法和变换域算法，并结合图像质量评价参数峰值信噪比（PSNR）分析这两种算法的优缺点。
1 引言
随着互联网的普及和数字技术的广泛应用，数字产品变得极大丰富并且传播便捷，同时版权保护问题也日益突出。传统的信息安全技术在数字产品版权保护方面存在的不足，促成了数字水印技术的发展。数字水印技术将数字水印隐藏于数字媒体中,以便在版权纠纷中为版权所有者提供版权证明。数字水印根据水印的嵌入技术不同分为空间域数字水印和变换域数字水印。空间域算法包含叠加法和最低有效位（LSB）图像水印法等，变换域算法包含小波变换法等。实验部分使用Matlab软件进行，并分别用这三种方法对图像数字水印进行嵌入与提取。最后在相同的水印信号条件下，结合这三种方法所产生的含水印图像的峰值信噪比，分析了这三种方法的优缺点。
2 数字图像水印算法
数字水印技术是一种基于内容的、非密码机制的计算机信息隐藏技术。它可以将一些标识信息直接嵌入数字载体当中，且不影响原载体的使用价值，也不容易被探知和再次修改，从而实现保护版权、信息隐藏的功能。数字水印按照特性可以分为鲁棒数字水印和脆弱数字水印。本部分重点研究脆弱数字水印的应用，同时分别分析三种水印算法的机理和效果。
2.1 数字图像水印算法的基本框架
如图一所示的是水印嵌入与提取流程图，根据密钥和水印产生算法生成水印信号，通过水印嵌入算法，将水印信号和原始图像进行结合, 得到嵌入了水印的作品。然后，在水印信号提取过程中，可以在相同的密钥下，通过水印产生算法恢复出水印信号。需要注意的是，特定的密钥对水印的嵌入和提取至关重要。
2.2 叠加法
叠加法通过对原始图像灰度值进行处理，将其按照某个权重叠加上水印图像灰度值即可得到加入水印的图像。同理，若想恢复出水印图像，可以直接将加入水印的图像减去原始图像。
在Matlab中对图像灰度值进行处理要先将图像变换成double类型，然后再进行简单叠加操作。代码如下所示：
imNew=uint8(double(imOri)+0.01*double(imWat)) ;%水印图像灰度权重设为0.01 2.3 最低有效位（LSB）图像水印法
最低有效位算法是一种典型的空间域信息隐藏算法。对于一张8位灰度图像，它的灰度数值可以表示为0到255，那么可以将其分割为从低到高的8位比特平面。因为高位比特平面所占的灰度权重较高，由此可以直接将水印信号的高位比特平面替换原始图像的低位比特平面，从而达到水印嵌入的效果。对于水印提取的过程可以根据加入水印图像的低位比特平面直接进行恢复提取。
将lena图像的第六位到第八位比特平面特换掉cameraman图像比特平面的第一位到第三位，同时保留cameraman图像原本的高位比特平面。
由于低位比特平面所占像素权重不高，所以加入水印的图像不仅效果较好，而且可以很好地隐藏信息。通过代码可以实现低位比特平面恢复水印图像，代码如下，结果如图三所示。
newimgW=newimgW+bitPlaneRec(:,:,i)*2^(4+i); %低位比特平面转移到高位比特平面 2.4 小波变换法
小波变换是空间时间和频率的局部变换，能有效地从信号中提取信息，通过伸缩和平移等运算功能可对函数或信号进行多尺度的细化分析，达到高频处时间细分和低频处频率细分。一般来说，在数字图像处理中使用的是离散小波变换对图像进行处理，图像被变换成低频域（代表图像的概貌）和高频域（代表图像的细节）两部分，并且高频部分可以分为代表图像水平方向分量的HL，代表图像垂直方向分量LH，以及代表图像对角线方向分量的HH三部分区域。低频系数代表它所在的小波块对应的图像块的平均亮度，高频系数代表图像的纹理和边缘部分。如果对低频区域再进一步进行小波变换，则低频域将按照上述原则递归生成更高一级的低频和高频区域。如图四为图像进行三级分解的结构示意图。
图五：三级小波分解结构图与示例图
图像经过小波变换后生成的小波图像的数据总量与原图像的数据总量相等， 通过将原始图像和水印信号的小波变换低频系数相加，最终可以得到新的小波域系数，再经过一次小波反变换最终可以获得嵌入水印的图像。水印恢复可以表示为水印信号减去原始信号。图五为小波变换法效果图。
核心代码如下所示：
imNew =uint8(ihaart2(LLwatermarked,LHorig,HLorig,HHorig)); %添加水印图像 imagesc(double(imNew)-double(imOri))；%恢复水印 图六：小波变换法效果图
2.5 DCT变换
2.5.1 DCT变换的特点
在基于DCT的变换编码中，图像是先经分块（8×8或16×16）后再经DCT，这种变换是局部的，只反映了图像某一部分的信息。当然也可以对整幅图像的特点，但是运算速度比分块DCT要慢。图像经DCT后，得到的DCT图像有三个特点：
(1) 系数值全部集中到0值附近（从直方图统计的意义上），动态范围很小，这说明用较小的量化比特数即可表示DCT系数；
(2) DCT变换后图像能量集中在图像的低频部分，即DCT图像中不为零的系数大部分集中在一起（左上角），因此编码效率很高。
(3).没有保留原图像块的精细结构，从中反映不了原图像块的边缘、轮廓等信息，这一特点是由DCT缺乏时局域性造成的。
2.5.2 宿主图像的DCT变换
对于N×N大小的256灰度级的宿主图像I进行N×N二维离散余弦变换（DCT）。以ZigZag方式对于DCT变换后的图像频率系数重新排列成一维向量Y={y1, y2,…yN×N}. 并取出序列中第L+1到L+M的中频系数部分,得到YL={ YL+1, YL+2,…, YL+M}。
2.5.3 DCT数字水印嵌入算法流程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b65588c388e25125fb024d452f924bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e3e0d55b1ff9c5b6e70fe9c8ee6be8/" rel="bookmark">
			C语言中大小写字母的转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，大小写字母的转化是一个非常基础且常用的功能。C语言中的字符是以ASCII码的形式存储的，而ASCII码中，小写字母和大写字母之间相差32。因此，可以通过简单的数学运算来实现大小写字母的转换。
一、数学运算转化 大写字母转换为小写字母 要实现大写字母转换为小写字母，只需将其ASCII码值加上32。
char c = 'A'; // 大写字母A c = c + 32; // 转换为小写字母a 也可以使用位运算中的异或操作（XOR），也可以实现大小写字母的转换。
char c = 'A'; // 大写字母A c = c ^ 32; // 转换为小写字母a 小写字母转换为大写字母 相反地，要实现小写字母转换为大写字母，可以将其ASCII码值减去32。
char c = 'a'; // 小写字母a c = c - 32; // 转换为大写字母A 二、使用库函数 C语言标准库提供了两个函数toupper和tolower，分别用于大小写字母的转换。
1、toupper函数将参数中的小写字母转换为大写字母，并返回转换后的字符。
2、tolower函数将参数中的大写字母转换为小写字母，并返回转换后的字符。
char c = 'a'; // 小写字母a c = toupper(c); // 转换为大写字母A char c = 'A'; // 大写字母A c = tolower(c); // 转换为小写字母a 程序示例 以下是一个使用getchar函数从键盘接收输入，然后转换并输出大小写字母的C语言程序示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9e3e0d55b1ff9c5b6e70fe9c8ee6be8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ac55b2e258c5f0f1be69f3cb023c8c/" rel="bookmark">
			IT行业有哪些证书含金量高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IT行业，有一些证书被认为是具有高含金量的。以下是一些国内外常见的高含金量证书：
1、Microsoft Certified Solutions Expert (MCSE)：这是微软针对各种IT专业相关技能领域的高级证书，包括云计算、数据管理、服务器等方向。
2、Cisco Certified Network Associate (CCNA)：这是思科公司颁发的用于测试和验证网络工程师的证书，在网络和通信领域非常有价值。
3、Certified Information Systems Security Professional (CISSP)：这是国际信息系统安全认证联盟（ISC2）认可的全球性信息安全专业人士认证，对于安全工程师和信息安全管理人员非常重要。
4、Project Management Professional (PMP)：这是由美国项目管理学会（PMI）颁发的全球认可的项目管理专业人士证书，对于项目管理岗位非常有价值。
5、Amazon Web Services Certified Solutions Architect (AWS CSA)：这是针对亚马逊云服务平台的证书，对于云计算和架构设计相关的职位有很高的含金量。
6、Red Hat Certified Engineer (RHCE)：这是红帽公司颁发的针对Linux系统工程师的专业认证，对于Linux系统相关职位非常有价值。
这些证书是根据其在行业中的认可度和市场需求而被咨询师普遍认为是具有高含金量的。然而，值得注意的是，不同的岗位和领域对不同证书的需求也会有所不同。因此，在选择证书时，应根据自身职业目标和兴趣进行选择，并了解相应的认证机构和市场需求。
在中国的IT行业，以下是一些被认为含金量高的证书：
1、中级网络工程师（CCNP）：这是思科公司颁发的专业级别证书，对于网络工程师和网络管理员的职业发展非常重要。
2、计算机软件与应用能力（中级）：这是由国家教育部主管的计算机技术与软件专业资格认证，是软件开发和应用能力的重要证明。
3、网络与信息安全工程师（CISE）：这是由中国计算机学会推出的信息安全领域的高级证书，对于信息安全领域的职业发展具有较高的含金量。
4、项目管理资格认证（PMP）：这是由PMI（Project Management Institute）颁发的全球认可的项目管理专业人士证书，在中国的项目管理领域具有很高的认可度。
5、云计算工程师（CCF-CE）：这是由中国云计算联盟（CCF）认可的云计算领域的专业证书，对于云计算岗位具有重要意义。
6、微软认证工程师（MCSE）：这是微软公司推出的专业认证，覆盖了多个技术领域，包括服务器、云计算、数据管理等，对于从事微软技术相关工作的人员有很高的含金量。
请注意，以上证书的含金量因个人职业发展目标、专业领域和市场需求而有所差异。在选择证书时，建议结合自身兴趣、职业规划和行业趋势，选择最适合自己的证书。
IT行业证书的价值和作用主要体现在以下几个方面：
1、证明技能和知识：IT证书是证明个人具备某种专业技能和知识的有效依据。这些证书通常由国际知名IT企业颁发，为国际承认并通用，如微软认证、软考等。
2、提高竞争力：拥有IT证书可以提升个人在就业市场中的竞争力。许多招聘方将IT认证资格视为判定应聘者是否优秀的可靠依据，因为这些证书证明了应聘者具备所需的专业技能和知识。
3、更快提高工作熟练度：获得IT证书意味着个人已经掌握了一定的专业知识和技能，这有助于更快地适应工作环境，提高工作熟练度。
4、职业生涯投资：获得IT证书需要投入时间和资金，这表明个人对职业发展的兴趣和投入。这种投资对于个人职业生涯的发展具有积极的影响。
5、保持技能最新：IT行业技术更新迅速，拥有IT证书意味着个人具备紧跟技术发展的能力，这有助于保持个人技能的最新状态。
6、升职加薪：在许多公司中，拥有IT证书的员工可能获得更好的职业发展机会和更高的薪资待遇。一些公司甚至将IT证书作为招聘的必备条件之一。
7、积分落户：在一些城市，拥有IT证书可以获得积分落户的加分，这对于在一线城市打拼的年轻人来说具有重要意义。
综上所述，IT行业证书在个人职业发展和就业市场中具有很高的价值和作用。通过获得IT证书，个人可以证明自己的技能和知识，提高竞争力，获得更好的职业发展机会和薪资待遇，以及享受积分落户等政策优惠。
考取IT证书需要掌握一定的学习方法与技巧，以下是一些建议：
1、了解考试要求和内容：在备考前，首先要仔细了解考试的要求和内容，了解考试形式和评分标准。这有助于制定合适的学习计划，明确学习目标。
2、制定学习计划：备考过程中，制定一个合理的学习计划非常重要。要合理分配时间，根据考试的要求和自己的实际情况，制定每天、每周、每月的学习计划，并按计划执行。
3、注重理论与实践相结合：IT证书考试往往既考查理论知识，也考查实际操作能力。因此，在备考过程中，要注重理论与实践相结合，多进行实际操作和练习，加深对理论知识的理解和掌握。
4、多做模拟题和真题：做模拟题和真题是提高考试成绩的有效方法。通过做模拟题和真题，可以了解考试的难度和出题形式，找到自己的薄弱环节，有针对性地进行巩固和提高。
5、善于总结和反思：在备考过程中，要经常总结和反思自己的学习情况，找到自己的不足之处，及时调整学习计划和方法。同时，也要善于归纳和总结知识点，形成自己的知识体系。
6、保持积极心态：备考过程中，可能会遇到各种困难和挫折，但要保持积极的心态和信心。遇到问题可以向老师、同学或专业人士请教，寻求帮助和支持。
总之，考取IT证书需要付出一定的努力和时间，但只要掌握正确的学习方法和技巧，保持积极的心态，相信你一定能够取得好成绩。 IT证书持有者的职业发展： IT证书持有者的职业发展具有广阔的前景和多种路径。持有IT证书意味着个人具备了一定的专业技能和知识，可以在IT行业中寻求各种职业机会。
1、软件开发工程师：软件开发是IT行业中最受欢迎的职业之一。持有IT证书的软件开发工程师在技术发展、工作稳定性和薪资待遇等方面都有较好的发展前景和就业趋势。随着信息技术的不断发展，软件开发工程师的需求量将继续增长。
2、系统架构师：系统架构师是IT行业中负责设计和规划系统架构的专业人员。持有IT证书的系统架构师具备扎实的技能和知识，能够为企业提供高效、稳定、安全的系统架构解决方案。随着企业数字化转型的加速，系统架构师的需求也将继续增长。
3、数据分析师：数据分析师是IT行业中负责数据挖掘和分析的专业人员。持有IT证书的数据分析师能够利用先进的技术和工具，从海量数据中提取有价值的信息，为企业提供决策支持。随着大数据时代的到来，数据分析师的需求将进一步增加。
4、网络安全工程师：网络安全工程师是IT行业中负责保障网络安全的专业人员。持有IT证书的网络安全工程师具备防范网络攻击、保护数据安全的能力，为企业提供可靠的网络安保障服务。随着网络安全威胁的增加，网络安全工程师的需求也将持续增长。
5、云计算工程师：云计算工程师是IT行业中负责云计算技术的专业人员。持有IT证书的云计算工程师具备云平台的规划、部署、管理和优化的能力，为企业提供高效、灵活、可靠的云计算服务。随着云计算技术的普及，云计算工程师的需求也将进一步增加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ac55b2e258c5f0f1be69f3cb023c8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c096fe6da0682c7b9f842e4f64800c/" rel="bookmark">
			Python系列-列表&amp;元组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 会编程的果子君
​💫个人格言:“成为自己未来的主人~”
目录
列表是什么，元组是什么
创建列表
访问下标
切片操作
遍历列表元素
新增元素
查找元素
删除元素
连接列表
关于元组
列表是什么，元组是什么 编程中，经常需要使用变量，来保存/表示数据
如果代码中需要表示的数据个数比较少，我们直接创建多个变量即可
num1=10 num2=20 num3=30 但是有的时候，代码中需要表示的数据特别多，甚至也不知道要表示多少个数据。这个时候，就需要用到列表。
列表是一种让程序员在代码中批量表示/保存数据的方式
元组和列表相比，是非常相似的，只是列表中放哪些元素可以修改调整，元组中放的元素是创建元组的时候就设定好的，不能修改调整
列表是散装的，元组是包装的
创建列表 创建列表主要有两种方式，[ ]表示一个空的列表
# 1 alist=[] # 2 alist=list() print(type(alist)) 如果需要往里面设置初始值，可以直接写在[ ]里
可以直接使用 print 函数来打印 list 中的元素内容
alist=[1,2,3,4] print(alist) 列表中存放的元素允许是不同的类型（这一点和C++/Java差别较大）
alist=[1,'a',True] print(alist) 因为 list 本身是Python中的关键函数，不宜再使用 list 作为变量名，因此命名为alist
访问下标 可以通过下标访问操作符[ ]来获取到列表中的任意元素
我们把[ ]中填写的数字，称为下标或者索引
alist=[1,2,3,4] alist[2]=100 print(alist) 下标是从0开始计数的，因此下标为2，则对应着3这个元素
通过下标不光能读取元素内容，还能修改元素的值
如果下标超出列表的元素范围，就会出现异常
alist=[1,2,3,4] print(alist[100]) 如果下标是从0开始的，因此下标的有效范围是【0，列表长度-1】，使用 len 函数 可以获取到列表的元素个数
alist=[1,2,3,4] print(len(alist)) 下标可以取负数，表示倒数第几个元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03c096fe6da0682c7b9f842e4f64800c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509ab1d457e33f753784d3237ca8ea8b/" rel="bookmark">
			必备Python代码段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些常用的Python代码段，用于不同的编程任务：
1. 读取文件内容：
def read_file(file_path): try: with open(file_path, 'r') as file: content = file.read() return content except FileNotFoundError: return "File not found." except Exception as e: return f"An error occurred: {e}" 2. 列表推导：
numbers = [1, 2, 3, 4, 5] squared = [x ** 2 for x in numbers] 3. 字典操作：
student = {'name': 'John', 'age': 20, 'grade': 'A'} student['school'] = 'XYZ School' 4. 条件判断：
age = 18 if age &gt;= 18: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/509ab1d457e33f753784d3237ca8ea8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c374a2f7c0e0656f22d101794cd2d8/" rel="bookmark">
			c语言中代码运行时发生c&#43;&#43;弹窗的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言代码运行时弹出C++风格的窗口可能是由于以下几种情况引起的：
使用了C++库函数： 如果你的C代码中调用了C++标准库函数，这可能导致C++风格的窗口弹出。避免在C代码中使用C++库函数，确保只使用C标准库函数。链接错误： 如果C代码与C++代码混合编译，链接错误可能导致C++风格的弹窗。确保C和C++代码分开编译，并正确链接。编译器选项： 一些编译器选项可能会导致C++运行时环境被引入。确保使用适合的编译器选项，将代码编译为纯C代码。第三方库： 如果你在C代码中使用了带有C++部分的第三方库，可能会触发C++弹窗。尽量使用纯C的库，或者将与C++相关的部分隔离开来。 解决方法：
检查代码： 仔细检查你的代码，确保没有调用C++库函数或引入C++语法。遵循纯C语言的语法和函数调用。分离代码： 如果项目需要混合C和C++，将C代码和C++代码分开，分别进行编译，然后在链接阶段合并。编译器选项： 确保使用正确的编译器选项，将代码编译为纯C代码，例如对于gcc，使用"-std=c11"选项。第三方库： 如果使用第三方库，尽量选择纯C的库，避免引入C++部分。如果不可避免，确保正确处理C和C++代码的分离。 通过遵循这些步骤，你应该能够解决在C语言代码运行时出现C++弹窗的问题，确保代码在纯C环境中运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00d3d5f6e79dd43b200eb5d62e6ea64/" rel="bookmark">
			同一端口同一方法提供grpc和http流量支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在同一端口上支持gRPC和HTTP流量的方法：
使用gRPC Gateway： gRPC Gateway是一个可以将gRPC服务转换为HTTP/JSON API的工具。你可以在同一个端口上启动gRPC服务和gRPC Gateway，通过HTTP请求访问gRPC服务。这样，你可以同时支持gRPC和HTTP流量。使用HTTP/2： gRPC使用HTTP/2作为传输协议，而HTTP/2也支持普通的HTTP请求。通过在同一端口上启用HTTP/2，你可以在同一个端口上同时支持gRPC和HTTP请求。使用反向代理： 使用反向代理服务器（如Nginx）将流量分发到不同的后端服务。你可以在Nginx中配置代理规则，将gRPC请求转发到gRPC服务，将HTTP请求转发到HTTP服务。使用路径分发： 如果你可以通过请求路径来区分gRPC和HTTP请求，你可以在同一端口上启动一个HTTP服务，然后根据请求路径将流量分发到不同的处理逻辑（gRPC或HTTP）。使用协议判断： 在你的应用中，可以根据请求的协议（HTTP/1.1或HTTP/2）来判断是处理HTTP请求还是gRPC请求，然后分别进行处理。 以上方法可以让你在同一端口上同时支持gRPC和HTTP流量。具体的选择取决于你的项目需求和技术架构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113a7e8554ad19e9f8de8cd164ea4576/" rel="bookmark">
			Jenkins配置测试报告后无法正常显示或显示空的解决方法（问题集锦）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jenkins配置测试报告无法正常显示或显示空的解决方法：
检查路径和文件名： 确保在Jenkins配置中指定的测试报告路径和文件名是正确的，与实际生成的测试报告文件一致。构建后操作设置： 在Jenkins的构建配置中，确保已正确设置"Publish JUnit test result report"或其他适用的后操作，以便Jenkins能够正确解析和展示测试结果。插件版本兼容性： 检查Jenkins插件的版本是否与项目和工具链兼容。可能需要升级或降级插件以解决兼容性问题。查看控制台输出： 查看Jenkins构建的控制台输出，可能会显示有关为何无法正确解析测试报告的错误消息。报告格式： 确保测试报告是以支持的格式（如JUnit、TestNG等）生成的，以便Jenkins能够正确解析。文件编码： 确保测试报告文件的编码与Jenkins期望的编码一致，避免编码问题导致无法正确读取报告内容。权限设置： 确保Jenkins具有访问测试报告文件的权限，检查文件和文件夹的权限设置。日志调查： 如果测试报告是通过插件生成的，可以检查插件的日志以查找可能的问题。使用代理： 如果Jenkins位于内部网络中，可能需要配置代理以确保Jenkins能够正确获取测试报告。重启Jenkins： 有时在应用配置更改后重启Jenkins服务可以解决问题。 根据具体情况逐一排查上述问题，往往可以解决Jenkins配置测试报告无法正常显示或显示空的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf3ef76a86d26c463a929189dc5a7ccb/" rel="bookmark">
			Linux进程和计划任务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux进程和计划任务管理：
进程管理：
ps命令：用于查看当前运行的进程列表。top命令：实时监控系统中的进程，显示CPU、内存使用情况等。kill命令：发送信号给进程，终止或控制进程行为。pkill命令：根据进程名或其他属性杀死进程。pgrep命令：根据进程名查找进程的PID。 后台运行：
使用 &amp;：在命令后面添加 &amp;，使命令在后台运行。nohup命令：在命令前面加上 nohup，即使关闭终端，进程也会继续运行。 计划任务管理：
cron：用于定期执行任务。使用 crontab -e编辑用户的计划任务列表。at：一次性计划任务。使用 at命令指定时间执行任务。 后台守护进程：
后台守护进程是在系统启动时启动的后台进程，常常用于常驻系统，如 systemd。 进程优先级和限制：
nice命令：改变进程的优先级。ulimit命令：限制用户进程的资源使用。 查找僵尸进程：
使用 ps aux | grep 'Z'命令可以查找僵尸进程。 进程间通信：
Linux提供多种IPC机制，如管道、信号、消息队列、共享内存等。 通过这些命令和工具，你可以有效地管理Linux系统中的进程和计划任务，监控系统的运行状态并保持系统的稳定和可靠性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c2878fc4abf70564c721c678387e38b/" rel="bookmark">
			Linux中的known_hosts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中的known_hosts：
known_hosts是Linux系统中一个存储已知主机公钥的文件，用于SSH客户端验证远程主机的身份。当你连接到远程主机时，SSH客户端会检查该主机的公钥是否存在于 known_hosts文件中，以确保你连接到的是正确的主机而不是恶意主机。
known_hosts文件的路径通常在用户的家目录下的 .ssh文件夹内，文件名为 known_hosts。每个记录包含主机名、公钥、算法等信息，以及用于验证主机的指纹。当你首次连接到一个新的远程主机时，SSH会将该主机的公钥添加到 known_hosts文件中。如果主机公钥发生变化，SSH会发出警告，因为这可能意味着连接到了不安全的主机。
示例：
example.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC... (公钥) 通过维护 known_hosts文件，你可以防止中间人攻击，确保你连接的远程主机的真实性和安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399a3d2cf0a8f172394019d9b3127b86/" rel="bookmark">
			并查集&#43;巧妙分块，Codeforces1424B. 0-1 MST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、题目
1、题目描述
2、输入输出
2.1输入
2.2输出
3、原题链接
二、解题报告
1、思路分析
2、复杂度
3、代码详解
一、题目
1、题目描述 Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.
It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/399a3d2cf0a8f172394019d9b3127b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f248916ea47d341ec828e93186f48ac/" rel="bookmark">
			测试ASP.NET Core项目调用EasyCaching的基本用法（Redis）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyCaching中的包EasyCaching.Redis和EasyCaching.CSRedis都支持集成Redis实现缓存，前者基于StackExchange.Redis，而后者基于CSRedisCore，本文学习使用EasyCaching.Redis包连接redis服务实现缓存的基本用法。
新建WebApi项目，在Nuget包管理器中搜索并安装EasyCaching.Redis包：
接着在Program.cs文件中注册服务，主要使用AddEasyCaching和UseRedis函数，使用示例如下所示（示例参考自参考文献3，不过代码有问题，后续会提到），连接参数可以通过UseRedis配置，也可以通过配置文件配置，详细的说明见参考文献3。
builder.Services.AddEasyCaching(options =&gt; { options.UseRedis(config =&gt; { config.DBConfig.Endpoints.Add(new ServerEndPoint("127.0.0.1", 6379)); }); }); 在控制器类中使用时，可以使用IEasyCachingProvider接口，此时使用方式与上一篇文章相同，在此不再赘述，也可以使用IRedisCachingProvider接口，该接口中的函数与redis控制台命令相似，使用更加方便，测试用例如下所示：
public class EasyCachingController : ControllerBase { private readonly IRedisCachingProvider _provider; public EasyCachingController(IRedisCachingProvider provider) { _provider = provider; } [HttpGet] public string GetValue(string key) { if(!_provider.KeyExists(key)) { throw new Exception($"不存在key{key}"); } return _provider.StringGet(key); } [HttpPost] public void SaveData(string key,string value) { _provider.StringSet(key, value); } } 运行WebApi，在浏览器中调用GetValue测试，测试过程中报如下错误：“Value cannot be null.(Parameter"serializers”），百度错误信息，找了很多文章都没有看到类似的错误解决办法。
最终还是从开源博客项目Blog .NET Core源码中找到的问题原因，首先需要安装序列化包，主要包括5类，如下图所示。本文中安装的是包EasyCaching.Serialization.Json。
其次将Program.cs文件中注册EasyCaching服务的代码修改为如下方式，主要是增加了options.WithJson函数（如果是安装的其它序列化包，则需调用options中对应的函数）。同时WithJson函数中的参数（服务实例名称），要与UseRedis函数中指定的实例名称保持一致，否则后续还会报错。
builder.Services.AddEasyCaching(options =&gt; { options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f248916ea47d341ec828e93186f48ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d4deae561b7834e37ca218c4531c59/" rel="bookmark">
			WPOpenSocial实现WordPress的QQ登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人建站不可避免的需要自己搭建用户数据库的问题，可用户却往往因为注册繁琐而放弃浏览您的网站，由此可见，一个社交账号一键登录方式尤为重要。选择适合您网站需求的社交插件，可以提升用户互动，增加社交分享，同时丰富网站内容，本文即是介绍 WP Open Social 插件实现个人 WordPress 网站的 QQ 登录。
WP Open Social 插件为 WordPress 网站提供了便捷的QQ登录集成功能，使用户可以通过他们在 QQ 上的账户轻松登录 WordPress 站点。本文将介绍如何安装和配置 WP Open Social 插件，以及申请并集成 QQ 互联的 APPID 和 APPSECRET。通过详细的步骤，读者将能够在他们的 WordPress 网站上启用 QQ 登录，并实现更加便利和安全的用户身份验证。
WordPress 实现 QQ 授权登录需要三个步骤：
第一步，安装启用 WP 插件 WP Open Social，可以为我们的界面增加社交软件的登录入口；第二步，申请QQ互联开发者账号获得 APPID 和 APPKEY；第三步，将 ID、KET、回调域名填入 WP Open Social 并最终测试。 下面，是WPOpenSocial实现WordPress的QQ登录步骤的详细介绍。
一、下载WPOpenSocial插件 要安装 WP Open Social 插件，可以在 WordPress 的插件商店、官方网站或 GitHub 上找到该插件，并按照个人偏好的路径进行下载。
如果选择在WordPress插件商店以外的地方下载，下载完成后需要将插件文件夹复制到线上WordPress路径的插件目录下，然后返回WordPress控制台启用插件。
二、启用WPOpenSocial插件 WP Open Social 插件可以直接在 WordPress 自带的插件库里搜索下载，下载完成后启用，可以在插件设置里设置开启哪些登录方式，开启的登录方式会在我们的登陆界面显示入口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d4deae561b7834e37ca218c4531c59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5277a1a139464e93f5fd1453d20cad15/" rel="bookmark">
			【BUG】golang gorm导入数据库报错 “unexpected type clause.Expr“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		帮同事排查一个gorm导入数据报错的问题
事发现场 ck sql
CREATE TABLE ods_api.t_sms_jg_msg_callback_dis ( `app_key` String DEFAULT '' COMMENT '应用标识', `callback_type` Int32 DEFAULT 0 COMMENT '0送达，1回执', `channel` Int32 DEFAULT 0 COMMENT 'uid下发的渠道', `model` String DEFAULT '' COMMENT '设备机型', `jgid` String DEFAULT '' COMMENT '极光返回的msgid', `notification_state` Int8 DEFAULT 0 COMMENT '接收通知时通知开关是否打开', `params` String DEFAULT '' COMMENT '用户在push API推送请求的时候在payload的callback里自行指定的参数', `platform` String DEFAULT '' COMMENT '推送平台', `registration_id` String DEFAULT '' COMMENT '设备唯一标识', `alias` String DEFAULT '' COMMENT '设备registration_id对应的别名', `send_time` String DEFAULT '' COMMENT '通知的送达时间/ 用户点击通知的时间', `created_at` DateTime DEFAULT now() ) ENGINE = ReplacingMergeTree(created_at) PARTITION BY toDate(created_at) ORDER BY (callback_type, jgid, registration_id, send_time) SETTINGS index_granularity = 8192 COMMENT '极光push点击/送达回执记录表,中台notify服务用' go 数据表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5277a1a139464e93f5fd1453d20cad15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e268b59af6e90be4260bc28e3f5ddb/" rel="bookmark">
			AJAX进阶（重点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
◆ 同步代码和异步代码
◆ 回调函数地狱和 Promise 链式调用
什么是回调函数地狱？
Promise - 链式调用
什么是Promise链式调用？
Promise 链式应用 （重点）
◆ async 和 await 使用
async函数和await_捕获错误 ◆ 事件循环-EventLoop（重点）
为什么要学习事件循环？
什么是事件循环？ 事件循环 - 执行过程（重点）
事件循环 - 练习 宏任务与微任务 （重点）
事件循环 - 经典面试题 ◆ Promise.all 静态方法
◆ 同步代码和异步代码 什么是同步代码，什么是异步代码？
同步代码：
异步代码：
同步代码：逐行执行，需原地等待结果后，才继续向下执行 异步代码：调用后耗时，不阻塞代码继续执行（不必原地等待），在将来完成后触发一个回调函数
例子：回答打印数字的顺序是什么？ 打印结果：1,4,2 点击按钮一次就打印一次 3 异步代码接收结果：使用回调函数
◆ 回调函数地狱和 Promise 链式调用 什么是回调函数地狱？ 需求：展示默认第一个省，第一个城市，第一个地区在下拉菜单中
概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调函数地狱
缺点：可读性差，异常无法捕获，耦合性严重，牵一发动全身
总结：简单讲。回调函数地狱就是在回调函数中嵌套回调函数，进而导致代码耦合度高，异常难以捕获
Promise - 链式调用 什么是Promise链式调用？ 概念：依靠 then() 方法会返回一个新生成的 Promise 对象特性，继续串联下一环任务，直到结束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59e268b59af6e90be4260bc28e3f5ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c767040a4a8f3530dcb1df9668324f7/" rel="bookmark">
			测试ASP.NET Core项目调用EasyCaching的基本用法（InMemory）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyCaching属于开源缓存库，支持基本缓存方式及高级缓存用法，提高用户操作缓存的效率。EasyCaching支持的缓存方式包括以下类型，本文学习最基础的InMemory方式的基本用法。
EasyCaching.InMemory包属于基于内存的缓存库，使用的是程序所在计算机的内存，一般也称作本地缓存。
新建ASP.NET Core WebApi项目，在Nuget包管理器中搜索并安装EasyCaching.InMemory包：
接着需要在Program.cs文件中添加EasyCaching服务，主要是调用EasyCaching.Core程序集中的EasyCachingServiceCollectionExtensions.AddEasyCaching函数添加服务，最简单的用法如下所示：
builder.Services.AddEasyCaching(options =&gt; { options.UseInMemory("default"); }); 调用UseInMemory函数时，除了实例名称，还可以进行更详细的参数设置，EasyCaching支持在UseInMemory函数中进行设置，也支持在appsettings.json中设置参数后通过UseInMemory函数读取配置，如下图所示，更详细的说明见参考文献3。
注册服务后，即可在控制器类中使用，在控制器构造函数中传入IEasyCachingProvider接口，该接口继承自IEasyCachingProviderBase，后者包含常用的缓存操作函数，如下图所示：
编写简单的测试控制器类进行测试，代码如下图所示：
public class EasyCachingController : ControllerBase { private readonly IEasyCachingProvider _provider; public EasyCachingController(IEasyCachingProvider provider) { _provider = provider; } [HttpGet] public string GetValue(string key) { if(!_provider.Exists(key)) { throw new Exception($"不存在key{key}"); } return _provider.Get&lt;string&gt;(key).Value; } [HttpPost] public void SaveData(string key,string value) { _provider.Set&lt;string&gt;(key, value, new TimeSpan(0, 0, 30)); } } 直接在浏览器中测试WebApi接口，如下图所示，测试SaveData函数：
点击Execute按钮后报如下错误，应该是跨域访问的问题，本文中直接按《ASP.NET Core WebAPI从HTTPS调整为HTTP启动》中的方式删除了https相关内容后，即可正常调用函数。
接着调用GetValue函数获取值，如下图所示，可以正常返回指定key的值。
参考文献：
[1]https://github.com/dotnetcore/EasyCaching
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c767040a4a8f3530dcb1df9668324f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd35210658673e88abc2090eeec865d0/" rel="bookmark">
			【如何轻松拿捏LIO-SAM？】今天终于来啦！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中科院保研硕士教你如何轻松拿捏LIO-SAM，不仅会对LIO-SAM的论文原理和代码进行详细讲解，也会对SLAM中的数学知识、LOAM、LeGO-LOAM的论文原理及代码进行详细讲解，2024年1月28日开始更新啦！之后每周日晚20:00更新一章，欢迎大家了解更多信息！！
【第一章：绪论】部分的视频已经在我女朋友的B站更新啦！！！
下面是一些课程PPT片段~
课程简介 LOAM是目前为止激光里程计(LO)领域最经典最广泛使用的方法，堪称LO领域的baseline，至今仍在KITTI数据集上名列前茅。但是它存在诸多问题，比如：它直接存储全局体素地图而不是局部地图，从而很难执行回环检测以修正漂移；没有很好地使用IMU、GPS等测量融合进行位姿修正；并且体素地图的使用效率会随时间降低。
后续有很多研究者提出了各种改进方法提高LOAM在不同场景下的性能，如FAST-LIO使用EKF整合LiDAR和IMU的测量；LeGO-LOAM引入地面分割和回环检测进一步提高UGV的定位和建图性能；但其中效果较好的当属LIO-SAM，LIO-SAM是一种紧耦合的激光-惯性里程计方法，LIO-SAM可以说是LO的理想框架，其继承了LOAM特征检测和ICP匹配的稳定性，实现了激光雷达-IMU-GPS的多传感器融合，引入了回环检测方法修正全局漂移，利用了多种方法提高了SLAM算法的精度。
但是LIO-SAM中涉及到很多内容和理论的推导，不仅包括LOAM中原有的特征检测、特征匹配、噪声去除等内容，还使用了因子图来组织整个系统，其代码中使用了GTSAM包进行建模；除此之外，由于其紧耦合的设计，还使用了IMU预积分的知识，这部分知识往往是复杂的，对数学公式的的推导要求较高。
虽然网上也有一些LIO-SAM的论文讲解，但大部分都是对论文的简单翻译；虽然也有一些视频教程，但知识体系比较零散，铺天盖地的讲解导致很多初学者不能很好的把握其中的关键；关于其代码的讲解更是寥寥无几，导致很多同学很难理解其代码架构，更别提自己动手书写。
基于此，我们「3D视觉从入门到精通」知识星球特地增加了「如何轻松拿捏LIO-SAM？」系列视频课程，希望通过这门课，大家能对LIO-SAM的理论和代码有一些清晰的认识，自己能够真正地理解其算法思路，并进一步学习到一些阅读其他相关论文或代码的方法。
1.课程讲师 K.Fire，哈尔滨工业大学本科毕业保研至中国科学院大学攻读硕士，主要专注于3D激光SLAM、动态SLAM研究，CSDN资深博主，4000+粉丝量，热衷于知识分享。
2.课程大纲 第一章：绪论
LOAM系列算法介绍及比较LIO-SAM优势及效果展示
第二章：预备知识矩阵基础三维刚体变换李群与李代数非线性优化拓展:卡尔曼滤波
第三章：LOAM论文及原理详解LOAM论文带读ICP算法原理与发展、SVD分解LOAM代码速通、PCA算法
第四章：LeGO-LOAM、LIO-SAM论文及原理讲解LeGO-LOAM原理讲解LeGO-LOAM代码速通LIO-SAM原理讲解
第四章：LIO-SAM代码详解前端-GTSAM、IMU预积分、位姿融合后端-点云配准、建图、回环检测
第五章：实战及总结ROS系统简介及代码运行总结、未来工作
本课程自2024年1月28日开课，每周更新一章 3.课程收获及亮点 （1）对LIO-SAM算法的原理及应用有更深刻地理解；
（2）对LOAM系列的传统激光3D SLAM算法的原理及局限有更深入的理解，了解到常见的分析和改进方法；
（3）学习到以初学者的角度，如何高屋建瓴的把握一类算法的学习方法和学习经验，了解作为初学者如何高效吃透一种算法；
（4）掌握代码阅读及实现的方法，更加透彻的掌握代码阅读及实现过程。
4.还能收获什么 1.优质的学习圈子 星球汇集了国内外各个高校的研究生、博士生，包括但不限于清华大学、上海交通大学、华中科技大学、武汉大学、南京大学、北京理工大学、北京航空航天大学；以及国外留学的小伙伴，主要就读于南加州大学、墨尔本大学、慕尼黑工业大学、亚琛工业大学等。除此之外，还有很多一线工作的算法工程师、开发人员，包括但不限于百度、旷视、华为、奥比中光、云从、阿丘科技等。
星球的主要嘉宾
3D视觉从入门到精通知识星球是一个技术社区，在这里你可以讨论任何3D视觉相关的难题、前沿技术。星球邀请了国内外高校博士（北航、慕尼黑工业大学等）、CV独角兽公司CTO/CEO、以及各大厂的算法工程师解惑。在这里，你可以一对一和大佬交流，提出自己在工作学习上的疑问。
合作企业
知识星球现已和众多公司建立了良好的合作关系，公司内的算法负责人会不定期的来内部进行前沿技术/产品分享，除此之外，星球也为公司推荐合格的算法/开发人才。现有合作企业包括但不限于：华为云、腾讯、图漾科技、镭神智能、中科慧眼、INDEMIND、迁移科技、追势科技等~
2.各种SLAM学习文章及代码 星球中不仅包含3D激光SLAM的各种算法及代码讲解，另外涵盖了多模态融合SLAM、视觉SLAM、三维重建、相机标定等多种领域讲解专栏，更有如ORB-SLAM3、Vins-Fusion等各种经典框架的详细讲解视频教程，在星球进行提问可向包括讲师在内的多位领域大牛进行提问，并获得及时解答。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803130ab187cd28a7da87335b17f7faa/" rel="bookmark">
			AJAX的原理（重点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		◆ XMLHttpRequest 什么是XMLHttpRequest？ 定义：
关系：axios 内部采用 XMLHttpRequest 与服务器交互
注意：直白点说就是axios内部就是封装了XMLHttpRequest这个对象来实现发送异步请求的
使用 XMLHttpRequest 步骤：
1. 创建 XMLHttpRequest 对象
2. 配置请求方法和请求 url 地址
3. 监听 loadend 事件，接收响应结果
4. 发起请求
1.无参数的情况 获取并展示所有省份名字 //1. 创建 XMLHttpRequest 对象 const xhr = new XMLHttpRequest() //2. 配置请求方法和请求 url 地址 xhr.open('GET','http://hmajax.itheima.net/api/province') //3. 监听 loadend 事件，接收响应结果 xhr.addEventListener('loadend',function(){ console.log(xhr.response); const rs = JSON.parse(xhr.response) console.log(rs.list.join('&lt;br&gt;')); document.querySelector('p').innerHTML = rs.list.join('&lt;br&gt;') }) //4. 发起请求 xhr.send() 2.有URL查询参数的情况 使用字符串拼接 使用浏览器提供的内置对对象 URLSearchParams // 1. 组织查询参数字符串 const qObj = { pname: '辽宁省', cname: '大连市' } // 2查询参数对象 -&gt; 查询参数字符串 const paramsObj = new URLSearchParams(qObj) const queryString = paramsObj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/803130ab187cd28a7da87335b17f7faa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fae8be92e89e1f78fc1a5a978cecc05/" rel="bookmark">
			【Go-Zero】Windows启动rpc服务报错panic:context deadline exceeded解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Go-Zero】Windows启动rpc服务报错panic:context deadline exceeded解决方案 大家好 我是寸铁👊
总结了一篇Windows11下启动rpc服务报错panic解决方案的文章✨
喜欢的小伙伴可以点点关注 💝
问题来源 今天在编写完proto文件后，使用goctl生成对应的rpc 服务文件时，启动rpc 服务，发现panic 报错。
goctl命令
// rpc目录下创建 goctl rpc protoc user.proto --go_out=types --go-grpc_out=types --zrpc_out=. 报错信息 报错信息如下：
具体如下：
panic: context deadline exceeded
goroutine 1 [running]:
github.com/zeromicro/go-zero/zrpc.(*RpcServer).Start(0x28d3ec0?)
D:/Environment/GoWorks/pkg/mod/github.com/zeromicro/go-zero@v1.6.1/zrpc/server.go:89 +0x75
main.main()
D:/GoProject/zero_study/user/rpc/user.go:38 +0x299
exit status 2
排查 方法1 是不是其他进程的占用了启动rpc 服务的默认端口:2379
需要先把进程关闭，再启动服务。
必要时，重启电脑，试一下
方法2(优先尝试) 假如不是上面的原因引起的，则说明是因为etcd 服务没有启动！
为什么？
这里需要简单了解一下rpc 的原理
查阅一下官方文档
这说明使用goctl生成rpc服务时会默认向etcd注册中心注册当前服务的信息，也就是说etcd需要开启，才能接收到生成的rpc服务发送过来的信息！
在清楚这个原理后，只需要启动etcd 服务即可。
假如你还没有安装etcd ，那么需要先安装一下。
具体安装教程见这篇博客
如果你已经安装，那么需要手动打开一下
首先，找到你安装etcd 的文件夹
接着，需要在路径框输入cmd
最后，在启动的窗口中输入etcd 即可 之后再回到goland去启动rpc 服务即可！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fae8be92e89e1f78fc1a5a978cecc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3fd1f917a3847e26384d0be41f922e1/" rel="bookmark">
			Tensorflow2.0笔记 - tensor的padding和tile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本笔记记录tensor的填充和tile操作，对应tf.pad和tf.tile
import tensorflow as tf import numpy as np tf.__version__ #pad做填充 # tf.pad( tensor,paddings, mode='CONSTANT',name=None) #1维tensor填充 tensor = tf.random.uniform([5], maxval=10, dtype=tf.int32) print(tensor) #参数paddings最外层方括号必须加，对于1维tensor，只有一个维度 #因此最外层方括号里面只有一个内层[A,B] #左边填充1列，右边填充2列的话，A=1，B=2 print("=====tf.pad(tensor, [[1,2]])\n", tf.pad(tensor, [[1,2]])) #2维tensor填充 tensor = tf.random.uniform([2,2], maxval=10, dtype=tf.int32) print(tensor) #上下填充一行，左右填充一列 print("=====tf.pad(tensor, [[1,1],[1,1]]):\n", tf.pad(tensor, [[1,1], [1,1]])) #上面不填充，下面填充两行，左边填充两列，右边填充一列 print("=====tf.pad(tensor, [[0,2],[2,1]]):\n", tf.pad(tensor, [[0,2], [2,1]])) #padding实际案例，图片数据padding #假设下面的tensor表示2张5*5*3的图像数据 tensor = tf.random.uniform([2,5,5,3], maxval=256, dtype=tf.int32) #在图像的上下填充两行，左右填充两列数据 print("=====tf.pad(tensor, [[0,0],[2,2],[2,2],[0,0]]).shape:\n", tf.pad(tensor, [[0,0],[2,2],[2,2],[0,0]]).shape) #tile复制数据 #tile(input, #输入 # multiples, #同一维度上复制的次数 # name=None #) #https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3fd1f917a3847e26384d0be41f922e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c8aaf86adecc518466a629fae88363/" rel="bookmark">
			【C语言】（9）分支结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.if-else 语句 if-else 适用于简单和复杂的条件判断。
a. 基本 if 语句 用途：基本的条件测试。语法：if (condition) { // 代码块 } 示例：if (score &gt; 60) { printf("及格\n"); } b. if-else 语句 用途：二选一的条件判断。语法：if (condition) { // 条件为真时的代码 } else { // 条件为假时的代码 } 示例：if (age &gt;= 18) { printf("成年\n"); } else { printf("未成年\n"); } c. if-else if-else 语句 用途：处理多个条件。语法：if (condition1) { // 第一个条件的代码 } else if (condition2) { // 第二个条件的代码 } else { // 所有条件都不满足时的代码 } 示例：if (score &gt;= 90) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73c8aaf86adecc518466a629fae88363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b4b68ffe0e8f803b628b8a118500d9/" rel="bookmark">
			机器学习系列 16：使用 scikit-learn 的 Pipeline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习项目中，我们经常需要进行大量的数据预处理步骤，最后用处理干净的数据集来拟合机器学习算法得到一个合适的机器学习模型。
scikit-learn 提供了一个强大的 Pipeline 类来帮助我们将所有的数据预处理步骤和训练模型的步骤串起来。就像流水线一样，前一个步骤处理完的结果输入到下一个步骤，依次处理。
这里我们将使用 UCI 提供的威斯康星洲乳腺癌数据集，下载地址如下：
https://archive.ics.uci.edu/dataset/17/breast+cancer+wisconsin+diagnostic
这个数据集一共包含 569 个样本，每个样本有 30 个实数值特征，数据集的前 2 列分别是标识病人的 ID 和肿瘤诊断结果（M 表示恶性，B 表示良性）。让我们首先加载数据集，然后抽取出特征 X 和类别 y，我们还用了 scikit-learn 提供的 LabelEncoder 将字符串表示的样本类别编码成数字表示。
现在我们已经将 M 编码成 1，B 编码成 0。
然后我们将数据集拆分成训练集和测试集，其中训练集占 80%，测试集占 20%。
许多机器学习算法要求输入的特征的取值范围都在同一个范围内，由于这里的数据集中的特征是以不同的度量标准测到的，所以我们需要标准化特征。然后，假设我们还要将这 30 维的高维数据通过 PCA 压缩到 2 维空间。最后我们用数据集拟合逻辑回归算法得到一个二分类模型。
我们可以通过 make_pipeline 函数将中上述步骤中涉及的标准化、PCA 和训练模型串到一个管道（pipeline）中。
make_pipeline 函数可以接收任意数量的 scikit-learn transformer（包含 fit 和 trasnform 方法的对象），最后跟一个 scikit-learn estimator（实现了 fit 和 predict 方法的对象）。
在前面的例子中，StandardScaler() 和 PCA() 就是 transformer，LogisticRegression 就是 estimator。
在我调用 pipe_lr 的 fit 方法时，Pipeline 会先调用 transformer 的 fit_transform 方法（fit_transform 方法其实先调用 fit 再调用 transform），然后调用 estimator 的 fit 方法来训练模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b4b68ffe0e8f803b628b8a118500d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb806e6ba113020eeef0fa7674c12126/" rel="bookmark">
			探讨UI自动化测试几步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着软件开发的不断发展，UI自动化测试变得越来越重要，它能够提高测试效率、降低人为错误，并确保软件交付的质量。本文将介绍UI自动化测试的一般步骤和一些最佳实践，以帮助开发团队更好地实施自动化测试。
需求分析和选择测试工具：在进行UI自动化测试之前，首先需要明确测试的需求，包括被测应用的功能、支持的平台等。然后选择适合项目的测试工具，如Selenium、Appium、Cypress、掌动智能等。
环境设置和配置：确保测试环境的稳定性和一致性，包括被测应用的版本、浏览器或设备的设置等。配置好测试工具，确保能够正确地与应用进行交互。
制定测试计划和用例设计：基于需求分析，制定详细的测试计划，明确测试的范围和目标。设计具体的测试用例，覆盖关键的功能和路径，确保测试的全面性和有效性。
编写测试脚本：使用选择的测试工具编写测试脚本，这些脚本将模拟用户与应用的交互。确保脚本的可维护性和可扩展性，以应对应用变更和新增功能。
执行自动化测试：运行编写好的测试脚本，监控测试的执行过程。注意收集测试结果、日志和可能的异常信息，以便后续的分析和调试。
结果分析与报告：分析测试结果，确定是否符合预期。生成详细的测试报告，包括通过的用例、失败的用例、异常信息等，以便开发团队能够迅速定位和修复问题。
定期维护和更新测试脚本：应用的变更和更新可能影响测试脚本的执行，因此需要定期维护和更新测试脚本，保持其与应用同步。
集成到持续集成/持续交付(CI/CD)流程：将UI自动化测试集成到CI/CD流程中，确保每次代码提交都会触发相应的测试。这有助于快速发现和解决问题，提高软件交付的速度和质量。
培训和知识共享：对团队成员进行培训，确保他们了解并能够有效地使用UI自动化测试工具。建立知识共享机制，让团队成员分享经验和最佳实践。
综上所述，UI自动化测试是确保软件质量的关键步骤，通过明确的步骤和最佳实践，团队可以更好地规划、执行和维护自动化测试，提高软件开发的效率和质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a05e4a753e7c89f641f8b44c4a4dc27/" rel="bookmark">
			在centos 7 中安装配置Jdk、Tomcat、及Tomcat自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装配置Jdk
1.创建目录并上传文件
2.解压JDK压缩包
3.配置JDK环境变量
4.设置环境变量生效
二、安装配置Tomcat
1.上传Tomcat并解压
2.启停Tomcat
3.修改tomcat-user.xml配置
4.配置远程访问Tomcat
5.远程项目发布
三.Tomcat自启动配置
1.配置Tomcat自启动服务：
2.重启或关闭虚拟机：
前言:
版本：Jdk1.8、Tomcat8.5
远程连接软件：FinalShell
安装配置centos 7 查看：Linux之安装配置CentOS 7-CSDN博客
需压缩包及文件后台私信
一、安装配置Jdk 1.创建目录并上传文件 在/usr/local目录下创建mytools目录，用于存放后续所有的安装文件。
# 创建目录mkdir /usr/local/mytools # 上传文件 rz jdk-8u151-linux-x64.tar.gz 2.解压JDK压缩包 将上传至/usr/local/mytools/目录下jdk压缩包文件，解压至指定的/usr/local目录中。
# 切换目录 cd /usr/local/mytools # 解压文件 tar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local 在解压的时候 -C 是解压到指定目录中，一定要加-C参数，而且区分大小写的。 &amp;&amp;可将多条命令合成一行
cd /usr/local/mytools &amp;&amp; tar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local tar文件解压缩命令：
# 压缩 tar -zcvf 压缩名.tar.gz 文件/目录 # 解压 tar -zxvf 压缩包名 # 静默解压 tar -zxf 压缩包名 zip文件解压缩命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a05e4a753e7c89f641f8b44c4a4dc27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c1dd7c4a0b3ec7e82bed8e11117629/" rel="bookmark">
			kotlin协程flow retryWhen当加载失败后重试功能函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import kotlinx.coroutines.delay import kotlinx.coroutines.flow.* import kotlinx.coroutines.runBlocking import java.lang.NullPointerException fun main(args: Array&lt;String&gt;) { runBlocking { load().onEach { if (it == null) { throw NullPointerException() } }.retryWhen { cause, attempt -&gt; if (cause is NullPointerException) { println("重试 $attempt") delay(1000) //延时重新尝试 } attempt &lt; 3 } .onCompletion { println("onCompletion") } .collect { println("collect $it") } } } fun load() = flow { //生成一个概率布尔，模拟加载概率性成功与失败 var b = Boolean.let { var p: Int = (Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c1dd7c4a0b3ec7e82bed8e11117629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/088734f49693da880b522fa4731556d4/" rel="bookmark">
			retrywhen实现重连（kotlin）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大多数人都在用rxjava+retrofit网络框架,在用着框架的时候我们不难发现，一些复杂，连续请求不再复杂，那么我今天提到的retrywhen操作符作用是什么呐?
在我们开发过程中肯定有网络请求断开，失败的情况，可是用户的网络立马又回复正常了，这时候我们突然给用户toast一个网络请求失败,很明显这种体验度不是很好.下面我就贴上我用retrywhen实现重连请求的代码:
val loginService = Retrofit.Builder().addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .baseUrl("") .client(OkHttpClient.Builder() .readTimeout(15, TimeUnit.SECONDS) .writeTimeout(15, TimeUnit.SECONDS) .connectTimeout(5, TimeUnit.SECONDS) .addInterceptor(HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY)) .build()) .build().create(Api.LoginService::class.java) loginService.doLogin("", "", "") .retryWhen { throwableObservable -&gt; throwableObservable.flatMap&lt;Any&gt; { throwable -&gt; //--是网络异常或者i/o并且重连次数小于3就重新发送请求 if (throwable is IOException &amp;&amp; ++retrycount &lt; 3) { Log.e("--throwable-", "第" + retrycount + "次重试") Observable.timer(3, TimeUnit.SECONDS) } else Observable.error&lt;Any&gt;(throwable) } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(object : BaseObserver() { override fun onNext(t: Any) { } override fun onError(e: Throwable) { } }) ————————————————
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/088734f49693da880b522fa4731556d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba956cfc6fef13854df592318e30a37f/" rel="bookmark">
			go 面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 gochannelclose后读的问题 在Go语言中，当我们调用close(ch)关闭一个channel后，仍然可以从该channel中读取数据，直到channel中的数据全部被读取完。但需要注意以下几点：
从关闭的channel中读取数据时，接收操作不会阻塞，会一直返回channel中剩余的数据，直到channel为空。当channel关闭后，再次尝试从该channel中接收数据时，将得到对应类型的零值和一个布尔值false，这个布尔值用来表示是否成功从channel中获取到了有效数据。例如，对于整型channel ch := make(chan int), 从关闭的ch中读取数据可能是这样的：value, ok := &lt;-ch，如果channel已经关闭并且没有数据可读，那么ok为false，value为0（int类型的零值）。 示例代码：
Go
1ch := make(chan int) 2go func() { 3 defer close(ch) 4 ch &lt;- 1 5 ch &lt;- 2 6}() 7 8for i := 0; i &lt; 3; i++ { 9 value, ok := &lt;-ch 10 if ok { 11 fmt.Println("Received:", value) 12 } else { 13 fmt.Println("Channel is closed and no more data to receive.") 14 break 15 } 16} 上述代码中，goroutine会向channel中发送两个整数然后关闭它，主goroutine则会从channel中接收三次数据，前两次能成功接收到值并打印出来，第三次由于channel已关闭且无数据可读，因此会输出"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba956cfc6fef13854df592318e30a37f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5963f2beaa6a20cf08bc6ffc1604a2bf/" rel="bookmark">
			【学习笔记】vue3的watch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通
课程 P152节 笔记：
情况一：监视ref所定义的一个响应式数据
情况二：监视ref所定义的多个响应式数据
这两种情况比较简单，正常写就ok：
情况三：监视reactive所定义的一个响应式数据
这种情况下，问题来了，此时无法正确获取oldValue的值，打印如图：
此时如果一定要获取oldValue的值，可以将需要获取oldValue的某个属性值单独使用ref定义。
第二个坑是：强制开启了深度监视，也就是配置deep：false也不起作用
情况四：监视reactive所定义的一个响应式数据种的某个属性
这种情况需要将所要监视的属性写到一个函数的返回值里：
情况五：监视reactive所定义的一个响应式数据种的某些属性
特殊情况：监视reactive所定义的一个响应式数据的一个对象属性
此时由于监视的是reactive所定义的响应式对象种的某个属性，所以deep配置有效
特殊情况，如果不加{deep:true}，监视不奏效：
总结 如果监视的是一个reactive定义的响应式数据（情况三），则会出现两个小问题：1、无法正确获取到oldValue；2、强制开启了深度监视且无法关闭，即配置{deep:false}无效
如果监视的是一个reactive定义的响应式数据中的某一个对象属性（特殊情况），则需要配置{deep:true}监视才会生效；此时仍然无法正确获取到oldValue
貌似是：只要监视的值是对象，就无法获取到oldValue
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5106935c8efb3667cc1b8dcdb4ba43d2/" rel="bookmark">
			Flutter Web持久化存储SharedPreferences原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在Flutter中，类似于Android，SharedPreferences 是一种用于持久化存储键值对数据的机制
实现原理 对于移动平台（如Android和iOS），SharedPreferences 利用了各自平台的持久化存储能力。在Android上，它使用轻量级的Key-Value存储系统，在iOS上，使用UserDefaults
对于Web平台，SharedPreferences 的实现有所不同，因为Web平台没有与Android或iOS相同的持久化存储机制。在Web上，SharedPreferences 的实现是基于浏览器的 localStorage 功能
注意要点 localStorage：Web浏览器提供的一个持久化存储机制，允许网站存储键值对数据。它与会话存储（sessionStorage）类似，但它的数据在浏览器关闭后仍然保留
键值对存储：和移动平台上的实现一样，SharedPreferences 在Web上也是通过键值对来存储数据的。但在Web端，这些数据被保存在浏览器的 localStorage 中
数据持久化：使用 localStorage，数据会在用户的浏览器中持久化存储，即使关闭和重新打开浏览器，这些数据也会保留
限制：由于它是基于浏览器的，localStorage 有一些限制，如存储容量限制（通常为5MB左右），并且只能存储字符串。因此，对于非字符串类型的数据，SharedPreferences 需要将其序列化为字符串，然后再进行存储
附言 需要注意的是，用户可以通过清除游览器数据来删除localStorage中的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd3d106463ef8d475faa956777e38e5/" rel="bookmark">
			NSA承认购买敏感数据监控美国公民
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚焦源代码安全，网罗国内外最新资讯！
编译：代码卫士
上周四，美国参议员罗恩·怀登 (Ron Wyden) 披露称，美国国家安全局 (NSA) 承认从数据经纪商手中购买了关于美国公民所使用网站和应用详细信息的记录。
去年，怀登迫使FBI 承认它也在购买美国公民的敏感数据。如今，他呼吁所有情报机构“停止从非法获得数据的数据经纪商手中购买美国公民的个人数据”。
怀登在向美国国家情报总监 (DNI) 艾薇儿·海恩斯 (Avril Haines) 的信函中提到，“为此，请制定一项政策，未来，”情报机构‘’仅能按照由 FTC 颁布的合法数据出售标准购买美国公民的数据”。
怀登认为情报社区可能帮助数据经纪商违反FTC的一项指令。该指令要求美国公民的数据被出售给第三方之前，必须获得公民“清楚明确的”披露和知情同意。在怀登调查这些数据经纪商的七年里，他表示尚未“发现任何公司在收集用户数据之前发布了这类提醒”。FTC的指令在与数据经纪商 X-Mode 达成协议之后发生。X-Mode 承认在未获得用户同意的情况下出售用户的位置信息，甚至在用户取消同意之后仍然出售这些数据。
怀登在信函中指出该指令是 FTC 提出的“新规则”，但实际并非如此。FTC 并未发布新规则，而是FTC的协议通常被视作“判例法”，是对违反《FTC 法案》等法律的市场发出的信号。
从FTC在网站对该法令的分析来看，X-Mode“不公平地出售敏感数据、不公平地未能尊重客户的隐私选择、不公平地收集和使用客户的位置信息、未经同意验证地收集和使用客户的位置信息、不公平地根据敏感特性对客户进行分类实现营销目的、欺骗性地未能披露位置数据的使用，并提供了从事欺骗性行为或实践的手段和工具。”
FTC 拒绝就该指令是否适用于情报机构购买数据的情况置评。在定义“位置数据”方面，FTC 指令看似排除了发生在美国境外的数据收集行为以及出于“安全目的”或“联邦机构或其它联邦实体出于国家安全目的”的数据使用行为。
NSA 必须清除数据
NSA 的官员告知怀登称，情报机构不仅购买身在美国的美国公民的数据，还购买美国公民的互联网元数据。
怀登提醒称，前者“可基于互联网的行动轨迹如访问与心理健康资源或与性侵犯或家庭虐待幸存者的资源的网站，或者访问节育或堕胎药物相关的远程医疗服务商，暴露敏感的私密信息”，而后者“可能同样敏感”。
为解决这个问题，怀登希望情报社区能够达成库存协议，然后“及时”清除在未获得许可的情况下非法收集的美国公民数据。怀登表示这一流程可使NSA、FBI等机构“实际”使用“他们的信用卡规避《第四修正案》。”
FTC 表示，X-Mode的行为可能会“给客户造成重大伤害，这种伤害不及客户或竞争带来的利益且无法由客户合理避免”。怀登的发言人凯斯楚 (Keith Chu) 表示，对于X-Mode，“向政府出售互联网记录的数据经纪商似乎做出了近乎一致的行为”。FTC的这一指令表明“美国公民必须被告知且同意自己的数据‘出于国家安全目的’被出售给‘政府承包商’，以允许这一实践的发生”。
国防部辩护可疑的数据经纪商交易
美国国防情报与安全部长罗纳德·莫尔特里 (Ronald Moultrie) 回应怀登的信函时指出，国防部在购买美国公民的位置数据时，“遵守高标准的隐私和公民自由保护规定”。他还表示自己“未在美国法律或司法意见中发现任何要求”强制国防部“获得法庭令以收购、访问或使用”那些“像美国政府那样，同样可由外国对手、美国企业和个人获取的”商业信息。
NSA 的负责人保罗·中曾根 (Paul Nakasone) 上将回应该信函时表示，“NSA 采取措施最少化收集美国的个人信息”并“继续仅获取与任务要求相关的最有用的数据”，包括可用的美国公民商用信息，“通信的一端是美国IP地址，另一端则位于国外”，中曾根指出这一数据“对于保护用于维护军事武器系统的美国国防工业基础的安全至关重要”。
虽然FTC目前端掉多个数据经纪商，但怀登认为未经美国公民知情同意出售数据的可疑实践是需要立法的“行业”问题。情报机构不应成为这一不完善市场的客户，而应当停止资助那些被FTC认为对美国公民实施“侵入性”和“未经查验的”监控的企业。
莫尔特里指出，国家情报总监海恩斯判定哪些信息来源对于协助情报机构是“相关且适当的”。但怀登认为美国公民应当有机会拒绝这些入侵性、秘密性的数据收集行为。他指出，美国情报机构从可疑经纪商处购买数据创建了这样一个社会：客户没有机会拒绝入侵性追踪。
怀登表示，“因为情报机构试图使美国人民陷入黑暗中，与数据购买相关的保密性被放大了。”
代码卫士试用地址：https://codesafe.qianxin.com
开源卫士试用地址：https://oss.qianxin.com
推荐阅读
NSA 发布关于集成SBOMs 提升网络安全的指南
CISA、NSA等联合发布关于SBOM的软件供应链安全保护新指南
NSA离职员工被指向俄罗斯泄露机密数据
NSA和CISA联合发布十大最常见的网络安全配置不当问题清单
NSA发布软件内存安全问题缓解指南
原文链接
https://arstechnica.com/tech-policy/2024/01/nsa-finally-admits-to-spying-on-americans-by-purchasing-sensitive-data/
题图：Pexels License
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bd3d106463ef8d475faa956777e38e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e018175ac81d36df5f6eeb98e6f101/" rel="bookmark">
			Westermo 交换机存在多个漏洞，可攻击工业机构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚焦源代码安全，网罗国内外最新资讯！
编译：代码卫士
美国网络基础设施安全局 (CISA) 通知组织机构称，某些 Westermo Lynx 工业路由器受多个漏洞影响，可被用于篡改设备。
CISA 在安全公告中提到，Lynx 206-F2G 工业以太网交换机受8个漏洞影响，其中2个是高危漏洞，6个是中危漏洞。这些漏洞由西班牙网络安全公司 S21sec 公司的研究员 arón Flecha Menéndez、Iván Alonso Álvarez 和Víctor Bello Cuevas发现。
研究人员提到，多个漏洞是存储型XSS漏洞，可导致非管理员权限的攻击者访问交换机的 web 管理接口或配置软件，在多个地方植入恶意代码。当合法用户访问被植入代码的页面时，该恶意代码就会被执行。
研究人员还发现了代码注入和跨源资源分享问题，这两种问题都可影响设备的正常运行，另外还有一个CSRF漏洞，可用于使目标用户以攻击者的名义执行多种操作。
研究人员提到，“具有远程访问权限的攻击者能够注入恶意代码，修改设备的 web 功能行为，修改由交换机管理的通信或拒绝用户访问。”
研究人员提到还发现超过12台被暴露在互联网的设备易受远程攻击。然而，他们发现，虽然社工技术可能导致攻击者在无需认证的情况下利用其中一些漏洞，但也有一些漏洞不易利用。例如，上述提到的 CSRF 漏洞的利用要求用户认证，且反CSRF标头可拦截攻击尝试。
Westermo 尚未发布相关安全公告，不过该公司向CISA表示该CSRF漏洞已修复，余下漏洞也将会被修复。
代码卫士试用地址：https://codesafe.qianxin.com
开源卫士试用地址：https://oss.qianxin.com
推荐阅读
Juniper 提醒注意防火墙和交换机中的严重RCE漏洞
罗克韦尔自动化称 Stratix 交换机受思科0day影响
思科提醒：多款交换机存在多个RCE漏洞且利用代码已公开
高危无补丁0day影响思科数据中心交换机，可导致加密流量遭篡改
严重漏洞 TLStorm 2.0 影响大量 Aruba 和 Avaya 网络交换机
原文链接
https://www.securityweek.com/westermo-switch-vulnerabilities-can-facilitate-attacks-on-industrial-organizations/
题图：Pexels License
本文由奇安信编译，不代表奇安信观点。转载请注明“转自奇安信代码卫士 https://codesafe.qianxin.com”。
奇安信代码卫士 (codesafe)
国内首个专注于软件开发安全的产品线。
觉得不错，就点个 “在看” 或 "赞” 吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db94c45c8c437892918bb49f063f5e7/" rel="bookmark">
			qt学习：QTSQL&#43;连接sqlite数据库&#43;增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基础
头文件
模块
编程步骤
实战
ui界面
ui界面的成员定义
构造函数初始化准备
在ui界面类析构函数里关闭数据库
添加按钮
删除按钮
改按钮
查询按钮
效果
基础 现在常用的是sqlite是sqlite 3，我用的是sqlite 3
数据库文件是以db结尾的
查看数据库文件软件下载路径
SQLite administration | SQLite Experthttps://www.sqliteexpert.com/download.html
头文件 #include &lt;QTSql&gt;
模块 QT += core gui sql
编程步骤 连接数据库，并且要指定要连接哪一个数据库打开数据库文件，如果文件不存在，则创建创建表增删改查 实战 ui界面 ui界面的成员定义 #include &lt;QSqlDatabase&gt; #include &lt;QSqlError&gt; #include &lt;QSqlQuery&gt; #include &lt;QDebug&gt; private: QSqlDatabase db;//数据库文件 构造函数初始化准备 //1、连接数据库，指定你要操作的数据库的类型 并且设置数据库文件的名字 //第二个参数不写，指的是该数据库文件 是这个工程默认操作的数据库文件 db = QSqlDatabase::addDatabase("QSQLITE","a1"); //第二个参数指的是连接名称，其实就是标识符 //指定操控的数据库文件，没有则创建，如果用db.open打开文件要密码 db.setDatabaseName("company.db"); //2、打开数据库文件 if(db.open()==false) { //db.lastError()错误的原因 qDebug()&lt;&lt;"open error:"&lt;&lt;db.lastError().text(); } //3、创建表 QString sql = QString("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db94c45c8c437892918bb49f063f5e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b46a1690ca63fbdfefad5bd5a99e13/" rel="bookmark">
			【教程】iOS如何抓取HTTP和HTTPS数据包经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📱 在日常的App开发和研发调研中，对各类App进行深入的研究分析时，我们需要借助专业的抓包应用来协助工作。本文将介绍如何使用iOS手机抓包工具来获取HTTP和HTTPS数据包，并推荐一款实用的抓包应用——克魔助手，希望能够帮助读者提升工作效率，高效地完成日常工作。
引言
在移动应用开发和研究过程中，我们经常需要了解App与服务器之间的交互过程，以便更好地优化和改进应用的性能和体验。而抓包工具作为一种重要的网络分析工具，可以帮助开发者捕获并分析应用与服务器之间的HTTP和HTTPS数据包，从而更好地理解应用的网络请求行为。本文将介绍如何在iOS平台上使用抓包工具来获取HTTP和HTTPS数据包，并推荐一款实用的抓包应用——克魔助手，希望能够帮助读者提升工作效率，高效地完成日常工作。
工具/原料
在iOS平台上，我们可以使用克魔助手这款抓包应用来获取HTTP和HTTPS数据包。首先，需要下载并安装克魔助手应用到iOS设备上。
方法/步骤
下载克魔助手应用并安装到iOS设备上。
添加图片注释，不超过 140 字（可选）
打开克魔助手应用，在应用内完成相关设置和准备工作，包括证书安装等操作。
确保iOS设备和抓包工具处于同一局域网环境下。
在克魔助手应用中启动抓包功能，开始捕获HTTP和HTTPS数据包。
添加图片注释，不超过 140 字（可选）
打开目标App，并进行相关操作，触发App与服务器之间的交互过程。
添加图片注释，不超过 140 字（可选）
回到克魔助手应用，停止抓包，并查看捕获到的HTTP和HTTPS数据包。
添加图片注释，不超过 140 字（可选）
代码案例演示
// 示例代码 func captureAndAnalyzeTraffic() { // 开启抓包功能 ProxyServer.shared.startCapture() // 执行App操作 // 停止抓包 let capturedData = ProxyServer.shared.stopCapture() // 分析捕获到的数据包 AnalysisTool.analyze(capturedData) }
其他操作
除了基本的抓包操作外，克魔助手还提供了更多复杂的数据包操作，包括修改、替换、分享等功能。具体操作可以参考应用内的操作手册进行详细了解。
总结
通过本文的介绍，我们学习了在iOS平台上如何使用抓包工具来获取HTTP和HTTPS数据包，推荐了一款实用的抓包应用克魔助手。抓包工具能够帮助移动端开发者更好地理解App与服务器之间的交互过程，同时也可以帮助定位和修复网络请求相关的问题，提升工作效率。
参考资料
克魔助手下载链接
抓包工具介绍
希望本文能帮助读者更好地利用抓包工具进行移动应用开发和分析工作，提升工作效率。📱
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e300e81462c72df70d5a2d52bd384a8/" rel="bookmark">
			2024年软考高项备考攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、了解考试大纲和要求
在开始备考之前，首先要对考试大纲和要求进行全面了解。这有助于明确考试内容和学习方向，制定学习计划。
二、制定学习计划
在制定计划时，可以根据自己的实际情况和学习习惯，选择适合自己的学习方式。以下是一个适用性很强，可供参考的学习计划：
1、基础阶段（1-2周）
①学习《信息系统项目管理师·第4版教程》的基础知识，重点关注十大管理及对应子过程等相关概念；
②结合【思维导图】对五角星、小红旗重点标注的内容进行理解性记忆。
2、强化阶段（3-12周）
①按照上面分享的学习顺序，深入学习项目管理十大领域、高级管理、配置管理、绩效域，以及信息化专业知识。
②完成每周的课后作业练习，复习、总结、巩固题目所对应的知识点，认真听视频讲解，对知识点进行第三次的吸收理解。
③抄写十大管理论文范文，熟悉论文框架结构，学习论文写作技巧，寻找适合的论文背景，尝试撰写论文提纲、自己写论文。
3、提高阶段（13-17周）
①论文专项提升课：帮助考生深度掌握论文写作框架和写作技巧，并提供讲师论文一对一批改指导服务，帮助考生快速掌握论文要点，不断修改提高，写出一篇45+的合格论文！
②简答题专项提升课：针对十大管理提供对应的实例讲解和答题技巧、话术分享。
③计算题专项提升课：针对双代号和时标网络图的画法及应用、工期压缩等常考问题，进行详细讲解，深入练习历年真题和模拟题，提高考生的解题能力。
4、冲刺阶段（18-20周）
①复习【思维导图】中标注的重要知识点，回顾教材，查漏补缺，熟悉一些细节性的内容；
②加强论文写作练习，背诵论文背景，对十大管理子过程相关进行梳理、串联，如此在考场上才能灵活应对，随机应变；
③参加模拟测试，熟悉机考系统平台的操作、画图系统中的图表用法以及常考网络图的画法，提前调整考试状态。
软考交流讨论+资料分享​
三、灵活调整学习方式
学习方式因人而异，要结合自己的实际情况选择最适合自己的方法。除了传统的看书、听课等方式外，还可以听在线课程。同时，结合思维导图、笔记等方式进行知识点梳理和总结，有助于加深理解和记忆。
四、合理安排时间
备考过程中，合理安排时间至关重要。可以根据自己的工作和学习情况，将备考时间分散到平时的闲暇时间中。例如，可以利用周末或每天晚上抽出1-2小时进行学习。这样可以减轻备考压力，提高学习效率。
五、保持积极心态和信心
备考过程中可能会遇到各种困难和挑战，但保持积极的心态和信心是成功的关键。要相信自己能够顺利通过考试，同时也要注意调节学习和生活压力，保持身心健康。
六、注重实践和应用
软考高项考试注重实践和应用能力的考察。在学习过程中，要注重将理论知识与实际工作相结合，提高自己的项目管理能力。可以尝试在实际工作中应用所学知识，或者参加一些项目管理实践项目，积累实践经验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553c431e1914ae8fb7a2a5e718d94091/" rel="bookmark">
			Web 开发 9：Django 框架基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本篇文章中，我们将深入探讨 Django 框架的基础知识。Django 是一个功能强大且流行的 Python Web 框架，它提供了一套完整的工具和功能，用于开发高效、可扩展的 Web 应用程序。
什么是 Django？ Django 是一个基于 Python 的免费开源 Web 框架，由一群富有经验的开发者创建和维护。它遵循了 MVC（模型-视图-控制器）的软件设计模式，旨在帮助开发人员快速构建复杂的 Web 应用程序。
Django 的特性 Django 框架具有许多强大的特性，使其成为 Web 开发的首选框架之一：
强大的 ORM（对象关系映射）：Django 提供了一个简单而强大的 ORM，使开发人员可以使用 Python 代码来操作数据库，而无需直接编写 SQL 查询语句。
自动化的管理界面：Django 自动生成管理界面，使开发人员可以轻松管理数据库记录和模型。
灵活的 URL 配置：Django 的 URL 配置非常灵活，可以根据需要定义各种 URL 模式，并将它们映射到相应的视图函数。
模板引擎：Django 提供了内置的模板引擎，使开发人员可以将业务逻辑和显示逻辑分离，实现更好的代码组织和可维护性。
强大的表单处理：Django 的表单处理功能简单易用，可以轻松处理表单验证、数据存储等任务。
安装 Django 在开始使用 Django 之前，我们需要先安装它。可以使用以下命令来安装 Django：
pip install django 确保您已经安装了适当版本的 Python，并且已经配置了正确的环境变量。
创建 Django 项目 在安装 Django 后，我们可以通过以下命令来创建一个新的 Django 项目：
django-admin startproject myproject 这将创建一个名为 “myproject” 的新目录，其中包含 Django 项目的基本结构和配置文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553c431e1914ae8fb7a2a5e718d94091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25175ad3c1eba661907d5a88dd027c9c/" rel="bookmark">
			Ajax入门与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
◆ AJAX 概念和 axios 使用
什么是 AJAX？
怎么发送 AJAX 请求？ 如何使用axios axios 函数的基本结构
axios 函数的使用场景
1 没有参数的情况
2 使用params参数传参的情况
3 使用data参数来处理请求体的数据
4 上传图片等二进制的情况
form-serialize 插件
◆ AJAX 概念和 axios 使用 什么是 AJAX？ 概念：AJAX 是浏览器与服务器进行数据通信的技术 怎么发送 AJAX 请求？ 1. 使用 axios [æk‘sioʊs] 库
基于 XMLHttpRequest 封装、代码简单 Vue、React 项目中都会用到 axios 2. 使用 XMLHttpRequest 对象
如何使用axios 语法：
1. 引入 axios.js
在线引入： https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js --axios在线库本地引入：下载好axios文件，使用相对路径引入 2. 使用 axios 函数
axios 函数的基本结构 url 这个参数是必须的，里面填的是请求的url地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25175ad3c1eba661907d5a88dd027c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a15cabba34f81a9d263b99f4941fa7/" rel="bookmark">
			书生浦语大模型 笔记&amp;作业汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一节课笔记：https://blog.csdn.net/2301_80618119/article/details/135376409?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22135376409%22%2C%22source%22%3A%222301_80618119%22%7D
第二节课笔记：
https://blog.csdn.net/2301_80618119/article/details/135431085?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22135431085%22%2C%22source%22%3A%222301_80618119%22%7D
第二节课作业：
https://github.com/InternLM/tutorial/discussions/105#discussioncomment-8035135
第三节课笔记：
https://blog.csdn.net/2301_80618119/article/details/135466030?spm=1001.2014.3001.5501
第三节课作业：
https://github.com/InternLM/tutorial/discussions/246#discussioncomment-8091741
第四节课笔记：
https://blog.csdn.net/2301_80618119/article/details/135527634?spm=1001.2014.3001.5501
第四节课作业：
https://github.com/InternLM/tutorial/discussions/251#discussioncomment-8122487
第五节课笔记：
https://blog.csdn.net/2301_80618119/article/details/135563114?spm=1001.2014.3001.5501
第五节课作业：
https://github.com/InternLM/tutorial/discussions/331#discussioncomment-8154781
第六节课笔记：
https://blog.csdn.net/2301_80618119/article/details/135721550?spm=1001.2014.3001.5501
第六节课作业：
https://github.com/InternLM/tutorial/discussions/444#discussioncomment-8234275
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3447cf2b8fcf97e7a7c2dc3b38b84e/" rel="bookmark">
			vue3之echarts3D环柱饼图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3之echarts3D环柱饼图 效果：
版本
"echarts": "^5.4.1", "echarts-gl": "^2.0.9"
核心代码：
&lt;template&gt; &lt;div class="content"&gt; &lt;div ref="eCharts" class="chart"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { onMounted, ref } from "vue"; import * as echarts from "echarts"; import "echarts-gl"; const eCharts = ref(null); let myChart = null; let boxHeight; let optionData = ref([ { name: "林地", value: 5, itemStyle: { color: "#22c4ff", }, }, { name: "草地", value: 13, itemStyle: { color: "#aaff00", }, }, { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be3447cf2b8fcf97e7a7c2dc3b38b84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84db3638a4986bc84ff39a63da2f21b/" rel="bookmark">
			常见的网络安全威胁和防护方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数字化转型和新兴技术在各行业广泛应用，网络安全威胁对现代企业的业务运营和生产活动也产生了日益深远的影响。常见的网络安全威胁通常有以下几种：
1. 钓鱼攻击 攻击者伪装成合法的实体（如银行、电子邮件提供商、社交媒体平台等），通过欺骗用户来获取敏感信息，如账号密码、信用卡号码等。攻击方式包括电子邮件钓鱼、网站钓鱼和电话钓鱼等。
预防方法：
止电子邮件钓鱼的最佳方法是了解这种攻击手段的关键特征，进而及时识别并避开这些钓鱼陷阱。
电子邮件网络钓鱼最明显的伪装纰漏是邮件内容信息在拼写、标点和语法上存在错误，这类邮件中通常会有很多拼写错误和域名不正确的邮箱地址。如果企业内部发现收到的邮件内容存在这些可疑之处，就要引起注意，叮嘱员工避免点击任何链接，对于以商品促销或折扣为主题的邮件内容更要注意。
这类钓鱼邮件的另一个特征是附加链接很短。因为一般短链接会被攻击者用于躲避安全电子邮件网关检测，因此这也可能是证明链接不安全的信号。
2. 恶意软件 恶意软件包括病毒、蠕虫、木马和间谍软件等，可以在用户的设备上执行恶意操作。病毒会感染计算机文件，蠕虫可以自动传播到其他设备，木马可以暗中控制受感染设备，而间谍软件会收集用户的个人信息。
1、病毒：病毒是一种恶意软件，能够自我复制并传播到其他计算机。一旦感染，病毒可以破坏数据、操作系统或整个系统。
2、蠕虫：蠕虫与病毒类似，但不需要被感染的文件或程序来传播。蠕虫会利用系统漏洞，自动复制并传播到其他网络设备。
3、木马：木马是一种看似正常的软件，但它在背后开启了一个隐藏的后门，使攻击者能够远程控制受感染的计算机并窃取敏感信息。
4、间谍软件：间谍软件（也称为间谍或间谍程序）会在用户的计算机上暗中收集敏感信息，如个人身份信息、浏览习惯、键盘记录等，并将其发送给攻击者
预防方法：
1. 更新您的设备，操作系统，插件程序，浏览器至最新版本
2. 设置账户访问权限
3. 设置强而独特的密码
4. 加强网络安全意识培训
5. 安装防病毒软件和防恶意软件工具
6. 使用数字证书保护您的网站和电子邮件
3. DDoS 攻击 分布式拒绝服务（DDoS）攻击旨在通过发送大量的请求使目标服务器超负荷，导致服务不可用。攻击者会利用大量的僵尸计算机或其他受感染设备发起攻击，使目标服务器无法处理正常用户的请求。
预防方法：
1.选择 ddos 防护的机房，如德迅云安全，阿里云，腾讯云等
2.使用德迅云安全SCDN，抗D盾，隐藏服务器真实 IP 地址
3.利用负载均衡技术
4.做好硬件保护措施
5.系统安全配置与及时更新，了解攻击病毒类型
4. 数据泄露 数据泄露指组织或个人的敏感数据遭到未经授权的访问、窃取或泄露的情况。这可能导致个人隐私泄露、金融欺诈、身份盗窃等问题。数据泄露可以发生在个人设备、组织内部网络或第三方服务提供商的系统中。
预防方法：
外部
做好自身供应链（如物流、仓储、支付系统）和第三方供应商（如海外购、第三方商店）的数据访问控制，尤其需要完善审计措施。
做好互联网应用服务的安全配置并定期巡检，避免违规共享内容被搜索引擎收录。针对内部员工进行全面的网络安全意识培训，规范数据存储和共享，杜绝内部机密数据通过互联网存储和传输。建立邮件和社交网络使用规范，建立红线机制并设定奖惩措施，防微杜渐。
互联网应用系统正式上线前应进行全面的渗透测试，尽可能避免存在未授权访问、管理弱密码、SQL注入等漏洞，导致数据泄露。
内部
业务系统运营人员和运维研发人员等的访问权限应做好访问控制，建立相应角色并根据需求最小化原则分配访问权限，指派专员对业务系统的访问进行审计。
建立终端准入机制，统一部署杀毒和终端管控软件。
通过安全意识培训，培养员工良好的终端使用习惯，避免数据通过终端被窃取。
内部应用系统正式交付前应做好全面的软件测试，避免存在隐藏的数据调用接口。并在正式上线前做好渗透测试，避免攻击者通过数据遍历、未授权访问和SQL注入等漏洞批量获取数据。
5. 无线网络攻击 无线网络攻击针对通过Wi-Fi连接的设备。攻击者可以进行Wi-Fi劫持，即欺骗用户连接到恶意的Wi-Fi网络；中间人攻击是指攻击者窃听或篡改通过无线网络传输的数据。
预防方法：
1. 如果接入点和客户端设备能够支持WPA3，请尽快使用这种最新的无线网络安全标准。WPA2仍然也是不错的选择，但是WPA3可以提供的防护能力将更加可靠和完善。
2. 为每个无线网络接入点设置一个独特的、难以猜到的强密码。
3. 确保所有网络组件版本及时更新并合理配置，最大限度地减少可利用的漏洞。
4. 尽量减少或禁止接入点的远程访问，始终将默认接入点密码改为独特的、难以破解的密码。这可以阻止随意性的攻击者通过互联网连接到接入点，并轻松获得控制权。
5.除了这些基础无线安全措施外，有条件的企业组织还应该为其无线网络实施以下安全控制措施将无线网络与其他网络系统区分开。这常常可以使用防火墙、虚拟局域网或其他网络边界执行技术来实现，同时执行限制流量进出的安全策略。
6. 零日漏洞 零日漏洞是已存在但尚未被公开披露的软件漏洞。攻击者可以利用这些漏洞来进行攻击，因为尚未有有效的防御措施可以抵御。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b84db3638a4986bc84ff39a63da2f21b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ecf2db05772fc2b7e803ac0a94b02bf/" rel="bookmark">
			【Uni-App】Vue3如何使用pinia状态管理库与持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装插件 pinia-plugin-unistorage
引入 // main.js import { createSSRApp } from "vue"; import * as Pinia from "pinia"; import { createUnistorage } from "pinia-plugin-unistorage"; export function createApp() { const app = createSSRApp(App); const store = Pinia.createPinia(); // 关键代码 👇 store.use(createUnistorage()); app.use(store); return { app, Pinia, // 此处必须将 Pinia 返回 }; } 初始化 根目录创建store文件夹，在该文件夹内添加pinia2.ts文件，内容如下：
import { defineStore } from "pinia"; export const useStore = defineStore("pinia2", { state() { return { someState: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ecf2db05772fc2b7e803ac0a94b02bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b854c921fd4e17d2f7b25d8ba51d05/" rel="bookmark">
			Flutter提示Don‘t use ‘BuildContext‘s across async gaps.的解决办法---flutter里state的mounted属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天编写代码，遇到了Don't use 'BuildContext's across async gaps.的蓝色提示，虽然不是警告也不是报错，但是强迫症还是受不了想解决这个bug
原因 我在async函数进行了显示toast的wiget，flutter不希望我们这样做，因为这里我们函数是异步的，执行显示widget时候的buildcontext可能变化了，也就是我们现在界面widget树可能变化了
解决 在你的widget构建前增加
if (!mounted) return; 在Flutter的 State 对象中，mounted 是一个布尔值属性，用于指示与这个 State 对象相关联的 Widget 是否仍然挂载到Widget树上。当一个Widget被从Widget树中移除时，它的 State 对象的 mounted 属性将会变为 false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cad3a1bc1cb2fb3283b4bf5d64eec47/" rel="bookmark">
			按照模板生成文件，Word 或者 Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求流程：
模板部分如图：
Web端技术选用Jfinal
功能实现：
下面代码是调用 --“外部接口”--传参，将前端选中的信息传给后端， 另外将后端返回的文件流下载成文件
package ibasic.web.com.controller; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.net.URLDecoder; import java.text.SimpleDateFormat; import java.util.Date; import javax.servlet.annotation.MultipartConfig; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.client.HttpClient; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.message.BasicHeader; import org.apache.http.protocol.HTTP; import com.jfinal.kit.PropKit; import net.sf.json.JSONObject; //excel模板 @MultipartConfig @WebServlet("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cad3a1bc1cb2fb3283b4bf5d64eec47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2280bcc4bba6b81f081ec5880df9fd/" rel="bookmark">
			unaipp微信小程序-跳转switchTab bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bug wx.switchTab: url 不支持 queryString 解决 uni.setStorageSync("selectedLabel", selectedLabel) uni.getStorageSync("selectedLabel") 跳转到tabar导航栏，switchTab不能携带参数，我使用的是setStorageSync 储存，也可以使用vuex
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eaf792674bed49e52bbfe836f95844c/" rel="bookmark">
			JWT（JSON Web Token）详解以及在go-zero中配置的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 对用户进行身份认证和信息交换 RFC 7519
传统方式 通过session保存对话信息，服务端返回一个session id，用户保存这个id在cookie内，然后每次请求都传给服务端
局限性 对于服务器集群难以向每个服务器共享同一session
jwt的方式是不在服务端保存session数据，数据只保存在客户端，请求时发给服务端
JWT原理 jwt结构 jwt是个很长的字符串，包含如下部分，每个部分之间用'.'来分隔
Header（头部）：通常包含两部分信息，token的类型（即JWT）和所使用的签名算法（如HMAC、SHA256或RSA）Payload（负载）：包含所要传递的数据。这些数据被称为Claims（声明），分为三种类型：注册声明（例如，iss - 发行者、exp - 过期时间戳）、公共声明（可以自定义，但不建议包含敏感信息）、私有声明（由双方约定的信息）Signature（签名）：对前两部分进行签名，以验证消息的发送者并确保消息在传递过程中未被篡改 签名需要指定一个服务器才知道的密钥，然后根据Header指定的签名算法，算出签名 Header.Payload.Signature 额外说明 头部和负载部分本身不加密，以Base64编码传输，所以任何人都可以解码，签名部分才加密，
服务端验证签名，通过则信任jwt的信息未被篡改
工作流程 用户使用其凭证（如用户名和密码）登录系统服务端验证凭证的正确性，并创建一个包含用户信息的JWTJWT中的负载部分包含所需的数据（如用户ID），然后用服务器的密钥进行签名服务端将此JWT返回给用户用户随后的每个请求都将包含这个JWT，通常是在HTTP请求的Authorization头部中携带服务端接收请求后，会验证JWT的签名并解析负载中的数据，以确定用户的身份和权限 过期时间戳的详细解释 过期时间戳是jwt标准自带标准字段exp
当Token被创建时，exp字段被设定为一个特定的未来时间点。这通常是Token创建时间加上一个预定的时间间隔当服务端接收到一个请求中的JWT时，它会检查当前时间是否已经超过了Token中的exp时间戳如果当前时间超过了exp时间，那么Token就被视为无效，服务端通常会拒绝该请求并要求用户重新登录或获取新的Token 时间格式的Unix纪元以来的秒数，跟大部分标准规定的一样的
GoZero中配置 详细见我的这篇文章
GoZero微服务个人探究之路（九）api文件编写总结_go zero api 文件 如何定义参数非必填-CSDN博客
在api文件的@server指定jwt:Auth即可开启jwt，但是框架只做了服务端逻辑，对于 jwt token 的生成及 refresh token 仍需要开发者自行实现
在GoZero框架中配置并启用JWT（JSON Web Token）后，框架会自动处理每个请求中的JWT验证。GoZero的JWT中间件会检查和验证请求中的Token，然后根据验证结果决定是否允许请求通过
相关代码 go中实现创建jwt token 可以使用github.com/dgrijalva/jwt-go库
// 自定义的一些Claims数据结构 type MyCustomClaims struct { UserID string `json:"user_id"` jwt.StandardClaims } func main() { // 密钥、、 var mySigningKey = []byte("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eaf792674bed49e52bbfe836f95844c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf30cf68fc23c35723ba90c53eba19a5/" rel="bookmark">
			R-YOLO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract 提出了一个框架，名为R-YOLO，不需要在恶劣天气下进行注释。考虑到正常天气图像和不利天气图像之间的分布差距，我们的框架由图像翻译网络（QTNet）和特征校准网络（FCNet）组成，用于逐步使正常天气域适应不利天气域。具体来说，我们使用简单而有效的QTNet来生成图像，这些图像继承了正常天气域中的注释，并对两个域之间的间隙进行插值。然后，在FCNet中，我们提出了两种基于对抗性学习的特征校准模块，以局部到全局的方式有效地对其两个领域中的特征表示。
Introduction 基于UDA的方法将知识从源域转移到目标域，以弥补域差距，提高泛化能力。用于对象检测器的最先进的（SOTA）UDA方法主要依赖于对抗性学习来在全局级别和实例级别对齐源图像和目标图像的表示。然而，在一级物体探测器上使用上述方法的问题有两个：
全局级别的特征对齐容易发生负迁移，使得UDA模型甚至表现得比模型在源域上更差其次，主要针对受益于区域建议网络的两级检测器设计了实例级特征自适应方法。
提出了一个R-YOLO网络，包含QTNet（图像翻译网络）和FCNet（特征对齐网络）来逐步减少两个域之间的差异。我们声称，作为预处理步骤，不需要在源域和目标域之间进行严格的翻译，我们只能将图像生成为两个域之间的插值，以指导对抗性学习。因此，我们设计了一个简单而有效的网络来学习残差图像，以在源域和目标域之间进行相互图像翻译。与现有的图像翻译/恢复方法相比，我们的QTNet有三个主要优势：它生成具有相同场景但位于不同域的跨域图像，有利于以下基于对抗性学习的特征对齐它不需要对朦胧和雨天图像的先验知识，因此可以统一用于不利图像的翻译任务；易于训练以避免基于GAN的方法的训练问题。
在FCNet中提出了两种对抗性学习模块：逐像素特征对齐模块（PFC）全局特征对其模块（GFC）
PFC模块以像素方式对齐低级别特征，以增强前景对象和背景的跨域，这对于降低后续全局特征对齐中的负迁移风险非常重要。
GFC模块使用多尺度特征对抗性训练来全局消除不同域之间特征图上的多样性，并增强对象类别对齐。 主要贡献如下：
我们提出了一个统一的一阶段目标检测器训练框架，即R-YOLO，在恶劣天气下，不使用不利领域注释。R-YOLO包含QTNet和FCNet适用于所有YOLO系列检测器，且有着相同的推理速度。设计了一种简单且有效的网络来相互转化正常图像和不利图像以生成两个域之间的插值。我们还建议使用两种对抗性学习模块来逐步减少特征水平上的领域差异。 Method 我们有两个主要目标来提高YOLO在恶劣环境下的性能：
在不引入基于GAN的方法的训练问题的情况下，设计一个简单而有效的图像翻译网络来进行数据扩充提出一种为一级检测器量身定制的特征对准网络，避免触发负转移 QTNet 我们的QTNet的目的是设计一个适用于朦胧和雨天图像的统一网络，因此在图像翻译过程中无法探索任何特定于天气的信息或先验信息。受残差图像最近在图像恢复和增强任务中的成功启发，如图像去噪[45]、[46]、[47]和图像阴影去除[48]、[49]、[50]，我们设计了带有残差模块的QTNet，以直接缩小从输入到输出的映射范围，使学习过程更容易。我们使用简单的自动编码器作为主干，并添加跳过连接路径，将多层编码器特征融合到解码器特征中。为了改进网络训练过程，我们在自动编码器的输入和输出之间添加了跳跃连接，使其能够学习负残差映射。
具体来说，使用源域和目标域图像XS、XT，我们可以获得合成目标图像，XST。然后，QTNet可以训练成对的XS、XST图像，如果XS被用作输入图像，则XST被用作GT图像，反之亦然。
我们使用多尺度重建损失来监督图像翻译后的语义保存网络训练，可以定义如下：
xi是输入图像，QTNet（xi）是输出图像，xiG是xi对应的GT图像。d是损失强制执行的总层数，λi是对应每层的权重参数。注意QTNet训练的都是合成图像，一旦经过训练，就可以被用来翻译图像。我们还使用感知损失来生成逼真图像。具体来说，给定QTNet的输出图像及其相应的GT图像，我们使用预训练的网络，例如在ImageNet上预训练的VGG，来提取上述两幅图像的特征。然后，我们使用这两个特征之间的MSE损失来评估生成图像的真实性，从而感知损失Lp可以指导高真实性图像生成的QTNet训练，可以定义如下：
训练QTNet的损失如下：
生成的图像的重要性有三个方面，这有利于以下特征自适应步骤：
我们可以在目标域中获得大量的注释样本生成的图像可以看作是源域和目标域之间的插值样本，它驱动源域决策边界适应目标域对于大量的跨域图像（具有相同场景但在不同域中的图像），我们可以在不考虑语义不一致问题的情况下对齐两个域中的特征，从而避免负迁移。 FCNet（特征对齐网络） 得益于生成的跨域图像，我们在FCNet中进行了基于对抗性学习的特征对齐，其关键是学习鉴别器无法识别的常见特征分布。为此，我们提出了两种特征校准模块，PFC模块和GFC模块，以消除两个领域在特征水平上的差异。FCNet建立在YOLO主干上，而不改变YOLO网络结构。我们唯一做的事就是添加两种鉴别器和对应损失函数来限制特征学习。
PFC
我们发现，与正常天气相比，恶劣天气下的物体细节和背景之间存在巨大差异。具体来说，悬浮的微小颗粒或快速下落的雨滴首先影响前景对象和背景的颜色、边缘和纹理等低级特征，然后导致对象的草图和语义等高级特征的差异。因此，有必要且相对容易地将每个像素的低水平特征校准为对不利天气具有鲁棒性的共同分布。
Dp是像素特征鉴别器，在本文中是简单的Conv+sigmoid。Gp(xi)j表示从Gp（xi）获得的特征图中的第j个位置的特征向量，H和W是Gp(xi)的高度和宽度。对于QTNet生成的跨域图像，可以严格保证源图像和目标图像之间的语义一致性。然后，在低级别特征图上实施PFC损失可以以像素方式对齐低级别特征，以有效地增强关于前景对象和背景细节的跨域特征。然后，在低级别特征图上实施PFC损失可以以像素方式对齐低级别特征，以有效地增强关于前景对象和背景细节的跨域特征。
GFC Module
一旦像素级低级别特征被校准，就更容易通过多尺度GFC模块学习图像级对齐的特征表示，例如图像风格、全局亮度和暗度。根据YOLO结构（以YOLOv3为例），其中多尺度特征图被提取并发送到用于收集不同尺度特征图的颈部结构，我们在多尺度特征上强制执行GFC模块。多尺度GFC损失定义如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cccea6be4672803a9929d1b749169f97/" rel="bookmark">
			不重视项目复盘，就不是合格的项目经理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来讨论一下项目复盘或者叫工作复盘。复盘一词源自围棋术语，指的是在每次对局结束后，双方棋手会把刚才的对局再次重演一遍，以加深对这场对弈的印象，并找出攻守的不足之处。这是提高围棋水平的有效方法，因此围棋高手都有复盘的习惯。
后来，复盘的概念被引入到企业管理中，个人或者管理者通过总结过去的工作经验，从中学习并提高自己的能力或团队的工作水平。
柳传志（联想总裁），非常重视复盘，在做出重要决策后，他会关注取得的成果，无论是否完成，都会定期进行复盘。这是联想公司取得成功的必要条件之一。万达公司也通过复盘发现并改进不足之处，开业三个月内一定会进行复盘，以便内部经验的传承。复盘为万达创造了巨大的商业价值。柳传志和王健林都非常注重复盘。我也参加了公司的一些复盘会议，之前没有意识到存在问题，直到我读了一些相关书籍才意识到，我可能参加的是一些形式上的复盘会议，更像是吐槽会、邀功会或简单的回顾会。
最终很少有制定规章制度或标准流程，也很少分享有借鉴意义的复盘经验。从这个角度来看，我们公司可能并不十分重视复盘，或者复盘还没有成为主流文化。如果我们希望复盘成为公司的主流，从小的方面来说，需要获得领导的支持；从大的方面来说，就需要企业文化对复盘的支持。
我总结了我所阅读的书籍，一方面是为了与大家一起学习，另一方面是为了加深我的理解。总结的目的主要包括以下几点：
1、复盘目的：
以学习为目的，吸取经验教训，从中找到成功之路；
通过复盘发现问题，规范相关流程，实施标准化流程；
深入分析问题，寻找解决方案，为未来类似问题提供基础；
改进未来的绩效表现。
2、复盘与总结的联系与区别：
复盘和总结都以学习为目的，但有一些不同之处：
复盘有一套固定的流程，而总结则不需要；
复盘是连续的、立体化的，包括对已知事物的总结和对未知事物的探索；而总结是静态的、平面化的，主要对已知事物进行归纳；
复盘是重现过去发生的事情，与目标进行比较，找出根本原因，吸取经验教训，从而完善标准化流程或规避未来的风险，是一个持续的过程；而总结主要是从过去的经历中学到什么，这是复盘与总结的本质区别。
三、复盘程序
复盘准备
在复盘会议前，需要确定以下内容：
复盘的主题，即复盘哪个事项。
参与会议的人员。
复盘会议的时间和地点。
确定复盘引导人，最好是与复盘事项没有直接利益关系的人，但引导人必须对复盘事项的前因后果有一定了解。
准备会议所需的资料。
复盘顺序
（1）回顾预期目标（绩效）：
在这一步，引导人可以向大家提出以下问题：
当初需要达到什么目标？目标完成的标准是什么？
对这次目标完成是否满意？
完成这个目标的标准流程是什么（顺序）？在执行过程中是否预计遇到困难？
引导人可以向多人提问，直到大部分人意见达成一致（记录下不同意见），然后可以进行下一步。
（2）回顾实际情况：
在大家对预期目标（绩效）标准的理解一致的情况下，可以分阶段、分专业分类探讨工作执行过程中实际发生了什么事情（对事件的关键节点有影响的事情）。
实际发生了什么事情？
这些事情是怎么发生的？
与预期的标准顺序是否一致？
是否遇到了预期的困难？如何解决了这些预期的困难？
是否出现了新的困难？如何解决的？
（3）分析目标成败原因：
首先问大家是否按时按质完成了这次目标。
如果是，分析成功的关键原因是什么？
如果不是，指出差异之处，并分析为什么会发生差异？是哪些因素造成的差异？在目标制定过程中，有哪些不利因素可能对我们没有考虑到的造成了影响？需要找出差异的根本原因。
（4）得到经验教训：
在这一步，引导人可以提问：
从这次目标的完成中我们学到了哪些东西？
哪些东西可以引入公司知识库供他人学习，并形成标准化流程？
下次遇到类似问题该如何解决或规避风险？
根据这次目标的完成情况，我们的规章制度或流程该如何改进？
如果再次进行类似目标，我们是否能完成得更好？
（5）整理并分享复盘结果。
（6）推进复盘会议结果的落实。
引导人的观察和引导能力很关键：复盘会议需要引导人具备较高的观察水平和引导能力，以确保每个人都能积极发言。引导人应该能够注意到每个人的观点和反馈，并能够巧妙引导讨论，让每个人都有机会表达自己的意见。
避免开成对领导的歌功颂德会：复盘会议不应该成为领导受赞扬的场所，而应该以实事求是的态度对待问题。引导人需要引导讨论聚焦在事实和问题本身，而不是为了取悦领导而迎合或夸大成绩。
避免开成批斗会：同样，复盘会议也不能成为批评和指责的场合。引导人需要注意控制会议的气氛，避免个人攻击或责备，促进积极、建设性的讨论。每个人都应该能够自由地表达自己的意见，而不用担心被指责或受到惩罚。
备考资料分享如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b78eccb8b045a09696e5aeac909de94/" rel="bookmark">
			Selenium——利用input标签上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Selenium利用input标签上传文件 完整流程 打开文件上传页面选择要上传的文件点击上传按钮确认文件上传成功介绍怎么方便的获取对应元素的Xpath或者Css 简单介绍 在使用Selenium进行浏览器自动化测试时，文件上传是一个常见的需求。而 标签就是实现文件上传功能的一个主要方式。以下是如何使用Selenium利用 标签上传文件的步骤：
注意事项 selenium版本不同,定位元素的方法也不相同
Selenium定位元素是浏览器自动化测试中非常重要的一步。以下是最新的Selenium定位元素的方法总结：
通过ID定位元素 from selenium.webdriver.common.by import By driver.find_element(By.ID, 'element_id') 通过name定位元素 driver.find_element(By.NAME, 'element_name') 通过Class Name定位元素 driver.find_element(By.CLASS_NAME, 'element_class') 通过Link Text定位元素 driver.find_element(By.LINK_TEXT, 'link_text') 通过Partial Link Text定位元素 driver.find_element(By.PARTIAL_LINK_TEXT, 'partial_link_text') 通过Tag Name定位元素 driver.find_element(By.TAG_NAME, 'tag_name') 通过Xpath定位元素 driver.find_element(By.XPATH, 'xpath_expression') 具体使用哪种定位方法,根据实际情况选择
具体步骤 1.打开文件上传页面 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver.Chrome() driver.get("https://example.com/upload") # 等待文件上传框出现 element = WebDriverWait(driver, 10).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b78eccb8b045a09696e5aeac909de94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4843d94c5afb91801ab67fb2c34008a5/" rel="bookmark">
			软件项目交付应该注意什么？全过程讲解！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多年前，信息技术行业流行以自嘲的方式称呼自己为"挨踢"，也可以用"整电脑"或者"做软件"等说法来表达。后来，"互联网"火了起来，渐渐地变成了"搞互联网"的行业。尽管近年来国内互联网发展有些停滞，中概互联公司也被戏称为中丐互联，但目前还没有新的替代词汇出现。相比之下，英文中对于信息技术的称呼则更为直接，比如"IT"代表信息技术，"CS"代表计算机科学，"SE"代表软件工程师。我们常说的"系统"、"应用"、"APP"、"程序"统称为"软件"，与硬件相对应。对于软件的分类有很多方法，可以从2B或2C、工具或业务，通用或垂直等角度进行划分。
在我入行的早期，我从事电信软件集成工作。当时，除了工具软件，业务软件主要分布在电信、金融、政府（税务）和企业资源计划(ERP)四个领域。当年，神州数码采取了多管齐下的策略，在软件服务方向上大举进攻，涵盖了各个领域。在国内，企业级软件的产品化道路充满坎坷，据称没有成功的案例。然而，凭借灵活的定制化服务和廉价的劳动力，一些企业在各行业中艰难求存，并与国外厂商展开差异化竞争，争取自己的市场份额。那些幸存下来的公司都有它们的真本事，可能是优秀的客户关系、高质量的工程或者成本控制，在其中一个或多个方面表现出色。比如，我的前任公司亚信，专注于电信行业已有20多年的时间，拥有上万名工程师，大型项目常常需要几百人参与，项目管理能力非常强大——传统软件项目管理涵盖了多个方面，不仅仅局限于研发流程。
随着云计算时代的到来，2B软件已经进化到了SAAS阶段，希望通过产品化和平台化快速扩展企业服务，成为国内的Salesforce。然而，国内的市场环境比较特殊，企业客户往往要求定制化的服务，他们会按照自己的需求来定制，并且要求支持私有化部署，在接口对接其他系统时也要能够适配原有系统。一旦大版本上线后，可能还会有更多的定制需求需要持续迭代升级，衍生出二期、三期乃至N期的版本。面对标准化和定制化的抉择，一些大型云计算企业为了深入企业服务体系上游，纷纷加入这一领域，并动用自己的宝贵资源或者通过外包和合作伙伴来增加人力。如今，大型定制软件实施交付项目仍然广泛存在，展示了大团队合作的独特光辉，并且随着"下半场"、"产业互联网"和"数字化转型"的深入，它们将在新时代继续创造辉煌。
我收集整理了大型定制软件项目实施交付各阶段技术团队的注意事项，共计6个阶段、28项主要任务、48种交付物、53条注意事项，内容涵盖了实践教训，也吸取了一些同行的宝贵经验。和CMMI（软件能力成熟度模型）类似，这些内容不一定适用于所有情况，可以根据实际情况进行取舍。
行业的兴衰、企业的成败起落，那些能够屹立不倒的企业，必定有着独特的优势，散发着独特的光芒，令人难以忽视。这类项目具有一些特点，需要进行定制化或实施，私有部署。它们涉及到线下商务流程，需要投入较多的技术资源，因为其临时性和唯一性，所以对项目管理体系有着严格的要求，以确保项目的交付。
在这样的项目中，乙方提供实施服务，其中可能包含第三方集成选型，一般由乙方自行选择，也可能由甲方通过招标或选型进行决定。这类项目可能涉及其他供应商，但都面向甲方，因此项目的协作关系较为复杂。项目在签订合同后会有明确的预算、项目周期、里程碑和回款条款，通常在合同签订后收取首付款，在上线验收后收取尾款。
甲乙双方会成立项目组进行对接，项目组中有明确的职能角色，并指定统一的对接人和沟通、决策机制。责任要求也十分清晰，交付标准也要求严格，并设立了违约机制。整个项目过程按照PMBOK项目管理过程控制方法论进行划分，以确保项目按照阶段进行管理控制。
售前阶段
在销售阶段，客户经理的主要任务是领导销售团队，参与招投标或与甲方进行谈判，签订合同，并在必要的情况下提前在内部提出项目立项建议，最终确定项目经理。售前阶段的主要任务是进行技术交流，确定可行性技术方案，并提供实施方案以及初步估计项目成本。在这一阶段，需要准备合同并进行签署，或者提前立项。同时，需要任命项目经理，以确保项目的顺利进行。
在交付阶段，需要准备工作量清单（报价清单）以及中标合同及附件等交付物。同时，需要提前提交立项申请表以及项目经理任命书等相关文件。在估算项目工作量时，需要尽量控制误差，并对难以评估的内容进行声明。此外，需要避免过度承诺，如遇到困难，应客观地表达出来。
启动阶段
阶段目标及项目准备工作
为了顺利开展项目，我们需要按照以下步骤进行内部立项和项目准备工作:
主要负责人的转换：确定项目经理，并将其作为主要负责人来管理项目。
内部立项：进行项目内部立项，确保项目的正式启动。
细化预算和资源：进一步细化项目的预算和资源需求。
明确项目工作范围和里程碑：明确项目的具体工作范围和各个阶段的里程碑。
确定项目干系人：明确项目涉及的各方利益相关者，并与他们进行充分的沟通和协调。
组建项目团队：根据项目需求组建合适的团队，明确项目组成员和组织架构，并制定相关规章制度。
召开项目启动会：召集项目团队成员和其他相关人员，进行项目启动会议，明确项目目标和任务，以及各方的角色和责任。
收取首款：根据合同规定，确保及时收取项目的首款。
交付物：制作项目交接备忘录、项目章程、项目组织结构、规章制度和通讯录等交付物。
注意事项：立项后需要重点关注合同签订和收款情况。同时，尽量邀请公司高层领导参加启动会，以提高项目的重视程度。
关注核心成员资源投入情况：确保核心成员按时提供所需资源。
明确甲乙双方主要角色和职责：明确各方的主要角色和职责，并对干系人进行适当的分级。
明确甲乙双方主要角色对接关系：确保每个角色都有专人负责，并明确后备人员和授权机制。
建立持续沟通机制：明确沟通的方式和频率，在影响项目的重要事件发生前及时与客户进行沟通并上报。
记录和审核沟通过程：用邮件或项目管理工具记录和审核所有正式的沟通过程，以便追溯和备案。
及时同步变更信息：如项目组成员的职责或投入比例发生变化，确保第一时间同步双方。
解决问题和升级管理：对于无法解决或达不成共识的问题，及时向上级进行升级汇报。
不允许私下接需求和评估工作量：所有需求和工作量评估必须经过正式的渠道进行，不允许私下进行。
不允许私下承诺交付时间：任何交付时间的承诺必须经过项目经理或相关负责人的确认和协调。
不允许角色职能边界外的沟通：在项目中，不允许超出各自角色职责范围的私下沟通。
以上是项目准备工作的一般流程和注意事项，遵循这些步骤可以提升项目的管理效率和成功实施的可能性。
规划阶段
阶段目标的制定和项目管理计划的可执行性是我们在项目启动阶段的重要任务之一。在这个阶段，我们需要制定一个全面的管理计划，包括产研计划、风险识别和分析，以及与客户召开项目启动会等。下面是我们需要考虑的一些交付物管理计划：
变更管理流程：确保项目中的变更能够被有效管理和控制。
团队建设计划：制定团队建设策略，提供培训和发展机会，以建立一个高效的工作团队。
沟通管理计划：明确沟通渠道和频率，确保信息传递的有效性和及时性。
风险管理计划：识别项目可能面临的风险，并采取相应的措施进行预防和应对。
质量管理计划：确保项目交付物符合质量标准，制定相应的质量保证和控制策略。
会议管理机制：规划会议的目的、议程、参与人员和决策方式，以确保会议的高效和产出。
而在产研计划方面，我们需要制定以下计划：
需求调研计划：对项目需求进行深入调研和分析，以明确项目目标和要求。
设计、开发、测试计划：规划项目的设计、开发和测试阶段，确保按时交付高质量的产品。
培训计划：为相关人员制定培训计划，以提高他们的技能和能力。
上线计划：规划产品上线的时间和步骤，确保顺利进行并对用户进行有效的转型。
验收计划：制定验收标准和程序，确保项目能够被成功验收。
在召开项目启动会时，我们需要注意以下事项：
尽量邀请客户方高层领导参加启动会，以确保他们对项目的重视和支持。
充分沟通与客户方未达成一致的待定事项，以确保双方的理解和共识。
明确项目层面的激励办法，以保持团队的积极性和动力。
在任务拆分时，要遵循100%、穷尽和合理的原则，确保任务被合理分配和完成。
对于公共模块，要明确其与其他模块的交互关系，以避免遗漏和冲突。
对协作方进行评估时，切忌过于乐观，要尽可能细致地了解他们的能力和意愿。
为了保证项目的顺利进行，我们还需要建立文档管理机制，以沉淀项目中涉及的各类文档。同时，对于周期较长的项目，要考虑到人员流动的情况，及时提供新人快速上手的指引，并持续进行项目的迭代。在分工方面，我们应该充分发挥每个成员的长处，并尊重他们的意愿，给予选择空间。此外，培养高效会议的文化，并进行全员培训，以避免过多低效会议的发生。在项目前期，需要提前了解客户方的工作流程、规范等要求，以确保我们能够顺利配合。最后，在项目组团队成立后，应尽早进行团建活动，以促进成员之间的了解和合作。
实施阶段（执行&amp;监控）
为了确保阶段目标的完成并交付合同约定的产品或服务，需要按照以下步骤进行工作：
需求调研和分析：对项目需求进行深入了解，并进行需求评审报告。
方案详细设计和评审：制定详细的解决方案，并进行评审。
研发：根据设计方案进行开发工作。
测试：对开发完成的产品进行全面测试。
培训：根据产品特性和需求编写培训计划和课程，进行培训，并确保培训确认书的签署。
上线：制定上线方案，并进行上线申请和上线验证测试。
交付物准备：准备好需求规格说明书、功能列表、UX/UI设计稿、总体设计规格说明书、详细设计规格说明书、数据字典、测试用例、详细开发计划、代码、代码检查报告、单元测试报告、缺陷记录、测试报告、培训计划、用户使用手册、业务词典以及上线完成报告等文档。
注意事项：确保有统一的对接人与内外部进行沟通，掌握整体情况。管理客户的期望值，识别关键人员，并定期向双方高层汇报项目状态。监控项目风险并及时上报，进行评审和CodeReview，并明确提测标准。在客户验收前，进行内部验收，整理业务词典，进行培训。定期进行团队建设，活跃团队氛围，并邀请客户接口人参与。
使用项目管理工具进行有效管理，包括每日站会和周会。确定技术选型和基础设施，并按统一规范使用。进行项目组内外部交接，并进行形式化邮件通知和确认。进行上线前的准备工作，包括召开上线动员会和模拟演练。细化上线操作步骤，并编写文档，确保任务明确到每个责任人和操作时间，包括客户方，并预留问题解决的时间。上线方案中包含问题处理手册、脚本和回退预案。确保上线后具备监控能力和故障响应机制。在上线后，适当调整工作节奏，缓解团队疲劳和紧张状态。
收尾阶段
阶段目标的完成时间之后，需要协调客户进行初验，解决遗留问题并提供线上支持。一旦初验通过，项目可以进入终验阶段，并完成项目验收，同时协调干系人进行项目总结。初验阶段的主要任务是验证项目的可用性和性能。在线上支持阶段，我们的任务是解决任何遗留问题，确保项目的正常运行。终验阶段是项目的最后一步，我们将移交项目维护责任，并回收尾款。项目总结是为了总结项目经验并进行复盘会，以兑现激励，并评估绩效。最后，进行结项和财务结算，并解散项目组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4843d94c5afb91801ab67fb2c34008a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4713d54e095a592941240975d097ba7e/" rel="bookmark">
			四.存储引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储引擎 1.查看存储引擎2.设置系统默认的存储引擎3.设置表的存储引擎3.1创建表是指定存储引擎3.2修改表的存储引擎 4.引擎介绍4.1InnoDB 引擎：具备外键支持功能的事务存储引擎4.2MyISAM 引擎：主要的非事务处理存储引擎4.3Archive引擎：用于数据存档4.4Blackhole引擎：丢弃写操作，读操作会返回空内容4.5CSV引擎：存储数据时，以逗号分隔各项数据4.6Memory引擎：至于内存的表4.7Federated 引擎：访问远程表4.8Merge引擎：管理多个MyISAM表构成的表集合4.9 NDB引擎：MySQL集群专用存储引擎4.10引擎对比 5.MyISAM和InnoDB6.阿里巴巴、淘宝用哪个 为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API,获取到数据后返回给客户端就好了。
MySQL中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。
1.查看存储引擎 查看mysql提供的什么存储引擎 SHOW engines; 查询结果显示，MySQL8支持9种存储引擎，分别为MEMORY、MRG_MYISAM、CSV、FEDERATED、PERFORMANCE_SCHEMA、MyISAM、InnoDB、BLACKHOLE和ARCHIVE。
Engine参数表示存储引擎名称。Support参数表示MySQL数据库管理系统是否支持该存储引擎：YES表示支持，NO表示不支持。DEFAULT表示系统默认支持的存储引擎。Comment参数表示对存储引擎的评论。Transactions参数表示存储引擎是否支持事务：YES表示支持，NO表示不支持。XA参数表示存储引擎所支持的分布式是否符合XA规范：YES表示支持，NO表示不支持。代表着该存储引擎是否支持分布式事务。Savepoints参数表示存储引擎是否支持事务处理的保存点：YES表示支持，NO表示不支持。也就是说，该存储引擎是否支持部分事务回滚。 show engines \G; 显示如下：
mysql&gt; show engines \G *************************** 1. row *************************** Engine: InnoDB Support: DEFAULT Comment: Supports transactions, row-level locking, and foreign keys Transactions: YES XA: YES Savepoints: YES *************************** 2. row *************************** Engine: MRG_MYISAM Support: YES Comment: Collection of identical MyISAM tables Transactions: NO XA: NO Savepoints: NO *************************** 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4713d54e095a592941240975d097ba7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b54f112695fe064a6208b6690479957/" rel="bookmark">
			在线制作gif动图怎么做？一个方法轻松制作gif动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候一张普通的图片无法表达出我们的意思，但是视频又比较长看起来太过复杂。这时候，大家就可以使用gif动图了，不需要下载软件使用gif生成器（https://www.gif.cn/）-GIF中文网，轻松一键就能快速完成gif在线制作的操作，支持原画质导出手机、pc均可操作。一起来看看具体的操作步骤吧！
打开GIF中文网，点击“gif合成”上传jpg、png格式图片。
设置生成gif的尺寸、速度等参数，点击“开始生成”。
完成后，点击下载图片。
图片制作gif动图表情包的操作就完成了，是不是很简单呢？并且，GIF中文网还支持视频转gif、gif压缩、gif分解、gif加字等功能，希望以上内容能够帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa7beea5a6287cef8638fe5ad978a26/" rel="bookmark">
			线程&amp;锁&amp;多线程的复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程 实现方式3种乐观锁&amp;悲观锁线程池线程池总结 进程:是正在运行的程序
线程:是进程中的单个顺序控制流,是一条执行路径
实现方式3种 1.Thread
//步骤一:定义一个继承Thread的类 //步骤二:再定义的类中重写run()方法 //步骤三:创建定义类对象 //步骤四:启动线程 class MyThread extends Thread{ @Override public void run(){ System.out.println("线程执行了"); } } public static void main(String[] args){ MyThread my1= new MyThread(); my1.start(); } 2.Runnable
//步骤一:定义一个实现Runnable接口 //步骤二:再定义的类中重写run()方法 //步骤三:创建定义类对象 //步骤四:创建Thread类对象,把定义的对象作为构造方法的参数 //步骤五:启动线程 class MyRunnable implements Runnable{ @Override public void run(){ System.out.println("线程执行了"); } } public static void main(String[] args){ MyRunnable my1= new MyRunnable(); //Thread thread= new Thread(my1); Thread thread= new Thread(my1,"第一个线程"); thread.start(); } 3.Callable
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa7beea5a6287cef8638fe5ad978a26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cf776a465d3b8eb8258fc9d29834c0/" rel="bookmark">
			idea控制台出现乱码的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：有时候控制台的关键说明出现乱码，就很令人烦恼
在 IntelliJ IDEA 中出现控制台乱码通常是由于编码设置不正确或者字体显示问题导致的。以下是一些可能的解决方案：
1. 设置项目编码 确保你的项目编码设置正确：
在 IntelliJ IDEA 中，点击顶部菜单中的 "File" -&gt; "Settings"（或者使用快捷键 Ctrl + Alt + S）。在弹出的窗口中，选择 "Editor" -&gt; "File Encodings"。确保 "Global Encoding"、"Project Encoding" 和 "Default encoding for properties files" 都设置为合适的编码，一般推荐使用 UTF-8。勾选 "Transparent native-to-ascii conversion" 以确保正确的显示非 ASCII 字符。 2. 设置控制台编码 在 IntelliJ IDEA 中，点击顶部菜单中的 "File" -&gt; "Settings"。选择 "Editor" -&gt; "Color Scheme"。在右侧的窗格中，找到 "Console Font" 和 "Console Colors" 部分，确保字体和颜色设置正确。尤其是在 "Console Font" 中，选择一个支持你需要显示字符的字体。 3. 修改启动配置 如果是在运行程序时出现乱码，可以尝试修改运行配置：
在 IntelliJ IDEA 中，找到你的运行配置（通常位于顶部工具栏旁边的下拉菜单中）。右键点击运行配置，选择 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00cf776a465d3b8eb8258fc9d29834c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7277dffda8ac8ff1a9a93f630912ec3/" rel="bookmark">
			elementui中的tree自定义图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：实现如下样式的树形列表
自定义树的图标以及点击时，可以根据子级的关闭，切换图标
&lt;el-tree :data="treeList" :props="defaultProps"&gt; &lt;template #default="{ node, data }"&gt; &lt;span class="custom-tree-node"&gt; &lt;img v-if="!node.expanded " class="node-img" :src="./aaa.svg" /&gt; &lt;img v-if="node.expanded" class="node-img" :src="./bbb.svg" /&gt; &lt;span&gt;{{ node.label }}&lt;/span&gt; &lt;/span&gt; &lt;/template&gt; &lt;/el-tree&gt; 参考：element-ui的el-tree自定义图标 - 简书
https://download.csdn.net/blog/column/12320696/130819498
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc9d154c9aca1846137a1f9274b93c61/" rel="bookmark">
			在Ubuntu Linux上安装Chrome浏览器的最佳方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以使用GUI和命令行方法在Ubuntu Linux上安装Google Chrome浏览器，但是，终端是配置Chrome浏览器的最佳方式。在这里，我们讨论如何使用它。 有数十种浏览器，甚至Linux系统如Ubuntu也带有自己的默认浏览器Mozilla Firefox。然而，许多人要么不满意它，要么只想安装他们喜欢的浏览器，如Chrome。在Linux上安装应用程序并不是一件困难的事情，但是，最好的方法是什么呢？
当然是终端，因为只需几个命令就可以获取你的应用程序，包括Chrome。它是一款跨平台浏览器，也可用于Debian二进制格式。
因此，在本教程中，我们不会涵盖多种在Ubuntu Linux上安装和管理Google Chrome的方法，而是介绍最佳方法。
1. 运行终端应用程序 在你的Ubuntu Linux上，无论你使用的是22.04、20.4、23.04还是其他版本，你都可以按Ctrl+Alt+T快速打开终端应用程序。
2. 更新并安装Wget 当你在终端应用程序上时，让我们首先运行系统更新命令，为系统安装最新可用的软件包。
sudo apt update -y 此外，还要安装我们在下一步中需要的wget工具。
sudo apt install wget -y 3. 下载Google Chrome Deb文件 接下来，我们需要Debian软件包，该软件包旨在在基于Debian的Linux上安装Google Chrome，包括Ubuntu。好吧，为此我们可以使用浏览器，但是为什么要走一个那么长的路呢？当我们可以使用单个命令来完成这个任务。
wget "https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" -O google.deb 很快，名为“google.deb”的文件将保存在你的系统上。移动到下一步进行安装。
4. 在Ubuntu Linux上安装Chrome浏览器 为什么我说使用Chrome的Debian二进制文件是在Ubuntu上安装它的最佳方法，因为我们不需要手动添加它的存储库。运行浏览器的Deb文件还会为我们配置仓库，以便我们可以通过运行系统更新命令轻松获取未来的更新。
sudo dpkg -i google.deb 5. 开始使用浏览器 这就是了，你已经看到了使用终端安装Chrome是多么简单。因此，现在是时候访问浏览器，开始浏览我们喜欢的网站了。要运行浏览器，我们可以使用命令终端或GUI界面。
如果你想使用CLI，则执行：
google-chrome
而其他用户可以单击Activities，搜索Chrome，当其图标出现时，单击运行此应用程序。
6. 更新 虽然浏览器会在最新版本可用时通知你，但是定期运行系统更新命令就足够了。因为除了其他软件包之外，它还将升级浏览器到最新可用版本。
sudo apt update &amp;&amp; sudo apt upgrade -y
7. 结论 在本教程中，我们学习了在Ubuntu Linux上安装Google Chrome的最佳方法。使用终端方法，我们可以轻松安装最新版本的Chrome浏览器，而不会有任何麻烦。此外，它还允许我们为将来的更新自动配置存储库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48965e6639167a128ef94b946e048c43/" rel="bookmark">
			机器学习：多项式回归（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多元线性回归闭式解：
closed_form_sol.py
import numpy as np import matplotlib.pyplot as plt class LRClosedFormSol: def __init__(self, fit_intercept=True, normalize=True): """ :param fit_intercept: 是否训练bias :param normalize: 是否标准化数据 """ self.theta = None # 训练权重系数 self.fit_intercept = fit_intercept # 线性模型的常数项。也即偏置bias，模型中的theta0 self.normalize = normalize # 是否标准化数据 if normalize: self.feature_mean, self.feature_std = None, None # 特征的均值，标准方差 self.mse = np.infty # 训练样本的均方误差 self.r2, self.r2_adj = 0.0, 0.0 # 判定系数和修正判定系数 self.n_samples, self.n_features = 0, 0 # 样本量和特征数 def fit(self, x_train, y_train): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48965e6639167a128ef94b946e048c43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa445e447ae7c74ed2080d9ac58536b/" rel="bookmark">
			Qt SQLite3数据库加密 QtCipherSqlitePlugin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在客户端软件开发过程中，基本都会涉及到数据库的开发。QT支持的数据库也有好几种（QSQLITE, QODBC, QODBC3, QPSQL, QPSQL7），SQLite就是其中之一，但这个 SQLite 是官方提供的开源版本，没有加密功能的。如果对于数据保密性有要求的，那么就要考虑对数据库或者数据本身进行加密了。最好的选择或许是对数据库本身进行加密（既不会暴露表结构，也不会暴露数据细节），那么如何对sqlite3数据库进行加密？本文将逐一进行剖析。
一、下载插件 https://github.com/devbean/QtCipherSqlitePlugin
https://gitee.com/mirrors/QtCipherSqlitePlugin
二、QtCipherSqlitePlugin的编译 QtCipherSqlitePlugin工程包含三个项目：demo、sqlitecipher、test_plugin。其中sqlitecipher是插件，另外两个都是示例程序。使用qtcreator打开QtCipherSqlitePlugin.pro文件，再选择项目的编译器，在debug模式下编译。编译完成后的dll文件位于：sqlitecipher\plugins\sqldrivers\sqlitecipher.dll
三、QtCipherSqlitePlugin的使用 找到sqlitecipher/plugins/sqldrivers/sqlitecipher.dll文件，将其拷贝到qt目录下 C:\Qt\5.14.2\mingw73_64\plugins\sqldrivers。检查插件是否成功加载
qDebug() &lt;&lt; QSqlDatabase::drivers();如果输出的内容包含SQLITECIPHER，则表示已被成功加载。例如我输出的是：“QSQLITE”, “QODBC”, “QODBC3”, “QPSQL”, “QPSQL7”, “SQLITECIPHER”支持的加密方式：aes128cbc、aes256cbc、chacha20、sqlcipher、rc4 四、示例代码 int main(int argc, char *argv[]) { QCoreApplication app(argc, argv); Q_UNUSED(app) qDebug() &lt;&lt; QSqlDatabase::drivers(); Q_ASSERT(QSqlDatabase::isDriverAvailable("QSQLITE")); // from Qt Q_ASSERT(QSqlDatabase::isDriverAvailable("SQLITECIPHER")); // from our plugin // QSqlDatabase conn = QSqlDatabase::addDatabase("SQLITECIPHER"); conn.setDatabaseName("test.db"); #if 0//将原本没有加密的数据库文件进行加密(只需要执行一次) conn.setPassword("test"); QString options = "QSQLITE_USE_CIPHER=sqlcipher; SQLCIPHER_LEGACY=1; SQLCIPHER_LEGACY_PAGE_SIZE=4096; QSQLITE_CREATE_KEY"; conn.setConnectOptions(options); bool ok = conn.open(); qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa445e447ae7c74ed2080d9ac58536b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ef5c9d1bd711339b835968cf411a43/" rel="bookmark">
			springboot热部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot热部署 为了进一步提高开发效率,springboot为我们提供了全局项目热部署,日后在开发过程中修改了部分代码以及相关配置文件后,不需要每次重启使修改生效,在项目中开启了springboot全局热部署之后只需要在修改之后等待几秒即可使修改生效。
引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 设置idea配置自动编译 开启允许在运行过程中修改文件 这里修改的操作是2021 版本的idea的操作。
在任意java文件中按下 ctrl + alt + shift + / ----&gt;选择1.Registry —&gt; 勾选 compiler.automake.allow.when.app.running 这个选项
另外2023年版本的idea，操作如下：
鼠标右键：File --&gt; Settings --&gt; Advanced Settings --&gt; 勾选 Allow auto-make to start even…
启动项目验证 解释原理 当开发人员修改了应用程序的代码或配置文件后，Spring Boot DevTools 会检测到这些修改。
Spring Boot DevTools 会重新编译应用程序的代码，并将编译后的代码部署到应用程序的运行环境中。
应用程序会自动重新加载修改后的代码或配置文件。
我们这里做的只是自动编译和部署： IDEA 默认支持自动编译和部署功能。当你修改了代码后，IDEA 会自动编译修改的文件，并将其部署到运行中的应用程序中。确保在项目设置中启用了自动编译功能。算不上真正的热部署。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e65277adfa330255134e2ea8079fa2f7/" rel="bookmark">
			Spring Cloud &#43; Vue前后端分离-第15章 课程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 源代码在GitHub - 629y/course: Spring Cloud + Vue前后端分离-在线课程
Spring Cloud + Vue前后端分离-第15章 课程总结 重点难点梳理 环境的搭建 代码生成器 文件上传和视频播放 通用权限设计 学习技巧 养成做笔记的习惯 养成阶段性提交代码的习惯 问答区多交流 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845f12268aafd79af6d078c1607fd99e/" rel="bookmark">
			Ubuntu22.04 网络图标突然消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本来
好好的，突然就发现没有网络了，图标也不见了。
修复办法 1. sudo service network-manager stop 2. sudo rm /var/lib/NetworkManager/NetworkManager.state 3. sudo service network-manager start 到这基本应该就恢复了，如果还不行往后继续
4. sudo gedit /etc/NetworkManager/NetworkManager.conf（把false改成true） 5. sudo service network-manager restart 6. reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79ce6b003da6dad4ac3a6def1c8494f9/" rel="bookmark">
			Java 集合 01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集合简要介绍： 集合的容量是可以变的
可以将基本数据类型变为包装类存入集合中；
ArrayList： ：的尖括号代表泛型（限定集合中存储数据的类型），在类名后面写数据类型
例如：Arraylist 后面的&lt;&gt;写int会报错，只能写引用数据类型，可以写String
错误的：
正确的：
在jdk7以前是以上的那种写法，下面是jdk7以后的写法，可以在&lt;&gt;里面不写类型
运行一下：
结果：
如果[ ]里面什么也没有，那么就说明该集合为空；
ArrayList的成员方法：（增删改查） 添加代码演示：
import java.util.ArrayList; public class practice{ public static void main(String[ ] args){ //创建一个集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //添加元素 boolean result = list.add("aaa"); System.out.println(list); System.out.println(result); } } 代码结果：返回值是boolean类型的，代表是否添加成功，不管添加什么，都返回为true。
删除代码演示：（两种删除方法）
import java.util.ArrayList; public class practice{ public static void main(String[ ] args){ //创建一个集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //添加元素 list.add("aaa"); list.add("bbb"); list.add("ccc"); list.add("ddd"); System.out.println(list); //删除元素 boolean result = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79ce6b003da6dad4ac3a6def1c8494f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90fede07a4b32656ef999c4551be10f/" rel="bookmark">
			IDEA开发使用 thymeleaf 模板$表达式报红波浪线解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录后端存值前端取值thymeleaf 后端存值 @RequestMapping("/testModelAndView") //使用ModelAndView时返回的方法类型必须是ModelAndView public ModelAndView testModelAndView() { //创建ModelAndView对象 ModelAndView mav = new ModelAndView(); //使用ModelAndView共享数据，ModelAndView有两个作用 //Model处理模型数据：向request作用域中共享数据，将底层获取的数据进行存储（或者封装） //最后将数据传递给View mav.addObject("ModelAndView", "hello,ModelAndView"); //View视图设置视图名称:设置转向地址 mav.setViewName("succeed"); return mav; } 前端取值thymeleaf 通过thymeleaf 进行前端取值的情况下$表达式报红波浪线报错无法正常进行取值。
解决方法如下：
settings中找到thymeleaf取消下列选项进行保存即可解决！
解决后：
显示正常取值正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc0a3df3f738fb6ba68c24ea47122f3/" rel="bookmark">
			ubuntu 安装python3.10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
How to Install Python 3.10 on Ubuntu 22.04 or 20.04 - LinuxCapable
方法二：
Ubuntu python3.10 安装教程，并更新python，pip默认指向为python3.10, pip3（超详细教程）_apt-get install python-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/201a9439c3b734e8f872520f26b967ac/" rel="bookmark">
			C# 图片或PDF保存到SQL Server数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 图片或PDF保存到SQL Server数据库 数据库字段如下：图片保存要用image数据类型 保存到数据库的两种方式： // 打开文件，获取图片路径 OpenFileDialog openFileDialog = new OpenFileDialog(); if (openFileDialog.ShowDialog() == DialogResult.Cancel) { return; } //pictureBox1.Image = Image.FromFile(openFileDialog.FileName); FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read); //通过BinaryReader类对象的ReadBytes()方法将FileStream类对象转化为二进制数组 BinaryReader br = new BinaryReader(fs); byte[] img = br.ReadBytes(Convert.ToInt32(fs.Length)); // 方法一：通过参数的形式直接用Sql语句保存 string insert = "insert into T_Img(ID,Img) values(@ID,@Img)"; SqlParameter[] parameter = new SqlParameter[] { new SqlParameter("@ID", Convert.ToInt32(textBox1.Text)), new SqlParameter("@Img", img) }; db.ExcuteBySqlParmeter(insert, parameter); // 方法二：使用SqlBulkCopy string sql = "select top 0 * from T_Img"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/201a9439c3b734e8f872520f26b967ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2fc77ce60c883c4391f0a23b050517/" rel="bookmark">
			FPGA硬件架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Xilinx FPGA是异构计算平台（所谓异构，就是有很多不同的部分组成）：CLB,BRAM,DSP
2.
软核：
把经过功能验证的、可综合的、实现后电路结构总门数在五千门以上的Verilog HDL模型称为软核(soft core)。
硬核:
把在某一种专用集成电路工艺的(ASIC)器件上实现的、经过检验证明是正确的、总门数在五千门以上的电路结构版图称为硬核。
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/321</span>
	<a class="pagination__item pagination__item--next btn" href="/page/2/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>